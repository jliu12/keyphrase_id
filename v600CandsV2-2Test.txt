corpus/krapavin2000-test/628753.txt
symmetry
mirror
centroid
shape
symmetries
symmetric
folding
occluded
reflection
shapes
cn
contour
3d
sd
plane
folded
center
focals
2d
image
interlaced
measurements
quad
angular
transform
probable
rotational
chirality
orientation
axis
radians
distance
reconstruction
images
closest
fp
angles
fig
symmetrical
selection
smoothing
quadrant
configuration
marked
flowers
jerusalem
multiresolution
rotated
grey
origin
hel
sensed
averaging
regions
rotation
quadrants
skewed
smoothed
orbit
continuous
focal
cos
recognition
neighborhood
locations
visual
sin
arm
perfectly
vision
detection
dn
orbits
locally
averaged
unfolding
minimization
axes
grasping
unfold
frontal
circular
marola
symme
tuzikov
busyness
gilat
pled
chiral
symmetropy
seperately
avnir
planes
reflective
resolution
obtaining
appendix
sampled
derivations
location
phi
deviation
digitization
laue
crystals
attentive
hebrew
unoccluded
squared
polygon
uncertain
tog
radial
object
patch
handed
reflecting
dark
distances
geometric
projected
planar
noisy
szymon
funkhouser
guiding
perpendicular
objects
analytic
perceived
rotating
shortening
elevation
photograph
evaluating
mass
rusinkiewicz
iii
measurement
farthest
groups
pattern
rectangles
probability
intelligence
graphics
faces
robust
sampling
variance
unfolded
kun
divisions
guess
measuring
recomputed
gamman
feature
coefficient
finding
uncertainty
multipliers
israel
onto
group
yang
contours
expanded
sam
lagrange
reconstructing
criterion
occlusion
vi
division
inverted
normalization
perception
derivation
guibas
niloy
metries
normalizefig
colliot
lytical
breckon
organic
densityfig
zavidovique
terefrence
yossi
symmetry distance
mirror symmetry
symmetry transform
symmetric shape
reflection plane
symmetry group
cn symmetry
folding method
locally symmetric
symmetric regions
occluded shape
angular selection
equal angles
symmetry value
closest symmetric
quad tree
distance value
probability distribution
cn symmetric
symmetry focals
symmetric configuration
continuous symmetry
symmetry axis
3d object
n points
probable symmetric
continuous feature
shape p
using angular
distance values
original shape
symmetry detection
points fp
dn symmetry
3d mirror
mirror axis
mirror symmetric
symmetry map
g symmetry
shape using
symmetry groups
order n
original image
measured points
d fig
section iii
symmetric shapes
points selected
q sets
symmetry c
symmetry focal
equal distances
symmetry d
occluded shapes
folded points
perfectly symmetric
n radians
distance sd
multiresolution scheme
expected location
b c
c d
rotational symmetry
resolution image
low resolution
point symmetry
c 3
symmetric 3d
sd values
single shape
average point
given shape
shape represented
finding locally
almost symmetric
measuring symmetry
circular symmetry
mirror symmetries
rotational symmetries
2d polygon
face orientation
averaged point
continuous contour
angular intervals
sensed points
values denote
obtaining f
finite symmetry
occluded flowers
symmetric region
minimum symmetry
frontal vertical
symmetry measure
sampled points
possible reflection
local symmetries
vertical view
image quadrant
figure 21a
symmetry measures
folded measurements
symmetry content
different symmetries
value obtained
center of symmetry
symmetry distance value
locally symmetric regions
symmetry distance values
symmetry of order
distribution of symmetry
using angular selection
selection at equal
center of selection
c 3 symmetry
shape using angular
3d mirror symmetry
points are selected
c d fig
along the contour
evaluating the symmetry
closest symmetric shape
symmetry group g
original image b
mirror symmetry transform
selected at equal
amount of symmetry
symmetric shape using
symmetry distance sd
b c d
sets of n
configuration of points
regions in images
r t g
set of measurements
b c fig
shapes and objects
frontal vertical view
noting that r
points i 0
amount of different
symmetry of different
orientation of symmetric
obtaining a single
c the closest
probable symmetric shape
mirror symmetry axis
d e fig
g symmetry group
symmetry transform 1
algorithm for deriving
define the symmetry
finite symmetry group
cn symmetric configuration
marked by phi
finding locally symmetric
deriving the symmetry
low resolution image
maximum likelihood criterion
set of points
point symmetry group
center of mass
g n gamma1
multiple of n
fp i g
method as described
types of symmetries
described in section

corpus/krapavin2000-test/1039958.txt
irreducible
witness
homotopy
homotopies
cascade
deg
algebraic
continuation
isolated
multiplicity
polynomials
varieties
numerical
intersection
hypersurface
dimension
diagonal
polynomial
decomposition
ne
nonsingular
supersets
equations
dim
solutions
zariski
sommese
phcpack
verschelde
numerically
leg
tracking
paths
randomization
pure
notre
dame
intersecting
milliseconds
curve
legs
subspace
ln
cpu
dimensional
cylinder
sphere
smooth
embedding
gough
wenyuan
en
union
eq
generic
dn
platform
membership
jan
uic
wampler
abuse
lm
intersected
identically
seventh
superset
reid
tracker
restrictions
email
triangle
article
geometry
edu
red
cient
di
stewart
generically
coordinates
decompose
projective
greg
slack
erent
remark
intersect
vanish
singular
zeroes
math
decomposes
component
fb
chicago
url
euclidean
hypersurfaces
erentiable
ornl
bertini
unramified
mound
wittkopf
surjects
pretending
oberwolfach
monodromy
numerics
randomizations
husty
offshoot
gri
ometry
stiftung
algebra
generalization
trace
slice
item
charles
contained
xw
postures
gov
volkswagen
blackbox
codify
karger
duplications
intertwine
genoa
adjunction
material
stages
plane
symbolic
wu
z
fa
solver
rip
kinematic
equilateral
adjoined
diverged
letting
wish
realize
abstract
restricted
nonempty
duncan
chair
motors
equates
pullback
constructing
defining
lemma
dense
thrust
gm
monomial
pde
app
xz
perturbing
papers
identified
nonzero
limits
submatrices
appendices
beijing
degree
emphasize
mixed
naively
constructible
diverge
warren
assembling
algebraic set
irreducible decomposition
irreducible components
witness set
irreducible component
isolated solutions
c n
witness points
c m
polynomial systems
witness sets
system f
solution set
solution components
diagonal homotopy
ne algebraic
deg x
numerical irreducible
v f
polynomial system
x c
polynomial equations
f x
numerical continuation
u v
pure n
homotopy continuation
dimensional algebraic
solutions f
z 1
set x
algebraic geometry
witness point
numerical algebraic
n polynomials
algebraic subset
probability one
dimension n
cpu time
linear subspace
solution sets
n dimensional
v r
embedding theorem
r f
zariski open
abstract embedding
w red
positive dimensional
seventh leg
dimensional components
jan verschelde
equations restricted
multiplicity one
algebraic sets
paths defined
generic points
c dim
milliseconds cpu
general linear
z b
f 1
two components
total degree
dim x
membership tests
general n
user cpu
dimensional system
lm n
deg b
notre dame
component z
x z
v b
identically zero
d 1
r 1
x k
number d
b r
n k
f b
y y
finite set
choosing linear
seconds user
papers 12
compute witness
two polynomial
start solutions
numerically represented
nonsingular isolated
z i j
numerical irreducible decomposition
ne algebraic set
polynomials on c
dimensional a ne
f 1 0
algebraic set x
x c n
system of polynomials
r f x
r 1 u
e i f
system of polynomial
x c m
pure n dimensional
system f x
f x k
dimensional algebraic set
v r f
start the cascade
solutions of f
intersection of components
set x c
polynomial system f
f x y
b a 1
u v b
z 1 b
components of v
b r 1
component of v
find the intersection
abstract embedding theorem
cascade of homotopies
numerical algebraic geometry
dim x 1
polynomial on c
system of restrictions
systems by homotopy
sets of polynomial
c dim x
n i dimensional
user cpu time
irreducible component z
theorem 5 1
number of paths
intersection of two
system of n
x v f
curve of degree
lemma a 1
d 1 dn
component of x
number of variables
system of equations
f on x
restricted to u
distinct irreducible components
pure dimensional algebraic
f of solutions
find the irreducible
dimension n irreducible
continuation to compute
y are contained
restrictions of polynomials
follows by considering
irreducible of dimension
identically zero equations
whose irreducible components
algebraic curve b
stewart gough platform

corpus/krapavin2000-test/635802.txt
el
msc
ale
abox
lcs
homomorphism
descriptions
concept
aboxes
dls
existential
homomorphisms
ind
nr
msca
nc
subsumers
completions
characterization
dl
subsumption
specic
nite
atomic
individuals
approximations
sublanguages
eectively
depth
restrictions
jaj
cyclic
trees
names
dened
subsumer
conp
successor
relationships
concepts
completion
approximation
denition
exponential
constructors
inconsistent
sound
aln
rst
assertions
classic
grow
translated
occurring
cn
xed
tree
exponentially
negation
yields
unraveling
tk
icting
labeled
depicted
root
label
logics
innite
role
engineers
name
subsumed
ut
conjunction
engineer
double
reached
characterizations
semantics
greatest
turned
rg
graphs
notions
corollary
cycle
pletions
rosy
unraveled
alen
subsump
vrw
lufg
approximating
characterizing
encounters
generalizes
decided
intractability
structuring
roots
imations
rwth
approxi
inconsis
theoretische
suce
lifecycle
obviously
translating
individual
cope
additionally
bases
pruning
quanti
straightfor
subsuming
vh
tent
aachen
inductively
con
existence
logic
structural
cf
denitions
analogously
rome
trim
nave
mations
informatik
interpreted
conceptual
bottom
ship
sublanguage
prototypical
gc
cept
signa
incompleteness
jcj
ward
ict
sketch
blow
fpg
acyclic
onto
building
gg
construc
diculties
equivalence
fx
subsume
rene
suggestion
subtasks
questionable
innitely
race
foundations
quantiers
vn
chemical
restriction
negated
thoroughly
disjoint
descriptive
roughly
conjunctive
pg
revision
approx
dene
enumerating
speak
yield
allowing
usable
ture
containment
concept description
concept descriptions
el description
description graph
el concept
k approximation
description tree
el abox
instance relationships
g c
k approximations
description trees
existential restrictions
msc k
specic concepts
concept names
w r
atomic completion
atomic completions
least common
description c
ale description
l concept
depth c
common subsumers
algorithm computing
c k
descriptions c
least concept
description logic
ale concept
instance problem
always exists
c 0
v 0
c t4
individual b
concept name
ale abox
el aboxes
msc exists
value restrictions
role names
el el
graph g
grow exponentially
process engineering
r r
depth k
computing k
double exponential
number restrictions
jaj k
l abox
role name
common subsumer
description graphs
characterizing instance
engineering application
dls allowing
top concept
description w
corresponding description
concept msc
cyclic concept
dl systems
nc nr
existential restriction
u 9r
may grow
theorem 1
p u
knowledge base
description logics
root v
el description graph
homomorphism from g
el concept description
characterization of instance
exists a homomorphism
el description tree
k a g
description graph g
c into g
eectively be computed
el concept descriptions
el description trees
least common subsumers
concept description c
abox a 2
characterization of subsumption
least concept description
computing the msc
el and el
r 2 nr
concept descriptions c
problem for el
relationships in el
msc in el
r r r
bottom up construction
root of g
sound and complete
least common subsumer
xed and nite
l concept description
description w r
tree of c
computing k approximations
p 2 nc
cyclic concept descriptions
l concept descriptions
process engineering application
ale description graph
g c k
concepts in el
may grow exponentially
depth c 0
exist an el
p u 9r
computed in double
ale concept descriptions
el to el
concept description w
computing the k
g c 0
nc and nr
completions of g
el to ale
easy to see
double exponential time
decided in polynomial

corpus/krapavin2000-test/630534.txt
featuremine
mining
winnow
pruning
fire
features
wwwwww
frequent
spelling
training
feature
classification
ignite
eid
idlist
bulldozer
maxw
raises
classifiers
freq
sequences
parity
idlists
betting
classifier
distinctive
bb
bayes
bet
subsequence
word
mine
plan
irrelevant
sequential
suffix
bets
ab
tag
subsequences
digat
spade
naive
prune
pos
mined
accuracy
covers
label
bc
domains
frequency
redundant
vs
terrain
millions
boolean
dataset
folds
weights
bulldozers
truei
burned
moveto
politics
subsumes
chess
selecting
correction
traces
meta
dna
correlated
subsumed
corpus
eids
hcmac
poker
mines
brown
ith
criteria
additionally
datasets
monitoring
million
conf
integrates
item
chih
learning
produced
vegetation
weigh
www
heuristic
games
predictive
plans
patterns
web
min
items
classify
observable
hf
attributes
trained
confidence
exponentially
primitives
parent
cell
phoenix
nm
scalable
thousands
moves
bd
personalized
someone
efficiently
database
partition
rare
events
forest
lattice
rules
selection
association
water
wins
predicting
discover
categorical
simulation
ci
win
success
iff
novices
xrules
bayesfm
ignites
xiaonan
dig
ferr
falsei
winnowfm
dug
igniting
arificial
unburnable
featurem
garbay
yih
merl
shiou
winnowtf
burning
rialle
bayestf
winnows
duchne
dichotomic
bez
ria
guozhu
classification algorithms
features produced
feature set
frequent sequences
wwwwww wwwwww
feature value
class c
feature f
pruning rules
training examples
data mining
value pairs
naive bayes
feature mining
d bb
featuremine algorithm
bb d
min freq
pruning rule
classification accuracy
boolean features
fire world
sequential domains
f 1
d d
standard classification
spelling correction
mining techniques
selecting features
execution traces
ith bet
b pruning
www www
mined features
sequence mining
non sequential
class label
exponentially large
decision lists
max l
sequence data
target word
test examples
mining algorithm
potential features
meta features
betting sequences
features features
sequence lattice
sequential features
parent partition
observable features
raises twice
improve classification
bets 3
parity problems
ignite x3
examples d
example features
raises 2
feature sets
time time
training data
new examples
feature subset
boolean feature
possible features
frequent sequence
brown corpus
redundant features
sensitive spelling
classification performance
irrelevant features
label c
c j
mining algorithms
feature selection
f 2
sequential data
large space
class labels
cpu seconds
p 1
training set
selection criteria
context sensitive
ones played
pos 2
non distinctive
specified min
irrelevant boolean
efficiently search
length sequences
integrates pruning
sequence classifier
produced by featuremine
feature value pairs
wwwwww wwwwww wwwwww
d bb d
p 1 raises
bb d d
data mining techniques
number of features
class c j
examples in d
f 1 covers
d d bb
standard classification algorithms
criteria for selecting
d d d
f 2 covers
www www www
sequences as features
used a min
context sensitive spelling
sensitive spelling correction
data mining algorithms
set of examples
web usage data
evidence for different
scalable and disk
based on length
simulation the fire
min freq maxw
intersecting the idlists
maxw and max
feature set f
f 1 subsumes
feature is true
plan execution traces
eids f1 2
features of length
algorithm itself instead
primitives for describing
reduce classification accuracy
pruning rule described
examples that f
two pruning rules
classify new examples
n a 94
different min freq
vector of feature
post processing step
features to feed
c than f
classification algorithms furthermore
n a 86
first pruning rule
frequent and distinctive
frequent for class
scalable feature mining
large feature sets
digat bd2 x7
respect to class
seconds cpu seconds
d and parameters
use data mining
belonging to class
someone bets 3
ab bd bc
irrelevant or redundant
user specified min
trained the classifier

corpus/krapavin2000-test/1038204.txt
views
greedy
benefit
warehouse
indexes
ao
materialized
query
dag
monotonicity
quantity
interchange
arc
occupied
selection
sinks
oe
maintenance
cubes
queries
inner
absolute
graphs
units
wrapper
updates
achievable
olap
ig
stage
costs
binds
outgoing
vh
dags
heuristics
materialization
update
minimizes
viz
sales
ff
answering
occupies
occupying
cube
edges
interchanging
competitive
stages
constraint
index
fi
warehousing
ary
heuristic
frequency
select
monitor
subgraph
selected
ancestors
md
descendants
expression
incurred
optimizer
cover
edge
till
benefits
unit
quency
interatively
nonsink
rdb
cornuejols
algrorithm
multiobjective
harinarayan
semicircle
subgraphs
distributing
genetic
occupy
children
response
node
optimize
selecting
specifier
unanswered
integrator
fre
feige
automobiles
vms
contructing
incremental
generalize
label
deliver
manager
plan
om
materialize
subsection
facility
binding
gamma
cheapest
ic
arcs
disjoint
polynomial
depicts
behaves
roussopoulos
multiplying
aggregate
maintaining
advisor
approximability
warehouses
maintained
sources
acyclic
ka
competitiveness
powerset
ullman
merging
iff
produces
satisfies
thought
metadata
accessing
dimen
float
skipping
administrator
structures
encouragement
descendant
intersection
noteworthy
approximated
guarantee
subexpressions
jeff
halts
surely
bipartite
operator
exceeds
trading
contradiction
omit
ignore
prof
augmenting
ancestor
delivers
lawrence
bank
evolutionary
insightful
associate
simplied
sions
breakdown
spaces
looked
kn
lems
motivation
np
repository
incurs
sql
view graph
view selection
greedy algorithm
view graphs
query view
selection problem
benefit per
level greedy
unit space
absolute benefit
view v
benefit function
data warehouse
per unit
monotonicity property
inner level
update costs
graph g
without updates
optimal benefit
space occupied
greedy interchange
expression ao
achievable using
ao greedy
benefit achievable
interchange algorithm
views m
algorithm 3
materialized views
much space
solution m
ao dag
whose benefit
total query
data cubes
g l
selected views
space constraint
total space
function b
b satisfies
maximum benefit
outgoing edges
quantity g
maintenance cost
algorithm algorithm
v oe
c selected
query response
node u
b v
set cover
view maintenance
algorithm produces
already selected
space also
base relations
node view
arc binds
structures selected
greedy manner
incremental benefits
given quantity
views u
materialized view
total maintenance
view u
r level
v ff
time heuristics
performance guarantee
set o
cost associated
greedy heuristic
g m
problem given
least 1
query q
m assuming
computing u
multiple query
arbitrary sets
intersection graph
see algorithm
e times
graph without
data cube
minimum set
g without
running time
set of views
view selection problem
view graph g
per unit space
benefit per unit
level greedy algorithm
units of space
query view graph
inner level greedy
benefit of m
greedy interchange algorithm
graph with indexes
benefit achievable using
used by m
optimal benefit achievable
using as much
selection of views
ao greedy algorithm
total space occupied
m that uses
greedy algorithm algorithm
expression ao dag
satisfies the monotonicity
algorithm algorithm 3
benefit function b
algorithm 3 3
select a set
greedy algorithm produces
also the absolute
expression a dag
maximum benefit per
function b satisfies
total query response
produces a solution
m with respect
gamma 1 e
respect to m
query response time
updates the benefit
minimizes the quantity
benefit of c
whose benefit per
set of structures
quantity g m
m that minimizes
o g l
query view graphs
algorithm 3 1
satisfy the monotonicity
times the optimal
set c selected
space with respect
set of queries
least 1 gamma
b v m
o i consists
minimum set cover
given a quantity
cost function associated
see algorithm 3
g without updates
respect to arbitrary
algorithm given g

corpus/krapavin2000-test/627540.txt
stale
propagator
restart
bdb
recovery
transaction
pages
page
committed
fresh
logging
checkpointing
mmdbs
records
marking
backup
database
crash
pdb
flushing
dirty
redo
log
backups
incremental
buffer
undo
updates
manager
logger
flush
resident
checkpoint
loser
accumulator
ru
stable
flushed
fetch
steal
flushes
date
mmdb
locking
activities
driven
secondary
concurrency
aries
disk
mhl
recovered
commit
locks
activity
lsn
redone
volatile
image
dko
atomicity
safe
memories
brought
winner
memory
rs
lock
tail
persistence
lush
redoing
recs
paging
rus
decoupling
management
propagation
uncommitted
resumed
storage
ffl
underlie
undone
clean
granularity
record
fetched
triggers
post
checkpoints
raid
commitment
databases
status
quiescent
propagating
policy
transactions
pipeline
restoration
issuing
aborted
aborts
transitions
keeping
undoing
fuzzy
delayed
suffix
updating
thereby
items
rrh
writeset
wal
ram
propagated
physical
update
logged
invariant
committing
recovering
trade
interrupted
updated
falsifying
tei
precluding
hsien
read
enforcing
emphasize
grouped
deferred
architecture
principle
cache
demands
fetching
featuring
capitalizes
interchangeable
crux
bringing
segmented
processed
discarding
consistent
disaster
intolerable
flash
compatibility
affect
accommodate
atomic
idempotence
freshness
reflects
concurrently
forwards
commute
vacuously
amortize
gbytes
semiconductor
facilitate
event
atomically
subtransactions
correctness
traditional
finer
sweeps
active
improvements
marked
book
principles
conventional
item
deficiencies
enforced
triggering
contemporary
log records
stable memory
transaction processing
incremental restart
log driven
stale fresh
page x
buffer manager
level recovery
fresh marking
main memory
driven backups
memory database
operation logging
x stale
restart processing
high level
database pages
post crash
safe fetch
level undo
base recovery
committed transactions
log record
memory resident
secondary storage
restart procedure
page based
log tail
recovery processing
stale page
database systems
recovery management
recovery techniques
backup image
dirty stale
backup database
committed image
crash transactions
level log
database recovery
resident database
flush fresh
single propagation
steal policy
stale holds
large main
loser transactions
page flushes
restart algorithm
stale pages
level operations
recovery scheme
multi level
database cache
crash recovery
concurrency control
buffer management
fast restart
x dirty
redo log
crash transaction
standard restart
backup x
recovery activities
database page
restart transaction
recovery manager
recovery related
operation consistent
invariant holds
consistent state
transaction execution
propagating updates
entire database
current image
data items
base level
steal buffer
f lush
forward transaction
ffl page
missing updates
entry logging
o activity
checkpointing algorithms
corresponding updates
fresh stale
normal transaction
fuzzy algorithms
log recs
transaction rates
resident databases
stale marking
page basis
reflect updates
dirty pages
large buffer
single pages
backups technique
propagator applies
stale fresh marking
log driven backups
main memory database
high level recovery
high level undo
high level log
post crash transactions
memory database systems
image of x
multi level recovery
following a crash
high level operations
records of committed
incremental restart algorithm
operation consistent state
memory resident database
memory database recovery
database on secondary
x is stale
x stale holds
flushing a page
resident database system
approach to recovery
page is brought
driven backups technique
fresh stale marking
page is recovered
x is fresh
single i o
transactions are processed
log on disk
high transaction rates
steal buffer management
based on operation
ffl page x
updates to bdb
x is dirty
large main memories
parallel with transaction
post crash transaction
normal transaction processing
redo only log
redo log records
approach to restart
buffer management policy
high level action
x is denoted
transaction processing systems
say that x
based concurrency control
read and write
pages a b
techniques for main
level recovery management
mmdbs without precluding
crash recovery scheme
enforcing safe fetch
page i o
redo only bdb
li pin chang
initialization and crash

corpus/krapavin2000-test/1039213.txt
ele
game
player
games
agent
payo
equilibrium
learning
payos
agents
nash
players
pareto
reward
prole
monitoring
adversary
policy
reinforcement
payments
irrational
imperfect
maximin
rewards
economically
stochastic
action
normative
punishment
cient
actions
rationality
joint
played
play
deviate
perfect
attain
repeated
rational
folk
multiagent
deviates
mix
ai
equilibria
mixing
denition
punish
theorists
bowling
cooperative
converge
descriptive
convergence
defect
histories
plays
rg
veloso
economics
bayesian
stick
cooperate
policies
deviation
resp
prescribed
shneidman
parkes
xed
polynomial
ciently
ciency
probabilistic
social
stipulates
monetary
settings
spirit
surplus
playing
payoff
history
strategies
payment
adopt
articial
rst
knows
adopted
modied
maximizes
dened
shot
justied
strategic
quickly
dierent
stationary
behave
economic
online
outcome
response
matrix
individually
initially
max
jeffrey
mixed
dierences
people
motivation
attained
unknown
covergent
deviators
conitzer
rby
thuc
unplayed
irrationality
deviator
enforceable
knowng
noncooperative
vorobeychik
fassumed
awesome
deviating
tuomas
polynominal
satinder
punishing
ramications
osprings
groves
undiscounted
iterations
paid
complements
interactions
technically
dynamics
associates
learns
visit
learn
adopting
existence
appealing
yevgeniy
boella
conver
vickrey
devoid
leendert
torre
pretend
prisoner
decreased
setting
termed
rigorous
strict
dene
designer
equated
opponents
wellman
shoham
faithfulness
psychology
instructed
sandholm
nv
nding
exploration
average
accomplish
autonomous
uncertainty
yoav
paramount
foe
ages
outset
vu
pv
gence
recommending
guido
incentive
utility
stochastic games
repeated games
player 1
imperfect monitoring
policy prole
average reward
player 2
pareto ele
perfect monitoring
nash equilibrium
learning equilibrium
e cient
joint action
reinforcement learning
learning algorithms
economically e
cient learning
probabilistic maximin
learning algorithm
repeated game
game g
monitoring setting
side payments
r max
multi agent
game matrix
game theory
normative approach
return mixing
best response
average sum
mixing time
possible histories
common interest
expected payo
maximin value
payo obtained
ele algorithm
agent initially
xed sum
initially plays
game m
always play
sum game
agent 1
agent reinforcement
non cooperative
machine learning
desired value
rg m
sum stochastic
payos obtained
individually rational
game theorists
players play
strict imperfect
nash ele
self play
equilibrium ele
folk theorems
game associated
monitoring case
ele exists
general sum
initially unknown
e ciently
behave according
always exist
e ciency
bayesian approach
polynomial number
learning v
economically e cient
e cient learning
cient learning equilibrium
learning in games
return mixing time
sum of rewards
perfect monitoring setting
approach to learning
adversary will always
probabilistic maximin value
agent initially plays
agent reinforcement learning
work on learning
case of repeated
learning equilibrium ele
games with perfect
player can observe
bowling and veloso
known the game
xed sum game
sum stochastic games
learning v 67
adversary s payo
strict imperfect monitoring
repeated game m
multi agent reinforcement
set of possible
machine learning v
number of steps
multi agent systems
v 67 n
near optimal reinforcement
game theory literature
player 1 plays
multi agent interaction
rewards are based
learning in general
discuss the extension
stochastic games stochastic
imperfect monitoring settings
algorithms in computer
called folk theorems
learning in cooperative
theorems in economics
game is g2
corresponding rg m
player 1 deviates
long term average
denition for player
general sum stochastic
speed of convergence

corpus/krapavin2000-test/609397.txt
channel
cell
nccs
cochannel
channels
fca
borrowing
blocking
station
traffic
dca
cells
interference
hca
borrowable
sharing
cellular
cbwl
nominal
mobile
inner
radio
outer
pool
adjacent
neighbor
occupancy
borrowed
region
cir
locking
pools
assignment
borrow
distributor
load
pb
borrows
tier
terminal
wireless
stations
resources
terminals
directional
handoff
coverage
adapt
probability
density
swapping
schemes
base
receiver
probabilities
teletraffic
distributors
mobility
dynamics
register
equipped
db
occupied
lending
regions
loads
signal
lent
bandpass
capacity
link
frequency
reuse
arrival
users
intra
underflow
radius
congestion
fl
six
blocked
slope
conflict
band
fig
separation
service
telephone
carrier
retry
ff
spot
rejection
network
binomial
management
unused
calls
turned
guard
quality
hot
communications
overflow
omnidirection
richest
falloff
handover
splatter
eqivalent
weihua
chak
indoormultimedia
tiers
transceivers
satisfactory
utilization
busy
filter
sg
controller
interleaving
directionally
transmitters
subscribers
zhuang
itrc
occupancies
transmitting
exclusive
caused
interferences
passband
bcc
antennas
handoffs
assigned
expense
spectrum
divided
distance
cdma
conventionally
excellence
birth
flowchart
scheme
initiated
signals
groups
connection
adaptive
death
modulated
rf
rearrangement
satisfactorily
shadowed
referred
achieves
loaded
hexagonal
eligible
heavily
resource
cleared
separations
sector
happens
situation
spacing
suppressed
ae
overcome
allocated
power
calculated
suppress
voice
disappears
margin
autonomously
telecommunication
deficiency
unchanged
measurable
selectivity
terrain
admission
light
offers
cell region
inner cell
blocking probability
channel assignment
channel sharing
nccs scheme
base station
outer cell
adjacent channel
call blocking
channel interference
traffic load
channel borrowing
neighbor cells
nominal channels
cochannel interference
cell 1
cell 17
cochannel cells
sharing channels
sharing pool
channel occupancy
cell 2
traffic density
neighbor cell
channel resources
borrowable channels
channel locking
link quality
cell 24
blocking probabilities
borrowed channel
cell regions
mobile terminal
lower call
cbwl scheme
dca schemes
cir value
nominal channel
sharing pools
assignment schemes
dynamic channel
pb c
radio link
cell network
fca scheme
borrowing conflict
sharing channel
traffic dynamics
channel swapping
channels assigned
wireless cellular
cell channel
first tier
adaptive channel
sharing nccs
mobile cellular
adjacent channels
sharing scheme
cellular network
cellular mobile
mobile terminals
adjacent cells
mobile communication
cellular networks
communication systems
base stations
available channels
channel separation
c channels
borrowed channels
channel available
directional borrowing
n nominal
call connection
channel resource
desired channel
load distributor
intra cell
six cochannel
interference issue
new call
traffic loads
traffic adaptive
two cell
channel management
radio channel
overall traffic
cellular systems
d b
proposed scheme
exclusive use
proposed channel
adapt channel
reuse distance
bandpass filter
call blocking probability
adjacent channel interference
inner cell region
outer cell region
channel from cell
pb c 1
channel assignment schemes
radio link quality
channel sharing scheme
lower call blocking
channel sharing pool
interference and adjacent
using the nccs
outer cell 1
cell channel sharing
channel sharing nccs
borrows a channel
adaptive channel assignment
neighbor cell channel
mobile communication systems
traffic adaptive channel
dca and hca
two cell network
cell 2 channel
six cochannel cells
n nominal channels
adapt to traffic
inner cell regions
cell and outer
wireless cellular networks
traffic load distributor
cell 24 borrows
scheme can adapt
sharing nccs scheme
dynamic channel assignment
outer cell regions
probability of cell
channels and borrowable
d a d
order to overcome
two channels assigned
overcome the adjacent
channel sharing among
schemes can adapt
cochannel interference issue
intra cell handoff
six neighbor cells
light traffic load
satisfactory link quality
c 1 inner
inner cell mobile
q i value
cell 17 caused
traffic load dynamics
larger channel sharing

corpus/krapavin2000-test/609902.txt
nasty
adversary
learning
noise
pac
sample
vc
nsn
bad
malicious
ncn
binomial
delta
pr
learnable
ffi
errs
accuracy
dimension
learn
oracle
classification
hypothesis
concept
target
coin
probability
agnostic
misclassified
label
vcdim
nastyconsistent
nastylearn
chervonenkis
learns
vapnik
hypotheses
hoeffding
boolean
nb
noisy
ff
valiant
sub
intervals
flipped
ffl
tosses
learnability
vote
confidence
gamma
rate
sauer
cesa
bianchi
composition
labeled
unmodified
theoretic
inequality
dnf
majority
incorrectly
labels
learned
consistency
sees
concepts
biased
unreliable
modify
tolerant
adversarial
complemented
drawn
margin
trivial
samples
suffer
advance
js
modified
boundary
statistical
chooses
event
flip
random
unseen
ki
outputs
request
gets
certainty
weight
misleading
requested
polynomial
sufficiently
fcjx
scon
talagrand
cam
blaine
cpcn
jbad
neutralize
decatur
nastiness
hjc
misclassifies
prd
barreno
sears
commencing
weakly
corrupted
scenarios
knows
queries
variability
dual
incomplete
symmetric
remove
geometric
events
informative
argue
shattered
tygar
classes
asks
differences
showing
consistent
presence
reverses
taipei
unjustified
identically
fourier
resulted
implied
wrongly
reorders
maliciously
untouched
compression
query
distort
destructive
outputting
expectation
net
uniformly
wrong
happen
half
omega
distribution
settled
deviates
russell
subintervals
sharper
taiwan
error
proceeds
hg
boosting
nelson
randomly
decides
characterizing
bernoulli
choosing
randomized
strategy
combinatorial
cell
joseph
negations
exhausted
generalizes
criterion
constitute
anthony
blum
flips
learning algorithm
distribution d
vc dimension
concept class
noise model
classification noise
nasty noise
malicious noise
target function
class c
sub sample
bad 2
nasty sample
rate j
binomial distribution
class h
bad 1
sample noise
nasty classification
pac learning
pac model
instance space
accuracy ffl
gamma 2
d gamma
m examples
sub intervals
nasty adversary
random classification
composition theorem
noise rate
gamma ffi
concept classes
h f0
pr bad
symmetric differences
probability j
distributed according
h 2
c h
sample points
least 1
dimension d
ffl 2j
trivial class
bad 3
noise learning
ffi 4
trivial concept
d gamma1
consistency algorithm
x 2
learning algorithms
j delta
point x
c 1
m points
positive result
agnostic learning
total error
parameters j
noise tolerant
original sample
non trivial
information theoretic
x according
random variable
h j
pac learnable
accuracy parameter
target concept
function h
lower bound
sample complexity
vapnik chervonenkis
function c
complete sample
ff net
nsn model
biased coin
delta sample
bad part
result showing
bad sub
error rate
adversary chooses
probability distribution
w h
efficient learning
query learning
e points
smaller sub
statistical query
bad bad
parameters m
b nb
algorithm sees
confidence ffi
sub domain
noisy examples
x d
space x
confidence parameter
nb n
d gamma 2
probability at least
nasty sample noise
sample s g
distribution with parameters
number of examples
vc dimension d
random classification noise
c with accuracy
noise of rate
classification noise model
malicious noise model
nasty classification noise
concept class c
h f0 1g
class h f0
learning from noisy
learning with nasty
x d gamma1
d over x
theorem for learning
least 1 gamma
probability distribution d
h 2 h
instance space x
trivial concept class
gamma ffi 4
non trivial class
non trivial concept
algorithm that learns
point x 2
c t x
presence of noise
class of symmetric
c t 2
presented in 8
bad sub intervals
smaller sub sample
pr bad 1
class with accuracy
points from x
better than 2j
gamma 2 8
x 7 f0
gamma 2 2
concept class h
learning algorithm sees
thus with probability
call the nasty
target function c
nasty noise model
b nb n
efficient learning algorithms
h 2 c
statistical query learning
algorithm for c
choice of n
using a sample
random variable distributed
set of points
function h 2
number of sample
model the adversary
j and m

corpus/krapavin2000-test/628100.txt
semijoin
locational
qt
rt
spatial
join
site
keys
approximations
mbrs
joins
kbytes
mbr
theta
transmission
bandwidth
descriptions
parcels
transmitting
drops
cpu
records
transmitted
lis
semijoins
comm
sec
indexes
gis
land
bytes
compaction
objects
naive
databases
tree
record
false
merge
rectangles
joining
relations
database
quadrants
indexed
query
outperforms
conducted
uniprocessor
polygons
trees
bounding
costs
attributes
saving
relationships
dimensional
families
filter
object
communication
weaker
intersection
linearized
ffl
childptr
transmits
rectangle
outperform
adjacency
io
incurred
selections
final
buffering
cardinality
agencies
soil
mbytes
cheaper
fetching
compacted
filters
rotated
containment
sorted
sparc
leaf
thirds
employ
conventional
os
polygonal
incurs
expensive
oid
sites
strategies
sheer
varying
index
duplicates
varies
approximation
sweeping
saved
participate
nested
sort
indexing
speeds
populated
entirety
cut
effective
microseconds
transmit
dominates
geographic
quad
operator
middle
mapping
region
inexpensive
attribute
adopted
breadth
figures
scan
costly
relationship
milliseconds
monitored
jacox
geodetic
legislative
morton
assets
eastward
reread
patition
csiro
exporting
shipping
kilometer
unviersity
equijoin
refetching
northward
south
theta theta
locational keys
spatial descriptions
r tree
spatial join
distributed spatial
r site
locational key
final join
rt n
transmission cost
rt l
semijoin based
spatial semijoin
false drops
qt n
based algorithms
join processing
communication bandwidth
spatial joins
processing cost
join algorithms
algorithm qt
qt c
single dimensional
o cost
algorithm rt
local processing
qt 4
cpu cost
spatial databases
kbytes sec
comm bandwidth
spatial description
dimensional approximations
r 0
total time
two spatial
key based
spatial relations
multi dimensional
spatial objects
join strategies
object mapping
semijoin algorithms
based joins
r trees
tree based
spatial database
n theta
ffl algorithm
time comm
data sets
bandwidth varies
semijoin operator
lis applications
weaker relationship
keys based
outperforms rt
distributed join
approximations obtained
large spatial
communication cost
spatial relationships
l rt
join operation
minimum bounding
sort merge
joins using
tree index
n rt
dimensional locational
key algorithms
small spatial
semijoin result
c qt
kbytes rt
kbytes qt
record total
two families
merge join
dimensional approximation
several spatial
relation sizes
approximation based
different relation
query processing
spatial data
dimensional object
spatial query
time sec
spatial indexes
gis applications
sec figure
b f
relations r
cpu speed
approximation functions
conventional semijoin
region represented
based semijoin
qt rt
total processing
two polygons
merge like
transmits r
land information
descriptions rt
theta theta theta
distributed spatial join
semijoin based algorithms
n theta theta
number of mbrs
distributed spatial databases
bandwidth in kbytes
spatial join processing
locational key based
number of false
spatial join algorithms
r tree based
records of r
time comm bandwidth
rt n theta
number of approximations
key based algorithms
local processing cost
total time comm
two spatial relations
qt n theta
large spatial descriptions
communication bandwidth varies
rt l rt
multi dimensional approximations
locational keys based
length of spatial
r tree index
spatial joins using
kbytes qt n
theta theta b
cost of transmitting
record total time
kbytes rt n
number of locational
multi dimensional approximation
joins with varying
spatial database system
small spatial descriptions
dimensional approximation based
rt n rt
c qt n
different relation sizes
algorithm qt n
qt c qt
single dimensional locational
semijoin and final
transmitted to r
single dimensional object
locational key algorithms
dimensional object mapping
time sec figure
site s site
satisfy the join
total time sec
theta theta c
sort merge join
number of objects
cost i o
qt 4 qt
perform the semijoin
spatial semijoin operator
dimensional approximations obtained
algorithm rt l
descriptions of objects
n qt 4
based spatial join
several spatial join
cost transmission cost
dimensional locational keys
local processing costs
ffl algorithm rt
based semijoin algorithms
algorithm qt c
spatial join strategies
qt n qt
joins of different
algorithm rt n
total processing cost
site to r
algorithm qt 4
keys based joins
o cost saved
evaluate the semijoin
lists of locational
locational key values
varying communication bandwidth
families of algorithms

corpus/krapavin2000-test/624159.txt
nic
endpoint
endpoints
message
messages
firmware
virtual
packet
dma
packets
logp
nacks
gam
server
retransmission
myrinet
sender
acks
destination
microseconds
timer
sbus
outstanding
resident
network
nics
host
interfaces
bulk
daemons
receiver
clients
medium
nack
delivery
retransmissions
channel
senders
interface
client
multiprogramming
transport
resources
hamlyn
protocols
active
receiving
unloaded
send
transfers
timeout
receive
trip
interconnect
sending
protection
protocol
bandwidth
overruns
rates
rtt
mb
bisection
thread
microbenchmarks
shrimp
api
reliable
scheduling
reply
layers
round
virtualized
communication
bandwidths
channels
aggregate
hosts
buffer
ack
gap
unacknowledged
microsecond
mechanisms
management
mapper
undeliverable
msgs
backing
threaded
sequencing
bw
switches
streaming
workstations
credits
cables
culler
transmission
fm
latency
requests
routes
overheads
switch
contention
staging
gigabit
virtualization
benchmarks
net
flow
privileged
topology
cluster
costs
layer
unreachable
queue
delivered
transient
pm
deadlock
timestamp
networks
addressable
semaphore
supercomputing
pressure
avg
queues
martin
virtualizing
pageable
microbenchmark
overcommitted
frees
unduplicated
multiplexing
arpa
graceful
request
catastrophic
accommodate
bytes
handler
hardware
copy
eicken
clm
payloads
unloading
driver
protected
latest
scheduled
replies
fellowship
destined
berkeley
micro
tags
retries
tention
mainstream
posted
traffic
unavailable
storage
acknowledged
manage
event
robin
nsf
faults
indirection
retransmitted
graduate
positively
arrives
tag
latencies
actively
corrupted
errors
spmd
responsiveness
word
probe
baseline
handling
acknowledgment
load
clusters
received
virtual networks
active message
virtual network
network interface
message rates
message delivery
network interfaces
reliable message
per client
timer management
outstanding messages
flow control
active messages
non resident
endpoint scheduling
medium messages
client message
message rate
destination endpoint
k user
per endpoint
error model
virtual memory
round trip
transport protocols
host memory
resident endpoints
logical channels
medium message
destination nic
server thread
u net
sequencing information
sequence number
average per
ii api
nic transport
independent logical
interface architecture
virtual interface
resident endpoint
active endpoints
bulk messages
retransmission mechanisms
interface firmware
single virtual
trip times
receive queue
re transmission
buffer overruns
back pressure
communication layers
address space
communication system
network management
user level
successfully written
cluster interconnect
nic flow
level back
rate msgs
server endpoints
request receive
server message
nics delta
destination endpoints
latest nack
endpoint contention
overhead o
interface memory
additional messages
receive table
dma transfers
control timer
message staging
send table
per packet
communication resources
trip time
protection checks
channel table
common destination
message layer
packet retransmissions
fast communication
network system
performance communication
contention within
automatic network
general purpose
high performance
message system
transport protocol
multi threaded
per message
error handling
multiple independent
net work
parallel programs
link level
short messages
communication subsystem
network access
per second
end points
communication model
table entries
delta channels
error models
bisection 5
unrelated applications
outstanding requests
reliable message delivery
nic to nic
per client message
client message rates
number of clients
nic transport protocols
virtual interface architecture
acks and nacks
average per client
independent logical channels
medium and bulk
single virtual network
round trip times
send and receive
flow control timer
level back pressure
sending a packet
destination endpoint contention
nic flow control
link level back
active message system
non resident endpoint
virtual network system
multiple independent logical
active message layer
message rate msgs
network interface firmware
medium message staging
conference on supercomputing
round trip time
interfaces and communication
high performance communication
within a single
number of outstanding
per endpoint error
direct network access
collections of endpoints
channel management tables
acks that may
virtual memory regions
unduplicated message delivery
endpoint to endpoint
clients message rate
nics delta channels
server message rates
network management daemons
channel table state
logp communication model
stop and wait
bandwidth and low
timeout and re
server and per
endpoint contention within
communication system must
support automatic network
sun ultrasparc workstations
message round trip
management reliable message
wait flow control
scheduling flow control
microseconds the protection
deadlock free routes
programming i o
non resident endpoints
virtual network segment
interface architecture proceedings
receiving 4 word
thorsten von eicken
california state micro
server client figure
beyond a baseline
control timer management
ultrasparc workstations interconnected
using medium messages
arriving for non
network interface card
short message rates
dropped or corrupted
add another 1
network segment driver
return to sender
timer and retransmission
virtualization of network
per message round
using per endpoint
message staging areas
nsf infrastructure grant

corpus/krapavin2000-test/611436.txt
spiht
parallelisation
coe
wavelet
pe
cients
lis
pes
renement
separators
lip
stream
lsp
coding
bpp
insignicant
compression
sm
video
separator
bit
transform
cient
bs
ospring
speedup
signicance
speedups
zerotree
ezw
spacial
psnr
unevenly
bits
sequential
mimd
subband
synchronisation
bands
trees
alteration
iterator
band
decomposition
signicant
lists
assembly
pixels
scan
threshold
entry
image
decoder
rst
entries
lter
neglectable
spacially
processall
parallelise
listless
neighbouring
lled
rene
scalability
ltered
grandma
coder
encoded
descendants
inserted
encoder
ciently
desc
termination
ltering
dierent
sub
xed
dierence
decoded
assembling
compatible
assembled
mpeg
parent
necessity
inherently
list
sign
rates
distortion
predicates
tree
rate
eect
slices
counter
sig
coarse
frames
appended
decoding
altered
jumbles
synchronise
fwf
qmf
packetise
uhl
epcc
standardisation
parallelised
lena
synchronises
parallelising
signicances
dispenses
norcen
processcoe
utilisation
fmge
vtc
tracs
visualised
drawbacks
copied
slice
3d
motion
ow
substitute
ciency
bigger
roots
transformed
decodes
cance
austrian
localised
colours
computers
partitioning
nevertheless
overall
encodes
demands
loop
reads
collections
streams
splitted
bitmaps
initialisation
openmp
lling
breakdowns
pass
consecutive
symbols
false
encode
understands
uous
inconvenient
erb
dct
jpeg
pyramidal
multirate
algo
tmr
tricks
roland
smps
multiplexed
divisibility
edinburgh
hierarchical
competitive
approximates
frame
suits
competitors
redundancies
scientic
reserves
bit stream
coe cients
wavelet transform
spiht algorithm
renement step
zero tree
coe cient
sm based
zero trees
output bpp
single pe
original spiht
lis lip
bpp decomposition
sub band
decomposition overall
compression rate
parallel wavelet
video data
coding part
list entries
local coe
lip lsp
stream assembly
overall spiht
direct ospring
overall coding
sequential algorithm
d case
based algorithm
insignicant coe
approximation sub
hierarchical trees
set partitioning
d wavelet
lsp bs
cient p
b p
discrete wavelet
unevenly distributed
parallel algorithm
wavelet decomposition
data distribution
xed compression
resulting bit
pe local
approximation subband
scan order
sub bands
tree coding
transform algorithms
spiht parallelisation
stream bs
separator entry
cient scan
mimd computers
video compression
transformed data
compression rates
d algorithms
distributed complexity
wavelet coe
rate 0
frame size
video sequence
non local
inherently sequential
o p
sub tree
image compression
c p
low pass
spacially oriented
list operations
process synchronisation
altered algorithm
coding algorithm
oriented coe
complicated bit
sig sign
two competitive
renement steps
direct parallelisation
lists lis
coding figure
algorithm alteration
embedded wavelet
bs lis
parent coe
listless zerotree
memory demands
driven parallelisation
distributed lists
competitive approaches
cient positions
therefore implemented
mimd architectures
rst scan
mpeg 4
neighbouring pes
tree roots
spiht output
zerotree coding
desc p
bit streams
insignicant sub
parallelisation e
maps sm
trees spiht
entry associated
destination list
varying compression
ezw algorithm
direct spiht
software aspects
pass lter
b sm
sequential part
sm based algorithm
bpp decomposition overall
parallel wavelet transform
output bpp decomposition
lis lip lsp
lists of coe
bit stream assembly
b and c
partitioning in hierarchical
lip lsp bs
insignicant coe cients
approximation sub band
local coe cients
coe cient p
set of coe
discrete wavelet transform
zero tree coding
wavelet transform algorithms
within a renement
number of pes
unevenly distributed complexity
bit stream bs
resulting bit stream
coe cient scan
compression rate 0
number of separators
decomposition overall coding
rate 0 14
d wavelet decomposition
xed compression rate
decomposition overall spiht
p is true
wavelet coe cients
p is false
p b p
see section 2
performed in parallel
image and video
single entry associated
signicance maps sm
coder using three
rst scan order
collection of transformed
spacially oriented coe
lsp bs lis
embedded wavelet video
three dimensional set
renement step threshold
among the pes
sequential code parts
trees are local
p in approximation
therefore the global
video coder using
lip are lled
complicated bit stream
assembling the bit
memory mimd computers
parallelisation e ciency
scalability of 2
threshold threshold 2
containing a counter
parent coe cient
b sm based
direct spiht parallelisation
sub tree without
overall coding figure
aspects for 3
share in execution
step threshold threshold
video data size
child coe cients
zero tree based
substitute the lists
list of insignicant
number of renement
trees of coe
using three dimensional
tree coding algorithm
zero tree roots
data driven parallelisation
overall coding b

corpus/krapavin2000-test/1035804.txt
subring
subrings
leader
captured
message
capture
candidate
owner
election
candidates
messages
cap
elected
protocol
enter
capturing
sends
contest
phase
accept
node
chordal
send
spontaneously
entering
inform
blocked
waking
elect
id
announce
responded
wakes
flocchini
sent
nodes
received
ack
santoro
ring
passive
paola
direction
leaders
slots
log
electing
identity
increment
declare
rings
entered
hamiltonion
roncato
nicola
transit
reach
receiving
chords
elects
captures
response
lemma
wake
identities
compete
protocols
ignores
units
receives
receive
logically
incident
majority
alessandro
cycle
representative
networks
informs
proceeds
enters
inherits
network
edge
destination
synchronous
bits
responds
multiples
mans
moneta
synnve
sepa
kekkonen
conquest
successful
knows
distance
disjoint
asynchronous
fi
increments
negligible
arranged
rately
processors
tries
impacted
ffl
phases
behaves
largest
cept
elections
ccr
dividing
informally
attempts
announces
unaware
links
tolerant
ensures
reaches
awareness
multistage
leading
lemmas
simultaneously
eighteenth
false
js
declares
atlanta
bernard
link
possibilities
torus
induction
wins
inherited
contradiction
else
additions
omitting
eg
asynchronously
receipt
ignored
distances
accomplished
arrangement
bidirectional
georgia
informed
jv
sending
carry
complexities
dist
fault
initiate
unpredictable
distinguishing
spanning
acknowledge
interleaved
power
labeled
sender
delivered
numbered
initially
gamma
resulted
delay
clustered
edges
execution
carries
bounds
orientation
wants
reaching
principles
hypothesis
sense
capture message
second phase
cap level
enter step
first phase
accept message
n k
complete networks
step m
owner j
complete network
first node
o n
state candidate
captured nodes
capture nodes
step l
r j
message complexity
leader election
changes state
step variable
directly captured
node j
lemma 3
constant amount
k 2
log n
j e
n messages
capture j
candidate node
send messages
one node
level number
phase 2
log k
already captured
owner message
edge j
step log
two candidates
state captured
id pair
node entering
nodes j
accept 1
sends messages
step sends
single leader
l gamma1
o log
phase 1
time unit
level j
step j
subrings captured
asynchronous complete
direction sense
owner messages
k subrings
receive m
larger level
nicola santoro
level x
j level
captured node
chordal rings
entering step
candidate say
capture messages
paola flocchini
sense of direction
candidate in r
o n k
messages to capture
r i m
r i k
k 2 l
candidates in r
message to capture
candidate and phase
enter step m
r i x
sends a message
message to j
sends a capture
entering the second
node will enter
message is sent
within a constant
nodes in r
enter the second
set of subrings
step log k
r i 3k
entered the second
successful in capturing
first node entering
protocol is o
protocol for leader
enter step l
captured by j
ffl if state
edge j e
capture all nodes
state to captured
election in complete
candidate in cap
phase is o
power of 2
time t 0
one time unit
set i 1
o n messages
multiple of k
o log n
amount of time
j at time
may not know
log n bits
j 6 candidate
node i uses
exists a candidate
contest with one
lines 10 11
still a candidate
k 2 y
set of captured
increment its step
l gamma1 candidates
majority of nodes
state j 6
received an accept
ignores the message
level n k

corpus/krapavin2000-test/1011175.txt
alat
category
pequ
functor
equilogical
assm
equ
assemblies
lattices
equivalence
dom
codense
spaces
modest
dper
cartesian
berger
algebraic
pca
realizers
subobjects
fibration
equivariant
mod
jdj
totality
morphism
mappings
subcategory
powerset
powered
functionals
categorical
categories
realizability
topological
subobject
topos
kreisel
realizer
lattice
ershov
pcas
ja
countable
topology
closed
quotient
tripos
coproducts
morphisms
jej
dense
cocomplete
regular
adjoint
comprehension
continuous
object
kleene
domains
equalizers
chevalley
beck
ccc
jaj
quotients
analogy
sigma
faithful
theta
fibred
terminal
pullback
jlj
equalizer
rosolini
fibrations
combinatory
externalization
coequalizers
relations
universe
constructions
products
family
adjoints
reindexing
scott
omega
pers
calculus
dependent
pcp
jt
separable
preserves
completions
manuscript
embed
objects
maps
embedding
reinhold
subcategories
toposes
closedness
coequalizer
carboni
ufam
hjaj
typed
flat
partial
split
suggestion
hd
surjective
dn
exponentiation
tracked
retracts
heckmann
impredicative
colimits
logic
ni
hm
jf
arrows
separating
identity
sublattices
fu
embeds
ex
tracks
subspace
inclusion
codomain
reflection
isomorphic
iterated
hierarchy
map
familiar
limits
canonical
top
jacobs
forgetful
isomorphism
lambda
factorizations
realizable
theories
underlying
formed
theorems
pure
shall
jk
closure
exponential
preserve
polymorphic
internal
synthetic
id
faithfully
virtue
triples
preprint
vertically
families
representatives
likewise
subsets
projection
union
realized
product
co
lifting
injective
axiom
classes
assembly
think
genesis
sentatives
contians
equailizer
isomorphically
relizer
jpcp
coequailizer
mod alat
algebraic lattices
cartesian closed
partial equivalence
equivalence relations
assm alat
modest sets
equilogical spaces
equivalence relation
type theory
per dom
dper dom
algebraic lattice
well powered
dependent type
regular subobjects
berger 4
countable functionals
closed category
topological spaces
domain theory
equivalence classes
category equ
full subcategory
top 0
regular subobject
m jdj
topological space
kleene kreisel
terminal object
functor r
quotient types
sigma topology
numbers object
finite types
continuous mappings
powerset spaces
internal category
category assm
equivariant mappings
f x
l l
natural numbers
continuous functions
domain d
co well
category pequ
chevalley condition
parallel arrows
subset types
comprehension category
beck chevalley
functor p
finite limits
whose underlying
x g
function space
underlying domain
continuous extension
theorem 4
open sets
b y
equivalent proof
split coproducts
tracks f
top adding
alat since
sub ccc
flat domain
hd m
category mod
partial combinatory
n jej
adding functor
kreisel countable
codense set
partial equivalence relations
dependent type theory
cartesian closed category
partial equivalence relation
theta a e
sets and assemblies
category of assemblies
category of algebraic
l l l
natural numbers object
category of equilogical
x a ex
category assm alat
domains with totality
j b y
x a e
f x g
beck chevalley condition
follows 1 objects
f i i2x
universe of realizers
co well powered
codense and dense
category of equivalence
full and faithful
top adding functor
alat and mod
category of partial
kreisel countable functionals
model of dependent
regular well powered
analogy with categories
category mod alat
ex and y
classes of continuous
ccc of per
cartesian closed categories
kleene kreisel countable
maps a morphism
regular co well
type in context
small cartesian closed
functionals of pure
b e y
subcategory of per
y b e
category of realizers
maps an object
whose underlying domain
see e g
theory and logic
calculus of constructions

corpus/krapavin2000-test/627003.txt
bank
banks
subbank
subbanks
queue
buffering
cycle
port
logical
mp
lbr
unbuffered
streams
efficiency
cray
interconnection
processor
reference
stride
ports
conflicts
bailey
register
processors
references
stream
strides
loading
buffered
latency
writes
simulation
slots
arbitration
dram
conflict
intraprocessor
return
memory
simulations
memories
latch
cycles
queues
pipeline
reads
throughput
load
read
doubling
physical
ae
bandwidth
interreference
skewing
multiprocessor
pipelined
registers
subsection
predicted
eight
priority
drams
reserved
initiate
sram
sohi
agreement
vector
busy
moderate
initiation
taylor
degradation
vectorized
vii
designs
probability
successful
varied
arrived
predictions
attempts
cessors
smith
freed
slot
cached
handshaking
seznec
jegou
initi
llaberia
quadrupled
saturation
buffers
effective
scaling
relationships
predicts
issued
held
interleaved
chip
requests
delayed
briggs
corral
probable
robin
queuing
slower
rate
chained
club
reordering
network
plotted
drops
estimated
superscalar
drop
unpredictable
circuitry
blocked
bus
efficiencies
arrive
feedback
ated
compensated
excellent
loads
analytical
probabilities
increased
la
del
contention
hit
thrown
filled
ram
sub
succession
conservation
chips
scalar
caching
unsuccessful
viii
doubled
examined
initiated
subdivided
juan
instruction
vectors
request
dramatically
explores
routed
attempt
runs
dramatic
versus
pro
tag
hardware
ili
maximumlength
equalizing
ister
dspa
subishi
toni
hotspot
bitration
rambus
temam
ganization
multivector
borderline
diffi
terization
simulta
fourths
fan
benchmarks
substituted
logical bank
bank cycle
cycle time
logical banks
reference streams
bank model
y mp
cray y
queue size
interconnection network
successful reference
unbuffered case
per logical
vector simulation
vector register
independent reference
sub bank
bailey model
port line
scaling relationships
subbank cycle
return conflicts
e l
read latency
reference stream
mp architecture
bank level
physical bank
stride one
vector element
vector registers
without buffering
return ports
subbanks per
effective efficiency
reference rate
memory efficiency
random reference
memory systems
memory banks
infinite queue
physical banks
initiation rate
vector references
return port
taylor 20
eight processors
interconnection costs
one vectors
register feedback
output buffering
moderate loading
plotted versus
memory cycle
memory operations
design parameters
simulation study
interconnection cost
memory performance
per processor
priority scheme
memory bank
vector operation
one reference
simulation model
element latency
maximal loading
bank register
vector simulations
ports per
stride distributions
return interconnection
path simulation
vector read
additional lines
bailey 1
three ports
design criteria
queue case
bank hit
reference attempt
without logical
register lbr
x mp
cray x
data path
physical memory
access time
analytical model
shared memory
bank cycle time
logical bank model
cray y mp
number of banks
per logical bank
independent reference streams
number of reference
size of four
subbanks per logical
smith and taylor
subbank cycle time
y mp architecture
number of logical
number of processors
size of two
memory cycle time
logical bank cycle
constant at 5
number of subbanks
stride one vectors
number of attempts
reads and writes
infinite queue case
stream is making
number of return
logical bank hit
percentage of stride
data path simulation
cray x mp
efficiency is plotted
making a successful
vector simulation model
per processor interconnection
logical bank register
three ports per
bank register lbr
ports per processor
type of load
vector memory operations
initiate a reference
without logical banks
attempt to access
reduce the effective
doubling the number
additional interconnection cost
condition ffl 1
logical bank design

corpus/krapavin2000-test/1006322.txt
bn
collective
bayesian
site
sites
learning
mining
conditional
centralized
kl
probabilities
bns
ddm
dierent
commuicated
ckl
central
heterogenous
asia
samples
observations
alarm
kargupta
parents
likelihood
web
heterogeneous
cross
heckerman
vl
sivakumar
eos
spiegelhalter
network
depicts
coupling
buntine
eecs
learn
server
transmitted
joint
networks
cen
le
astronomy
gieger
distrbn
links
learnt
communicated
monitoring
fraction
wireless
session
selective
chickering
dasgupta
estimated
kenji
lauritzen
distance
friedman
weather
chen
vc
card
credit
dataset
condence
mdl
edges
sensor
la
dyspnoea
cheeseman
webserver
dkl
pcntr
gilks
bacchus
stutz
eosdis
probabilistic
parent
download
resources
node
tables
sampling
intranets
goldszmidt
russel
gov
autoclass
hershberger
bronchitis
spirtes
mc
oer
across
records
client
evidence
transaction
datasets
jensen
transmitting
log
oers
demographic
takeuchi
independence
em
xi
veried
associations
discovering
specic
homogeneous
koller
online
split
scalability
scenario
pb
transmission
threshold
sample
probability
gure
pursuing
estimating
keys
toy
distributions
city
pa
geiger
leibler
multinomial
gibbs
discovery
collaborative
hypothesis
kullback
features
hoc
cooperative
incomplete
classication
sales
congurations
faculty
repositories
cooper
relationships
www
dg
multiagent
fig
involve
dicult
uncertain
admission
benet
schema
detected
maybe
diagnosis
logs
estimates
databases
sa
conguration
school
inference
scales
lam
ad
hidden
communication
singh
pictures
missed
indices
dened
world
anaphylaxis
cellphones
wearable
bein
central site
bayesian networks
bayesian network
collective bn
conditional probabilities
kl distance
cross terms
collective mining
centralized approach
web log
asia model
heterogeneous data
alarm network
collective learning
distributed heterogeneous
site b
dierent sites
local sites
observations commuicated
data mining
local site
parameter learning
distributed data
bn learning
collective approach
local bn
ckl distance
bn structure
log le
log data
conditional probability
local variables
nodes 20
variables across
proposed collective
collective method
node 21
collective bayesian
across sites
r chen
local model
commuicated fraction
sample complexity
chen et
network structure
data communication
bayesian learning
two sites
local bns
centralized method
buntine 1991
cross links
observations communicated
local bayesian
overall bn
data sites
learning method
error threshold
node e
structure learning
learning approach
credit card
site using
homogeneous case
non local
conditional distributions
true distribution
distributed resources
observations across
distributed sources
involve variables
experiment illustrates
low likelihood
bn model
likelihood computation
bn based
right depicts
distributed site
joint probabilities
data scenario
commuicated fig
central bn
heterogenous data
clearly even
bn obtained
dasgupta 1997
gieger 1995
heterogenous case
mining ddm
card transaction
global site
edges detected
case site
pa x
local links
local likelihood
conditional independence
incomplete data
hoc wireless
learning error
distributed sites
jensen 1996
associated conditional
learning bayesian
local terms
left depicts
dierent nodes
scales well
distributed heterogeneous data
fraction of observations
networks from distributed
mining of bayesian
number of sites
web log le
r chen et
respect to number
observations commuicated fraction
learning a bn
chen et al
using a centralized
approach to learning
variables across sites
depicts the ckl
collective learning method
web log data
learning the structure
relationships between variables
distributed data mining
collective bn learning
true distribution p
proposed collective learning
obtain a collective
observations commuicated fig
credit card transaction
heckerman and gieger
data mining ddm
collective bayesian network
estimating the conditional
available at site
distance between conditional
local bayesian network
observations across sites
central site using
collective bayesian learning
set of keys
small data communication
ad hoc wireless
bayesian network structure
distance of node
learning bayesian networks
approach with respect
learning a bayesian
well with respect
probability of node
web log mining
approach is quite
hoc wireless networks
non local bn
local likelihood values
every distributed site
learning of local
parents of nodes

corpus/krapavin2000-test/614347.txt
terrain
ray
voxel
voxels
footprint
pvs
rendering
rays
byc
pixel
traversal
photo
flythrough
image
sticks
stick
hit
frame
camera
visualization
height
pitch
casting
flight
images
resolution
emanating
photograph
3d
photographs
pixels
color
tiles
graphics
flying
aerial
accelerated
viewing
texture
terrains
prp
resolutions
processor
realistic
cavities
frames
textured
pyramid
multiresolution
sgi
scud
kilometers
maxvideo
parris
subvoxel
hippi
egbert
arie
loaded
vertical
column
gigabytes
rasterization
undersampling
meter
ntsc
cards
coherence
eye
colors
ibm
sky
extrapolated
mapped
interpolation
visual
sculpting
horizon
scsi
sampled
master
bytes
card
secondary
tracing
warp
kaufman
toy
supersampling
voxelized
oversampled
fps
huamin
double
rate
challenge
trajectories
warping
vital
roll
pipeline
sampling
incrementally
emanate
busses
pool
workstation
mbytes
plane
textures
angles
background
meters
ware
tank
cline
hardware
transparent
sec
impression
pyramidal
realism
coordinates
scenes
colored
speed
cast
margins
slave
elevation
australasia
qu
hierarchical
hierarchy
objects
generation
processors
semaphore
video
viewpoint
field
disk
interactive
speeds
projection
innovative
cpus
memory
array
portability
grid
angle
load
smooth
east
discrete
database
ethernet
flat
united
asia
columns
simulator
heights
emphasized
bandwidth
aliasing
cohen
carolina
vertically
post
vast
fields
transparency
controllers
square
map
projecting
header
internally
shared
architecture
insignificant
wan
polygonal
grey
postprocessor
stephenson
pellacini
jiafa
kadosh
tiltan
shibolet
photo realistic
voxel based
x byc
rendering algorithm
real time
generation rate
ray q
frame generation
image footprint
visual flythrough
hit point
ray casting
ray coherence
multiresolution traversal
realistic images
terrain model
three photographs
hierarchical traversal
pitch angle
flight simulation
power visualization
based objects
post rendering
rendering processor
time performance
q x
parallel machine
3d objects
ibm power
images generated
mapped back
camera position
visualization system
computer graphics
shared memory
disk array
rays emanating
global terrain
previous hit
square kilometers
column footprint
geometric pipeline
height field
frame footprint
target area
traversal 5
flying trajectories
pixel footprint
time photo
discrete ray
meter resolution
memory architecture
one column
ray tracing
next frame
viewing parameters
flight simulator
height x
voxel space
double step
power challenge
step size
semi transparent
ray emanating
global memory
main memory
graphics v
viewing direction
lower resolution
image pixels
image space
sampling rate
q j
q y
see figure
per second
z q
realistic impression
voxels representing
control stick
sign q
desired real
terrain color
realistic visual
target areas
secondary rays
ray traverses
image column
realistic rendering
soft transition
background voxels
k egbert
real frame
david cline
memory cards
voxels since
rasterization hardware
vertical grid
secondary ray
terrain voxels
pixels back
flat traversal
frame generation rate
real time performance
field of view
ray q j
photo realistic images
voxel based objects
power visualization system
q j 1
ibm power visualization
post rendering processor
along the ray
shared memory architecture
conference on visualization
real time photo
discrete ray casting
height x byc
double step size
coherence and multiresolution
sampled and mapped
accelerated by ray
time photo realistic
number of steps
visualization and computer
computer graphics v
transactions on visualization
algorithm is based
three different viewing
cline parris k
hierarchical traversal 5
z q x
x incrementally update
kilometers of 0
z height x
along the major
sign q x
different viewing directions
using ray coherence
color at x
achieve real time
innovative rendering algorithm
david cline parris
purpose parallel architecture
powerful parallel machine
hit the terrain
since the terrain
via an hippi
bytes in total
background pixels back
top down traversal
pixel to voxel
terrain the terrain
voxel space resolution
parris k egbert
q x incrementally
real time rates
desired real time
rendering but also
photo realistic visual

corpus/krapavin2000-test/614370.txt
sweep
rendering
scanline
ray
casting
aedge
slice
grids
cells
plane
lsrc
vertices
mesh
giertsen
irregular
blunt
fin
status
volume
dataset
yagel
cell
rays
facets
visualization
datasets
vertex
event
grid
sorting
pixel
oxygen
segment
tetrahedra
3dheap
curvilinear
liquid
unstructured
queue
leftward
swept
segments
slices
convex
coherence
boundary
wing
chamber
edges
meshes
3d
incident
combustion
viewing
axis
hits
insertions
sorted
tetrahedral
sweeping
graphics
scanlines
disconnected
kaufman
2d
pixels
subdivision
active
2dheap
silva
tetrahedron
image
intersections
voxels
post
polyhedron
intersected
pointers
rendered
lazy
visibility
theta
coordinate
deletions
coordinates
depth
facet
lighting
critical
connectivity
nonconvex
ordering
resolution
milliseconds
firstcell
garrity
hertel
priority
seconds
polyhedra
shooting
complexes
shading
polygons
preprocessing
edge
projection
events
polyhedral
crossed
mehlhorn
acl
presorted
sweeps
sort
seed
screen
topmost
polygonal
planes
endpoint
bottommost
topological
slicing
render
ertl
degeneracies
farias
cludio
williams
intersects
thereby
handling
mitchell
storage
hardware
arie
bucketing
field
faces
worst
scalar
endpoints
2dsweep
tetrahedralized
uselton
lichan
ram
spent
salt
encounters
linked
lake
maintaining
scratch
handles
consumption
ricardo
format
stabbing
splatting
wedges
regular
intersecting
dot
buffer
spatial
doubly
utah
volumetric
bottom
geometry
ma
reading
sweep plane
ray casting
sweep line
irregular grids
line status
3d sweep
volume rendering
critical vertices
blunt fin
active edge
event queue
sweep status
2d sweep
active edges
aedge list
status structure
o n
sweep ray
liquid oxygen
oxygen post
depth ordering
rendering times
regular grid
rendering time
event points
plane hits
lazy sweep
leftward segments
event handling
data structure
z axis
boundary vertices
sweep algorithm
yagel et
rendering irregular
theta 300
direct volume
casting algorithm
visibility ordering
handling time
curvilinear grids
image size
post 513
status data
viewing plane
combustion chamber
time o
use set
y coordinates
priority queue
log n
worst case
unstructured grids
tetrahedral cells
topological information
y coordinate
graphics hardware
data structures
projection methods
per pixel
segments incident
bottom segment
current scanline
disconnected grids
irregular grid
event point
lsrc algorithm
giertsen 15
current sweep
fin 187
per scanline
viewing coordinate
segment objects
y axis
segment data
milliseconds per
cell complexes
sorted order
volume visualization
connected components
ray shooting
delta wing
cost per
point p
connectivity information
sorted list
n log
lower bound
topmost vertex
full pixels
z plane
wing combustion
integration time
mehlhorn 16
dimensional ray
casting problem
edge list
theta 200
convex cells
sweep line status
sweep ray casting
liquid oxygen post
line status structure
lazy sweep ray
along each ray
sweep plane hits
rendering irregular grids
yagel et al
n 2 rays
event handling time
vertex of c
ray casting algorithm
direct volume rendering
sweep of 3
post 513 375
status data structure
time o n
along the z
sweep status data
complexity of ray
grid of voxels
stop the sweep
fin 187 395
number of connected
blunt fin 187
algorithm for rendering
n log n
rendering of unstructured
conference on visualization
exploit spatial coherence
blunt fin liquid
event point p
active edge list
oxygen post delta
sweep plane encounters
transformation and sorting
lsrc post 513
within each slice
leftward segments incident
fin liquid oxygen
sweeping 3 space
delta wing combustion
viewing coordinate system
ray casting problem
x z plane
two dimensional ray
along a ray
hertel and mehlhorn
o n vertices
removed from aedge
wing combustion chamber
post delta wing
rendering of irregular
incident on p
dimensional ray casting
insertions and deletions
number of facets
list of active
cludio t silva
omega gamma n

corpus/krapavin2000-test/629492.txt
supernode
tiling
cone
schedule
hyperplane
extreme
vectors
cutting
supernodes
matrix
dependence
startup
hyperplanes
projection
lengths
directions
transformation
tile
nectarios
koziris
athanasaki
iteration
shape
georgios
ui
diagonal
index
pernode
maximal
loops
row
luce
goumas
orthogonal
jacobi
maria
drosinos
vector
iterations
rows
communication
message
nested
transformed
ramanujam
tiled
tcomm
sadayappan
parallelepiped
partitioning
phases
column
loop
surface
hull
volume
nikolaos
sinks
nests
processors
objective
lectures
direction
dependencies
got
processor
ct
square
selection
determinant
corollary
uday
rountev
uating
shahriar
perplanes
droped
hyperrectangle
muthu
atanas
parsa
lotfi
baskaran
rectan
bondhugula
extenssion
dependen
terminol
transformations
running
side
trix
boothe
startups
sotiropoulos
abstractwith
aristidis
rections
scal
professorship
tsoukalas
clare
sented
convex
transmission
sides
oe
dimensional
plane
ensured
minimized
template
media
nine
multiprocessors
sriram
za
tsanakas
ecution
saeed
utiliza
timal
triolet
supercomput
transfor
krishnamoorthy
sliced
minimizes
supercomputing
minimizing
architectural
communicating
multiplied
spaces
schedules
floor
pendent
respected
execu
panayiotis
seminar
irigoin
transputer
doacross
rectangular
multidimensional
minf
wavefront
stencil
cies
henry
smps
pen
ogy
diag
gle
optimum
optimality
uniform
jersey
tiles
grouped
optimizations
passing
rescaling
hy
nicosia
hadamard
normals
shorten
systolic
sv
equidistant
gorithms
hd
direc
alternates
inde
criterion
labs
vec
linear schedule
supernode transformation
h u
index space
tiling cone
hyperplane direction
projection vectors
direction matrix
iteration index
relative side
cutting hyperplane
schedule length
schedule vector
supernode size
maximal projection
supernode shape
side lengths
optimal supernode
total running
extreme directions
dependence vectors
row vectors
matrix h
cone generated
n extreme
column vectors
optimal linear
extreme projection
side length
communication startup
extreme dependence
running time
hyperplane directions
transformed algorithm
supernode relative
supernode index
supernode side
startup cost
optimal relative
optimal q
dimensional algorithms
length matrix
dependence cone
time optimal
supernode partitioning
equal components
two dimensional
tile size
length vector
vector l
cone m
h ui
projection vector
jacobi algorithm
optimal cutting
optimal hyperplane
optimal tile
dependence matrix
supernode transformations
original iteration
one supernode
maria athanasaki
communication phases
nectarios koziris
matrix d
uniform dependencies
transformation h
objective function
vector 1
available processors
vector z
extreme points
j d
y y
considered approximate
relative supernode
su pernode
cone formed
extreme index
z arbitrarily
matrix e
supernode template
four row
corresponding tiling
optimal orthogonal
new maximal
orthogonal tiling
another hyperplane
sufficient condition
communication time
vector r
corollary 1
nested loops
exactly n
matrix r
vector v
nested loop
computation time
drosinos maria
startup time
stronger result
georgios goumas
athanasaki nectarios
hyperplane matrix
extreme vectors
supernode volume
parallelepiped supernodes
unit determinant
cone proof
continuous space
tiling multidimensional
partitioning hyperplanes
multidimensional iteration
negative components
two row
space j
square supernode
goumas nikolaos
index points
convex hull
diagonal matrix
iteration index space
hyperplane direction matrix
linear schedule length
linear schedule vector
relative side lengths
total running time
maximal projection vectors
optimal linear schedule
cutting hyperplane direction
set of extreme
matrix h u
extreme projection vectors
optimal relative side
communication startup cost
supernode index space
two dimensional algorithms
optimal supernode shape
supernode relative side
vectors of matrix
side length matrix
vector with equal
direction matrix h
relative side length
cutting hyperplane directions
supernode side length
side length vector
n extreme directions
n extreme dependence
r is optimal
extreme dependence vectors
original iteration index
length matrix r
h u 1
exactly n extreme
y y y
supernode transformation h
optimal tile size
j s d
time optimal supernode
based on lemma
number of communication
number of iterations
maximal projection vector
another hyperplane direction
inside the cone
extreme index points
four row vectors
condition for optimal
optimal hyperplane direction
based on relation
z arbitrarily close
selection of optimal
relative supernode side
construction of vector
matrix with vector
defined by corollary
optimal cutting hyperplane
generated by maximal
vectors of b
new maximal projection
h u 2
two extreme dependence
derived in continuous
selection of supernode
vector z arbitrarily
orthogonal to vector
directions and optimal
optimal orthogonal tiling
results are derived
min s d
ensured by selecting
tiling cone proof
time it takes
optimal supernode relative
iterations in one
athanasaki nectarios koziris
vectors in d
multidimensional iteration spaces
index space j
size the relative

corpus/krapavin2000-test/608327.txt
wavelet
coe
deconvolution
noise
thresholding
subbands
deconvolved
equ
cients
satellite
image
transform
subband
erent
packet
noninformative
regularization
cwp
textures
snr
inhomogeneous
cient
gaussian
bayesian
rhea
regularizing
wavelets
di
variance
homogeneous
denoising
invariance
mle
covariance
nonquadratic
shift
restoration
inversion
estimation
deblurring
hyperprior
cnes
residual
tailed
fourier
psf
artefacts
areas
sharp
fig
rey
risk
law
prior
spot
selectivity
db
blur
signal
imaginary
images
estimate
transforms
adaptive
directional
kalifa
decimated
denoise
kingsbury
cwpt
noisy
french
ciently
approximate
exhibits
diagonalization
erentiate
su
filtering
agency
wiener
filters
separable
convolution
je
packets
heavy
filter
biorthogonal
dct
trees
reconstruction
enable
invariant
nearly
visually
exponent
estimator
hybrid
impulse
quadratic
improper
blurred
regularized
insu
minimax
supposed
frequency
attenuation
posed
directions
map
quad
priors
rotational
variational
doubling
accelerated
histogram
variances
bank
mes
scales
behaviour
decomposition
edges
orientations
ill
cosine
posterior
enabling
symmetry
drawback
unknown
spatial
symmlet
ecole
noisefree
amplifying
hyperparameters
decorrelate
assumimg
miroirs
restauration
invertable
undecimated
deconvolving
rivaz
econvolution
pix
ondelettes
attenuated
noninvertible
cmapx
mallat
cowpath
deconvolutions
nonregularized
magnitude
regions
rough
ome
amplified
une
diagonalized
mcmc
intermediately
decorrelated
bidimensional
amplifies
deconvolve
contaminates
polytechnique
donoho
directionally
usion
onboard
soft
inverse
separating
estimated
classical
recombined
unacceptably
satellites
dans
integrable
exempt
enables
redundancy
automatic
thresholded
dispersion
subsampled
amplification
reconstructs
penalizes
orientation
wavelet packet
complex wavelet
coe cients
approximate original
di erent
original image
deconvolved noise
real wavelet
satellite image
coe cient
packet transform
homogeneous areas
residual noise
shift invariant
gaussian model
wavelet transform
parameter estimation
cwp transform
unknown coe
prior law
spot 5
wavelet thresholding
original coe
wavelet packets
shift invariance
approximate image
proposed algorithm
packet basis
satellite images
w r
frequency space
heavy tailed
wavelet based
deconvolved image
agency cnes
generalized gaussian
regularizing model
noise coe
space agency
regularization method
given subband
image deblurring
adaptive parameters
je rey
new transform
minimum risk
equ 19
constant areas
rhea algorithm
french space
complex wavelets
thresholding technique
image deconvolution
detail subbands
see equ
equ 17
e cient
directional selectivity
fourier space
homogeneous regions
using equ
z j
wavelet coe
erent methods
hybrid technique
noise variance
quadratic model
j k
map estimate
invariance properties
p k
image restoration
proposed method
observed data
complete data
rotational invariance
nearly diagonal
bayesian thresholding
data mle
better directional
deconvolution algorithm
homogeneous model
original complex
known h
psf h
inhomogeneous gaussian
noninformative prior
fully bayesian
automatic parameter
adaptive gaussian
erent subbands
preserve textures
strongly oriented
complex transform
packet decomposition
invariant real
proposed complex
cient noise
variational method
noise remains
estimate x
wavelet domain
invariant transforms
real separable
thresholding function
subband k
equ 20
behaviour even
transform exhibits
mes spot
without regularization
soft thresholding
equ 21
real satellite
thresholding functions
erent trees
su ciently
complex wavelet packet
approximate original image
wavelet packet transform
complex wavelet transform
computing the map
z j k
satellite image deconvolution
complex wavelet packets
real wavelet packet
space agency cnes
spot 5 simulation
wavelet packet basis
satellite image deblurring
noise coe cients
french space agency
unknown coe cients
original coe cient
estimate the unknown
wavelet coe cients
di erent methods
model is used
divide by f
estimation is made
image of n
signal and noise
using the known
regularization and wavelet
wavelet based image
di erent subbands
h and see
within a bayesian
thresholding to obtain
compared to real
blurred and noisy
using equ 19
estimate the adaptive
seen on fig
complete data mle
n mes spot
adaptive gaussian model
rhea algorithm 11
new complex wavelet
proposed algorithm consists
variance s 2
di erent trees
original complex wavelet
described by equ
mes spot 5
shift invariant real
automatic parameter estimation
proposed complex wavelet
shift invariant transforms
variances s 2
original image x
inhomogeneous gaussian model
compute the variance
parameter estimation step
wavelet packet decomposition
use a wavelet
used to estimate
real or imaginary
trees a b
noise as well
illustrated by fig
original image using
computation of k
heavy tailed distribution
possible to use
d j k
transform coe cients
computationally e cient

corpus/krapavin2000-test/1031858.txt
os
segments
slab
segment
green
shooting
multislab
log
subdivisions
ray
blue
deletions
vertical
planar
red
external
arge
answered
rst
query
subdivision
amortized
agarwal
subsegment
insertions
cascading
sorted
eciently
endpoints
kq
decomposable
ecient
hit
fractional
insertion
slabs
stored
disk
secondary
logarithmic
redundant
monotone
delete
deletion
crossing
dynamization
rmca
queries
rw
blocks
rebuilding
answering
sampled
leaf
inf
location
nd
ij
batched
deletes
union
sorting
lowest
static
rebuild
internal
searching
structures
plane
storing
lars
tree
disjoint
pointer
consecutive
store
endpoint
emanating
root
interval
intersects
sample
haverkort
rebalance
dynamic
modied
answers
vitter
subsegments
bentley
berg
consecutively
sup
pankaj
herman
charging
updates
height
eia
duke
aggarwal
sixteenth
lemma
scanning
crossed
partition
jr
intersecting
ke
memory
objects
vertices
trees
ubiquitous
answer
node
lie
geographic
xm
boundaries
leaves
middle
querying
denition
interior
deleting
ancestor
supports
successor
counters
discarding
jv
incomparable
cutting
goodrich
bmca
jarnadan
janardan
originalp
themv
baumgarten
muenster
socg
semidynamic
cheng
massive
charge
deleted
email
persistent
children
visiting
specically
build
face
handled
adds
mca
aord
stabbing
edelsbrunner
bv
hinrichs
inspiring
vahrenhold
worst
polygon
insert
constructed
mark
encountered
dene
oset
ess
nding
preprocessing
visited
copy
inecient
sampling
subsets
pointers
multidimensional
yi
dened
annual
maintain
tting
digraphs
collect
iteratively
asymptotically
seek
pisa
log b
b n
o log
n b
b log
green segments
point location
ray shooting
external memory
o n
vertical ray
green segment
log 2
structure d
logarithmic method
multislab structure
using o
shooting query
m b
data structure
log m
blue segment
red segments
fractional cascading
rst segment
secondary structures
non redundant
disk blocks
sorted sequence
b tree
planar point
agarwal et
structure m
external version
b disk
n disjoint
o ecient
red segment
os amortized
disjoint segments
node v
planar subdivision
lowest non
structures d
general subdivisions
dynamic data
structure using
linear space
interval union
arge et
internal memory
log kq
base tree
memory data
segments r
al 1
find structure
union find
redundant segment
find x
vertical slab
dynamic point
blue segments
dynamic structure
segments g
b blocks
external decomposable
k b
u ij
o 1
data structures
segment g
static structure
union operations
o b
internal node
segment hit
segments b
support deletions
monotone subdivisions
amortized respectively
global rebuilding
dynamic fractional
new external
shooting queries
leaf z
insertion bound
searching problems
planar subdivisions
consecutive green
rmca g
right structures
o efficient
sampled segments
ecient dynamic
o eciently
static external
r v
b k
answers queries
segments stored
n log
d j
o k
segment r
interval tree
et al
log b n
o log b
n i os
o n b
n b log
b i os
b log b
log m b
o log 2
vertical ray shooting
performed in o
segments in r
answered in o
g i 1
b log m
m b n
ray shooting query
b n b
constructed in o
planar point location
slab s j
using o n
agarwal et al
b disk blocks
k i os
nd the rst
queries in o
n i b
lowest non redundant
external memory data
sequence of segments
log b k
structure using o
deletions in o
r i 1
segments in g
interval union find
n b disk
arge et al
o log kq
log 2 n
insertions and deletions
d i 1
et al 1
union find structure
dynamic data structure
o k b
structures d j
k b log
green segment g
multislab structure m
os in total
data structure using
data structure d
dynamic point location
n disjoint segments
b i 1
memory data structures
dynamic fractional cascading
consecutive green segments
static external memory
external memory algorithms
internal node v
d j j
log k d
crossing s j
version of dynamic
kq i os
b n log
ray shooting queries
g s j
new external version
structure for point
non redundant segment
v and b
n log m
o log k

corpus/krapavin2000-test/608696.txt
seller
sellers
myopic
price
profit
pricing
shopbot
kephart
agent
prices
learning
agents
opponent
players
wars
policies
fl
discount
war
reward
economies
tesauro
player
profits
simultaneous
policy
sairamesh
myoptimal
consumers
lookahead
convergence
undercutting
economy
rewards
diamonds
nash
learner
economic
vs
myopically
crites
games
game
dynamics
consumer
buyers
foresight
stationary
quality
alternately
payoffs
reinforcement
instantaneous
asymmetric
equilibrium
buyer
lookup
undercut
unending
greenwald
rl
anticipate
dashed
amplitude
plot
filtering
approximators
trajectory
action
profitability
opponents
hanson
sandholm
converged
differentiation
markov
landscape
asymmetries
competing
cyclic
curve
discounting
infinitely
competition
regime
minimax
baseline
curves
monotonically
symmetric
products
barto
priced
littman
prisoner
pfig
abandon
watkins
discounted
abandons
multiagent
cumulative
alternating
economically
wellman
allowable
equilibria
landscapes
markets
charging
deterministic
discretized
corresponded
persist
payoff
iterated
compete
observable
markovian
immediate
dilemma
circle
chess
adjusting
instantaneously
arrows
self
actions
strategic
consequences
td
asymmetry
filled
optimize
infeasible
autonomous
turns
history
tables
implied
pq
competitive
perfect
leading
cross
training
evolves
consistently
plots
offering
amongst
discretization
yielded
symmetry
adjust
tirole
scissors
useable
fudenberg
fluctua
infintely
damp
subgame
substitutability
kreps
welfare
hashimoto
montonically
hunters
pricebots
differen
tesfatsion
rampant
microeconomic
leigh
undercuts
yoshitsugu
collusive
deltaq
utilites
shopbots
gammon
bargain
charge
deterministically
extent
terminating
simplifying
despite
phenomena
simultaneously
problematic
realistic
adaptive
hu
circles
unpredictable
ordinary
q learning
seller 1
seller 2
simultaneous q
price quality
vs myopic
discount parameter
price war
q functions
profit functions
price wars
myopic vs
q function
shopbot model
q derived
quality model
q learner
kephart 1999
agent q
multi agent
average profit
expected profit
two player
agent economies
information filtering
parameter fl
two sellers
pricing policies
cyclic price
asymmetric solution
derived price
price pair
myopic opponent
immediate reward
state action
expected reward
take turns
price curves
cross plot
kephart 1998
time step
state space
dashed line
single agent
filtering model
zero sum
vs q
non stationary
current price
setting prices
action pair
fl dashed
alternately take
myopic optimal
exact convergence
pricing algorithms
vs discount
approximate convergence
alternating turn
quality seller
indicates baseline
price curve
economic models
lookup tables
longer term
profit per
b cross
p 2
reinforcement learning
price competition
arbitrary sum
high prices
derived policies
deterministic policy
cumulative profit
future rewards
derived policy
stationary environment
solid diamonds
open diamonds
self consistently
sairamesh 1998
two seller
defined order
model myopic
optimal pricing
minimum price
fixed strategy
myoptimal pricing
unending cyclic
instantaneous profits
expected profits
sellers alternately
optimal policies
myopic policy
function approximators
fully observable
competing sellers
term consequences
pricing policy
kephart hanson
war regime
diamonds vs
self consistent
optimal price
theoretical guarantees
also found
three models
per time
software agents
history dependent
nash equilibrium
q table
sum games
two competing
agent systems
p 1
lookup table
full knowledge
good approximate
two step
arrows indicate
learning rate
optimal policy
simultaneous q learning
myopic vs myopic
price quality model
agent q learning
tesauro and kephart
discount parameter fl
q derived price
single agent q
cyclic price wars
plot of q
information filtering model
alternately take turns
derived price curves
seller 2 open
vs discount parameter
functions and policies
model a average
multi agent q
state action pair
b cross plot
profit per time
fl dashed line
average profit per
sairamesh and kephart
values of fl
value of fl
per time step
well defined order
price for seller
model myopic vs
parameter fl dashed
case the seller
sellers alternately take
line and arrows
hanson and sairamesh
step for seller
price war regime
longer term consequences
sandholm and crites
line indicates baseline
q derived policy
good approximate convergence
lack of theoretical
agent s current
q derived policies
seller 1 solid
filtering and shopbot
diamonds vs discount
diamonds and seller
myopic optimal price
open diamonds vs
unending cyclic price
adjusting their prices
state s 0
multi agent systems
despite the lack
dashed line indicates
number of sellers
function of fl
price of approximately
assumptions of knowledge
turns setting prices
current q function
vs q shopbot
vs myopic pricing
basis of price
price dynamics trajectory
current price pair
non stationary environment
step lookahead calculation
two player alternating
state space transitions
myopic 2 average
whether such solutions
vs myopic expected

corpus/krapavin2000-test/1006427.txt
cells
paging
paged
mobile
devices
device
round
cell
wireless
xr
strategy
nd
rounds
located
quasipartition
minimizes
rst
nding
convex
page
terminal
location
reporting
oblivious
np
pages
chances
telephony
cgt
heuristic
station
stations
cellular
users
strategies
probabilities
enumerator
lemma
lb
xed
boundary
strictly
achieves
hessian
radio
terminals
jtr
zr
establishing
specically
phone
inductive
aord
eps
dened
tra
adaptive
approximation
dene
proposition
family
ciently
gsm
sd
groups
hardness
interior
extremum
lasts
links
sr
gd
combinatorial
restate
divisible
yellow
completes
maximize
managers
backbone
search
partition
sign
delay
denite
battery
convexity
uncertain
multidimensional
signals
derivatives
expectation
ratio
broadcasts
consumes
ept
matation
strightforward
intersystem
constantfactorapproximation
repag
inator
repaging
proximation
jsr
persisted
amotz
podc
lagarias
etsi
fam
leah
mobility
probe
searching
denominator
predetermined
personal
generalizes
management
standards
looking
hosts
intractability
nds
johnson
sizes
units
muthukrishnan
awduche
merritt
symmetricity
burkard
shvartsman
epstein
denom
roams
tia
grater
intern
noy
conducts
across
motivated
optimally
base
maximizes
fr
suspects
generous
asaf
roaming
garey
ily
yishay
quadratic
product
pr
directories
mansour
lookups
prevailing
probed
xd
polynomial
expected
signature
eia
lasting
websites
guessed
identier
recursive
calls
seek
expression
cardinality
divide
defective
sx
presently
aects
advisor
newfoundland
predened
expected paging
conference call
cells paged
call problem
mobile devices
mobile device
minimizes expected
rst round
expected number
k cells
last k
location area
one mobile
cell j
strictly convex
wireless links
c cells
xr e
dynamic programming
mobile users
e times
lemma 5
location management
base station
located among
product y
quasipartition problem
paging across
paging equal
xr m
wireless conference
base stations
proposition 4
np hard
delay constraints
ciently nd
round r
performance ratio
convex optimization
pages cells
wireless system
multidimensional convex
minimal expected
establishing wireless
approximation solution
mobile telephony
telephony systems
oblivious algorithms
location areas
search theory
page cells
may page
expensive wireless
paging strategy
contains cells
length d
conference calls
m 1
quadratic assignment
two mobile
e ciently
e k
cellular systems
approximation algorithm
right side
family f
d c
partition problem
conference call problem
number of cells
minimizes expected paging
devices are found
strategy that minimizes
last k cells
nd a strategy
strategy of length
least one mobile
device is located
one mobile device
sizes of groups
set of cells
bound the product
strategies of length
expected paging equal
chances of nding
among the last
expected paging across
problem is np
problem of establishing
e ciently nd
subset of cells
lemma 5 4
need to search
e d c
units of time
mobile telephony systems
cells to page
boundary of h
number of devices
minimal expected paging
cells are paged
multidimensional convex optimization
page the last
equal to lb
minimizes the expected
expensive wireless links
across all strategies
wireless conference calls
value of expected
use the inductive
establish a call
xr m 1
establishing wireless conference
devices are located
two mobile devices
nding all mobile
among all strategies
reporting and paging
proposition 4 1
unit of time
quadratic assignment problem
personal communication systems
lemma 5 3
proposition 4 2
lemma 3 1
value of e

corpus/krapavin2000-test/608119.txt
classiers
mdts
meta
mdt
classier
cdp
stacking
attributes
bla
odts
scann
bagging
predictions
voting
learning
boosting
classication
vote
predicted
trees
induced
expertise
base
cml
odt
ordinary
diversity
signicantly
ltree
tac
toe
decision
hypothyroid
hepatitis
soya
diabetes
echocardiogram
ionosphere
ensembles
wine
waveform
glass
combiner
tic
correlation
classifiers
inducing
dierent
training
breast
entropy
plurality
german
bridges
australian
combining
accuracy
chess
improvement
condence
conf
iris
td
heart
prediction
leaf
insignificant
distributions
car
nn
siers
induce
clas
bayes
probability
cdps
weka
impurity
outperform
domains
comprehensible
certainty
propositional
signicant
areas
balance
knn
combine
nearest
stratied
classi
errors
correlated
frameworks
stacked
naive
modication
mining
cascading
dependence
cd
worse
pruning
dierence
brazdil
lml
gama
maxprob
aml
accuracies
uci
ensemble
info
classied
appendix
image
discriminant
regression
weight
arbiters
classications
losses
rst
ve
leaves
neighbor
density
error
ect
condent
expressive
na
validation
attribute
pavel
dierences
twenty
repository
species
predicting
votes
comprehensibility
induces
classify
identifying
concise
vs
post
ilp
asterisk
predicts
select
slope
fold
endfor
settings
cv
suite
dened
paired
renement
constructing
calculate
bernard
signicance
cn
conquer
unseen
tree
art
wins
neural
pred
cross
calculated
split
expressiveness
avg
returned
enko
domingo
ibl
base level
level classiers
meta level
level attributes
meta decision
decision trees
class probability
level classier
combining classiers
error correlation
relative improvement
data set
induced using
ordinary decision
mdts induced
classier c
level learning
learning algorithms
accuracy improvement
level data
multiple classiers
class value
tic tac
tac toe
distributions predicted
select best
combining multiple
probability distributions
predicted class
relative areas
cdp bla
class values
signicantly worse
ordinary attributes
bridges td
insignificant significant
breast w
using cdp
probability distribution
signicantly better
k nn
plurality vote
mdt leaves
balance breast
chess diabetes
trees mdts
distribution properties
diabetes echocardiogram
short line
decision tree
line density
voting schemes
class distribution
example x
learning algorithm
image ionosphere
hypothyroid image
iris soya
soya tic
trees induced
ionosphere iris
classiers c
w bridges
level classifiers
toe vote
wine insignificant
td car
echocardiogram german
constructing ensembles
vote waveform
glass heart
classication errors
given example
waveform wine
german glass
car chess
hepatitis hypothyroid
australian balance
classifiers australian
classiers induced
heart hepatitis
attributes used
data sets
voting scheme
set m
improvement achieved
see table
dierent learning
attributes bla
significant figure
original base
conf 1
tree induced
mdt induced
classication error
mdt cdp
density 5
c 1
naive bayes
trees vs
machine learning
table 6
set l
relative accuracy
c j
conf 2
distribution predicted
using class
error c
cdp set
inducing meta
stacking framework
learning mdts
odts induced
current subset
values predicted
combine classiers
using bla
maximum probability
base level classiers
meta level attributes
meta decision trees
base level classier
class probability distributions
level data set
meta level data
ordinary decision trees
areas of expertise
class probability distribution
tic tac toe
base level attributes
combining multiple classiers
meta level learning
data set m
mdts induced using
set of meta
probability distributions predicted
balance breast w
decision trees mdts
short line density
tac toe vote
soya tic tac
toe vote waveform
bridges td car
hepatitis hypothyroid image
w bridges td
breast w bridges
wine insignificant significant
german glass heart
image ionosphere iris
glass heart hepatitis
level learning algorithms
ionosphere iris soya
australian balance breast
echocardiogram german glass
car chess diabetes
heart hepatitis hypothyroid
boosting and bagging
level classier c
hypothyroid image ionosphere
diabetes echocardiogram german
waveform wine insignificant
induced using cdp
vote waveform wine
td car chess
level classifiers australian
base level classifiers
classifiers australian balance
iris soya tic
chess diabetes echocardiogram
correlation between base
meta decision tree
ensembles of classiers
see table 6
set of base
decision trees induced
class distribution properties
decision tree induced
decision trees vs
original base level
used to induce
insignificant significant figure
line density 5
achieved with mdts
dierent learning algorithms
shows that mdts
examples in l
sets of meta
diversity of errors
relative accuracy improvement
single data set
level attributes bla
class values predicted
boosting of decision
two base level
used for classication
classiers with mdts
certainty and condence
domains and signicantly
area of expertise
induced with mlc4
highest class probability
bagging of decision
base level learning
level classiers induced
level classiers c
method for combining
accuracy of mdts
ect the certainty
level attributes used
base level predictions
density 5 0
bagging and boosting
one data sets
linear regression line
twenty one data
degree of error
side of figure
used to classify

corpus/krapavin2000-test/1024484.txt
csp
membership
rules
consistency
constraint
arc
equality
chr
krzysztof
monfroy
apt
rule
unk
domains
adder
waltz
ecl
propagation
labeling
allen
eric
uhwirth
elan
satisfaction
notions
neg
junction
programming
valid
generation
dnot
solvers
xor
af
predefined
ps
scenes
pos
logic
polyhedral
consistent
gh
enot
msign
closed
arity
constraints
gc
var
arrow
ternary
cb
fork
ih
boolean
relaxation
fr
viewed
base
extends
claire
temporal
permutation
ge
overlaps
cons
gamma
seconds
compound
parametrized
jh
ffl
cd
ef
atomic
solver
disequality
hentenryck
ai
lying
ab
confine
fag
coincides
respective
valued
tuples
feasible
fuzzy
query
triples
hc
winston
assignment
bool
clarify
usefulness
brand
hj
imp
inconsistency
notion
language
ed
characterize
computations
retained
cg
validity
cardinality
coincide
mains
shadows
castro
contradiction
conjunction
subsequence
minimal
hg
enforce
equivalence
weak
participate
equals
weaker
formulas
sebastian
page
room
relations
ba
schedulers
translated
premise
abbreviate
unifies
additionally
virtue
production
eg
truth
implication
rewrite
built
prolog
hi
domain
fe
bc
iff
concerning
rigotti
forgy
beek
feasability
ringeissen
frhwirth
mackworth
borovansky
kirchner
luger
pedrycz
abdennadher
tsang
mohr
laburthe
caseau
schaerf
unavoid
demons
masini
codognet
gomide
action
syntax
shall
automatically
signs
entirely
assignments
suffices
equality rules
membership rules
rule consistency
constraint programming
rules generation
arc consistency
constraint c
rule based
membership rule
based programming
rule consistent
generation algorithm
krzysztof r
r apt
programming viewed
eric monfroy
csp p
arc consistent
constraint propagation
d x
d 2
full adder
local consistency
explicitly given
gamma gamma
minimal valid
equality rule
finite domains
f c
valid equality
constraint satisfaction
csp base
algorithm generated
ps e
variables x
c ffl
x 6
variable x
end end
boolean constraints
consistent w
fr uhwirth
polyhedral scenes
constraint logic
o m
satisfaction problems
domains d
propagation rules
respective domains
current domain
y z
arbitrary arity
predefined explicitly
allen 1983
small finite
chr rules
describing polyhedral
predefined constraints
logic programming
o b
valued logic
b o
tuples d
following table
p based
d o
given constraints
rules r
rule r
x y
finite constraint
hand x
permutation c
zero zero
basic constraints
gamma dnot
valid rules
table x
adder constraint
ffl given
b m
csp based
given finite
handling rules
repeated application
m b
programming language
constraint handling
element d
rules generation algorithm
rule based programming
krzysztof r apt
equality rules generation
d 2 c
constraint programming viewed
viewed as rule
apt and eric
membership rules generation
sequence of variables
rule a x
domain of x
x i 6
ecl i ps
consider a csp
r t base
rule consistent w
generation algorithm generated
membership rule consistent
x y z
consistent w r
ffl we call
explicitly given constraints
approach to constraint
valid equality rules
valid for f
form a x
valid for c
types of rules
type of rules
constraint satisfaction problems
constraint logic programming
gamma gamma gamma
notion of local
c is based
c is closed
based on base
consistency and arc
respective domains d
small finite domains
domain of y
constraints of arbitrary
predefined explicitly given
describing polyhedral scenes
b d o
closed under r
csp p based
rules and membership
d o m
p is arc
given a constraint
rule a b
variable x j
p is based
c of p
r for e
following table x
explicitly given finite
minimal valid equality
consider a constraint
table x y
f c ffl
extends the rule
end end end
var of cardinality
gamma gamma dnot
full adder constraint
notions of local
ffl we say
tuples d 2
consistency for constraints
m s f
rules are considered
based on e
constraint handling rules
set of rules

corpus/krapavin2000-test/614405.txt
subdivision
bicubic
extraordinary
surface
catmull
mesh
patches
clark
eqn
surfaces
spline
faces
vertices
patch
forces
valence
shape
deformable
3d
vertex
stiffness
damping
meshes
shapes
smooth
face
nurbs
rectangular
topology
qin
physics
mass
spring
fitting
subdivided
limit
fig
mri
geometric
motion
caudate
fitted
energy
deltat
freedom
terzopoulos
genus
matrices
polyhedral
butterfly
graphics
degrees
modelers
modeling
force
recursive
vemuri
nonrigid
visualization
assembled
brain
infinite
sculpting
deforms
hong
depicts
slices
recovered
interactive
normal
enclosed
recovery
tension
differential
wesche
sabin
conformation
zorin
styling
baba
celniker
nucleus
chhandomay
duan
chaikin
cerebellum
balloon
anvil
gerold
mandal
superscript
dynamic
analytic
fit
recover
irregular
inflation
bulb
haptic
offspring
doo
positions
old
image
incident
boundary
formulation
functionals
splines
lagrangian
workbench
responsive
interpolation
dynamics
aforementioned
multiresolution
matrix
multilevel
green
interactively
equilibrium
initialized
interpolates
ye
reconstruction
parametric
polygonal
smoothness
arbor
shells
welch
symposium
cortical
kinematics
schemes
november
recursively
continuity
solid
around
nodal
seth
subsections
dr
quantities
dyn
michigan
governing
levin
adaptive
edges
concatenation
hierarchical
criteria
fair
derivation
initialization
topologically
defining
physical
united
volume
interpolating
synthesized
ann
siggraph
assigning
deformations
discontinuities
animation
convergent
enumerating
edge
deformation
curvature
tangent
evolution
coordinate
thin
parameterized
scan
coordinates
jacobian
eigenvalue
gossard
droske
roughness
schroder
overstruck
sagittal
zhengyi
storry
amicis
denggao
limit surface
catmull clark
initial mesh
bicubic patches
clark subdivision
subdivision surfaces
b spline
arbitrary topology
subdivision surface
local subdivision
extraordinary points
subdivision scheme
extraordinary point
control mesh
bicubic b
surface model
dynamic model
extraordinary vertex
dynamic subdivision
control vertices
smooth surface
november 10
recursive subdivision
subdivision rules
physics based
control points
new dynamic
free form
based forces
subdivision around
special element
deformable models
hong qin
stiffness matrices
spring forces
subdivision schemes
infinite number
range data
shape recovery
fitted model
spline surfaces
extraordinary vertices
normal elements
normal element
bicubic patch
dynamic catmull
geometric modeling
data points
spline patches
bicubic surface
eqn 17
new face
mass damping
special elements
normal faces
k matrices
subdivision algorithm
subdivision steps
final fitted
rectangular control
initialized model
control point
u v
f f
data set
finite element
image based
shape design
vertex positions
spline patch
recovery problem
smooth surfaces
many bicubic
potential energy
patches around
butterfly subdivision
smooth limit
recover shapes
d nurbs
dynamic surface
mesh m
nonrigid motion
vertices defining
model deforms
subdivision based
control vertex
old vertex
energy functionals
freedom control
near extraordinary
generated b
valence 3
arbitrary genus
global subdivision
generalized coordinates
analytic formulation
face point
patches corresponding
form deformable
subdivision mesh
valence 4
vertex point
computer graphics
m d
finite elements
dynamic nurbs
non boundary
recursively generated
mass matrix
spline surface
fitting process
geometric shapes
surface patch
volume data
based deformable
surface defined
non rectangular
motion equation
catmull clark subdivision
november 10 1997
bicubic b spline
clark subdivision surfaces
dynamic subdivision surface
around an extraordinary
number of bicubic
image based forces
degrees of freedom
may be noted
damping and stiffness
new dynamic model
subdivision surface model
dynamic catmull clark
surfaces of arbitrary
equation of motion
b spline surfaces
f f f
b spline patches
local subdivision around
clark subdivision surface
clark subdivision scheme
final fitted model
shape recovery problem
around the extraordinary
shapes of arbitrary
number of extraordinary
b spline patch
level of subdivision
shown in fig
d and k
number of degrees
bicubic surface patch
local subdivision mesh
range and volume
control vertex positions
new dynamic surface
mesh of arbitrary
form deformable models
free form deformable
near extraordinary points
step of subdivision
bicubic patches around
generated b spline
smooth limit surface
initial mesh m
recursively generated b
number of subdivision
collection of infinite
volume data sets
freedom control vertices
new face point
dynamic surface model
j g 1
based on catmull
vertices of valence
point of valence
develop the dynamic
symposium on solid
given by eqn
b spline surface
range data set
graphics and visualization
data sets using
modeling and applications
number of vertices
e and f
depicts a slice
new face points
shape representation using
clark subdivision rules
size 3 48
forces are applied
using the vertices
continuous image based

corpus/krapavin2000-test/606706.txt
renable
mask
dilation
smoothness
interpolatory
sobolev
exponent
symmetry
mz
quincunx
multivariate
masks
subdivision
matrix
exponents
eigenvalues
interpolating
refinable
lattice
wavelets
satises
nitely
shifts
spectral
hexagonal
isotropic
han
symmetric
invariant
axes
nonnegative
radius
norm
multiplicity
bin
dened
compactly
jia
holder
jj
converges
rs
stable
shall
dene
bhan
group
culty
wavelet
renement
numerically
ualberta
symbol
subspace
quantity
biorthogonal
bivariate
nite
regularity
cients
coe
numerical
cbc
ima
therein
rules
dual
operator
matrices
linearly
det
quantities
joint
alberta
corollary
subgroup
cagd
quotient
di
eigen
cosets
butter
dimension
transition
coset
denition
anisotropic
dyadic
stability
levin
references
spaces
2d
acting
matlab
completes
aided
kr
modulus
cascade
mm
lim
splines
representatives
dim
duality
riemenschneider
ree
teicher
zuowei
igpm
deslauriers
oswald
villemoes
mina
zulti
pinterpolatory
nfg
warranty
nfjj
shen
schemes
3d
zhang
factorization
counting
greatly
family
equivalently
demonstrated
bidimensional
tempered
fredholm
kuk
hogan
dubuc
adi
preassigned
ca
overcome
routines
mention
min
generalizing
dilations
kak
determinants
extraordinary
nonseparable
uniqueness
interpolation
renable function
dilation matrix
smoothness exponent
symmetry group
sum rules
sobolev smoothness
renable functions
z d
b m
algorithm 2
interpolatory mask
multivariate renable
symmetric multivariate
smoothness exponents
matrix m
interpolating renable
lattice mz
mz d
nitely supported
subdivision scheme
r d
full axes
symmetric renable
mask g
matrix 2i
spectral radius
interpolatory masks
v 2k
axes symmetry
compute 2
supported mask
quincunx dilation
order k
d r
bin han
subdivision schemes
multivariate re
m converges
p norm
m j
numerical computation
l p
refinable function
scheme associated
d 2z
computing smoothness
joint spectral
norm joint
transition operator
rs r
compactly supported
general dilation
corollary 3
linearly independent
g 3
hexagonal symmetry
dilation m
subspace v
matrix mask
dilation matrices
renement equation
holder smoothness
quantities m
group h
dimension three
m 2z
mz 2
dual mask
sequence u
g d
interpolatory subdivision
numerically stable
matrix size
m d
m 1
example 4
g r
quincunx lattice
m invariant
mask 2d
2d mask
u 2k
j det
jj 6
p smoothness
isotropic dilation
function vectors
using method
counting multiplicity
nonnegative symbol
order 2r
order 2k
dilation matrix m
rules of order
algorithm 2 1
satises the sum
group with respect
computing the smoothness
multivariate renable function
symmetric multivariate renable
sobolev smoothness exponent
lattice mz d
interpolating renable function
dilation matrix 2i
k a m
method in 25
full axes symmetry
axes symmetry group
v 2k 1
m is isotropic
mask on z
nitely supported mask
corollary 3 2
g d r
subdivision scheme associated
therefore by corollary
sobolev smoothness exponents
exponents of symmetric
mask g 3
mask with respect
algorithm 2 5
norm joint spectral
joint spectral radius
shifts of m
symmetric renable functions
p norm joint
l p r
d 2z d
symmetric renable function
compute the sobolev
p r d
general dilation matrix
theorem 3 1
p a m
m 1 1
quincunx dilation matrices
b is invariant
associated with mask
computing the sobolev
m 2z d
quantities m j
matrix 2i 2
dened in 1
hexagonal symmetry group
account the symmetry
algorithms 2 1
j 2 n
function and 2
using algorithm 2

corpus/krapavin2000-test/628198.txt
kdb
join
leaf
tree
ffl
joins
dimensions
splitting
mbrs
bounding
similarity
rectangles
dimension
merge
sort
epsilon
mbr
split
datasets
tv
subsequences
grid
indices
synthetic
neighboring
dimensional
spatial
regions
gaussian
distance
chunk
traversal
file
self
rectangle
children
node
gap
dataset
norms
dimen
index
images
metric
skewed
funds
overlap
sorted
inadequacies
hb
life
biased
screening
chunks
covered
cpu
buckets
internal
build
neighbors
stocks
ordering
mitigated
screen
faster
multidimensional
directory
atomic
shortcomings
nodes
family
rationale
music
sequences
pages
reads
sliding
disk
emerging
laboratories
metrics
external
seeds
subtree
splits
neighbor
fit
enhancements
traverse
traversing
yes
overlaps
dramatically
varied
mining
sion
bucket
ith
broken
overlapping
narrowed
stitches
geomagnetic
interbrain
unsplit
fflc
reinsert
fastmap
auroral
qbism
utilization
mapped
window
mit
child
hyper
orderings
query
subsequence
uniform
databases
root
norm
gradually
medical
reinserted
screened
sionality
grafted
joined
joining
execution
page
experimented
trees
mb
shaded
dip
narrows
deallocates
manhattan
prelude
scaleup
storage
around
ai
memory
ff
trie
creases
mf
seeded
suddenly
rectangular
pointers
finding
algo
grow
solar
abstractmany
deterioration
daily
aries
qbic
ther
fanout
aix
bytes
sized
branches
interior
forced
converted
tance
sults
scales
lie
multimedia
image
experiment
ffl kdb
kdb tree
r tree
similarity joins
sort merge
high dimensional
leaf node
dimensional points
ffl distance
leaf nodes
level sort
bounding regions
join x
similarity join
bounding rectangles
neighboring leaf
self join
build time
dimensional similarity
tree family
within ffl
tree e
tv tree
merge r
performance gap
join test
index structure
dimensional space
distance metric
current indices
epsilon tree
traversal cost
local ordering
k d
multi dimensional
b tree
grid file
x tree
execution time
k dimensions
split dimension
gap increasing
time sequences
splitting dimension
non self
tree figure
join algorithm
e k
execution times
every dimension
d b
spatial similarity
self joins
space covered
extended bounding
tree gaussian
atomic subsequences
bounding rectangle
merge algorithm
points whose
join time
global ordering
internal node
internal nodes
whose values
merge join
gaussian distribution
time epsilon
ff dimensions
neighbor leaf
sub images
external file
ffl chunk
sort dimension
emerging data
hb tree
similar sub
epsilon 2
dimensional data
skewed data
main memory
times faster
real life
first k
o cost
similar time
nodes within
least ffl
join result
d tree
every leaf
tree 4
time dimension
new index
second dataset
node becomes
data points
synthetic data
l 2
two leaf
finding similar
join procedure
cpu cost
mining applications
node x
dimension 2
minimum bounding
becomes full
points within
ffl kdb tree
number of dimensions
level sort merge
high dimensional points
within ffl distance
r tree e
e k d
tree e k
high dimensional similarity
sort merge r
dimensional similarity joins
neighboring leaf nodes
r tree family
merge r tree
d b tree
k d b
number of neighboring
number of points
b tree figure
points whose values
performance gap increasing
sort merge algorithm
used for splitting
self join x
b tree gaussian
dimensions are used
first k dimensions
multi dimensional space
problem of finding
high dimensional data
number of neighbors
joins on high
epsilon 2 level
similar time sequences
splitting a node
time dimension 2
execution time epsilon
using the ffl
values of ffl
emerging data mining
cost for internal
node becomes full
time epsilon 2
execution time dimension
non self joins
new index structure
dimensions for splitting
leaf nodes within
r tree 4
nodes within ffl
x i join
neighbor leaf nodes
dimension 2 level
performance on synthetic
pairs of points
k d tree
fit in memory
performs the join
leaf node x
pairs of similar
two leaf nodes
data mining applications
value of ffl
sort merge join
tree and r
synthetic and real
every leaf node

corpus/krapavin2000-test/607896.txt
evolutionary
wcet
sa
timing
categorizations
cache
fitness
generations
instruction
analyzer
caches
bcet
individuals
longest
population
testing
mutation
cycles
recombination
schedulability
loop
reinsertion
bubblesort
temporal
shortest
static
caching
loops
extreme
defense
mueller
hit
offspring
miss
execution
associativity
flow
predictions
railroad
gnat
kiran
preemptive
hardware
instructions
worst
trio
portability
loc
calculator
misses
calling
frank
permissible
chapter
simulator
deadlines
compiler
estimates
calculated
references
conflicts
systematic
matrices
stopping
seth
correctness
reproduction
uncached
benz
rotenberg
daimler
kaustubh
aravindh
anantaraman
instrumentation
genetic
gcc
electronics
datum
regard
risc
pipeline
harman
crossover
yifan
ipx
insufficiently
dfa
cles
patil
iterations
cy
multitude
program
cached
processor
prediction
afterwards
paths
optima
toolbox
cycle
generation
portable
confidence
software
assuring
edf
tighter
multiplication
examination
inner
simulation
safe
procedures
graphics
child
analytical
programs
matlab
recommend
executing
et
tester
coverage
logical
interrupt
quantify
thoroughly
overhead
fit
categorization
embedded
stopped
adjustments
optimum
timed
zhu
measurements
outer
diversity
pipelining
parents
header
procedural
nested
sys
configurations
selection
inversely
missed
conservative
addresses
deadline
categoriza
popula
expenditure
bination
retargeting
preheaders
vpcc
mandrioli
fittest
sporadically
regehr
creased
dasarathy
brylow
asymptoted
sibin
substantiated
mutating
decls
pohlheim
timum
vpo
binkley
brightest
dudani
execution times
evolutionary testing
time systems
timing analyzer
real time
longest execution
extreme execution
temporal behavior
execution time
evolutionary algorithms
static cache
timing analysis
static analysis
schedulability analysis
test object
timing constraints
loop level
case execution
control flow
test data
cycle level
temporal correctness
best worst
actual execution
cache simulation
flow information
cache simulator
frank mueller
test objects
evolutionary computation
shortest execution
best case
logical correctness
worst case
data flow
instruction categorizations
systematic test
timing tree
time environments
worst best
bubblesort algorithm
testing real
timing predictions
remaining associativity
associativity levels
input parameters
test methods
caching behavior
run times
cache behavior
path analysis
static timing
population size
evolutionary optimization
sa approach
testing et
test program
shortest run
calling structure
test datum
et approach
time determined
input situations
kiran seth
defense electronics
gnat gcc
function instance
times determined
discrete recombination
fitness values
address calculator
evolutionary algorithm
data caches
entire program
current work
instruction cache
data references
first miss
specified timing
existing test
analytical method
stopping condition
cache state
instruction caches
first hit
processor cycles
test programs
call graph
two methods
random testing
first misses
high fitness
driven software
mutation probability
since instruction
miss hit
analysis sa
cycles results
program lines
real time systems
extreme execution times
longest execution time
actual execution times
behavior of real
sa and et
number of generations
longest execution times
static cache simulation
case execution time
instruction and data
shortest execution time
shortest and longest
testing the temporal
method of static
worst best worst
static cache simulator
multiplication of matrices
testing real time
real time environments
remaining associativity levels
bcet and wcet
best worst best
control flow information
worst case execution
n a n
best case execution
static timing analysis
determined by sa
evolutionary testing et
execution time determined
case and best
execution times determined
shortest run time
executing the test
analysis and evolutionary
specified timing constraints
case execution times
provides the means
number of input
data flow analysis
obtain high fitness
calculated by sa
time environments may
temporal system behavior
actual running system
support for testing
use of formal
constraints of real
methods to verify
run times possible
timing constraints specified
within the control
important analytical method
test methods shows
afterwards the new
actual real time
extreme run times
static analysis sa
bottom up within
verify timing constraints
individuals are selected
execution times obtain
lack of support
development of real
method for assuring

corpus/krapavin2000-test/1024429.txt
pictorial
appearance
image
iconic
locations
posterior
energy
location
erent
articulated
configuration
parts
matching
images
ij
minimization
training
covariance
di
chamfer
recognition
sampling
connections
joint
configurations
gaussian
likelihood
deformable
foreground
object
grid
faces
joints
deformation
pixels
match
occluded
ml
learned
vision
ciently
foreshortening
fischler
elschlager
parent
rectangle
estimate
learning
body
filters
spring
statistical
pose
cient
human
people
root
mst
mahalanobis
convolution
torso
orientation
vertex
mises
snakes
tracking
estimation
bodies
matches
transformed
ji
seeing
children
distance
prior
transform
viterbi
desktop
arm
mouth
ideal
generic
depth
background
diagonal
angles
visual
corner
erence
occlusion
connection
hausdor
erode
subtraction
nose
sample
eye
costs
distributions
child
indicator
objects
revolute
detections
pupil
limbs
discrete
finding
specifies
connecting
imprecise
arranged
template
formulation
arg
picking
bayesian
geometric
relationships
map
von
noisy
silhouette
articulation
eigenspace
stretching
face
patches
spatial
detect
binary
told
nearby
connected
segmentation
corners
tree
leg
eyes
hypotheses
heuristics
features
convolving
ambiguities
informative
border
equation
position
likelihoods
rigid
leaf
cult
doesn
motion
measuring
learn
flexible
positions
count
measures
samples
decisions
transforms
agree
transformations
modeling
sampled
categorization
matrix
shapes
cylinder
generative
detecting
derivative
restricting
separable
distances
coarse
overlap
probability
intuitively
discretization
orientations
quality
peaks
marginal
parameterized
counts
indices
markov
detection
limb
rosales
pinz
coughlan
spherically
jianzhuang
occlude
pictorial structure
pictorial structures
v j
energy minimization
di erent
possible locations
location l
training examples
part v
structure models
best location
matching results
l j
d ij
appearance parameters
object configuration
human body
posterior distribution
p l
distance transform
statistical framework
connected parts
iconic representation
best match
minimization problem
e ciently
map estimate
individual parts
transformed space
binary images
two parts
o h
cient algorithms
deformation costs
ml estimate
object configurations
connection parameters
energy function
part based
e cient
binary image
optimal location
covariance matrix
part models
transformed locations
relative locations
deformable configuration
ideal relative
matching algorithms
object recognition
minimization algorithm
learned model
diagonal covariance
l r
maximum likelihood
depth d
image given
appearance models
joint distribution
model parameters
multiple good
background subtraction
iconic indices
child v
erent modeling
five parts
structure model
map estimation
foreground pixels
structures approach
like connections
statistical formulation
chamfer distance
prior distribution
gaussian distribution
spring like
generalized distance
modeling schemes
single part
good matches
novel images
articulated objects
binary decisions
mahalanobis distance
object location
distance transforms
dynamic programming
b j
computer vision
quite di
indicator function
vision v
vertex v
generic recognition
estimation procedure
desktop computer
parts connected
image rather
border area
ij l
pairs of parts
pictorial structure models
connections between parts
energy minimization problem
e cient algorithms
sample a location
model the appearance
p i l
energy minimization algorithm
form a tree
likelihood of seeing
location of part
l i l
o h 2
pair of connected
spring like connections
child v c
location of v
pictorial structure model
di erent modeling
location for v
fischler and elschlager
b j l
pictorial structures approach
erent modeling schemes
number of possible
problem of finding
h 2 n
finding the best
quite di erent
form of p
shown in equation
part v j
von mises distribution
locations of parts
connected by flexible
models from examples
replacing the min
position of one
collection of parts
relationships between parts
ji l j
parts are connected
b c l
placed at location
parts are occluded
distribution of l

corpus/krapavin2000-test/614361.txt
animation
implicit
deformations
skeletons
contact
deformable
surfaces
collision
skeleton
surface
volume
blending
interpenetration
forces
elastic
substances
collisions
sti
layer
substance
soft
deformation
animating
field
fusion
particles
bodies
inelastic
motion
ness
articulated
friction
blend
territories
elasticity
particle
isosurface
rigid
radial
flesh
coated
solids
characters
compression
layered
separation
colliding
erent
graphics
preservation
unwanted
bryan
propagation
physically
object
brien
deformed
character
force
modeling
fluids
animations
di
skin
sampling
sample
animated
coating
goktekin
intercollisions
tolga
klingner
response
variations
mass
detection
siggraph
volumes
gradient
contributions
clay
transverse
deforming
meshes
contacts
displacement
cani
paule
disconnected
smooth
region
feldman
deforms
tog
objects
visualization
reaction
shapes
cient
detected
fig
damping
ji
solid
interactive
fluid
locally
pieces
marie
influence
fiction
coats
alexis
grabbed
bargteil
lennard
skele
angelidis
pliers
haptics
compactness
shape
contributing
slope
frames
breathe
detailing
respiration
dilorenzo
celly
bara
bhrigu
alteration
floaters
lobb
repulsion
melt
interpenetrations
territory
nixon
boxes
james
depicted
animator
kitchen
inertia
eurographics
behaviors
convincing
chiu
voxels
attraction
zordan
controlled
controlling
flexible
opposite
displayed
pentland
isovalue
thickness
sudden
ects
precise
geometric
infinitesimal
nodal
ent
collide
sectional
defining
massachusetts
controller
boston
fields
inside
material
piecewise
adam
undergo
exacerbated
grenoble
ers
coherence
dynamics
3d
jing
qin
attenuation
rendering
correspondence
jones
zone
spheres
hua
particularly
simplified
falling
implicit layer
implicit surfaces
collision detection
implicit surface
base structure
sti ness
contact surface
sample points
field function
exact contact
field functions
contact surfaces
volume variations
interpenetration region
field contributions
deformable models
applied forces
contact modeling
response forces
physically based
particle system
volume preservation
blending graph
local volume
skeleton territories
soft substances
constant volume
unwanted blending
point skeletons
di erent
implicit object
soft substance
james f
collision processing
soft inelastic
relative motion
smooth surface
elastic behavior
articulated skeletons
linear elasticity
deformable bodies
processing collisions
implicit formulation
inelastic substances
controlled blending
field term
skeletons coated
deformation field
characters made
character animation
o brien
time step
point p
deformable objects
computer animation
f o
section iii
local coordinate
acm siggraph
bryan m
colliding bodies
m klingner
model contact
implicit flesh
four frames
compression field
bryan e
volume variation
surface around
tolga g
erent skeletons
transverse propagation
cient collision
friction forces
blending list
field terms
simplified characters
force r
fusion threshold
k a0
animation step
along contact
local volumes
propagation region
substances capable
precise contact
volume control
e feldman
g goktekin
articulated structure
modeling soft
computer graphics
f p
iii d
models v
adaptive sampling
purely geometric
p ji
blend together
non linear
graphical models
using implicit
volume v
layered construction
deformable model
separation and fusion
f o brien
exact contact surfaces
james f o
field s gradient
articulated skeletons coated
soft inelastic substances
correspondence between applied
physically based model
made of articulated
next time step
set of sample
section iii d
local volume v
inelastic substances capable
used for collision
k a0 w
field function f
modeling soft inelastic
coated with implicit
smooth surface around
tolga g goktekin
along contact surfaces
precise contact modeling
separation or fusion
cient collision detection
forces and deformations
using implicit surfaces
e cient collision
bryan e feldman
bryan m klingner
radius of influence
capable of separation
surfaces between colliding
di erent skeletons
graphical models v
equations of motion
detection and response
transactions on graphics
graphics tog v
marie paule cani
depicted in figure
order to generate
controlling the volume
collisions between pairs
hong qin haptics
generate exact contact
generated by skeletons
soft object model
animation of simple
models using implicit
way of modeling
brien bryan m
particularly well adapted
motion and deformations
lennard jones forces
k f p
e feldman james
fluid based soft
jing hua hong
animating soft substances
displacement of p
j s gradient
local sti ness
lobb a fluid
exact contact modeling
moves and deforms
animation kitchen fiction
instance a rigid
object model ieee
fusion under compression
local volume variations
precise collision detection
inside outside function
away by pliers
non linear elasticity

corpus/krapavin2000-test/631218.txt
printer
unity
laptop
mobile
receiver
sender
statements
reactive
reacts
disconnection
transient
increment
roman
catalin
gruia
inhibit
mobility
statement
driver
mccann
history
interactions
synchronization
disengage
reconfiguration
superposition
bit
disconnected
picco
abstractions
sharing
queue
coordination
gian
guard
murphy
location
engage
pietro
status
assignment
disengagement
wireless
compositional
actions
amy
inhibited
action
synchronized
composition
mascolo
inhibitions
engagement
idlei
program
co
atomic
transaction
decoupled
flag
reactively
csp
xx
automata
shared
declare
month
reactions
interleaved
phase
hoare
ed
coselection
expressing
fqg
constructs
reasoning
services
quantification
xb
lime
cecilia
params
programs
interaction
logic
modular
abstraction
weakly
superposed
participants
tosem
isolation
propagate
vol
express
software
semantics
reconnection
hosts
propagation
idle
fair
interleaving
execute
limerick
connectivity
vari
recording
ireland
engineering
synchronous
consensus
predicate
luiz
filesystems
newloc
wermelinger
actionka
frgs
fpgs
fiadeiro
coexecution
idleg
payton
triple
propagated
methodology
guards
appending
located
medium
designers
telephone
simultaneous
dependent
mechanisms
registration
ables
print
concurrent
union
namespaces
reset
scheduled
axiomatic
communication
predicates
executing
indirectly
assign
safety
reaction
synchronizing
connection
executed
agents
execution
coarser
operationally
lf
reintegration
jamie
liveness
communicate
transparency
ha
false
interference
augmented
quiescent
inhibition
sf
rendezvous
nization
documents
clauses
style
directional
specify
modularity
underlying
guessed
falsified
programmer
compose
failures
transmission
sides
host
items
asymmetric
sigsoft
aware
serialized
reasoned
julien
printer q
laptop q
q printer
mobile unity
standard unity
reactive statements
reactive statement
mobile computing
catalin roman
q laptop
gruia catalin
interactions section
receiver bit
program sender
assignment statements
software engineering
transient sharing
mobile components
sender bit
underlying program
b y
non reactive
b increment
proof logic
state satisfying
context dependent
receiver history
compositional programming
false reacts
program receiver
co located
satisfying p
pietro picco
programming abstractions
gian pietro
l murphy
roman compositional
o automata
location dependent
month 1998
amy l
statement would
x month
vol xx
x b
sender receiver
input actions
hoare triple
new statements
value written
engineering vol
history sequence
output actions
status laptop
inhibit b
reactive propagation
ed b
initially assign
phase variable
phase idlei
guard b
picco gruia
r inhibit
phase idle
unity superposition
program composition
unity program
q reacts
current location
shared variable
program variables
two programs
two statements
earlier example
fixed point
shared variables
right hand
wireless communication
receiver may
hand sides
variable bit
among mobile
components must
distributed consensus
xb y
increment ed
length receiver
coordination constructs
j mccann
cecilia mascolo
fair interleaving
unity programs
true reacts
program union
statement synchronization
connection status
system sender
mobile setting
underlying variables
expressing reconfiguration
unity union
triple notation
non mobile
sender counter
synchronization relationships
ensures q
q printer q
laptop q printer
q laptop q
gruia catalin roman
x b y
printer q laptop
abstractions for mobile
state satisfying p
compositional programming abstractions
gian pietro picco
roman compositional programming
mccann and roman
driver when r
transactions on software
status a x
engineering vol xx
xx no x
reconfiguration and disconnection
non reactive statement
x month 1998
printer q printer
amy l murphy
selected for execution
software engineering vol
notation and logic
b t driver
status laptop q
b t guard
laptop q laptop
picco gruia catalin
pietro picco gruia
forms of synchronization
location and context
mobile computing systems
right hand sides
ed b increment
left hand variables
components are disconnected
phase when r
f true reacts
statement is scheduled
every value written
non reactive statements
f false reacts
peter j mccann
decoupled and context
among mobile components
system sender receiver
b t r
sequence of boolean
length receiver history
pietro picco amy
increment ed b
b t phase
hoare triple notation
picco amy l
continue to function
given in equation
y a x
methodology tosem v
engineering and methodology
capable of expressing
software engineering p
must be added
june 04 11
allowed to execute
provides a mechanism

corpus/krapavin2000-test/627878.txt
descriptors
phi
cdnf
boolean
descriptor
server
servers
directory
similarity
query
atomic
rdnfs
documents
radecki
rdnf
rb
cisi
ra
distributive
spearman
queries
compact
homer
descriptions
indie
cdnfs
danzig
coefficient
services
ranking
usc
law
tq
jaccard
discovery
expressions
confidence
gloss
subtree
subtrees
rankings
measures
rank
retrieval
wais
parse
complexities
resource
calculate
proportion
rc
internet
archie
database
fig
binary
ranks
disjunctive
normalization
cluster
tied
negated
broker
filter
closer
smith
document
keyword
duplicated
trees
expression
similarities
tree
manually
searching
rs
superior
relevant
expansion
administrators
crs
users
client
hit
qj
representatives
parents
child
author
keywords
operators
transformed
experiment
rooted
height
expanded
logical
interval
southern
li
ranked
nfs
transforming
content
head
responses
indexing
expanding
formulations
dataset
centralized
normalized
transform
file
expand
filters
relevance
submit
figs
collect
theta
overlap
root
node
attribute
measure
cd
correlation
nested
operator
conjunctions
klusch
jianguo
ilarities
vanced
outperfroms
sufyan
demote
matchmaking
abstractas
eariler
trb
mcleod
nia
reformed
rashid
hbp
sycara
califor
cyberspace
nyi
demoted
dice
overwhelms
widoff
cormack
larks
minus
sends
parent
generates
descending
spend
nn
generator
feedback
leaves
duplicates
vii
therefor
nih
ffis
brokers
novice
lup
bison
fil
katia
disjunction
managed
collaborative
requests
agents
negation
ests
quantile
ily
compact atomic
atomic descriptor
atomic descriptors
server descriptions
boolean expressions
reduced atomic
similarity measures
boolean expression
resource discovery
relevant servers
binary tree
distributive law
server description
boolean similarity
user query
similarity measure
confidence interval
usc homer
user queries
complete binary
q 2
boolean queries
binary trees
phi computation
danzig boolean
q 1
two boolean
n node
logical operators
directory server
ranking closer
client directory
p descriptors
binary parse
query q
space complexity
spearman coefficient
author smith
internet resource
determine relevant
rank servers
original boolean
tq tr
node binary
phi generates
homer database
server model
server called
space complexities
similarity values
linear binary
descriptor contains
spearman rank
complicated boolean
whose parents
query pair
include 0
rb 2
query 100
compact disjunctive
cisi database
nested boolean
description rc
n server
node complete
information retrieval
disjunctive normal
associated query
individual similarity
servers based
o n
interval r
cluster representatives
user sends
n servers
retrieval systems
directory of services
compact atomic descriptor
reduced atomic descriptors
compact atomic descriptors
boolean similarity measures
time s phi
measures for resource
q and r
number of descriptors
complete binary tree
danzig boolean similarity
li and danzig
phi is superior
two boolean expressions
ra and rb
reduced atomic descriptor
directory server model
client directory server
generates a ranking
jaccard s coefficient
time and space
number of documents
determine relevant servers
linear binary tree
measure s phi
sets of descriptors
n node binary
internet resource discovery
original boolean expression
descriptors that appear
disjunctive normal form
times the theta
calculate s phi
similarity between boolean
queries and server
tq and tr
n node complete
usc homer database
r j v
node complete binary
relevant to query
include 0 5
query 100 server
say with 95
expressions to rdnfs
confidence interval r
server description rc
n server descriptions
n 1 descriptors
rdnfs of q
descriptor of q
binary parse tree
atomic descriptor contains
number of common
number of reduced
list of relevant
query q 1

corpus/krapavin2000-test/1014977.txt
laurent
framelet
wavelet
anti
refinable
symmetric
banks
cients
coe
filter
polynomials
filters
gcd
symmetry
tight
qun
mra
mo
splitting
detm
moments
vanishing
pass
frames
spline
polynomial
generators
orthonormal
han
frame
compactly
proposition
odd
antisymmetric
matrix
z
irreducible
nonzero
cz
shall
riesz
satisfied
ualberta
sq
bank
zeros
necessity
detw
fej
mask
bn
bin
fir
degrees
wavelets
su
daubechies
nontrivial
det
ciency
decimal
sa
alberta
sd
claims
identically
framelets
integer
deduce
multiplying
symmetries
roots
trivial
equations
bhan
haar
math
factorize
sm
multiresolution
chui
factorizing
generates
freedom
impulse
auxiliary
homogeneous
edmonton
ca
er
canada
valued
sibling
cient
bases
unitary
unknowns
sp
discontinuous
normalization
consequently
polyphase
coef
tamir
zheludev
ams
ducible
ficients
dilates
multiwavelets
qquad
valery
petukhov
parity
generator
convention
da
dual
lemma
shifts
averbuch
tempered
selesnick
overcomplete
nonconstant
stimulate
autocorrelation
verify
contradiction
desirable
verified
subband
nonnegativity
denoising
unnatural
parameterizing
cu
multirate
integers
reconstruction
sciences
conjecture
forall
irre
evident
signal
rewrite
calculate
iv
parameterizations
degree
dirac
dyadic
demonstrated
coefficients
remind
amir
classifications
nserc
lectures
motivated
lot
observing
split
sequently
cv
sv
bs
shift
laurent polynomial
laurent polynomials
anti symmetric
framelet filter
real coe
symmetric laurent
tight wavelet
filter banks
pass filters
coe cients
z 0
wavelet frame
high pass
symmetric framelet
even integer
two high
refinable function
wavelet frames
u 1
symmetric tight
polynomial d
matrix splitting
qun mo
vanishing moments
low pass
proposition 2
theorem 2
gcd condition
m z
pass filter
b spline
g z
z z
orthonormal wavelet
z g
p 2n
compactly supported
d z
z 1
linear equations
spline function
r z
z d
v 1
refinable functions
mra tight
p z
z u
every x
polynomial p
bin han
matrix m
wavelet basis
h z
d h
z p
shall present
trivial laurent
nonzero laurent
cz k
two generators
two anti
z 2k
su ciency
z b
z 2
filter bank
step algorithm
b 1
even number
c 1
b z
solution c
four anti
riesz lemma
symmetric high
good vanishing
detm laurent
condition detm
nontrivial irreducible
common zeros
polynomials real
identically zero
q z
z c
l 2
c z
symmetric refinable
exist four
theorem 1
algorithm 2
d 1
auxiliary results
ualberta ca
two symmetric
q 1
real coe cients
framelet filter banks
anti symmetric laurent
high pass filters
tight wavelet frame
symmetric laurent polynomials
symmetric framelet filter
two high pass
polynomials with real
laurent polynomial d
symmetric tight wavelet
symmetry and framelet
filters a 1
splitting with symmetry
han and qun
tight wavelet frames
theorem 2 4
theorem 2 3
symmetric laurent polynomial
low pass filter
z z 1
theorem 1 1
proposition 2 1
polynomial with real
r z z
laurent polynomial p
l 2 r
matrix of laurent
d 1 z
g z 0
system of linear
proposition 2 2
m z 0
b 1 z
z u 1
u 1 z
b spline function
degrees of u
orthonormal wavelet basis
banks with two
polynomials with symmetry
splitting a matrix
must be true
conditions in theorem
generates a symmetric
d with real
every x 1
mra tight wavelet
algorithm 2 5
number for every
follows from 2
p z 0
z b 1
b z b
polynomials a 1
nonzero laurent polynomial
two anti symmetric
equations in 4
trivial laurent polynomial
zeros in c
z g x
framelet filter bank
since a z
x 1 0
b and c
algorithm 5 1
examples of symmetric
z p z
z d 1
integer for every
conditions a b
defined in 2
function of order
four anti symmetric
construction of symmetric
z t since
result on splitting
polynomials real coe
symmetric high pass
good vanishing moments
m be defined
exist two anti
u z u
detm laurent polynomial
low pass filters
p 2n 1

corpus/krapavin2000-test/1027341.txt
yes
mobility
waypoint
border
statistic
mst
uniformity
pstat
eect
tpause
brownian
mobile
deployment
voronoi
hoc
spatial
vmax
ad
delaunay
cells
triangulation
occupancy
pmove
longest
simulations
region
intensity
pause
cell
dierent
stationary
statistics
networks
density
diagram
velocity
vmin
edge
uniform
transmitting
wireless
uniformly
intense
tests
nearest
statistical
node
graphics
motion
center
hypothesis
sample
concentration
neighbor
uence
routing
capacity
simulator
intentional
route
varied
rejected
limit
cellular
outcomes
indistinguishable
resemblance
sharp
vacant
longestnearestneighboredge
tmst
uenced
totalmst
edgelength
mobilescenario
passed
analytical
les
deviation
resembles
graphic
torus
calculated
boundary
nodes
network
cdf
contrary
distribution
random
sim
displayed
theoretical
simu
increment
scenarios
circumvent
moving
signicant
ve
cumulative
corner
square
coverage
approximated
conservation
rejecting
accuracy
tend
move
nal
central
histogram
convergence
subsection
critical
connectivity
visualize
movement
simulation
resemble
lifetime
routes
borschbach
lator
totaldel
totalvoronoidiagramedgelength
nicant
emptycells
impaired
handos
longestmst
longestnn
lmst
bounced
totaldelaunaytriangulationsedgelength
totalvor
nonintentional
nnl
tained
experimental
lesser
anyway
distributions
inaccurate
concentrate
invalid
localized
handbook
tends
cient
sity
evidences
spanners
spanner
bush
vehicular
exacerbates
cross
reported
observations
boundaries
le
su
extreme
arranged
modeled
dsr
perceivable
tribution
geography
conrmed
fect
desti
outweighs
curate
concentrated
dis
accounts
practically
specic
moderate
yes yes
node spatial
spatial distribution
border eect
random waypoint
deployment region
hoc networks
waypoint model
brownian like
limit distribution
mobility parameters
voronoi diagram
ad hoc
edge length
delaunay triangulation
mobile ad
longest nearest
mobility model
total edge
mobility steps
transmitting range
neighbor edge
n 49
n 900
uniformity test
mobility models
statistical tests
experimental density
like motion
n 100
pause time
mst edge
edge statistic
empty cell
statistics considered
occupancy graphics
wireless ad
nearest neighbor
uniform distribution
mobile network
uniformity assumption
theoretical density
critical transmitting
stationary networks
mst voronoi
border rule
way point
distribution generated
node distribution
square cells
total mst
limit distributions
tpause 0
pstat 0
random way
cell statistic
like model
hypothesis h
distributed uniformly
empty cells
point model
hoc network
analytical results
route length
range assignment
two mobility
side 1
like mobility
parameter separately
vmin 0
longest edge
mobile scenarios
vmax 0
deployment area
corner cells
central cells
test accuracy
uniformity tests
triangulation edge
experimental distribution
mobile networks
standard deviation
uniform mobile
next position
n square
distributed nodes
distribution resulting
statistical hypothesis
mobility patterns
mobility pattern
n nodes
initial node
uniformly distributed
dierent values
cellular networks
normal distribution
average value
node spatial distribution
yes yes yes
ad hoc networks
random waypoint model
yes no yes
mobile ad hoc
longest nearest neighbor
total edge length
nearest neighbor edge
diagram and delaunay
brownian like motion
wireless ad hoc
brownian like model
nodes are distributed
networks of size
mst voronoi diagram
way point model
random way point
empty cell statistic
spatial distribution generated
critical transmitting range
set of simulations
steps of mobility
value and standard
uniformly and independently
number of empty
ad hoc network
brownian like mobility
model with dierent
cells of side
size n 49
like mobility model
vmax 0 01
triangulation edge length
test the uniformity
neighbor edge statistic
n 49 n
sample of uniformly
number of mobility
vmin 0 001
varied each parameter
n square cells
delaunay triangulation edge
mst edge length
total mst edge
two mobility models
number of nodes
uniformly at random
distribution of mobile
uniformly distributed nodes
steps of 0
independently at random
rate of convergence
reported in figure

corpus/krapavin2000-test/1036205.txt
mus
unsatis
satis
cnf
horn
formulae
minimally
clauses
subformulae
clausal
inequalities
infeasible
iis
sat
ci
propositional
chandru
hooker
chinneck
integral
subformula
cj
clause
tex
arborescence
bruni
yt
ned
gleeson
renamable
polyhedron
balanced
feasible
sect
farkas
formula
selection
ryan
unsatisfiable
vertex
truemper
kleine
conforti
veri
ip
ow
subtractive
relaxation
nding
inconsistencies
ning
approached
ed
ows
inconsistency
matrix
sassano
tsitsiklis
chandrasekaran
nonzeroes
drown
guieu
aspvall
opportune
bertsimas
dravnieks
gallier
imposing
digraph
contradiction
de
bu
ability
yes
feasibility
kullmann
dowling
ejols
cornu
balancedness
locating
rst
mu
nition
simplex
ir
nes
franco
solvable
xi
infeasibility
icting
arcs
additive
literals
cplex
polynomial
subsystem
exact
star
gelder
ciency
satisfiable
polytope
box
ak
rules
contrary
polyhedra
submatrix
classes
rooted
demanding
irreducible
rounding
incidence
polyhedral
solving
heuristics
literal
truth
composed
zhao
matrices
ax
jointly
removing
fleischner
witha
orcontradiction
arcsof
particularized
postinfeasibility
amatrixa
boros
themus
fellegi
grgoire
piette
lettman
cdric
whish
amaldi
nmnmtime
scutell
litera
slur
reckoned
infea
expecially
maaren
isfeasible
protasi
autarkies
muses
isgivenby
tamiz
swaminathan
fractionary
isinfeasible
mannino
mazure
deciding
verifying
row
van
computationally
compendium
schrijver
ric
matroid
disguised
characterizable
cation
realization
arrows
recognition
detection
strict
solved
integer
unsatis able
mus selection
minimally unsatis
satis able
satis ability
clausal inequalities
ci 1
extended horn
able subformulae
integral point
exact selection
linear inequalities
cnf formula
ip property
exact tex
tex 1
ability problem
linear relaxation
selection problem
box constraints
cnf formulae
de ned
p exact
h vector
propositional formulae
point property
hooker 1991
farkas lemma
renamable horn
ryan 1990
veri ed
underlying system
polynomial time
integer constraints
formula f
one integral
truemper 1998
bruni 2002
easy classes
selected mus
kleine bu
ir h
able subformula
infeasible 7
horn formulae
bu ning
able therefore
extended star
yt b
strict integer
de ciency
inequalities ci
one 1
vector b
form 10
sat problem
property either
clauses corresponding
propositional formula
programming problem
propositional variables
original formula
max sat
linear programming
linear case
linear programs
methods would
property holds
de nition
propositional cnf
dravnieks 1991
formulae verify
world contradiction
positive 1
proposed procedure
ones imposing
rooted arborescence
clause subset
polyhedron 8
subformula mus
help deleting
arrows drown
minimal unsatis
computational experience
relaxation 7
chinneck 2001
minimally unsatisfiable
hooker 1999
irreducible infeasible
inconsistencies produces
real h
arborescence realization
zhao 2002
denote also
clauses jointly
re design
alternative system
minimally unsatis able
selection of minimally
unsatis able subformulae
tex 1 04
exact tex 1
chandru and hooker
satis ability problem
mus selection problem
systems of linear
f is unsatis
p exact selection
contains a mus
integral point property
case of systems
gleeson and ryan
classes of formulae
set of clauses
solving a linear
linear programming problem
inequalities ci 1
corresponding to ci
unsatis able subformula
least one integral
subset of clauses
extended horn formulae
strict integer constraints
one integral point
yt b 0
ip property holds
classes of propositional
kleine bu ning
system of linear
number of clauses
set of rules
conditions of theorem
problem of deciding
whose rows correspond
nding a vertex
dowling and gallier
real world contradiction
checking the rules
correspond to clauses
jointly unsatis able
cnf formula contains
world contradiction detection
consists in nding
real h vector
conforti and cornu
whether a cnf
well de ned
bruni and sassano
guieu and chinneck
clausal inequalities contains
non zero components
locating a mus
general we show
xi 0 1
nd a mus
rules into clauses
additive or subtractive
components will correspond
con icting rules
rules for inconsistencies
negative 0 otherwise
solved by locating
property is veri

corpus/krapavin2000-test/628118.txt
rnn
mealy
sma
dfsta
neural
tlu
sigmoid
analog
nite
encoding
sperduti
moore
nx
weights
activation
automata
exclusive
recurrent
biases
transducer
neuron
encodings
eqs
rst
transducers
prescription
biasless
rank
recursive
bias
discrete
biased
hot
inputs
dtrnn
dierent
undened
fsm
neurons
encode
networks
tree
simulate
dened
starita
sima
mnx
saturation
stable
trees
scaling
alternate
nets
realized
conversion
jm
growing
symbols
gori
frasconi
jg
jj
ik
grow
elman
hammer
nu
formalizations
uppercase
deterministic
alphabet
units
label
su
forbidden
threshold
slower
giles
tolerance
machines
logistic
dimensionality
outputs
layer
strategies
splitting
cient
constructive
ports
simulation
appling
safest
tecnologa
carrasco
ndfsta
prescriptions
reestimates
rederive
unaccepted
spanish
nxk
comision
strickert
transducing
playing
mn
cult
gain
monotonically
ranked
children
barbara
network
accepting
weight
counterparts
inordinately
alessio
micheli
classies
interministerial
ciencia
valence
jacobsson
vectors
dene
enlarging
duced
omlin
abstractrecently
minimization
counterpart
intro
tanh
designate
restatement
adaptive
kremer
tio
aj
arena
symbol
net
transition
limits
frontier
hyperbolic
comma
unaware
schemes
constructions
acyclic
architecture
architectures
accordingly
explore
learning
laid
henrik
collection
widespread
strictly
split
tolerances
fullled
node
max
struc
jw
mapping
style
bj
alessandro
classication
incrementing
operating
letters
classi
ce
tures
kg
syntactical
explored
di
string
marc
ig
shorthand
discrete state
recursive neural
order mealy
nite state
high order
state tree
state rnn
neural networks
order moore
exclusive encoding
sigmoid rnn
activation function
tree automata
rnn using
rst order
one hot
mealy rnn
analog neuron
analog unit
tree transducer
rank m
recurrent neural
output function
next state
moore rnn
deterministic nite
threshold linear
stable simulation
sma 16
zero otherwise
neural network
hot encoding
linear unit
using tlu
analog rnn
time recurrent
activation functions
exist q
scaling factor
output functions
discrete time
lower saturation
growing activation
sigmoid recursive
rnn described
sperduti 17
input tolerance
mealy encoding
biased construction
eqs 23
possible rank
automata dfsta
strictly growing
tree transducers
biased high
order discrete
neural nets
state units
dierent schemes
single layer
weights obtained
state function
state functions
weight values
computational power
function g
input vector
binary input
adaptive processing
binary inputs
w 0
q 0
constructive proof
input vectors
state machines
may easily
two dierent
w m
minimum value
directed ordered
stable encoding
smaller weight
eqs 29
moore recursive
unit tlu
biasless high
simulate dfsta
alternative scheme
state vectors
state high
monotonically growing
language theoretical
state splitting
sperduti 5
unit using
neural architectures
encoding using
encoding tree
suitable minimization
theoretical formalizations
undened otherwise
minimum h
state recursive
mealy nite
nite automata
log mnx
alternate encoding
state version
using sma
order rnn
saturation level
accordingly weights
elman style
section tree
order sigmoid
nx slower
jg x
therefore works
accepting states
rnn encodings
high order mealy
nite state tree
discrete state rnn
rst order moore
sma s construction
recursive neural networks
together with 1
state tree transducer
order mealy rnn
recursive neural network
order moore rnn
recurrent neural networks
discrete time recurrent
time recurrent neural
rnn using tlu
strategies to encode
one hot encoding
exist q 0
slower than log
threshold linear unit
nite state machines
value of h
order mealy encoding
recursive neural nets
next state function
next state functions
tree automata dfsta
sigmoid recursive neural
order discrete time
discrete state units
activation function g
sma s theorem
state rnn using
biased high order
state tree automata
deterministic nite state
collection of m
shown in table
conditions are shown
sma s result
minimum h satisfying
language theoretical formalizations
deterministic nite automata
application of sma
using discrete state
single layer neural
apply our alternate
mealy nite state
result by sma
order mealy recursive
conditions and max
eqs 23 25
state high order
otherwise there exist
values of h
reported for second
moore recursive neural
weights in discrete
rnn using discrete
function is realized
state machines fsm
grow with m
biasless high order
bounded real inputs
mealy recursive neural
automata and recursive
binary input vector
hot or exclusive
discrete state high
minimization of h
dened as undened
operating on binary
second order discrete
explore the application
function and bounded
section tree automata
gori and sperduti
realized as rnn
using no biases
sigmoid rnn 3

corpus/krapavin2000-test/628088.txt
video
query
content
entities
declarative
interval
objects
querying
intervals
generalized
database
retrieval
att
object
attributes
visual
concatenation
semantic
oid
constructive
language
multimedia
entailment
hacid
mohand
sad
mpeg
dense
attribute
indexing
predicate
queries
semistructured
relationships
languages
constraint
symbol
databases
frame
frames
media
sql
audiovisual
satisfiability
sequencing
identities
compression
toumani
farouk
atomic
primitive
exploitation
pred
rule
concatenations
paradigms
textual
sequences
elmagarmid
atom
image
conjunctions
audio
arity
movies
editing
ffl
id
layer
countably
temporal
ahmed
elisa
bertino
videos
expressive
pictorial
interpreted
tv
disjunctions
manipulations
facts
events
constraints
relations
storing
inequality
management
concatenating
integrates
literal
infer
omega
head
mining
tive
vari
modeling
constants
logical
pictures
arithmetic
annotations
maier
scholarly
arslan
digitize
openness
hjelsvold
bilvideo
ovid
rupert
enced
videostar
nonnega
panagiotis
chrisa
polydoros
iller
abstractindexing
oomoto
ediz
aykol
gintervals
midtstraum
meghini
palenichka
tsinaraki
violone
videosql
dexptime
gdkbay
stavros
kazasis
dnderler
pods
styled
fotis
citizen
duration
web
dom
virtual
body
names
fragments
unary
ary
uur
christodoulakis
thematic
disciplinary
worldwide
tanaka
descriptional
umut
zobel
emin
advent
trieval
rokia
avis
hoad
adali
inherent
concrete
periods
template
retrieving
relational
negation
television
brandon
ulusoy
missaoui
bibliographic
anytime
declara
ptime
puter
exploration
advanced
symbols
proposal
semantics
beautiful
attr
mehmet
sigmm
zgr
fcg
evaluable
unsatisfiable
shapes
pairwise
spatial
human
video data
generalized interval
generalized intervals
query language
data model
video sequence
constraint query
order constraints
interval objects
rule based
semantic objects
query languages
set order
video object
based constraint
based query
g entities
querying video
video information
dense order
declarative rule
order inequality
predicate symbol
video frames
video objects
query list
time interval
video content
object identities
among objects
video database
relationships among
generalized time
content indexing
video query
pred d
given video
extended active
frame sequences
mohand sad
range restricted
sad hacid
video databases
dense linear
set constraints
active domain
database systems
video sequences
type d
concrete domain
arity n
constraints involving
database technology
inequality constraints
restricted form
linear order
natural way
o att
g duration
valued attribute
like video
new sequences
simple sql
constraint paradigms
clear declarative
video visual
view video
infer relationships
att 0
new relationships
set functions
content dimension
atomic constraints
primitive atomic
support video
content layer
feature content
primitive constraint
constructive term
special unary
virtual editing
letters stand
important direction
constructive rule
formal rule
hacid farouk
constraint g
interpreted function
interval object
constructive interval
content based
new techniques
first class
variables called
farouk toumani
dom d
concatenation operator
relation contains
relation names
value o
semistructured data
build new
called object
two generalized
ahmed k
k elmagarmid
query involves
involving 2
query answers
declarative graphical
following rule
frame sequence
fix point
semantic layer
new generalized
o 0
body literal
framework presented
interval associated
information represented
video applications
among others
o 2
video data model
based constraint query
generalized interval objects
constraint query language
rule based constraint
set order constraints
objects of interest
based query language
modeling and querying
associated with g
declarative rule based
querying video data
rule based query
relationships among objects
within a video
generalized time interval
linear order inequality
order inequality constraints
extended active domain
much more declarative
mohand sad hacid
dense linear order
expressed as g
used to infer
entailment of conjunctions
compute the answer
objects and constraints
ffl a special
interpreted function symbol
content of frame
formal rule based
object and constraint
sad hacid farouk
linear constraint query
declarative and operational
simple sql like
generalized interval object
declarative and natural
like video query
list all generalized
special unary predicate
build new sequences
constraint query languages
entities of interest
video database management
well as semantic
video query language
fix point semantics
primitive atomic constraints
models and query
feature content layer
constraints involving 2
inherent to video
power and complexity
nature of video
sql like video
hacid farouk toumani
entities the query
set constraints involving
form of set
given video sequence
unary predicate symbol
developed a simple
dimension i e
ahmed k elmagarmid
time interval associated
intervals as well
approach to represent
query we need
values of attributes

corpus/krapavin2000-test/607292.txt
jacobi
enumerator
coset
polarization
polynomials
codes
golay
molien
invariants
designs
weight
enumerators
extremal
codewords
gammadesign
gdd
ozeki
covering
macwilliams
jt
dual
packing
bivariate
assmus
magma
invariant
mattson
octad
gammahomogeneous
series
resp
self
delsarte
simultaneous
divisible
coefficient
sol
wc
cosets
reynolds
gleason
aronhold
polarizations
gammas
gammaset
hammingcomposition
gammasets
bannai
puncturing
combinatorial
polynomial
taylor
homogeneous
bachoc
hamming
wz
reed
joint
na
zx
muller
codeword
combinatorially
christine
congruent
schur
varieties
code
rank
assertion
blocks
outer
groups
correcting
operator
gammaform
bidegree
decresing
gammaforms
michio
suggestively
actes
restatements
wzxy
gammadesigns
monodimensional
eiichi
prange
gammasubsets
issai
congr
choie
gammauples
wzx
emmynoether
lattices
subtraction
algebra
discr
bonnecaze
xix
hironaka
anyways
congress
witt
steel
ematiques
calderbank
group
acting
fixes
monomials
degree
shall
expansion
spaces
putative
leaders
gammaj
coordinate
pb
noticing
chap
aj
equ
shortening
monomial
yields
secondary
modulo
gammat
gammai
elusive
quadruples
injectivity
radius
binary
decomposition
enumerates
combinatorics
counts
matrix
nice
gd
allan
denotations
children
notations
cp
wiley
congruence
contemporary
gf
cumbersome
strengthening
forms
formula
stands
scalar
doubly
owner
standing
vanish
ffi
math
det
incidence
generating
enumerating
belonging
places
substitutions
dm
jacobi polynomials
weight enumerator
self dual
molien series
jacobi polynomial
weight enumerators
covering designs
type ii
given weight
dual codes
simultaneous invariant
ii code
coset weight
generating series
golay golay
extremal type
bivariate molien
distribution matrix
weight hold
polarization operator
polynomials j
joint weight
jacobi forms
assmus mattson
weight distribution
j c
group divisible
finite groups
p sol
outer distribution
combinatorial interpretation
invariant space
reynolds operator
mattson theorem
extremal self
invariant theory
j 8
code c
g 2
two polynomials
binary codes
binary code
degree 40
jt may
seen combinatorially
length 32
coset x
j 16
length 72
j d16
x 44
coordinate place
muller code
r designs
rank parameters
y 28
aronhold polarization
covering design
y 43719104
codewords whose
combination 8
ffi p
length 8
secondary invariants
macwilliams relation
n groups
series f
primary invariants
simultaneous invariants
divisible designs
length n
w z
group g
code obtained
macwilliams formula
collection b
order 192
extremal codes
new rank
w 8
reed muller
covering radius
binary linear
sol e
christine bachoc
following decomposition
dual code
weight 4
simple combinatorial
second assertion
w x
z 6
four variables
algebra system
self dual codes
type ii code
terms of degree
packing and covering
space of jacobi
given weight hold
bivariate molien series
jacobi polynomials j
golay golay golay
design with parameters
bound on b
extremal type ii
joint weight enumerator
extremal self dual
assmus mattson theorem
code of length
codes of length
number of pairs
linear combination 8
simple combinatorial interpretation
hold a 5
contains no word
p sol e
coset weight distribution
cases in length
codewords of every
every given weight
parameters for spaces
coefficient of u
theory of error
outer distribution matrix
formula for jacobi
invariant of g
collection b j
x 44 y
codewords of given
coset x c
combination 8 1
new rank parameters
polynomials j d16
coefficient of w
designs with parameters
group divisible designs
generated by two
enumerator of c
invariant for g
aronhold polarization operator
reed muller code
terms of generating
gives the packing
use the reynolds
w z x
invariants of finite
molien series f
b t c
introduced by ozeki
c of length
shown in 7
group of order
self dual code
codewords of weight
word of weight
group g 2
j a b
blocks of size
may be generated
f u v

corpus/krapavin2000-test/1007765.txt
opt
mistakes
agreements
clustering
clusters
disagreements
ptas
cluster
jc
wrt
mopt
vertex
vertices
edges
clean
agnostic
singleton
cautious
edge
learning
maximizing
triangles
mistake
partition
fw
pick
lemma
moses
incurs
classifier
ja
erroneous
inside
planted
noise
removal
labels
tester
jn
partitions
picked
approximation
negative
median
sided
correlation
picking
agrees
minimizing
xif
guruswami
dissolving
partitioning
lemmas
italic
documents
dense
believes
probability
triangle
affiliations
jzj
whp
venkatesan
doubly
clusterings
charikar
perfect
supscrpt
additive
ij
external
enter
joachims
bonn
thorsten
exponential
disjoint
suffices
maximizes
labeled
density
bj
facility
bad
ments
inline
agree
divide
graphs
entity
items
sc
ccr
fu
formulation
weights
coloring
penalty
np
goodness
shuchig
persson
ailon
myampersandotilde
whizbang
surajit
mjc
uniq
lingas
tkdd
immorlica
ganti
raghav
mwith
ptass
dissolved
fnikhil
nicole
jansson
sarma
tsaparas
lundell
eva
finley
jesper
afresh
alantha
yigal
ently
yael
mellon
veg
deduplication
mia
dessmark
jjc
theroy
giotis
dissolve
charge
firstly
nearly
approximating
notice
testing
please
spectral
weight
polynomial
unsure
mcsherry
gionis
condon
sponding
gnc
avidan
heikki
kaushik
bejerano
newman
hopcroft
chaudhuri
carnegie
aristides
rameter
domly
mislabeled
apx
lies
trying
internal
plus
guess
neighbors
qualitative
random
labelings
avrim
goldwasser
c opt
opt 0
positive edges
good wrt
maximizing agreements
optimal clustering
jc opt
edges inside
vertex addition
negative edges
singleton clusters
minimizing disagreements
mistakes made
c 0
edge labels
agnostic learning
vertex removal
clustering opt
internal mistakes
least opt
external mistakes
least 1
non singleton
jc 0
correlation clustering
divide choose
inside clusters
positive edge
addition step
negative mistakes
factor approximation
ja 0
u v
constant factor
property tester
erroneous triangles
removal step
general partitioning
clusters plus
opt n
addition phase
edge disjoint
u w
gives us
opt k
good partitions
v w
lemma 13
using lemma
edge weights
k median
linear cost
clustering problem
let opt
m 0
removal phase
sided noise
clean cluster
planted partition
wrt c
opt 3
good partition
positive mistakes
algorithm divide
different clusters
cost due
high probability
fully connected
symmetric difference
opt j
doubly exponential
negative edge
edge u
theorem 17
opt denote
median problems
facility location
graph partitioning
graph g
argument similar
random noise
o n
number of agreements
edges between clusters
number of disagreements
fw i g
exponential in 1
number of edges
c 0 j
ptas for maximizing
edges inside clusters
vertex addition step
number of mistakes
good with respect
probability at least
non singleton clusters
inside a cluster
constant factor approximation
vertex addition phase
produce a clustering
density of positive
vertex removal step
positive edges inside
c opt k
clustering opt 0
approximation for minimizing
number of positive
u and v
incurs a cost
plus the number
inside clusters plus
opt n 2
n 2 agreements
learning to match
vertex removal phase
us the following
clustering that agrees
least opt n
w are positive
vertices from c
clusters of opt
clusters in opt
external mistakes made
algorithm divide choose
agrees as much
match and cluster
let c opt
ja 0 j
respect to fw
partition of w
jc 0 j
w 2 c
linear cost function
number of clusters
let opt denote
denote the optimal
number of negative
number of edge
cost of 1
much as possible
edge u v
runs in time
u opt v
clusters and negative
opt the mistakes
pick a w
clustering on g

corpus/krapavin2000-test/629166.txt
dfs
speedup
superlinear
backtracking
processors
sequential
leaf
searched
heuristic
faults
visited
visits
puzzle
backtrack
successors
search
queens
podem
depth
processor
expanded
pruned
gammaqueens
backtracks
subtree
atpg
superlinearity
fl
bounding
htd
instances
visit
ordering
solutions
heuristics
ob
wn
density
efficiency
anomalies
formulations
hacker
regions
tree
pruning
hm
trees
wild
visiting
formulation
root
nodes
satisfiability
speedups
node
branching
densities
circuits
fraction
probabilistic
succeeds
ae
region
advice
karypis
intelligence
serial
multiprocessors
fault
hackers
banded
homogenization
simd
cards
curves
artificial
kumar
average
monien
sublinear
prune
iscas
sliced
randomized
statically
validate
analyzed
overhead
gammafl
happens
circuit
trials
vipin
frontier
balancing
branch
searches
cutoff
bernoulli
analytical
solve
searching
slicing
shallow
dominates
reader
subspace
annals
experimental
uniform
uniformly
multiprocessor
analyses
ordered
expansions
uniformity
validated
balanced
expands
dist
nagy
thedistribution
browne
krauss
symult
chaplin
formany
areconsidered
unexpanded
lintao
shapira
arvindam
deceleration
prunesearch
forsimple
korf
aesequential
dehne
soln
thetheoretical
dibmyampersandmdash
comparethe
upperlimit
fpt
stege
youssef
vineet
okushi
nonattacking
challou
felner
alori
rau
saletore
antreich
isnonuniform
fumiaki
kbfs
taillon
cheetham
ganz
harmonic
hardness
italic
occurrence
identifies
proportional
busy
files
located
leaves
cuts
fundamentals
unstructured
promising
substantially
dynamically
faulty
andrew
gamma
violates
dr
kurt
sunil
bordeaux
parallel dfs
sequential dfs
superlinear speedup
simple backtracking
parallel search
dfs algorithms
leaf nodes
solve instances
space tree
search space
bounding heuristic
average speedup
first search
backtrack search
nodes expanded
ordering heuristic
state space
depth first
nodes visited
sequential search
fl fraction
dfs visits
ob trees
regions searched
speedup obtained
parallel formulations
leaf node
different processors
parallel formulation
heuristic backtracking
parallel depth
n gammaqueens
linear speedup
probabilistic algorithms
space search
search overhead
solution density
randomized parallel
atpg problem
queens problem
solution densities
parallel branch
solution nodes
heuristic information
htd faults
ordered dfs
one solution
left subtree
search tree
communication overhead
parallel algorithm
branching factor
generate tests
experimental results
search algorithms
one processor
artificial intelligence
average number
d gamma
speedup anomalies
n regions
solutions among
nodes searched
expanded node
probabilistic search
processors finds
heuristic makes
total instances
gammaqueens problem
superlinear speedups
dfs algorithm
parallel podem
puzzle problem
processor parallel
recently generated
root node
pattern generation
serial algorithm
w 1
random order
test pattern
case happens
makes correct
wild cards
search problems
simd parallel
heuristic reduces
whole search
gamma fl
n processors
non uniform
bound algorithms
state space tree
depth first search
sequential and parallel
distribution of solutions
searched by different
density of solutions
number of leaf
number of nodes
number of processors
parallel depth first
theorem a 1
sequential or parallel
parallel dfs algorithms
leaf nodes visited
hard to solve
state space search
efficiency of parallel
solution is found
heuristic is available
average speedup obtained
gamma 1 leaf
parallel dfs visits
backtrack search algorithms
formulation of dfs
anomalies in parallel
d gamma 1
easy to solve
finding a solution
test pattern generation
n gammaqueens problem
speedup for parallel
two processor parallel
speedup in parallel
whole search space
algorithms we analyze
average case behavior
solutions are distributed
visited by sequential
hacker s problem
branch and bound
find a solution
near the root
simd parallel computers
finds a solution
theorem 5 3
balanced binary tree
automatic test pattern
number of leaves
trees of depth
non leaf node
analysis in section
solutions then dfs
solutions are uniformly
ordered backtrack search

corpus/krapavin2000-test/614306.txt
gasp
animation
polyhedron
animations
faces
style
atomic
geometric
pluck
ayellet
programmer
colors
visualization
scene
viewer
debugging
graphics
screen
file
button
poly
vert
tal
mesh
programmers
fade
rotate
geometry
inventor
sweepline
text
animated
video
ascii
fading
fades
cones
naive
vertices
objects
camera
char
polyhedra
dobkin
animate
fig
visual
titles
create
int
advanced
hands
obj
visibility
visualizations
movies
creation
undo
cone
visualized
geometer
buttons
visualizing
minnesota
meshes
thumbwheels
balsa
shneerson
plucking
thumbwheel
heapsort
princeton
panel
editing
heap
window
object
motion
polyhedral
visualize
fonts
snippets
default
segments
float
spheres
floats
accompany
cylinders
writer
fourteenth
plane
push
conceptual
created
units
animating
click
views
minneapolis
creator
document
creating
isolate
script
apart
annual
nmax
geometers
blinks
lpr
polyhe
dron
videotapes
medford
examiner
linearpath
zeus
mainloop
color
files
ease
attach
home
holes
united
anima
xxx
videotape
crossno
weizmann
tango
explanations
users
sweep
maria
windows
quick
triangulation
aspects
library
animator
mathematica
stc
elucidate
traveling
electronic
combinatorial
highlight
students
world
days
backwards
green
hooks
motif
tices
concerned
classroom
documents
dimensional
margins
taste
invaluable
cubes
creates
map
explains
rotation
movie
grasp
watch
unit
configurations
experiment
thirteenth
pause
red
facilitates
rectangles
david
primitives
mpeg
annotate
seventeenth
prints
sorting
intersections
remove
interfaces
spin
arrangements
ver
finish
symposium
array
dimensions
yellow
struc
style file
algorithm animation
animation system
atomic unit
atomic units
geometric algorithms
ayellet tal
naive programmer
advanced programmer
computational geometry
dimensional geometric
visibility map
taken apart
add faces
style files
geometry p
geometric objects
three dimensional
conceptual model
advanced programmers
visual aspects
highly complex
two hands
annual symposium
process 1
new faces
text window
visual debugging
p dobkin
gasp supports
unit style
rotate world
control panel
david p
create polyhedron
gasp allows
logical phase
single pluck
process 2
geometric algorithm
animation systems
polyhedron p
combinatorial objects
lines points
get polyhedron
ascii data
naive programmers
finish early
classroom proceedings
ascii style
polyhedron fades
algorithm windows
programmer interface
enables others
unit gasp
end atomic
maria shneerson
push buttons
shneerson ayellet
electronic classroom
level starting
name char
script file
c code
end users
application writer
code includes
objects combinatorial
united states
algorithm implementation
fourteenth annual
computer graphics
line segments
june 07
minnesota united
algorithm animation system
cannot be taken
computational geometry p
symposium on computational
objects that cannot
three dimensional geometric
david p dobkin
supported by gasp
apart with two
dimensional geometric objects
level after level
gasp s environment
visualization of geometric
use it easily
domain of computational
objects combinatorial objects
text and titles
snippets of c
knowledge of computer
others to use
interact and experiment
animation is running
shneerson ayellet tal
gasp s library
maria shneerson ayellet
electronic classroom proceedings
animation the animation
june 07 10
fourteenth annual symposium
system that enables
possible to create
minnesota united states
minneapolis minnesota united
see the animation
facility for geometric
style file b
medford massachusetts united
two hands using
p dobkin ayellet
objects typical objects
system for algorithm
highly complex geometric
line sets point
matter of days
like to experiment
assist the geometer
lines points line
animation is still
nature of geometry
initial line segments

corpus/krapavin2000-test/608686.txt
agent
agents
mobile
message
delivery
channel
channels
messages
flushed
mobility
arrives
detained
delivered
destination
forwarding
fifo
snapshot
ahead
home
buffering
identifier
holding
deliver
incoming
broadcast
processed
migration
faults
telescript
mole
aglets
platform
arriving
communication
slave
held
flush
action
node
runtime
master
multicast
originate
active
network
outgoing
remote
movement
released
buffered
mechanisms
orphan
connectivity
transitions
aforementioned
recording
progress
reliable
server
pre
simplistic
eventually
voyager
shout
livered
implementability
neighbors
arrive
notably
gateway
transit
retransmission
catches
source
sent
host
hosted
kqml
buffer
arrived
mechanism
overly
sender
tcl
received
visited
passing
subnetworks
platforms
delivering
reply
argue
sockets
flushing
broadcasting
sheer
ip
open
willing
consumption
dynamically
checkpointing
reliability
spanning
finished
migrate
defeat
guaranteed
conventional
inherently
ensuring
associating
effectively
applicability
amenable
leave
transition
copy
provision
nodes
intentionally
unreasonable
enhancements
piece
straightforwardly
traveling
constrains
ffl
guarantees
guaranteeing
burst
bidirectional
enhancement
complicates
forwarded
missed
moves
fault
umbilical
dynamicity
hojjat
yazdani
objectspace
qusay
navid
misunderstood
jafarpour
nasser
rectional
departed
masif
centralization
cuiting
strawman
merseguer
buenes
emerald
ilarri
bidi
curmsg
chore
trapping
daoud
listener
resorts
mosaab
rive
bazzaz
zadeh
scenarios
traffic
party
challenge
move
site
visit
traversed
invocation
propagating
coordination
lost
diagram
transitioned
counterarguments
operative
spawning
nel
shouting
mahmoud
lime
gration
reintroducing
omg
argentina
missing
locating
wait
assumes
enable
mobile agent
mobile agents
message delivery
network graph
message j
pre message
home agent
arrives action
agent arrives
j arrives
agent systems
runtime support
incoming channels
agent platform
multiple message
held agents
communication mechanism
last message
next message
message source
highly mobile
reliable communication
group communication
master agent
pre agent
distributed snapshot
fifo property
destination node
underlying mobile
holding channels
physical mobility
message processed
messages 5
detained agents
forwarding scheme
agent migration
holding j
message received
current message
using mobile
orphan detection
messages arriving
message passing
reliable message
multiple messages
every node
state transitions
message arrives
remote procedure
channels open
mole 1
d processing
tree broadcasting
action buffer
fifo assumption
one host
message action
gateway servers
agent message
active graph
eventually arrive
sheer presence
agents release
making z
open channel
processing action
channel transitions
outgoing channels
grow dynamically
incoming channel
source ahead
tuple spaces
like remote
message identifier
guarantees message
conventional mechanisms
messages originate
agent arrived
eventually released
agents therefore
agent server
destination ahead
slave agents
y active
free network
channel y
agent platforms
finished processing
action deliver
related diagram
agents arriving
j finished
mobile agent systems
pre message j
mobile agent platform
presence of mobility
highly mobile agents
message j arrives
multiple message delivery
j arrives action
using mobile agents
case the channel
last message processed
messages 5 8
broadcast and forwarding
source the identifier
underlying mobile agent
purpose of using
pre agent arrives
group of agents
last message received
reliable message delivery
agent arrives d
host to another
finished processing action
y to z
making z y
mobile agent platforms
action 4 pre
diagram for multiple
channel is active
currently available mobile
willing to host
initially all channels
nodes and channels
static network graph
release held agents
flushed or buffering
could be delivered
allowing any node
pre no incoming
delivery to highly
held agents release
agent systems currently
delivery of information
processing action 4
agents release held
arrives action buffer
deliver to held
yet been delivered
spanning tree broadcasting
many mobile agent
possibility of faults
message j finished
done with respect
current message delivery
guarantees message delivery
arrives action deliver
algorithm to allow
agent systems provide
mobile agent server
processing same message
mechanism for mobile
available mobile agent
burst of messages

corpus/krapavin2000-test/628041.txt
rectangles
buffer
pinning
pinned
rectangle
query
queries
pages
faloutsos
mbrs
kamel
disk
ij
accesses
region
trees
mbr
tree
lru
packing
nx
loading
tat
hs
accessed
buffering
leaf
theodoridis
guttman
levels
hit
simul
hilbert
retrieved
accessing
warm
plot
bhide
visited
dif
intersect
uniformly
theta
tiger
sellis
square
bounding
steady
corner
upright
databases
probability
node
versus
spatial
policy
nodes
extents
top
root
predicted
structured
pool
fractal
pins
perimeter
shaded
yannis
resulted
beach
metric
simulation
packed
enclosing
plotted
confidence
insertion
resident
jun
plots
page
area
inside
bufsize
computen
replacemtn
modestly
byunggu
chakka
xinran
abstractpast
gting
edgington
insight
ignoring
replacement
scenarios
file
indexing
trajectories
validation
analytical
benefit
quantitative
bottom
policies
fit
dr
bigger
vassilakopoulos
subqueries
rishe
jignesh
geoinformatica
yufei
prasad
naphtali
irrevocable
papadias
underscoring
methodology
pointed
internal
performing
predict
fits
reside
curves
qualitative
knee
ralf
tpr
bufferless
fractals
bureau
corral
gains
poorly
numbered
studies
experimentally
ne
hartmut
purposely
sevcik
bailey
keyed
box
synthetic
rectangular
inserting
querying
splitting
almeida
census
accrued
capitalize
teixeira
retrieve
tuple
intervals
patel
dimitris
shu
experiencing
manolopoulos
multiversion
halving
spatio
ching
weiss
ith
emphasize
placed
touched
r tree
r trees
disk accesses
region queries
buffer size
buffer model
point queries
r ij
q tr
unit square
loading algorithms
leaf level
point query
theta q
buffer hit
hit probability
size q
theta 0
region query
q y
query q
x theta
query performance
rectangle r
accesses required
tree nodes
buffer effects
top levels
q x
expected number
minimum bounding
well structured
top right
n queries
data set
query region
nodes accessed
nodes visited
uniformly distributed
buffer sizes
total area
lru buffer
packing algorithm
accessing r
buffer impact
guttman 3
nx algorithm
simul model
pages pinned
rectangles within
model dif
accesses versus
input rectangles
per query
bounding rectangles
u 0
level 1
n rectangles
packing algorithms
state buffer
new buffer
data size
query model
within 2
many levels
q ij
buffer pool
level r
size 0
steady state
queries using
analytical model
data file
right corner
upright rectangle
cluster rectangles
faloutsos 4
dr ne
tr must
pinned pages
versus buffer
rectangles per
fewer disk
access within
buffer warm
three loading
first becomes
tree packing
dif simul
ignoring buffer
rectangles internal
inside u
buffer resident
retrieved rectangles
structured r
considered versus
tree update
hs algorithm
linear improvement
nodes per
root level
rectangles stored
nodes retrieved
accessing rectangle
sellis 10
poorly structured
node 17
bhide et
structured trees
insertion algorithms
tat algorithm
number of disk
kamel and faloutsos
q x theta
x theta q
theta q y
size q x
area of r
number of nodes
probability of accessing
buffer hit probability
number of pages
query of size
disk accesses required
model of kamel
r tree nodes
minimum bounding rectangles
simul model dif
state buffer hit
theta 0 3
within the unit
size 0 3
steady state buffer
disk accesses versus
new buffer model
performing a query
probability that r
plots the number
bhide et al
top few levels
theodoridis and sellis
three loading algorithms
r tree update
r tree using
rectangle r ij
b a figure
region queries consider
queries of size
versus buffer size
retrieved as derived
q tr must
rectangles per node
dif simul model
pinned is less
rectangles are sorted
accesses required per
required to retrieve
reduction in disk
accessed in n
region query q
first two levels
amounts of buffer
pinned is within
accesses versus buffer
querying an r
pinning the first
r tree packing
nodes per level
small buffer sizes
region query model
buffer for point
point query q
must be retrieved
inside u 0
query q tr
model dif simul
accessed while performing
first becomes full

corpus/krapavin2000-test/636898.txt
tcp
red
flows
packet
queue
diffred
packets
window
drop
congestion
timeout
gentle
aqm
udp
queues
trip
round
ns
goodput
maxth
tail
avoidance
simulations
fairness
flow
minth
pps
priority
throughput
maxp
epoch
steady
timeouts
diffserv
da
coefficient
acks
newreno
traffic
differentiated
delay
bottleneck
service
losses
analytical
reno
rsvp
loss
congested
transmission
competing
dropped
inversely
fig
option
internet
link
network
ietf
session
queuing
probability
ecn
propagation
population
validated
burst
drops
heterogeneous
th
responsive
average
td
sec
duplicate
simulation
gateways
services
variant
detection
vis
sessions
ack
unknowns
schematic
proportional
raphson
ip
solver
topology
abouzeid
minthv
dependance
wred
sharing
reservation
validation
bias
links
equations
qv
nda
unfairness
aimd
formula
poisson
sink
mixed
dropping
rates
newton
postulate
underutilized
duration
multiplicative
modeling
header
macroscopic
conditioned
routers
additive
overflow
lost
marking
neglecting
tos
configure
buffer
substituting
forced
promoting
roy
rio
lossy
destination
evolution
experiment
decrease
advertised
kbps
formulae
capacity
transmitted
slope
detected
accurate
allocation
recipes
av
margin
numerically
approximation
delays
originates
differentiation
figures
ideally
reception
governed
rate
analytic
capacities
averaged
numerical
connection
slow
convergent
connections
belongs
efforts
expressions
networks
yielding
consecutive
passes
neglected
derivation
troy
filed
rensselaer
tcp flows
tail drop
window size
packet drop
red queue
average queue
queue size
drop probability
packet loss
round trip
congestion avoidance
flow j
gentle variant
red queues
average window
congestion window
th flow
th queue
udp flows
steady state
tcp flow
v th
priority coefficient
ns simulations
size obtained
drop queue
average goodput
j denote
z w
trip time
differentiated services
timeout formula
red algorithm
comparison points
priority class
goodput obtained
gentle option
point approximation
congestion control
average round
diffred queues
tcp timeout
timeout behavior
tcp session
network solver
packets sec
pps approximation
th epoch
j th
flows sharing
multiple tcp
ns 2
tcp reno
inversely proportional
fixed point
tcp traffic
burst loss
simulations packets
mixed tcp
flows obtained
packets average
packets fig
packets second
j packets
inter loss
competing flows
fairness index
m tcp
diffred queue
state throughput
analysis packets
loss window
random early
trip delay
bottleneck link
single queue
tcp congestion
average packet
packet drops
queue management
early detection
e w
higher priority
transmission rate
packet losses
udp traffic
queuing delay
k j
propagation delay
w denote
slow start
analytical results
w j
current round
transmission rates
two red
experimental network
bottleneck red
fairness coefficient
red packet
responsive flows
forced packet
trip propagation
raphson technique
packets minth
different round
congested red
increase multiplicative
denote flow
consecutive da
aqm queues
heterogeneous flows
fairness results
window increase
duplicate ack
tcp newreno
loss within
non responsive
modeling tcp
drop queues
resource reservation
first loss
average queue size
packet drop probability
obtained from simulations
tcp and udp
average window size
v th queue
j th flow
fixed point approximation
round trip time
obtained from analysis
tail drop queue
average goodput obtained
congestion window size
simulations and analysis
average round trip
population of heterogeneous
experiments with tcp
denote the probability
sharing a bottleneck
w i j
non linear equations
random early detection
round trip delay
network of aqm
steady state throughput
simulations packets average
multiple tcp flows
without the gentle
validated against ns
m tcp flows
average packet drop
queue size obtained
network of red
variant of red
analysis packets fig
tcp flows sharing
packets are dropped
round trip times
denote the average
packet loss detection
versions of tcp
additive increase multiplicative
round trip propagation
one packet loss
burst loss within
tail drop queues
sets of flows
different round trip
tcp congestion avoidance
total of 160
case of red
j denote flow
red and tail
denote the steady
congested red queue
experimental network topology
denote flow j
newton raphson technique
non responsive flows
e z w
increase multiplicative decrease
queues with tcp
red and diffred
analysis for mixed
congestion avoidance phase
way propagation delay
least one packet
active queue management
class of service
round i 1

corpus/krapavin2000-test/1013707.txt
cts
snd
extraction
df
extr
buf
channels
dom
csp
traces
ep
communicating
refusals
koutny
channel
refusal
behaviour
burton
pappalardo
ref
processes
eg
uninterpreted
trace
refinement
divergences
specification
di
interface
relating
realisability
compositionality
actions
unfinished
erent
transition
compositional
interfaces
bm
dp
action
idch
nak
vcts
failures
abstraction
ack
er
patterns
verification
diverging
composition
erence
alphabet
blocked
deadlock
domall
engage
ge
collapses
target
compound
transmission
hiding
ak
sim
failure
vertical
fault
divergence
refining
event
unambiguous
prefix
labelled
proposition
twice
arcs
interpreted
arc
stipulate
horizontal
treatment
reachable
composed
concurrency
sender
mapping
rensink
gorrieri
unboundedly
disambiguating
breached
cult
communication
interpret
bu
signals
te
suitably
lc
specifications
concrete
tolerant
respective
refuse
implementations
verifying
modelling
contribute
regarded
targets
replicated
restatement
monotonic
device
explosion
formedness
adhering
technically
pattern
bisimulation
transducers
mappings
sources
base
implements
entailment
realm
faulty
erences
treatments
prone
hidden
internal
verify
graphs
identity
interprets
io
associative
arrows
outgoing
extract
semantics
transitions
extracted
amenable
modelled
infinite
ambiguous
imposed
progress
constraining
unacceptable
denotational
intended
strict
amounts
highlighted
algebras
transmissions
sequences
enabled
deleting
collapse
ambiguity
sensible
liveness
coincide
motivations
interact
fig
composing
reliable
algebraic
duplicated
connecting
wish
deterministic
correctness
notions
annotations
interpretation
disturbers
realis
accomplishments
ctss
ployed
terpreted
overtaken
pcts
izontal
implementation relation
extraction patterns
cts u
extraction pattern
communicating transition
relating communicating
extraction graph
m koutny
j burton
g pappalardo
burton m
communicating processes
base process
extraction graphs
dom q
extraction mapping
d 1
vertical implementation
snd 2
base processes
action refinement
transition system
process p
process q
implementation process
standard horizontal
graph eg
interface di
cts n
di erent
snd 1
extr q
csp process
output channels
dom ep
interface refinement
output channel
input channels
implementation relations
transition systems
input channel
r 1
target process
system cts
specification component
non diverging
eg twice
csp processes
source channels
channel b
snd buf
behaviour abstraction
deadlock properties
extr ep
refusal bounds
r 0
communicating sequential
non empty
p p
di er
channel d
channels b
implementation system
sequential processes
di erence
parallel composition
q 0
system q
q p
buf c
interfaces di
q implements
uninterpreted channel
uninterpreted channels
placed upon
local failures
interpreted channel
implementation processes
nak r
prefix closure
cts buf
network composition
bm n
standard csp
set extr
ep twice
q df
local failure
implementation conditions
failures divergences
implementation component
sim min
r dom
ep eg
subset closed
mapping ref
identity extraction
q satisfies
two processes
specification system
relating communicating processes
koutny and g
j burton m
burton m koutny
set of channels
communicating transition system
traces in dom
communicating transition systems
d 1 d
extraction graph eg
snd and buf
specification and implementation
base process p
vertical implementation relation
implementation process q
event of interface
transition system cts
sets of channels
p s ack
communicating sequential processes
domain of q
set of extraction
p p p
snd buf c
model of csp
interface di erence
simulation for cts
defined for traces
r dom q
traces and refusals
blocked t r
u and cts
systems and extraction
b i dom
failure of q
interfaces di er
notion of extraction
graph of cts
sequence of traces
shown in figure
high level action
p r 0
p 1 p
state explosion problem
denoted by dom
v a w
q and p
q implements p
interfaces of communicating
system cts u
definition of extraction
connecting their respective
w in cts
implementation relation collapses
nak r 0
transition systems representing
several connected systems

corpus/krapavin2000-test/1015755.txt
sgplvm
poses
motion
pose
animation
lgp
latent
lik
xi
training
character
wk
gp
gaussian
posing
2d
interpolation
style
learning
ik
mog
yi
tting
synthesis
lawrence
likelihood
keyframing
baseball
tog
siggraph
kinematics
styles
markers
speci
annealed
popovi
learned
pdfs
pca
eurographics
motions
active
3d
pitch
graphics
learn
sgplvms
jovan
pdf
human
vienna
gaussians
hertzmann
neil
animator
eugene
yt
ef
objective
capture
wright
joint
austria
ne
articulated
kernel
optimizes
parameterization
rbf
dragging
orientation
interactive
gps
annealing
trajectory
neural
variance
angles
minima
smooth
humans
missing
mackay
sketching
interpolated
scaled
animating
optimizing
frame
unknowns
modi
posterior
image
plot
sumner
nocedal
shmm
igarashi
gesticulation
bfgs
rasmussen
storyboarding
puppetry
gesture
moscovich
yk
believable
hagan
yamane
hollywood
keyframed
mogs
sigchi
unannealed
plvm
handrix
animations
dif
additionally
inverse
smoother
acceleration
aaron
virtual
ln
velocity
interpolate
qi
hsu
optimization
sqp
karen
avatars
legged
rbfs
adverbs
rigging
entertainment
fiume
arm
rst
symposium
principled
interpolating
synthesized
vision
reconstructions
neff
corvalis
kinematic
nakamura
bayesian
angeles
correspondences
interpolates
zoran
ps
reconstruction
optimize
heuristic
gradients
realtime
feet
july
de
novel
los
noise
tells
nearby
neal
subtracted
hughes
warped
verbs
regression
sg
ned
video
scaling
sheng
mao
numerical
nd
reconstruct
soft
warping
qin
alternates
mouse
constraints
california
animated
marker
active set
motion capture
new poses
latent space
gaussian process
human motion
computer animation
style based
process latent
training data
latent variable
inverse kinematics
objective function
model parameters
eurographics symposium
graphics tog
tog v
acm siggraph
siggraph eurographics
based ik
training poses
original poses
new pose
gaussian processes
numerical optimization
speci c
variable model
sgplvm model
gp model
scaled gaussian
lawrence 2004
baseball pitch
animation september
joint angles
de ne
vienna austria
data sets
real time
character posing
likely pose
handle constraints
interactive character
jovan popovi
xi wk
poses given
missing markers
pose synthesis
september 02
2d image
x values
p y
hard constraints
kernel matrix
ef cient
motion data
virtual humans
select new
july 2005
feature vector
motion synthesis
v 24
set points
acm transactions
likelihood function
articulated figure
motion transformation
mackay 1998
ps y
2d constraints
motion graphs
conventional pca
model sgplvm
capture poses
xi values
log posterior
mog model
trajectory keyframing
time motion
automated extraction
character pose
kernel function
animation proceedings
x x
y q
y 0
low dimensional
learned model
aaron hertzmann
xi yi
automatically synthesized
dif cult
soft constraints
latent variables
july 29
variable models
small data
c q
optimization algorithm
neural networks
y 1
variance 2
animation july
new active
learning algorithm
learning process
training set
learning p
process latent variable
gaussian process latent
transactions on graphics
graphics tog v
siggraph eurographics symposium
acm siggraph eurographics
symposium on computer
style based ik
n 3 july
tog v 24
computer animation september
september 02 04
animation september 02
latent variable model
constraints in real
interactive character posing
active set points
p y 0
scaled gaussian process
v 24 n
x x x
real time motion
motions in large
motion capture poses
space of poses
variable model sgplvm
c q 0
select new active
capture with missing
extraction and parameterization
parameterization of motions
small data sets
new active set
animation july 29
latent variable models
july 29 31
position and orientation
large data sets
computer animation july
machine learning p
conference on machine
los angeles california
applications interactive character
parametric hidden markov
purpose probability distribution
o hagan 1978
background on gaussian
automatically synthesized motion
character posing trajectory
knowledge enhanced motion
motion transformation inferring
time motion capture
optimization of lgp
motion by knowledge
sigchi international conference
satisfying those constraints
c karen liu
shadow puppetry motion
eugene fiume methods
chen mao sheng
kinematics system based
yamane and nakamura
williams and rasmussen
hughes spatial keyframing
negative log posterior
f hughes spatial
liu aaron hertzmann
enhanced motion transformation
nocedal and wright
animated with human
ln 2 x
general purpose probability
describes the mapping
storyboarding to immediate
hertzmann zoran popovi
ln p y
david k wright
inferring 3d structure
aaron hertzmann zoran
articulated figure motion

corpus/krapavin2000-test/1007526.txt
repok
java
coverage
red
symbolic
precondition
black
treemap
elds
checker
jpf
korat
testing
box
lazy
uninitialized
inputs
trees
specication
preconditions
testera
white
util
initialization
specications
elem
eld
conservative
checking
cr
tests
pc
tvla
symbolically
initialized
cl
generation
pathfinder
destructive
concrete
null
worklist
primitive
koushik
rst
structural
xd
branch
godefroid
ignoreif
fixafterdeletion
marinov
psreanu
deleteentry
structures
manipulating
entry
instrumented
automated
static
software
deos
darko
patrice
public
shelf
isomorphic
sen
del
corina
rover
backtracks
nondeterministically
infeasible
sigsoft
helper
thread
color
foo
cloud
execution
boolean
xi
maine
invariant
remove
counterexamples
tree
predicate
nikolai
tillmann
pelnek
fixafterinsertion
redhasonlyblackchildren
schulte
astoot
removefirst
scp
verisoft
elems
concolic
rupak
programs
heap
code
dierent
backtrack
systematically
initializes
branches
engine
radek
slam
isempty
asml
ecient
predicates
put
aliasing
void
library
wolfram
majumdar
visser
notes
verication
portland
willem
doong
structs
declaration
int
colored
generating
lastly
satisability
threaded
swaps
kingdom
program
acyclic
temporal
uml
created
path
violates
instrumentation
reconstruct
verify
generate
paths
linked
notices
logic
false
shape
oracles
specied
exibility
proach
checkers
exploration
cond
beach
assertion
node
doubly
pointers
unreachable
london
sigplan
object
mem
initializing
dene
engineering
sequences
checks
satises
explores
conguration
parenthesis
constraints
criteria
validating
criterion
behavioral
automating
concurrency
algebraic
symbolic execution
input generation
red black
test input
model checking
model checker
lazy initialization
white box
path condition
black trees
black box
next next
branch coverage
test inputs
input structures
black tree
box approach
input trees
java util
input structure
box testing
class invariant
execution tree
util treemap
color red
uninitialized elds
conservative precondition
generate tests
software testing
box test
complex data
manipulating complex
generalized symbolic
execution framework
conservative repok
pc x
generating tests
concrete precondition
generate test
non isomorphic
software engineering
java pathfinder
primitive data
remove methods
specication based
y pc
jpf model
koushik sen
java treemap
cr null
cl null
solve constraints
java predicate
java predicates
reference elds
code manipulating
unit testing
using model
java programs
y x
test data
based testing
y y
structural coverage
public static
data structures
test generation
shape analysis
testing criterion
method calls
analysis july
destructive updates
method preconditions
isomorphic input
treemap library
input elds
darko marinov
red return
xd xi
checker backtracks
logic engine
patrice godefroid
symbolically executing
conservative preconditions
primitive elds
algebraic specication
pointer assertion
del xd
program testing
x y
oriented programs
testing proceedings
size 5
static analysis
space exploration
assertion logic
class node
left entry
based coverage
sigsoft software
notes v
engineering notes
acm sigsoft
return false
software model
international symposium
also reports
code coverage
thread scheduling
test input generation
red black trees
red black tree
next next next
java util treemap
box test input
put and remove
x y y
black box testing
black box approach
trees of size
manipulating complex data
symbolic execution tree
generalized symbolic execution
x x y
jpf model checker
used during lazy
y y pc
symbolic execution framework
white box test
pc x y
code manipulating complex
checking as testing
white box approach
testing and analysis
using model checking
o the shelf
theory of test
symposium on software
x y x
complex data structures
sequences of put
constraints on primitive
non isomorphic input
method s precondition
generate test inputs
y pc x
java treemap library
model checker backtracks
red return false
checking to generate
color red return
del xd xi
assertion logic engine
corina s psreanu
pointer assertion logic
constraints on reference
y x x
y y x
object oriented programs
software engineering notes
engineering notes v
acm sigsoft software
sigsoft software engineering
state space exploration
n 5 september
automated software engineering
notes v 30
stop the analysis
black box fashion
current color red
entry cl current
cl current left
static final boolean
properties of interfaces
java data structures
validating temporal safety
current entry worklist
repok returns true
removefirst entry cl
model checking used
java pathfinder jpf
method under test
logic based theory
nodes represent entries
generating test inputs
cr current right
testera and korat
inputs from constraints
parameterized unit tests
straight model checking
right if current
entry worklist removefirst

corpus/krapavin2000-test/628121.txt
folding
shattering
uced
fat
learning
activation
vc
neurons
lraam
feed
learnability
recurrent
luckiness
height
empirical
trees
sigmoidal
pseudodimension
neural
inputs
neuron
lucky
ffi
concrete
training
dm
dimension
architecture
shatters
unlimited
networks
forward
shattered
raam
kff
oe
generalization
perceptron
bounds
trained
argumentation
encoding
connectionistic
weights
pac
hm
dynamics
deviation
outputs
deltal
sgd
recursive
finiteness
dealing
ln
quantity
regularity
architectures
phi
ffl
error
permutations
decoding
smoothness
swappings
unluckiness
digit
backpropagation
tree
ff
jx
unfolded
jd
learned
structured
stratification
inequality
hoeffding
biases
encoded
labels
probability
swap
priori
network
combinatorial
recursively
polynomial
mapping
bits
ij
responsible
descent
xy
hammer
subtrees
layer
mj
mappings
possesses
answered
equipped
substitute
gradient
classification
restricted
capacity
units
ae
sample
lists
pseudo
summand
automata
valid
chemical
sup
vanishing
differs
coincides
valued
differentiable
covering
wn
quantization
deals
ps
pseudometric
sitao
chebychef
maxfheight
unlucki
rahman
jfgjx
gammamj
gammaun
arity
subtracting
quantities
infinite
fulfilled
generalizes
barbara
learn
scratch
smooth
alphabet
contained
tommy
decodes
alessio
trains
dichotomies
superpositions
prefixed
micheli
fits
propagation
principle
fix
induced
computes
estimating
capable
sperduti
ensembles
convergence
characterizes
unknown
risk
coefficient
nonempty
sequences
hidden
adjustable
descend
affirmative
analogy
indices
concerning
mutually
tio
chervonenkis
dichotomy
prohibited
elman
learnable
svm
identity
derivative
folding networks
empirical error
fat shattering
uced property
shattering dimension
feed forward
function class
learning algorithm
initial context
folding architecture
real error
activation function
valid generalization
small empirical
distribution independent
concrete learning
dm f
activation functions
forward networks
vc dimension
function oe
forward part
high trees
input height
folding network
context y
maximum input
information theoretical
input trees
standard feed
r l
input tree
derive bounds
structured data
f jx
via g
recursive part
vc pseudo
underlying regularity
folding architectures
latter probability
independent uced
theoretical learnability
f ffi
sigmoidal case
neural networks
generalization error
hm f
computation units
x f
input space
p f
maximum height
l 0
luckiness function
w ln
fat ffl
finite fat
concrete training
luckiness framework
two feed
processing dynamics
f hm
perceptron activation
combinatorial quantity
connectionistic methods
distribution dependent
context neuron
first bits
sigmoidal function
ffi ff
context neurons
jd p
unlimited size
y 0
x 0
real vector
guarantee valid
covering number
class f
phi m
different length
recurrent neural
recursive nature
input neurons
cannot exist
explicit bounds
vector space
allows us
g y
valued function
y y
function classes
o w
distributed representation
adaptive processing
y 2
r m
fat shattering dimension
small empirical error
activation function oe
number of examples
trees of height
l 0 x
feed forward networks
maximum input height
feed forward part
probability of high
standard feed forward
algorithm with small
us to derive
information theoretical learnability
initial context y
independent uced property
inputs in x
distribution independent uced
x f ffi
y y y
number of functions
f hm f
two feed forward
finite fat shattering
hm f x
recurrent and folding
dimension if f
jd p f
pseudo and fat
phi m l
concrete learning algorithm
valued function class
guarantee valid generalization
weights and inputs
smooth with respect
learnability of folding
m l 0
recurrent neural networks
y 2 r
ffl and 1
p on x
theorem 5 7
polynomial in 1
real vector space
derive explicit bounds
k deltal r
concrete training set
distribution into account
error generalizes well
function l 0
f g2f jd
error cannot exist
feed forward architectures
tree structured inputs
time series prediction

corpus/krapavin2000-test/608351.txt
tls
vovk
warmuth
reinforcement
learning
episodic
forster
trial
regression
learner
outcomes
trials
gammay
temporal
td
episode
loss
lstd
thetan
pseudoinverse
discounted
prediction
signals
definite
barto
episodes
predictions
inv
invertible
morrison
sherman
bradtke
azoury
bounds
widrow
fl
outcome
gamman
schapire
discount
hoff
boyan
vectors
expectation
ridge
predictor
clipping
sutton
predict
predicts
clips
comparator
motivation
pseudoinverses
akwk
kwk
kivinen
instances
squares
jm
sums
matrix
infimum
rk
profits
stochastic
semi
lie
proven
cy
norms
minus
clip
logarithmically
foster
euclidean
equality
weight
beta
unknown
losses
difference
conjecture
grow
inequality
minimizes
lemma
inverse
gradient
matrices
company
covariance
gamma
rahmen
flannery
merman
unclipped
teukolsky
rektorys
landern
stearns
doktorandenstipendium
bund
hochschulsonderprogramms
graps
duffy
herbster
gemeinsamen
logarithmic
orthonormal
setting
ff
signal
relative
norm
exponentiated
cesa
nigel
saunders
gam
diction
regressor
bianchi
daad
hassibi
jurgen
convex
transforms
receive
worst
continuous
differences
yt
atr
hindsight
gammaq
interval
corollary
tuned
fourier
dimensionality
walker
muth
manfred
introductory
arithmetic
formula
war
practitioner
converges
rate
alternate
rates
clipped
unpublished
square
theta
rescaling
xx
und
absolute
markov
tg
bx
interpret
recipes
des
supremum
assures
technical
divisible
month
inverses
vector
substantially
advance
wavelets
proofs
comparatively
policy
grows
tune
strategy
lengths
logs
shorter
really
em
relative loss
loss bounds
temporal difference
difference learning
tls algorithm
reinforcement signals
linear regression
r n
outcomes y
gammay y
total loss
k warmuth
j forster
loss 1
future reinforcement
n thetan
best linear
trials 1
order algorithm
learning algorithm
interval gammay
semi definite
second order
m k
morrison formula
outcome y
vovk 1997
linear predictor
episodic learning
regression algorithm
sherman morrison
order algorithms
vectors x
positive semi
linear function
vector w
theorem 9
episodic setting
temporal least
new second
discount rate
discounted sum
algorithm td
stochastic strategy
warmuth 1999
additional loss
positive definite
instances x
real interval
definite matrix
learning setting
case relative
ridge regression
vector x
theorem 6
rate parameter
parameter fl
unknown distribution
reinforcement learning
line algorithm
x 0
instance vector
warmuth 1996
loss bound
discounted sums
td algorithm
consider temporal
algorithm minus
continuous setting
prediction b
gamman x
reinforcement signal
arbitrary sequences
squares tls
minimizes 2
expected relative
theorem 3
corollary 6
first inequality
weight vectors
consider linear
every vector
widrow hoff
y lie
bound y
learning rates
order learning
known relative
least squares
theta r
formula 2
signal r
lower bound
n theta
first order
average case
learning rate
fl 2
relative loss bounds
temporal difference learning
bounds for temporal
forster and m
m k warmuth
relative loss 1
case a 0
future reinforcement signals
sequence of examples
loss 1 2
interval gammay y
r n thetan
sherman morrison formula
second order algorithm
examples in r
best linear predictor
positive semi definite
r n theta
x 2 r
loss 1 3
second order algorithms
morrison formula 2
real interval gammay
difference learning setting
new second order
azoury and warmuth
schapire and warmuth
rate parameter fl
discount rate parameter
temporal least squares
case relative loss
lemma a 2
theorem 6 1
theorem 9 1
algorithm for temporal
bounds for linear
number of trials
n theta r
x t 2
theorem 3 1
theorem 3 2
needs to know
instance vector x
algorithm the expectation
minimizes 2 2
vovk s prediction
first order algorithm
best linear function
reinforcement signal r
clips the prediction
gamma the learner
theorem 9 2
prediction b 0
linear regression algorithm
expected relative loss
vector w 2
sequences of examples
distribution on r
squares tls algorithm
vovk s linear
lie in gammay
order learning algorithm
consider linear regression
w 2 r
consider temporal difference
bradtke and barto
line algorithm minus
second order learning
outcomes y lie
least squares tls
uses the weight
known relative loss
relative loss bound
average case relative
vectors x 2
minus the total
formula 2 5
sequence of trials
corollary 6 2
r t 2
bound of theorem

corpus/krapavin2000-test/637247.txt
hop
ttl
probes
accsig
pathchar
hops
packet
probe
pacesetter
clink
invisible
route
quartets
icmp
peak
delay
ct
estimates
link
ip
accumulation
pacesetters
quartet
traffic
busy
packets
bandwidth
receiver
measurement
noise
sender
segments
segment
variation
cross
tailgater
acc
histogram
errors
probing
routes
layer
queue
cancels
sensitivity
lan
bandwidths
estimation
headers
detection
trip
signature
service
estimate
udp
mbps
periods
measurements
filtering
mixing
bottleneck
peaks
symmetric
uncorrected
histograms
backward
dropped
period
measuring
est
waiting
router
invasiveness
sigcomm
internet
departure
veitch
suspected
header
atm
minima
leaving
byte
switched
bimodal
pace
round
fw
bw
streams
suffer
sent
nettimer
darryl
lindley
gater
magnification
spacing
baker
cancellation
analysed
slope
sizes
returning
sridhar
wetherall
lai
rate
propagation
variants
fig
pq
estimated
linearities
dovrolis
utilised
arrive
queues
timestamps
correction
messages
machiraju
dispersion
routers
equation
forwarding
accuracy
traverse
seg
drawbacks
accurate
simulation
network
rates
expired
behaviour
iii
entering
neil
medians
stream
symmetry
erroneous
live
median
fragmented
gps
reliance
arrived
sending
arriving
won
anderson
consequences
delays
cancel
nominal
unknown
instant
differences
ethernet
expires
inter
analyse
links
error
arrives
equations
arrival
detected
spaced
sig
arrivals
diagnosis
sized
alternate
sec
forward
simulations
obey
ft
delay variation
invisible hops
cross traffic
peak detection
packet quartets
h ttl
hop h
link bandwidth
busy period
probe size
packet quartet
detection errors
service time
ttl 1
international route
packet pair
estimate lower
w h
last hop
link rate
upper estimate
limited ttl
different busy
acc component
bandwidth estimates
accumulation signature
pathchar clink
probe sizes
busy periods
invisible hop
hop route
link layer
icmp messages
sender receiver
estimation errors
k ttl
backward route
measurement methods
hop segments
pacesetter packets
variation based
link rates
packet size
round trip
link bandwidths
minimum delay
ttl values
ttl field
estimation methods
relative error
defining equation
lower layer
probe stream
packet 3
component leaving
pathchar like
ip ttl
hop 3
hop 2
based estimates
ip 1
accsig pq1
layer headers
mixing equation
packet 4
fw hop
hop mixing
path representation
accumulation term
receiver packet
different packet
rate estimates
accumulation component
pacesetter packet
hop 1
single hop
packet sizes
new methods
like methods
network measurements
packet 2
bandwidth estimation
packet 1
section ii
waiting time
component b
segment 9
packet delay
departure time
trip delay
waiting times
bottleneck link
table iii
method pq1
variation histogram
based estimate
method pq2
suspected bottleneck
pacesetter sizes
probe packet
pathchar and clink
ct with ct
upper estimate lower
peak detection errors
sensitivity to peak
ct no ct
delay variation based
h ttl 1
different busy periods
number of probes
end to end
back to back
equation for method
leaving the defining
accumulation component leaving
packet 4 packet
packet 3 packet
packet 2 packet
receiver packet 3
link bandwidth estimates
sender receiver packet
hop h ttl
clink and accsig
round trip delay
number of hops
h w h
relative error uncorrected
inter departure time
lai and baker
uncorrected est upper
delay variation histogram
h k ttl
packet pair based
delay variation histograms
model of packet
acc component sender
est upper estimate
w h w
link bandwidth estimation
presence of invisible
correction for invisible
bw estimates upper
variation and peak
packet quartet methods
error uncorrected est
link layer headers
pathchar clink accsig
estimates upper estimate
accsig pq1 pq2
along the route
measuring bottleneck link
time to live
f i g
section ii d
methods are based
store and forward
number of different
assumption of probes
pathchar like methods
different network routes
hop 3 hop
hop mixing equation
packet sizes used
simulation based link
generate the icmp
invisible hops correction
equation the first
bandwidth estimation method

corpus/krapavin2000-test/629472.txt
coord
cubefulldist
fulldist
stability
hypercube
coordinator
protocol
messages
info
rtt
round
message
multicast
hypercubes
protocols
ack
node
failures
neighbors
array
multicasts
logical
hop
arraymin
receive
topology
scalability
count
hm
detection
reliable
received
queue
receives
incomplete
load
fault
tolerant
goto
stable
hypercast
middlewares
topologies
sent
nodes
network
ensemble
arrays
receiving
cube
bitmap
sg
pseudo
maintains
periodically
gossiping
iteration
ms
label
ids
heard
recipients
hy
scalable
rmtp
zooms
fifo
children
hops
regularity
links
log
faulty
totem
horus
endif
physical
sends
ring
connections
toolkits
transis
parent
diameter
discarded
superimposed
delivery
member
wise
simulations
embed
routing
tolerance
disseminate
isis
multicasting
delta
yes
tree
missing
wait
loaded
superimposing
root
goals
detect
rounds
everyone
initialization
queues
buffers
replies
weakening
reflected
bottlenecks
detecting
bytes
dissemination
communicates
guo
preceded
rings
peer
collisions
sending
indices
transport
randomly
relacs
fwjw
jsg
percast
heartbeats
jitters
topolo
percube
refraining
percubes
iterations
fan
cubes
row
hardly
analytical
connection
unreliable
advance
travel
bus
advisable
ordinator
rebuilt
pinwheel
mpp
lookup
finished
imposed
buffer
indication
indexes
delivered
communication
srm
fitness
tailoring
subscribe
underlining
send
counted
seconds
matrix
infrastructure
faults
piggybacking
topol
gt
mishra
sustain
employ
sensitivity
fully
medium
bit
labels
worst
traverse
cristian
stability detection
logical hypercube
detection protocols
sequence number
info message
reliable multicast
message count
network load
hop count
cubefulldist coord
incomplete hypercube
stability information
coord fulldist
based protocol
detection protocol
protocol round
log n
message stability
fulldist s_coord
maximum queue
node k
coord protocol
hypercube structure
hypercube based
number array
incomplete hypercubes
node j
o n
array r
every node
goto step
system size
network topology
n messages
first node
fully distributed
sg z
fulldist protocol
last message
upon receiving
messages received
current round
iteration number
average network
fault tolerant
queue length
number p
queue size
distributed protocol
group communication
physical topology
become stable
input arrays
cubefulldist performance
receives o
stability array
stability messages
ack messages
coordinator receives
member rtt
messages cubefulldist
stability message
round r
tree based
node sends
round number
pseudo code
logical neighbors
ack r
increases r
node failures
nodes number
message received
element wise
last node
protocol messages
physical network
node 0
round ffl
info messages
notice difference
hypercube approach
receiving ack
m cube
logical hypercubes
code line
cubefulldist protocol
node rtt
start message
messages node
containing array
receiving info
failures 4
stability g
failures failures
arraymin element
worst result
coordinator based
whose j
max queue
array stability
current iteration
network topologies
g z
line 1
n o
based protocols
j th
failures 5
stability detection protocols
number of messages
stability detection protocol
number of nodes
node i maintains
cubefulldist coord fulldist
coord fulldist s_coord
sequence number array
logical hypercube structure
label all messages
sequence number p
received from every
fully distributed protocol
every node k
k with sequence
maximum queue size
receive from k
average network load
received by node
k as stable
function of system
tree based protocol
receives o n
logical hypercube based
maintains the following
last message received
protocol in figure
o n messages
o n o
messages are sent
coordinator based protocol
failures 4 failures
messages cubefulldist coord
array stability array
contains all 1
node in round
connection is added
info message containing
difference in scale
start a protocol
g 2 z
receives an info
count and message
hypercube based protocol
failures 3 failures
difference between first
logical hypercube approach
according to node
arraymin element wise
failures 5 failures
failures failures 3
better than cubefulldist
whose j th
code line 1
first member rtt
pseudo code line
wait until receive
g 1 z
element wise minimum
coord and cubefulldist
node and last
randomly generated network
number array stability
failures on cubefulldist
multicasts an info
last node rtt
upon receiving info
r from node
o n 2
sends and receives
r i whose
scalability and fault
node i receives
n 2 messages

corpus/krapavin2000-test/623929.txt
optical
beam
dmd
sorting
wavelength
array
beamsplitter
lens
pixel
mirror
light
electrodes
optics
deflection
rank
smart
torsion
photodetectors
subtraction
sorted
cylindrical
optoelectronic
lenslet
laser
wavelengths
emitting
modulators
imaged
reordering
optically
photodetector
lasers
dmds
focal
addressing
pixels
photonics
modulates
devices
reflected
deformable
angular
electronics
electrical
column
eqn
incident
screen
arrays
impinges
sbwp
electrode
spreading
axis
prism
opaque
physically
intensity
cl
la
vertically
substrate
focused
voltage
ranks
amp
deflected
microlasers
vcsels
splitter
photonic
onto
thresholding
legend
interconnects
matrix
electronic
detector
landing
opening
fabricated
device
row
electrically
gammau
analog
surface
sort
gammaa
switching
fig
horizontally
integrated
tristable
polarizing
filterl
vstep
crosstalk
pentaprism
impinge
vcsel
resistive
sorter
plzt
gaas
photons
parallelism
modulation
contribute
conventions
spread
detectors
reorder
conventional
summing
modulating
deflects
zeros
positions
silicon
position
zeroes
capable
beams
cavity
differential
wave
superimposed
si
thresholded
elec
proceeded
sp
subtracting
massive
negative
modulated
counterclockwise
transistor
occasion
optic
reflects
separates
mirrors
string
sectional
op
widespread
color
element
configuration
chip
behind
communications
spatial
filter
layout
filters
inputs
contributes
resolve
setup
vector
summed
interfering
addressed
hm
quantum
items
bandwidths
gate
bias
occupies
approx
fastest
interact
permit
equilibrium
internally
preceded
spatially
ascending
seed
pointer
formed
passes
jg
reflection
stirk
micromechanical
sorted output
rank vector
smart pixel
cylindrical lens
optical implementation
optical system
torsion beam
data elements
smart pixels
optical sorting
incident light
lenslet array
deformable mirror
surface emitting
imaged onto
sorting algorithm
non unique
wavelength 2
proposed optical
sorted data
dmd pixel
opaque screen
column addressing
physically reordering
wavelength 1
difference matrix
sorting system
sorting systems
d 0
parallel sorting
focal length
intensity level
light modulators
actual subtraction
angular deflection
original vector
column j
matrix d
light intensity
light reflected
constant time
point f
d array
optical axis
pixel size
d laser
electrical inputs
unique ranks
addressed configuration
f la
spatial light
reflected light
address electrodes
emitting laser
addressing lines
physical reordering
top view
electronic sorting
op amp
optically addressed
position 1
position 2
potential difference
pixel array
step 4
selected elements
highly parallel
eqn 8
vector r
sequence length
r 0
data arrays
angular beam
beam splitter
differential bias
compare every
unique rank
optical array
mirror device
optical setup
theta 1080
unique numbers
landing electrodes
laser array
r array
beam deflection
color filter
two wavelengths
sorting algorithms
n times
array array
fundamental operation
single pixel
sorting networks
every element
time parallel
input data
massive parallelism
array of wavelength
parallel sorting algorithm
d 0 array
proposed optical sorting
difference matrix d
light of wavelength
optical sorting system
generating the rank
rank vector r
r 0 array
column addressing lines
viewed from behind
non unique ranks
light intensity level
surface emitting laser
smart pixel array
implementation of step
angular beam deflection
summing each column
spatial light modulators
reordering the data
number in column
time parallel sorting
n data elements
deformable mirror device
electronic sorting systems
optical sorting systems
j of d
non unique numbers
constant time parallel
d laser array
e o 1
along the optical
number of data
o 1 time
cylindrical lens elements
comparing each element
optical and electrical
arrays in parallel
array array array
element a j
position 1 position
pixel of size
properties of optics
focused to point
implementation of smart
optically addressed configuration
compare and exchange
reflected from position
single smart pixel
mirror s position
fabricated with conventional
switching and control
pixels for optoelectronic
modulates the surface
locations of selected
implementation using currently
using currently available

corpus/krapavin2000-test/627899.txt
pi
justified
wrt
revision
negatively
literals
coherence
skeptical
fixpoint
cj
positively
sem
founded
semantics
dole
conservatism
negations
literal
notb
notl
credulous
scs
revised
shadow
justification
ccs
clause
removal
argumentation
cumulativity
relevance
contradiction
semantical
derivable
clauses
logic
priority
pres
rn
ht
nota
program
alternating
negation
maximal
belief
ci
interpretation
honest
problematic
preservation
light
complementary
presidential
politicians
notc
politician
fujitsu
valued
head
partial
newly
switch
contradictory
iff
conflict
fn
programs
semi
deleting
republican
inconsistent
liberal
body
dung
abnormal
tw
isis
deleted
doubling
conflicting
truth
rel
lights
consistent
inconsistency
prioritized
gardenfors
notlm
pnew
notdg
frn
notbroken
notbg
ljnot
numazu
fnotl
przymusinski
alferes
notd
resolve
ag
stable
normal
lg
tractable
trn
dg
np
yuan
lemma
negative
dix
fnot
demonstrates
characterized
contradicts
believed
atom
retains
behaved
removing
normalized
fixpoints
grounded
abductive
tn
autoepistemic
gl
pereira
interpretations
violates
tg
revise
candidate
said
labs
resolves
favors
minimality
derives
interchangeably
monotonic
coincides
abuse
characteristic
satisfies
mr
coincide
advocated
transformation
notable
classical
establishes
conservative
normalization
parties
anti
characterize
fyuan
troublemaker
flict
inoue
chiaki
counterattack
revising
dgi
srs
flj
ngi
lrel
isomorphy
katsumi
youg
sakama
liberals
preserva
notbthe
removalapproach
witteveen
fnotlj
servative
notf
uergen
coherenceapproach
labora
candidates
expressive
imply
heads
japan
atoms
fg
false
proposition
simplicity
favor
pi r
justified wrt
partial model
wrt m
justified model
positively justified
cj partial
negatively justified
program pi
coherence semantics
well founded
shadow justified
negatively shadow
revised program
revision semantics
assumption removal
let pi
l 2
founded model
coherence approach
negative justification
justified partial
sem pi
removal approach
assumed negations
argumentation semantics
pi n
extended program
program revision
alternating fixpoint
logic programs
pi rn
complementary literals
l pi
belief revision
assume l
three valued
founded semantics
pi 2
contradiction free
ht f
ci n
maximal fixpoint
skeptical partial
n cumulativity
normal alternating
pi f
l maximal
valued interpretation
semi normalized
least justified
extended programs
semantical properties
maximal cj
partial models
credulous argumentation
justified models
every clause
literal l
priority relation
logic programming
newly introduced
lemma 9
logic program
m 3
pi m
ccs satisfies
assumption set
problematic assumptions
coherence theory
credulous coherence
sub interpretation
pres candidate
pi iff
classical negation
stable model
l 62
skeptical coherence
rel pi
cumulativity negative
maximal justified
contradiction problem
justified literals
skeptical revision
honest dole
assumed false
program obtained
extended logic
given program
m 4
maximal consistent
consider pi
semantics 6
regular model
f pi
therefore l
model of pi
justified wrt m
fixpoint of pi
l is negatively
cj partial model
positively justified wrt
negatively justified wrt
negatively shadow justified
l is positively
well founded model
assumption removal approach
shadow justified wrt
justified partial model
l 2 f
semantics of pi
pair of complementary
well founded semantics
program of pi
clause with l
deleted from pi
obtained from pi
clause in pi
l maximal fixpoint
skeptical partial model
normal alternating fixpoint
pi r n
credulous argumentation semantics
least justified model
let pi r
maximal cj partial
three valued interpretation
credulous coherence semantics
logic program revision
m and pi
approach to logic
justified with respect
pi is defined
argumentation semantics 6
l 2 fn
head in pi
cumulativity negative justification
program pi r
deleting all clauses
cj partial models
derivable from pi
maximal justified model
given program pi
consistent and justified
exists a clause
set of assumed
n cumulativity negative
wrt m 3
skeptical coherence semantics
n 6 l
skeptical and credulous
case 2 case
cannot be derived
lemma 2 3
m and therefore
case 1 case
f 6 l
light on switch
ccs satisfies preservation

corpus/krapavin2000-test/1014075.txt
pseudopredicates
formulas
mining
extents
miner
pseudoformulas
food
pseudopredicate
foxsports
pseudoformula
chaining
predicates
beverly
espn
scores
pagerank
query
head
importance
glen
frequent
itemsets
formula
stanford
steve
conjoining
substructures
predicate
simrank
studentb
studentc
queries
web
association
similarity
com
students
indian
objects
advisor
pages
chinese
datalog
likes
undergrads
studenta
dopredicates
pseudopredi
mlb
student
hits
home
mine
cates
enormous
nexus
masters
hubs
pseu
authorities
citation
blocks
someone
went
relationships
jennifer
explanations
dangling
precomputation
notions
univ
singleton
analyses
posed
ranking
members
apriori
people
undergrad
iit
importances
molfea
satisfied
extent
database
jing
qi
appearing
personalized
depth
inductive
building
arguments
mulas
goethals
nonuniformly
pointed
preferences
hector
interrelationships
schools
sriram
prompt
advisors
bussche
discovery
subtree
pseudo
club
hyperlinked
bart
authoritative
uc
jects
ranked
score
attributes
identifying
relational
argument
publications
professors
says
analogues
basket
challenge
den
chain
molecular
cliques
renamed
eleventh
manageable
pose
publication
sources
analogously
xml
sole
forest
person
rules
utility
berkeley
fragment
expanded
predefined
logic
deeper
recursive
iteratively
databases
explanation
enabled
sigkdd
feasibility
summing
chris
precomputed
edges
edge
superset
chicago
intersection
deemed
append
brian
renaming
conjunctions
satisfies
returned
riety
dbpubs
oformula
pseudopred
legibility
djoko
peo
clubnexus
india
surnjani
intelligibility
aidong
eveline
interlinking
gspan
deemphasized
madras
f miner
e p
set argument
important formulas
p k
foxsports com
property mining
importance scores
head pseudopredicates
data mining
query types
espn com
frequent itemsets
building blocks
association rules
head variable
frequent substructures
experimental system
graph properties
database group
set arguments
objects input
basic building
similar objects
formula f
query space
web pages
g f
miner system
computing importance
indian food
enormous size
pagerank 20
predicate p
base set
head predicate
web search
good authorities
com espn
chaining f
formulas corresponding
miner experimental
studenta studentb
mining framework
pseudo formula
pseu dopredicates
important pseudopredicates
intersection closure
user 178
formula g
mlb com
likes chinese
hits 16
pseudopredi cates
formula h
predicates satisfied
query results
computational resources
data set
data sets
traditional data
co citation
tree structures
k e
personalized web
mining queries
satisfying assignment
graph data
mining frequent
existing systems
graph structures
class objects
work well
knowledge discovery
important aspects
e p k
space of properties
basic building blocks
similar objects input
objects which satisfy
f miner system
traditional data mining
k e p
space of graph
p k e
f and g
letters to denote
utility and feasibility
miner experimental system
personalized web search
set of pseudopredicates
f miner experimental
chaining and conjoining
objects in u
closure of e
hits 16 algorithms
property mining framework
represents the property
predicates in f
mining the space
set of objects
section 2 2
discussed in section
first class objects
p k 1
set of formulas
shown in figure
set of head
relational association rules
patterns and relations
two query types
work well empirically
lot in common
studentb and studentc
uc berkeley stanford
call to chain
set of pseudoformulas
user 98 user
substructures from graph
someone who knows
look for important
results for uc
set p k
g i renamed
notions in data
foxsports com espn
students are related
pseu dopredicates p
foxsports com satisfies
database group survey

corpus/krapavin2000-test/608747.txt
pssa
predicated
cmpp
hyperblock
pspec
guarding
chr
predicate
speculation
schedulable
dependences
predicates
bagf
trimaran
agf
uc
earliest
instruction
renaming
hyperblocks
cagf
epic
ssa
height
speculated
scheduled
cycle
bahf
fpp
predication
ebagf
lbagf
cahf
ecagf
guarded
scheduling
ac
lbahf
op
br
schedule
renamed
edcagf
ahf
fpps
ebahf
ecahf
edcahf
ia
un
dependence
register
branch
ilp
live
join
registers
playdoh
instructions
branches
statements
false
block
tag
mahlke
paths
flow
duplication
duplicated
static
conversion
committed
operands
code
path
pred
optimized
aggressive
alvinn
rename
isa
assignment
reduction
def
optimizations
sensitive
statement
cfg
scheduler
cycles
operand
expansion
reaching
compiler
rand
normal
guard
flexibility
disjointness
exit
architecture
superblocks
speculating
nbradar
predicating
cydra
fib
parallelism
copy
duplicate
definitions
defining
fir
nullify
compress
oe
executed
traditional
qsort
relieve
hewlett
region
infinite
character
blocks
remove
packard
wc
file
benchmarks
recurrences
italics
floating
selective
intel
speculate
eliminating
execution
profile
utilization
clean
removing
waiting
accomplish
architectural
profiling
exiting
names
unnecessarily
mm
architectures
corporation
assure
weighted
transformed
introduces
post
merged
reflect
converted
benchmark
wave
pipelining
versions
expose
targets
prior
pressure
normalized
anded
tiberiu
elimation
rodric
vinod
chelcea
rabbah
poison
budiu
multiflow
copen
stmts
merced
guarding predicate
height reduction
control height
schedulable cycle
earliest schedulable
predicated code
cmpp un
un uc
predicated execution
predicated speculation
true 3
full path
path predicates
path information
cmpp op
using pssa
static single
false dependences
ia 64
predicate sensitive
normal op
single assignment
predicated hyperblock
uc t1
predicated static
guarding predicates
instruction scheduling
code expansion
control flow
lbagf ebagf
ebagf cmpp
ac t1
next def
cmpp statements
sensitive analysis
dynamic code
oe functions
join block
epic architecture
control paths
bagf cagf
assignment pssa
ecahf edcahf
pssa transformed
lbahf ebahf
bahf cahf
cmpp operations
edcahf cmpp
ecagf edcagf
cmpp ac
edcagf cmpp
predicate registers
ebahf cmpp
optimized infinite
cmpp operation
guarding pred
block predicates
original code
flow graph
data flow
ac ac
define predicates
op guarding
cahf cmpp
pssa allows
b predicated
cagf cmpp
renamed variables
pssa dependence
non predicated
agf ahf
def get
pssa pspec
infinite results
pssa form
multiple control
multiple definitions
issue machine
block predicate
uc w1
predicated region
op schedule
transformed code
graph b
control dependence
basic blocks
control path
eliminating false
original control
per cycle
level parallelism
b q
dependence graph
flow analysis
sensitive implementation
traditional code
trimaran system
hyperblock pssa
predicate register
duplicated code
executed cycles
uc z1
op earliest
earliest schedulable cycle
control height reduction
cmpp un uc
full path predicates
pspec and chr
static single assignment
y t r
speculation and control
predicated static single
un uc t1
control flow graph
cmpp an ac
lbagf ebagf cmpp
dynamic code expansion
definitions of y1
predicated on true
value of true
predicate sensitive analysis
pssa transformed code
single assignment pssa
cmpp ac ac
ecahf edcahf cmpp
ecagf edcagf cmpp
lbahf ebahf cmpp
eliminating false dependences
uc w1 2
next def get
un uc w1
definition of y1
uc t1 7
bagf cagf cmpp
r if d
flow graph b
bahf cahf cmpp
instruction level parallelism
number of operations
predicated speculation pspec
b predicated hyperblock
operations in figure
predicate sensitive implementation
uc z1 7
cmpp op guarding
flexibility in scheduling
ac ac z1
bagf and cagf
true 1 agf
f b 2
un uc z1
d b 3
true 3 ecagf
ac z1 7
multiple control paths
pssa dependence graph
true if true
normal op target
graph b predicated
non predicated code
q if p2
true 3 lbagf
predicate defining operations
original control flow
true 3 ecahf
original 16 way
r 5 x
optimized infinite results
op earliest schedulable
need for renaming
operation s guarding
true 3 lbahf
op guarding pred
schedulable cycle f
height reduction chr
support for predicated
implementation of ssa
data flow analysis
g b c
hard to predict
true and c
c t r

corpus/krapavin2000-test/629004.txt
dependence
subscripts
references
array
loop
dependences
coupled
interprocedural
nonlinear
subscript
parafrase
supercomputing
wolfe
linpack
packages
kuck
coefficients
urbana
loops
dissertation
assertions
champaign
proc
ependence
depen
independence
banerjee
parallelizing
sigplan
compiler
dcs
independences
distances
pp
symbolic
gcd
dependenc
rpt
ph
yew
vol
illinois
conf
ence
dimension
diophantine
routines
uncertain
padua
eispack
tests
aug
xample
iucdcs
notices
multiprocessor
unknown
subroutines
fortran
valued
zhu
int
partially
cytron
distance
est
iteration
statements
parallelization
direction
reference
nest
zhiyuan
nonzero
nesting
programs
ping
cologne
antidependent
nicolau
cumulatively
ndependence
eferences
cripts
uccess
inear
uiucdcs
hose
ispack
ivisor
umber
leasure
propagation
kennedy
fo
compile
synchronization
scheduling
rice
rep
dimensions
ion
ar
percentage
indices
ome
itpack
dat
nce
directions
restructuring
west
library
alue
yunheung
als
vectorizer
flow
york
chih
zeroth
doacross
partitioning
nonetheless
thousand
package
crosses
linearity
airs
hoeflinger
tx
symp
paek
houston
supercompilers
kuhn
weng
nov
tang
nasa
transformations
marina
university
proceeds
undefined
dimensional
measurements
detection
parallelism
fisher
jay
subscripted
compilers
index
effects
conceivable
ave
multiprocessors
usage
subdomain
weather
chang
counted
iterations
tech
chu
substitution
trans
examined
ble
supercomputers
cm
toplas
testing
speedup
vectors
detected
data dependence
coupled subscripts
array references
dependence direction
partially linear
dependence distance
dependence test
user assertions
dependence analysis
nonlinear subscripts
reference pairs
symbolic terms
direction vector
dimensional array
array reference
dependence distances
linear subscripts
d dissertation
l conf
data dependences
test algorithms
dependence directions
data independence
int l
urbana champaign
test sequence
ph d
single dimension
equal test
champaign dcs
independence detection
dissertation university
depen ence
subscript expression
supercomputing p
gcd test
reference pair
test method
wolfe test
acm sigplan
constant propagation
dependence exists
multiprocessor systems
banerjee wolfe
exact test
direction vectors
unknown symbolic
nonzero coefficients
d kuck
test terminates
root test
loop nesting
interprocedural constant
loop indices
parallel processing
real valued
unknown variables
parallel execution
self scheduling
theta test
given dependence
diophantine equation
detection rate
loop index
sigplan notices
test 4
j loop
valued solutions
test could
array subscripts
notices v
rep iucdcs
working programs
p yew
dimension tests
usage frequency
p tang
test proceeds
loop partitioning
ith coupled
different passes
total array
undefined defined
flow dependent
u banerjee
iucdcs r
dcs rep
c zhu
two dimensional
test methods
parallelizing compiler
real programs
considered simultaneously
data depen
constant distances
next dimension
data synchronization
dimension test
library routines
c chen
terminates otherwise
unknown values
user programs
every loop
flow dependence
example 2
west germany
cross iteration
may 1998
ordinary programs
cologne west
table 9
either 1
dependence tests
index variable
zhiyuan li
integer solutions
interprocedural analysis
dependence testing
array reference pairs
ph d dissertation
int l conf
dependence direction vector
data dependence analysis
illinois at urbana
linear or partially
two dimensional array
data dependence test
dimensional array references
conference on supercomputing
dependence between s1
d dissertation university
partially linear subscripts
urbana champaign dcs
university of illinois
banerjee wolfe test
distance with respect
data dependence exists
interprocedural constant propagation
dependence test methods
coefficients of loop
dependence direction vectors
unknown symbolic terms
dependence test algorithms
dimensional array reference
sigplan notices v
acm sigplan notices
iteration i must
data dependence tests
test is performed
dependent on s2
otherwise it proceeds
execution of s1
dcs rep iucdcs
champaign dcs rep
rep iucdcs r
test terminates otherwise
percentage of references
terms with unknown
number of unknown
single dimension tests
yew and c
ith coupled subscripts
pair of array
example 2 4
real valued solutions
could be extended
cologne west germany
shows the percentage
june 17 21
therefore the equation
total array references
independence detection rate
loop is variable
wolfe beyond induction
distance of 1
l conf parallel
data dependence distance
often coupled subscripts
scheme to enforce
sigplan not vol
art in data
large multiprocessor systems
urbana champaign rpt
exact test could
rice university houston
kuck r kuhn
constant dependence distance
p tang p
d kuck r
packages were chosen
w nonlinear subscripts
enforce data dependence
references ith coupled
current data dependence

corpus/krapavin2000-test/627641.txt
girl
conceptual
sue
eat
pie
eating
hierarchy
graphs
predecessors
parents
agent
levinson
query
subsumption
canonical
ip
immediate
person
formation
fig
generalization
referent
generalizations
act
instructions
subhierarchies
kitchen
garner
tsui
specializations
fuse
conforms
successors
marker
food
piece
differences
specialization
subtype
woods
mappings
animate
sentences
database
topological
adjacent
compressed
subgraph
breadth
markers
uds
chess
compilation
restrict
arcs
concept
subhierarchy
insert
cat
supertype
entity
labels
morph
canon
coatoms
restrictref
parent
object
children
files
concepts
dog
conformity
traversal
absurd
arc
redundant
instruction
traversing
storing
file
sentence
join
morphisms
subtypes
specialized
compression
linked
conform
queue
rules
manner
acgs
queensland
colomb
whitepawn
fritz
kayed
unifiable
oev
oddprime
compiled
taxonomy
searching
inserting
attribute
search
predecessor
lempel
referents
ffg
morphism
joining
ith
kl
ffl
examine
answers
matching
neighbourhood
ziv
falsity
compresses
canonically
lehmann
fast
mapping
reconstructed
wn
indexing
prime
derivable
hierarchies
duplicate
enqueue
ahmad
incomparable
stored
relations
linking
ontologies
retrieval
intersection
derivations
chy
compressing
traversed
existential
phase
acyclic
copy
duplicates
classification
addressable
priority
hierar
levin
walking
ordering
effected
generic
denotation
read
chemical
maps
largest
match
unification
lattice
depth
son
removal
mode
querying
traverse
schemas
figs
column
robert
conceptual graphs
generalization hierarchy
girl sue
agent eat
conceptual graph
formation rules
immediate predecessors
query graph
canonical formation
adjacent graphs
manner fast
query u
eat object
eating fast
type labels
object pie
piece piece
graph u
eating pie
parents method
generalization space
immediate successors
canonical graphs
database graphs
immediate generalizations
eat manner
largest parent
sue agent
insert u
individual marker
topological search
person sue
act object
pie girl
pie fast
graphs u
levinson 6
pie object
object agent
conceptual relations
object entity
database graph
maximal common
girl eat
eat person
immediate specializations
woods 16
marker conforms
breadth first
first search
concept c
agent act
fig 7
u c
u v
graph v
graph d
first phase
eat agent
individual markers
identical concepts
specialized cases
c c3
conformity relation
referent c
eat pie
conceptual relation
ith arc
act agent
sue d
specialization space
location kitchen
kitchen agent
compressed using
partial order
knowledge base
second phase
b u
graphs b
subsumption test
graph f
common subtype
d u
redundant data
type c
predecessors match
match v
entity manner
function immediate
performing matching
graph differences
manner act
common computation
eat girl
fast girl
simple instructions
u ip
subgraph morphism
ip u
canonical formation rules
hierarchy in fig
piece piece piece
sue is eating
eat object pie
generalization of u
girl is eating
agent eat object
garner and tsui
eat manner fast
sue agent eat
act object entity
girl sue agent
eating pie fast
agent eat manner
agent eat person
u in fig
tsui s method
individual marker conforms
u is identical
conceptual graphs u
maximal common subtype
person is eating
kitchen agent eat
c in u
compilation of conceptual
location kitchen agent
order over conceptual
differences between adjacent
breadth first search
set of immediate
u and v
set of sentences
predecessors match v
girl eat agent
conceptual graph theory
girl sue eating
entity manner act
graphs in fig
eat agent eat
girl sue pie
conforms to type
immediate successors ip
immediate predecessors u
manner act attribute
query graph u
act agent act
must be linked
manner fast girl
graphs as differences
procedure insert u
eat person object
object entity manner
sue girl sue
processing between graphs
agent act object
traversing the hierarchy
minimal common supertype
subgraph of u
shows the size
acyclic graph representing
redundant data use
fast girl eat
pie object agent
agent person sue
c c3 r2
elements of ip
three ways removal
pie girl sue
set of conceptual
ignore redundant checks
v 2 ip

corpus/krapavin2000-test/628059.txt
inds
fds
bcnf
sigma
chase
noncircular
schema
ind
anomalies
database
idnf
vrfnf
superkey
ftg
integrity
redundancy
insertion
fd
tuple
circular
arfnf
lect
entity
rfnf
generalised
implication
stud
violation
enrol
relational
boyce
redundant
proj
interact
normal
dependencies
codd
inclusion
interaction
dependency
head
attribute
emp
compatible
modification
schemas
nontrivial
employee
anomaly
proper
attributes
normalisation
zeros
verified
formalise
tuples
pullback
axiom
libkin
satisfaction
formalised
characterise
insertions
lecturer
leonid
id
department
student
arenas
understood
stands
implied
xml
keys
functional
violated
unary
update
inference
logically
referential
marcelo
noncircularity
addressg
junhu
ld
nonempty
justification
hd
pairwise
enforcement
databases
project
fug
armstrong
stating
said
fr
deletion
contrary
typed
relation
elimination
presence
ab
undecidable
projection
firstly
petit
wb
forms
multivalued
proposition
relations
sigart
departments
enforcing
arise
sigmod
employees
fag
generalise
semantic
subclasses
sigact
satisfies
free
uniqueness
bg
secondly
twenty
propagation
va
title
marc
theoretic
propagate
normalization
fhead
kolahi
disagrees
snowflake
enrolg
noninteraction
overr
marchi
nonredundant
nameg
femp
cosmadakis
fenrol
fstud
abstractfunctional
solmaz
redudnancy
initialise
ferraggine
ename
casanova
millist
chengfei
jixue
concluding
rule
violating
consistency
database schema
schema r
chase d
entity integrity
chase procedure
implication problem
r j
modification anomalies
proper circular
insertion anomalies
normal form
ind r
generalised entity
database d
relation schema
fds f
database design
noncircular inds
d ftg
key based
d sigma
update anomalies
relation r
inclusion dependency
d 0
stud id
x r
current state
normal forms
single tuple
superkey based
dependency normal
satisfies generalised
insertion violation
j y
ind rule
redundancy free
free normal
r 2
definition 2
circular inds
relation schemas
nontrivial ind
attribute redundancy
codd normal
distinct value
boyce codd
let r
r given
axiom system
inclusion dependencies
set sigma
inference rule
redundancy problems
student stud
based update
pairwise consistency
nonempty relation
pullback inference
let d
y r
non interaction
redundant since
f j
relational database
fds and inds
set of fds
respect to f
set of inds
database schema r
bcnf with respect
free of insertion
respect to sigma
generalised entity integrity
x r j
presence of fds
r i x
r is free
r j y
d over r
chase d sigma
sigma is reduced
free of modification
chase d ftg
state of r
relation in d
inds over r
database over r
vrfnf with respect
fds and noncircular
compatible with d
superkey for r
inclusion dependency normal
satisfies generalised entity
sigma of fds
f and inds
relation schema r
r i 2
redundancy free normal
sigma is understood
dependency normal form
understood from context
state of d
codd normal form
boyce codd normal
free normal form
problem for fds
d 0 6j
proper circular inds
database d 0
easily be verified
r 2 d
redundant with respect
j with respect
definition 2 10
relation over r
d with respect
key based update
f over r
schema with attributes
inds a set
ind r x
verified that sigma
d but chase
schema r 2
violation of entity

corpus/krapavin2000-test/626675.txt
instruction
branch
sequencing
pipeline
instructions
branches
slots
inline
insertion
fetch
predicted
target
scratched
refill
redirects
pif
prediction
successors
incorrectly
compiler
pipelined
fetched
mcfarling
iti
delayed
expansion
hardware
unlikely
ref
inclusively
hennessy
risc
squashing
sif
interrupt
ill
likely
restructuring
exception
threshhold
benchmarks
mips
compile
processors
cycle
ps
fallthru
interrupts
redirect
deep
address
pipelining
delay
buffers
slot
timing
sequential
illinois
cycles
addresses
static
freeze
incorrect
unconditional
pipelines
branching
contract
profile
cyclone
microarchitecture
processor
code
frequency
clock
stage
assisted
stages
freezes
reload
af
inserted
clean
ex
efficiency
executed
superpipelined
originals
wisq
nonproductive
uncond
refilling
jsep
restartable
minicomputer
hoevel
iclass
locations
fetches
tradeoffs
nasa
correctness
exceptions
accuracy
diagram
successor
hps
rupt
bison
opcode
spur
crisp
nonstop
cs
executing
compiling
execution
fill
repair
fetching
aerospace
espresso
conte
motorola
hwu
vax
inputs
microprocessor
program
lemma
return
microcode
aeronautics
percentage
programs
arc
architecture
predicting
stanford
ncr
checkpoint
nag
threshold
predict
superscalar
machines
impact
subdividing
ao
mip
ensures
reaches
emerging
issue
champaign
folding
naval
urbana
administration
saved
peak
chip
correctly
subsequent
supercomputer
save
cancel
infrequently
filled
visited
unix
adjusted
cad
profiling
startup
cond
duplicate
buffer
scalar
resume
architectures
rate
office
inserting
dynamic
counter
issuing
column
ibm
format
target insertion
inline target
sequencing pipeline
instruction sequencing
instruction fetch
likely branch
likely branches
original address
code expansion
insertion slots
instruction issue
predicted successors
multiple instruction
branch prediction
incorrectly predicted
branch target
branch slots
sequencing efficiency
instruction sequence
per instruction
delay slots
ref ill
branch instructions
pipelined processors
code restructuring
predicted branch
sequential instruction
order execution
exception return
subsequent instructions
target buffers
sequencing cost
delayed branches
pipeline implementation
unlikely branch
next sequential
interrupt exception
deep pipelining
target address
code size
n inclusively
clock frequency
execution machines
ex stage
hardware methods
branch direction
delayed branching
sequential locations
dynamic instructions
pif performs
compile time
dynamic instruction
h 0
timing diagram
prediction accuracy
c compiler
predicted successor
fetch pipeline
true proof
unlikely branches
fetch algorithm
branch delay
per cycle
also true
branch instruction
compiler implementation
instruction execution
cycles per
pipelined instruction
compiler assisted
taken pif
target instruction
freeze cycles
target addresses
branches among
incorrect branch
sequencing rate
time branch
relative sequencing
unit processors
expansion control
branch redirects
time code
machine language
static code
target buffer
fetch address
profile information
cost per
contract n00014
inline target insertion
multiple instruction issue
instruction sequencing efficiency
redirects the instruction
incorrectly predicted branch
branch target buffers
mcfarling and hennessy
pipelining and multiple
order execution machines
number of slots
cycles per instruction
figure 8 e
sequencing cost per
sequential instruction fetch
instruction fetch algorithm
compiler and pipeline
instruction fetch pipeline
cost per instruction
branches with squashing
impact i c
compile time code
number of instructions
r t 1
compare and branch
redirect the instruction
code expansion control
pipelined instruction fetch
cost of branches
relative sequencing cost
static code size
incorrect branch prediction
interrupt exception return
time branch prediction
time code restructuring
compile time branch
taken pif performs
ps i 1
branch target buffer
branch prediction accuracy
instructions per cycle
reducing the cost
performs a f
interrupts and exceptions
predict the branch
insertion is correct
sequencing for pipelined
next sequential instruction
multiple functional unit
reaches the end
next n sequential
instruction is 1
machine language program
code restructuring algorithm
case the branch
functional unit processors
n predicted successors
may be scratched
also true proof
insertion slots see
instruction fetch unit
cs i n
stage in cycle
branch prediction strategies
instruction sequencing mechanism

corpus/krapavin2000-test/1013681.txt
player
adversary
jobs
competitive
target
er
job
sjt
signal
airs
gene
wrr
targets
breakpoint
adversarial
chance
tjs
probabilities
scheduling
chromosome
breakpoints
suppressor
irr
genes
knows
signals
bayesian
harmonic
players
ratio
rmax
regret
scenario
fractions
completion
strategy
dierent
clinical
xed
diuse
nonclairvoyant
rightmost
preemptive
candidate
jt
candidates
games
assigns
denition
entropy
tumor
online
randomized
root
decision
partner
gets
nished
robin
deadline
unknown
sjr
nish
costs
weights
sn
adversaries
devoted
clairvoyant
damaged
st
innite
malicious
omniscient
damaschke
randomization
minimizing
game
posterior
schedules
ignorant
shut
deterministic
versions
xes
devote
maximized
density
searching
strategies
achieves
raise
schedule
freely
resembles
round
dene
rst
spent
prex
stretch
likelihoods
slowdown
children
equidistant
smith
motivation
moment
interval
rr
monotone
comparative
intervals
proportional
axis
constantly
permanently
shannon
decreasing
weighted
xn
sided
minimize
ith
prior
forwarded
overloaded
dened
selects
actions
falsication
lthi
devotes
nerman
searcher
imagines
somatic
grange
amazingly
matical
knocked
unforeseeable
vivid
olle
looses
uniformityo
omnipotent
sahlgrenska
misinterpreted
martinsson
dures
slighted
gothenburg
unawareness
bergkvist
cells
fraction
ik
robot
dier
remark
object
child
completes
favor
dening
objects
wishes
informative
nally
nds
opt
tommy
uncountably
probabil
normalizations
healthy
surprises
fortune
fools
grows
supposed
decrease
minimized
preemptions
mathe
wheel
fatal
chalmers
searchers
mutations
tree
multiplicative
action
line player
competitive ratio
decision times
chance node
p sjt
target probabilities
line strategy
player gets
x tjs
adversarial root
target job
rightmost breakpoint
chance nodes
optimal competitive
completion time
c j
suppressor gene
signal density
candidate genes
l o
o g
w l
x k
signal probabilities
decision time
player knows
bayesian model
problem versions
jobs results
start processing
ratio er
target candidates
airs model
adversary assigns
decreasing c
scenario 2
line scheduling
chosen according
competitive analysis
deterministic strategy
target decision
optimal solution
airs framework
er n
diuse adversary
short job
results scenario
harmonic achieves
randomized strategies
scenario 4
target completion
scenario 5
partner chromosome
target candidate
nonclairvoyant scheduling
prior probabilities
optimal strategy
jt j
probabilities p
st c
xed weight
random signal
time fraction
one target
times c
expected completion
deadline scheduling
lemma 4
line problems
comparative analysis
round robin
scenario 1
following strategy
non decreasing
theorem 3
preemptive scheduling
adversary may
running jobs
scheduling search
shows theorem
target probability
adversary node
root entropy
randomized adversaries
er measures
multiplicative regret
airs setting
breakpoint falls
line players
ordered targets
unknown decision
adversary xes
gene search
sided signals
achieves er
expected index
given probabilities
scheduling online
overloaded systems
clairvoyant scheduling
robot searching
line player gets
knows the target
l o g
w l o
line player knows
optimal competitive ratio
non decreasing c
processing the jobs
knows the p
competitive ratio er
x k x
x k 1
denition of competitive
player and adversary
level of chance
known and unknown
deterministic on line
target completion time
target is chosen
expected completion time
smith s rule
k x k
one by one
theorem 3 4
scheduling online computation
target probabilities p
beyond competitive analysis
online parallel heuristics
preemptive on line
jobs adversarial root
job as target
o g consider
one sided signals
jobs results scenario
jobs before shut
assigns target probabilities
totally ordered targets
unknown decision times
decision times c
p sjt x
heuristics and robot
target and assigns
o line player
know the c
target candidate points
jobs not nished
non clairvoyant scheduling
targets and one
reached c j

corpus/krapavin2000-test/1035752.txt
cgss
cgs
poss
db
pb
phi
hcgs
inst
hb
minstate
happened
monitor
possconjalg
clocks
initstates
lattice
detection
detecting
events
predicates
timestamps
clock
sublattice
modalities
fromentin
makesc
event
occurred
endif
synchronization
cohrnt
alagar
scgss
raynal
marzullo
waldecker
venkatesan
predicate
queues
pr
jcgs
scgs
conjunctive
satellite
ideals
definitely
lock
advancing
leases
orderings
timers
garg
records
timestamp
hev
coherence
heads
iff
concurrent
ordering
cooper
record
priority
timestamped
hs
worst
invariants
held
properly
modality
queue
head
ev
causal
cached
succ
idx
stoller
unstable
satisfying
piggybacking
indiana
synchronized
endwhile
asynchronous
violations
informally
overlapped
depth
monitoring
ideal
ptri
lambdaptr
dce
extractmin
rof
depthfirstsearch
getmin
truthify
en
consistent
ne
hk
maximal
interval
message
detect
underlies
immediate
ntp
consis
oei
osf
expires
receive
predecessors
waits
pred
sublattices
gs
wise
detected
uncertainty
ptr
lifetime
meanings
removes
loop
protocol
minimal
atomic
file
computations
tm
satisfies
strongly
received
successor
nfs
falsify
debugging
executions
observers
tolerant
transaction
overlap
maintain
interprocess
oe
server
channel
suffices
expanding
returns
processes
global
disjunct
irreflexive
epsilon
sends
advance
send
exploration
started
lamport
constituent
messages
mu
inevitable
adapted
synchronizing
log
fragment
pairwise
barrier
commits
calls
receiving
asymptotic
hi
timeout
tackle
optimizations
reflexive
tens
inform
local states
local state
global state
poss db
computation c
satisfying phi
poss hb
state g
initial cgs
case time
global states
cgs db
detecting poss
clock synchronization
detection algorithms
time complexity
computation satisfies
hcgs pb
cgs pb
global predicates
inst phi
satisfies poss
possconjalg true
db c
satellite data
partial ordering
distributed systems
head q
hcgs c
worst case
line detection
o n
event e
detecting global
distributed computations
detection based
depth first
interval timestamp
wise total
properly hb
maintain invariants
o d4
add records
detecting inst
db phi
cgs g
empty p
process wise
jcgs db
state satisfying
first search
time clocks
g 0
non empty
key c
predicate detection
o ne
c 1
n e
log n
one event
priority queues
o 3
initstates g
minimal increase
cgs satisfying
modalities based
hev c
immediate successor
fixed bound
predicate phi
timestamped local
invariants j1
lattice hcgs
total partial
interval timestamps
receive events
ne local
cgss vs
possibly occurred
strongly concurrent
ev c
last local
e cgss
hcgs db
phi iff
e occurred
process names
monitor waits
one process
w c
e 2
e 1
local computation
unique minimal
takes o
p 2
every event
real time
pb c
every maximal
conjunctive predicates
maximal path
advancing one
p 1
complexity analysis
process j
coherence protocol
c satisfies
unstable predicates
g 2
global state g
case time complexity
worst case time
predicates in distributed
number of cgss
lattice of cgss
algorithms for detecting
based on happened
algorithm for detecting
fromentin and raynal
state satisfying phi
global state satisfying
detection of global
alagar and venkatesan
error between clocks
o 3 n
detecting poss db
garg and waldecker
depth first search
o d4 e
computation satisfies poss
poss db phi
real time clocks
state of process
non empty p
process wise total
contains a record
record with key
log n e
cgs db c
definition of cgs
cooper and marzullo
happened before relation
contained in every
cgs pb c
wise total partial
path of hcgs
pr s 7
process by one
quality of clock
cgs satisfying phi
o ne local
every maximal path
overlapped in time
ne local states
advancing one process
non empty queues
satisfies poss db
computation c 1
collection of local
yields a cgs
g 0 pr
consistent global states
total partial ordering
last local state
algorithm in figure
every event e
loop in figure
ideals of hev
linear in e
ordering on events
detecting poss hb
p 1 contains
poss hb phi
predicate of interest
data i p
inter event times
states in g
error in clock
priority queue p

corpus/krapavin2000-test/1015045.txt
tgdh
gdh
ckd
str
bd
blinded
member
members
agreement
exponentiations
sponsor
group
membership
secure
keys
protocol
diffie
protocols
hellman
controller
spread
leave
contributory
rsa
broadcasts
rounds
milliseconds
join
merge
br
token
round
multicast
broadcast
communication
synchrony
security
jhu
reliable
peer
wan
modular
cliques
dh
icu
verifications
exponentiation
exponent
session
messages
toolkit
lan
key
attacks
testbed
openssl
securering
secret
msec
ensemble
uci
collaborative
costs
signature
signatures
modulus
message
daemon
management
expensive
groups
cryptographic
library
bk
partition
burmester
thirteen
tree
service
services
pcs
desmedt
authenticated
leaving
ika
antigone
pfs
wans
party
bit
events
secrecy
rekeying
outsider
unicasts
totem
establishment
centralized
sender
refreshing
securing
exchange
event
server
isis
agreed
height
public
conceptual
keying
receipt
authentication
partitionable
oldest
notable
unicast
hopkins
brk
tzeng
rekey
teleconference
rightmost
insecure
virtual
platform
five
channels
provably
delay
horus
avl
sponsors
irvine
shallowest
sages
bits
client
fault
joining
ring
tolerant
root
mem
multiplications
blown
multicasts
steer
refreshes
rampart
transis
mhz
sessions
mes
delivery
network
wide
insider
trip
entity
integrated
pairwise
bimodal
rus
performer
distribute
negligible
computes
policy
ber
imbalanced
balanced
contribution
pentium
receiving
chinese
logarithmically
lans
merging
integrity
hl
bers
leaf
hidden
passive
overhead
robustness
deteriorates
sensor
korea
charged
machines
runs
setup
factoring
cpu
area
group key
key agreement
group communication
group controller
group size
diffie hellman
agreement protocols
group membership
blinded keys
key management
secure spread
key tree
communication system
group member
gdh str
membership service
reliable group
group members
r br
br r
modular exponentiations
new member
current group
bd ckd
ckd gdh
wide area
secure group
key server
str tgdh
merge protocol
virtual synchrony
new group
hellman key
agreement protocol
new key
group diffie
membership change
membership changes
computation costs
size members
bd protocol
blinded key
bits bd
msec group
protocol runs
peer groups
time msec
remaining member
rsa signature
members leave
every member
key exchange
party diffie
signature verifications
group keys
leave event
hidden cost
tgdh membership
key distribution
two rounds
contributory key
modular exponentiation
bit modulus
security services
communication rounds
new members
peer group
gdh protocol
group step
dh 512
tgdh protocol
five protocols
sponsor sponsor
member leave
extended virtual
partial keys
system spread
session random
communication systems
two party
dynamic peer
members join
broadcast message
one member
average time
average cost
less expensive
area networks
ordered message
toolkit supports
secure channels
leaving member
ckd protocol
burmester desmedt
exponent n
new exponent
leave dh
securing group
dynamic groups
membership protocol
underlying group
expensive protocol
bit diffie
establish secure
area group
lan setting
high delay
hellman parameter
management protocols
remaining group
group key agreement
key agreement protocols
group communication system
group key management
reliable group communication
keys and blinded
r br r
ckd gdh str
key agreement protocol
join and leave
bd ckd gdh
str and tgdh
br r br
gdh str tgdh
diffie hellman key
hellman key exchange
group diffie hellman
bits bd ckd
new group controller
group size members
time msec group
runs as follows
msec group size
group communication systems
communication and computation
secure group communication
party diffie hellman
ckd and gdh
current group controller
compute the group
number of exponentiations
str tgdh membership
two party diffie
contributory key agreement
group of size
generates a new
number of rounds
extended virtual synchrony
group membership changes
gdh and ckd
communication system spread
n 1 messages
dh 512 bits
dynamic peer groups
wide area networks
diffie hellman parameter
reliable and ordered
membership service figure
tgdh and str
list of partial
members leave dh
group membership service
performance of group
securing group communication
partition and merge
area group communication
wide area group
gdh ika 3
short term group
centralized group key
peer group communication
rsa signature verifications
size members leave
tgdh membership service
underlying group communication
member can compute
contributory group key
bit diffie hellman
leaves the group
efficient group key
key distribution scheme
members join dh
spread group communication
size members join
local and wide
members are added
centralized key distribution
key management protocols
wide area network
two communication rounds
robustness in group
efficient conference key
many to many
mhz pentium iii

corpus/krapavin2000-test/614463.txt
gac
probe
accessibility
obstacle
gacs
bent
clipping
cmm
grown
tip
truncated
cones
workpiece
ram
cone
probes
inspection
buffer
sphere
obstructed
accessible
planning
radius
dd
straight
depth
ball
cmms
stylus
directions
half
visibility
spherical
fpg
planner
cubic
setup
minkowski
penetrate
cube
faces
face
surface
solid
plane
tactile
machining
coordinate
rendered
aligned
mesh
plan
origin
graphics
offset
centered
viewing
render
bitmaps
surfaces
measuring
inspected
articulation
assembly
wgac
renishaw
endpoint
retract
curved
shading
mechanical
direction
projection
pg
solids
intersection
shrunken
hemi
rotary
approachable
orthographic
orientations
axis
volume
abstraction
shade
orientation
polyhedral
clipped
onto
penetrates
acis
approachability
spyridi
frustum
projected
component
facial
polygons
abstractions
gray
spheres
obstacles
contact
feature
optimistic
rendering
repair
initializing
requicha
shades
hardware
precision
near
bitmap
9d
radiosity
pessimistic
collisions
spatial
planes
opengl
chines
portion
robot
placed
maps
collide
locus
iff
tool
viewer
touch
complement
approximations
center
generator
tolerances
normally
distance
strips
tentative
maximize
infrequently
boundary
cylinders
map
reasoning
geometric
abstracted
light
accessed
positioned
cylinder
automatic
notice
illustrates
superset
projecting
shadow
manufacturing
placing
object
coordinates
inspec
offsetting
elmaraghy
orient
ramani
fixturing
findpath
jackman
workpieces
menq
nonobvious
abstractanalyzing
penetrating
projec
probex
spection
screw
lightest
potion
spitz
digitizer
machinability
drills
limaiem
half line
depth buffer
bent probe
truncated half
accessibility analysis
straight probe
obstacle x
clipping plane
first component
second component
d 1
coordinate measuring
far clipping
dd 1
global accessibility
radius d
line d
x fpg
direction cones
dimensional inspection
near clipping
gac x
half lines
grown obstacle
point p
solid model
accessibility cone
cubic map
direction cone
accessible directions
viewing volume
graphics hardware
radius r
computing d
probe abstractions
grown half
measuring machines
clipping operation
probe abstraction
cmm ram
inspection planning
measuring machine
regular gac
component accessibility
unit sphere
computer graphics
line 0
component d
compute d
visibility maps
setup planning
approach retract
setup orientations
world mechanical
rotary joint
tactile probe
clipping planes
grown object
automatic inspection
surface features
mechanical part
articulation point
facial mesh
gac algorithm
solid difference
spherical surface
minkowski operations
penetrate x
maps 5
accessible direction
offset point
bent probes
retract path
orthographic projection
d 2
mechanical parts
spatial reasoning
probe d
projected onto
truncated half line
half line d
line d 1
centered at p
far clipping plane
ball of radius
near clipping plane
probe can access
global accessibility cone
gac x fpg
coordinate measuring machine
computing d 1
line 0 d
access a point
half line 0
straight probe abstractions
obstructed by x
coordinate measuring machines
compute the gac
computing the gac
set of directions
approach retract path
approximate the intersection
compute the grown
planning and programming
truncated half lines
initializing the depth
computer graphics hardware
straight probe abstraction
given a direction
placed at p
choose an alternative
point of dd
first component accessibility
real world mechanical
p with respect
d 1 x
cost of computing
assume that p
algorithm to compute
used to compute

corpus/krapavin2000-test/1018238.txt
oading
surrogate
jvm
engine
device
mobile
inference
javanote
fuzzy
offloading
availmem
pervasive
remote
java
triggering
biomer
linguistic
stretch
platform
splitclass
bandwidth
wireless
lru
trigger
prototype
newmemsize
migrated
partition
monitoring
dence
partitioning
oaded
oad
availbw
plans
mb
devices
delay
kb
interaction
heap
plan
rpc
vk
transparent
candidate
accesses
chaivm
coign
jvms
resource
composite
con
memory
adaptations
moderate
runtime
guration
msk
elevator
interactions
mbps
migration
trace
invocations
baseline
adaptive
hp
rpcs
footprint
utilization
membership
speci
rtt
modi
ef
vi
monitor
triggers
pm
ps
dia
driven
redhat
gured
gurability
isnative
delity
basement
jini
accessfreq
objects
ne
constrained
metrics
metric
ed
execution
relieving
mincut
ck
decides
linux
master
relieve
discovery
native
grained
overhead
traces
simulator
splitting
pulled
traf
wi
fidelity
laptop
slave
cant
decision
bytes
merged
editor
bi
eld
classes
multimedia
adaptability
ned
adaptation
service
selects
incurring
spectra
ubiquitous
transferred
degradation
edge
nition
person
aware
module
ce
cl
threads
object
overcoming
adaptively
rst
card
middleware
elds
article
developers
developer
crash
lifetime
delivering
merging
consumes
vng
behrooz
oads
uctuation
msmax
creations
ride
fuzzi
shumao
puppeteer
lingvar
bmax
surrogates
placeholders
thinkpad
bandwidthrequirement
smert
kayak
monet
stairway
kalasapur
sesco
1diabiomer
insigni
upnp
shirazi
oading inference
inference engine
mobile device
oading platform
candidate partition
application execution
partition plan
execution graph
pervasive computing
oading system
fuzzy control
partition plans
wireless bandwidth
oading triggering
average interaction
making approaches
different decision
decision making
program objects
interaction stretch
con dence
lru algorithm
oading delay
fuzzy trigger
mobile devices
application partitioning
bandwidth requirement
memory size
remote data
constrained memory
linguistic variable
data accesses
trace driven
control model
memory constraint
object reference
oading rules
partitioning cost
triggering inference
remote function
fuzzy inference
splitting large
prototype experiments
threshold based
javanote application
memory utilization
java class
available memory
cost metric
wireless network
generic fuzzy
linguistic values
total memory
plan generation
membership function
execution time
memory sizes
total execution
splitclass fuzzy
oading action
interaction delay
engine decides
baseline memory
two jvms
remote interaction
time stretch
composite metric
comparison ratio
approaches figure
smaller memory
oading decisions
monitoring overhead
bi k
device runs
surrogate discovery
con guration
total bandwidth
fuzzy sets
computing environment
remote execution
remote objects
ef cient
graph edge
graph node
partition selection
memory footprint
java heap
large classes
large class
simple threshold
speci c
approach different
edge cost
new memory
modi ed
ne grained
numerical value
service composition
control based
resource constrained
fi k
four different
available bandwidth
current prototype
ieee 802
fuzzy logic
name space
component based
function calls
un optimized
slave device
oading prototype
constrained devices
expensive application
application speci
oading inference engine
adaptive of oading
candidate partition plan
decision making approaches
different decision making
candidate partition plans
average interaction stretch
fuzzy control model
total of oading
application execution graph
pervasive computing environment
partition plan generation
generic fuzzy inference
runtime of oading
four different decision
fuzzy inference engine
total execution time
splitting large classes
making approaches figure
simple threshold based
inference engine decides
triggers of oading
oading triggering inference
approach different decision
new of oading
remote data accesses
objects of two
decrease the bandwidth
new memory utilization
total bandwidth requirement
reduce the average
selects the best
illustrated by figure
framework for quality
remote function calls
complete of oading
largest edge cost
linguistic variable availmem
simulations and prototype
classes can reduce
availmem is within
application execution monitoring
trigger our approach
lru algorithm compared
whether of oading
amount of free
trigger approach different
remote function call
stochastic con dence
inference engine uses
response time stretch
partitioning cost metric
expensive application rewriting
requirements and interaction
fuzzy control based
resource constrained devices
system for mobile
best partition plan
neighbors of v1
memory of oading
uses a composite
linguistic of oading
partition plans generated
linguistic value low
vi and vk
composite cost metric
target memory utilization
enable more precise
decision making problems
availmem is low

corpus/krapavin2000-test/614330.txt
isosurface
cells
isovalue
cell
span
kd
visualization
extraction
iso
grids
unstructured
isosurfaces
livnat
intersect
pv
graphics
octree
sweeping
min
simplices
yarden
extrema
triangulation
sweep
nv
volume
parker
marching
hansen
tree
itoh
pointerless
koyamada
pascucci
subtree
max
united
han
bajaj
trees
utah
buckets
grid
count
submited
tetrahedral
intersected
fig
root
search
traversed
charles
johnson
striped
median
francisco
wei
october
cubes
rendering
mode
salt
triangle
intersects
lake
vertices
brain
torso
geometry
san
skip
structured
fem
wilhelms
fd
near
decomposition
gelder
scanned
sub
array
california
visualizing
mri
valerio
schikore
chandrajit
interactive
chiang
delta
jen
geometric
shen
contour
intervals
active
trim
snoeyink
cludio
heart
ray
traverse
carolina
octrees
city
polygon
vis
tracing
subgroup
spans
bucket
surface
peter
lie
searches
coordinate
seed
noise
scalar
lutz
lists
rumpf
ohlberger
encompassed
pike
doted
multidimentional
painter
shirley
worst
jack
preprocess
scientific
yi
steven
horizontal
head
fields
north
locate
recursively
neighborhood
purged
koji
takayuki
isocontouring
safari
kettner
marks
routine
mario
coherence
siggraph
silva
field
scans
accelerated
hans
yamaguchi
subranges
puppo
rossignac
sutton
thinning
jarek
bentley
node
3d
pseudo
multiresolution
perspective
park
nano
quicksort
ertl
haimes
flag
depicts
eq
milliseconds
degenerate
cpu
yasushi
montani
sloan
scopigno
criterion
isosurface extraction
kd tree
span space
iso value
active list
unstructured grids
count mode
search max
sub tree
data set
min iso
search min
value root
computer graphics
o n
sweeping simplices
optimal isosurface
max min
space decomposition
sweep list
data sets
extraction algorithm
maximum values
yarden livnat
right sub
kd trees
han wei
near optimal
geometric space
graphics v
united states
value space
structured grids
sub trees
array size
marching cubes
ff october
near search
v node
isovalue v
isosurface intersects
min pv
pv v
pointerless kd
root left
construct polygon
livnat han
francisco california
log n
volume visualization
fast triangulation
worst case
san francisco
charles hansen
neighborhood search
minimum value
new isovalue
fd 128
graphics submited
extrema graphs
skip node
cell set
build array
structured grid
min list
isosurface generation
volume data
california united
min max
october 18
large data
l bajaj
given isovalue
varying fields
span filter
salt lake
lake city
memory requirement
october 28
ray tracing
underlying domain
yi jen
minimum values
extraction proceedings
wei shen
jen chiang
cell search
n log
two sub
algorithm using
isosurface inside
simplices algorithm
search skip
average isosurface
new isosurface
min coordinate
fem u
cubes method
previous isovalue
right search
steven parker
left else
left sub
striped area
one subtree
noise algorithm
max coordinate
max iso
node right
u grid
value skip
seed cell
skip min
search phase
root right
optimized search
maximum value
o k
cells that intersect
conference on visualization
intersect the isosurface
iso value root
min iso value
using the span
number of cells
search max min
optimal isosurface extraction
isosurface extraction algorithm
visualization and computer
transactions on visualization
near optimal isosurface
right sub tree
computer graphics v
extraction algorithm using
complexity of o
minimum and maximum
francisco california united
cells that lie
set of cells
san francisco california
johnson a near
pointerless kd tree
wei and johnson
livnat han wei
pv v node
california united states
near search max
computer graphics submited
max min iso
wilhelms and gelder
intersect an isosurface
value root left
max min pv
min pv v
o n log
october 28 29
n log n
two sub trees
ff october 28
time varying fields
salt lake city
isosurface extraction proceedings
structured and unstructured
han wei shen
yi jen chiang
value root right
search min iso
itoh and koyamada
geometric space g
search min max
left sub tree
search skip min
kd tree construction
iso value skip
root s cell
array size criterion
max iso value
sweeping simplices algorithm
line at v
isosurface extraction methods
value skip node
skip min iso
fem u grid
marching cubes method
node s minimum
build array size
need to traverse
large data sets
maximum and minimum
lake city utah
city utah united
research triangle park
october 18 23
triangle park north
visualization 98 p
park north carolina
utah united states
north carolina united
carolina united states
bajaj valerio pascucci
interactive ray tracing
value is greater

corpus/krapavin2000-test/628284.txt
toprof
profpage
coursepage
proflistpage
dname
pname
page
tocourse
navigational
pages
deptpage
web
professors
query
piproflist
proflist
cname
courses
site
nalg
navigations
pointer
join
attribute
relational
navigation
link
courselist
picourselist
plans
sessionpage
toses
todept
deptlistpage
navigate
adm
chasing
url
sessionlistpage
views
external
algebra
plan
piseslist
conferences
vldb
navigating
nested
profdept
pideptlist
sites
queries
chase
taught
joins
araneus
inclusion
attributes
html
hypertext
department
ses
professor
mono
selections
deptlist
courseinstructor
links
databases
session
1d
unnest
ull
rewritings
relations
gamma
querying
rewriting
pi
expressions
computable
optimizer
pushing
declarative
rank
tuple
extents
redundancies
navigates
accesses
dept
instructors
dcoursepage
monovalued
dprofpage
navigated
materialized
email
oriented
home
entry
rewrite
indices
downloads
atzeni
descr
paths
oe
bibliography
schemes
rule
hypertextual
2d
projections
valued
optimization
default
redundancy
teach
graduate
pointers
database
formalize
accessed
enrich
favor
departments
documented
push
excessively
text
joining
urls
radically
optimizing
name
network
contrary
tuples
object
expensive
documents
expression
translate
engine
constraints
projection
rules
constraint
remote
author
algebraic
sql
expands
answer
containments
listname
seslist
gem
tocoursed
tre
igations
nazionale
legenda
gammamail
ulixes
trier
delle
doni
instructor
fictional
weboql
pia
ricerche
toprofd
materializes
dsessionpage
consiglio
masci
confer
ddprofpage
abstractlarge
materializing
auxiliary
fall
operators
pushed
virtual
rewritten
reached
ordinary
concentrate
access
issued
page scheme
navigational algebra
external relation
page schemes
pointer join
toprof gamma
r 1
proflistpage piproflist
query optimization
attribute l
piproflist toprof
relational views
inclusion constraints
page relations
link constraint
gamma profpage
type link
cost model
pointer chasing
proflist toprof
pointer chase
link constraints
data model
web sites
access structures
network accesses
external relations
pointer sets
gamma coursepage
courses taught
sessionlistpage piseslist
tocourse gamma
full professors
science department
r 2
object oriented
entry points
rule 8
oe ses
araneus data
mono valued
deptlistpage pideptlist
relational view
pname dname
link attribute
web type
ses f
default navigations
piseslist toses
join approach
toses gamma
constraint r
oriented query
relations r
execution plans
page relation
external view
oriented databases
rewriting rules
nested relation
relational databases
home page
rule 6
path expressions
deptpage proflist
dname deptpage
pideptlist todept
candidate execution
deptpage dname
three vldb
web scheme
ull 0
dname profpage
deptpage piproflist
plan 2d
navigation plans
source relation
declarative queries
profpage pname
profpage picourselist
dname pname
vldb conferences
plan 1d
rank email
dname address
department page
coursepage rule
courselist tocourse
valued web
inclusion constraint
proflistpage proflist
toprof proflistpage
picourselist tocourse
following links
profpage courselist
courselist cname
f ull
sessionpage picourselist
nested attribute
graduate courses
entry point
access paths
query engine
two pointer
query name
virtual views
r 3
web site
two page
rule 9
index html
two relations
rule 1
query plan
materialized views
one among
suppose also
selecting one
given two
network access
computer science
rule 4
multi valued
suppose x
proflistpage piproflist toprof
piproflist toprof gamma
toprof gamma profpage
link to r
relations r 1
associated with l
tocourse gamma coursepage
l of type
computer science department
object oriented query
araneus data model
f all 0
oe ses f
given two relations
sessionlistpage piseslist toses
piseslist toses gamma
link constraint r
pointer join approach
link and inclusion
taught by full
object oriented databases
two relations r
valued web type
constraint r 1
last three vldb
selecting one among
proflistpage proflist toprof
candidate execution plans
f ull 0
navigate the site
picourselist tocourse gamma
two pointer sets
toprof proflistpage proflist
r 2 suppose
gamma coursepage rule
deptlistpage pideptlist todept
scheme in figure
r 1 suppose
attributes of r
number of network
paths to reach
cname tocourse courselist
gamma tocourse gamma
query in example
many web sites
equals the value
page scheme name
optimizing path expressions
consider the department
lack of control
approaches to query
different navigation paths
access to relevant
dname deptpage dname
expands the source
name and e
professors and courses
nalg rewriting rules
finding all links
links to courses
dname profpage dname
pname rank email
view as follows
given relations r
full professors ii
views over network
links between data
attribute of p
university web site
toses gamma tocourse
access support relations
deptpage dname profpage
hand side path
follow the link
restrict network access
cname descr oe
web a number
gamma sessionpage picourselist
constraint r 2
science department page
gamma profpage picourselist

corpus/krapavin2000-test/1035756.txt
honest
witness
corrupt
wan
deliver
protocol
message
sender
peers
conflicting
processes
regime
signatures
messages
byzantine
witnesses
faultless
multicast
seq
signed
delivered
echo
av
exchanges
failures
quorum
agreement
participating
sends
regimes
recovery
active
authenticated
secure
quorums
cryptographic
rampart
members
faulty
timeout
resiliency
reliable
broadcast
delivery
acknowledgments
keys
intersect
mes
member
protocols
adversary
signature
malicious
acknowledgment
dissemination
delivers
availability
contents
intruder
reiter
digital
participants
consistency
failure
behalf
integrity
receives
resorted
sages
executes
infinity
overhead
reliability
cnt
collude
generals
validations
probabilistic
asynchronous
payload
malkhi
deliveries
intolerable
public
incurs
consensus
sign
borrows
relaxing
probe
sage
acknowledges
send
cryptosystems
private
scenarios
guarantee
attack
deviate
incurring
period
sent
replies
probes
probability
impossibility
bringing
tolerated
likewise
received
ack
destination
reply
peer
safety
albeit
cooperation
hashes
deliv
crypt
deliverable
haber
png
reprint
toueg
originators
resale
randomizes
copyrighted
inition
icdcs
negligable
ascertains
idirectly
fraction
forming
goes
despite
prohibitive
opportunity
eventually
promotional
inconsistently
myampersandohgr
sult
copyright
rupt
designating
authenticity
authenticates
material
acknowledge
exchanged
randomly
effectively
reverts
dahlia
disclose
acknowledging
wool
transis
avishai
impersonate
vanishingly
signing
behaving
digest
passed
valid
communicating
agree
collaborating
attributable
unsolvable
weakened
authentic
cryptographically
stamping
secondly
sending
incurred
generations
corrupting
wright
forge
avail
signa
rebecca
parame
threshold
distribute
concurrently
attempts
witness m
deliver m
honest processes
sender m
wan deliver
witness set
honest process
conflicting messages
seq m
p j
message exchanges
corrupt processes
message m
performs wan
multicast m
wan multicast
conflicting message
honest member
two honest
recovery regime
executes wan
failure regime
witness sets
digital signatures
signed acknowledgment
e protocol
m p
process p
reliable broadcast
previously received
timeout period
let p
process participating
peers h
honest members
signed acknowledgments
faultless scenarios
authenticated message
valid acknowledgments
processes may
processes participating
m 0
reliable multicast
quorum systems
m goes
every message
d n
secure reliable
consistency requirement
m executed
sends av
integrity self
executed wan
eventually p
previously delivered
message av
probabilistic agreement
delivered p
member p
k authenticated
two regimes
obtain signed
av deliver
self delivery
corrupt process
corrupt witness
echo protocol
multicast protocol
p h
different messages
message complexity
theta k
case scenario
every process
theorem 4
additionally theta
systems total
set witness
forming agreement
message 3t
protocol execution
sends 3t
active t protocol
wan deliver m
performs wan deliver
two honest processes
wan multicast m
p i receives
j be two
message was previously
protocol if p
receives a message
p i performs
p i sends
m is honest
sends a signed
authenticated message exchanges
seq m goes
honest process participating
acknowledgments for m
must have obtained
honest processes participating
obtained a set
p i executes
goes to infinity
deliver m p
signatures and message
corrupt witness set
limit as seq
case of failures
executes wan deliver
relaxing the consistency
executed wan multicast
p i deliver
integrity self delivery
av deliver m
previously delivered p
gamma 1 3c
theta k authenticated
obtain signed acknowledgments
k authenticated message
honest member p
period has passed
member p h
sender m executed
m executed wan
set of d
p to obtain
b n gamma
secure reliable multicast
deliver a message
p i must
reliable multicast protocol
obtain a set
worst case scenario
set of processes
agreement on message
witness m witness
p executes wan
regime and additionally
deliver m 0
j deliver m
algorithms for asynchronous
least one honest

corpus/krapavin2000-test/606884.txt
gu
skorokhod
gj
entrant
qi
dv
rf
nonnegative
ni
xi
mq
idling
gi
rn
saddle
hamiltonian
uniqueness
complementarity
lipschitz
orthant
xb
queueing
dynamics
server
queue
load
boundary
filippov
ej
bf
aj
ji
interior
dierential
hu
dt
fluid
uu
hamilton
service
gub
gua
pgu
optimality
ai
ik
exogenous
maximizer
loads
verifications
viscosity
xa
queues
continuity
supremum
trajectory
family
reflection
gtj
gei
mjt
jk
wi
tn
dai
calculations
confirmed
mj
di
arrivals
andi
policy
customers
feedback
jj
inequalities
integrable
dj
convex
jacobi
virtue
ui
confirmation
accord
idi
siui
uand
nlt
isaacs
draining
andq
akj
uis
inflow
game
stability
nonempty
projection
strategies
confirming
departures
eect
calculation
velocity
xj
nonzero
coordinate
unserved
dupuis
piecewise
strategy
scalar
existence
dicult
maximal
exit
singleton
pi
trac
uwe
infimum
stochastic
nj
backwards
qualifications
formulas
origin
entries
exceptions
criterion
confirm
dierent
assertions
region
outer
deductive
qualification
xk
lag
staged
gradient
imply
compact
ray
reaches
representable
invariant
exclude
suciently
ak
suces
maximizes
entry
observe
formulation
lemma
confirms
sn
coecients
numerically
invoke
sucient
manifold
satisfied
exception
servers
assertion
insist
pl
verify
q gu
gu 0
re entrant
dv x
x v
skorokhod problem
load q
v x
u x
skorokhod dynamics
x q
non idling
p gu
x k
p x
minimum performance
qi 0
x 0
p t1
x t1
j j
saddle point
given x
invariant control
nonnegative orthant
ni p
complementarity problem
performance criterion
x p
maximal sequence
server re
mq g2
x dv
strategy x
gu q
p rf
loads q
projection map
state feedback
single server
mq gu
robust control
x gu
optimal service
fluid models
rf q
hamilton jacobi
hu x
viscosity sense
control vector
velocity projection
entry queue
x mq
state trajectory
optimal control
queueing systems
control functions
j j1
xi 0
new arrivals
point conditions
control function
scalar multiple
optimal policy
rf v
gtj gj
control vectors
mjt mj
boundary verifications
special solution
gj x
server examples
feasible maximizer
bf p
stability property
vertical boundary
gj j
exit k
compact subset
reflection matrix
nonnegative load
individual hamiltonian
outer boundary
v rn
queueing applications
ni gu
lipschitz continuity
gi j
entrant line
quadratic programming
function v
f l
hamiltonian system
multiple server
trajectory x
nonnegative entries
conditions 25
numerous examples
simply take
x t p
x q gu
u t x
x 0 q
minimum performance criterion
p gu 0
x t remains
l i x
gu q gu
q gu q
ni p gu
server re entrant
x t 2
invariant control vector
q t gu
rf q gu
x t1 p
saddle point conditions
velocity projection map
x t x
x t k
x 0 k
section 2 4
f i x
control functions u
state trajectory x
p t1 p
queues are empty
qi t 0
given x k
single server re
x t1 x
verifications of section
g and u0
resulting state trajectory
bf p gu
point conditions 25
control function u
construction of v
x x q
re entrant line
invariant control vectors
x dv x
function v x
given x 0
family of solutions
j j j
observe that since

corpus/krapavin2000-test/1013566.txt
impl
metalogical
maude
logic
rewriting
itp
theories
meta
frameworks
ective
equational
ection
module
logics
induction
inductive
metatheory
subsort
deduction
membership
metatheorem
metalevel
initiality
metatheoretic
sentconstant
reasoning
nat
rewrite
mb
makenewgoalsetf
universal
logical
arrow
entailment
formalize
extractrulesystem
metatheorems
inference
prover
axioms
principles
meseguer
bool
denitions
formula
axiom
reflection
intstring
metarepresentation
modules
abstractly
mod
sort
parameterized
formulae
reied
concretely
soundly
idx
sentences
clauses
horn
scoped
alpha
proving
vars
constructors
jos
dened
findsortv
getvars
fmod
metalogic
implicative
metathe
gomyampersanduml
proveininitial
reflective
dierent
ory
deductive
derivations
rules
beta
calculus
metamathematics
nuprl
syntax
sound
formalized
satised
conditional
lf
subscrpt
inductively
specied
ected
goals
proven
minimal
proofs
sequents
hol
rosser
none
re
signature
church
rewrites
rl
isabelle
theorems
strategies
implication
fs
quantied
denable
institutions
eective
formalization
rst
propositional
realization
gateway
xs
sen
del
sorts
object
conservatively
hilbert
calculi
equality
lm
shorthand
families
modulo
universally
modal
constructions
thesis
exible
interpreter
extracts
predicate
fixedpoint
noncommittal
proveinitial
basin
goalset
bow
destructors
neutrality
sublogic
meqtl
emptygoalset
internalized
endm
verdejo
logician
xedpoint
vquantification
metarepresentations
eker
proveinvariety
rwlogic
theoremhood
ecumenical
algebra
tm
italic
terminating
commutative
assertions
abstract
semantics
dening
formal
structuring
falseg
slogan
interrelationship
oliet
nitary
narciso
metaobject
subsorts
extensionally
durn
supercompiler
trueg
entailments
sentential
metareasoning
discriminators
bruni
clavel
yaw
rewriting logic
re ective
framework logic
metalogical frameworks
logical framework
meta reduce
deduction theorem
re ection
metalogical framework
minimal logic
membership equational
universal theory
equational logic
induction principles
module meta
initial models
logical frameworks
meta level
impl impl
impl b
mb impl
inductive denitions
theorem mb
rewrite theory
sentconstant formula
metatheoretic reasoning
theory u
subsort sentconstant
maude system
formula subsort
subsort theorem
sort term
b theorem
theorem formula
inductive theorem
inference rules
object logic
sub goals
arrow impl
b impl
mod arrow
module itp
bool subsort
ective logic
including bool
c impl
none none
reduce arrow
theory e
rewrite rules
induction step
higher order
theorem prover
object logics
object level
order abstract
module m
representation function
jos meseguer
formal systems
sound reasoning
ective metalogical
entailment relations
eective metalogical
formalize theories
inductive definitions
zero nat
function makenewgoalsetf
framework theory
ective logical
meta metalevel
module minimal
reasoning principles
rule induction
equational theory
base case
formula theorem
conditional rewriting
membership algebra
abstract syntax
horn logic
inference system
meta programming
order logic
theorem proving
re ected
strong enough
using re
metathe ory
intstring idx
logic independent
underlying equational
membership equational logic
impl a impl
module meta level
theorem mb impl
sentconstant formula subsort
inductive theorem prover
formula subsort theorem
b theorem mb
subsort theorem formula
subsort sentconstant formula
impl a b
mb impl impl
b impl impl
impl b theorem
impl a theorem
meta reduce arrow
theorem and impl
reduce arrow impl
impl b c
impl a none
b c impl
logic is re
arrow is including
bool subsort sentconstant
re ective logic
including bool subsort
order abstract syntax
higher order abstract
higher order logic
theories have initial
ection and initiality
programming in logic
metatheory of rewriting
re ective metalogical
represented in itp
re ective logical
clauses that dene
conditional rewriting logic
calculus of constructions
terms of sort
logic with equality
theorem is true
dene the set
rewrite theory e
families of theories
specied in itp
logic and rewriting
sound reasoning principles
intstring idx 1
mb a theorem
using re ective
universal theory u
abstractly and concretely
rewriting logic maude
term mod arrow
rule induction along
metatheory on inductive
framework with re
appropriate base case
theorem formula mb
true in minimal
ective metalogical framework
eective metalogical framework
logic of implication
good logical framework
internal strategy languages
b is proven
framework rewriting logic
ective logical frameworks
reasoning with higher
using the equations
subsort zero nat

corpus/krapavin2000-test/631084.txt
coverage
subdomains
subdomain
universally
covers
testing
properly
criteria
mutation
suites
criterion
decision
suite
subsumes
cover
sd
sdc
adequacy
fault
mdcc
detecting
arising
faults
branch
flow
causing
inputs
weyuker
myers
program
oi
narrows
covering
failure
subsume
selection
minimized
tuples
specification
mutant
hamlet
du
nfa
exercised
software
laski
korel
paths
false
mcc
contexts
duplicates
subsumption
testers
phyllis
rise
subexpression
elaine
detect
statement
adequate
analogs
frankl
association
statements
executable
mutants
ability
tosem
strategies
edges
dc
unexecutable
practitioner
ordered
operators
applicable
associations
engineering
programs
guaranteed
clarke
avritzer
reliability
selecting
feasible
da
sigsoft
edge
tester
node
yuen
harrold
deficiency
evaluate
failures
effectiveness
boolean
path
bev
littlewood
morasca
sandro
ntafos
sub
compound
strigini
tak
jeng
anomalies
controlling
showed
occurring
inspire
exercise
argued
decisions
conditional
consisting
weiss
def
occurrences
overlapping
db
multi
partition
distributions
dr
poorer
lorenzo
negations
analytical
elementary
likely
negation
attention
satisfies
abilities
modification
alberto
loop
artifact
repetitive
goto
definitions
measures
branches
zhu
regardless
family
investigated
dividing
assessing
structural
expose
suffix
cause
executed
relations
exposed
strategy
dept
assembly
predicate
bingchiang
tacit
mumcut
fxjnot
curiosity
forgcs
dcc
ftjp
fai
anecdotal
evoke
eof
malevris
notes
likelihood
fails
mary
transitivity
summarizing
arrow
adequately
cc
condition coverage
universally properly
decision condition
properly covers
context coverage
multiple condition
properly cover
decision coverage
p uses
c 2
covers c
c 1
branch testing
test case
ordered context
failure causing
test suites
mutation testing
test suite
test cases
minimized decision
fault detecting
multi set
detecting ability
testing criteria
subdomains arising
data flow
required k
test selection
program p
cover decision
causing inputs
criterion c
cover c
coverage universally
software engineering
detecting faults
subdomain based
subdomain d
coverage criterion
input domain
software testing
covers relation
test data
decision d
causing input
covers decision
mutation operators
sd mdcc
one test
definition clear
flow testing
clear path
adequacy criteria
flow graph
sdc p
partition testing
limited mutation
uses universally
c sub
k tuples
du paths
simple oi
node n
d d
start node
satisfies c
testing methods
p use
universally applicable
coverage subdomains
oi paths
d 9
tuples criterion
coverage 0
coverage requires
coverage subsumes
every program
testing strategies
criterion requires
paths criterion
nfa property
based testing
adequacy criterion
data adequacy
d 2
edge 8
coverage proof
subdomain consisting
coverage according
relative fault
selection strategies
based criteria
data selection
d 1
let d
program specification
universally covers
expression controlling
sub multi
sub 2
decision condition coverage
multiple condition coverage
universally properly covers
universally properly cover
covers c 2
properly covers c
ordered context coverage
minimized decision condition
fault detecting ability
failure causing inputs
coverage universally properly
c 1 properly
properly cover c
one test case
evaluate to true
required k tuples
properly cover decision
cover c 2
c 1 universally
failure causing input
inputs that make
properly covers decision
covers decision coverage
definition clear path
data flow testing
path with respect
detect a fault
properly covers relation
limited mutation testing
coverage and ordered
evaluate to false
transactions on software
c 1 subsumes
likely to detect
suite that satisfies
m and e
cover decision coverage
better at detecting
set of subdomains
true at least
uses universally properly
simple oi paths
cover all p
p uses universally
cover decision condition
condition coverage universally
context coverage universally
inputs that cause
subdomain based criteria
number of failure
software engineering v
p and specification
test data adequacy
flow testing criteria
requires that every
test data selection
selection of one
false at least
require the selection
d 2 sd
edge 8 9
d d f
condition coverage subdomains
condition coverage criterion
relative fault detecting
condition coverage 0
least as likely
condition coverage requires
number of conditions
satisfies c 1
attention to programs
selecting test cases
c sub 2
c sub 1
d is d
inputs in d
sub multi set
boolean expression controlling
subsumes c 2

corpus/krapavin2000-test/1037116.txt
dst
pkt
dsr
routing
packets
packet
destination
route
hop
destinations
ood
hops
routes
query
nbr
buer
pause
rd
timeout
tag
update
src
protocol
neighbor
attachment
protocols
predecessor
reply
mac
tracing
broadcast
hoc
driven
updates
innity
send
link
ns
sent
demand
distance
ad
wireless
routers
bdcast
lh
dropped
router
node
rt
successor
neighbors
fig
newpath
forwarding
seconds
layer
nite
else
source
addr
ows
tables
overhead
percentage
sender
scenarios
permanent
forwarded
tora
wrp
msecs
promiscuous
entries
identier
entry
tra
internet
aodv
infty
simulations
peer
satised
received
delays
jk
loop
topology
discovery
queries
count
suers
sends
receive
delay
dierent
scenario
innite
loops
header
radio
stale
unicast
kbps
stack
zqs
dsdv
unreliably
rebroadcast
buered
rmv
delivery
looping
attenuation
unreliable
congestion
ow
headers
networks
cient
suered
listening
regular
movement
network
cumulative
bandwidth
prevent
sequenced
sce
parenthesis
paths
mobile
broadcasts
implied
cpt
ection
mimics
rst
static
incurs
started
stamps
miles
bellman
mobility
community
connectivity
throughput
learns
picks
ssa
ford
dt
path
caches
searches
links
ciency
emergency
simulation
qr
mimic
km
resets
picking
receiver
loses
secs
metric
maintaining
updating
eect
helps
receives
false
specication
routed
distances
host
pending
ip
elapsed
aect
dierences
collisions
plot
zrp
ilmj
bys
timeline
thatthe
bat
pkt dst
data packets
table driven
data packet
source tracing
routing table
pkt src
driven routing
control packets
routing protocols
node d
routing protocol
demand routing
distance table
regular update
query receive
receive timeout
reply update
ood search
control overhead
hoc networks
neighbor k
hop query
packet overhead
pkt hops
control packet
ad hoc
rt update
pause times
routing information
hop count
pause time
route discovery
query send
zero hop
distance vector
limited broadcast
send timeout
broadcast address
routing tables
packets received
node e
node c
send update
vector routing
pkt nbr
bdcast addr
last hop
packets run
data buer
max hops
rd add
destination bdcast
src set
dst set
maximum hop
destination j
known neighbors
dsr percentage
j rd
run number
packets sent
packet delivery
query table
update send
add else
dynamic source
delivery ratio
table entry
source routing
e cient
scenario 2
tra c
link connectivity
community networks
distance predecessor
timeout seconds
update routing
regular updates
permanent loops
infty _
forwarding layer
ood searches
distance tables
update source
unreliable updates
dsr dst
required destination
else procedure
packet pkt
routers maintain
procedure dt
dst correct
destination pkt
addr else
constants used
routing message
send false
dt update
known destinations
table driven routing
percentage of data
query receive timeout
ad hoc networks
control packet overhead
point of attachment
number of control
data packets received
query send timeout
dst and best
demand routing protocols
limited broadcast address
zero hop query
driven routing protocol
distance vector routing
number of hops
second to last
driven routing protocols
update is sent
destination bdcast addr
routing table entries
rt update send
packets run number
overhead of dsr
rd add else
else if rd
pkt src set
tag i pkt
distance table entry
pkt dst set
packet delivery ratio
entry j rd
maintain routing information
procedure rt update
used in best
pkt hops 1
control packets sent
routers maintain routing
performance of dsr
longer be sent
dsr and dst
source tracing algorithm
path to j
bdcast addr else
procedure dt update
see that best
send false rt
pkt dst correct
counting to innity
paths to destinations
update pkt nbr
update with source
overhead than dst
packets sent percentage
false rt update
e cient routing
routing in ad
ad hoc network
packet is dropped
j 2 n
shown in fig
times more control
update routing tables
either on demand
nodes e f
overhead of dst
n if rd
called for processing
number of pending
nbr k called
maximum hop count
due to unreliable
simulations for two

corpus/krapavin2000-test/609203.txt
cyclone
tal
template
mexp
codegen
splice
tempo
int
compiler
instructions
certifying
fill
hole
popcorn
specializer
annotated
templates
cut
specialization
safety
holes
italicized
env
stack
assembly
safe
code
cgdump
templatebeg
verifier
generation
scoping
region
declarations
sp
certificate
ml
dyc
dumped
eax
malloc
macros
compile
constructs
front
hidden
jumped
esp
frame
cgfill
cgstart
splc
specializers
templateend
compiled
outermost
compilation
morrisett
vis
instruction
arguments
gen
dialect
italics
typing
markers
mode
mov
float
action
fragments
precondition
modulus
cghole
specialized
lexical
postcondition
macro
program
necula
microsoft
statement
visible
analyses
italic
marker
filled
optimizations
typed
specializing
register
issued
language
stmt
emits
bugs
exp
body
dump
executable
invariants
concerns
specializa
cgabort
modifiers
cgend
untrusted
assembled
label
exponent
plate
exponentiation
programmer
object
nested
compiles
tem
translation
consel
masm
retn
shaders
normal
id
manipulating
beg
impressions
crew
lawall
statically
filling
meta
linker
dumps
popped
programs
translated
interpreter
statements
allocating
args
return
generators
fig
ffl
evaluated
julia
encountered
certified
pointer
jump
closures
emitted
invariant
security
translating
allocate
box
caught
notices
mobile
func
fills
source
generating
concatenated
declares
unsafe
writer
transforms
loop
translates
translate
sigplan
speedup
generates
manipulated
aircraft
aborts
frames
usable
expression
bindings
appended
environments
gram
static
expands
allocates
neces
strmer
modifier
plesko
helsen
blau
ible
tered
provokes
codegens
code generation
run time
time code
action annotated
object code
mexp sp
certifying compiler
generation region
annotated program
cyclone program
mexp gen
type safe
template code
assembly language
front end
time specializer
function mexp
return codegen
m templatebeg
cyclone compiler
codegen int
dynamic code
type safety
f int
local variables
certifying compilation
normal mode
int mexp
time specialization
codegen cut
cut splice
splice statement
italicized constructs
tal instructions
fill holes
cut statement
ml box
c program
int f
lexical scoping
code fragments
type system
typing rules
m templateend
non italicized
template end
esp 0
template mode
codegen expression
l hole
int base
compile cyclone
cyclone env
safe dialect
l template
tempo front
e vis
meta ml
invariant arguments
generation process
first template
morrisett et
typed assembly
int x
first non
static analyses
label l
italicized code
float int
hidden frame
subsequent paper
mov esp
non italic
exp int
popcorn compiler
normal code
splc end
ffl tal
int mod
new tal
generates code
int exp
object templates
cyclone programs
region stack
generation regions
fill e
tal procedure
env cyclone
old region
m fill
nested codegen
move instruction
non hidden
ffl cyclone
mod f
inter template
cyclone language
tem plate
mobile code
source code
modular exponentiation
int g
new template
specialized function
second phase
run time code
time code generation
action annotated program
code generation region
run time specializer
tal t instructions
return codegen int
dynamic code generation
run time specialization
tal t program
splice and fill
code generation process
dialect of c
codegen cut splice
function mexp sp
code and certificate
parameters and local
tempo front end
type safe dialect
morrisett et al
code that generates
typed assembly language
fill the hole
non hidden frame
int exp int
program to cyclone
float int f
within a template
sequence of x86
exp int mod
mov esp 0
env cyclone env
mod f int
code of mexp
used to fill
int float int
esp 0 eax
body of h
first non hidden
code generation regions
cyclone to tal
int mod f
f int x
int f int
function that generates
higher order types
compiles a type
sequence of tal
template end splc
cg fill holes
produces object code
generate a function
label or address
mexp int base
onto the stack
codegen or splice
c 20 21
source language program
stack of code
arguments are invariant
tal t language
args on stack
c into tal
write e vis
example the cyclone
types in cyclone
instructions are x86
object code satisfies
generates a function
using pointer types
label l template
code generation cyclone
cyclone source code
takes a source
expression fill e
base int exp
int mexp int
written in cyclone

corpus/krapavin2000-test/628045.txt
epa
soft
gryphon
thread
dqm
vpr
cpu
resource
deadline
negotiation
deadlines
pcip
policy
orb
manager
dve
rt
threads
resources
qos
dm
levels
managers
wcet
benefit
policies
usage
caching
admission
pipeline
missed
corba
traffic
principles
confidence
schedulability
video
scheduling
scenarios
service
pipe
rialto
object
scenario
centralized
allocation
operating
kernel
location
device
period
wireframe
hints
execution
bandwidth
dynamically
misses
overload
app
consistency
host
floaters
betty
negotiated
fair
utility
filter
skip
stream
availability
weather
termination
avatar
underutilization
oversubscribed
damage
fidelity
management
movement
allocations
miss
principle
assurance
steady
response
frames
joe
request
vrml
option
priorities
objects
multimedia
priority
reliability
mach
admitted
synthetic
placement
clip
negotiate
periodic
quadruples
modules
mechanism
os
responsibility
brandt
dves
mmoss
negotation
softening
softorterm
faction
scheduler
parametrically
effort
duration
network
monotonic
quality
virtual
eq
render
devices
interface
centric
conventional
smart
supports
units
tapp
avatars
satis
fluctuate
nutt
pipelines
graphic
estimates
meet
clients
workstation
runtime
requirements
module
room
moving
satisfaction
overshoot
unoccupied
facility
transparency
students
importance
intensive
proportional
supplementary
timeliness
engaged
smooth
processes
schedulable
directing
executing
frame
diverse
explains
mechanisms
polygons
multiprogrammed
lowers
reserves
max
interact
remote
client
requests
adjustment
hosts
update
opt
laboratory
adjust
workstations
entities
lowering
frequently
deliver
reliable
controlled
allocate
execution levels
soft real
real time
cpu usage
execution level
rt pcip
resource manager
resource managers
epa dm
dynamic negotiation
d soft
negotiation mechanism
location best
best location
hard real
time applications
c low
d term
epa rt
thread thread
resource management
object manager
thread 1
gryphon system
scenario c
network bandwidth
operating system
distributed object
maximum benefit
c high
application execution
execution time
per second
resource allocation
network traffic
location caching
missed deadlines
dm scheduling
thread 2
usage 0
app directed
scenario b
available cpu
cpu benefit
skip value
deadline misses
resource availability
level cpu
object placement
best effort
resource usage
directed caching
update rate
application knowledge
strong consistency
frames per
data movement
application 3
application 2
principle 3
frame update
max cpu
distributed policy
distributed corba
host y
application 1
thread application
termination deadlines
synthetic applications
location strong
gryphon distributed
desired response
object managers
fair proportional
message traffic
using execution
user satisfaction
resource needs
principle 2
running applications
principle 1
uses execution
maximum amount
normal distribution
time systems
system 2
deadline monotonic
time application
resource types
deadline miss
steady state
operating systems
level abstraction
user space
application 4
kernel pipe
resource requests
weather modeling
conventional thread
vpr processes
planning room
application provides
follows principle
levels 6
caching app
video clip
manager dqm
termination deadline
qos manager
pcip facility
parametrically controlled
reliable service
proportional option
cpu overload
mechanism execution
dqm dynamically
b scenario
soft real time
location best location
hard real time
real time applications
epa rt pcip
app directed caching
epa dm scheduling
cpu usage 0
level cpu benefit
set of applications
frames per second
joe and betty
uses execution levels
best location caching
distributed object manager
soft and termination
location strong consistency
thread thread thread
gryphon distributed object
confidence and reliability
max cpu usage
thread thread application
low or high
using execution levels
fraction of cpu
execution level abstraction
real time systems
amount of resources
real time application
available cpu cycles
number of missed
principle 1 soft
overall cpu usage
rt pcip mechanism
set of principles
application 3 application
application execution levels
scenario a scenario
b scenario c
applications and resource
mechanism execution levels
gryphon with location
scenario b scenario
principle 3 dynamic
virtual planning room
conventional thread thread
time application execution
location and caching
mechanism for implementing
form of soft
soft or term
follows principle 1
dynamic qos manager
caching app directed
application 2 application
knowledge the application
principle 2 application
application 1 application
low d soft
frame update rate
rt pcip facility
scenario c system
running the applications
quality of service
shows the cpu
messages per second
object is stored
real time support
number of objects
system 4 1
e g see
data from one
provides a means
real time scheduling
provide a mechanism

corpus/krapavin2000-test/628040.txt
spatial
rectangles
queries
query
eq
join
da
workspace
analytical
yufei
papadias
sj
density
na
dimitris
buffer
tree
formulae
intsect
accesses
indexes
lbeach
tao
trees
window
disk
height
skewed
buffering
joins
rectangle
rel
uniformity
leaf
mbr
indexing
estimations
entries
oid
multidimensional
node
readpage
mgcounty
hits
countries
uniform
lb
selection
spatio
overlap
synthetic
gis
tods
intersected
mg
database
ptr
sdbms
estimation
fanout
faloutsos
representative
surface
tiger
formula
parent
proposals
populated
databases
distributions
cardinality
projections
lru
samet
packed
selectivity
geographical
overlaps
subsection
directional
sams
rect
skyline
fklog
shuirupdqfh
ohyho
bugra
uhodwlyh
qrgh
motorways
distanced
gunther
jimeng
brinkhoff
pagel
gedik
pams
fractal
geometry
eqs
perimeter
child
capacity
experimental
index
lsd
traina
bang
guttman
cad
average
dimensional
management
multimedia
ss
dbms
seeger
tpr
roads
bureau
jun
dotted
hanan
encloses
enclosure
centers
plotted
prediction
census
fd
objects
hardly
entry
dimension
shu
histograms
north
temporal
bernhard
plays
costs
kamel
sigmod
object
estimate
yannis
nodes
extent
affects
extracted
greg
grouping
gain
l r
r tree
tree r
r l
r trees
join queries
level l
r r
r 1
data sets
r d
path buffer
selection queries
query window
node rectangles
range queries
data set
node accesses
uniform like
dimitris papadias
yufei tao
cost models
non uniform
data properties
density d
d l
data rectangles
disk accesses
real data
spatial data
window q
r 2
join query
using r
algorithm sj
spatial queries
uniform data
average size
spatial joins
tree indexes
density surface
r da
tree index
l l
r h
da r
representative points
analytical formulae
relative error
tao dimitris
access methods
average number
spatial query
uniformity assumption
eq 14
analytical estimations
da l
non point
node disk
rel 1
r n
node capacity
tree performance
two r
r total
access cost
skewed data
experimental results
data distributions
like data
spatial objects
joins using
dimensional data
k l
two dimensional
analytical model
papadias yufei
points x_y
proposed analytical
corresponding r
actual density
average extent
false hits
density l
per axis
buffering scheme
tree based
query processing
point queries
d r
analytical results
cost model
spatio temporal
tree node
cost estimation
systems tods
query optimization
tods v
buffering mechanism
cost formulae
average density
n rectangles
database systems
eq 12
spatial databases
cost analysis
queries using
indexing methods
around 10
spatial selection
selection query
refinement step
queries proceedings
relation rel
dimension k
eq 17
wide set
lru buffer
spatial join
tree structure
cardinality n
random data
leaf level
leaf node
r l r
l r l
d l r
l r r
r tree r
tree r 1
l r d
r r r
using r trees
query window q
non uniform data
l l r
r d l
r r l
k l r
r r da
number of node
tao dimitris papadias
r tree index
yufei tao dimitris
r tree indexes
dimensional data sets
r l l
selection and join
r da l
uniform like data
rectangles at level
da l r
tree r 2
na and da
r tree based
r 1 q
r tree node
l r n
r tree performance
real data sets
given by eq
illustrated in figure
spatial joins using
entries of r
points x_y node
density l r
spatial data sets
papadias yufei tao
simple path buffer
dimitris papadias yufei
node disk accesses
representative points x_y
estimate the cost
two dimensional data
synthetic and real
transactions on database
database systems tods
systems tods v
node and disk
queries using r
joins using r
level l l
spatial query processing
level l 1
plays the role
processing and optimization
r 1 r
cost in terms
trees r 1
underlying r tree
r 2 respectively
comparison for selection
tree that plays
point and range
rectangles with average
r of tree
point or range
due to entry
proposed analytical model
around 10 15
point data sets
tree based structures
query rectangle q
b real data

corpus/krapavin2000-test/626781.txt
pe
scattering
gathering
fdf
regimen
pes
message
shoulder
schedule
transmission
messages
flit
tap
certified
lag
wakeup
certificates
children
multiport
flits
oe
transmit
certificate
dispatch
stream
tapping
segment
transmitting
nonnull
port
synchronization
certification
schedules
nonleaf
destined
nrf
dispatched
bufferless
broadcasting
spanning
parallelogram
dispatching
trees
relay
child
receives
gap
parallelizing
scheduling
collide
token
networks
streams
parallelograms
segments
tree
buffering
relaying
gaps
protocol
processors
endpoint
root
leaf
orders
communication
originating
hypercubes
toroidal
schultz
juxtaposed
routing
destination
personalized
observes
saad
parent
phases
permutation
optimality
ring
broadcast
interconnection
sending
leftmost
subtree
inequality
noncolliding
multiscattering
moral
taps
fthe
topologies
distant
receiving
nearby
transit
arrival
activities
slant
relays
wit
johnsson
leveled
scat
materially
hypercube
meshes
fl
axis
scatter
network
sends
wherein
visualized
positioned
transmissions
mesh
bhatt
scattered
contrasts
queuing
backwards
units
honor
receive
rings
rooted
indices
resides
modes
indivisible
covering
passively
acknowledges
send
lengths
neighbors
repertoire
phase
arrive
henceforth
paths
equidistant
span
contrasted
tentative
recipient
null
remark
unidirectional
reconfigurable
communicating
specifically
claim
intended
begins
originate
dissemination
received
delaying
pipelining
broadcasts
shadow
breadth
hiding
deadlock
transmitted
responds
ho
interpretation
positions
fraigniaud
wagar
lessening
interlacing
schwabe
amending
tapped
abhiram
jinoo
rationalize
northwest
annexstein
claimclaim
ranade
baumslag
regimens
geppino
descibed
weizhen
bilardi
reckoning
conduit
prearranged
ensue
imen
satifies
northeast
pe p
scattering schedule
message sequence
shoulder tap
certified lag
algorithm shoulder
fdf scattering
gathering operation
lag time
segment x
message m
sequence m
gap free
transmit message
wakeup call
schedule oe
message stream
p 0
single port
transmission certification
gathering schedule
line segment
shoulder tapping
transmission certificates
fdf regimen
message transmission
oe 1
communication regimen
message streams
lag times
dispatch time
scattering schedules
algorithm transmission
root pe
nonleaf pe
message orders
transmission time
length l
c 0
oe 2
optimal scattering
scattering operation
transmission certificate
general tree
multiport communication
left endpoint
port communication
intended interpretation
line segments
message order
time receives
synchronization token
one flit
general trees
free transmission
dispatch times
length messages
optimal algorithm
phase 2
transmission times
personalized communication
spanning trees
space time
spanning tree
every message
time c
phase 3
ff oe
toward p
flit message
l flits
disjoint trees
gathering messages
order transmit
children p
stream length
pe must
nrf regimen
scattering operations
scattering time
pe sends
child p
schedule fl
pe associated
form segment
port regimen
schedules oe
free message
sub 0
certified stream
fdf schedules
scheduling activities
every fdf
p sub
originating pe
algorithm shoulder tap
pe p 0
scattering and gathering
message sequence m
certified lag time
scattering schedule oe
line segment x
fdf scattering schedule
algorithms for scattering
transmit message orders
algorithm transmission certification
certified lag times
time for gathering
algorithm for gathering
port communication regimen
single port communication
networks of processors
p i computes
form of communication
computes its certified
d i children
optimal scattering schedule
networks of arbitrary
every message sequence
transmit message order
gap free transmission
scattering or gathering
operation of gathering
operations of scattering
fdf scattering schedules
schedule for m
lag time c
observes the fdf
flit of m
transmitting its message
receives its wakeup
synchronization and scheduling
via the use
p i j
p i receives
network of processors
operation a pe
point c 0
equal length messages
p 0 receives
observe the fdf
time for scattering
single port regimen
toward p 0
p sub 0
schedule is optimal
schedule oe 1
optimal for m
corresponding message stream
networks we study
gap free stream
schedules oe 1
gathering schedule fl
whose left endpoint
transmission of messages
form segment x
use of spanning
p i 1
x i k
take at least
produced by algorithm
trees of arbitrary

corpus/krapavin2000-test/609199.txt
mutex
catch
caller
asetq
semaphore
kernel
queue
ready
dispatch
continuation
applicative
lambda
cons
busy
interrupts
cond
car
exclusion
cont
nil
rplaca
msg
preemption
interrupt
wait
saving
deleteq
denotational
arg
multiprocessing
elementary
lisp
restarted
protection
fork
algol
sem
processes
hewitt
manager
cell
semaphores
reynolds
steele
languages
count
waiting
modules
semantics
preempt
privileged
sussman
indiana
cdr
disable
foo
val
block
fn
processor
continuations
locus
stack
rplacd
uninterruptible
demo
progn
landin
brinch
addq
emptive
create
calling
schedulers
shall
bliss
funarg
junk
creates
private
ideas
returns
flag
syntactic
holland
church
executing
released
scheduling
throw
operating
garbage
pointer
gen
amsterdam
pp
hansen
spin
puts
returned
multiprogramming
handler
argument
binding
facility
processors
arguments
protected
module
eval
decentralized
expects
monitors
calls
track
critical
forth
dummy
pages
executed
language
answers
interpreter
loop
labels
serpette
multistack
vliet
revive
fuss
funargs
microcomputers
commend
unjustly
blithely
grips
trickiest
parc
errset
biagioni
enue
preempting
republished
neuhold
debakker
edoardo
entrance
dcom
hyperspace
quietly
greaterp
serializer
interdefinable
cleanness
verona
boussinot
xerox
someplace
emptyq
reversed
syntax
bottleneck
alleviate
code
cc
timing
causes
lock
treatment
execute
adequate
ml
north
resource
past
passing
lost
started
region
revised
huntington
maclisp
individuation
reclaimed
rib
expounded
busy wait
ready queue
make ready
create process
process saving
applicative languages
next process
lambda msg
msg cond
elementary exclusion
check done
mutex v
cont arg
mutex p
catch caller
one done
critical region
kernel dispatch
enable preemption
caller block
rplaca x
denotational semantics
car x
cons cell
scheme 3
class instance
read loop
catch expression
create queue
wait lambda
ready caller
block mutex
gen kernel
block make
data protection
try later
ready cont
deleteq q
mutex busy
disable preemption
language design
applicative language
set car
multiprocessing system
processes waiting
global state
control access
l values
queue q
always returns
asetq x
causes control
cond lambda
use catch
lambda val
val asetq
brinch hansen
emptive scheduling
computation 11
cons ans1
association list
semantic ideas
kernel make
kernel define
x rplaca
preempt x
x cons
process cont
asetq count
mutex mutex
completely decentralized
cons process
lambda dummy
lambda error
waiting process
semaphore let
car rplaca
past mutex
catch operator
scheme demo
kernel exclusion
get past
ready process
find inside
function create
process lambda
v mutex
protection error
lambda check
nil labels
self lambda
preemption lambda
timing interrupt
many functions
interrupt handler
x car
write code
small many
define cons
complex schedulers
demo 1
count mutex
single argument
continuation object
scheduling system
test and set
lambda msg cond
call by value
catch caller block
use of catch
scheme 3 1
v is executed
inside the kernel
dispatch to find
queue with argument
wait lambda msg
busy wait lambda
make ready caller
system the kernel
mutex busy wait
ready cont arg
block make ready
use of call
order and symbolic
preemption lambda error
next process run
area of applicative
lambda val asetq
preemption and enable
kernel s job
msg cond lambda
cons t nil
labels self lambda
expects a single
car rplaca x
ready to run
nil labels self
kernel s ready
process which called
continuation in denotational
functions which one
mutex v mutex
north holland amsterdam
let x cons
kernel make ready
set car x
report on scheme
busy wait let
make ready cont
small many functions
process lambda check
cons ans1 ans2
self lambda msg
writing the kernel
mutex is released
executes a dispatch
executed the calling
process is restarted
assign a process
calling process first
run time structure
cons process cont
check done asetq
create process lambda
computation 11 2
creates a continuation
use of asetq
caller of x
caller block make
kernel the kernel
error protection error
symbolic computation 11
process cont arg
must get past
pre emptive scheduling

corpus/krapavin2000-test/1035782.txt
quorum
deliverupdate
masking
quorums
servers
client
byzantine
faulty
server
timestamp
clients
opaque
initiateupdate
load
replicated
echo
dissemination
prone
universe
executes
read
protocol
dahlia
op
serialization
constructions
grid
secure
malkhi
member
failures
fail
signatures
dominated
preceding
tolerant
writer
availability
secret
fault
services
public
concurrent
iff
mema
undetectably
correct
intersect
exclusion
service
alvisi
consensus
update
reiter
failure
schneider
writes
ready
atomic
timestamps
agreement
threshold
repositories
maniatis
lidong
bazzi
giuli
benignly
rida
precede
scenarios
protocols
roussopoulos
sends
verifying
induces
receives
authority
benign
hadamard
petros
busiest
rosenthal
lorenzo
fred
security
peer
reply
write
wool
dispersal
coterie
assigns
corollary
precedes
tocs
digitally
eventually
michael
consistency
digital
voting
members
certificates
authenticate
message
ittai
echoed
cheuk
robbert
ncommon
odlyzko
evelyn
accessing
certificate
tolerate
self
baker
confidentiality
intersects
certification
validity
integrity
pierce
merritt
coteries
domination
neves
survivable
dahlin
renesse
era
bg
reader
lemma
chooses
rcd
liskov
rampart
signed
replication
authentication
rows
satisfied
nineteenth
denver
lemmata
lau
zhou
annual
mask
votes
wright
bolton
fortiori
disable
rebecca
sharing
mary
fg
date
databases
variations
received
executed
propagation
naor
strategy
multicast
registers
preservation
propagating
constructible
landing
rad
quorum system
quorum systems
masking quorum
correct server
deliverupdate c
c v
fail prone
prone system
write operation
faulty servers
executes deliverupdate
quorum q
server executes
dissemination quorum
echo q
q v
opaque quorum
q c
initiateupdate q
preceding write
read operation
replicated data
write operations
correct servers
update q
byzantine quorum
self verifying
assigns equal
opaque masking
non dominated
system b
op 1
value timestamp
update protocol
failure scenarios
quorum induces
system q
value written
client c
op 2
masking quorums
highest timestamp
ready q
universe u
public key
equal probability
execute deliverupdate
grid construction
faulty client
executes initiateupdate
correct client
last preceding
timestamp pairs
dahlia malkhi
b iff
q 2
fault tolerant
lemma 6
c executed
correct member
f echo
faulty server
higher timestamp
server u
g u2q
sends echo
operations returns
faulty clients
arbitrarily faulty
q 1
byzantine fault
k reiter
two quorums
michael k
every correct
corollary 4
c q
holds since
single reader
fred b
executed initiateupdate
mema roussopoulos
correct clients
regular masking
load induced
q similarly
b schneider
given fail
l exclusion
quorums intersect
secret sharing
correct process
byzantine failures
lorenzo alvisi
quorums q
digital signatures
system 2
example 5
distributed computing
multi reader
u g
variable x
server receives
deliverupdate c v
system for b
fail prone system
masking quorum system
masking quorum systems
q c v
executes deliverupdate c
correct server executes
server executes deliverupdate
prone system b
member of q
initiateupdate q v
echo q c
dissemination quorum system
quorum system q
opaque quorum system
byzantine quorum systems
v t u
servers in q
strategy that assigns
assigns equal probability
induces a load
update q v
opaque masking quorum
ready q c
value timestamp pairs
server in q
execute deliverupdate c
last preceding write
preceding write operations
operation in w
preceding write operation
executes initiateupdate q
queries each server
corollary 4 2
obtain a set
q to obtain
client to obtain
u g u2q
members of q
write operations returns
set of value
f echo q
q are correct
michael k reiter
dissemination quorum systems
load of 1
x it queries
given fail prone
client to read
quorum q 2
induced by w
c executed initiateupdate
fred b schneider
executed initiateupdate q
u 2 q
byzantine fault tolerant
every correct server
arbitrarily faulty servers
v t proof
set of correct
q is non
v t 2

corpus/krapavin2000-test/633045.txt
multicast
overlay
narada
members
layer
cluster
hosts
peer
nice
host
member
leader
stress
stretch
streaming
join
protocol
unicast
rp
peers
leaders
heartbeat
clusters
networking
delivery
kbps
latency
hierarchy
topology
telecommunications
overheads
layers
internet
sites
multimedia
routers
latencies
hops
joining
scalable
bayeux
packet
packets
traffic
overlays
protocols
media
membership
video
pastry
receiver
ms
scribe
hilton
suman
bobby
overhead
links
testbed
super
group
bhattacharjee
mesh
audio
cl
departures
bandwidth
panel
paths
infrastructure
workshop
recovery
onds
cork
yoid
baochun
druschel
stevenson
topologies
singapore
tapestry
belongs
banerjee
seconds
cumulative
joins
leave
losses
ton
zhang
proxies
advances
lengths
seungjoon
refreshes
simulation
native
resilient
path
ip
routing
trees
scattercast
eachmember
basicjoinlayer
leadership
rmx
almi
secs
refresh
li
link
period
network
metrics
metric
ireland
networks
periodic
guang
plot
groups
dissemination
messages
ananth
rao
failures
simulations
trip
contacts
experimented
kurose
aravind
rapid
nearby
experiment
stream
sigcomm
operating
june
nineteenth
bootstrap
chord
multicasting
probes
tree
duration
yang
washington
towsley
route
joined
merge
soft
guo
failure
stabilizes
quicker
closest
lee
lifetime
addressable
invariants
amortized
beichuan
kyoungwon
georganas
minseok
zongming
robustnessof
shavitt
spiros
sugat
gorinsky
animesh
mojtaba
kommareddy
ungraceful
joinjoin
hefeeda
hosseini
harrick
pucha
layer multicast
application layer
layer l
data path
control overhead
end hosts
nice protocol
multicast group
control traffic
narada 5
super cluster
data delivery
group sizes
networking v
telecommunications networking
cluster leader
overlay multicast
computer networks
path lengths
highest layer
multicast protocols
multicast protocol
video june
overlay topology
delivery path
level hops
link stress
control overheads
layer l0
control topology
data paths
media streaming
group size
digital audio
wide area
path length
cluster leaders
average member
average control
failure recovery
ip multicast
systems support
application level
direct unicast
member departures
bandwidth data
new leader
multicast using
group members
cumulative distribution
international journal
peer multimedia
overlay networks
bobby bhattacharjee
multimedia streaming
hilton singapore
operating systems
suman banerjee
large receiver
receiver sets
stream applications
source specific
join phase
narada protocol
change phase
area implementation
layer l1
data stream
join procedure
international workshop
data packets
streaming november
membership change
control path
multicast data
simulated time
data packet
o k
log n
end host
join query
ieee acm
ton v
networking ton
joining member
peter druschel
stevenson washington
nice hierarchy
multicast infrastructure
narada 30
multi unicast
average path
overlay path
panel 0
member h
cluster membership
stress distribution
system multicast
stress metric
cork ireland
joining host
baochun li
different members
site c
unicast latency
heartbeat message
application layer multicast
peer to peer
layer multicast protocols
telecommunications networking v
networks the international
computer and telecommunications
support for digital
network and operating
application level hops
layer multicast protocol
operating systems support
workshop on network
journal of computer
data delivery path
audio and video
cluster in layer
fraction of members
peer multimedia streaming
groups of size
data stream applications
layer l j
l i cluster
membership change phase
wide area implementation
basic data path
networking v 50
advances in peer
time in secs
streaming november 11
workshop on advances
multimedia streaming november
networking v 51
end to end
ieee acm transactions
networking ton v
transactions on networking
l j 1
november 11 11
conference on multimedia
large receiver sets
video june 16
k and 3k
average link stress
average control overhead
june 13 14
along the overlay
stevenson washington usa
end system multicast
video june 13
different group sizes
low bandwidth data
n 1 p
june 16 18
clusters of size
v 50 n
v 51 n
o log n
join and leave
v 2007 n
control and data
number of application
acm international conference
v 82 n
stress on links
sites c d
suman banerjee seungjoon
hosts that correctly
j 1 cluster
time 1000 seconds
new host joins
tree building protocol
scalable application layer
secs 128 end
belongs to layer
banerjee seungjoon lee
average path length
data path quality
advances in multimedia
using an overlay
distributed tree building
simulation v 82
size upper bound
worst case control

corpus/krapavin2000-test/629077.txt
arrays
array
dimensions
processors
cyclic
compiler
sequentialized
partitioning
alignment
loop
dimension
multicomputers
grid
loops
contiguous
kandemir
parallelization
sequentialize
parallelizing
processor
aligned
mahmut
supercomputing
replicated
references
quality
parallelizable
ramanujam
parallelism
cag
xij
subscript
banerjee
cyclically
interprocessor
choudhary
parafrase
ipsc
fortran
communication
sequentialization
replication
prithviraj
notices
multiprocessors
programs
sigplan
program
xrsiq
zaafrani
costs
distributions
rhs
constraints
measures
favoring
ito
locality
anderson
monica
compilers
onetomanymulticast
constraint
jennifer
decisions
alok
block
subroutines
trfd
apl
dgefa
subscripts
topology
automatic
eispack
ym
zm
tseng
rows
compile
chau
linpack
vm
manish
distribute
compiling
strategy
assignment
tuple
chen
shenoy
ching
lam
var
optimizations
layout
distribution
diniz
manytomanymulticast
interf
modn
pande
primitives
lhs
interprocedural
ifip
owns
compilation
gets
segments
scientific
washington
pivoting
united
appearing
nested
aug
statement
outer
nagaraj
rinard
pedro
taylan
mee
machines
methodology
routine
align
xm
segment
toplas
index
conflicts
coprocessor
sheu
dino
santosh
restructurer
mdg
amarasinghe
gains
expression
memory
message
subramanian
advocates
club
saman
multicasting
peizong
estimates
regarding
wen
determination
speedup
shared
across
superb
wai
balasundaram
kremer
affinity
sequential
programmer
iterated
subroutine
transformations
commack
nova
katz
kind
favor
intel
gupta
considerations
varies
chien
override
ulrich
numerous
multiply
kennedy
imbalance
dependence
routines
emerges
wise
np
determining
partitioned
tokyo
microseconds
quality measures
data partitioning
array dimensions
data distribution
grid dimension
cyclic distribution
array dimension
distributed memory
distribution scheme
processor grid
execution time
quality measure
automatic data
communication constraints
distribution function
communication costs
various arrays
processors along
distribution functions
partitioning scheme
various constraints
supercomputing p
parallelization constraints
parafrase 2
j ramanujam
interprocessor communication
d arrays
block size
mahmut kandemir
program segment
ipsc 2
notices v
program segments
parallelizable loops
m anderson
jennifer m
component alignment
loop index
sigplan notices
acm sigplan
prithviraj banerjee
parallelizing compiler
parallelizing compilers
memory multiprocessors
memory machines
real programs
shared memory
distributed cyclically
final distribution
aligned dimensions
various loops
grid topology
corresponding grid
contiguous distribution
relative block
distribution schemes
small arrays
memory multicomputers
subscript expression
assignment statement
alignment problem
various dimensions
block sizes
reference patterns
two dimensions
data references
explicit communication
alok choudhary
multicomputers proceedings
communication time
across processors
parallel program
distributed systems
outer loop
gets mapped
smaller arrays
scheme suggested
contiguous manner
time expression
gains made
aggregate communication
processor tuple
aligned array
distribute arrays
multiprocessors acm
compiler would
r ito
various array
zaafrani m
parallelizable loop
arrays used
xij 1
memory parallel
compile time
parallel loops
number of processors
conference on supercomputing
automatic data partitioning
data partitioning scheme
distribution of arrays
data distribution scheme
sigplan notices v
acm sigplan notices
distribution of various
jennifer m anderson
expression for execution
values of n
dimension is distributed
distributed systems v
transactions on parallel
parallel and distributed
distributed memory multicomputers
contiguous or cyclic
class of aligned
relative block sizes
notion of constraints
component alignment problem
measures of various
measures of constraints
outer loop index
value of n
li and chen
kinds of constraints
numbers of processors
monica s lam
notices v 30
execution time expression
second distribution function
corresponding grid dimension
m r ito
dimension a k
two array dimensions
multiprocessors acm sigplan
class of dimensions
zaafrani m r
scientific application programs
determine the applicability
alignment of array
various array dimensions
regarding the distribution
alignment of two
formulation of constraints
constraint to sequentialize
washington d c
acm ieee conference
distributed memory parallel
choudhary j ramanujam
mahmut kandemir alok
constraints on data
iterated parallel loops
sequentially iterated parallel
overall execution time
partitioning of arrays
implementing our approach
kandemir alok choudhary
distributed memory machines
d and e
number of elements
architectures and compilation
problem of automatic
intel ipsc 2
techniques for parallelizing
along each dimension

corpus/krapavin2000-test/630575.txt
unexpected
interestingness
association
rules
consequent
discovered
meat
conforming
milk
rpc
unexpectedness
grape
items
mining
fruit
beef
ias
gi
apple
grades
clicking
ranking
visualization
pork
cheese
ij
actionability
subjective
vague
actionable
match
pk
conform
associations
item
fooditem
confm
specification
impression
belief
rule
conditional
pear
rankings
chicken
feelings
conforms
courses
specifications
ga
confidence
rn
rm
screen
rank
expectations
colored
rvn
bsunexp
gb
analyzes
beliefs
believes
impressions
truly
lm
grade
boxes
exam
students
box
conformity
metaqueries
fooditems
unexpcond
dmql
discovery
taxonomy
ranked
forgotten
precise
nus
lsn
clothes
objective
buy
query
proposes
pruning
subjectively
counted
rpcs
analyzing
consequents
feeling
butter
degrees
optional
post
measures
gis
people
specify
remind
buying
health
sn
uninteresting
hierarchy
huge
discovering
unwanted
contradict
singapore
something
beforehand
helping
generalized
matches
interactive
concept
retrieves
language
insignificant
reasonably
sql
glut
sebastin
identifiy
rps
interestingenss
ventura
interestngness
intellgent
preciseness
yiyuan
confid
unexpectcond
rvm
internationalisation
wizwhy
pks
blanchard
envelopment
nstb
associatino
fule
courseware
kender
guillet
unexpconseq
datamine
minqing
disjunctive
predictive
queries
deviations
fly
sure
basically
matching
potentially
visual
bad
findings
cristbal
shekar
kefir
dempster
romero
shafer
lsm
briand
association rules
discovered rules
unexpected rules
interesting rules
existing knowledge
conforming rules
discovered rule
unexpected condition
consequent parts
unexpected consequent
side unexpected
association rule
rules visualization
visualization unit
generalized association
rule mining
u j
consequent rules
milk cheese
condition rules
discovered association
subjective interestingness
proposed technique
beef pork
match value
visualization system
data mining
interestingness analysis
objective interestingness
precise knowledge
rank 2
potentially interesting
unexpected items
specification language
rules using
analysis system
rules unexpected
match purpose
purpose ranking
vague feelings
rn rm
rpc specification
user believes
existing concept
consequent match
grape pear
colored box
j u
unexpected patterns
conditional part
post analysis
rules according
fruit dairy_product
unexpected association
pork chicken
rules easily
unexpected match
condition items
bad grades
milk apple
meat milk
reasonably precise
lm ij
conforming match
average grades
j well
rules shows
pear apple
truly unexpected
exam results
interesting items
query based
various types
specification 2
interesting association
interestingness measures
consequent part
user identify
match values
interesting ones
objective measures
mining process
l ij
finding interesting
associations among
mining algorithm
rules visualization unit
conditional and consequent
support and confidence
unexpected consequent rules
unexpected condition rules
side unexpected rules
association rule mining
user s existing
unexpected with respect
rank 2 0
discovered association rules
u j u
generalized association rules
number of rules
analyzes the discovered
rules a discovered
interestingness analysis system
user s specifications
match purpose ranking
generalized association rule
using the user
degrees of interestingness
ij to denote
types of knowledge
association rules using
n b 1
denote the degree
b 1 b
rule mining process
grape pear apple
identify those potentially
beef pork chicken
potentially interesting rules
rules are interesting
interesting rules easily
unexpected association rules
discovered rules according
conforming rules visualization
fruit dairy_product meat
user s vague
expressed where 1
numbers of items
rules that conform
meat milk apple
unexpected consequent match
ranking the rules
u j well
rules shows us
user to specify
set of rules
set of discovered
rule a 1
interesting association rules
rules with respect
rules that satisfy
rules in particular
r r r
set of items
average to average
interestingness match values
conforming rules unexpected
unexpected consequent rule
b k conforms

corpus/krapavin2000-test/1008286.txt
dc
gb
des
leak
ltl
tts
gas
chop
dpe
transition
duration
trajectory
burner
timed
burn
ignition
ae
transitions
formulas
axiom
temporal
oe
flame
premises
logic
invariance
trajectories
tltl
req
refinement
tla
stuttering
untimed
goidle
sigma
axioms
ht
formula
durations
action
primed
pe
pi
predicate
actions
interval
reactive
units
modality
def
sound
iff
separation
linking
induction
purge
verification
calculus
specification
specifications
modalities
idle
fqg
reals
asserts
position
positions
dqe
consecution
recapitulates
ttss
timing
heat
dense
deduced
bounded
structural
premise
validity
diligent
css
yardstick
rules
semantics
ss
satisfaction
frameworks
neighbourhoods
liveness
methodologies
corollary
suffix
satisfies
style
connectives
responsiveness
sequencing
fairness
variability
fpg
lasts
reasoned
overlapping
proving
elementary
rule
valid
modelling
occurrence
modelled
correctness
initiation
disciplines
operators
reasoning
ni
response
predicates
denotational
enters
stopped
stand
inductive
enabled
provable
satisfied
behaviour
entered
compositional
safety
meaning
dre
fpgt
intv
flon
manna
unlit
dimensionaldomain
traj
durational
fld
instanta
consolidation
fae
reoccur
heaton
seconds
clocks
automaton
specifying
link
linked
refined
observable
stable
abstract
progress
critical
soundness
safeness
chopped
neously
pnueli
valve
culus
operational
rigid
saying
singleton
refine
hybrid
gb 1
transition system
trajectory ae
timed transition
gb 2
transition systems
system gb
gas burner
position p
minimal separation
time units
duration calculus
state variables
real time
bounded response
bounded invariance
temporal logic
state predicate
linear temporal
r r
temporal formula
state transitions
invariance property
temporal formulas
time point
d pe
within e
des 2
chop operator
bounded unless
duration formula
induction rules
time domain
time systems
bounded progress
chop modality
des 1
bounded critical
gb 3
tts framework
des des
interval logic
critical duration
original dc
structural induction
reactive systems
r true
least l
p holds
r 0
action formulas
duration formulas
finite variability
untimed transition
let leak
duration properties
combined logic
ltl style
hold iff
property d
dc framework
separation property
heat request
position ht
duration terms
leak 2
style specification
leak 1
ae 1
primed variables
induction rule
p state
formula f
proof system
dynamic systems
rule 3
timing constraints
oe 0
remain valid
state predicates
state sequence
time bound
first order
r x
high level
embedded real
d time
invariance properties
state transition
predicate p
d e
position m
super dense
flame failure
sound rules
x dpe
axiom 8
explicit clocks
interval b
axiom 6
transition system gb
timed transition system
r r r
timed transition systems
system gb 2
real time systems
linear temporal logic
taken at position
leak in gb
state predicate p
property of gb
rules for bounded
bounded critical duration
ae 1 p
specification and verification
untimed transition systems
refinement of gb
system gb 1
position p 2
d time units
oe oe 0
requirement and design
minimal separation property
satisfied by ae
dc and ltl
axioms and rules
set of state
embedded real time
reflects the engineering
r true holds
bounded response property
interval b e
bounded response properties
structural induction rules
holds and r
prove a bounded
gas burner example
des des des
within e time
hold until p
conventional dynamic systems
bounded invariance property
proofs of des
dpe d pe
bounded invariance properties
section 4 satisfies
transition system consists
still s sound
system gb 3
simple error recovery
ae over sigma
real time point
timed linear temporal
since the change
critical duration property
deduced from corollary
hold iff phase
occurrence of q
ltl style specification
liveness and fairness
c time units
e 1 property
d e holds
value from r
underlying transition system
dense chop operator
trajectory over sigma
least l time

corpus/krapavin2000-test/1009317.txt
liveset
probe
cells
gradient
cell
descendant
iceberg
gradients
oronto
quant
grad
cube
descendants
mining
avg
pruning
cubes
info
significance
cubing
price
prb
constrained
driven
anti
mismatch
prune
ancestor
cubegrade
header
matchable
sibling
cient
constraint
sales
ancestors
sig
transactional
cnt
aggregated
dimension
business
toronto
association
siblings
jm
probes
tuples
dimensions
growth
attributes
monotonic
pruned
threshold
montreal
jan
customer
vancouver
multidimensional
scalability
transaction
gcell
mds
grp
city
bins
household
runtime
di
erent
solid
ciency
olap
mismatches
feb
bought
cust
sold
count
cp
education
erence
tree
depth
items
confined
monotone
huge
measures
databases
sector
sectors
gqs
imielinski
itemset
aggregates
itemsets
constraints
attribute
parent
fp
tuple
pairs
top
mutation
monotonicity
month
sharing
exploration
compressed
hyper
pc
weaker
rudimentary
dimensional
average
grow
pushing
ski
mined
cd
significant
dvd
drill
mdss
datacubes
potential
erences
explored
comparable
thresholds
item
examine
rough
deeply
house
rp
prices
schema
base
specialization
leaf
measure
roll
database
ovhd
hopeful
shopping
matchability
live
frequent
buy
query
west
professionals
interestingness
buyers
explores
ciently
link
attr
prod
ascending
queries
scalable
sql
weakly
matching
roughly
labeled
constrain
cardinality
prunes
search
rules
relational
searches
links
ok
mine
warehousing
subsection
microsoft
probe cells
c g
c p
gradient cell
gradient cells
probe cell
liveset driven
cell c
constrained gradients
gradient constraint
h tree
significant pairs
quant info
k average
data cubes
liveset c
top k
data cube
gradient analysis
gradient probe
avg price
c grad
significance constraint
mining constrained
interesting gradient
header table
e cient
constraint c
driven algorithm
grad c
c sig
h cubing
probe constraint
solid mismatch
c prb
price c
constrained gradient
anti monotonic
significance threshold
base table
transactional databases
table h
g c
probe pairs
cells p
d cell
gradient threshold
measure values
probe constraints
c 3
depth first
c g1
anti monotone
one solid
base cells
cube computation
side link
cell constraint
iceberg cube
avg k
association rules
descendant cell
measure attributes
pairs algorithm
pairs liveset
iceberg cubes
significance constraints
driven figure
potential gradient
gradient constraints
dimension matching
cells c
multi dimensional
set oriented
top 100
c g2
oriented processing
probe pair
ancestors descendants
hyper tree
comparable cells
computing iceberg
side links
weaker anti
average price
cells w
cient iceberg
aggregated cells
per probe
gradient mining
c g3
w r
multidimensional space
e ciency
p c
m c
di erent
search space
maximal sharing
cubegrade problem
matching analysis
aggregated cell
dimensional gradient
pairs let
measure value
base cell
complex measures
sales price
iceberg growth
interesting gradients
c gcell
dimensional cells
set of probe
top k average
mining constrained gradients
liveset driven algorithm
g c p
descendant of c
c g c
c grad c
gradient cell c
interesting gradient probe
liveset c g
constrained gradient analysis
gradients in data
header table h
avg price c
gradient probe pairs
cell c g
grad c g
probe cell c
cell c p
probe cells p
probe constraint c
constraint c prb
sibling of c
constraint c sig
significance constraint c
one solid mismatch
p is matchable
gradient cell constraint
number of probes
constraint c grad
liveset driven figure
significant pairs algorithm
top 100 average
d since c
iceberg cube computation
cells c p
gradient constraint c
pairs liveset driven
price c g
gradients in transactional
potential to grow
g and c
c p c
number of cells
interesting gradient cells
set oriented processing
gradient probe pair
pairs of cells
cells w r
average of c
e cient iceberg
per probe cell
significance and probe
gradient cells w
probe cells c
sharing of computation
c d since
example one may
p and c
number of tuples
used for pruning
multi dimensional space
descendants of c
bins to 3
potential gradient cells
c p v
threshold all pairs
significant probe cells
matchable with c
gradient analysis problem
descendant cell c
depth first order
gradient probe cell
set of gradient
depth first descendant
descendants and siblings
price c p
cube computation algorithm
weaker anti monotonic
m c p
ancestor of c
number of bins
p c p
number of probe
using the gradient
prune the search

corpus/krapavin2000-test/1013817.txt
hull
convex
inplace
situ
hulls
graham
chan
planar
clockwise
vertices
nding
rst
sorting
seidel
scan
median
vertex
log
bridge
kirkpatrick
slope
insitu
lexicographic
megiddo
recurses
pq
merging
array
recurse
cient
paired
place
round
leftmost
abscissa
partitioning
fpg
nd
stable
2d
discarded
geometry
storage
swaps
unprocessed
tangent
stack
mergesort
recaps
yap
ham
csy
candidates
sort
ultimate
recomputing
sorted
jarvis
leftward
carleton
comparisons
bottommost
recompute
grouping
dual
mcgill
snoeyink
maximal
tests
fqg
slopes
signs
dimensions
computes
partition
implementable
ks
topmost
rounds
polar
beginning
js
jsj
extra
modications
separated
stored
nal
brute
swap
school
modication
consecutively
trick
intersection
lp
duality
consecutive
lines
shuing
sandwich
jiaconog
fmorin
engi
explicity
katajainen
fhbr
algorithmxs
gra
jyrki
neering
sirakov
danish
godfried
treesort
piercings
morrisong
shamos
diku
smoothsort
klee
marily
colonel
council
rightmost
pseudo
runs
shifts
groups
opt
care
favourably
horowitz
vahrenhold
undiscarded
wenger
cgm
paritioning
nikolay
metrotech
copenhagen
herv
tangents
brnnimann
unpaired
intersecting
half
concatenation
solves
running
radially
ottawa
pri
endpoints
sorts
fig
bhattacharya
ordinate
brooklyn
dk
indices
phrased
polytechnic
cis
polytopes
voronoi
sized
dierent
probably
maximality
postprocessing
reordered
programming
movement
constants
cs
resp
identi
collinear
farthest
medians
sensitive
convince
referee
randomized
odd
download
primal
convex hull
upper hull
convex hulls
graham inplace
n log
hull algorithm
log h
inplace hull
h time
lower hull
o n
planar convex
right turn
linear time
log n
clockwise order
space e
upper bridge
inplace scan
linear programming
2d linear
inplace sort
hull candidates
lower convex
turn tests
hull computes
programming problem
e cient
n time
hull algorithms
place sorting
median nding
hull vertices
n points
maximal elements
cient algorithms
o 1
computational geometry
input points
recurse z
z recurse
place implementation
insitu hull
z output
output hull
situ algorithms
running time
time algorithm
using o
additional memory
hull figure
o log
additional storage
time using
point set
candidates z
stable merging
order beginning
bridge problem
median slope
chan inplace
separated 2d
abscissa x
computing convex
seidel 21
median abscissa
elements problem
hull z
storage used
space efficient
original algorithm
x 0
four space
place algorithms
output sensitive
place algorithm
n additional
n g
h 1
n right
end result
rst half
one call
point p
l 0
inplace lp
leftmost vertex
h vertices
extra storage
opt graham
lp 2d
z move
hulls convex
ultimate planar
describe four
ultimate algorithm
turn test
o n log
n log h
log h time
space e cient
graham inplace hull
convex hull algorithm
hull of g
computes the convex
planar convex hull
graham inplace scan
linear programming problem
n log n
right turn tests
sets s 0
2d linear programming
log n time
convex hull algorithms
planar convex hulls
kirkpatrick and seidel
call to graham
lower convex hull
e cient algorithms
hull of n
o 1 additional
runs in o
time in place
practical in place
inplace hull computes
output hull figure
graham s scan
lower hull candidates
chan s algorithm
z output hull
z recurse z
algorithm for planar
points in o
o log n
number of vertices
computing convex hulls
abscissa x 0
computes the upper
upper bridge problem
n time using
place sorting algorithm
seidel s algorithm
storage where h
implementation of graham
separated 2d linear
maximal elements problem
right of x
time using o
chan inplace hull
convex hull vertices
scan to compute
cost of recomputing
median abscissa x
hull candidates z
n right turn
log n additional
upper or lower
algorithms for computing
using o 1
computing the convex
computing the upper
log n 1
two and three
done in o
linear time algorithm
set of n
algorithm megiddo inplace
sampling in computational
log n levels
partitioning in linear
inplace hull theorem
right turn test
o n right
convex hull vertex
call the convex

corpus/krapavin2000-test/1007852.txt
mesh
untangling
untangled
feasible
vertex
meshes
invalid
tangled
untangle
eulerian
ale
lagrangian
jacobian
volume
knupp
objective
barely
2d
1d
patch
quadrilateral
corners
valid
untangles
optimization
conguration
vertices
triangle
interior
boundary
zoom
alamos
inverted
congurations
subcells
rezone
gure
triangles
procedures
volumes
reposition
polygon
3d
connected
corner
remapping
repositioning
repositioned
unstructured
quadrilaterals
quad
eect
simplex
czech
quadratic
movement
rayleigh
polygonal
horseshoe
plassmann
hydrocodes
teran
irving
fedkiw
xing
tetrahedral
xed
fig
los
hexahedral
smooth
laboratory
freitag
rst
gradient
shaded
metal
deformation
shear
intersection
minimized
element
ele
aected
ow
taylor
denition
minimization
dr
smoothing
numerical
nd
simulations
modied
polyhedron
continuum
laplacian
convex
mechanics
half
eq
invertible
placement
signed
validity
simulation
quality
area
degenerate
ccw
vachal
raphal
bfoe
subcell
fcgo
endorse
interrupting
gdho
rourke
nonsimplicial
quads
aeoh
demarcating
congura
reevaluated
loubre
tangling
liska
parametrization
berndt
shashkov
redenition
institu
planes
national
forming
dierent
perturbation
improvement
kovalev
pentagon
endeavor
staggered
prague
indiscriminately
everywhere
speeds
center
neighbors
determinants
cavities
impractically
sandia
acd
mikhail
reentrant
hydrodynamics
formed
keeping
ments
maximizing
dotted
spaces
squares
entangled
chasing
relocating
republic
success
dened
moves
positions
xes
uncommon
detrimental
feasible set
optimization procedure
objective function
untangled mesh
set method
valid elements
set approach
2d meshes
mesh shown
invalid elements
arbitrary lagrangian
barely valid
lagrangian eulerian
mesh untangling
untangling procedure
elements connected
vertex connected
x 9
positive volume
invalid element
set polygon
elements valid
untangling meshes
zero volume
original mesh
local function
mesh nodes
step procedure
mesh optimization
area triangles
inverted elements
one invalid
tangled mesh
valid mesh
ale simulations
reference jacobian
interior vertices
feasible sets
mesh vertex
connected elements
quadratic objective
mesh generation
volume elements
x 4
x 3
global objective
numerical optimization
boundary vertices
nodes connected
optimization method
x 8
los alamos
area volume
invalid quadrilateral
mesh improvement
ale methods
eulerian methods
lagrangian step
taylor simulation
mesh conguration
untangle meshes
past line
connected neighbors
distinct corners
1d mesh
mesh patch
element volumes
improvement procedures
connected element
rayleigh taylor
node repositioning
solution transfer
unstructured 2d
number based
based optimization
mesh quality
zero area
nd three
edge connected
procedure 4
procedure performs
feasible region
b mesh
mesh b
multi step
b fig
optimization based
optimization approach
alamos national
simplex method
inequality constraints
half spaces
national laboratory
x 6
condition number
one element
eulerian hydrocodes
quadrilateral elements
respective feasible
g irving
local iteration
x element
method 17
based rezone
feasible set method
feasible set approach
arbitrary lagrangian eulerian
feasible set polygon
untangle the mesh
shows the mesh
barely valid elements
shown in figure
connected to invalid
untangles the mesh
x 8 x
least one invalid
global objective function
area of triangle
lagrangian eulerian methods
based optimization procedure
mesh improvement procedures
edge connected neighbors
untangling by optimization
condition number based
procedure 4 5
jacobian at v
success in untangling
rayleigh taylor simulation
optimization procedure 4
unstructured 2d meshes
set for vertex
quadratic objective function
eect of increasing
los alamos national
alamos national laboratory
keeping the mesh
simple laplacian smoothing
o f g
mesh after improvement
cannot be xed
g irving j
irving j teran
three distinct corners
mesh is presented
vertex is repositioned
jacobian optimization based
procedure for untangling
mesh while keeping
interior vertices connected
method 17 18
untangling the mesh
x as many
denition of element
intersection of half
x element x
smooth and convex
accurate solution transfer
elements as possible
eulerian computing method
nd three distinct
make all connected
sets a feasible
shows the untangled
positive area triangles
lagrangian and eulerian
making the feasible
positive volume elements

corpus/krapavin2000-test/628140.txt
subtransactions
subtransaction
transaction
serialization
rpo
flexible
hddbs
compensating
cascading
sseg
committed
compensation
compensatable
ct
commit
retriable
serializability
ip
aborts
serializable
oe
ls
serialized
rpos
atomicity
concurrency
gtm
database
commits
site
jp
multidatabase
schedule
compensated
abort
commitment
compensations
jq
dependencies
surplus
retrial
schedules
items
invalid
pivot
ldbs
unilaterally
interference
mrb
serialize
aborted
insertion
consistency
alternate
switching
transactions
integrity
globally
bank
submitted
criterion
ldbss
precede
termed
protocol
scheduling
sites
reads
conflict
execute
executed
submission
deposit
deleted
heterogeneous
preference
precedence
ticket
edge
prefix
trans
executes
blocking
avoids
manager
global
ds
execution
avoiding
deletion
effects
executions
unambiguous
priority
retried
item
enforcing
conflicts
preferred
semi
committable
resubmitted
refundable
autonomous
alternatives
gd
regain
inserted
delete
autonomy
preservation
edges
databases
conflicting
workflows
multidatabases
retry
consistent
semantic
scheduled
attempted
enforced
traditional
serial
fare
withdrawal
isolation
prepare
scheduler
contradicts
ft
concurrent
inconsistency
delays
maintains
wc
preserve
precedes
successors
formed
management
forced
uncommitted
action
inconsistent
observations
fails
resilience
travel
ld
rc
undone
transfers
backtrack
submits
avoided
centric
transactional
sub
unavoidable
unaffected
ensures
maintained
insert
predecessors
submit
ffl
plane
issuing
rule
flow
integrates
violate
preserves
resilient
decision
accesses
limo
uncompleted
bds
schek
flexible transaction
flexible transactions
serialization point
oe rpo
global transaction
local site
global transactions
concurrency control
local transactions
cascading aborts
compensating subtransaction
ls p
local database
compensating subtransactions
hddbs environment
compensation interference
global serializability
committed oe
oe rpos
serialization order
data items
global schedule
interference free
f serializability
f serializable
site ls
edge insertion
globally serializable
serializable schedules
global concurrency
semi atomicity
database state
m ip
avoiding cascading
ct ip
database consistency
distributed database
transaction model
global subtransactions
local sites
subtransaction ct
insertion rule
avoids cascading
sseg algorithm
invalid subtransactions
switching set
global database
control criterion
bank b
cascading compensations
global subtransaction
sub transaction
scheduling protocol
global decision
consistent database
conflict equivalent
heterogeneous distributed
local transaction
transaction may
local databases
surplus transactions
two subtransactions
must serialize
ct 1p
operation submission
local flexible
cascading abort
submission rule
ip must
integrity constraints
database systems
global consistency
value dependencies
one subtransaction
semantic atomicity
well formed
transaction management
committed subtransactions
committed flexible
flexible trans
retriable subtransactions
serialization points
ct m
two flexible
avoid cascading
formed flexible
compensatable subtransaction
compensating transaction
maintains global
alternate oe
transaction manager
execution of flexible
compensation interference free
local site ls
global concurrency control
committed oe rpo
executes its serialization
avoiding cascading aborts
decision to commit
compensating subtransaction ct
flexible and local
execute its serialization
makes a global
transaction t j
heterogeneous distributed database
consistent database state
edge insertion rule
concurrency control criterion
site ls p
globally serializable schedules
executed its serialization
flexible transaction may
operation submission rule
avoids cascading aborts
transaction t 1
j can execute
set of subtransactions
compensation or retrial
two flexible transactions
subtransaction t j
global database consistency
condition for avoiding
global transaction manager
global data items
among the subtransactions
f serializable schedules
committed flexible transaction
avoid cascading aborts
subtransaction of flexible
well formed flexible
flexible transaction model
alternate oe rpo
concurrency control protocol
execution of global
local database systems
global transaction g
nodes and edges
set of data
sseg algorithm maintains
enforcing t 1p
entire flexible transaction
bounded serialization point
committed oe rpos
commit the oe

corpus/krapavin2000-test/608736.txt
ard
dependence
ards
grains
rw
ro
wf
interprocedural
grain
dependences
loop
subscripting
oset
writefirst
accesses
array
stride
summary
privatization
readonly
readwrite
subscript
art
intersection
classication
ne
summaries
summarization
compiler
loops
parallelization
anti
polaris
idiom
dimension
reshaping
expressions
lmad
descriptor
rst
parallelizing
osets
overlap
parallelize
enclosing
omega
read
subscripts
span
mca
classifying
testing
access
transformations
strides
outer
references
symbolic
simplication
intersections
arc
tests
representative
memory
interprocedurally
bdna
swim
privatized
ocean
privatizing
locations
region
induction
ow
intersect
eective
dim
parallelism
enclosed
expansion
classied
codes
declared
inductions
tomcatv
dierence
subroutine
summarizing
flow
endif
location
army
intersecting
index
compilers
removed
benchmark
scientic
nested
conservative
expand
descriptors
boundaries
dimnew
lmads
oating
dierent
ag
inner
marked
trfd
removable
statements
nest
recognition
dimensions
mdg
intersected
happened
iteration
dimensionality
safely
fm
referencing
unwieldy
gated
program
dened
expanded
parallelized
remove
indivisible
writes
brie
contexts
reduction
depen
fpg
comma
ssa
analyses
coupled
contract
ignored
patterns
nd
write
ron
reductions
nding
translated
calling
interpretation
universal
sink
gcd
reference
triplet
instruction
translate
subroutines
reads
perfect
passed
cross
spec
likewise
implication
abstract
classify
nonlinear
spans
vi
across
dimensional
declaration
indices
eliminating
internal
predicate
rethink
rwn
viet
intraprocedurally
recursing
interpretion
kaist
benchmarksmyampersand
nga
agged
dierentiated
summary sets
dependence analysis
summary scheme
range test
dependence testing
access region
write order
loop index
data dependence
list ard
summary set
omega test
subscript expressions
ard list
dependence grain
representative dependence
later grain
order summary
memory location
two ards
two grains
dependence grains
region test
stride equivalent
subscripting expressions
ro wf
base oset
procedure boundaries
access summaries
enclosing context
dependence arc
dependence test
memory accesses
ne expressions
input dependence
ne subscript
anti output
memory locations
memory references
across procedure
compiler transformations
array access
intersection algorithm
memory access
subscripting oset
flow anti
internal overlap
array reshaping
recursive intersection
dim ard
dimensional recursive
sets ro
oset sequence
enclosed context
access patterns
test could
loop based
dimension index
linear memory
memory related
outer loop
accesses within
abstract interpretation
memory classication
region descriptor
classication analysis
classifying memory
actual argument
single ard
execution predicate
multiple subscript
ard rlist1
overlap due
complex array
remove dim
order summarization
rst access
rw 2
general dependence
point dependence
interprocedural dependence
cross iteration
output dependence
array dependence
based dependence
array subscripting
level 2
array reference
single memory
parallelism detection
coupled subscripts
flow dependence
symbolic analysis
intersection operation
base address
loop indices
execution order
multi dimensional
dependence tests
induction variable
rw 1
simplication operations
happened rst
new summary
wf 1
two dependence
idiom recognition
could parallelize
ro ro
access representation
real u
iteration dependence
wf ro
type input
conservative direction
non a ne
order summary scheme
write order summary
access region test
read only summary
across procedure boundaries
wf and rw
removed by privatization
list ard list
recursive intersection algorithm
ne subscript expressions
multi dimensional recursive
flow anti output
dimensional recursive intersection
linear memory access
add to list
ard list ard
subscripting oset sequence
point to point
memory classication analysis
access region descriptor
dependence between grains
classifying memory locations
single memory location
representative dependence arc
remove dim ard
end do end
write order summarization
anti and output
section of code
array dependence analysis
interprocedural dependence analysis
input flow anti
cross iteration dependence
set of memory
removed by induction
memory access descriptor
two dependence grains
list ard rlist1
induction or reduction
new summary sets
summary sets ro
construct and return
three summary sets
based dependence testing
fails level 2
anti output flow
internal overlap due
end do real
omega test could
memory accesses within
sets ro wf
array subscripting expressions
range test could
dependence type input
type input flow
memory referencing unit
number of loops
must be done
based on access
return a new
non empty intersection
analysis for parallelizing
data dependence analysis
programming with polaris
interprocedural array region
analysis exact side
represent memory accesses
real u 1

corpus/krapavin2000-test/628191.txt
itemsets
representatives
items
clusters
clustering
transaction
cluster
item
clasd
rock
itemset
correlations
meta
associations
poisonous
edible
aggregate
categorical
localized
ci
ai
ri
association
seeds
merge
discovered
basket
affinity
mushrooms
startsize
neighbors
market
nearest
mining
representative
similarity
unmarried
segments
database
marketing
discovering
mushroom
men
partitional
craft
neighbor
agglomerative
adult
correlation
sample
segmentation
attributes
corresponded
indian
tended
updatecriterion
cactus
eskimos
samplesizes
samplesize
mergecount
initsamplesize
weight
synthetic
picked
transactions
databases
partitions
merged
considerable
delta
concatenation
dataset
repair
grad
males
female
customer
dimensionality
ff
women
customers
percentage
species
census
noise
potentially
threshold
nn
segment
precompute
kill
random
population
recognized
lowering
synthetically
educational
bought
attribute
likelihood
lists
meaningless
finding
asymmetry
groups
grouping
sup
outliers
constituent
clustered
american
hs
links
assignment
scalability
correlated
assigning
helps
iteration
partitioning
discover
reported
option
weights
partition
expose
empirical
experiment
people
report
merging
spatial
parition
wtm
gills
extraodinarily
doctorate
cutomers
apparel
jijg
atleast
currentsize
husbands
recomputations
eskimo
thereare
professions
disproportionate
farming
sandwiches
maintainance
professorships
orrelation
educated
whites
amer
respository
thr
odor
clustersize
specialty
agglomerates
alaska
insight
running
correspondingly
dynamical
spend
notations
samples
closest
transformed
male
indiscriminate
caps
jmj
tendencies
minfg
affinities
spondingly
keke
medoid
optics
females
baskets
ran
meta transaction
item sets
cluster representatives
data set
random sample
aggregate data
categorical data
two transactions
clusters k
transaction m
cluster representative
output clusters
clustering algorithm
basket data
potentially large
market basket
association rules
large itemsets
k clusters
running time
support relative
meta transactions
localized correlations
partition itemsets
neighbor lists
itemsets ai
representatives m
data itemsets
localized associations
target marketing
large databases
nearest neighbor
support level
clustering method
maximal potentially
large itemset
k groups
m 0
item correlations
aggregate analysis
nn m
aggregate itemsets
log ff
itemsets ci
adult data
clustering categorical
common neighbors
clusters edible
representative m
overall dimensionality
craft repair
entire database
threshold 0
o n
cluster c
clustering methods
among items
two clusters
entire data
empirical results
transaction data
data points
nearest neighbors
synthetic data
categorical attributes
random partition
significant percentage
shall denote
helps us
clusters c
delta q
requires o
large spatial
merge operation
spatial databases
find associations
aggregate support
localized segments
time finding
full database
sets discovered
best merge
clustered itemsets
distance computations
list becomes
american indian
final pass
resulting meta
final partitioning
startsize seeds
rock algorithm
transactions assigned
seconds total
educational level
finding localized
hs grad
edible poisonous
number of 2
meta transaction m
number of clusters
market basket data
number of representatives
pair of items
set of items
number of links
ai s 0
nearest neighbor lists
data itemsets ai
potentially large itemset
aggregate data itemsets
number of transactions
potentially large itemsets
pairs of items
maximal potentially large
used in order
entire data set
cluster representatives m
clustering categorical data
transaction m 0
set of cluster
ai s ci
cluster representative m
number of items
number of common
cannot be found
m and m
large spatial databases
order to measure
mining association rules
partition itemsets ri
resulting meta transaction
running time scalability
representatives m clusters
transactions is defined
clusters edible poisonous
item a v
set of seeds
itemsets the set
associations in market
item sets aggregate
meaningless 2 itemsets
finding cluster representatives
ff n k
denoted by ri
n 2 delta
seconds total time
itemsets with enough
conclusions and summary
two meta transactions
adult data set
lowering the support
comparison between clustered
m and nn
item sets reported
largest k clusters
list becomes empty
finding localized associations
sets aggregate data
ai s k
useful for target
cluster representatives figure
mushroom data set
concept of meta
factor of ff
ai s figure
transactions into k
formally the similarity
transaction was chosen

corpus/krapavin2000-test/626980.txt
fbdd
obdd
hwb
omega
ae
boolean
psi
bdd
deltaff
au
synthesis
red
bdds
sink
algebraical
circuit
diagrams
bryant
manipulation
representations
merging
phwb
theta
deletion
tp
isa
sy
branching
verification
equivalence
ib
succinct
hwbfbdd
satisfiability
quantification
drechsler
wegener
canonical
gamma
hidden
efficiently
jawahar
algebraically
weighted
orderings
decision
tautology
sinks
bn
sangiovanni
vincentelli
jose
labeled
aided
gnther
jain
circuits
pc
signals
cited
wt
equ
eliminate
quadratic
successor
exponential
rolf
nonterminal
ingo
subtype
restrictions
binary
united
wm
congruent
testability
mention
bollig
brace
sieling
nobdd
bbbn
beate
darwiche
thetafl
rudell
labelled
bit
tasks
compose
remark
hash
ordering
congruence
rule
quantifications
narayan
sentations
symbolic
california
packages
shannon
san
wolfgang
adnan
fujita
segmented
switch
redirect
dags
succinctness
z
package
polynomial
np
vlsi
transistor
merged
tested
internal
logic
became
gammai
amit
uniquely
ist
henrik
multiplication
decomposable
repre
combinational
logn
automation
indirect
merely
reductions
alberto
quantify
proposition
source
predecessors
son
going
heuristics
label
deleting
read
cubic
probabilistically
minimization
programs
containment
frontiers
ordered
altogether
reducible
inputs
working
woelfel
allmost
perkowski
thathachar
mdd
fbdds
probabilistical
occure
falkowski
meinel
brayton
ae ae
omega omega
z z
gamma psi
omega ae
boolean functions
theta theta
fbdd p
boolean synthesis
merging rule
binary decision
bit function
weighted bit
hidden weighted
deletion rule
r gamma
decision diagrams
reduced fbdd
x k
boolean manipulation
basic tasks
complete type
branching programs
type hwb
p 00
variable ordering
boolean function
psi r
ae j
function hwb
binary boolean
synthesis steps
tp p
synthesis step
p 0
equivalence test
red p
au deltaff
fbdd representations
variable orderings
size p
j omega
circuit design
sink path
psi gamma
j x
o size
z ae
obdd representations
sy n
fbdd size
deltaff gamma
size obdd
ordered binary
us mention
type 0
fbdd phwb
size fbdd
n fbdd
deltaff theta
two fbdd
bn deltaff
fbdd type
au omega
fbdd concept
equivalent nodes
algebraically reduced
au bn
important functions
internal variables
k 3
let us
x n
integer multiplication
circuit verification
au r
efficient manipulation
ae theta
bdd based
space efficient
design p
ae omega
exponential size
california united
jose california
efficient solutions
sometimes even
data structure
f k
ae r
computer aided
united states
graph driven
type tp
input fbdd
type cited
equ fbdd
algebraical congruent
variable quantification
obdd size
function isa
apply procedure
hence efficient
since fbdd
external signals
fbdd pc
fixed type
ingo wegener
congruence relation
art data
storage access
ib n
n hwb
algebraical reduced
ae ae ae
z z z
omega omega omega
omega omega ae
terms of fbdd
r gamma psi
theta theta theta
hidden weighted bit
weighted bit function
binary decision diagrams
omega ae j
gamma psi r
bit function hwb
x k 3
fbdd of type
terms of obdd
tasks of boolean
boolean synthesis steps
x k 2
j omega omega
psi r gamma
boolean synthesis step
ae j omega
red a p
z z ae
k 3 x
j x k
x k 1
z ae ae
psi gamma psi
gamma psi gamma
deltaff gamma psi
h 1 n
cited in figure
ordered binary decision
source to sink
structure for boolean
r r gamma
let us mention
au omega omega
k 2 x
functions in terms
ae ae r
deltaff theta theta
ae theta theta
fbdd s p
binary boolean synthesis
labelled by x
o size p
sy n fbdd
p of type
efficiently in terms
bn deltaff theta
au bn deltaff
jose california united
aided design p
h i j
number of ones
labeled by x
representations of boolean
f j x
ae omega omega
u and v
california united states
ieee acm international
san jose california
g 1 n
omega ae omega
type tp p
z z x
fbdd s let
variable is tested
indirect storage access
path each variable
storage access function
fbdd s similarly
fixed variable ordering
binary boolean operation
wolfgang gnther rolf
time o size
applying the merging
based data structures
r ae ae
bdd based data
ae r gamma
au r ae
analysis and manipulation
gnther rolf drechsler
case of obdd
labeled by 0
size p 0
satisfiability or tautology
single boolean synthesis
f 2 ib

corpus/krapavin2000-test/607196.txt
broadcast
tune
frames
signature
clustered
disks
indexing
cycle
index
frame
hybrid
scattering
flat
client
signatures
meta
tree
attribute
mobile
replicated
info
sig
channel
wireless
bd
channels
disk
scheduling
probe
sparse
air
integrated
access
segment
tunes
organization
overhead
broadcasting
clients
packets
chunks
efficiency
segments
drop
arrival
caching
comparisons
minor
filtering
saved
pull
dissemination
retrieving
clustering
query
dik
selectivity
chien
block
lun
waiting
retrieve
cycles
prefetching
pointers
lee
chunk
indexed
disseminated
skewed
push
hashing
false
schedule
retrieval
conservative
workaholics
sleepers
qinglong
jianliang
arrives
height
estimated
environments
levels
downloads
jianting
spinning
desired
offset
frequency
requested
overheads
indexes
interleaves
monitoring
children
wang
superimposed
equals
dk
gruenwald
strengths
ds
lcm
asymmetric
waterloo
imbalanced
attributes
hu
bandwidth
worse
consumption
chong
hwang
formulae
proportional
units
interleaved
frequently
scheduled
server
strings
speeds
cluster
successive
logically
accommodating
beginning
power
song
bit
delivery
conservation
battery
probes
items
retrieved
geographical
updates
consecutively
peng
record
impacts
ffl
balancing
packet
broadcasts
allocation
inversely
missed
enviroments
leong
fanouts
tuneb
imitates
consump
quinglong
qingzhao
administrating
hambrusch
employeed
influencies
clusterness
yuni
dmitri
kwangjin
interrelation
meee
sence
kalashnikov
baihua
prabhakar
index tree
broadcast cycle
data frames
access time
broadcast disks
clustered broadcast
non clustered
flat broadcast
index methods
data frame
signature method
integrated signature
indexing efficiency
data broadcast
scattering factor
tree method
sparse index
meta segment
data block
broadcast channels
desired frames
false drop
non index
data organization
signature methods
broadcast scheduling
index method
initial probe
time overhead
clustered data
indexing method
meta segments
broadcast channel
cost models
indexing techniques
time saved
minor cycle
replicated part
indexing methods
hybrid index
info frame
clustered cycle
frames tree
drop probability
desired frame
index overhead
waiting time
hybrid method
desired data
hybrid indexing
hybrid methods
first desired
index frames
conservative indexing
info info
tree overhead
probe time
client tunes
frame frame
tree techniques
hybrid figure
cycle x
x 1e
data access
attribute value
power conservative
distributed indexing
wireless broadcast
average access
sig hybrid
broadcast cycles
average false
wang chien
minor cycles
tree sig
frame info
broadcast units
chien lee
data broadcasting
data dissemination
broadcast schedule
attribute indexing
mobile computing
index trees
mobile computer
signature techniques
true match
information frames
level signature
expected access
query signature
broadcast d
time comparisons
simple signature
index nodes
saved per
signature technique
whole index
control index
access patterns
tune in time
clustered broadcast cycle
index tree method
non clustered broadcast
sparse index tree
access time overhead
number of frames
time and tune
clustered and non
number of data
false drop probability
clustering and scheduling
time for retrieving
x 1e 05
frames in cycle
power conservative indexing
hybrid indexing method
index tree techniques
index tree overhead
first desired frame
non index method
cycle x 1e
initial probe time
non clustered data
cycle the tune
tree and signature
tree sig hybrid
clustered data organization
frames tree sig
sig hybrid figure
desired data frames
clustered data broadcast
average false drop
cycle i e
wang chien lee
number of packets
data access patterns
data on air
amount of tune
time saved per
wireless data broadcast
upper t levels
scattering factor m
info frame info
time and indexing
tree is broadcast
saved per unit
frame frame frame
clustered broadcast cycles
whole index tree
expected access time

corpus/krapavin2000-test/609391.txt
ic
qam
qpsk
bpsk
modulation
cancellation
multistage
users
interference
fading
cdma
multicode
ber
rayleigh
noise
awgn
channel
channels
baseband
mf
mixed
signal
cancelled
mai
gaussian
ds
nddic
multicodes
multiuser
ary
variance
detector
zeroth
stage
pilot
imperfect
spreading
ranking
cancellations
signals
stages
multirate
symbol
receiver
symbols
detectors
analytical
gold
sequences
ae
signature
simulations
rec
ff
strongest
format
db
eqns
psfrag
icu
asynchronous
stationary
coherent
orthogonal
orth
amplitude
filter
matched
simulation
analysed
rate
flat
synchronous
five
branch
qq
cancelling
perfect
received
caused
decorrelating
dtt
canceller
nonselective
replacements
ser
decision
composite
decoded
transmitted
energy
employing
nels
oe
qi
subscript
th
gain
formats
rectangular
mobile
pulses
codes
power
rates
radio
correlation
theta
conditioned
transmission
amplitudes
detection
holtzman
sers
correlator
estimates
uncorrelated
transmits
degradation
spread
sin
outputs
schemes
optimistic
prospect
interfering
unconditional
analyse
division
average
estimated
variances
chan
agree
spectrum
successive
bit
decoder
iq
shadowing
mix
station
preferable
calculate
patel
subtracted
synchronously
capacity
noticed
probability
partly
chip
conventional
frequency
quadrature
pdf
error
ave
near
successively
stringent
cancel
slowly
estimation
statistics
block
approximation
estimate
rewriting
optimum
bank
delta
thereafter
suboptimal
expression
expressions
multiples
counteract
antipodal
demodulation
koe
sic
despreading
quaternary
despread
verd
intersymbol
asyn
suboptimum
mmse
jamal
cellation
multiaccess
implicates
mistaking
decorrelator
mixed modulation
interference cancellation
qam users
qpsk users
single stage
rayleigh fading
ds cdma
th user
multistage ic
stage ic
m ary
ary qam
parallel channels
modulation systems
signature sequences
gaussian approximation
five stages
average ber
ic scheme
baseband signal
multicode system
modulation format
noise caused
user bound
h th
e b
k l
stationary awgn
decision variable
modulation system
multiple access
simulation results
cdma systems
channel parameters
imperfect cancellation
single bpsk
pilot symbols
single rate
gaussian noise
fading channels
single user
matched filter
bpsk figure
flat rayleigh
bpsk users
mf rec
multicode systems
multistage scheme
composite signal
symbol error
bpsk qpsk
b n
one two
near far
random sequences
rate systems
spreading sequences
rate users
cdma system
strongest user
mf receiver
successive interference
multistage interference
ff k
oe k
q k
similar expression
awgn channels
decision variables
n 0
k h
data rates
power control
noise term
channel gain
non decision
multiuser detectors
decision directed
ratio ae
channels per
zeroth symbol
perfect ranking
noise ratio
two parallel
multiple data
division multiple
code division
psfrag replacements
known channel
error probability
k th
simulation analysis
th stage
data rate
directed interference
orth gold
perfect power
rec simulation
modulation formats
imperfect cancellations
orthogonal spreading
first user
analysis single
per bit
rec single
stage interference
received signal
average power
m ary qam
mixed modulation systems
single stage ic
b n 0
e b n
two and five
mixed modulation system
single user bound
stages of ic
k th user
caused by imperfect
h th user
single bpsk figure
ds cdma systems
flat rayleigh fading
bpsk and qpsk
n i q
two parallel channels
analytical and simulation
rayleigh fading channels
signal to noise
single rate systems
stationary awgn channels
ae i ae
multistage interference cancellation
successive interference cancellation
n 0 values
probability of error
respect to ff
ds cdma system
probability of symbol
non decision directed
parallel channels per
channels per user
noise ratio ae
q k l
ae i h
code division multiple
division multiple access
systems with ic
users in rayleigh
multiple data rates
decision directed interference
analysis single bpsk
multistage ic scheme
system with 15
qpsk and 16
simulation analysis single
rec simulation analysis
using order statistics
mf rec single
orthogonal spreading sequences
rec single bpsk
mf rec simulation
energy per bit
high rate users
users and two
l i k
number of stages
stage of ic
qpsk 15 users
mean square value
graph shows analytical
stage interference cancellation
bpsk and 16
single rate system
multirate ds cdma
number of ic

corpus/krapavin2000-test/627818.txt
imprecision
impamt
lock
locking
updatespeed
compatibility
semantic
transaction
invocation
req
consistency
esr
concurrency
serializability
submarine
rtsorac
safety
locks
request
ot
attribute
import
osition
temporal
object
invocations
la
preconditions
spec
export
oesr
accumulation
granted
database
epsilon
exportimp
getspeed
speed
requested
priority
precondition
readaffected
arguments
item
requests
cf
restrictions
attributes
logical
rtdbms
enforcement
accumulated
temporally
importimp
writeaffected
returnargs
return
writes
serializable
queue
oriented
interleavings
jz
released
exported
imprecise
affected
mechanism
timing
execute
interleaving
limit
inter
getp
valuej
incp
locked
endif
restore
commutativity
schedule
amounts
arg
act
simultaneous
concurrently
correctness
sensor
wj
bearing
databases
argument
evaluates
old
read
objects
limits
ffl
invoked
invariant
bounding
deadline
threatened
impamts
incposition
activelocks
riteaffected
sstate
getposition
reads
update
active
enforcing
increment
updates
tracking
differs
maintains
country
queued
lc
mi
manager
conjunctive
restored
designer
semantically
ships
safe
meets
semantics
retried
combat
enqueue
inconsistency
trade
amount
restriction
clause
yes
maintain
executes
sufficiency
traded
restores
specifies
relaxing
scheduling
items
held
metric
exec
imported
transactions
precise
releasing
contact
meeting
specify
prototype
constraint
blocking
gamma
violated
management
predicate
restricted
js
lb
solaris
updated
allowed
accumulates
synchronizing
protocol
considerations
accumulate
releases
involving
computes
constrains
frontiers
criterion
allowable
concentrates
constraints
air
compatible
enforce
offs
relationships
ensures
returned
architechture
hpr
getcountry
semantic locking
compatibility function
semantic lock
temporal consistency
m req
method invocation
locking technique
locking mechanism
r impamt
concurrency control
step la
logical consistency
data ffl
speed attribute
ffl spec
return argument
invocation request
inter object
control technique
ot safety
return arguments
lock request
real time
method invocations
import limit
object type
restricted semantic
la 2
limit r
initial imprecision
object oriented
write affected
data item
epsilon serializability
m 1
imprecision amount
affected set
updatespeed 10
cf m
future method
time object
impamt new
m act
object safety
step c
bounded imprecision
item x
submarine object
rtsorac model
imprecision accumulation
imprecision procedure
la 1
impamt old
data safety
priority queue
oriented database
input argument
general restrictions
export limit
remains invariant
safety remains
lock requests
timing constraints
imprecision limits
active lock
logical imprecision
updatespeed 2
updatespeed 1
safety thus
object constraint
consistency constraints
time concurrency
object o
data temporal
m 2
oriented databases
active locks
potential increase
importimp r
introduce imprecision
simultaneous method
bound imprecision
speed value
writeaffected m
readaffected m
enforcement rule
p osition
imprecision amounts
argument r
invocation m
control work
affected sets
cf updatespeed
technique maintains
time databases
r using
metric space
correctness criterion
value time
may return
precise data
input arguments
value written
database manager
amount of imprecision
semantic locking mechanism
semantic locking technique
data ffl spec
concurrency control technique
method invocation request
restricted semantic locking
semantic lock request
import limit r
step la 2
future method invocation
time object oriented
real time object
data item x
object oriented database
initial imprecision procedure
safety remains invariant
step la 1
updatespeed 10 6
imprecision t x
write affected set
time concurrency control
imprecision that m
r impamt new
data temporal consistency
inter object constraint
real time concurrency
lock is released
technique is used
object oriented databases
temporal consistency constraints
may return true
imprecision that may
method invocation m
cf updatespeed 1
invariant for every
function for cf
invocation of updatespeed
updatespeed 1 updatespeed
concurrency control work
transaction t update
locking technique maintains
invariant after step
imprecision that could
return argument r
transaction t read
two general restrictions
imprecision is accumulated
r impamt old
lock for m
objects and transactions
real time databases
value of r
limit t x
lock is requested
based concurrency control
time and imprecision
impamt new yields
write affected sets
cf m 1
original r impamt
submarine object type
accumulation must specify
increase in imprecision
combining this relation
ffl spec speed
computes the amount
r 2 returnargs
logical and temporal
compatibility function cf
compatibility function evaluation
value of speed
invocation request m
safety thus ot
associated imprecision accumulation
limit r gamma
locking mechanism executes
maintain temporal consistency
argument s 1
safety t o
m req exportimp
requirement for ot

corpus/krapavin2000-test/1013758.txt
bll
realizability
polytime
morphism
lambda
resource
monoidal
witnessed
ne
morphisms
substitution
dyadic
functor
computable
polynomials
xyz
witnesses
goerdt
pwq
xy
untyped
theoretic
formulae
tally
positively
negatively
sequent
resp
category
sequents
girard
polynomial
categorical
valuations
waste
forgetful
pnq
yx
functoriality
homologous
syntax
denotations
logic
calculus
typed
proofs
axiom
arity
lists
constructive
successor
da
lh
proposition
representable
weak
cut
composition
extensional
storage
closed
monotone
erent
formula
interpretation
polymorphic
ambient
induction
light
pairing
stratified
characterizations
computability
lemma
justifies
quantification
functional
formulas
normalization
st
formers
antitone
subquotient
uneasy
eponymous
normalisable
monoidalness
sleight
scedrov
bck
dereliction
connectives
lemmas
interpret
elimination
universe
axioms
derivations
indexed
semantics
def
ij
products
soundness
odel
retracts
feels
lll
retractions
polymorphically
sloppily
gentzen
topos
substitu
occurring
capturing
generous
fibred
bears
zf
ptime
pers
mathematician
inductively
says
notice
shall
compilation
cf
provability
gurevich
peano
fst
yz
characterisations
defini
er
strength
di
formalize
qa
subterms
logspace
lncs
stipulate
multisets
iteration
occurrence
inductive
remark
validates
presumed
combinators
foundational
componentwise
encompasses
constructively
constructions
categories
ternary
valuation
xx
defect
write
usual
characterizing
ectively
intriguing
nx
connective
extends
polymorphism
pspace
interprets
isomorphisms
inverses
congruence
carrier
ordinary
tracked
bijection
epsrc
subsumed
witness
multiset
distinctions
encoded
atomic
universal
primitive
merits
sublinear
weakening
rules
concrete
altering
binomial
syntactical
realizability set
realizability sets
resource variables
ne lambda
linear logic
b x
dyadic lists
resource polynomials
set theoretic
n x
resource polynomial
x p
lambda term
second order
bounded linear
order environment
lambda terms
bll formula
v x
f n
p x
free resource
x x
x xy
x y
light linear
e x
untyped lambda
x n
proposition 4
weak x
tally natural
iteration lemma
bll formulas
polytime algorithms
xy x
e witnesses
witnesses f
polytime computable
n n
time computation
occurs positively
symmetric monoidal
order variable
ne linear
monoidal closed
lemma 4
polynomial time
forgetful functor
morphism f
definition 4
lambda calculus
natural numbers
n p
cut elimination
order variables
f e
time computable
p p
algorithm e
set theory
function n
x 0
indexed products
resp negatively
ne variant
logic characterizing
consider morphisms
useful examples
constructions 2
resp see
xyz x
resource variable
complexity lambda
bounded storage
size increasing
type primitive
representing zero
inductive constructions
non size
functions representable
realizability model
bll syntax
computational strength
increasing polynomial
u indexed
homologous p
ambient set
application st
entire discussion
linear types
bll 3
y yx
satisfying x
logic bll
iteration principle
stratified functional
functor proof
example 4
e y
write p
function f
function e
complexity classes
polynomial p
substitution from x
set over x
bounded linear logic
second order environment
ne lambda terms
n 2 x
free resource variables
x is positive
e is polytime
ne lambda term
computable in time
may be witnessed
witnessed by e
polynomial time computation
set of resource
e is computable
light linear logic
x to y
n x n
f n n
n p x
e witnesses f
second order variable
syntax of bll
morphism f n
tally natural numbers
environment over x
second order variables
function f n
e x y
x is defined
occurrence of resource
define a realizability
x xy x
increasing polynomial time
type of dyadic
valuations over x
resource polynomial q
write a substitution
appropriate categorical structure
environment over y
resp see 3
sequent a 1
bll in terms
higher type primitive
x n p
inductive constructions 2
resource polynomial p
theorem 4 21
u indexed products
realizability set n
linear logic bll
programs and computational
linear logic characterizing
categories b x
calculus of inductive
e v x
p p x
realizability sets must
xy x xy
size increasing polynomial
classes by higher
sets definition 4
cf lemma 6
variant of bll
x y yx
realizability sets definition
e y x
morphism from n
sets over x
type primitive recursive
formalize the entire

corpus/krapavin2000-test/1039913.txt
terminals
rounding
terminal
semimetric
multiway
relaxation
lg
uv
tardos
integrality
cut
planar
vazirani
metric
nonterminals
jt
kleinberg
inequality
multicut
expander
dahlhaus
rao
klein
met
endfor
kpr
minfr
triangle
pixel
nonterminal
garg
minor
vertices
infinitely
approximation
nonnegative
calinescu
graphs
weight
expanders
arcs
weighted
metrics
flow
extension
yannakakis
plotkin
edge
arc
cluster
integrands
karzanov
karloff
hst
maxfa
labels
labeling
pp
claim
edges
ratio
capacity
reals
min
jv
log
flux
relaxations
disconnects
penalizes
rabani
leighton
distance
separated
unassigned
cuts
lengths
minimize
feasible
multicommodity
lemma
intensity
hl
assignment
randomized
polynomial
max
integral
jsj
pr
comput
restoration
removal
siam
vertex
distances
assigned
je
notice
jc
growing
vision
chuzhoy
sarnak
antiparallel
khot
aranyak
lubotzky
subhash
kjv
pick
permutation
shortest
gupta
closest
jr
multiterminal
dlg
apx
karger
eh
fsg
combin
earthmover
tight
label
clusters
fix
pixels
subgraph
nee
thorup
cunningham
phillips
yuval
ramanujan
penultimate
diameter
endpoints
sequences
expansion
supposedly
dk
mehta
maxfn
disjoint
assign
stein
bartal
raster
seymour
jcj
connect
asymptotically
optimum
uniformly
exhibit
intensities
combinatorially
howard
nonpositive
congruent
hr
iff
nodes
approximating
tg
jej
sqrt
papadimitriou
weights
flavor
bounds
excludes
nondecreasing
agarwal
visual
fractions
exceeding
cn
ravi
distortion
rounding procedure
u v
multiway cut
integrality ratio
approximation algorithm
f u
planar graphs
c u
lg n
metric relaxation
r minor
jt j
d f
v u
extension problem
log jt
c uv
lg k
log k
u f
triangle inequality
k r
f v
multicut problem
minor free
approximation algorithms
assignment cost
programming relaxation
flow min
feasible solution
u 6
polynomial time
max flow
o z
metric labeling
minimize c
z 2m
uv 2
terminal j
least k
v d
linear programming
cut problem
cut theorem
infinitely many
o r
graph e
edge lengths
terminal closest
nonnegative edge
weight o
inequality 3
least lg
uniform metric
dahlhaus et
j approximation
weighted planar
l j
min cut
r r
improved bounds
edges uv
arc disjoint
z log
klein plotkin
claim 5
whose removal
o log
r 3
inequality follows
l v
j 2
u therefore
every nonterminal
time algorithm
positive integer
k 2
region growing
r j
d max
optimal solution
v 0
input graph
k approximation
v c
u 4
o 1
g 0
cluster c
nodes u
vazirani 17
growing technique
add arcs
rao 13
instance defined
fix u
extension instance
al relaxation
semimetric d
weight z
cost penalizes
pick uniformly
natural linear
uv c
minimum flux
garg vazirani
labels model
d f u
c u v
r r minor
k r r
f u f
u f v
least k 2
kleinberg and tardos
o r 3
v d f
linear programming relaxation
log jt j
r 3 z
minimize c u
v a u
solution of met
r minor free
u v d
max flow min
multiway cut problem
u and v
min cut theorem
o 1 approximation
u 6 v
flow min cut
u v u
u a u
dahlhaus et al
polynomial time o
z log k
d to v
weighted planar graphs
j approximation algorithm
j a u
extension of weight
o z log
jt j approximation
minfr t 2g
o log jt
polynomial time algorithm
extension of d
log k approximation
v c u
u a v
plotkin and rao
l j 2
l v r
distance in g
u v c
v u v
k approximation algorithm
x 2 c
e u v
o log k
given a graph
r so d
assignment cost penalizes
edge weights c
et al relaxation
every nonterminal u
problem of dahlhaus
edges of minimum
produces a 0
amounts to determining
lg n since
e with nonnegative
gupta and tardos
extension instance defined
v are nonterminals
observed and assigned
jc r j
e v u
assigning a label
nodes to terminal
g path metric

corpus/krapavin2000-test/606895.txt
gencan
extrapolation
spg
lancelot
tn
fe
quacan
gradient
cg
backtracking
evaluations
ge
unconstrained
chebyqad
kg
box
iterations
trust
trial
ks
iterate
conjugate
functional
armijo
steplength
extrap
sif
cute
spectral
qrtquad
projected
constrained
minimization
innite
unsuccessful
expquad
descent
rst
face
faces
extrapolations
quadratic
gradients
newton
nishes
directional
convergence
aatrial
unicamp
nonscomp
hadamals
secant
aamax
borwein
ime
birgin
barzilai
dened
subproblems
lagrangian
convergent
fortran
stationary
hg
iteration
region
stops
nal
minimizer
derivative
augmented
satises
interior
unitary
hessian
quotient
ao
packing
cient
xnew
newtonian
pronex
usp
quot
bdexp
fapesp
projections
martnez
boundary
nish
direction
schrage
modications
judge
satised
xed
fx
cylinder
dene
multipoint
cnpq
preconditioned
stopping
lim
numerical
su
truncated
incremental
preconditioning
accepted
go
leave
ug
complementarity
max
radius
nonlinear
subsequence
successful
optimization
continuity
paulo
fullled
br
criterion
else
angle
perhaps
kd
leaving
subspace
aa
subroutines
surprisingly
dierence
seed
objective
active
ronconi
mccormck
kbkks
monitorized
nnaa
trapolation
campinas
rua
nishihara
linverse
films
retards
deconvb
lagrangean
explin
imecc
subalgorithms
nondegen
sociometry
egbirgin
functional evaluations
x k
trust region
ge cg
fe ge
line search
kg p
box quacan
box constrained
spectral projected
tn iterations
projected gradient
step 4
k 2
fe functional
trial point
spg iterations
cg time
algorithm 2
conjugate gradient
step 3
algorithm 3
gradient method
functional value
directional derivative
global convergence
armijo condition
x kg
bound constrained
current face
x k1
constrained optimization
problem n
d k
f x
step 2
k max
else go
augmented lagrangian
limit point
k 5
step 1
unconstrained minimization
fx k
new iterate
k 1
p x
incremental quotient
ks k
cient descent
hg x
simple bounds
tn extrap
computer time
chebyqad 50
time f
step 5
direction d
exists k
iterate x
search direction
compute step
functional values
active set
well dened
free variables
k 4
large scale
k k
constrained minimization
minimization algorithm
taking limits
qrtquad 120
using sif
projected gradients
every limit
order stationary
truncated newton
g birgin
gencan incremental
spg iteration
set trial
expquad 120
angle condition
quotient version
backtracking step
ks 0
gradient iterations
convergent subsequence
nonscomp 10000
region algorithms
iterations tn
constrained algorithm
region radius
cg iterations
extrapolation tn
unconstrained stationary
quadratic subproblems
cylinder packing
tn step
working set
x di
else set
unconstrained optimization
evaluations per
m martnez
k g
descent direction
many constraints
strictly decreasing
conjugate gradients
objective function
feasible set
number generator
theorem 3
algorithm 2 1
k 2 k
fe ge cg
ge cg time
fe functional evaluations
x k 1
f x k
go to step
kg p x
iterations with extrapolation
time f x
spectral projected gradient
fe it fe
f x kg
p x k1
n it fe
x kg p
algorithm 3 1
direction d k
algorithm 3 2
exists k 2
step 2 2
fx k g
step 3 1
k is computed
su cient descent
cg time f
iterate x k
step 4 2
generated by algorithm
box constrained optimization
hg x di
rst order stationary
x k d
j m martnez
conjugate gradient iterations
trust region algorithms
incremental quotient version
step 5 else
box constrained algorithm
tn step 1
barzilai and borwein
trust region radius
spectral projected gradients
extrapolation tn extrap
step 4 1
ks k k
within the faces
boundary of b
set s step
computed at step
step 4 backtracking
every limit point
step 2 1
step 3 3
r 2 f
k d k
k 2 f0
random number generator
algorithm 4 1
birgin j m
unconstrained minimization problem
bound constrained minimization
gencan true hessian
leave the current
tn iterations tn
large scale unconstrained
constraints and simple
methods for unconstrained
evaluations per iteration
set to step
bounds a globally
line search procedure
truncated newton approach
perform the test
bound constrained optimization
projected gradient method
order stationary proof
optimization 76 79
backtracking was necessary
additional unnecessary functional
trust region methods
onto the box
criterion kg p
continuous projected gradient

corpus/krapavin2000-test/1037287.txt
documents
slovenian
odds
tagalog
query
croatian
retrieved
queries
document
learning
web
ptf
ltmii
czech
minority
frequency
target
issued
scores
neg
doc
ratio
rtfidf
exclusion
lengths
probabilistic
pages
filter
ghani
speaker
corpus
inclusion
tf
languages
language
precision
exclude
fmii
morelikethislist
mlii
corpusbuilder
retrieving
altavista
corpora
fading
ltaii
jones
english
issuing
score
engine
selection
handful
scoring
collecting
lta
multinomial
native
docs
fm
keywords
vocabulary
generation
classifier
relevant
hit
za
si
url
websail
cavnar
trenkle
splet
janez
miza
speakers
po
unseen
outperforms
informal
probabilistically
crawler
winnow
text
fetch
news
querying
supplied
word
hits
preferred
multiplicative
coverage
asked
classified
lt
ml
probabilities
len
normalize
update
selecting
experiments
engines
frequent
ideal
portuguese
resnik
sola
distractor
morelikethis
cvetje
rennie
karkoli
posdocs
incterm
boley
nonrelwordfrequencies
izmenjava
serbian
stran
ltm
grobelnik
vsebina
zoprno
rtf
delo
gostilne
kazalo
posqueries
relwordfrequencies
noord
hisa
independence
urls
examined
past
finds
ker
select
success
getting
decaying
multilingual
spider
ang
mccallum
dwarfed
diligenti
brazilian
categorization
concept
uniform
proportion
odds ratio
found total
term frequency
documents found
term selection
slovenian documents
documents retrieved
query generation
total documents
target language
probabilistic term
query length
queries issued
target documents
length 3
language filter
total queries
probabilistic odds
retrieved doc
term memory
learning methods
non relevant
selection method
initial documents
exclusion terms
language documents
generation method
different initial
selection methods
relevant documents
query lengths
target concept
generation methods
long term
query parameters
initial document
tagalog documents
web pages
initial conditions
length 5
fading memory
inclusion terms
retrieved query
conditions using
learning query
using length
issued query
search engine
include terms
exclude terms
issuing 1000
minority language
minority languages
ltmii fmii
memory learning
word queries
memory less
mlii ltmii
query terms
d m
update rule
positive documents
fixed query
different learning
documents examined
croatian czech
slovenian croatian
related pages
si domain
different term
exclusion term
jones 2000
retrieving around
longer queries
ptf 3
natural languages
documents using
single word
web search
function words
normalize scores
method m
new documents
best performance
unique words2
queries odds
common words2
common words3
neg informal
fmii ltaii
initial negative
positive document
useful words3
memory method
useful words1
ghani jones
find documents
news 4
initial positive
unique words3
ratio query
common words1
additive update
retrieved different
achieved precision
slovenian words
unique words1
tf 3
using ltmii
informal 4
neg news
ratio found
collecting documents
croatian documents
documents found total
probabilistic term frequency
found total documents
slovenian documents found
total documents retrieved
found total queries
probabilistic odds ratio
total queries issued
term selection method
term selection methods
long term memory
query generation method
query generation methods
target language documents
number of documents
query length 3
different initial conditions
non relevant documents
relevant and non
number of queries
initial conditions using
retrieved query length
documents retrieved query
frequency and probabilistic
issued query length
queries issued query
target documents found
number of target
different learning methods
generation method m
mlii ltmii fmii
documents were found
total documents examined
method and length
issuing 1000 queries
ratio to select
different term selection
documents using length
methods and lengths
learning query parameters
tagalog documents found
fixed query parameters
performance is achieved
odds ratio achieved
conditions using ltmii
unique words2 useful
documents retrieved different
generate a query
scores to give
different initial documents
queries odds ratio
odds ratio found
term frequency 0
ghani and jones
odds ratio query
single word queries
useful words3 common
common words3 unique
odds ratio 5
slovenian croatian czech
query length 5
neg informal 4
ghani jones 2000
unique words1 useful
news 4 neg
neg neg news
ltmii fmii ltaii
retrieved different initial
czech and tagalog
informal 4 neg
neg news 4
common words2 unique
unique words3 useful
common words1 unique
useful words1 common
documents in tagalog
croatian documents found
inclusion and exclusion
comparison of different
number of total
achieved by odds
terms are included
frequency probabilistic term
odds ratio 0
exclusion term selection
m i according
distribution over methods
ratio with length

corpus/krapavin2000-test/629280.txt
arjuna
persistent
rpc
object
atomic
binding
server
helios
naming
module
replicas
replication
action
client
uid
activated
services
abort
gvd
objectstate
cid
commit
service
volatile
transparency
actions
passive
remote
ansaware
serialisability
statemanager
atomicaction
uids
replica
store
manager
lock
migration
concurrency
servers
stub
objects
lockrecord
thisone
invocation
functioning
crash
invocations
modules
responsible
replicated
storage
recordlist
transparencies
persistence
stable
invoking
initiate
ordinator
port
bindings
rajdoot
lockmanager
recoveryrecord
recovery
failures
structuring
invoked
clients
supporting
aborted
portable
name
crashes
portability
hostname
rpcs
facilities
activation
galileo
abstractrecord
ansa
managing
activating
copy
functionality
recoverable
tolerant
locks
permitting
destructor
node
fault
locking
active
algol
connection
unix
oriented
operating
binder
atomicity
accessing
mutually
abortion
aborting
repaired
implementing
capable
identifier
prepare
organised
transaction
facility
setlock
wheater
transputers
getmsg
putmsg
guardians
cids
rpccallrecord
concealing
hfs
committed
consistency
interfaces
management
modular
names
subsystem
committing
registered
activate
nested
copies
host
permanence
recoverability
trader
invoker
ensuing
provision
replicating
mappings
failure
policy
file
hierarchy
enhancements
creation
registering
checkpoints
revisions
cohorts
stubs
mechanisms
aborts
stores
heterogeneous
co
instances
messages
demon
transputer
gr
reply
delete
location
normally
named
primary
sockets
crashed
isa
executing
terminating
locate
maintained
string
multicast
invokes
intentions
destroyed
recorded
program
examination
interface
stuart
interconnecting
atomic action
object store
persistent object
object support
atomic actions
action module
binding service
rpc module
persistent objects
support module
active replication
object servers
object server
application program
naming service
passive replication
binding services
abort operation
connection manager
stable storage
transparency mechanisms
concurrency control
programming system
object replicas
store component
object oriented
module provides
object storage
distributed system
state changes
object manager
manager process
location information
distributed programming
remote procedure
co ordinator
commit processing
remote objects
class hierarchy
mutually consistent
object structure
persistent state
available replicas
arjuna system
invoking operations
server processes
store node
group view
volatile storage
volatile store
object b
replicated objects
name server
write lock
commit time
application programs
application level
made available
server process
replica consistency
non replicated
passive object
object stores
fault tolerant
server node
system structuring
procedure call
services provided
x window
arjuna distributed
window system
copy passive
access transparency
service operation
class specific
store representation
activated objects
server managing
activated object
system implementing
stable object
node crashes
class objectstate
replication policy
helios operating
support modules
nested atomic
naming module
system services
class statemanager
prepare operation
concurrent invocations
disk representation
manager component
binding modules
serialisability property
replication transparency
arjuna 11
local rpc
objectstate instance
user defined
operating system
persistent object support
atomic action module
object support module
naming and binding
object store component
distributed programming system
client and server
connection manager process
object store node
object is responsible
objects in arjuna
remote procedure call
support for distributed
migration and replication
version of arjuna
x window system
helios operating system
information about object
one object store
copy passive replication
object manager component
single copy passive
instance of objectstate
local rpc module
arjuna 11 23
services can also
state and methods
object support modules
rpc and persistent
necessary to ensure
operations on objects
implementing fault tolerant
consider an application
object oriented systems
list of available
managed through appropriate
concurrency control policy
achieved by invoking
using the helios
structuring fault tolerant
operation is responsible
guardians and actions
robust distributed programs
store representation e
heterogeneous computer systems
servers are created
oriented transaction processing
operations initiate terminate

corpus/krapavin2000-test/1005399.txt
robot
brooks
layer
layers
sonar
subsumption
heading
prover
pttp
circumscription
provers
prolog
shanahan
feelforce
nonmonotonic
wander
cwa
theories
golog
fwd
sensors
module
mccarthy
baral
sonars
latches
attachments
force
reiter
architecture
reactivity
levesque
logical
stickel
runaway
halt
agents
manipulators
logic
reasoning
latch
actions
nsonars
circumscribing
lesperance
circ
nonmonotonicity
reactive
tran
ai
assert
ab
modules
giacomo
fluents
planning
predicates
ahead
dist
outputs
lsa
goals
got
abduction
hol
pushing
axiomatization
agent
negation
intelligent
collide
override
sensory
inputs
antoniou
kartha
informatic
lesprance
elaboration
angle
obstacles
action
paradigm
scription
circum
cliff
brewka
repulsive
wandering
kautz
vicinity
robotics
competence
chitecture
selman
abnormality
behaviors
mobile
behavioral
commands
sure
semantic
overrides
axiomatizations
leaning
stein
lifschitz
embodied
world
axioms
html
precedence
quadrants
cycle
sentences
obstacle
seconds
plan
quadrant
overriding
ar
priority
formalizing
speed
language
readings
inability
decomposition
objects
asserted
object
body
location
physical
decoupling
strength
sensing
moore
documentation
controlling
capabilities
move
difficulties
inferences
fol
society
forces
motivations
asserts
appendix
forward
default
lisp
benefits
loop
moment
nipulators
gabbay
nomad
reactiv
concur
brains
rodney
wielding
debut
bibel
soutchanski
extendability
deduc
treewidth
otter
ox
lesper
konolige
cmd
ligence
kuipers
zeroed
abides
competent
fluent
shana
aimlessly
nonmonotonically
troubles
encoders
subsumption architecture
theorem prover
theorem provers
brooks subsumption
higher layers
robot control
logical theory
based subsumption
lower layers
layer 1
layer 0
nonmonotonic reasoning
heading angle
technology theorem
prolog technology
semantic attachments
mobile robot
get force
avoid layer
halt robot
heading speed
turn heading
logic based
common sense
different layers
level robot
reading sonar
need turn
brooks system
sonar reading
pushing object
lower layer
language includes
two layers
intelligent agents
logical theories
logical approach
fwd heading
levesque 1997
ai architecture
shanahan 1998
action theory
feelforce module
ab avoid
sonar dist
circumscription formula
wander layer
parallel circumscription
layers may
brooks 1986
brooks architecture
separate theorem
level layers
goal location
high level
input language
higher layer
physical sonars
control modules
specify actions
sonar number
agent programming
subsumption latch
r module
sonar direction
priority goals
behavioral decomposition
turn module
detected objects
model elimination
give formal
avoid heading
layers 0
reactive layers
sense informatic
formalizing common
based ai
avoid objects
shanahan 1996
antoniou 1997
min dist
directly ahead
towards 0
avoidance capabilities
new heading
prover implementation
reiter 1996
circ layer
logical representation
module checks
runaway module
let layer
complex layers
tran 1998
combined repulsive
g shanahan
level layer
sonar module
output language
extended prolog
object ahead
proof goal
lesperance levesque
circum scription
original theory
elaboration tolerance
overall state
golog program
brooks subsumption architecture
technology theorem prover
based subsumption architecture
logic based subsumption
prolog technology theorem
turn heading angle
sonar reading sonar
robot to move
high level robot
negation as failure
fwd heading speed
theory of layer
need turn heading
first two layers
search for cost
baral and tran
robot control system
reiter 1998 lesprance
based ai architecture
lesperance levesque 1997
output from layer
goals to override
higher layers may
tran baral tran
common sense informatic
al 1996 reiter
commands the robot
planning and execution
baral tran 1998
model elimination theorem
e g shanahan
circumscribing the theory
collection of theories
version of brooks
combined repulsive force
parallel circumscription formula
ab avoid heading
c function get
system of layers
separate theorem prover
g shanahan 1996
includes the symbols
idea of subsumption
lesprance et al
sensors output latches
logic based ai
layer i ab
higher level layers
levels of competence
prolog and lisp
layers to observe
formalizing common sense
function get force
mccarthy s circumscription
add the parallel
inferences in 0
elimination theorem prover
theorem prover implementation
give formal semantics
input language includes
society of mind
sense informatic situation
implemented using theorem
reading sonar dist
general purpose theorem
use of semantic
find the required
possible for higher

corpus/krapavin2000-test/1005058.txt
recommender
vzpro
customer
association
mining
genbus
msweb
breese
dependency
recommendations
customers
products
heckerman
sarwar
datasets
item
dataset
profile
commerce
usocs
ratings
recommendation
confidence
items
cosine
similarity
training
collaborative
predictions
erent
karypis
prediction
filtering
purchase
predictive
historical
sql
verizon
correlation
ms
profiles
similarities
product
sparse
rules
clustering
coe
accuracy
di
networks
active
server
sites
rates
ered
communities
overfitting
decline
sparsity
companies
abilities
loyalty
usoc
caller
pearson
null
scores
toy
er
cient
schafer
microsoft
cluster
ect
recommend
voice
bayesian
scoring
service
euclidian
listing
acceptance
predict
scalability
preferences
votes
news
na
mail
clusters
siteseer
ungar
wtn
underfitting
hettich
konstan
unread
crm
charges
grouplens
resulted
online
published
problematic
rate
ave
regression
neighborhood
benchmark
purchases
industries
usenet
personality
kdd
services
ective
id
successes
residential
pennock
methodologies
subsection
users
recommended
et
clustered
assist
purchased
measures
took
bay
scored
assoc
popularity
web
business
prohibitive
score
levels
format
industry
conditional
summaries
deploying
music
marketing
ects
successful
frequent
learning
foster
ciency
poor
uci
archive
editors
basket
rating
methodology
empirical
reported
ers
pd
neighborhoods
telephone
pruning
minutes
personalized
sales
database
probabilistic
telecommunication
depict
discrepancy
quality
rule
wherein
buy
entries
conducted
remarkably
discover
nonzero
network
frequency
successfully
changing
erence
pages
e vzpro
recommender systems
dependency networks
association mining
recommender system
based recommender
item based
breese et
customer profile
heckerman et
confidence rate
user based
al 2000
dependency network
al 1998
server 2000
active customer
collaborative filtering
support level
association rules
sarwar et
active user
et al
al 2001
correlation coe
sql server
e commerce
commerce sites
user item
karypis 2001
customer profiles
null predictions
ms sql
di erent
msweb dataset
product 29
time accuracy
item matrix
similarity measure
test data
predictive abilities
support levels
decline rates
accuracy time
product 26
caller id
top 5
training data
similarity measures
o er
o ered
systems based
model based
based methods
coe cient
datasets respectively
genbus datasets
genbus dataset
basic voice
voice mail
accuracy rates
mail service
ms commerce
non published
purchase data
published listing
user ratings
following subsection
confidence levels
test datasets
customer database
dataset e
commerce server
id name
rule base
product b
memory based
service order
items across
recommend products
genbus msweb
microsoft 2000
internal verizon
confidence rates
product recommendation
benchmark dataset
vzpro performed
historical purchase
ave number
better predictions
product 51
known recommender
schafer et
cluster 5
msweb datasets
certain products
mining models
toy example
based approaches
networks based
e ect
bayesian networks
lower confidence
product 1
accuracy results
based algorithms
machine learning
second phase
based recommender systems
breese et al
vzpro and association
heckerman et al
et al 2000
et al 1998
sarwar et al
et al 2001
item based recommender
e commerce sites
sql server 2000
recommender systems based
correlation coe cient
ms sql server
active customer profile
user item matrix
al 1998 heckerman
user based methods
genbus and msweb
user based recommender
number of rules
caller id name
ms commerce server
dependency networks based
non published listing
accuracy time accuracy
name and number
voice mail service
time accuracy time
commerce server 2000
basic voice mail
networks based recommender
dataset e vzpro
pearson s correlation
number of items
number of transactions
e vzpro performed
model based methods
item based algorithms
relationships that exist
cient and cosine
changing the support
well known recommender
schafer et al
well in terms
top 5 recommendations
historical purchase data
introduced in breese
number of cases
based on association
two di erent
reported in table
used to predict
used in item
association mining table
model based recommender
represent the active
acceptance and decline
ungar and foster
may have di
recommender system based
association mining based
measure of 1
performed very well
construct a dependency
proposed in breese
products recommender systems

corpus/krapavin2000-test/614396.txt
convolution
unsteady
lic
scattering
pathline
uflic
texture
flow
particle
pixel
advection
airfoil
visualization
vortex
tiles
coherence
pathlines
wing
noise
animation
visualizing
seed
image
integral
vortices
velocity
jittered
fields
buffer
buckets
flows
field
subregions
streamlines
cfd
steady
accum
wijk
forssell
jobard
filter
bucket
span
streamline
pixels
particles
filtering
deltat
gathering
visualize
life
spot
bursting
fig
feed
pass
integration
advects
erlebacher
processor
textures
physical
advected
traces
kao
workload
jarke
leedom
hussaini
yousuff
spots
motion
cohen
accurate
curvilinear
tails
cabral
dye
animations
bruno
simulations
speedup
surfaces
laplacian
phenomena
processors
tail
convolutions
successive
graphics
scattered
vis
gordon
accumulated
white
forward
surface
timestamp
ames
subdividing
normalized
zhanping
baptista
moorhead
weiskopf
bending
convolves
reattachments
hege
pitches
subdivide
nasa
phi
temporal
animated
travel
age
frames
shedding
eulerian
spiraling
convolved
scatters
velocities
coherent
normalization
travels
resolution
accelerated
jet
advect
highlight
fi
drives
ertl
leading
van
delta
mask
shen
parallelized
oscillating
stalling
regions
distribute
instantaneous
trailing
tile
obscure
originating
theta
separations
convolving
animate
phenomenon
formation
intensity
devising
uncorrelated
snapshot
ring
cpus
vertical
simulates
successively
consecutive
varying
clockwise
noteworthy
ubiquitous
buffers
images
simulation
effectiveness
blue
create
lagrangian
patterns
backward
multiprocessor
robert
wave
breakdown
contrasts
dramatic
edge
timestamps
fluid
snapshots
synthesis
emerge
unsteady flow
value scattering
line integral
integral convolution
scattering scheme
time accurate
computational time
input texture
c buffer
high pass
accurate value
flow fields
pass filtering
life span
uflic algorithm
physical time
lic method
convolution algorithm
flow field
convolution method
successive feed
integration step
time step
every pixel
new convolution
seed particle
unsteady flows
image value
flow data
jittered high
scattering convolution
noise jittered
pass filter
leading edge
pathline convolution
spot noise
current computational
noise texture
th integration
noise image
convolution path
steady lic
delta wing
temporal coherence
feed forward
flow visualization
pixel values
fi fi
flow texture
texture resolution
convolution results
convolution image
flow lines
value gathering
van wijk
vector fields
white noise
time dependent
time steps
new algorithm
visualizing unsteady
vector data
vector field
convolution values
forward process
seed particles
bruno jobard
image values
texture space
regular lic
time varying
fields using
case studies
filtering process
cohen 4
gordon erlebacher
flow features
steady flow
n th
parallel algorithm
velocity magnitude
jobard gordon
pathline p
every integration
flow patterns
leedom 3
convolution result
pixel b
pixels along
dependent method
flow motion
lic convolution
texture input
parallel uflic
unsteady lic
using line
instantaneous method
c buffers
yousuff hussaini
flow traces
shift method
flow animations
m yousuff
vertical tails
flow line
noise technique
convolution length
data scattering
flow advection
primary vortex
several cfd
ring buffer
w accum
jarke j
highly coherent
previous convolution
image generated
erlebacher m
reason lies
vortex bursting
image space
visualization 2003
ieee visualization
vis 03
line integral convolution
value scattering scheme
accurate value scattering
time accurate value
unsteady flow fields
high pass filtering
successive feed forward
high pass filter
jittered high pass
noise jittered high
unsteady flow data
th integration step
current computational time
n th integration
new convolution algorithm
white noise image
fi fi fi
value scattering convolution
forssell and cohen
along the leading
integral convolution method
pass filtering process
feed forward process
computational time step
computing the convolution
every time step
jobard gordon erlebacher
unsteady flow visualization
cabral and leedom
flow data sets
using line integral
flow line integral
unsteady flow line
bruno jobard gordon
erlebacher m yousuff
computational time steps
convolution image generated
data in unsteady
jarke j van
spot noise technique
phase shift method
every integration step
m yousuff hussaini
j van wijk
gordon erlebacher m
compute the convolution
integral convolution algorithm
unsteady flow simulation
time dependent method
visualization 2003 vis
october 22 24
vis 03 p
ieee visualization 2003
results over time
algorithm for visualizing
following we first
visualizing time varying
vector fields using
visualizing unsteady flow
visualization and computer
computer graphics v
transactions on visualization
number of buckets
ames research center
nasa ames research
wave of vortex
zhanping liu robert
new convolution method
hussaini lagrangian eulerian
path for pixel

corpus/krapavin2000-test/627097.txt
unfolded
ff
gammafi
separation
events
unfoldings
timing
dasdan
asynchronous
maximization
automation
event
rajesh
occurrence
startup
synthesis
microprocessor
delta
root
synchronize
anmol
cutsets
ali
omega
occurrences
segment
circuits
delay
pipelines
gupta
pipeline
mathur
edges
todaes
cycle
composition
cutset
marculescu
mmu
caltech
kondratyev
concurrent
acyclic
repetitive
graphs
vk
synchronizations
repeat
decomposition
myers
repetition
annotated
closure
matrix
circuit
vertices
bounds
symbolic
tightest
max
infinite
mip
separations
louisiana
segments
offset
rt
orleans
period
topologically
relate
cycles
award
labelled
tight
scalar
inexact
unspecified
fi
synchronizing
removal
cyclic
ig
optimum
ae
interior
timed
wn
strongest
relating
coupled
edge
ratio
sparc
functional
synchronous
yielding
alex
gamma
haynal
unfoldedprocess
sangyun
xiaoping
mcgee
pyi
tod
croprocessor
annihilator
dill
borriello
perfromance
csto
jiwen
nowick
abstractdetermining
froot
sunan
ratan
cortadella
kishinevsky
repetitively
beerel
davare
lwin
wig
brewer
zamora
sandy
amon
tugsinavisut
fhl
taokuan
ranges
algebra
electronic
steven
hu
united
delays
formalization
jejurikar
coffman
gaetano
unfortu
transistors
nonexpansive
composi
abhijit
gunawardena
vincentelli
peggy
yokohama
mcmillan
ravindra
rooting
sangiovanni
irani
nandi
forrest
hulgaard
madisetti
verification
ring
infinitely
concern
singleton
decompose
incident
steady
interface
denmark
presburger
havior
clocked
repeatable
nately
kelvin
matroids
multiplica
exploration
shifted
structural
co
inefficiencies
gammaff
process graph
m values
unfolded process
ff gammafi
delta ff
m root
function maximization
v k
design automation
occurrence index
time separation
maximum ratio
maximum separation
k gupta
ali dasdan
rajesh k
function composition
event occurrences
ff values
asynchronous circuits
timing verification
delay ranges
asynchronous microprocessor
startup rules
d values
automation p
relate m
cycle c
index offset
anmol mathur
structural decomposition
compute delta
f synchronize
occurrence period
ratio cycles
finite acyclic
k gamma
two events
r 0
repeat f
rate analysis
u k
graph algorithm
concurrent systems
co design
embedded systems
ae oe
todaes v
electronic systems
systems todaes
max 0
infinite unfolded
initial startup
conditional behavior
june 21
pipeline choosing
possible bounds
without conditional
wn ig
compute repeat
finite unfolded
synchronous component
gammafi omega
represents two
symbolic timing
analysis synthesis
initial occurrences
repetitive system
unfoldings relative
values repeat
relating m
unspecified delay
two startup
ratio cycle
caltech asynchronous
graph relative
synchronize b
alex kondratyev
relates m
represent events
offset 2
processes synchronizing
delay information
topologically left
infinitely unfolded
optimum cycle
coupled pipelines
tightest possible
award mip
event v
mathur ali
function relating
ff omega
microprocessor 6
hardware software
d c
edges using
matrix product
separation problem
ff max
dasdan rajesh
th occurrence
unfolded graphs
sparc 2
management unit
software co
arbitrary process
finite graph
semi ring
gupta rate
annual conference
fundamental problem
unfolded process graph
separation in time
u k gamma
m t ff
root to m
conference on design
rajesh k gupta
graph in figure
design automation p
example in figure
delta ff values
separation of events
repeat f synchronize
max 0 fi
occurrence index offset
m b 0
maximum ratio cycles
compute the maximum
systems todaes v
transactions on design
electronic systems todaes
automation of electronic
d c c
relates m root
process graph corresponding
maximization and composition
represents two coupled
synchronize b compute
infinitely unfolded process
occurrences at zero
edge u k
relating m root
function relating m
k th occurrence
arbitrary process graph
removal of six
graph he r
optimization of asynchronous
maximum ratio cycle
right by omega
process graph without
m values repeat
finite graph algorithm
m v k
index offset 2
choosing the delay
gupta rate analysis
events in concurrent
anmol mathur ali
two coupled pipelines
symbolic timing verification
june 21 25
events in y
caltech asynchronous microprocessor
tightest possible bounds
asynchronous microprocessor 6
maps the m
occurrence of event
m values obtained
since the m
unspecified delay ranges
dasdan rajesh k
part of 1
events in x
synchronize a compute
ratio cycle c
optimization of concurrent
process graph relative
mathur ali dasdan
finite acyclic graph
number of unfoldings
delay between consecutive
single function relating
compute repeat f
ff gammafi omega
relate m root

corpus/krapavin2000-test/628018.txt
ant
ants
grasp
qap
colony
trace
tabu
nugent
dorigo
activity
permutation
colonies
facility
coupling
assignment
couplings
burkard
gilmore
gl
offices
stagnation
pheromone
floors
maniezzo
autocatalytic
location
lawler
ij
population
quadratic
activities
aco
middendorf
metaheuristics
buildings
optimum
evolutionary
krarup
facilities
tsp
floor
man
ching
layout
minutes
pardalos
schmeck
boryczka
merkle
elshafei
qaplib
locations
heuristic
persistence
matrices
ih
probl
taillard
intensity
permutations
agents
heuristics
probabilistically
artificial
units
hartmut
vittorio
hospital
substance
company
life
indices
solutions
marco
tentatively
desirability
passage
li
genetic
dimension
inspired
salesman
week
unassigned
assigning
tower
quantity
assign
sec
sciencesinformatics
bk
employees
percentage
assigned
datum
managers
numbered
martin
objective
coefficient
logistic
liang
reconfigurable
emergence
accumulation
matrix
hybrid
flow
norwell
traveling
neighborhood
arrangement
allocation
goodness
avg
coeteris
evaporation
vitorino
wenbing
quali
wade
iasme
solnon
pronged
rosa
agostinho
conveyance
dragon
testcase
walkways
maxiter
alimohammadi
gonzales
shxyong
milan
rizzi
mckendall
fenet
zomaya
shiyan
hospitals
gambardella
footpaths
problema
assegnamento
colorni
abbasi
dras
shyang
desirabilities
multinational
uffici
fernandes
formiche
applicato
liman
vrat
quadratico
solimanpur
salhi
denebourg
carbonaro
hossam
koopmans
reischle
urszula
subrata
ant system
quadratic assignment
assignment problem
ant colony
th ant
colony optimization
al 1994
ant colonies
activity j
tabu list
best solution
local search
trace matrix
dorigo et
best solutions
solution found
k th
artificial life
good solutions
best known
objective function
li et
et al
ant population
man sec
martin middendorf
ant algorithm
best permutation
marco dorigo
al 1996
known solution
location 1
burkard et
system applied
system algorithm
percentage error
already assigned
partial assignment
search procedure
research v
operations research
colony system
best best
therefore z
location 2
life v
lower bound
results obtained
n 3
evolutionary heuristics
error percentage
vittorio maniezzo
trace level
floor numbered
subsets 1
permutation found
goodness ij
experience acquired
lawler bound
possibilities remain
ant chooses
flow matrices
maniezzo et
hartmut schmeck
hospital layout
tabu k
nugent et
percentage distance
d ih
autocatalytic process
dimension 20
taillard 1990
trace intensity
computer decision
trace persistence
gl bound
location h
change true
opt bk
choosing probabilistically
choice goes
yet assigned
complete permutation
distributed heuristic
m ants
potential goodness
logistic situation
z gl
assigning facility
making kluwer
sub optimum
substance called
burkard 1984
ant algorithms
gilmore lawler
solution computed
trace left
nugent nugent
daniel merkle
al 1968
ih f
whose costs
lawler lower
metaheuristics computer
man hours
n locations
three units
still unassigned
merkle martin
dimension n
lower bounds
quadratic assignment problem
k th ant
coupling i j
ant colony optimization
et al 1994
j to location
dorigo et al
local search procedure
best solution found
li et al
computers and operations
operations research v
bounds are therefore
ants have constructed
facility to assign
ant system algorithm
quantity of trace
obtained by grasp
number of ants
ant system applied
et al 1996
burkard et al
best known solution
artificial life v
ant colony system
according to equation
n 3 p
two subsets 1
gilmore and lawler
et al 1968
optimum or best
dimension n n
z the choice
define the assignment
optimal or best
best known results
best best result
solution s k
traveling salesman problem
nugent et al
produce its best
assignment to location
distributed heuristic algorithm
best result obtained
best permutation found
qap of order
making kluwer academic
metaheuristics computer decision
d ih f
computer decision making
called the ant
maniezzo et al
decision making kluwer
average over 5
distance and flow
assign to location
lawler lower bound
daniel merkle martin
best known solutions
behavior of ant
goes to assigning
one must thus
gilmore lawler lower
known solution computed
level one needs
error t best
potential goodness ij
f s k
merkle martin middendorf
error percentage error
problem of dimension
m n 3
journal of heuristics
best solution obtained

corpus/krapavin2000-test/629113.txt
quorum
coterie
coteries
nondominated
quorums
join
antiquorum
dominated
composite
agreements
nonempty
replica
exclusion
minimality
contradiction
qc
molina
abbadi
mutual
garcia
agrawal
barbara
qa
nonleaf
el
cg
unavailable
containment
agreement
complementary
masafumi
yamashita
tree
intersection
harada
complimentary
takashi
fc
protocol
protocols
read
iff
cgg
ibaraki
replicated
vote
saxena
rai
ae
rcd
children
voting
timestamps
nodes
cu
timestamp
availability
cis
votes
vulnerability
ag
node
enumerate
copy
copies
rad
returns
replicas
fa
advance
mc
inline
kuo
depth
decentralized
lem
consensus
append
kameda
tsaan
yiwei
nonreplicated
ffbgg
bioch
cbe
chiao
abaddi
ffagg
toshihide
sangita
neilsen
jagmohan
coter
clocks
assignments
satisfied
permission
ary
shyan
arbiters
mizuno
shing
reviews
joining
formalized
dahlia
wool
avishai
masaaki
petersen
subsection
dominates
replication
ments
false
agree
leaf
malkhi
maximal
subsets
write
transversal
sixteenth
folded
occasions
yu
likewise
wr
herlihy
ub
concurrency
prob
determining
accident
ies
weighted
reliability
byzantine
qg
reiter
ng
gracefully
kun
child
stabilizing
database
equivalently
maxima
recovery
failures
acquires
h 3
join algorithm
composite coterie
g 3
nondominated coteries
quorum g
tree coteries
quorum set
suppose g
g 2
c 3
y 62
quorum agreements
replica control
h 1
intersection property
input coteries
quorum agreement
write quorums
consider either
complementary quorum
g 1
mutual exclusion
u 3
x 62
q gamma1
h 2
exists y
coterie join
coterie c
algorithm may
u 1
quorum sets
containment test
nonempty coteries
coterie g
antiquorum set
quorum containment
nonempty set
c 1
garcia molina
c 2
g 0
q 3
generate quorum
nondominated coterie
u 2
el abbadi
y 2
h 0
ae ae
tree protocol
consider 1
distributed mutual
depth two
tree coterie
join function
nonleaf node
nodes contains
coteries may
set h
given set
let u
new larger
version number
binary tree
control protocols
distributed systems
theorem 2
let g
exclusion problem
tree c
two cases
either x
since c
efficient method
z 62
complimentary quorum
takes nonempty
takashi harada
simple input
antiquorum sets
quorum h
harada masafumi
masafumi yamashita
g 02
qa 3
vote assignments
sets complementary
larger coterie
g h
q 2
coterie under u
set under u
show that g
cases to consider
contains a quorum
y 62 h
set of nodes
join algorithm may
g 3 6
g 3 h
y 2 g
may be used
g 3 2
coteries are nondominated
x 62 g
node a 1
theorem 2 1
g 2 c
agrawal and el
let g 3
quorum g 2
quorum containment test
exists y 2
h 3 6
consider 1 suppose
consider either x
binary tree protocol
suppose g 2
complementary quorum set
agreement under u
properties in theorem
replica control protocols
obtain a contradiction
u 1 let
distributed mutual exclusion
molina and barbara
quorum g 0
g 0 h
coterie join function
note that qc
g 2 2
dominated by theorem
coteries of depth
g 3 6ae
h 3 since
method for determining
definition of h
introduced by agrawal
x 2 u
showing that g
h 0 h
mutual exclusion problem
property is satisfied
distributed systems v
transactions on parallel
parallel and distributed
read and write
follows that g
x 2 g
start by showing
let u 1
ae ae ae
let u 2
may be applied
used to generate
c 2 first
sets complementary quorum
sets and antiquorum

corpus/krapavin2000-test/606888.txt
sqp
alsqp
qp
optimality
newton
ssc
parabolic
lagrangian
semilinear
augmented
lagrange
adjoint
banach
convergence
sucient
regularity
rst
multiplier
cgm
iterate
generalized
augmentation
satised
derivatives
bijective
yy
bw
linearized
strongly
nonlinear
discretization
boundary
spaces
iter
dened
uy
pontryagin
satises
hilbert
triplet
equations
convergent
numerical
suciently
multipliers
functional
variational
elliptic
dierential
robinson
ad
iterates
belongs
kunisch
imbedded
volkwein
gnm
jjvjj
burgers
coercive
mesh
xed
fullled
perturbation
dierentiable
locally
equation
endowed
regular
continuous
coercivity
denition
unconstrained
quadratic
veried
perturbed
shall
mapping
norm
assumptions
convex
verify
remark
hf
diculty
mappings
subsystem
boltzmann
quadratically
ku
strong
controls
tests
operator
grid
uniqueness
kr
iterations
discrepancy
mention
concrete
dene
constrained
subject
identied
cone
signicantly
concerns
precisionof
sabatier
bertsekas
precised
dierents
justifed
jjujj
sfb
quasilinear
cranck
augemented
kyk
polak
khk
kantorovitch
optimalit
optimalcontrol
kunish
unger
ckv
troltzsch
interprete
bergounioux
mittelmann
kaumann
adress
imbeddings
dsdt
hinreichende
ribiere
respectiveely
admits
dierent
stefan
sqp method
optimality system
y u
alsqp method
generalized equation
d qp
augmented lagrangian
newton method
lagrangian sqp
generalized newton
control problems
strongly regular
u 2
y n
optimal control
second order
augmented sqp
strong regularity
order sucient
semilinear parabolic
u ad
qp n
l 00
y p
optimality conditions
banach spaces
condition ssc
order optimality
parabolic equations
unique solution
u 4
convergence analysis
y 2
class c
u n
c c
boundary condition
adjoint state
boundary control
n 1
b y
f y
z y
adjoint equation
generalized equations
lagrange multiplier
equation 5
numerical tests
rst order
assumptions a1
p n
state equation
sucient optimality
state constrained
lagrange newton
run 1
local solution
y z
current iterate
control constraints
non augmented
run 2
f yy
u y
control problem
let us
sucient condition
hilbert spaces
z n
y y
u z
optimality condition
mesh size
system 5
z z
let y
l u
associated lagrange
respectively u
parabolic control
multiplier p
uy y
sqp methods
yy y
linearized equation
nonlinear optimal
problem d
continuous linear
multipliers p
order necessary
problem qp
f uy
w n
order derivatives
f u
problem 6
dierential equations
y v
partial dierential
u b
u u
l w
v h
test corresponds
v 2
update rules
y belongs
theorem 2
u p
augmented lagrangian sqp
generalized newton method
lagrangian sqp method
y n 1
qp n 1
augmented sqp method
y u 4
second order sucient
c c c
n 1 u
y to u
optimal control problems
p n 1
generalized equation 5
class c 2
d qp n
semilinear parabolic equations
u n 1
class c 1
system of p
belongs to u
y u p
locally of class
rst order optimality
problem 6 27
f y v
mapping of class
order sucient condition
order optimality system
boundary control problems
bijective from y
order sucient optimality
d a u
second order derivatives
solution of p
solution of d
c 1 1
partial dierential equations
sucient optimality condition
continuous linear operator
class of optimal
optimality system 5
method for generalized
l 00 y
z y n
solution to 5
f 0 v
f yy y
l u b
nonlinear optimal control
operator from y
type of augmentation
non augmented sqp
write for short
system for p
regular at y
z a y
rst order necessary
f y u
continuous and bijective
lagrangian sqp methods
z n 1
problem d qp
assumptions are needed
dened by 5
f uy y
let y u
u 2 u
solution of e
y u 2
n 1 2
subject to z
methods for nonlinear
z y z
n 1 n
f u v
y 2 y
let us rst
existence and uniqueness
z z z
obtained by taking
equations 5 4

corpus/krapavin2000-test/628383.txt
epipolar
optical
motion
segmentation
affine
flow
scene
rotation
regions
rigid
depth
image
frame
camera
frames
recovered
matrix
rigidly
koenderink
discontinuities
motions
doorn
cube
axis
priors
jjq
perspective
constraint
correspondences
rotating
region
ave
fundamental
velocity
coordinates
statistic
angle
planar
displacement
piecewise
kalman
moving
boundaries
geometry
perpendicular
unassigned
field
measurement
orthographic
segmented
measurements
plane
squares
growing
patches
soatto
0degrees
rubik
platen
pixel
foreground
functional
weighting
stereopsis
dense
weak
axes
projection
covariance
undergoing
objects
fit
rank
tracked
projected
outliers
displacements
recovery
prediction
uncertainty
stochastic
viewing
estimate
object
estimation
filter
omega
van
visual
shape
pixels
occlusion
shapiro
hadiashar
oe
cubes
background
discontinuity
singular
views
differentiating
texture
bab
alireza
tracking
squared
descriptive
suter
scaled
3d
projections
weighted
imaged
arctan
partitioning
synthetic
explosion
segmenting
weng
train
merged
boundary
recover
separate
rotations
penalty
toy
translational
dr
saw
intensity
depths
delta
translating
translation
variance
centroids
labeled
calibration
differential
statistical
pure
noise
silicon
unity
estimating
multiplier
dictated
multiplying
lagrange
minimization
distances
fields
perturbed
transformation
relating
deformation
gradient
matrices
formed
vision
colored
smoothness
continuation
minimizing
gheissari
schunck
niloofar
cernuschi
mitiche
cyclorotation
optical flow
epipolar constraint
fundamental matrix
affine flow
motion parameters
cost functional
flow field
velocity space
weak perspective
epipolar geometry
image coordinates
scene structure
region growing
moving objects
rigidly moving
independently moving
image plane
van doorn
rotation axis
affine camera
motion segmentation
initial segmentation
rigid motion
constraint line
scene partitioning
frame number
omega v
statistical test
rigid objects
error covariance
segmentation algorithm
rigid transformation
kalman filter
rotation matrix
least squares
measurement matrix
doorn kvd91
affine epipolar
separate regions
measured optical
recovered depth
rotation axes
axis angle
linear constraint
squares solution
viewing direction
moving object
point x
growing algorithm
perspective effects
distinct regions
partitioning problem
depth map
single frame
constraint equation
matrix w
weighting factor
shapiro et
filter approach
undergoing pure
projected point
segmentation via
constraint exists
rotating platen
separate objects
z ave
perspective camera
0degrees rotation
statistic based
unique epipolar
unassigned regions
growing method
w gamma
example optical
singular values
two regions
special form
rigid object
flow vectors
solution n
factor w
second frame
3d world
descriptive language
epipolar line
visual scene
image sequences
based region
piecewise continuous
new frame
multiple frames
optical axis
gamma q
relative depth
three dimensional
squared distances
two frames
optical flow field
koenderink and van
rigidly moving objects
least squares solution
distances in velocity
scene partitioning problem
measured optical flow
scene into distinct
van doorn kvd91
recovered depth map
motion and structure
region growing algorithm
independently moving object
shapiro et al
rotation in depth
affine in image
statistic based region
unique epipolar constraint
0degrees rotation axis
function of frame
epipolar constraint equation
kalman filter approach
weighting factor w
epipolar constraint line
example optical flow
w gamma q
flow is affine
flow and recovered
region growing method
weak perspective camera
based region growing
rotation axis angle
motion segmentation using
independently moving objects
weak perspective projection
frame to frame
function of x
value of delta
difficult to recover
using affine epipolar
new optical flow
weng et al
described in web94
point matches using
frames the rotation
representation for rotations
subject to error
projected point x
flow under weak
moving rigid objects
texture mapped cubes
first 10 frames
z 0 ave
constraint on points

corpus/krapavin2000-test/615161.txt
lock
transaction
locks
mode
downgrading
inheritance
downward
locking
waits
concurrency
ix
downgraded
inferiors
downgrade
tl
nested
deadlock
subtransactions
hierarchy
superiors
retained
commit
retains
subtransaction
parent
deadlocks
ancestors
yes
modes
upgrade
granules
argus
moss
parallelism
nl
acquire
sphere
upgrading
held
commits
child
locus
retainer
dbms
holding
ancestor
upward
object
offering
hierarchies
subhierarchy
opening
downgrades
camelot
eden
eot
descendants
holder
intra
rollback
requestor
lockable
tuples
locked
wait
children
committed
clouds
transactions
recovery
descendant
subobjects
controlled
retain
sibling
database
flat
fig
rules
six
intention
uncommitted
restrictive
compatibilities
aborts
granted
conflicting
anymore
transac
trans
cooperation
unrepeatable
firewalls
consistency
isolated
siblings
detection
resolution
request
acquired
releases
avalon
durability
relationships
hierarchical
abort
superior
acquiring
avoidance
release
sec
upgrades
rolled
holders
concept
acquires
cycle
aborting
aries
aborted
inherit
inherits
incompatible
indirectly
centralized
leaf
objects
management
inferior
protocols
read
isolation
acid
requestors
downgrader
depicted
segment
subtasks
coordinated
undo
chies
wound
retaining
decomposition
offered
effects
inherited
atomicity
conflicts
root
tuple
kind
subtree
action
refined
multilevel
timeout
victim
firewall
concurrent
updates
outcome
prevents
flexible
offer
logging
soon
released
concurrently
inconsistencies
mechanism
requesting
mohan
selective
reads
operating
access
act
requested
db
nested transactions
downward inheritance
x mode
concurrency control
x lock
h ix
controlled downward
tl transaction
locking rules
mode m
yes yes
level rules
object hierarchy
ix h
lock modes
retained locks
intra transaction
retained lock
parent child
deadlock detection
transaction parallelism
transaction hierarchy
transaction may
upward inheritance
level transactions
single level
nested transaction
parent transaction
transaction tree
object hierarchies
object o
may acquire
tl transactions
sibling parallelism
lock relation
lock held
transaction holds
h x
lock relationships
lock holder
x sphere
x locks
nl mode
mode x
level transaction
may see
locks held
control structure
trans action
transaction model
relation r
locking protocols
level concurrency
indirectly waits
hierarchical locking
see changes
mode conflicting
transaction hierarchies
lock granules
lockable units
transaction management
rules stated
among transactions
lock in x
controlled downward inheritance
level to level
inheritance of locks
waits for lock
h ix h
waits for retained
holds the lock
ix h ix
waits for commit
intra transaction parallelism
hold the lock
yes yes yes
lock in mode
single level transactions
holding a lock
retains the lock
lock to mode
lock on o
transaction t may
holding the lock
acquire a lock
tuples of r
opening up deadlock
holds or retains
retain the lock
retained lock relationships
downgrade the lock
lock it holds
transactions that retain
root to leaf
r x h
level concurrency control
may see changes
downgrading the lock
locks it holds
upgrade the lock
proposed by moss
mode are ancestors
releases all locks
downgrading a lock
offering a lock
opening up deadlocks
transaction may see
acquire the lock
conflicting with m
tl transaction hierarchy
concurrency control scheme
concept of nested
lock and waits
act as firewalls
basic locking rules
ancestor of r
outside its hierarchy
concept of downward
lock on r
top level transaction
upgrade a lock
transaction t holding
segment s h

corpus/krapavin2000-test/628513.txt
hausdorff
image
translation
distance
rasterized
voronoi
fb
pixels
bk
nonzero
translations
vision
recognition
shapes
rotation
pixel
ranked
ruling
ruled
correlation
deltax
array
rigid
probe
norm
shape
overlaid
motion
surface
nearest
phi
intelligence
ive
matching
envelope
rasterization
versa
directed
vice
registration
circles
cone
transform
locations
portions
graphics
scan
pointwise
circle
multimedia
resemblance
farthest
euclidean
images
radius
daniela
gb
united
zezula
haikel
hlk
alhichri
closest
raster
rus
pattern
geometry
translated
jacobs
na
carton
buffer
metric
delta
triangle
surfaces
portion
fa
egg
distances
david
occluded
maximization
matches
video
rotations
fractions
lee
match
bitmap
probed
kyoung
pavel
letters
pq
annual
cones
min
sparcstation
salem
near
termination
obey
retrieval
dissimilar
nicolai
petkov
anarta
rasters
huttenlocher
breuel
doermann
workshops
amato
devika
savino
rabitti
hoppenot
pradel
dec
kamel
curves
center
skipping
claim
location
camera
grid
arrays
face
mohamed
slope
athitsos
ramin
zabih
davi
olson
vita
talip
abidi
iannizzotto
philippe
thomas
sang
probing
mu
neighbor
similarity
invariant
signal
comparing
detection
neighbors
object
zheng
theta
january
ronen
gdalyahu
pasquale
luh
giancarlo
handwritten
asian
vassilis
rising
ja
zhu
uk
minimizing
fraction
symposium
measuring
inequality
park
analogously
subramanian
ghosh
gun
pan
fausto
basri
tyng
gammam
mismatched
fourteenth
hausdorff distance
k l
x y
fb x
directed hausdorff
d 0
b k
distance transform
partial distance
voronoi surface
nonzero pixel
machine intelligence
pattern analysis
th ranked
f x
computer vision
b phi
intelligence v
test image
translation x
d x
rigid motion
point sets
ranked value
directed distance
vision v
z buffer
minimum hausdorff
nearest point
pattern recognition
international journal
binary correlation
model pixels
distance h
scan termination
gb x
early scan
object recognition
vice versa
image pixels
fa x
nonzero pixels
voronoi surfaces
image registration
rasterized approximation
pointwise maximum
na ive
nonzero model
probe values
set b
ieee transactions
recognition using
b 0
k th
array d
v 24
minimum value
point b
united states
graphics hardware
triangle inequality
recognition letters
distance transforms
delta k
k delta
possible relative
upper envelope
possible translations
translated model
current translation
norm used
cone shapes
min a2a
min b2b
binary image
two shapes
within d
relative positions
computational geometry
v 21
image understanding
every point
daniela rus
minimizes f
model set
euclidean motion
min k
l elements
metric properties
letters v
two sets
shape comparison
least l
x direction
geometry p
first test
increasing x
d 0 x
b k l
fb x y
directed hausdorff distance
point of b
f x y
h a b
analysis and machine
transactions on pattern
machine intelligence v
k th ranked
d x y
computing the hausdorff
computer vision v
center of rotation
th ranked value
translation x y
distance under translation
minimum hausdorff distance
ruling out circles
l and bk
points of b
journal of computer
early scan termination
function of translation
b and vice
k delta k
hausdorff distance h
fa x y
distance under rigid
near some point
proof of claim
v 24 n
y of b
pattern recognition letters
recognition letters v
point in b
n 1 p
v 21 n
list t 0
using the hausdorff
min k l
point a 2
array d 0
first test image
gb x y
d 0 b
nonzero model pixels
compute the hausdorff
pixel of b
possible relative positions
increasing x direction
translation only case
distance for point
points in b
n 2 p
intelligence v 24
model and image
defined in equation
circle of radius
v 23 n
n 3 p
object recognition using
m x y
computational geometry p
e x y
image understanding v
vision and image
translation and rotation
n 4 p

corpus/krapavin2000-test/629048.txt
interprocedural
pfc
riceps
linpack
dependence
yew
subscript
kennedy
regular
parallelization
array
descriptors
triolet
subscripts
supercomputing
parascope
linpackd
compiler
fortran
dependences
rice
notices
summary
lattice
ref
stride
sigplan
dogleg
propagation
precision
ranges
parafrase
parallelism
symbolic
parallelized
lowenthal
kathryn
callahan
calls
dataflow
dads
sites
effects
li
benchmarks
ken
hall
arrays
expressions
loops
subarrays
sandhya
blas
style
diff
references
optimizing
enddo
atom
loop
compilers
rugina
dad
inline
cdrom
mckinley
linearization
mary
rs
codes
meet
translation
mpi
toplas
ip
subroutines
compilation
referenced
regions
rinard
dwarkadas
manchester
translating
cache
merge
supercomputer
junjie
england
strides
amarasinghe
standardization
editor
caller
scalar
programs
saman
inlining
radu
monica
intersection
scientific
descriptor
mimd
zhiyuan
hoeflinger
paek
flow
merged
suite
sections
precise
convex
merging
mod
bronis
clobber
marathe
jaydeep
chauhan
eggers
blockability
dhruva
supinski
jeremiassen
delinearization
efie
weatherly
telescoping
lowered
abs
perfect
transformations
classical
gu
united
tseng
aug
kd
cooper
july
ayon
rencuzogullari
vectorizing
basumallik
murphy
tushar
reshaped
mckee
reshapes
nakazawa
deficiency
disciplines
intersecting
euler
locations
restructuring
san
else
multiprocessors
programming
hazard
willy
brent
yunheung
eigenmann
chakrabarti
umit
gyungho
yoo
analyzers
zwaenepoel
franklin
sorrento
lo
banerjee
keeping
site
interactive
lam
mueller
hazards
club
rudolf
privatization
inefficiencies
sally
bounds
translated
utility
induction
jose
procedures
translate
liao
regular sections
regular section
section analysis
interprocedural analysis
dependence analysis
side effects
value numbers
supercomputing p
call sites
parallel programming
actual parameter
notices v
sigplan notices
formal parameter
acm sigplan
interprocedural side
access sets
interprocedural propagation
constant propagation
induction variables
meet operation
ken kennedy
dataflow analysis
interprocedural summary
global value
ieee conference
acm ieee
bounded regular
local analysis
atom images
loop induction
summary analysis
summary regular
data access
symbolic analysis
programming style
parascope editor
summary information
array side
call graph
program parallelization
subscript expressions
shared memory
bounds f
meet operations
rice compiler
restricted regular
parallel calls
analysis alone
end algorithm
compiler evaluation
program suite
true access
dependence graphs
interprocedural constant
call site
procedure calls
dependence testing
automatic parallelization
called procedure
corresponding actual
modular programming
return end
distributed shared
algebra subroutines
w hall
access descriptors
mimd distributed
inline expansion
complete applications
side effect
n 7
actual parameters
supercomputing cdrom
cdrom p
distributed memory
systems toplas
toplas v
evaluation program
bounds information
summary sections
referenced section
section subscripts
lo bounds
sections implemented
programming support
compilation dependences
subscript values
stride information
radu rugina
subscript lattice
alone ip
efficient interprocedural
enddo return
rugina martin
summary section
classical interprocedural
scientific disciplines
programming environment
fortran d
memory machines
cache performance
international conference
saman p
interactive parallel
p amarasinghe
parameter array
k lowenthal
direct parallelization
interprocedural array
convex regions
manchester england
invariant expressions
linpack library
sandhya dwarkadas
united states
programming v
recursive programs
call statements
analysis must
junjie gu
mary w
gu zhiyuan
perfect benchmarks
programming languages
regular section analysis
li and yew
conference on supercomputing
sigplan notices v
acm sigplan notices
acm ieee conference
ref a else
interprocedural constant propagation
modular programming style
global value numbers
true access sets
bounded regular sections
rice compiler evaluation
loop induction variables
number of subscripts
languages and systems
n 7 p
distributed shared memory
kathryn s mckinley
data access descriptors
interprocedural side effects
linear algebra subroutines
mimd distributed memory
distributed memory machines
supercomputing cdrom p
number of references
transactions on programming
systems toplas v
journal of parallel
enddo return end
performance of regular
library of linear
restricted regular sections
consistent then ref
parameters and global
evaluation program suite
analysis alone ip
summary regular sections
analysis in linear
compiler evaluation program
radu rugina martin
parallel programming v
data flow analysis
interprocedural side effect
parallelization of call
corresponding actual parameter
saman p amarasinghe
interactive parallel programming
july 11 15
david k lowenthal
memory machines proceedings
array side effects
effects of procedure
using the parascope
analysis for program
gu zhiyuan li
mary w hall
junjie gu zhiyuan
november 07 13
notices v 32
monica s lam
detection of parallelism
side effect analysis
cdrom p 1
software distributed shared
interprocedural dependence analysis
analysis and optimization
notices v 36
san jose ca
parallel and distributed
chauhan ken kennedy
parallelization of numerical
franklin lowenthal dyn
regular sections implemented
complete application codes
jaydeep marathe frank
dependence graphs produced
fast execution time
take time proportional
keeping useful internal
interprocedural analysis alone
range then let
non dedicated clusters
wei liao monica
figure 2 lattice
interprocedural data flow
else let l
jeremiassen susan j
array data flow
regular section subscripts
good programming practice
expense of translating
pointers array indices
r chakrabarti prithviraj
supercomputer performance evaluation
ambitious optimizing compiler
riceps a set

corpus/krapavin2000-test/628151.txt
raid
sid
slice
disk
video
disks
dispersal
sds
fragments
layout
layouts
streams
slices
stream
parity
striping
designs
seek
service
failure
cohort
reading
bibd
movie
fi
buffer
designates
server
stripe
reconstruction
fragment
degraded
fault
mttdl
cycle
redundancy
organization
circa
configuration
rotational
wmin
declustering
consumption
servers
kb
discontiguity
surviving
mpeg
organizations
kilobytes
storage
segmented
configurations
theta
movies
juxtaposed
mbits
sx
starvation
capacity
array
bytes
videos
contiguous
calculations
robin
actuator
latencies
jbod
ozden
inoperative
cylinders
latency
redundant
contiguously
arrays
accesses
burkhard
declustered
failed
clients
shaded
resides
rebuild
reliability
drives
compression
workload
utilizes
mode
cylinder
transfer
ms
rate
nine
failures
ka
tolerant
read
replenishment
berson
discontinuites
stored
archive
diminish
ensemble
grain
track
serviced
ave
buffering
contiguity
staggered
vbr
muntz
balancing
costs
multimedia
offsets
utilize
mb
round
load
cohorts
dmax
alvarez
percent
residing
sec
tolerance
tertiary
designate
display
overflow
gb
groups
technologies
accommodate
cristian
manufacturers
seeks
sized
workloads
cbr
materials
shenoy
impact
continuity
vastly
ten
eleven
width
list
utilized
concurrent
overlay
gracefully
evenly
pi
exclusive
delivery
cycles
accommodated
slots
inevitable
sweep
timely
streaming
poor
portions
composing
migration
slot
wichita
raid 5
service list
raid 3
reading cycle
data layout
per stream
dispersal factor
video server
list s3
sid data
fault free
size fi
data layouts
data fragments
disk failure
cost optimal
disk array
size per
sid design
video servers
data organization
information dispersal
without failure
storage capacity
theta theta
segmented information
sid designs
sds based
single disk
disk 3
buffer size
movie x
based sid
failed disk
list s1
list s7
check data
ffl raid
degraded mode
video stream
disk arrays
consumption rate
sid q
q sid
dispersal sid
failure sid
streams per
data fragment
sid based
slice size
parity groups
redundancy ratio
reading cycles
seek time
redundant data
data organizations
seek latency
video data
per disk
slice y
per reading
parity disk
surviving disks
fi r
video consumption
configuration costs
stream raid
disk failures
optimal designs
sid without
list s2
stripe width
grain striping
check fragments
video slice
system configuration
buffer space
bit rate
k bytes
mbits sec
round robin
row number
rotational latencies
stored contiguously
shaded slice
contiguous data
buffer starvation
sid ffl
case seek
tolerant video
wmin ffl
single failure
five disks
concurrent streams
separated difference
continuity condition
service list s3
buffer size per
size per stream
theta theta theta
segmented information dispersal
service list s7
sds based sid
service list s1
raid 5 data
number of streams
slice is read
sid and raid
raid 3 organization
information dispersal sid
cycle t 1
single disk failure
ffl raid 5
denotes the worst
sid with failure
service list s2
slices are stored
sid without failure
cost optimal designs
sid data layouts
per stream raid
raid 3 data
slice s z
within the raid
per reading cycle
stream raid 5
y of movie
run time performance
number of disks
groups of size
sid ffl raid
list s1 0
slightly larger example
list s2 7
failure theta sid
fault free access
fault free performance
higher dispersal factor
failure sid q
raid 5 sid
video server designs
fault tolerant video
fault free operation
worst case seek
contiguous data layout
fi r c
list s1 1
slice of data
single video stream
list s7 3
track to track
list s3 10
list s7 4
n q sid
sid data layout
cycle t disk0
list s3 6
sid data organization
capacity for video
disk array declustering
typical fault free
list s3 9
list s3 7
failure wmin ffl
streams per disk

corpus/krapavin2000-test/1022634.txt
cage
cages
disk
qudg
chains
sat
realization
quasi
gc
hoc
wire
sensor
chain
ad
embedding
mortar
coordinates
crossing
udg
orientable
drawing
interior
literal
terminals
plane
virtual
clause
wattenhofer
grid
routing
connectivity
directed
hinge
satisfiable
embed
unit
wireless
np
adjacent
terminal
double
euclidean
embedded
mortars
tn
vertex
localization
perimeter
vertices
disks
clauses
impossibility
away
realized
roger
approximability
hop
networks
packing
fabian
breu
directable
ralg
gu
upwards
hooked
kirkpatrick
intersecting
infinity
geographic
packed
lemma
im
inapproximability
moscibroda
capped
capacity
neighboring
cycle
mobile
horizontal
ptas
tw
networking
dist
kuhn
dell
closer
mere
approximation
edge
towards
gd
component
graphs
wires
realizable
erent
located
prominent
hard
transmission
distance
recognition
geometry
neighbors
oriented
west
evolutionary
forces
radius
edges
radio
coordinate
peer
connecting
orientability
goafr
meghanathan
gfg
sirer
saikat
sabhnani
isfiable
lotker
sextant
anycast
gpsr
corrollary
densest
funke
nieberg
ratajczak
katharina
girishkumar
mirjam
manes
zollinger
octagons
amitabh
krller
concretized
giorgetti
pfisterer
south
literals
direction
lemmas
distant
italic
goes
unstable
stefan
internet
ts
ratio
di
geometric
nodes
florida
intractability
north
tends
border
gianni
rohan
fekete
murty
sndor
encircled
emin
approximatively
glaring
squeeze
chasm
circle
usa
imposed
contradiction
assigning
neatly
sedona
gianfranco
regina
nent
lehmann
florence
fulfils
secures
unit disk
disk graph
quasi unit
virtual coordinates
d qudg
d quasi
g sat
grid drawing
disk graphs
ad hoc
directed away
sat c
sensor networks
double chain
single chains
crossing component
directed towards
graph g
np hard
one double
clause component
adjacent cages
defined interior
lemma 3
variable component
r g
approximation ratio
intersecting edges
length 2t
connectivity information
oriented towards
two single
instance c
u v
lower bound
euclidean plane
d 1
d d
quasi udg
directed upwards
literal vertex
good embedding
realization r
cage closer
networks proceedings
multi hop
approximation algorithm
wireless ad
distance 1
hoc networks
geographic routing
embedding r
given unit
roger wattenhofer
dist u
two adjacent
positive literal
n goes
length k
component 3
r c
euclidean distance
mobile ad
nodes u
d 2
neighboring nodes
adjacent cage
two literal
chain vertex
graph gu
fabian kuhn
geometric routing
prominent application
without location
hooked together
ralg g
joint workshop
coordinate information
assigning virtual
graph recognition
usa fabian
unit disks
geometric ad
chain must
clause vertex
horizontal terminals
unstable transmission
robust position
literal components
unit disk graph
quasi unit disk
d quasi unit
hoc and sensor
g sat c
unit disk graphs
d 1 2
disk graph g
qudg with d
two single chains
towards the component
one double chain
well defined interior
d 2 3
drawing of g
finding a realization
two adjacent cages
graph with d
chains or one
lemma 3 4
hard to find
embedding r g
chain is embedded
c is orientable
realization of g
find a realization
component 3 3
coordinates for ad
graph g sat
given unit disk
wireless ad hoc
d and d
ad hoc networks
dist u v
theorem 3 1
goes to infinity
must be directed
sensor networks proceedings
given in 3
mobile ad hoc
u and v
chain between two
recognition is np
ratio of o
sat is satisfiable
non neighboring nodes
realization r g
another impossibility result
breu and kirkpatrick
tn is directed
given a unit
two literal components
instance of 3
modeling ad hoc
robust position based
wire is oriented
assuming w l
usa fabian kuhn
c of 3
construction of gc
foundations of mobile
either the clause
routing without location
terminals are directed

corpus/krapavin2000-test/608045.txt
lossy
channel
channels
nonprimitive
eb
reachability
undecidable
termination
decidable
weakly
decidability
workspace
dke
perfect
tm
nets
polarity
congurations
abdulla
expanders
ackermann
encodings
ack
petri
nite
markers
behaviors
turing
prop
lost
folder
jonsson
finkel
dack
recursive
hs
bisimulation
unreliable
expander
conguration
verication
hq
losses
innite
simulation
automata
letters
consumes
folders
countdown
antonn
schnoebelen
kuera
hardness
undecidability
innitely
tape
equivalences
contents
alphabet
petr
reset
transition
alain
monotonicity
transferring
rabinovich
subword
transfered
writes
primitive
visit
hw
consumed
encoding
faithful
induction
verification
fo
encodes
terminates
visits
inverses
marker
entail
veri
encoded
communicating
fig
proposition
messages
equivalence
faithfully
rst
rotation
simulating
isolate
accepts
resp
hstart
runnings
kuske
giorgio
delzanno
clumsy
subalphabet
irremediably
uncontrived
reworded
ddci
formk
mayr
eventuality
egin
genest
jancar
nomenon
revisits
expansive
shorthands
janar
subrun
meyssonnier
hab
abracadabra
unfaithful
dme
buers
abba
inevitability
verifying
fifo
writing
unbounded
letter
accept
consume
da
asynchronous
lemma
protocols
loops
simulate
entitled
dietrich
slogan
phe
estelle
gadget
amadio
muscholl
notication
higman
blaise
lose
machines
everywhere
quasi
appendix
mode
loop
grard
oneself
anca
faithfulness
tween
nordic
underlining
channel systems
lossy channel
channel c
nonprimitive recursive
c n
channel system
recursive complexity
channels c
c 1
ack n
eb d0e
e n
weakly compute
lossy behaviors
f n
prop 3
lossy systems
shown decidable
decidable problems
primitive recursive
petri nets
one b
one e
one 1
single channel
every w
finite state
nite equivalence
dack n
hq w
weakly computing
undecidable problems
probabilistic lossy
perfect run
perfect step
unreliable channels
several channels
n channel
reset nets
c x
one channel
z times
control state
q n
state systems
turing machine
m using
n e
transition rules
nite state
n k
w j
computation v
contain encodings
accept figure
innite run
recursive time
folder systems
lossy behavior
dke d1e
weakly computes
channels contain
antonn kuera
huge workspace
hence corollary
proof omitted
structured transition
writes back
always write
verication problems
perfect steps
alain finkel
communication information
consumes one
unreliable computations
store auxiliary
perfect channels
systems everywhere
leaving q
bounded workspace
e markers
congurations 0
v 202
allocated workspace
run hs
verifying lossy
improved search
state automata
lossy channel systems
nonprimitive recursive complexity
channel c 1
channels c 1
c n 1
encodings of numbers
systems has nonprimitive
eb d0e eb
induction over n
channel c n
simulation of m
n and f
dack n e
automata that communicate
abdulla and jonsson
contains one b
prop 3 2
proof of prop
termination and reachability
c 1 contains
reachability for lossy
encodes a number
termination for lossy
decidable for lossy
probabilistic lossy channel
information and computation
b and one
ackermann s function
lemma a 1
c x c
x c x
theorem 2 3
hard as termination
termination for tm
improved search strategy
nite state automata
v 202 n
structured transition systems
isolate the congurations
letters and writes
w i contains
systems that weakly
e then every
primitive recursive time
verifying lossy channel
nets between decidability
decidable in aj96b
beyond the allocated
problem for petri
dke d1e d0e
inverses a 1
rule q c
well structured transition
channels contain encodings
simulation and bisimulation
l a n
accepts in space
reasoning about probabilistic
consumes one 1
following formal sense
contents of channel
transition systems everywhere
channels c 2
equivalences for lossy
contents of c
eb d0e d1e
m with huge
m is simulated
systems have nonprimitive
m using c
expander e n
infinite state systems
bisimulation between lossy
control state reachability
hence corollary 4
ack n steps

corpus/krapavin2000-test/1008135.txt
cgls
lanczos
multishift
attainable
recurrences
alg
krylov
residual
cg
shifted
squares
conjugate
iterates
tridiagonal
rounding
precision
perturbation
gradient
matrix
residuals
roundo
accuracy
subspace
erence
errors
recurrence
perturbed
arithmetic
paige
tikhonov
damped
quantities
qmr
di
orthonormal
norm
coupled
ill
numerical
proposition
inversion
diagonal
greenbaum
conditioned
vectors
roundoff
cients
coe
regularization
factorized
recursions
dstqds
chromodynamics
normwise
quantity
erences
floating
scaling
stagnates
orthogonalization
utrecht
qd
restarted
quantum
picture
bidiagonal
phillips
ingredient
shift
ax
products
eigenvalues
dash
gmres
dl
summarized
computations
families
implementations
iterate
stable
ects
error
vector
impact
shifts
mathematically
symmetric
cult
proposals
consult
influence
ciently
forward
ingredients
cancellation
iterations
perturbations
orthogonal
overwhelming
eigenvector
columns
convenience
accurate
cient
confirm
solving
argued
lemma
mr
attain
expression
subspaces
bold
norms
euclidean
exact
attained
elfving
foxgood
lscg
modynamics
ursell
stroke
colinear
tridiagonalizing
algorithmus
chro
quotienten
erenzen
eshof
quark
financially
strako
capitals
insight
minus
stability
contribution
alternative
monotonically
ultimate
characters
factorization
relations
definite
eventually
inequality
orck
rences
stiefel
bidiagonalization
sylvester
dhillon
parlett
rutishauser
hestenes
dot
band
zeros
bounding
gap
su
variants
formulation
guess
unconventional
masses
warn
canceled
precisions
outlook
inspection
stress
plays
variant
tries
inner
stationary
dotted
cf
celebrated
arnoldi
countless
bicgstab
approximations
lattice
outcome
thankful
positivity
erential
nwo
dutch
dashed
multiplying
cgls method
multishift cgls
lanczos method
lanczos part
attainable accuracy
cgls lanczos
least squares
cg method
conjugate gradient
standard lanczos
krylov subspace
shifted systems
finite precision
alg 1
cgls recurrences
rounding errors
lanczos relation
gradient method
precision computations
alg 2
tridiagonal matrix
squares problems
shifted system
alternative lanczos
forward error
squares problem
linear systems
computer arithmetic
shifted linear
true residual
method based
di erence
starting vector
damped least
perturbed lanczos
w vectors
inversion part
perturbation term
numerical experiments
relative error
method applied
two term
coupled two
condition number
w 3
term recurrence
w 1
stable method
qmr method
squares residual
coupled recurrences
matrix vector
proposition 2
ill conditioned
exact arithmetic
lanczos vectors
normal equations
orthogonal basis
roundo errors
term recurrences
r k
three term
errors made
relatively close
orthonormal basis
error analysis
cg type
x cgls
multishift version
cgls methods
vector updates
multishift versions
lanczos process
future convenience
exact conjugate
diagonal elements
r j
special structure
vector w
direct application
lanczos type
b ax
residuals r
recurrence relations
subspace k
residual gap
g 12
coe cients
approximate solution
side b
mathematically equivalent
previous proposals
factorized form
abstract formulation
right hand
point arithmetic
hand side
vector product
inner products
floating point
v k
key ingredient
di erences
type methods
test problems
multishift cgls method
cgls lanczos method
standard lanczos method
conjugate gradient method
cgls method based
least squares problems
shifted linear systems
least squares problem
finite precision computations
damped least squares
matrix t k
contribution of w
based on coupled
coupled two term
least squares residual
vector w 3
two term recurrences
proposition 2 1
three term recurrence
exact conjugate gradient
multishift cgls methods
rounding errors made
recurrences in 2
hand side b
cg type methods
matrix s k
applying the cgls
influence of rounding
lemma 4 1
right hand side
e g 12
j 1 6
floating point arithmetic
krylov subspace k
given in 4
matrix vector product
solving linear systems
j a b

corpus/krapavin2000-test/628464.txt
polar
retinal
optical
sensor
velocity
fovea
motion
camera
ae
ccd
cortical
radial
flow
impact
sin
image
rotational
tracking
oe
plane
visual
retina
fl
images
translational
gaze
wz
variances
egomotion
cartesian
fixation
foe
log
vision
derivatives
coordinate
scene
mapping
derivative
obstacles
acquired
equations
pixels
resolution
focal
eccentricity
fig
sampling
navigation
field
angular
sandini
sensors
divergence
angles
velocities
raster
axis
variance
anthropomorphic
estimation
coordinates
hazard
wx
ego
conformal
periphery
motor
motors
depth
movements
moving
observer
rotation
cos
retino
dialation
foveal
avaliable
foveated
receptors
usefulf
logarithmic
squares
sampled
rotations
attention
variant
effector
efficently
burlina
analysing
amplitude
sensing
concentric
rama
chellappa
fabrication
equation
hi
autonomous
monocular
abundance
conventional
scenes
devices
relate
performances
transformation
pointed
robot
recover
advantages
object
humans
geometry
centered
imaging
prototype
stabilized
animals
uncorrelated
neighbouring
feb
formulations
translation
noting
spatial
estimated
spherical
vital
cameras
circular
pixel
qualitative
position
straight
differentiating
rotates
driving
certainly
active
substituting
processed
recognition
conducted
worth
motions
mandatory
unitary
greatest
frames
formulation
trajectory
intelligence
expansion
stereo
filiberto
capurro
dinates
analogic
buit
chalimbaud
pelegrn
foeva
boluda
fabin
prey
gratefull
undertaking
gerdes
yehezkel
camacho
fixated
rosenfeld
ballard
altamirano
corridors
panerai
aeof
analitically
direcition
rotstein
parabola
konrad
donoghue
visuo
applyed
traver
meaurement
tagliasco
optical flow
log polar
polar mapping
sin fl
oe sin
log e
retinal plane
ae ae
space variant
ccd sensor
radial component
f oe
w z
z log
cortical plane
retinal sensor
retina like
radial coordinate
z w
rotational angles
polar transformation
retinal velocity
tracking egomotion
retinal image
equation 25
partial derivatives
ae z
motion equations
optical axis
general motion
visual navigation
focal length
z ae
cartesian coordinate
fixation point
like sensor
visual field
visual sensor
polar representation
retinal ccd
polar images
fl log
velocity field
equation 31
coordinate system
tracking motion
equation 33
data reduction
parameters involved
rotational velocity
cortical projection
flow equations
system centered
active tracking
sampling structure
z oe
inverse time
z wz
hi wx
sensitive elements
ae hi
variant sampling
ae plane
angular component
logarithmic mapping
wz z
coordinate ae
polar plane
translational flow
conventional raster
cartesian plane
translational component
obtain z
z f
computer vision
two equations
ae log
ae f
obtain ae
variances oe
image velocity
order partial
image plane
least squares
high resolution
independently moving
active vision
f ae
conformal mapping
object motion
equation 27
time to impact
log polar mapping
oe sin fl
focus of attention
polar and log
f oe sin
z w z
z log e
compute the time
log a e
direction of gaze
log polar transformation
w z log
e a f
cartesian coordinate system
ae ae ae
sin fl log
along the radial
e a gamma
retina like sensor
retinal ccd sensor
radial coordinate ae
z f oe
space variant sampling
obtain z w
log polar images
component of velocity
ae z oe
w z z
polar or log
case of tracking
optical flow equations
radial and angular
ae oe sin
z oe sin
ae hi wx
flow in fig
independently moving objects
computed by applying
z ae ae
field of view
estimate the time
amount of information
transactions on pattern
analysis and machine
machine intelligence v
shown in fig
sampling structure characterized
combining this equation
f oe cos
abundance of equations

corpus/krapavin2000-test/627416.txt
articulator
meta
agent
agents
software
organizational
mary
joe
behavioral
collective
team
tasks
resources
spsl
articulation
trajectory
company
resource
action
skill
agenda
follower
accommodation
foo
task
query
development
actions
web
prescriptive
simulation
history
activities
workplace
processes
manager
queries
schema
prescription
specification
entity
managers
acquisition
fugini
bellettini
scacchi
rights
teams
simulator
developers
slot
conflicts
situations
plans
project
peter
consumed
infrastructure
skills
controller
attributes
hierarchy
period
finish
simulating
manipulate
fifs
lamppost
timen
peiwei
object
entities
organizations
settings
users
negotiation
engineering
strategic
empirical
tosem
efforts
metamodel
walt
faceted
condensed
unexpected
operators
document
slots
preconditions
architecture
mi
modeling
interactions
offices
spec
procedural
developer
possession
performers
infrastructures
force
linking
legend
interrelated
production
deductive
symbolic
synchronization
circles
plan
relations
subtask
articulated
authorized
people
instantiation
reasoning
stores
recorded
mechanism
interface
conflict
ie
facilities
emerges
manipulation
mechanisms
chaining
behaviors
products
resolved
individual
subclass
planned
customized
status
assigned
super
objects
social
idle
planning
querying
simulated
manipulated
retrieve
projects
exchange
validating
schematic
primary
schedule
subsystems
assist
automating
toronto
strategy
kb
configured
selects
minable
damiani
articulate
conceptualized
madhavji
oivo
prototyped
reiterates
ishys
explorerii
teamwork
statics
wileden
osterweil
affiliated
molgen
toubache
software process
meta model
task performance
articulator meta
process models
meta knowledge
company f
query mechanism
process model
software processes
behavioral simulation
software development
task space
define object
task execution
software engineering
design foo
domain space
architecture design
process modeling
collective agent
performance skill
engineering processes
knowledge acquisition
task force
many many
history query
process meta
knowledge base
acquisition manager
strategy space
information query
develop data
development activities
mary joe
behavioral simulator
detail design
symbolic execution
schema name
two agents
task decomposition
knowledge query
current action
task specification
new state
open systems
multi agent
outside world
one many
organizational settings
project managers
members mary
manipulation power
space stores
many 1
history queries
acquisition query
primary tasks
meta actions
information queries
relations linking
chain task
agent task
accommodation strategy
instantiation manager
g fugini
work assignment
p model
meta reasoning
q relation
collective tasks
task hierarchy
collective task
force assigned
instance schema
c slot
behavior simulator
meta tasks
process researchers
c bellettini
organizational work
perform tasks
agent controller
joe define
knowledge representation
data representation
time n
agent may
development projects
unexpected events
task chain
software design
individual task
object based
system interface
another task
problem solving
information access
resource requirements
subsystem interface
articulator meta model
software process models
software process model
resources and situations
web of resources
software process modeling
task performance skill
software engineering processes
model of software
software process meta
process meta model
mary and joe
agent s task
knowledge acquisition manager
assigned to mary
meta knowledge query
chain task force
joe define object
file to peter
knowledge acquisition query
task chain task
develop data representation
definition of meta
task force assigned
modeling and simulating
software development projects
acquisition query mechanism
individual task performance
individual in collective
assigned to agent
model the software
instance schema name
period of time
agent s ability
agent s behavior
types of software
software development process
transactions on software
methodology tosem v
engineering and methodology
rights of task
hierarchy of task
finish one fifs
approach to faceted
task design foo
consumed or produced
specification an object
modeling a behavioral
rights of information
meta model consists
methods and procedures
simulator the query
environment for modeling
members mary joe
agents an agent
agent software processes
multi agent process
agents and tasks
software maintenance work
software process researchers
slots c slot
fugini c bellettini
processes are software
define object meta
types of agents
meta model individual
case words reserved
force has follower
new value agent
oriented components acm
task performance skills
knowledge engineering environment
query mechanism knowledge
understanding software maintenance
state through continuous

corpus/krapavin2000-test/629444.txt
supernode
supernodes
hyperplanes
grain
schedule
tiling
ct
shape
dependence
startup
parallelepiped
koziris
nectarios
transformation
partitioning
athanasaki
phases
transferred
dependences
lengths
loops
communication
georgios
matrix
hyperplane
tile
processors
running
sotiropoulos
goumas
processor
nested
index
vectors
iteration
tiled
volume
maria
iterations
loop
nests
cone
fronts
aristidis
tsoukalas
luce
transmission
square
discusses
message
transformations
tsanakas
drosinos
panayiotis
cutting
smps
extreme
nikolaos
nonlinear
pipelined
penalty
theta
hypercube
systolic
hd
comm
grouping
scheduling
doubly
oe
wave
closed
comp
jingling
rajopadhye
disp
rashmi
hyperrectangular
dharma
balev
papakonstantinou
hodzic
multicom
wentong
hyperrectangles
andonov
campbell
lsgp
yanev
edin
planes
vector
hyper
affine
boothe
weijia
startups
dimensionalities
clare
abstractwith
nitions
professorship
convex
sides
minimized
media
multiprocessors
bajaj
crete
triolet
hal
sliced
supercomputing
spaces
schedules
messages
ramanujam
dencies
defi
respected
sadayappan
irigoin
gt
peizong
transputer
xue
doacross
rectangular
multidimensional
side
henry
zvi
supercompilers
pen
dell
mapped
families
uniform
depen
jersey
oblique
kedem
island
greece
grouped
sizes
columns
shang
puters
nicosia
collinear
thirteenth
reasonably
transmitted
transformed
phase
interdependent
assistant
meir
lemmas
neighboring
subtasks
equidistant
alternates
analytical
formulation
modeled
ave
integral
rank
cai
cyprus
baltimore
minimizing
approximated
dependencies
initiation
orthogonal
normal
bg
supernode size
supernode transformation
total running
grain size
optimal supernode
linear schedule
index space
running time
optimal grain
length vector
side lengths
supernode index
iteration index
relative side
supernode shape
dependence matrix
supernode relative
dependence vectors
different supernode
parameter model
relative length
parameter communication
optimal linear
one parameter
partitioning hyperplanes
supernode sizes
two parameter
supernode transformations
schedule vector
optimal relative
size g
computation phases
parallelepiped supernode
communication model
h r
communication time
algorithm j
communication phases
nectarios koziris
nested loops
side length
j d
startup penalty
two supernode
transformation h
matrix h
matrix d
vector r
closed form
supernode partitioning
one supernode
maria athanasaki
square supernode
startup cost
communication startup
communication cost
g o
r g
index set
bounded loop
resulting supernode
n partitioning
nonlinear program
supernode grain
memory parallel
communication phase
iteration space
consider algorithm
transformed algorithm
optimal shape
supernode side
hyperplane matrix
dimensional algorithm
convex cone
constant bounded
ct ct
l processors
space j
g r
distributed memory
single processor
processors time
tile size
form expression
theta theta
v g
communication volume
schedule length
computation time
loop nests
set j
scheduling length
dependences 12
size shape
independent supernodes
components depend
four iterations
affine function
g ct
wave fronts
changes lemma
schedule wave
containing four
loops onto
normal vectors
nested loop
real positive
optimal tile
startup time
sotiropoulos georgios
athanasaki aristidis
tiled nested
parallelepiped supernodes
georgios goumas
tsoukalas nectarios
drosinos maria
athanasaki nectarios
uniform dependence
square containing
parameters h
extreme vectors
supernode volume
aristidis sotiropoulos
constant communication
algorithm problems
total running time
optimal grain size
optimal supernode size
size and shape
iteration index space
optimal linear schedule
parameter communication model
relative length vector
supernode index space
j s d
h r g
side length vector
amount of data
find the optimal
transformation h r
relative side length
supernode transformation h
length vector r
different supernode sizes
one parameter model
optimal relative length
grain size g
one parameter communication
find an optimal
linear schedule vector
communication startup cost
relative side lengths
dependence matrix d
supernode relative side
algorithm j d
distributed memory parallel
h and r
number of communication
problem of finding
square supernode shape
two parameter model
two parameter communication
two supernode transformations
v g r
l processors time
supernode index set
constant bounded loop
model with constant
optimal supernode shape
optimal supernode relative
index set j
closed form expression
finding an optimal
time for different
number of phases
memory parallel computer
d 2 d
g g o
linear schedule wave
set with g
model communication cost
supernode transformation applied
square containing four
bounded loop iteration
shape the total
supernode grain size
schedule wave fronts
supernode size changes
supernode size g
components of dependence
vectors d 2
shape or close
change as supernode
changes lemma 3
cost is modeled
size and supernode
algorithm in example
h g r
n partitioning hyperplanes
close to square
constant communication time
supernode the supernode
supernode relative length

corpus/krapavin2000-test/614371.txt
isosurface
cells
dataset
cell
unstructured
datasets
intervals
extraction
active
interval
isovalue
visualization
coherence
marching
chess
black
volume
dr
hash
tetrahedra
vertex
vertices
normals
bluntfin
grids
board
isosurfaces
white
fighter
surface
visited
tetrahedral
speedup
tree
span
structured
cubes
mesh
graphics
facets
cthead
seed
extremes
bajaj
strip
gridded
gradients
hexahedra
occupancy
prisms
forest
overhead
big
auxiliary
lists
intersected
pyramids
discriminant
traversal
sigma
seeds
bucky
unstr
tmin
connectivity
field
chandrajit
livnat
edelsbrunner
exploit
adjacencies
rendering
trees
array
shen
lying
adopting
scanned
query
storage
wilhelms
grid
iso
october
layers
adjacent
edges
encoded
flag
redundant
curvilinear
gelder
interpolation
addressing
bong
sohn
siddavanahalli
normal
efficiency
regular
courtesy
hansen
advancing
hexahedral
nasa
traversed
arrays
extracted
han
sorted
fig
adopted
fitting
deepest
itoh
isocontouring
pascucci
individuate
exploiting
oe
implicit
edge
stored
tradeoff
interpolated
propagation
ffi
layer
san
storing
accelerated
indexes
sutton
isosurfacing
vinay
tmax
isovalues
thinning
soo
3d
interactive
triangular
arrangement
spans
subdivision
classification
redundancy
ertl
warrant
langley
haimes
ascending
collisions
indices
arc
patches
conceptual
traverse
octrees
stripe
dashed
spanned
scalar
california
backward
node
triangles
triangulated
playback
octree
finkelstein
list
march
wei
united
charles
gradient
depth
lutz
celebrating
sector
bare
sectors
massachusetts
irregular
boston
francisco
adam
chiang
optimally
meshes
searched
timing
jen
coordinates
interval tree
isosurface extraction
active cells
local coherence
white cells
black cell
march 7
black cells
unstructured datasets
chess board
isovalue q
range based
structured datasets
span space
interval trees
data structure
marching cubes
board approach
cell selection
q 0
tree data
hash table
cell classification
unstructured grids
ffi r
vertex normal
active intervals
storage cost
based methods
normal data
volume data
active cell
input mesh
active white
query value
isosurface vertices
global coherence
seed set
active black
value q
active list
computer graphics
space based
auxiliary structures
found move
cell oe
exploit local
connectivity list
dr lists
dr list
big al
surface normal
memory overhead
graphics v
isosurface facets
search structure
active edges
varying fields
auxiliary data
surface based
memory requirements
tetrahedral cells
normal computations
livnat et
edelsbrunner 5
visited recursively
memory words
unstructured case
big dr
branching node
hash indexing
adjacent white
white cell
structured ones
standard marching
range domain
conceptual organization
graphics october
extraction process
time varying
time efficiency
volume visualization
oe j
volume dataset
marching tetrahedra
regular dataset
new conceptual
optimally efficient
active edge
march 7 1997
interval tree data
chess board approach
case of unstructured
range based methods
case of structured
vertices and normals
vertex normal data
al and dr
active at q
number of cells
conference on visualization
structured and unstructured
normal data structure
active white cells
number of intervals
tree data structure
vertex and normal
active black cell
tree data structures
exploit local coherence
coherence between isosurfaces
query value q
computer graphics v
visualization and computer
transactions on visualization
visualization and graphics
auxiliary data structure
time varying fields
q and q
forest of interval
proposed by edelsbrunner
livnat et al
hash indexing technique
efficiency and memory
else while intervals
order to speedup
surface based methods
isovalue q 0
lists of type
wilhelms and van
new conceptual organization
list of cells
using an interval
given an isovalue
computation of surface
extraction in time
han wei shen

corpus/krapavin2000-test/608654.txt
agent
gaia
agents
roles
responsibilities
permissions
customer
liveness
quote
multiagent
coffeefiller
coffee
autonomous
customerrequirements
role
acquaintance
organisation
customerdetails
quotemanager
methodologies
safety
kgr
creditrating
bologna
service
oo
protocols
activities
services
serviceislegal
bespoke
joint
interaction
coffeestock
checkstock
methodology
oriented
modelling
schema
qm
dignum
mylopoulos
costing
coffeestatus
awaitempty
informworkers
customerhandler
realise
organisations
protocol
supplied
nil
organisational
costbespokeservice
vetcustomer
coffeemaker
checkservicelegality
servicetype
csd
italy
melbourne
interactions
mas
president
bdi
vetting
giorgini
getcustomerrequirements
customervetter
intelligent
fill
organizational
madrid
jennings
stock
multi
software
business
ffl
rating
engineering
wooldridge
activity
society
paolo
individuals
australia
concrete
company
concepts
elaborating
fredrik
arnon
tropos
enacting
coffeemachine
onn
costservice
continuationdecision
pot
gandon
wernstedt
davidsson
karageorgos
institutionalised
corrado
mehandjiev
archon
perini
shehory
kinny
dmars
pathways
quebec
july
carrying
development
sigsoft
juan
micro
wic
credit
fabien
legality
santoro
workers
sturm
nikolay
premature
summarised
initiator
annotation
commerce
montreal
maker
antonella
cust
fipa
behaviour
organizations
commitment
dd
specification
fifth
fusion
inheritance
elaborated
giunchiglia
fausto
notes
permission
achievement
rights
vladimir
dai
reads
production
simon
article
abstract
resources
goals
auction
schemata
anna
spain
intelligence
behaviours
departments
ao
responsibility
abstraction
reiko
emiliano
societal
networkdesigner
vet
kolp
pavn
brewed
customeragent
vettingresponse
vzquez
sierra
prabhat
giverequirements
padgham
conceptions
carles
shatz
legalcheckrequest
holvoet
depke
returncosting
konushy
aose
winikoff
zambonelli
multi agent
agent oriented
agent systems
autonomous agents
multiagent systems
agent based
international joint
agent system
joint conference
agent types
agent model
software engineering
roles model
acquaintance model
systems part
bologna italy
july 15
oriented analysis
responsibilities liveness
role schema
first international
services model
agent type
coffeefiller role
liveness properties
reads supplied
design process
part 1
permissions reads
liveness expression
kgr approach
liveness responsibilities
analysis stage
interaction model
systems july
modelling techniques
july 14
business process
quotemanager role
informworkers checkstock
liveness expressions
john mylopoulos
stock level
liveness safety
oo methodologies
gaia methodology
computing march
safety properties
based system
agent technology
second international
applied computing
systems v
credit rating
systems proceedings
melbourne australia
fifth international
object oriented
engineering review
run time
checkstock awaitempty
oriented development
supplied customerrequirements
quote nil
paolo giorgini
fusion 6
frank dignum
oriented methodologies
oo modelling
coffee machine
agent carrying
role coffeefiller
concrete concepts
role might
intelligent agent
oriented software
madrid spain
distributed artificial
safety figure
interaction models
knowledge engineering
acm symposium
open systems
december 18
protocol definition
notes v
sigsoft software
engineering notes
information systems
montreal quebec
agent communication
acm sigsoft
electronic commerce
agents p
quebec canada
based systems
software development
agent instances
coffeestock stock
corporate semantic
agent classes
customerrequirements quote
analysis and design
multi agent systems
conference on autonomous
international joint conference
agents and multiagent
multi agent system
protocols and activities
first international joint
multiagent systems part
july 15 19
agent based system
agent systems v
agents and multi
part 1 july
systems part 1
schema for role
design of agent
permissions reads supplied
agent oriented analysis
july 14 18
systems july 14
second international joint
multiagent systems july
agent oriented software
symposium on applied
applied computing march
responsibilities liveness safety
methodology for agent
customer is satisfactory
agent based systems
knowledge engineering review
engineering review v
full or empty
informworkers checkstock awaitempty
oo modelling techniques
agent systems proceedings
oriented software engineering
distributed artificial intelligence
n 3 p
intelligent agent technology
agent technology p
conference on intelligent
december 18 22
may 2001 montreal
engineering notes v
acm sigsoft software
sigsoft software engineering
software engineering notes
march 11 14
montreal quebec canada
fifth international conference
computing march 11
run time system
autonomous agents p
n 2 p
wic acm international
ieee wic acm
relationships between agents
jennings and kinny
changes coffeestock stock
customer contact information
empty changes coffeestock
paul davidsson fredrik
coffeestock stock level
supplied customerdetails customer
level of coffee
customerdetails customer contact
giunchiglia john mylopoulos
object oriented analysis
antonella di stefano
liveness safety ffl
design of multi
abstract and concrete
modelling and design
safety ffl true
reads supplied customerdetails
agent oriented development
business process management
davidsson fredrik wernstedt
liveness and safety
corporate semantic web
ffl true figure
fausto giunchiglia john
agent oriented methodologies

corpus/krapavin2000-test/627846.txt
dql
default
query
defaults
datalog
companies
credulous
queries
barilla
valuation
expressive
saiwa
company
eiter
logic
qdql
cadoli
database
stable
recognizable
boolean
skeptical
strategic
rst
eter
gottlob
ice
diagnostic
cf
tuple
propositional
semantics
mary
relational
melts
frutto
fuses
hd
electric
trust
facts
abductive
oce
normal
np
theories
tuples
bulb
diagnosis
circuit
predicates
eects
troubleshooting
explanation
denable
prog
comp
ground
denes
computable
strat
databases
jw
expressiveness
specic
languages
sentence
sue
producers
sold
mgr
denition
existential
extensional
language
polynomial
fragment
resistors
pacist
mbd
nmr
resistor
seminormal
fbarilla
recognizability
aul
relations
formula
inst
leone
disjunctive
schemata
sell
xed
semi
fragments
instantiation
rules
reasoning
products
monotonic
deciding
melting
wine
brave
background
nite
nicola
atom
wrt
belongs
dened
answer
predicate
negation
pfeifer
atoms
vi
extension
explanations
subclass
intensional
causes
paul
married
battery
light
yes
schema
cautious
oracle
collapse
expressible
rela
satised
nc
entailment
cont
fuse
saiwag
nies
melted
ew
quaker
oces
compa
fbulb
adults
amperage
pasta
noncollapsing
formalisms
arity
gerald
reiter
quantier
agreements
resistance
gd
power
prerequisite
voltage
pspace
universe
captures
extensions
managers
nonmonotonic
satises
formulas
informatica
symptom
observa
melt
conjectured
express
hypotheses
false
broken
exp
meaning
intuitive
continued
remark
exceptional
dlv
faber
republican
scarcello
malfunctioning
perri
simona
greco
roma
capture
ex
symbols
inclusion
observations
default logic
default theory
dql queries
query language
o query
expressive power
boolean dql
q dql
datalog stable
normal dql
database instance
semi normal
p recognizable
instance w
boolean query
default rules
query languages
hd w
dql query
normal default
open defaults
p eter
default theories
query q
gottlob default
queries precisely
default query
precisely capture
maximal trust
cadoli eiter
o ice
rst order
q q
class p
order logic
relational databases
o queries
small o
background knowledge
queries computable
q w
boolean queries
intuitive meaning
polynomial time
rst tuple
database query
electric circuit
comp w
language dql
credulous default
complexity class
order queries
fact f
p 2
second order
database instances
last tuple
credulous semantics
logic programming
minimal sets
skeptical semantics
non monotonic
logic programs
query qdql
abductive diagnosis
ground formula
existential universal
credulous dql
queries denable
strategic companies
control light
p dql
relation instance
default semantics
relation schemata
propositional default
b 0
polynomial hierarchy
complexity classes
z 0
b d
stable models
output relation
relevant facts
database w
diagnostic problem
one extension
schema r
extensional relations
q 00
combined complexity
cf 23
possible causes
data complexity
section vi
function free
thomas eiter
theorem 1
output relations
nicola leone
q p
q q dql
extension of q
capture the class
dql i o
dql queries precisely
queries precisely capture
gottlob default logic
small o ice
second order logic
fragment of second
eiter and gottlob
expressed in dql
produce all products
barilla and saiwa
class p 2
default in d
query language dql
boolean dql queries
boolean dql query
normal dql queries
power of dql
database instance w
z a b
normal default theories
o query q
relational database query
based on default
default query language
normal and semi
fragments of default
complexity of dql
sets of companies
credulous default semantics
follows from q
q p dql
tuple in 0
companies that produce
semi normal default
first order queries
database query languages
computable in polynomial
queries first order
concludes the part
p recognizable queries
ex p eter
p eter ex
ice p eter
denition of extension
q is dened
pair b d
causes and eects
query q q
semantics of dql
open defaults d
company is strategic
plus a set
query is p
captures the class
existential universal fragment
battery s voltage
background knowledge b
follows the background
model based diagnosis
rst order formulas
defaults in d
eter ex p
theory hd w
polynomial time queries
w of r
fixed point queries
o ice p
dql is p
logic this result
default theory hd
class of p

corpus/krapavin2000-test/1017478.txt
plugin
haskell
plugins
ghc
loader
loading
api
plugs
ghci
runtime
library
edsl
pdynload
edsls
interface
file
rsrc
module
host
parser
dsl
compilation
compiled
dynload
apitypeconstraint
stringprocessor
load
safe
linking
typing
loaded
import
stringprocplugin
languages
safety
libraries
polymorphic
emacs
stub
pantheon
typed
files
compiler
infrastructure
string
dsls
stringprocapi
obj
syntax
dynamic
resource
dynamically
configuration
pan
checker
dynamics
lightweight
unsafe
foreign
staged
hs
fromdynamic
python
putstrln
compiling
invoking
manager
err
scripting
language
symbol
object
expects
checksum
hi
statically
compile
hooks
reload
jvm
linker
package
interpreter
unchecked
circlereg
irc
hmake
hep
checking
dependencies
loads
code
ui
declarations
interactive
source
eval
plication
existential
exported
trust
glasgow
circle
export
num
typeable
reloading
marshalling
named
parse
loaders
chasing
attribution
ast
dependency
ty
monad
caml
clean
inference
lisp
modules
embedded
parsers
animc
recompile
typecheck
incs
circleanim
writeout
plu
newtyconstraint
dlopen
yampa
mailconfigapi
impulses
session
ffi
animations
extensible
evaluator
temporary
ml
enables
slider
pkgs
frac
usr
caller
char
client
java
extension
wrap
plug
animation
generics
prompt
estonia
andersson
tallinn
tmp
bool
native
strings
author
applica
internally
luckily
str
apis
crash
int
functionality
cast
resolving
sigplan
shell
forall
snowbird
displaying
functional
ap
mod
arranges
advocate
music
radius
enabling
invokes
implements
name
dirac
transparently
flags
gui
default
dynamic loader
host application
dynamic types
extension language
plugin library
dynamic typing
haskell plugins
plugin source
type safety
dynamic loading
extension languages
interface file
object code
type checking
dynamic type
compilation manager
plugin infrastructure
type safe
api interface
runtime system
domain specific
source code
type checker
haskell source
staged type
configuration file
specific languages
type information
type inference
object file
objective c
hi file
existential types
apitypeconstraint module
runtime type
object files
type dynamic
haskell compiler
interface files
dynamically loaded
stringprocplugin done
interactive haskell
haskell code
haskell value
plugin resource
plugin api
plugin code
plugin interface
error messages
user input
dynamically typed
dynamic linking
interface interface
embedded languages
source file
full type
type check
data interface
abstract syntax
c program
statically typed
configuration files
host language
application author
load obj
haskell interpreter
plugins using
plugin author
perform type
loaded plugins
interface hi
export list
loading package
package base
linking done
lightweight parser
haskell parser
following plugin
embedded domain
using haskell
code plugins
mod rsrc
function named
temporary module
c string
done loading
haskell p
external process
module name
typed extension
runtime compilation
unchecked load
hs plugins
invokes ghc
invoking ghc
infrastructure library
safe plugins
dynamics implementation
haskell plugin
haskell environment
safe dynamic
polymorphic values
hs eval
function interface
base linking
type system
using dynamic
polymorphic languages
separate compilation
staged type inference
domain specific languages
runtime type checking
haskell source file
make and load
using dynamic types
data interface interface
plugins in haskell
form of dynamic
plugin s interface
via the ffi
ghc s dynamic
interface hi file
loading the plugin
application and plugin
plugin infrastructure library
resource where import
loading package base
written in haskell
c and objective
type safe dynamic
base linking done
type safe plugins
package base linking
typed extension language
compiling and loading
embedded domain specific
foreign function interface
workshop on haskell
glasgow haskell compiler
file i o
java virtual machine
discuss the use
acm sigplan workshop
ghc base string
obtains a handle
compiled and loaded
standard dynamics library
statically typed extension
correct symbol name
emacs the extensible
building domain specific
interactive haskell environment
differentiation with dirac
v load obj
module and library
expression plugin resource
haskell and xml
functions from continuous
using haskell plugins
load a plugin
haskell is used
generics and dynamics
type checking using
use the plugin
plugins using dynamic
application configuration files
ad hoc language
parts of ghc
ghc s recent
user friendly edsls
sort 7 3
ghc runtime system
generate a plugin
haskell execution platform
loop mod rsrc
host applica tion
plugin s functions
dynamically loaded plugins
haskell runtime system
dynamically checked plugins
plugin resource api
plugin s source

corpus/krapavin2000-test/628884.txt
lighting
harmonics
harmonic
images
reflectance
lambertian
sphere
albedo
light
surface
reflectances
subspace
recognition
illuminated
normals
image
9d
energy
illumination
convolution
hnm
spherical
shashua
kernel
pca
dz
intensity
georghides
albedos
4d
belhumeur
coefficients
lights
3d
cosine
pose
shadows
spanned
oe
amplitude
kriegman
face
scaled
dc
nine
reflection
kba
hecke
zonal
funk
object
delta
diffuse
nm
sin
gamman
approximation
analytically
lambert
negative
pixels
koenderink
qr
doorn
cone
analytic
approximated
faces
zmura
ramamoorthi
ik
photometric
analog
enforce
vision
epstein
negativity
specularities
cos
rendering
distant
rendered
convex
basri
moses
ck
tog
isotropic
reflected
specular
rotationally
normal
theta
squared
intensities
subspaces
bidirectional
pixel
doe
amplitudes
blicher
subsample
hanrahan
brdfs
pnm
hallinan
dobashi
coefficient
accuracy
dimensional
captured
realizable
matlab
angle
approximations
brdf
7d
physically
transform
1d
yuille
longitude
legendre
poles
illuminate
lagrange
graphics
2d
fourier
projecting
squares
unscaled
convolutions
latitude
roc
coordinate
coordinates
van
stereo
cast
orthonormal
linearity
rearrangement
polynomials
exponent
variations
render
materials
accurately
recognizing
varies
jacobs
pole
enforcing
svd
everywhere
fourth
half
objects
facing
suggestion
angles
appearance
matrix
mike
scattering
integral
visible
human
integrating
bad
law
basis
choi
six
shading
ambient
ravi
inverting
arbitrarily
generative
multiplier
approximates
source
inherits
saturated
direction
projection
frequency
near
constraint
produced
shape
varying
basis images
harmonic images
reflectance function
linear subspace
non negative
lighting conditions
surface normal
order approximation
spherical harmonics
negative lighting
low dimensional
point source
surface normals
reflectance functions
harmonic basis
delta functions
lambertian kernel
dc component
lighting function
dimensional linear
delta function
gamma ik
negative combination
half cosine
9d space
georghides et
harmonic reflectances
order harmonic
space spanned
n gamma2
first order
cosine function
four harmonics
m gamman
images produced
energy captured
lambertian reflectance
kriegman 1
negative light
order harmonics
lambertian object
harmonic transform
space coordinates
normals scaled
linear space
face recognition
theta r
first nine
low order
n x
9d linear
object illuminated
illumination cone
b nm
bidirectional reflection
sin d
dz n
recognition algorithms
kba gamma
hecke theorem
unit albedo
light includes
analytic description
positive lighting
funk hecke
qr decomposition
unit sphere
theta 4
linear combination
light reflected
oe sin
z ck
van doorn
z direction
dimensional space
r oe
order n
degree polynomial
linear method
n z
min z
arbitrarily bad
z 1zp
d zmura
epstein et
harmonic light
4d linear
attached shadows
reflection distribution
coefficients k
lambertian objects
squared energy
negative least
first harmonic
shashua 25
rotationally symmetric
photometric stereo
physically realizable
specular objects
nine harmonic
enforce non
d doe
set of images
non negative lighting
low dimensional linear
model s images
non negative combination
georghides et al
harmonic basis images
belhumeur and kriegman
surface normals scaled
first order approximation
dimensional linear subspace
funk hecke theorem
non negative light
order harmonic images
combination of delta
object can produce
min z ck
kba gamma ik
koenderink and van
z 2 z
low dimensional space
make our approximation
half cosine kernel
dz n gamma2
oe sin d
use this analysis
lambert s law
r theta r
reflection distribution function
near a low
shashua s method
first few harmonics
d n gamma2
pose and lighting
z 1zp n
half cosine function
dimensional linear space
enforce non negative
nine harmonic images
th order approximation
bidirectional reflection distribution
epstein et al
b is p
first order harmonic
non negative least
p theta r
according to lambert
first nine harmonic
negative least squares
n gamma2 dz
negative lighting function
light is non
sphere is illuminated
sin d doe
non negative function
second order approximation
n th order
computed at run
transactions on graphics

corpus/krapavin2000-test/627506.txt
backpropagation
learning
neural
stochastic
cooling
configuration
annealing
boltzman
weights
configurations
generalization
training
eq
recognition
network
markov
temperature
acceptance
metropolis
weight
monotonic
convergence
lit
trained
stationary
minima
module
simulated
opt
trial
commands
outcome
samples
chain
backprop
backpropogation
outputs
globally
explorations
probabilities
descent
connectionist
gradient
fit
irreducible
derivatives
forall
exp
aperiodic
error
transition
transitions
matrices
networks
memorization
psuedo
federation
microstructure
aperiodicity
schedule
adjustments
handwriting
inputs
neighboring
homogeneous
simulator
np
cognition
trigonometric
epochs
discover
perturbation
symbolic
perturb
lk
frozen
routines
criteria
probability
learn
brain
abilities
stuck
shallow
slowly
reproduce
neurons
conditional
fig
tune
curve
lm
constructive
converges
ch
jt
boolean
hidden
sd
outcomes
yielded
massively
interactability
walkthrough
crooked
behaviorial
variablesby
forallj
mchines
datafiles
expotential
neurocomputer
limq
feller
outpputs
finat
numeral
urop
minimas
reimplement
stisfaction
confi
xmp
train
comprises
sample
trials
testing
validation
analytical
organizing
pascal
regression
accepting
fitting
matrix
surface
modules
loading
dies
guration
hopfield
plateaus
teria
historic
prediction
il
square
squared
propagation
aims
formulation
associating
layered
numeric
randomly
neighbors
implements
inset
stu
cri
memorizing
handwritten
hereinafter
artificial
output
expert
discovering
setup
changed
schedules
bond
irreducibility
seminar
emergent
inhomogeneous
package
formalism
reuse
contingent
sinusoidal
sitions
shekhar
recognize
derivative
net
signal
stochastic backpropagation
generalization problems
neural network
backpropagation algorithm
simulated annealing
eq c
learning algorithm
markov chain
stationary distribution
monotonic functions
current configuration
output pairs
control parameter
globally optimal
neural networks
input output
weight space
optimal configurations
learning samples
boltzman machine
total square
cooling schedule
optimal weights
configuration j
trained network
generalization problem
per pattern
cooling rate
th trial
metropolis criteria
learning sample
neighboring configuration
r opt
recognition problems
square error
non monotonic
error function
network simulator
desired output
gradient descent
constructive function
homogeneous markov
error derivatives
boltzman distribution
stochastic backpropogation
function learning
symbolic meaning
new configuration
lower error
acceptance probabilities
corresponding markov
pattern error
testing module
weight adjustments
chosen weight
distributed processing
learning algorithms
c 12
global minima
learning examples
learning module
configuration w
error surface
signal detection
minimum error
conditional probabilities
probability distribution
j c
hidden nodes
detection problem
entire domain
parallel distributed
l 1
within 5
training example
output o
np complete
n o
o 2
data collection
real numbers
exp de
recognition 2
loading shallow
de k
creating artificial
learning translation
function neurons
analysis module
get stuck
backpropagation network
symbolic semantic
plots statistics
node neural
generalization ch
initial stochastic
neurons structure
th training
yields per
package 41
backpropagation package
node functions
backpropogation backpropogation2epoch
cooling schedules
brain style
psuedo pascal
lit jt
network yielded
g it l
input output pairs
l 1 lit
total square error
error of fit
globally optimal configurations
algorithm for generalization
neural network simulator
parallel distributed processing
n o n
l t l
shown in fig
case of stochastic
non monotonic functions
globally optimal weights
network is expected
randomly chosen weight
lit s r
stochastic backpropagation algorithm
l t g
corresponding markov chain
constructive function learning
signal detection problem
k th trial
eq c 5
per pattern error
eq c 4
given by eq
set of input
o 1 o
space f 1
expected to reproduce
yields per pattern
function neurons structure
c th training
parameter l 0
recognition in massively
control parameter l
implementation of stochastic
th training example
exp de k
fit the learning
homogeneous markov chain
compute an output
existence of stationary
handwriting recognition 2
initial stochastic backpropogation
trained network yielded
input i n
learning translation invariant
convergence to global
symbolic semantic network
design of intelligent
backpropogation backpropogation2epoch figure
data set generator
conditions on matrix
j c refers
y j c
backpropagation package 41
jt s r
learning the weights
chain is aperiodic
set of learning
error function e
backpropagation learning algorithm
training a 3
remember the outputs
federation of geometric
n e d
alternative learning algorithms
brain style computation
learning with various
examine and modify
stochastic backpropogation backpropogation2epoch
annealing in weight
change in total
backpropagation trained network
art of adaptive
represent the possibly
stochastic backpropagation learning
current configuration w
complexity of loading
shows the change

corpus/krapavin2000-test/628166.txt
datalog
stratified
xy
stable
fixpoint
iterated
stratification
diffchoice
stage
cliques
clique
ldl
st
atom
red
nondeterministic
predicate
ord
atoms
ad
deductive
negation
sv
semantics
nonmonotonic
query
temporal
template
sg
recursive
ut
programs
old
ar
translation
sp
exit
predicates
primed
databases
nondeterminism
dependency
aggregates
program
declarative
extensional
queries
topological
sales
stages
rules
interpretation
reasoning
argument
expressiveness
tuples
thorough
forgetful
rule
datacube
subclique
aculty
suffices
relational
coincidence
induction
translated
nondeterministically
faculty
syntactic
modularly
miller
aggregation
logic
fire
eval
semistructured
rels
disciplined
reconstructed
repeat
fb
rg
arguments
determinism
multiplicity
translate
tq
lifschitz
fd
sketch
inhibits
forget
gelfond
gray
optimizations
repertoire
db
deterministic
database
se
safe
sort
progression
magic
smith
iterative
aggregating
symbol
useless
traversals
amenable
els
termination
language
abbreviate
brown
date
deduction
monotonic
delete
concrete
fragment
additions
hypothesis
perfect
justifies
literal
track
delta
modulo
aggregate
head
mining
gathering
induced
obey
init
relations
outcomes
copying
ordering
mechanisms
iff
department
unrestricted
rondogiannis
instanced
gergatsoulis
subcliques
minfi
turini
deduceable
nomikos
poral
inconveniences
inexpressible
plified
stratifiable
giannotti
8diffchoice
undisciplined
fosca
expressing
saturation
deterministically
literals
approximating
admits
hierarchy
deduced
locally
sketched
tem
interpretations
constructs
approximable
manco
clarifying
seminaive
sale
eig
capitalized
operational
material
tailored
scott
answering
compromise
stable model
stage argument
st ad
stable models
iterated stable
xy programs
datalog programs
sum r
sg p
ord r
translation template
iterated fixpoint
q red
xy program
choice construct
datalog program
xy stratification
model procedure
deductive databases
program p
sv p
clique q
stratified programs
topological sort
chosen 0
old old
model semantics
r x
stable version
recursive cliques
stratified negation
fixpoint procedure
major st
temporal argument
diffchoice r
stage arguments
st area
ad major
xy stratified
ad st
ad area
h p
locally stratified
template 3
example 7
atom p
perfect model
temporal reasoning
chosen r
last p
r root
choice atom
dependency relation
n red
f smith
temporal arguments
choice safe
template 1
proposed optimizations
stratified program
forgetful fixpoint
predicate symbol
relation p
optimization techniques
nonmonotonic reasoning
copy rule
syntactic restriction
r defined
assigned using
exit rules
primed version
base relation
total sum
non deterministic
rule r
recursive predicates
iterative procedure
possibly infinite
minimal model
previously computed
declarative semantics
nondeterministic choice
non monotonic
relation r
se g
ldl 2
programs augmented
gray miller
red red
programs 22
choice fixpoint
realistic ldl
nondeterministically select
predicate stratified
iterated choice
cliques q
miller g
h sg
thorough account
aculty ad
iterated stable model
defined in q
stable model procedure
model of p
stable model semantics
semantics of datalog
p i x
datalog program p
clique so p
ad st ad
st ad st
old all 0
reasoning by means
st ad major
major st area
translation template 3
sum r x
ad major st
semantics of choice
r x n
program of example
ord r x
use of choice
multiplicity of stable
iterated fixpoint procedure
definition of h
repeat the process
r x y
gray miller g
j 0 old
ad area chosen
local stable model
lemmas 1 2
denotes the extension
area chosen st
f aculty ad
purpose of evaluating
total sum r
aculty ad area
stratified datalog programs
following translation template
interpretation i proof
n sum r
c chosen 0
area faculty ad
extension of relation
iterated fixpoint semantics
nonmonotonic and nondeterministic
h sg p
area f aculty
approach of 13
closely related lemma
program fragment p
repeat 8p defined

corpus/krapavin2000-test/1017155.txt
default
door
hd
defeasible
evidence
unblocked
conseq
videocamera
oe
compatible
observation
gammai
extensions
degr
defeated
refined
sensor
observations
logic
iff
consequent
readings
rules
cofinal
obs
prioritized
fusion
theories
qg
cumulative
proposition
satisfaction
incompatible
refining
cnd
robot
layered
obsi
sceptical
extension
rg
defeat
incomparable
sonar
fp
degrees
defaults
sigma
open
straight
normal
prerequisite
gamma
modelled
hm
numeric
pieces
reasoning
derivable
blocked
conflicting
ordering
nonmonotonic
directedness
closed
th
cautious
expectation
justification
interpretation
hf
image
reiter
logics
tautology
supplement
maximally
reality
inconsistent
sensory
interpreted
facts
notions
monotonicity
preferential
sensors
careful
priorities
proximity
minimal
regularity
mirroring
dg
rule
justified
priority
pg
fdg
ordinary
semantics
frg
believing
perception
founded
exceptions
induced
consistent
background
reading
agent
orderings
sentences
accordance
top
probabilistic
priori
interpretations
supposed
traditionally
play
believes
angle
intersection
applicable
minimality
ff
considerable
sight
satisfies
clause
bodies
argued
inference
behaviour
preferred
weaker
formulas
vision
expectations
deltai
prefence
gammaig
subsidized
unprioritized
restricitive
interpeted
harmonizing
bacground
pionier
disagreeing
harmonize
diffculty
stopperedness
subsymbolic
consitute
amended
consequence
sequentially
preference
belief
adequately
maximal
free
situation
stronger
incomplete
unreliable
justify
analogous
fi
acquired
underlying
intended
conclusions
tweety
perceptions
rendition
pgs
savage
poole
cetera
regular
possibilities
variants
concrete
additionally
refine
agents
consisting
insufficiently
servations
cancelling
pitman
reminder
withdraw
justifications
default rules
observation models
observation theory
default theory
observation model
default rule
default logic
observation logic
free default
d 0
hd gammai
normal free
e 0
refined evidence
degrees open
oe e
model m
straight observation
degr open
e 00
sensor fusion
level observation
observation based
videocamera image
gamma conseq
m d
th fp
well ordering
compatible extension
defeasible observations
th f
one level
ordering oe
theory hd
hd gamma
obs d
image taken
first order
default theories
q rg
d iff
conseq d
top less
conclusions supported
compatible extensions
sensor readings
extended observation
theory d
normal default
layered extension
conseq m
compatible observation
extension th
consequence operation
observation theories
order models
th gamma
q e
p e
m 0
specific proposition
open without
unblocked extension
minimal default
evidence underlying
logic using
rule d
prioritized default
conflicting observations
defeasible observation
information image
fusion process
cofinal observation
open 79
hm obsi
p q
background knowledge
evidence e
fp qg
unique extension
order model
d consisting
r e
every model
less refined
observations oe
th m
observation logics
gammai generated
prioritized normal
exact angle
m obs
open 84
multiple extension
rules representing
less observation
unblocked extensions
considerable distance
model hm
layered extensions
f p
models m
probabilistic interpretation
proposition 10
fp q
closed default
p qg
satisfaction relation
extension of d
door is open
normal free default
observation model m
m of d
door is 84
one level observation
extension of hd
well ordering oe
refined than e
videocamera image taken
th f p
r e 00
consequent of d
q e 0
level observation models
straight observation models
set of conclusions
pieces of evidence
e and e
free default logic
conseq m d
gamma conseq m
satisfies the consequent
evidence than e
observation theory d
first order models
extended observation models
straight observation model
theory d consisting
free default rules
door is closed
based on evidence
th fp qg
default rule d
set of default
first order model
sensor fusion process
default theory hd
th fp q
assumed to represent
taken from considerable
observations oe e
theory hd gamma
hd gammai generated
m obs d
conseq d 0
rule is called
default rules representing
interpretation of default
theory is regular
every model m
observation theory hd
multiple extension problem
open 84 degr
degr open 79
p q rg
obs d satisfies
situation of example
minimal default rules
m j d
observation logic using
fp q rg
situation is modelled
gamma conseq d
using 1 extensions
free default theory
top less observation
denotes the observation
rules of d
compatible observation models
observation model hm
observation models m
logic using 1
model hm obsi
theory hd gammai
level observation model
d d 0
normal default theory
f p qg
notion of extension
given the evidence
f p q

corpus/krapavin2000-test/1008818.txt
oaep
ciphertext
wayness
decryption
rsa
oracle
askh
security
plaintext
gammaow
encryption
adversary
succ
asked
gammapd
attacks
shoup
public
cbad
ind
event
oracles
permutation
rbad
gbad
askg
pkcs
trapdoor
unpredictable
sbad
pr
pd
gammak
success
attack
query
askrs
dbad
ffi
secret
ow
reduction
bad
simulator
sk
fail
bits
semantic
pk
cryptosystem
fl
outputs
hash
queries
attacker
askr
malleability
ds
awareness
asymmetric
simulation
probability
decrypted
rogaway
coppersmith
ut
adaptive
answers
stronger
secure
believed
ff
inverted
lattice
answer
unlikely
exponent
recover
lemma
encrypt
victor
events
partial
adv
cryptosystems
coins
proven
bellare
asks
reject
reducibility
notions
random
adversaries
encrypted
concatenated
famous
rejects
reaction
repair
gets
delta
plain
strongest
scenario
queried
fresh
feistel
thanq
gammaae
maskeddb
maskedseedkmaskeddb
gammaoe
xff
wording
misbehaving
epoc
lunchtime
onewayness
spotted
maskedseed
asking
lattices
soon
equalities
corrected
challenge
gaussian
modular
thanks
simulate
plaintexts
multiplicatively
anybody
rameter
conversion
uniquely
semantically
simulates
meaningfully
boneh
encryptions
fraction
message
reconsidered
forgetting
repairs
reduc
root
phi
wants
corrects
plications
univariate
encrypts
lists
correctly
omega
recalls
flaw
trailing
extractor
resp
theta
pre
image
preclude
indistinguishability
rabin
runs
looks
ae
oe
split
notations
conditioning
alice
insecure
mutation
self
modulus
former
probabilistic
messages
negligible
insist
overwhelming
bookkeeping
one wayness
decryption oracle
domain one
partial domain
rsa oaep
success probability
chosen ciphertext
semantic security
ciphertext c
public key
oracle simulation
gammapd gammaow
oracles g
adaptive chosen
h list
h respectively
ciphertext attacks
succ pd
pd gammaow
significant bits
q g
random oracles
g list
probability succ
within time
set partial
random oracle
q h
security result
pkcs 1
h ffi
ind cca2
succ ow
gammak 0
rsa function
th root
j askh
key encryption
h queries
ciphertext attack
e th
hash functions
random value
pre image
encryption scheme
q d
functions g
trapdoor one
security notions
partial pre
proof 3
asymmetric encryption
encryption oracle
fail cbad
gaussian reduction
plaintext awareness
gammaow succ
event fail
rsa problem
making q
challenge ciphertext
queries asked
pr fail
way permutation
valid ciphertext
event means
askh occurs
oracle simulator
time bound
g delta
function f
d q
secret key
split according
permutation f
victor shoup
modular equation
full domain
g fl
encryption schemes
query answer
whose running
query c
algorithm k
f means
stronger assumption
running time
upper bounded
constant fraction
oracle model
one gets
least significant
security analysis
delta 2
implies askg
awareness 1
askh q
plaintext attack
former event
oracle indeed
occurs h
since partial
gbad implies
quite unlikely
ffi h
trapdoor permutation
bad values
oaep conversion
one outputs
new computational
plaintext checking
pr askg
latter event
event askh
public data
reaction attacks
answers whether
attacks 10
domain one wayness
partial domain one
asked to h
wayness of f
g and h
adaptive chosen ciphertext
succ s gammapd
asked to g
chosen ciphertext attacks
succ pd gammaow
random oracles g
set partial domain
within time bound
decryption oracle simulation
denotes the event
public key encryption
q g delta
success probability succ
security of rsa
q d q
d q g
hash functions g
g and q
e th root
chosen ciphertext attack
q h queries
r is unpredictable
g delta 2
decryption oracle simulator
trapdoor one way
making q d
one way permutation
security of oaep
delta 2 gammak
list and h
security against adaptive
r to g
least significant bits
whose running time
time is bounded
denotes the time
random oracle model
latter event means
proof 3 based
askg j askh
full domain one
list of queries
askh occurs h
application of oaep
event that r
plaintext awareness 1
given a message
oracle simulation ds
key encryption schemes
shoup s result
actually be proven
security proof exists
event that query
respectively then succ
defined and thus
adversary a whose
chosen plaintext attack
except the challenge
partial pre image
shoup 15 recently

corpus/krapavin2000-test/627765.txt
tah
ventricle
lateral
image
tumor
brain
protrusion
spatial
tahs
query
relaxation
sr
images
contours
conceptual
mdisc
shape
features
bordering
content
semantic
contour
retrieval
pressed
matched
tumors
lesion
ur
nearby
relationships
ul
patient
lv
target
surround
operators
lr
similarity
protrusions
patientwithimage
ksim
obj
profile
feature
retrieve
sl
retrieving
lobe
subclause
relationship
ranges
height
objects
predicates
finalized
circumjacent
mtah
midline
ventricles
patients
tips
ll
rl
object
screen
width
surgeon
descriptors
frontal
layer
answers
ranking
segmentation
policy
extracted
mandatorily
srtl
kl
queries
database
occupied
medical
retrieved
joined
pt
clustering
precision
midpoint
centroids
resonance
qbic
answering
touching
matching
coverage
abstraction
engulfed
kmed
visualworks
invading
delineation
centrally
bronchial
surgeons
radiologists
protursions
roundness
cobase
santini
hierarchies
menu
pull
magnetic
angle
classified
composite
hacid
mohand
gemstone
sad
intelligent
decomposed
multimedia
hierarchy
attributes
symmetry
lined
simone
ct
literal
mr
attribute
intended
constructs
divides
display
directory
margins
alfonso
databases
ranked
layers
classify
textually
bnf
staged
specialization
ramesh
select
interpretation
customize
gui
location
ext
perimeter
raw
fuzzy
layered
cooperative
topological
jain
selected
relaxed
representative
chu
classification
axis
thick
centroid
users
highlighted
representations
extracting
segmented
certainty
semantics
locate
chih
retrieves
assist
shaped
vision
prototype
avinash
petraglia
projectional
wasfi
xcordofcentroids
lowerlrheightratio
arteries
sebillo
ison
tucci
ycordofcentroids
lateral ventricle
spatial relationship
spatial relationships
target image
conceptual terms
knowledge based
tah nodes
user model
image objects
value ranges
relaxation policy
tah node
right protrusion
query processing
based query
left protrusion
sr l
semantic spatial
semantic operators
relaxation error
object contours
shape features
similar images
protrusion height
user profile
image content
image features
relationship operators
brain tumor
image object
l lv
relationship features
tumor size
query 4
brain tumors
image retrieval
matched objects
upper protrusion
shape feature
ur ll
protrusion pressed
query relaxation
selected features
query constraints
user type
shape model
description table
image semantics
retrieving images
type abstraction
feature values
selected tah
frontal lobe
knowledge layer
obj feature
matched user
lesion lateral
value range
multi attribute
content based
o c
clustering algorithm
image similarity
relevant answers
two contours
large tumor
finalized tah
brain midline
patientwithimage patient
brain contour
ll lr
tumor nearby
image representations
fully surround
ventricle 1
select patientwithimage
query context
lateral ventricles
right symmetry
content matching
protrusion width
lower right
operators e
relationship model
shape descriptors
two objects
brain surgeon
ul ur
based content
abstraction hierarchy
g large
retrieve images
upper left
query query
upper right
image feature
lower left
terms e
target data
query analysis
shape description
features used
image databases
image model
srtl lesion
appropriate tahs
spatial image
layer kl
nearby far
object spatial
mandatorily matched
composite feature
conceptual query
policy provided
matched tah
extracted image
raw images
bordering fully
available conceptual
relaxation process
knowledge based query
features and spatial
sr t l
based query processing
semantic spatial relationship
sr l lv
spatial relationship operators
spatial relationship features
lesion lateral ventricle
matched user profile
upper right protrusion
tumor and lateral
upper left protrusion
lower right protrusion
angle of coverage
based on subclause
spatial relationship model
set of features
similar to operator
operators e g
context and user
right protrusion height
select patientwithimage patient
width of lower
upper protrusion pressed
lateral ventricle 1
height of lower
left protrusion height
based content matching
knowledge based spatial
similar to predicates
ventricle 1 sr
ur ll lr
lower left protrusion
query query query
e g large
ul ur ll
knowledge based content
width of upper
height of upper
target data values
conceptual terms e
terms e g
type abstraction hierarchy
images by content
knowledge based approach
tumor srtl lesion
mandatorily matched objects
semantic operators e
lv 2 brain
spatial relationship predicates
available conceptual terms
image content interpretation
relaxation policy provided
image model ksim
target image condition
l lv 2
knowledge layer kl
g large small
type abstraction hierarchies
model and spatial
feature description table
shape feature description
sr t f
features and content
content interpretation knowledge
description table table
d s r
spatial image model
nearby far away
tah for sr
pull down menu
based spatial image
bordering fully surround
srtl lesion lateral
retrieve similar images
queries with semantic
nearby the lateral
surround with bordering
analysis and feature
content based retrieval
features e g

corpus/krapavin2000-test/609202.txt
specialization
aeow
specializer
tempo
specialized
program
cache
loader
int
residual
stat
cached
dyn
dioeerent
romberg
explosion
computations
loops
loop
speedup
scienti
bpf
ruf
smirnov
knoblock
spline
compile
chebyshev
early
unrolled
cubic
binding
opportunities
gi
fft
expensive
ooe
unspecialized
static
doubly
signi
conditionals
bene
interpolation
strategies
specializing
nested
programs
nition
calculations
reader
void
cant
innermost
frontier
singly
unrolling
encodes
speedups
ps
lter
struct
dioeerence
eoeciently
dioeer
aizu
unrolls
annoted
ineoeective
caching
ts
speculative
invocation
fragments
integration
consel
rst
late
berkeley
aimed
body
extern
asian
lawall
danvy
specializations
limitations
annotated
trigonometric
approximates
backward
julia
packet
identi
rpc
rt
concretely
appendix
essence
preprocessing
fourier
iterations
compiled
olivier
intensive
sun
ambient
estimations
mainly
displayed
ct
procedures
textual
inexpensive
optimizes
analyses
evaluated
looked
costly
code
degrades
invocations
propagates
korsholm
izer
bulyonkov
franoise
brieaey
rohde
linearisation
isystemj
intpow
tegration
robertas
meur
damaeviius
eoecient
gyu
hornof
barzdins
malmkj
myong
ooeering
fabs
tuikys
malmkjr
karoline
getrusage
ager
eoeect
ooeers
iuserj
vytautas
japan
graphics
slower
hundred
charles
calls
named
torben
renaud
amtoft
shaders
rebuilt
henning
nitions
mads
thibault
simpli
marlet
improves
compilers
ve
dropping
dynamic
matcher
widen
thoughtful
metaprogramming
manipulate
improvements
park
tour
genera
eighties
cantly
pratt
alias
assess
phases
ed
integrate
instruction
data specialization
program specialization
specialized program
early computations
control aeow
code explosion
specialization strategies
aeow computations
residual program
data aeow
cubic spline
procedure f
partial evaluation
spline interpolation
gi procedures
program specializer
compile time
static dynamic
doubly nested
code size
scienti c
cache int
int stat
cause code
dyn d
romberg integration
expensive data
specialization encodes
program specialized
binding time
problem size
int j
void f
expensive enough
run time
nested loop
two programs
innermost loop
time analysis
speedups see
specialization problem
dyn int
struct data
specialization opportunities
combined specialization
expensive calculations
e stat
berkeley packet
specialization time
combining program
int d
computations program
aeow intensive
ooe line
int dyn
aeow graph
packet lter
bene ts
e dyn
dioeerent specialization
data specialized
unspecialized program
residual code
smirnov integration
size increases
de nition
new program
static computations
binding times
singly nested
analyze two
mainly consists
specialization process
preprocessing phase
perform data
nested loops
original one
c programs
signi cant
points n
automatic program
data cache
specialization actions
fourier transformation
specialization produce
performing speculative
speculative evaluation
becomes static
specialization phase
integration appendix
using estimations
similar speedups
control construct
d struct
test e
hand program
action analysis
aizu japan
manipulation p
estimations characteristics
program 4
ps rt
program applications
program and data
cubic spline interpolation
specialized with respect
result of early
data aeow computations
binding time analysis
specialization is applied
knoblock and ruf
specialization at compile
intensive a program
dyn d j
invocation of procedure
cause code explosion
dynamic or static
expensive data aeow
computations program specialization
encodes the result
berkeley packet lter
struct data cache
analyze two programs
e dyn d
ts and limitations
int dyn int
control aeow graph
control aeow computations
speedups see figure
programs where performance
scienti c programs
perform data specialization
computations which depend
specialization and data
dyn int d
problem size increases
doubly nested loop
program is data
number of iterations
side of figure
whereas data specialization
assess the bene
similar speedups see
c k w
specialized and program
specialized at compile
hand program specialization
programs data specialization
int w n
c programs 8
contrast data specialization
line program specializer
parameterized with respect
systems 10 11
cache int j
int stat int
specialized program using
source program b
propagates binding times
interval using estimations
one hand program
specialized program figure
data aeow intensive
candidate for program
produced by program
program is mostly
program b specialized
september 12 14
ct the program
case of program
cached by data
beyond some number
d struct data

corpus/krapavin2000-test/629399.txt
hull
mesh
hulls
broadcasting
buses
meshes
convex
supporting
bus
textstyle
submeshes
pocket
vertices
vertex
substep
olariu
rank
row
semigroup
processor
stage
schwing
broadcast
packet
neighbors
coordinates
plane
log
gurla
sorted
sample
rm
column
himabindu
dap
convexity
stephan
movement
geometry
rectangular
massively
venkatavasu
bokka
pockets
qa
theta
vlsi
broadcasts
processors
reconfigurable
holding
fastest
samples
wilson
larry
collinear
yn
halfplane
elizabeth
unenhanced
dedicate
stageg
bhagavathi
dominion
norfolk
enhanced
merged
submesh
unsorted
stored
virtue
stout
proposition
intersected
separable
square
altogether
preserved
communications
invariant
xy
mn
detects
qp
james
shall
architectures
image
illustrating
simd
sqrt
hashed
systolic
polygon
sampling
coordinate
lemma
computations
dlog
diameter
invariants
ingredients
miller
intention
perfectly
ffi
storing
va
horizontally
receipt
ranks
computers
guarantees
array
architecture
prescribed
spatially
eliminated
phenomenon
department
fvertical
amt
substeps
yuppie
odu
fhorizontal
holey
fpreprocessingg
podality
configurational
movable
edwardsville
cervical
pbroadcasts
ppa
pby
kand
khorizontally
merry
kbroadcasts
dharmavani
minfj
pand
jingyuan
subtracting
committed
spent
eliminate
update
enhancing
lying
connected
moved
vertical
correctly
counterparts
findings
involves
technicality
triangulating
ibarra
chosing
maxfa
noy
median
suitably
city
stages
generality
specifically
oe
belong
lies
tedious
chip
recognition
pixels
proceeding
handling
solved
consisting
abstractrecently
supporting line
upper hull
multiple broadcasting
convex hull
upper hulls
r j
u 2r
row buses
u 1
o y
sample vertex
stage 2
hull algorithm
th step
stage 3
right neighbors
semigroup computations
new upper
u 2
log n
n time
y theta
sorted points
size y
submeshes r
major order
n points
every processor
rectangular meshes
column major
mesh connected
two upper
textstyle 1
enhanced meshes
plane sorted
local communications
l schwing
supporting lines
stephan olariu
processor holding
n textstyle
y time
invariant h
data movement
computational geometry
first column
takes o
o n
theta n
o x
log 2
points stored
convexity guarantees
optimal convex
log textstyle
himabindu gurla
gurla stephan
task takes
size n
lemma 3
size p
sample vertices
hull problem
hull algorithms
mesh architecture
mesh r
correctly update
square meshes
lower hull
james l
running time
vertex u
log 3
n theta
o log
massively parallel
increasing x
every sample
rm log
p n
x coordinate
j k
stage 1
original mesh
every vertex
meshes ieee
every column
theta 2z
column buses
z time
y log
largest pocket
rm o
perfectly similar
venkatavasu bokka
new hull
packet along
larry wilson
bokka himabindu
rank within
mesh with multiple
broadcasting of size
meshes with multiple
o n 1
convex hull algorithm
computing the supporting
mesh with row
new upper hull
r j k
line of u
line of two
u and v
u 2r gamma1
size n 3
size y theta
two upper hulls
computing the convex
column major order
task of computing
n 1 8
step of stage
broadcast the packet
compute the supporting
o y time
pair of upper
size p n
stored in column
submeshes r j
points in r
performed in o
v in u
vertices in u
p n theta
state the following
u in u
log n log
proposition 3 3
left of u
log 3 4
time of stage
rank of v
using local communications
gurla stephan olariu
enhanced meshes ieee
pairs of upper
increasing x coordinate
line to p
takes o y
every sample vertex
optimal convex hull
meshes with row
rm log textstyle
james l schwing
himabindu gurla stephan
left and right
lemma 3 2
union of u
convex hull problem
coordinates of u
convex hull algorithms
rank of u
computing the upper
sorted by increasing
vertices of u
computed in o
massively parallel architectures
n 1 6
o log 2
meshes ieee transactions
r j 2
o y log
log 2 time
log 2 3
n sorted points
algorithms for sorted
reference we state
buses of size
task takes o
upper hulls u

corpus/krapavin2000-test/627595.txt
atbe
trees
pa
edit
query
dist
distwithcut
rna
subtrees
tree
file
matching
distwithprune
umbrellas
cuttings
editing
prunings
retrieve
manager
subtree
marks
bars
distance
someroots
retrieval
pattern
expr
database
match
screen
display
boy
umbrella
book
lexical
lql
donnell
users
delete
children
queries
distances
pop
matched
parses
parse
verbs
apt
bar
inexact
bool
node
hoffmann
relabeling
dictionary
rooted
displayed
foo
window
comparator
instantiation
contents
linguists
insert
pictorial
triangle
retrieving
cut
mark
molecular
sequenced
shasha
approximate
fl
processor
editor
keyed
unimportant
strings
string
unordered
farther
vp
reads
label
jt
ancestor
substitutions
alfredo
jason
windows
labeled
touched
ffl
rosalba
nonprocedural
kaizhong
byrd
wyk
chodorow
rnas
xifeng
giugno
dennis
philip
biology
extract
command
graphical
secondary
inputing
psql
menus
formats
mapping
sigmod
fig
eliminate
displays
var
pruning
tense
tsong
fingerprint
oql
extraction
files
structural
substitution
retrieves
inequality
correction
iter
jiawei
entered
name
language
semantic
customizable
tailor
verb
ingres
nouns
typing
sentence
transform
locate
grammar
sub
recognition
dissimilar
dissimilarity
wishes
op
locating
menu
deleted
routines
braces
wisconsin
nodes
template
newly
picking
serial
consideration
comparing
searching
preorder
repositories
closest
drawings
custom
yan
interpreters
manipulates
instantiating
seriously
dotted
operators
stages
siblings
ancestors
lowest
height
descendants
prefixes
det
querying
highlighted
shorthand
databases
extracting
stores
matches
format
portions
instantiate
text
edit operations
dist pa
tree matching
display manager
retrieve tree
editing distance
data trees
approximate tree
query processor
tree comparison
file name
data tree
pattern tree
distwithcut pa
atbe query
node contents
sub tree
labeled trees
query language
atbe system
match retrieval
bool expr
pattern pa
ordered labeled
would match
eliminate trees
tree type
given pattern
file f
triangle inequality
best match
computing distances
comparing trees
lowest node
o donnell
rna secondary
allowing zero
solution tree
subtree rooted
linear form
query optimization
string matching
users may
information retrieval
sub trees
approximate string
right order
without marks
computing dist
dictionary definitions
tree comparator
worst match
mark substitutions
distance would
boy reads
atbe provides
distwithprune pa
distance operators
unordered labeled
node formats
newly sequenced
inexact matching
horizontal normal
may edit
sequenced rna
extract information
query processing
language processing
allows users
two trees
edit operation
consecutive sequence
dennis shasha
underlying algorithms
matching tree
resulting distance
queries containing
secondary structures
using tree
user wishes
exactly match
distance metrics
entire tree
node l
approximate tree matching
distances between trees
distance between trees
hoffmann and o
best match retrieval
sequence of edit
distance between pa
ordered labeled trees
approximate string matching
set of algorithms
natural language processing
newly sequenced rna
resulting distance would
among the children
unordered labeled trees
distance between unordered
cuttings or prunings
match their corresponding
best matching tree
ffl in computing
operations that transform
removed when comparing
tree by example
tree of f
query by example
left to right
compute the distance
shown in figure
query the pattern
type of file
information from trees
spatial data modeling
o jt 1
inexact tree matching
yu jiawei han
system for psql
jason tsong li
var from file
parses the query
atbe is implemented
oql a query
trees and related
database and information
nodes black dots
current best matching
jt 1 j
var is tree
tree t 0
nonprocedural programming languages

corpus/krapavin2000-test/1017463.txt
nonfaulty
clock
pulse
clocks
processors
luck
processor
byzantine
pulses
faults
stabilizing
configuration
jumping
coin
averaging
synchronization
protocol
lc
toss
jump
period
faulty
anchor
protocols
wl
fault
tossing
drift
synchronous
gammaf
chinese
synchronized
increments
intervenes
nonanchor
self
scheduler
increment
tosses
agreement
ffi
physical
message
ae
safe
dim
elapsed
transient
tolerant
interventions
tolerate
incremented
synchronizing
counter
receives
apart
fixes
assigns
blowup
multisets
messages
stabilization
dhs
game
midpoint
chooses
successive
lsp
intervene
melliar
multiset
executes
delta
gamma
wrap
reached
reliability
generals
randomized
permanent
collecting
reach
finds
assign
logical
dl
wraps
validity
stabilizes
wrapping
remainder
resumes
presence
cope
severe
waits
received
halves
surrounded
sent
prime
lamport
election
pc
failures
semi
hs
inexact
mod
impossibility
reaching
reaches
lm
accelerate
destinations
round
converges
resilient
win
leader
synchronize
trip
kn
st
approximately
tamu
sheva
dij
napping
daliot
bgu
coan
incre
gurion
investigator
halve
rsb
misbehave
drifts
absrtact
games
delay
arrive
triggered
unifying
realistic
temporary
tolerance
lemma
synchronizes
implementer
trueg
swami
garner
rhee
injong
unexpected
subsequently
responses
spite
wait
procedures
distinguished
rounds
smith
correctness
contradiction
pigeon
dolev
shlomi
presidential
reintegration
mented
beer
elapse
around
bounded
agree
omission
excellence
denver
ticks
residue
gp
ariel
funds
devices
execution
nonfaulty processors
clock values
clock value
nonfaulty processor
clock synchronization
physical clock
byzantine faults
self stabilizing
processor p
jump procedure
m lc
every nonfaulty
averaging procedure
safe configuration
last increment
gamma f
pulse p
jumping period
averaging function
n gamma
clock j
scheduler luck
within ffi
common pulse
wl 88
new clock
stabilizing protocols
coin toss
p j
case 2
chinese remainder
faulty processors
logical clocks
synchronous protocol
first pulse
first configuration
jumping procedure
semi synchronous
synchronization protocols
n gammaf
every pulse
bounded clocks
successive pulses
remainder theorem
every processor
toss results
p increments
without tossing
clock drift
clock validity
luck intervenes
anchor processors
tolerant clock
anchor processor
distributed counter
luck game
processor measures
fault tolerant
processor executes
n 3f
logical clock
value thus
expected time
message system
value 0
two successive
transient faults
fault model
c 1
system reaches
least n
assign 0
clock agreement
reduced clock
ffi range
approximate agreement
physical clocks
receives 0
randomized self
r apart
within expected
synchronizing clocks
values list
dim 91
tolerant averaging
ffi 8
collecting clock
dim 95
symmetric clock
m pc
nonanchor processor
small range
two randomized
first protocol
jump function
else case
values 0
n gamma f
every nonfaulty processor
nonfaulty processor p
presence of byzantine
increments its clock
case 2 2
self stabilizing protocols
processors are within
clock synchronization protocols
new clock value
p s clock
least n gamma
clock value thus
chinese remainder theorem
case 2 1
coin toss results
two successive pulses
tolerant clock synchronization
around when appropriate
range of clock
clock by 1
scheduler luck game
number of pulses
fault tolerant clock
presence of faults
period of length
tosses a coin
configuration is reached
real time elapsed
processors are faulty
two randomized self
clock values list
tolerant averaging function
collecting clock values
clock value 0
clock values 0
tossing a coin
else case 2
randomized self stabilizing
p i chooses
executes the jump
fault tolerant averaging
reduced clock values
take a step
state and physical
n 6 n
within a small
follows the first
number of faulty
lemma 3 1
set of processors
wait free clock
achieving clock synchronization
values vector 0

corpus/krapavin2000-test/1036015.txt
multiplication
processor
multiplications
matrices
sup
elementary
matrix
cache
replication
tradeo
ik
communication
nb
kung
2d
3d
na
jk
lpram
cannon
strassen
bounds
bisection
toledo
conventional
snir
tiskin
univac
transferred
wp
asymptotically
sivan
memory
processors
misses
asymptotic
nc
loomis
berntsen
nanbnc
aggarwal
rows
ij
hong
irony
live
chandra
lemma
cut
whitney
unied
memories
dror
degenerates
dag
algebra
multipli
begins
phase
tradeoff
cations
reside
geijn
multiplicands
dekel
phipac
nassimi
lblas
resides
row
constants
cuts
underlies
send
sent
blocked
mnr
ncn
compulsory
watts
mul
rst
replicate
slow
subroutines
summa
prams
prefetch
sa
received
specic
broadcasts
inequality
pebble
receive
phases
bulk
mn
alexander
subroutine
nan
sahni
caches
sb
multiply
private
across
kalman
regime
cross
evenly
analyzes
fa
contributes
mc
blue
israel
columns
cm
sc
dense
ma
cient
hypercubes
dene
unlikely
involving
ibm
provable
fb
acyclic
synchronous
sgi
sp
cellular
arithmetic
accesses
hey
mccoll
humanities
compres
matri
tflops
rutledge
paterson
mckeller
organiza
bining
gustavson
zubair
nbn
tiplicands
coman
jerrell
feel
amount
perhaps
product
column
dierent
saves
specically
factorization
store
fc
subsets
red
products
contributions
workstations
tiplications
claries
partnership
worksta
johnsson
forbid
tiprocessors
computers
square
clusters
concrete
decompose
statement
mb
rigorous
academy
herbert
vb
rubinstein
isoperimetric
capacity
storage
matrix multiplication
communication lower
elementary multiplications
lower bounds
c ik
3d algorithms
2d algorithms
multiplication algorithms
distributed memory
processor must
per processor
b jk
memory parallel
ij b
m words
local memory
conventional matrix
parallel computer
memory per
must send
memory communication
multiplications involving
must perform
parallel matrix
slow memory
processor distributed
least words
asymptotic notation
involving rows
conventional multiplication
sup 2
p processor
exactly m
must cross
communication across
cache misses
linear algebra
g n
asymptotically optimal
lemma 2
multiplication algorithm
words must
sup words
aggarwal chandra
communication tradeo
input replication
n matrices
lower bound
two n
sivan toledo
input matrices
theorem statement
bounds also
phase begins
local memories
extra memory
computation begins
one processor
least n
irony sivan
p words
multipli cations
loomis whitney
least wp
whitney inequality
words per
output combining
lpram model
kung 17
discrete loomis
communication per
alexander tiskin
communication necessary
dror irony
nanbnc 1
concrete constants
fast cache
words proof
algorithms must
capacity cache
argument shows
n n
statement holds
synchronous parallel
basic lemma
bulk synchronous
least proof
element c
f n
communication network
n elements
m r
another processor
amount of communication
communication lower bounds
matrix multiplication algorithms
bounds for matrix
consider the conventional
ij b jk
number of words
distributed memory parallel
elements of c
number of elementary
memory parallel computer
conventional matrix multiplication
processor must send
hong and kung
memory per processor
n i sup
processor distributed memory
p processor distributed
elementary multiplications involving
lemma 2 2
send or receive
words of local
words of memory
multiplications involving rows
two n n
words that must
receive at least
parallel matrix multiplication
n n matrices
n 2 elements
elements of b
multiplication of two
least one processor
column of b
sup i p
exactly m words
algorithms are asymptotically
one processor must
chandra and snir
c is m
matrix multiplication algorithm
memory communication tradeo
theorem statement holds
n 1 2
must be transferred
sup 2 sup
amount of memory
row of c
bounds the number
p 2 3
state and prove
sent and received
communication e cient
strassen s algorithm
multiplication algorithms must
nanbnc 1 2
element c ik
dror irony sivan
loomis whitney inequality
algorithms must perform
irony sivan toledo
processor at least
communication lower bound
words per processor
communication that must
communication per processor
b is n
cannon s algorithm
toledo and alexander
discrete loomis whitney
data that must
capacity cache misses
n 2 2p
lemma 3 1
required to store
c 2 g
cache the number
p i sup
bulk synchronous parallel
n c 2

corpus/krapavin2000-test/608855.txt
cores
bypass
core
port
tpgr
misr
scan
bit
shortest
sink
ports
circuitry
bypassing
schedule
pcf
mode
cbg
circuit
infinity
wires
accessibility
cycles
testing
packets
dijkstra
controller
interconnections
transfer
paths
bypasses
bist
isolation
coverage
scheduling
fault
chip
interconnects
structural
transferred
parenthesis
widths
registers
asap
route
serial
isolated
mergeable
asic
reusable
dft
factorizing
inputs
syntest
multiplexors
transistor
clock
circuits
signatures
primary
faults
fastest
micron
compass
yoneda
tomokazu
interconnect
activities
match
automation
path
routes
outputs
chains
tentative
cmos
factorize
rtl
fujiwara
datapath
intellectual
hideo
embedded
unmarked
signal
schedules
overhead
chain
pipeline
bus
signature
bypassed
soft
buses
testable
synthesis
factorized
programmable
testability
tri
programmability
packetization
cota
packetizing
packetize
lubaszewski
carro
rika
width
logic
vlsi
europe
source
pile
gentest
busses
mux
nin
interfering
flip
char
characteristic
scrambled
packetized
vertex
overlap
pipelining
socs
vq
manuals
signals
protection
consumes
interface
predefined
eight
luigi
bellman
munich
stages
packet
pipelined
connections
marcelo
flops
jej
electronic
ort
entirety
shaded
wrapper
pursued
designer
summarized
tester
providers
cycle
ij
session
output
pseudocode
buffers
thoroughly
reusing
gate
cheaper
modes
library
methodology
patterns
reflecting
test time
core 1
test data
infinity infinity
bit match
bit data
output test
system primary
core k
shortest paths
cost values
fault coverage
test paths
test path
structural test
bypass mode
time cost
shortest path
core input
tpgr misr
test controller
four cores
dijkstra algorithm
b bit
output ports
output port
core 2
bypass scheduling
test shortest
port j
input test
bit widths
bypass circuitry
bypassing data
isolated core
bypass schedule
test point
core 4
bit width
input port
input ports
test points
input output
core based
cores signal
signal name
match circuit
misr stop_4
misr misr
tpgr tpgr
core environment
m bit
primary inputs
test patterns
test overhead
scheduling method
hard cores
embedded cores
global source
complete bypass
bypasses data
directed weighted
existing interconnections
test methodology
bit test
fastest route
name 17
bypass routes
transfer test
inputs outputs
design automation
paths 1
characteristic function
source sink
logic level
primary outputs
time overhead
n bit
path algorithm
reusable blocks
isolation techniques
n stages
bypass data
e cycles
without interfering
state buffers
tri state
scan registers
proposed structural
tentative path
micron cmos
global global
core circuitry
path weights
graph modeling
one core
existing wires
cycles cores
cbg graph
interface cost
programmable e
core output
core 3
k bit
two test
m n
weighted graph
infinity infinity infinity
test shortest paths
source and sink
system on chip
misr stop_4 stop_3
core under test
bit match circuit
cores signal name
output test shortest
tpgr misr stop_4
b bit data
input output test
data is transferred
directed weighted graph
tpgr tpgr tpgr
schedule for core
signal name 17
two test points
parallel to serial
transfer test data
system primary inputs
bit test data
misr misr misr
serial to parallel
finding the shortest
tri state buffers
test data distribution
cost d b
input test paths
isolated core environment
environment of core
bit input port
system primary outputs
programmable e g
input test path
output test path
packets of data
output test paths
route to transfer
core input ports
packets of 4
global global source
p s bit
cores are reusable
core based system
time cost d
design for test
example of figure
m n m
shortest path problem
core based systems
shortest path algorithm
terms of time
input and output
test in europe
figure 8 b
automation and test
electronic testing theory
figure 7 c
journal of electronic
algorithm to find
m bit input
transferred in 8
rika cota luigi
available bypass connections
n bit output
factorize the characteristic
point 2nd test
char interface cost
test data b
problem as finding

corpus/krapavin2000-test/629439.txt
dilation
packings
packing
hypercubes
sized
star
embedding
embeddings
hypercube
alg
packed
expansion
submeshes
asymmetric
kmax
avr
kmin
gamma
dimension
embed
theor
pack
links
nigam
bn
load
gammat
template
asym
dimensions
embeds
symmetrically
ratios
mesh
width
embedded
lfloor
rfloor
copies
sec
slices
int
disjoint
dim
submesh
sym
symmetric
odd
compose
cube
union
discarded
dings
dimensionality
expan
subsec
partitioning
aver
grouping
produced
krishnamurthy
image
mapped
induced
hyper
graphs
sahni
guest
congestion
connecting
produces
interconnection
asymmetry
link
eq
depicts
hierarchically
usable
base
migration
allocation
particularity
tearing
nacional
rically
conselho
reassigning
repertory
spaceand
desenvolvimento
ranka
dil
blog
bel
dimensional
metrics
mapping
viewpoint
origin
cdot
asymmet
packs
sional
subsecs
referred
permutations
node
labeled
devised
listed
var
hamiltonians
cayley
featuring
supercomput
diameter
characterizes
formed
subsection
sacrifice
coordinates
largest
relabel
intermediary
mult
omitted
average
host
denser
pioneered
temp
ranging
growing
accordingly
theta
symmetry
nodes
utilization
quantities
ding
slowdown
label
sorting
strings
assures
nk
accommodating
struc
fft
attractive
copy
pseudocode
discards
secs
producing
discusses
slow
unused
lists
terminology
tasks
compound
ture
contrasts
fig
arrangement
abstractwe
employ
nc
reader
configured
dist
characterize
labels
popularity
cubes
th
background
ultimate
slice
workloads
paths
achieves
variable dilation
n gamma
q k
dilation embeddings
gamma 1
sized packings
star graph
sized packing
average dilation
multiple sized
q n
dilation embedding
fixed sized
load 1
h n
disjoint union
expansion ratios
base dilation
packing p
g k
m n
dilation d
star graphs
dilation 3
p f
packing techniques
template packings
odd sized
d avr
d base
bn 2c
p m
alg 2
asymmetric packings
packed q
n gammat
alg 1
expansion 1
gammat h2hi
small expansion
hypercube dimensions
sized dimensions
use dim
embedding techniques
dilation 1
k b
dimension links
w dilation
avr w
largest hypercube
symmetric fixed
dilation vector
discarded submeshes
asymmetric fixed
th dimension
dilation 4
base p
b n
n 10
sec 2
k kmin
dimensional star
union u
asym q
hypercubes q
sym q
q kmax
symmetric packings
symmetrically packed
pack q
partitioning process
packing hypercubes
induced submeshes
low expansion
node allocation
theor 1
embedded hypercubes
space constraints
e u
k many
mapping algorithm
embedding hypercubes
dimension b
along dimension
gamma 2
q 4
omitted due
many copies
dimensional hypercube
sec 4
f int
v h
j k
cases 8
embed dings
produce dilation
pack hypercubes
pack p
left lfloor
define theorem
resulting packing
asymmetric template
n gamma 1
m n gamma
q n gamma
variable dilation embeddings
variable dilation embedding
multiple sized packings
fixed sized packing
embedding of q
fixed sized packings
n with load
base dilation 3
embeds the disjoint
hypercubes into star
multiple sized packing
copies of q
n gammat h2hi
sized packing p
embeddings of q
slices of width
dimensions of m
d base p
packing of q
d avr w
symmetric fixed sized
dilation d base
links of q
odd sized dimensions
q k b
dilation embedding techniques
asymmetric fixed sized
gamma 1 m
nodes of m
hypercubes q k
links of e
paths of h
dilation and expansion
p f n
hypercubes are packed
packing p f
gamma 1 2c
k n gamma
constraints the interested
dimension a links
packed q k
n dimensional star
k many copies
average dilation d
f n gammat
proof of theor
sym q n
dimensional star graph
f which embeds
asym q n
dilation d avr
disjoint union u
mapping of v
v h n
b n gamma
n gamma 2
referred to 9
comparison with related
denote the largest
subsection we present
due to space
denote by p
dimension i link
upper limit k
packings and embeddings
pack q n
characterizes a symmetric
sec 4 presents
size 2 theta
dimension b links
asymmetric multiple sized
packing p m
q n 2
node of h

corpus/krapavin2000-test/1039494.txt
rank
frieze
drineas
svd
singular
rows
matrix
subspace
az
kannan
vectors
sampling
szemer
ss
sample
frobenius
document
alan
spanned
approximation
edi
pick
documents
norm
regularity
row
bin
sd
jth
ith
approximations
columns
latent
lemma
monte
entries
sariel
achlioptas
peled
verbar
orthonormal
ay
carlo
matrices
vempala
mcsherry
szemeredi
submatrix
santosh
alon
har
ww
probability
dumais
kleinberg
mn
picked
seventeenth
su
cp
papadimitriou
span
entry
column
decomposition
miami
sparsity
retrieval
squares
eigenvector
cient
siam
expectation
expectations
semantic
annual
simonovits
rademacher
mnk
kmn
fernandez
odl
proximations
sparsify
yuster
koml
buzz
mahoney
bxx
karpinski
eckart
lefmann
shortly
pass
topics
ces
indexing
developments
florida
poly
ij
vega
yossef
rationals
chebychev
cursory
deerwester
boosted
parti
muthukrishnan
petros
median
squared
epsi
multiplica
hypothesizes
crudely
sedona
claims
frequencies
scaling
berry
deshpande
onwards
hyperlinked
golub
loan
polynomial
dense
partition
algebra
duke
authoritative
multiplying
approximates
sized
web
dimitris
creator
amit
precompute
fast
lth
marek
approximating
hypertext
luis
randomized
scaled
approximate
ory
consult
nm
symposium
random
jacm
unbiased
av
projective
rearranging
cur
arizona
assumptions
asserted
baltimore
eigenvectors
et
multiset
defer
magnitudes
orthogonal
satisfying
proportional
sublinear
ravi
unreasonable
sight
ce
md
attributes
geometry
bins
minimizes
tensor
mr
low rank
rank approximation
singular vectors
frieze et
f f
alan frieze
fast low
rank approximations
drineas et
assumption 1
k singular
regularity lemma
good low
subspace spanned
frobenius norm
assumption 2
szemer edi
fast monte
carlo algorithms
al 2004a
satisfying assumption
least 9
sampling assumptions
row space
matrix d
unit vectors
rank k
n matrix
et al
column space
distribution satisfying
p matrix
vectors z
vectors y
latent semantic
value decomposition
singular value
singular values
d k
vectors x
m n
time polynomial
f applying
probability distribution
probability proportional
ith row
monte carlo
top k
k approximation
matrix m
vectors u
lemma 3
first part
p columns
jth term
natural probability
error parameter
median shape
har peled
papadimitriou et
orthonormal set
constant sized
sariel har
finding low
d rank
b matrix
ith document
regular partitions
p rows
rows chosen
y 1
second part
get close
p independent
independently choose
assumption a1
explicit approximation
pick p
sparsity structure
corresponding rows
first pick
santosh vempala
taking expectations
n terms
takes time
f proof
y k
random variable
low rank approximation
frieze et al
alan frieze et
fast low rank
low rank approximations
drineas et al
good low rank
az i z
f f f
probability at least
d of rank
k singular vectors
sample the entries
et al 2004a
monte carlo algorithms
fast monte carlo
p p matrix
distribution satisfying assumption
least 9 10
m n matrix
polynomial in k
y 1 y
singular value decomposition
takes time polynomial
vectors y 1
top k singular
independent of m
unit vectors z
frieze and kannan
k and 1
holds with probability
rank k approximation
words that occur
part of lemma
f a f
see that f
set of vectors
problem of finding
algorithm to find
give an algorithm
probability distribution satisfying
finding low rank
p matrix w
satisfying assumption 1
f f using
d k f
matrix a k
sample of rows
ss t u
sariel har peled
d rank d
norm see section
computation of low
algorithm whose running
rank d k
set up data
natural probability distribution
f e n
vector valued random

corpus/krapavin2000-test/627693.txt
critics
kbds
critic
designs
ds
cables
joints
pillar
cable
critiquing
experts
polygon
sa
intersections
expert
redesign
worstparts
engineers
telephone
district
designjoint
tutoring
expertise
od
acquisition
kbdss
critique
consistency
diff
acquiring
street
intersection
redesigns
systemdesign
pits
adequacy
heuristics
sys
streets
engineer
houses
furthest
inconsistent
kb
routes
setinitial
correctnesscheck
incorrectness
incorrect
human
polygons
uphill
reorganize
subjectivity
inconsistency
inter
correctness
requests
misconceptions
pipes
facts
judgment
joint
costs
completion
telecommunications
automatic
consistencycheck
workability
updateod
choosepoly
expertexamine
modifykb
underground
dendral
assignjoint
numofdesign
refining
manually
pipe
resets
connect
codify
network
heuristic
refine
errors
manual
critiques
suggest
assist
annealing
intensive
null
elicit
laying
assisting
opinion
service
responsible
proper
optimum
wrong
insert
optima
enrich
unsatisfied
clues
served
building
examination
inference
reset
checking
fischer
contextual
house
theories
employed
lay
crossings
closest
away
base
provision
missing
intelligent
examines
rules
decision
designers
suggested
bring
subjective
alternative
verification
try
methodologies
beforehand
critical
usable
tries
modify
graphically
robin
temperature
finds
customers
meanings
missed
costly
allocates
grey
satisficing
leastod
generatedesign
mastered
nurtured
assigncable
consultation
objectivity
abstractexpert
iscs
scrutinize
reporterror
calculateod
objectively
cadastre
liuh
codifying
furthestinter
tutors
autoredesign
alternatives
minima
boundary
located
systematically
suggestions
engineering
calculates
impractical
computationally
terminated
downhill
equipping
unserved
taper
pragmatically
parks
complaints
hereby
knowledge based
knowledge engineers
design system
knowledge base
knowledge acquisition
domain theory
network design
engineering design
expertise completion
solution critic
decision points
problem description
alternative solution
sys p
completion critic
proper knowledge
based design
consistency checking
cost function
knowledge engineer
automatic redesign
independent system
designs produced
tutoring systems
two critics
cable network
service requests
sufficient knowledge
intelligent tutoring
adequacy problem
knowledge used
expert critics
good designs
designs generated
systemdesign sys
telecommunications network
four problems
design generation
furthest away
new design
alternative designs
system construction
insert figure
strong model
domain experts
algorithm 5
j c
design problem
human experts
design d
design b
cable routes
checking critics
ds generates
telephone network
known cases
ds p
kbds produces
design experts
various designs
optimal parts
produce designs
cable sizes
applying knowledge
way intersection
critical decision
better design
problem descriptions
based engineering
test cases
algorithm 4
heuristics used
based systems
inference rules
domain theories
sub optimal
computationally intensive
time constraint
intersection grey
knowledge based design
alternative solution critic
correctness and consistency
number of joints
set of critics
expertise completion critic
version of ds
telecommunications network design
based design system
use of critics
systemdesign sys p
critics are used
used in critiquing
consistency checking critics
sub optimal parts
intelligent tutoring systems
based engineering design
critical decision points
knowledge based engineering
knowledge based systems
p 2 p
algorithms that implement
number of cases
resets the strategy
fischer et al
apply sys p
apply ds p
intersection grey one
inconsistent systemdesign sys
alternative solution critics
building and applying
correct and consistent
kbds called ds
assist 1 acquiring
every service request
necessity of critics
subjectivity in knowledge
knowledge to generating
reorganize and generalize
implement the critics
generates the design
along the streets
chooses an intersection
middle intersection grey
way intersection od
acquiring sufficient knowledge
theories and problem
knowledge base modification
reports any errors
knowledge engineer reorganize
based design systems
help a knowledge
system and 2
telephone cable network
incorrectness or inconsistency
survey of expert
towards the pillar
modifykb kb diff

corpus/krapavin2000-test/608643.txt
agent
fipa
acl
veriable
verication
semantics
agents
kqml
speech
hearer
wooldridge
speaker
sl
acls
semantic
respecting
acts
ks
modal
believes
act
conformance
dene
message
beliefs
ungrounded
logic
language
autonomous
dened
quantied
performative
propositional
kif
veriability
performatives
cando
formulae
cohen
austin
mcburney
logics
communication
request
sender
denes
levesque
sincere
attitudes
parsons
eect
inform
recognised
denition
perrault
commissives
sincerity
frameworks
desires
standards
grounded
rational
multiagent
temporal
action
specication
simon
michael
pr
checking
recipient
content
spkr
lprolog
searle
labrou
formula
kripke
belief
article
addr
sending
propositions
program
messages
finin
utterances
tea
recognise
wants
classical
falsity
operability
rst
desire
ag
logical
intention
denitions
preparatory
actions
languages
planning
dialogue
truth
conform
mental
informing
satised
commerce
indistinguishable
characterise
annotations
practically
perlocutionary
draa
felicity
aairs
maudet
intending
mentalistic
rogier
chaib
illocutionary
eijk
kse
syntax
connective
joint
decidable
york
ontology
jl
price
dening
demonstrating
commitment
stand
programs
peter
paradigm
attributing
standardised
believe
signicant
uncertain
preconditions
began
social
consequence
grounding
arti
verifying
communicate
eects
identied
np
jj
species
war
commitments
phrased
sends
unlikely
satises
feasibility
referring
requesting
verbs
exchanging
pre
intentions
verifiable
nite
uncertainties
unsolved
theoretic
saying
declaring
strange
argumentation
encodes
enjoys
readings
branching
promising
receiver
claims
van
hoare
send
dierent
successful
harder
equivalently
richer
characterised
agent communication
speech acts
communication language
semantic language
communication framework
state l
agent program
language l
logical consequence
michael wooldridge
l c
semantic issues
fipa 97
model checking
autonomous agents
framework f
fipa acl
multi agent
communication languages
program semantics
agent systems
multi modal
classical propositional
quantied multi
propositional logic
l 0
simon parsons
peter mcburney
practically veriable
paradigm case
rational eect
verication problem
proof problem
modal logic
checking approaches
mcburney simon
temporal logic
f 1
proof theoretic
international joint
multiagent systems
program satises
acl semantics
semantic function
want pr
must believe
speech act
agent programs
cando pr
communication frameworks
conformance testing
speaker must
joint conference
ks ks
beliefs desires
knowledge theory
belief desire
agents communicate
pre conditions
request act
language sl
dened syntax
fipa semantics
intention logics
successful completion
kripke semantics
o conditions
logic l
modal connective
perform action
preparatory conditions
precisely dene
rational action
acl standard
physical actions
well dened
w l
co np
formal framework
np complete
grounded semantics
arbitrary programs
based theory
desire intention
plan based
classical rst
respecting the semantics
agent communication framework
issues in agent
communication language l
classical propositional logic
semantics of l
multi agent systems
quantied multi modal
semantic language l
theory of speech
language l c
agent communication languages
multi modal logic
model checking approaches
conference on autonomous
peter mcburney simon
mcburney simon parsons
international joint conference
agents and multiagent
whether an agent
agent communication language
agent communication frameworks
set of propositions
fipa 97 acl
dene the semantics
stand for members
done in time
cohen and perrault
sends a message
co np complete
labrou and finin
formulae of classical
well dened syntax
framework f 2
desire intention logics
formula of l
agent is respecting
claims to conform
communication language semantics
l 0 logical
plan based theory
classical rst order
respect the semantics
cohen and levesque
annotations to stand
speaker must believe
propositional logic l
logic l 0
semantics are given
agent systems v
agents and multi
dened in terms
m i l
belief desire intention
semantics for agent
normal i o
pre and post
truth or falsity
rst order logic
able to perform
l c semantic
multi agent scenarios
message must satisfy

corpus/krapavin2000-test/628254.txt
oid
oids
pph
hashing
bucket
mvbt
alive
page
alh
buckets
pages
lifespan
overflows
ephemeral
lifespans
persistent
snapshot
query
acceptor
evolution
evolving
overflow
nt
ri
nb
additions
temporal
records
membership
lh
round
instants
copies
rehashing
workload
workloads
queries
rp
lb
array
mvas
partially
multiversion
ub
pid
update
avg
bgo
atemporal
split
record
deletions
forest
deletion
poisson
tree
usefulness
deleted
ft
updating
maxtime
tsb
object
history
transaction
appended
amortized
indexes
evolves
index
searched
rehashed
tsotras
logarithmic
created
timestamped
instant
occurred
file
searching
remapped
utilization
answering
copying
load
mapped
stores
splits
objects
buffer
ptr
create
sibling
answer
insertions
artificial
reconstructing
contents
pure
updated
rehashings
overflown
evolutions
truncated
artificially
hashed
copied
sees
universe
persistence
stored
behaves
observes
merged
database
equivalently
copy
updates
exponential
balanced
entries
intervals
histories
accessing
arrays
branched
happens
queried
external
directory
list
zaniolo
deleting
maintained
traversed
store
proceeds
overlapping
pointer
uniform
locating
clustering
reconstruct
indexing
serially
uncontrolled
databases
entry
mb
existed
basics
join
added
const
efficiently
changes
ideally
traditional
falls
height
schemes
contradiction
splitting
access
insertion
interval
controlled
normal
conceptually
trees
answers
dept
possessed
bitemporal
rehashes
partially persistent
hashing scheme
linear hashing
persistent hashing
oid k
useful page
pph l
alive oids
snapshot index
b j
bucket b
hashing function
acceptor page
non useful
query performance
b tree
useful pages
temporal membership
snapshot query
membership query
bucket 0
alive records
l mvbt
alh pph
dynamic hashing
evolving set
ephemeral hashing
oid additions
oid lifespan
membership queries
avg number
o per
lb j
range snapshot
data pages
first overflow
object additions
alive objects
evolving list
temporal hashing
time tree
per query
transaction time
ft j
r tree
time instants
parameter u
new bucket
pure snapshot
lifespans per
per oid
space performance
usefulness parameter
ephemeral linear
access forest
lh file
b 1
bucket 5
per change
distinct oids
first useful
array h
given oid
data page
n b
last page
b total
update performance
next useful
temporal environment
real oid
oid copies
bgo 96
appropriate bucket
hashing problem
list page
multiversion b
exponential step
c space
nt array
ub alive
overflow occurs
query time
o 1
load factor
b update
uniform workload
time proceeds
new page
variable p
b r
set approach
per update
h 0
oid records
n overflows
temporal indexes
real changes
partially persistent hashing
bucket b j
pph s pph
number of alive
pph l mvbt
range snapshot query
number of lifespans
linear hashing scheme
b 1 oid
ephemeral linear hashing
temporal membership queries
temporal membership query
usefulness parameter u
number of changes
first useful page
dynamic hashing scheme
ephemeral hashing scheme
o n b
evolution of set
evolving set approach
object with oid
multiversion b tree
c space performance
update and c
becomes non useful
pure snapshot query
lifespans per oid
query b update
number of real
number of buckets
o per query
exponential step normal
external dynamic hashing
ephemeral dynamic hashing
ub alive records
mvbt and ri
list lb j
next useful page
o per update
real oid additions
hashing function h
array ft j
temporal hashing problem
o s per
real object additions
evolution of bucket
number of pages
expected o 1
number of copies
number of queries
l mvbt alh
k is deleted
case query performance
copy of page
records in bucket
lifespan at records
additions are needed
collection of buckets
addition of oid
query for oid
answer a temporal
performance for alh
page becomes non

corpus/krapavin2000-test/607562.txt
fevbdds
evbdds
fevbdd
evbdd
fevbddeval
diagrams
hc
obdds
nonterminal
terminal
gcd
ev
affine
fractions
boolean
ans
rulei
matrix
multiplication
matrices
rational
isomorphic
mtbdds
obdd
arithmetic
designators
factored
child
multiplicative
termwise
fgilp
lai
package
op
valued
complement
word
numerator
edge
jhc
weights
verification
normalizing
weight
additive
recursion
decision
nonisomorphic
walsh
val
consumption
precision
binary
cache
integers
gammak
pivot
kolmogorov
reconverging
sparse
denominator
jf
manipulation
ilp
multiply
swapping
bmd
zy
mtbdd
scalar
edges
row
associating
vertex
delta
graphs
inversion
spectral
signals
operands
additionally
circuit
integer
subgraph
chapman
multiples
node
vrudhula
euclid
subblocks
fdds
sevbdds
recursively
encode
goes
pivoting
inverses
bytes
branches
savings
drechsler
jgj
canonicity
cad
transposition
offer
representations
bit
rule
evi
redirected
signed
expansion
flattened
subgraphs
xy
subtraction
transforms
tabular
mbyte
subcase
multiplying
shifting
logic
realized
bdd
submatrices
rolf
concisely
canonical
denoting
encoding
routine
compact
ei
isomorphism
rows
lookup
conversion
calls
kronecker
gaussian
else
solver
uniqueness
compactly
jaj
maximal
assignment
hash
pointers
symbolic
fractional
mode
storing
divisor
recursive
column
absent
fields
fw
hx
transformation
concept
successfully
behavioral
internally
division
comp
expands
ffx
hreth
nowwe
seminumerical
khc
fdd
dds
mcgeer
rowadd
binarily
ite
gebraic
fevb
decisiond
dne
jfj
evbddeval
deltafevbddeval
bahar
risen
coladd
kgk
okfdd
fromnode
decision diagrams
function graphs
binary decision
edge valued
valued binary
boolean functions
word level
complement edges
affine property
fevbddeval h0
terminal node
recursion step
rational rule
every recursion
child e
edge weights
weight normalizing
factored edge
w f
nonterminal vertex
two fevbdds
recursively affine
computation cache
vertex f
gcd rule
lai et
integer linear
logic verification
scalar multiplication
matrix multiplication
node 0
arithmetic functions
multiplicative weight
using fevbdds
additive property
n gammak
function graph
boolean function
new node
memory consumption
non isomorphic
arithmetic operations
boolean operations
c f
o jf
f child
linear programming
top variable
f 6
fevbdd node
affine matrix
fevbdd representing
o jhc
column designators
f rulei
fevbdd representation
affine transformation
e f
matrix representation
multiple precision
f e
computational complexity
multiplicative weights
terminal case
arithmetic function
matrix inversion
matrix package
input signals
certain operations
matrix multiply
jhc f
conversion rules
matrix add
spectral transforms
ev w
single terminal
evbdd representation
multiplicative edge
directly represent
chapman kolmogorov
max field
evbdds additionally
weights allows
assignment f
evbdd representations
make new
evbdds 14
hc f
hc fi
termwise operations
fevbdds however
normalizing rules
row swapping
precision fractions
function decomposition
ev f
reconverging branches
pseudo boolean
fevbdds since
kolmogorov equations
normalizing rule
non sparse
complexity o
w g
generated using
jf j
operation op
maximal element
x n
three calls
moment diagrams
binary moment
topology except
edge valued binary
valued binary decision
binary decision diagrams
f and g
every recursion step
child e f
factored edge valued
terminal node 0
g are isomorphic
child t f
lai et al
integer linear programming
x n gammak
holds that fevbddeval
calls to matrix
evbdds and fevbdds
denotes the arithmetic
nonterminal vertex f
vertex f 2
recursively affine matrix
o jf j
class of matrices
f x n
multiplication of two
representation and manipulation
numerator and denominator
weights allows us
compared to evbdds
g then let
o jhc f
based on evbdds
weight normalizing rules
proposed by lai
based on fevbdds
complexity o jf
f and w
introduction of multiplicative
solving the chapman
weight normalizing rule
complexity of apply
make new node
f 6 c
f child e
fractions of arbitrary
multiplicative edge weights
satisfy the affine
word level function
chapman kolmogorov equations
based on function
binary moment diagrams
integer valued functions
verification of arithmetic
us to directly
array of boolean
time complexity o
lemma 3 1
ordered binary decision
method was proposed
modeling of conditional
terminal node 1
concept of complement
types of vertices
function with complement
represents the constant

corpus/krapavin2000-test/628733.txt
canny
operator
tangential
operators
image
curve
responses
combinators
statue
curves
continuity
discontinuities
derivatives
edge
maxima
oe
tangent
fi
vision
respond
derivative
logical
intensity
convolution
noise
nm
stabilizers
neighbourhood
response
zucker
psi
ae
gaussian
preconditions
ff
steerable
discontinuity
ending
gamman
cross
neck
edges
smooth
signal
normal
dcf
receptive
curvilinear
nearby
visual
images
xi
fig
orientations
lateral
gammag
positively
endline
michelangelo
junctions
categorize
perceptual
steven
behaviour
inflection
orientation
evidence
detectors
region
endings
koenderink
fingerprint
rising
centered
sign
dimensional
detection
convolutions
creases
ideal
eq
differentiable
spatial
locating
smoothing
field
peak
stable
junction
near
structural
discontinuous
contrast
differential
unstabilized
striate
hildreth
conveying
confusion
linearity
coincident
regions
attenuation
lim
cartesian
gaussians
equivalences
dubuc
terminations
xii
haralick
benoit
positives
false
algebra
fulfill
boolean
drawing
verified
overshoot
signalled
linearities
oval
cortex
salience
filters
chin
salient
grouping
curvature
stably
shoulder
stimulated
marr
sensitivity
crossing
gaps
negative
interfere
contour
profiles
family
exhibit
critically
extremum
intensities
folds
bifurcation
adopt
measurement
locally
confirmation
sectional
contradictory
iff
decomposing
examination
slope
stabilized
cat
revealed
complement
hypothesis
eqs
heat
contextual
criterion
pixels
symmetrically
singularities
crossings
song
early
drawings
pointwise
responding
biological
lines
noisy
deliberately
centroid
relied
rejection
around
additive
designs
zeroes
contours
detector
neural
figs
l l
l operators
image curve
l operator
logical linear
image curves
linear operator
canny operator
linear operators
contrast line
l combinators
line ending
one dimensional
negative contrast
positive responses
line operator
cross section
local maximum
step edge
end line
positive contrast
dimensional operator
image operators
operator responses
contrast lines
normal condition
fi oe
l x
linear reduction
local continuity
tangential operator
edge operators
component responses
half field
b canny
oe x
steven w
w zucker
fi x
maps computed
false positive
edge detection
edge maps
fi 0
vision v
operator psi
curve operators
gammag 00
derivative fi
curve types
gamman 3
dimensional operators
dimensional l
positive response
linear convolution
dimensional signal
differential structure
respond positively
line stable
see fig
computer vision
oe ae
local maxima
spatial support
receptive field
early vision
two dimensional
image structure
l image
normal conditions
visual system
p j
steerable filters
linear l
noise sensitivity
l edge
l combination
inflection points
line endings
signal fi
structural preconditions
line drawing
line like
line detectors
curve ff
image line
linear combinators
responses represent
perceptual grouping
ae approximate
second derivative
ae x
zero crossing
structural conditions
measurement operators
boolean algebra
minimal polynomials
b figure
additive gaussian
iff ff
l l operators
l l operator
l l combinators
canny s algorithm
lines and edges
maximum in fi
one dimensional operator
false positive responses
positive contrast line
contrast line operator
edge maps computed
steven w zucker
computed by b
f p j
computer vision v
operator is centered
negative contrast line
image curve operators
negative contrast lines
end line stable
edge and line
dimensional l l
l l image
one dimensional signal
oe ae x
algorithms are run
g i g
algorithm and c
f l x
c l l
journal of computer
logical linear combinators
l operator psi
signal fi x
operators both algorithms
normal and tangential
two dimensional operators
detail of statue
l l edge
logical linear operators
also a local
l l combination
one dimensional l
logical linear l
linear l l
dcf of l
curve with normal
near a step
derivative fi 0
p j x
analysis and machine
transactions on pattern
machine intelligence v
b c figure
intensity variation along
linear on f
operator responses represent
confusion between lines
g 00 operators
show the edge
low order differential
sense of three
confusion and perceptual
positive operator responses
zucker complexity confusion
convolution by g
kinds of image
fi 0 oe
one dimensional normal
operator s response
expected image structure
minimal polynomial p

corpus/krapavin2000-test/629420.txt
tet
tpg
tets
ray
consumer
producer
quadrant
lcet
blocking
rooted
lcets
terminating
tpgs
congruent
vertex
shootray
semaphore
numrecords
petri
fig
synchronization
slope
timed
shooting
rays
fl
segments
receive
green
horizontal
deadlocks
processes
upgs
subtrajectory
findalltets
segment
infinite
transition
nets
blocks
interprocess
buffer
axis
blocked
deadlock
transient
constraint
send
npaths
maxnpaths
branchless
dssp
lies
plane
semaphores
quadrants
vertical
progress
intersects
diagonal
iff
vertices
homotopic
visualization
arc
phi
program
dead
programs
geometric
cartesian
units
forever
nondeterministic
axes
disk
trajectory
exclusive
resource
lipski
findfreepoints
freepoints
net
hyperplanes
race
periodic
mutually
cycle
red
visual
concurrent
preceding
subpath
oe
od
thick
exclusion
repetitions
deterministic
figs
mct
carson
jjf
color
read
directed
vernon
transitions
colored
records
zg
rectangle
bounding
firing
reynolds
safety
meeting
transaction
final
mutual
spent
optionally
duration
reachable
lines
serially
papadimitriou
labeled
outgoing
restate
roman
cox
gi
initialize
locked
intersect
buffers
block
execution
synchronizing
followed
visualizing
arrangement
reusable
portion
outcomes
grey
terminates
abstractthrough
subtrajectories
jed
bottomg
shaffer
soisalon
impli
hfoe
deadlocked
upg
findnonblockinglcets
magott
edgesg
utp
tripathi
erability
marking
locking
jj
quantities
geometrically
brackets
fg
generators
simultaneously
paths
constraint line
point g
initial point
g 0
non terminating
tets rooted
g 00
possible tets
initial quadrant
process 0
terminating programs
line instance
slope one
non blocking
final point
tet rooted
constraint lines
producer consumer
f d
ray rooted
diagonal ray
computational geometric
line segments
l f
process 1
infinite length
n th
tpg h
progress graph
one ray
ray shooting
f o
code segment
time units
read send
performance properties
cartesian graph
vertex labeled
timed progress
blocking lcets
write y
petri net
infinite number
line l
y write
compute f
line segment
d g
continuous path
fig 3
program execution
consumer program
problem p2
shootray l
terminating program
directed continuous
never blocks
blocking lcet
problem p1
read x
f g
petri nets
h phi
rule ii
synchronization operation
program state
g c
g g
two processes
periodic behavior
synchronization points
graph model
p empty
tpg determine
time 4n
tet ray
th send
ii case
output process
terminating producer
spent blocked
blocking tets
consumer write
green vertex
second tet
solve p1
one tet
bounding line
horizontal ray
geometric performance
right bounding
program fig
time assumption
tets recall
tet contains
producer process
fig 6
cycle time
point 0
case 2
r 2
synchronization point
yet executed
model corresponding
color g
race condition
execution trajectory
return g
od figure
p operation
graph contains
one vertex
rooted at g
constraint line instance
non terminating programs
slope one ray
f d g
fig 3 c
given a tpg
point g 0
write y write
corresponding to fig
y write y
set of tets
one ray rooted
computation of f
producer consumer program
intersects a constraint
shootray l f
timed progress graph
directed continuous path
initial point g
compute f d
number of tets
possible tets rooted
g g 0
lines in fig
fig 3 b
g 0 g
final point g
right bounding line
two possible tets
computational geometric algorithms
transition function f
computational geometric problem
time spent blocked
thus the tet
process 0 process
tpg h g
tet is non
terminating producer consumer
vertex for point
graph model corresponding
point 1 1
g and final
non blocking tets
producer and consumer
h g c
output a representation
x from consumer
phi g c
another constraint line
f o g
top or right
n th send
ray with initial
exactly one tet
rule ii case
geometric performance analysis
process 0 blocks
h phi g
x from disk
fig 13 b
o and f
g 1 1
number of repetitions
horizontal and vertical
point 0 0
x or y
one buffer producer
fl we write
point 25 31
two conditions corresponding
exclusive resource access

corpus/krapavin2000-test/626722.txt
precision
mlp
bits
jamming
retrieving
learning
neural
neurons
eq
decimal
layer
neuron
rounding
propagation
weight
variance
squared
truncation
hidden
weights
propagated
bit
nonlinear
perceptron
error
statistical
forward
oe
activation
dive
chops
errors
training
ffl
calculation
curve
regression
operators
convergence
squares
fx
statistically
descent
hardware
updating
derivatives
derivative
delta
layers
evaluations
compound
finite
stages
lowest
alippi
dives
eqs
multilayer
operator
ij
sign
cesare
chopped
fffl
network
gradient
multiplication
propagates
fffi
stage
inputs
evaluated
undertaken
truncating
affine
central
interleaved
successive
contributing
sigmoid
random
ratio
silicon
outputs
xor
uniformly
converges
artificial
fw
formulated
sums
attained
seok
unwisely
jammed
delgado
wffl
vassiliadis
propensity
yongsoon
pizer
hiddens
stamatis
briozzo
truncated
xy
simplified
update
invoking
analytical
learn
discrete
sources
taylor
fy
trained
indicator
propagating
approximated
multiply
synaptic
fpga
frias
luciano
soft
ffi
back
accuracy
divert
bum
wx
precisions
momentum
fyg
lations
foe
accumulator
th
vlsi
disturbance
dallas
dating
ko
leaning
dashed
backward
devoted
degradations
guideline
intermediate
generates
vs
sigmoidal
simu
versatile
connecting
predicted
output
concluding
interconnecting
systolic
converge
download
electronics
iterative
limit
drastic
inability
caused
unified
employed
mac
manipulations
intent
wseas
products
surface
impact
summed
finite precision
precision computation
forward retrieving
precision error
calculation graph
back propagation
statistical evaluation
propagation learning
ffl y
random variables
weight updating
error generated
neural network
independent random
error ffl
lowest order
average sum
precision analysis
weight bits
precision errors
eq 9
discrete random
output delta
y i3
one sign
successive operators
hidden delta
bit value
precision ratio
ffl x
weight update
average squared
limit theorem
central limit
propagated error
sign bit
r th
bit 3
simplified notation
bits assigned
total finite
new lowest
normal curve
truncation jamming
delta computation
ffl 1w
precision hardware
convergence stage
statistically evaluated
bit weights
evaluation values
output layer
network algorithms
j g
regression problem
curve shows
order bit
l j
hidden layer
different stages
partial derivatives
statistical properties
ij g
gradient descent
generates error
range 08
ffl w
th neuron
squared figure
back propagated
network converges
fx l
bits average
q lowest
learning convergence
descent search
transformation interleaved
layer mlp
high precision
r 02
ffl oe
possible error
th layer
squared difference
bits one
th place
actual outputs
artificial neural
random variable
ffl 3
low precision
order bits
output neuron
error values
uniformly distributed
y y
affine transformation
multilayer perceptron
activation values
layer perceptron
activation function
four different
oe 2
using high
iterative learning
rounding techniques
precision weight
y j0
evaluated average
layer weights
training pattern
values fx
similar partial
retrieving phase
input errors
finite precision error
finite precision computation
back propagation learning
mean and variance
independent random variables
finite precision analysis
finite precision errors
l j g
one sign bit
finite precision ratio
stages of learning
neural network algorithms
central limit theorem
total finite precision
new lowest order
statistical evaluation values
convergence and accuracy
lowest order bit
high precision computation
sign bit 3
number of bits
desired and actual
retrieving and back
four different stages
gradient descent search
bits average squared
bit 3 bits
q lowest order
affine transformation interleaved
possible error values
bits one sign
average squared figure
decimal with range
r th place
lowest order bits
output delta computation
notation is shown
using high precision
finite precision hardware
error ffl y
fx l j
weight bits average
back propagated error
shows the statistical
r 02 3
due to finite
two independent random
discrete random variable
discrete random variables
sources of error
given in eq
artificial neural networks
nonlinear activation function
precision error ffl
first hidden layer
jamming and rounding
derivative evaluations using
mlp four different
weight bits finite
probability therefore 1
computation of back
jamming or rounding
precision error analysis
values fx l
updating error ffl
products of independent
bits of weights
weight updating error
say k bits
fffi l j
properties of independent
dashed curve shows

corpus/krapavin2000-test/628975.txt
dependence
subscripts
coupled
array
hyperplane
references
loop
cone
hyperplanes
intersects
dimension
plane
planes
subroutines
intersect
el
directions
parafrase
supercomputing
dimensions
parallelization
eispack
dependences
equations
wolfe
loops
interprocedural
bounds
vectorizer
canonical
min
solutions
inequalities
parallelizing
numerical
indices
motzkin
coefficient
fortran
inner
residues
dimensional
restructuring
geometrical
subscript
intraprocedural
yunheung
restructurer
iia
restraints
examined
obvi
lp
sign
parallelized
difficulties
convex
hoeflinger
paek
weng
supercompilers
marina
diophantine
ip
valued
tests
subscripted
jay
ind
independence
york
notices
wu
angles
ously
arrays
multiprocessors
subdomain
chu
nonempty
transformations
disjoint
checking
supercomputers
packages
outermost
testing
sigplan
unclear
simplex
max
cross
jan
lemma
chih
innermost
subsystems
chung
empirical
ping
analyzer
thousand
conservative
tested
boun
iic
xiaofang
baowen
jingke
zhongqiang
karmarkar
daries
minjoong
lilja
coefficients
massive
parallelism
direction
programs
lemmas
equalities
consistency
subsystem
ordinary
detect
hundred
pipelined
region
integer
lambda
lu
examination
spice
separatedly
tzen
ishfaq
itpack
iib
sects
maydan
fishpak
lee
csur
examining
boundaries
compilers
symbolic
equation
compiler
intersection
eigensystem
junjie
knowns
followings
rim
uniformization
hennessy
gyungho
sharma
interconnection
chang
fourier
simultaneously
areas
iterations
rare
chen
compile
spaces
examines
automatic
kwong
kwang
sadayappan
yew
privatization
ahmad
iid
bacon
monica
dror
residue
package
viewing
data dependence
l test
l 1
dependence directions
array references
f l
loop bounds
coupled subscripts
dependence analysis
l 2
intersects v
l plane
dimensional array
dependence direction
every l
l planes
el 1
l cone
integer solutions
r 2
loop indices
multi dimensional
v min
f el
numerical methods
min f
y line
coupled dimensions
linear combination
l set
l m
r m
l tests
canonical solutions
y equations
intersect v
earlier numerical
improvement rate
dependence test
additional time
v max
r 1
y equation
common solutions
f equation
equation corresponds
r n
j j
dimension j
valued solutions
exact data
inequality consistency
f equations
existing numerical
hyperplane p
plane intersects
l region
canonical solution
dimension algorithms
fixed l
inner loop
dimensional arrays
subscript expressions
m space
m equations
proof follow
dimension test
program restructuring
v j
linear function
direction vector
iteration dependences
consistency checking
data independence
program parallelization
f line
real valued
new algorithm
linear programming
determine whether
practical cases
ordinary programs
cross iteration
j 0
supercomputing p
j 1
u j
single dimension
half spaces
two half
real programs
loops r
fourier motzkin
whole r
dimension approach
parallelization restructurer
deciding linear
constant lower
interconnection complexity
loop residues
valued solution
f plane
common loops
computing loop
f l 1
l 1 l
dimensional array references
data dependence analysis
defined by loop
multi dimensional array
dimension by dimension
well as dependence
every l 1
v is defined
f el 1
called a l
bounds as well
l 2 l
case of 2
min f l
r 2 space
called a y
earlier numerical methods
hyperplane in r
line in r
equations in 3
l 1 v
r 1 r
called a f
based on inequality
fixed l 1
definition the equation
equations and inequalities
exact data dependence
l plane intersects
existing numerical methods
min f el
boundary of two
inequality consistency checking
line then f
f i j
conference on supercomputing
function of l
dependence direction vector
l 2 v
multi dimensional arrays
cross iteration dependences
two half spaces
dimension j 1
j a j
two dimensional array
real valued solutions
distributed systems v
transactions on parallel
within the loop
parallel and distributed
intraprocedural and interprocedural
divide r 2
restructuring for high
two coupled dimensions
upper bounds u
dependence of multi
computing loop residues
given a line

corpus/krapavin2000-test/628768.txt
thermophysical
truck
scene
thermal
surface
lwir
tank
imaged
energy
invariants
hypothesized
imagery
temperature
object
image
car
steel
elemental
feature
vehicle
invariant
contextual
material
cnd
vehicles
van
radiation
recognition
separability
measurement
reflectance
hypothesis
hypotheses
capacitance
null
emissivity
amb
mistaken
heat
infrared
pose
thermo
visible
wheels
invariance
features
erroneous
gi
absorbed
rear
polymer
coatings
driving
separation
physics
volume
afosr
conductance
irradiation
convected
cv
scenes
determinants
metal
ti
frame
intra
vectors
conics
solar
sensed
wavelength
photometric
materials
outdoor
eqn
visual
centered
air
rad
st
absorptivity
radiative
polypropylene
radiometric
vulcanized
stability
compose
2d
deviations
images
hypothesize
geometric
surfaces
fluxes
conduction
rubber
phenomenological
conductivity
atmosphere
wind
formulation
conducted
incorrect
panels
wheel
inter
subspace
transformation
elimination
algebraic
flux
vegetation
tai
counting
lost
buildings
identity
labeled
internal
region
formed
consisted
calibrated
deltax
dt
ith
infinitesimal
contract
vision
measurements
exchange
normals
objects
exploited
five
matrices
3d
abs
minimally
span
front
sensor
composition
derivation
vary
variation
deviation
conservation
military
illumination
alarm
spectrum
ratios
ambient
shading
orientation
histogram
circuit
interior
classifiers
freedom
diversity
precomputed
shape
establish
coordinates
reflection
stereo
unknown
relationships
pyranometer
emissive
plastic
albany
resistances
mundy
season
thermally
reputed
polystyrene
dts
sheet
gramm
groundwork
uncoated
unoxidized
insolation
truck 1
null space
feature value
space vector
thermophysical properties
imaged object
invariant features
object recognition
scene conditions
correct hypothesis
four points
lwir image
contextual support
elemental volume
w cnd
thermophysical model
truck 2
inter class
object class
class separation
thermal capacitance
unit surface
invariant feature
image region
one scene
measurement vector
energy exchange
object centered
intra class
physics based
surface area
type i2
lwir imagery
tank tank
invariant relationships
van car
unknown vehicle
counting argument
n points
per unit
erroneous hypotheses
measurement matrices
real imagery
material properties
measurement vectors
points labeled
energy per
image measurements
mean value
f k
object identity
thermal image
scene parameters
imaged surface
thermophysical algebraic
correctly hypothesized
like polymer
hypothesized data
driving conditions
energy absorbed
deviations away
tank van
car truck
hypothesized object
different material
incorrect hypotheses
hypothesis truck
feature consisted
surface reflectance
centered reference
correct hypotheses
second scene
mistaken hypothesis
thermophysical feature
thermophysical invariants
type feature
thermophysical approach
two point
object classes
standard deviations
contextual knowledge
non visible
formed using
different scenes
algebraic invariants
geometric invariants
space vectors
first scene
object properties
five points
vector j
linear transformation
consistency constraint
2d object
feature values
eqn 8
point set
physical properties
reference frame
theta 5
region r
truck 1 truck
null space vector
scene to scene
per unit surface
feature of type
unit surface area
thermal and visual
energy per unit
f k r
tank tank tank
truck 1 data
correctly hypothesized data
scene to another
object centered reference
null space vectors
tank van car
labeled in figure
hypothesis truck 1
using the thermophysical
respective other vehicles
van car truck
invariant to scene
2d object centered
consisted of point
truck 2 9
inter class separation
standard deviations away
identity and pose
value is formed
feature is applied
image region r
described in section
points are selected
used to establish
car at locations
reasonable to use
energy exchange model
space vector j
center coordinate frame
correct hypothesis hypothesis
inter class separability
derivation of thermophysical
image actually obtained
object class k
compose a 5
transforming the coordinates
measurements are obtained
given by transforming
figure 1 energy
formulation of feature
type feature used
feature f k

corpus/krapavin2000-test/607573.txt
markings
rs
pn
reachability
marking
rg
hn
transitions
ln
net
nets
pns
kronecker
rgs
places
aggregated
petri
lns
regions
invariants
transition
reachable
firing
tokens
coloured
macro
st
plates
subnets
spns
matrices
enabled
compositional
belt
incidence
successor
sect
hierarchical
producer
gspn
bordered
consumer
agg
gspns
cpn
cpns
fflt
lt
arcs
region
symmetries
compact
ut
zz
generation
hierarchy
hierarchically
boolean
invariant
en
structured
matrix
xh
tnr
conveyor
trivial
fired
subvectors
uncolored
spn
subnet
covered
superposed
radix
successors
od
stochastic
synchronized
obdds
aggregation
reduction
internal
crane
consumers
additionally
substituted
argumentation
place
production
vectors
stubborn
elevating
pastor
ord
numbering
unreachable
isolated
runtimes
metal
bags
consecutively
exploration
cell
na
huge
combinations
jv
composing
analogously
obdd
prop
ffl
effort
oe
arc
induction
characterize
lcm
feeding
nh
interleavings
buffer
merged
robot
polygons
sequences
decomposed
theta
thetan
belonging
markov
hashing
structuring
live
representations
projection
assures
mb
shaded
ri
generate
considers
jsj
minimal
partition
nb
reg
submatrix
versa
cpu
fig
subsequently
experiences
fulfill
conquer
obviously
preserving
vice
handled
row
exploitation
consequently
priori
asynchronously
omitting
delta
omega
aggregate
realized
clarify
workstation
reachability set
extended net
rs j
rs pn
rs h
reachability graph
p invariants
h pn
reachability sets
reachability analysis
level net
rg generation
kronecker representation
marking m
minimal regions
ln j
reachable markings
set rs
structured rs
petri nets
generate structured
local transitions
macro marking
macro markings
rs hn
generate rs
aggregated places
non trivial
n ffl
q h
place p
petri net
hn marking
successor marking
kronecker operations
p invariant
trivial regions
marking x
generated reachability
rg h
rg pn
successor markings
invariant computation
state space
reduction rules
incidence matrix
st st
hierarchically generated
component rgs
aggregated description
level nets
complete rg
zz n
p agg
low level
initial marking
running example
linear combinations
analysis approaches
production cell
m 0
compact representation
gspn models
aggregated marking
hierarchical reachability
preserving reduction
lt j
compositional analysis
behavior preserving
new places
place bordered
marking y
aggregated place
n r1
j x
high level
net n
possible transitions
space generation
m x
integer vector
complete reachability
internal behavior
g rs
synchronized transitions
identical reachability
characterize rs
kronecker product
mixed radix
extended nets
complete net
rs h pn
generate structured rs
rs and rg
number of markings
high level net
generated reachability set
reachability set rs
low level net
rg h pn
markings in rs
number of regions
non trivial regions
zz n m
covered by p
low level nets
hierarchically generated reachability
m 2 rs
rs j x
p 2 p
extended net n
set rs j
size of rs
size of rgs
subset of transitions
place p 2
covered by positive
representation of rs
behavior preserving reduction
enabled in marking
number of aggregated
state space generation
number of non
g rs j
hierarchical reachability graph
representation of rg
marking m 0
n r1 n
place bordered subnets
generate and represent
set and reachability
reachability graph generation
marking of ln
markings and possible
enabled in m
extended low level
generation of rs
projection of rs
transitions between markings
c or d
transition t 2
methods for efficient
analysis of large
n 0 r
st st st
effect of transitions
transitions t 2
stochastic petri nets
number of places
b is defined
set of transitions
set of output
theory for coloured
places p1 gamma

corpus/krapavin2000-test/608242.txt
controllability
controllable
lie
subalgebra
ad
jordan
sachkov
subsec
metabelian
ls
sp
bj
diml
codimension
invariant
solvable
spectrum
algebra
jurdjevic
kupka
eigenvalues
ae
gamma
hypersurface
eigenvalue
groups
semidirect
yu
gl
geometrically
sigma
bilinear
nilpotent
group
operator
matrix
subgroup
rank
adjoint
attainable
matrices
adbj
sallet
vectorfields
eigenspaces
subalgebras
oe
spaces
span
phi
proposition
saturation
corollary
algebras
lemma
commensurable
bonnard
complexification
gauthier
fi
sufficiency
ff
item
plane
coinciding
sec
kalman
quotient
violated
rb
iff
definiteness
root
virtue
nonzero
motions
hypotheses
bravo
blocksb
dimg
levi
cocompact
lawson
realification
mittenhuber
hilgert
lille
agrachev
subspace
conjugate
decomposition
connected
semi
purely
ayala
reductive
semigroups
preimage
sufficient
necessity
additionally
contradiction
globally
adjoined
compact
lemmas
fields
subspaces
analogously
russian
connectedness
cos
determinant
products
vector
cyclic
top
dirk
passage
dynamical
covering
omega
sin
affine
linearly
sl
tc
radical
subgroups
author
identity
raw
chain
chains
fft
nonnegative
theta
satisfied
remark
principle
corollaries
perturbations
jacobi
items
lim
cl
dimensional
bases
subsection
professor
dim
psi
cone
euclidean
multiplicity
crouch
eigengalue
coresponding
erard
sussmann
acces
sibility
fondamentale
assoudi
bornard
complexifications
tirao
stipend
nonuniquely
polysystem
subsemigroup
subsemigroups
brockett
homotheties
hautus
semisimple
operators
jth
spanned
ffl
inclusion
dc
homogeneous
geometric
base
right invariant
ad c
controllability conditions
system gamma
l 1
invariant systems
lie algebra
group g
operator ad
ls gamma
bj l
algebra l
lie group
lie groups
ae l
yu l
l sachkov
simply connected
sp 1
ad bj
c b
l 2
ad b
controllability condition
sufficient controllability
rank controllability
codimension one
space l
solvable lie
system sigma
groups g
conditions 1
vector b
g m
geometrically simple
lie saturation
necessary controllability
v jurdjevic
span x
control systems
subsec 4
hypersurface principle
gl n
adjoint operator
attainable set
jordan base
n pair
real n
r n
following conditions
lie algebras
gamma oe
invariant system
root space
globally controllable
simple spectrum
one subalgebra
purely complex
diml 3
ae ls
lie subalgebra
theorem 1
sec 2
subsec 5
lemma 3
l containing
containing b
l ae
plane r
vector space
adbj l
spectrum sp
semi simple
jordan chain
g sallet
systems gamma
c bj
cyclic spaces
bilinear system
metabelian lie
conditions 30
derived subalgebra
connected lie
invariant vector
kalman condition
compact group
n pairs
e 2
bilinear systems
ffl real
vector fields
single input
n theta
lemma 5
lemma 4
definition 3
finite dimensional
r ae
theta n
corollary 2
l 6
condition 6
b 6
complex spectrum
mathematical control
input systems
simple lie
algebras l
ad c b
right invariant systems
b a 0
controllability of right
lie algebra l
yu l sachkov
sufficient controllability conditions
ad bj l
gamma is controllable
group g m
bj l 1
c a 0
lie group g
ae l 1
operator ad b
l 1 c
rank controllability condition
space l 1
subalgebra of l
ls gamma oe
necessary for controllability
adjoint operator ad
lemma 5 1
gamma on g
codimension one subalgebra
sigma is globally
lie a b
operator ad bj
operator ad c
right invariant system
conditions 1 2
lie groups g
solvable lie groups
l 2 c
ae ls gamma
l 2 r
f l 1
n theta n
l 6 l
l ae l
ad c bj
kupka and g
simple and semi
controllable on r
geometrically simple spectrum
group of motions
controllable on g
adbj l 1
c bj l
necessary controllability conditions
gl n r
l 1 b
invariant vector fields
l 2 ff
proved in subsec
exists a codimension
k y k
l 1 ae
j a 2
l i 2
following conditions hold
x k y
l 1 r
used in theorem
introduce the notation
conditions 1 3
theta n matrix
gamma 1 diml
spaces of ad
j p gauthier
bonnard v jurdjevic
g e 2

corpus/krapavin2000-test/635251.txt
crossings
crossing
vertices
heuristic
heuristics
hamiltonian
neural
flcnp
mplan
bisect
page
drawing
greedy
graphs
edges
cube
len
subgraphs
embeddings
layout
planar
hypercubic
book
bisection
vertex
pagenumber
bruijn
edge
ccc
gr
displays
cq
hq
interconnection
fmt
udb
dyn
pages
neuron
embedding
tq
crossed
hypercubes
layouts
hypercube
torii
flq
wbf
neurons
ran
italic
sx
pub
excitatory
vlsi
xed
pk
books
circulant
embeddable
dimension
hamming
cycle
thickness
folded
recalculation
aside
uv
adjacency
dier
stacks
cycles
networks
opt
bisected
toroidal
fen
kautz
conjectured
st
positioned
branch
subgraph
rcd
insignicant
outerplanar
labelled
twisted
inhibitory
rst
nc
pm
cross
complexities
network
cpu
greedily
butter
dierent
predetermined
plane
recurrence
iterations
star
rad
versatile
cr
nd
optimally
permutations
motion
drawn
jl
nding
specied
rank
density
eight
dg
wrapped
inline
link
loop
tied
comput
torus
architectures
simulator
arc
convergence
optimality
minimization
node
dm
par
embed
regular
ordering
plot
formed
3d2
planarization
unxed
mostb
poorest
runing
embeddding
circulants
ubd
lution
mcculloch
cnmgrafmyampersandmdash
subhamiltonian
conected
alphaserver
eggleton
cnmgraf
topologies
ik
bounds
sorting
readability
brie
orderings
embedded
adjacent
deviation
handbook
eective
pendant
discernible
discouraged
nervous
headings
connectivities
diogenes
pancake
shue
dwarfed
supergraph
undetectable
deviated
undirected
signicant
diagrams
exact
exceeds
solutions
spine
ipping
crossing number
node line
e len
test graphs
d vertices
gr ran
programming heuristic
planar crossing
number problem
linear crossing
exact algorithm
neural network
dynamic programming
hypercubic networks
de bruijn
dyn bisect
greedy gr
len 1
link edges
mplan e
page drawing
page dyn
ran mplan
bisect neural
graph drawing
d 1
book crossing
complete graphs
initial upper
q d
random graphs
o m
greedy heuristic
hamiltonian cycle
optimal solution
vertex ordering
fmt italic
crossing minimization
xed linear
pub fmt
regular figure
hamming cube
test graph
linear layout
network heuristic
book embeddings
st d
maximal planar
crossed cube
bisection heuristic
one page
two pages
put aside
smallest increase
edge density
upper bound
network model
graph layout
layout problems
layout problem
bound algorithm
l g
connected cycles
optimal solutions
graph g
cube connected
crossings obtained
bit binary
fixed linear
heuristic results
graph 30
positioned along
smaller subgraphs
cq d
vertices 00
d bit
book thickness
neural found
crossings number
tq d
page embeddable
network graphs
upper page
ccc d
page heuristic
vertices along
embedding graphs
neural figure
lower page
global upper
pk d
sequential simulator
hamiltonian order
sx d
crossings found
hq d
k n
parallel computation
optimal vertex
crossing numbers
greedy heuristics
heuristic based
average rank
graph size
motion equation
interconnection networks
minimum number
theoretical bounds
partial solution
vlsi design
base cases
edge length
dimension d
planar graphs
star graph
m 2
adjacency matrix
number of crossings
along the node
d of dimension
crossing number problem
dynamic programming heuristic
planar crossing number
linear crossing number
e len 1
len 1 page
gr ran mplan
greedy gr ran
dyn bisect neural
ran mplan e
mplan e len
page dyn bisect
initial upper bound
book crossing number
o m 2
pub fmt italic
d has d
d 1 edges
neural network heuristic
d has 2
embeddings of graphs
neural network model
cube connected cycles
d 1 2
increase in crossings
xed linear crossing
optimal vertex ordering
regular figure 5
global upper bound
graphs in books
bisect neural figure
d bit binary
o n 4
branch and bound
d is formed
pair of edges
ordering of vertices
found the optimal
drawing of g
vertices are adjacent
edges are added
number of vertices
embed the edges
books a layout
heuristic gr ran
cr i k
fixed linear crossing
phase are added
graph was 84
arc in one
ik and jl
vertices 00 0
linear and book
exceeds the current
opt greedy gr
two greedy heuristics
vertices i j
pages are necessary
neural and e
found by heuristic
sorting using networks
motion equation loop
page embeddable graphs
bisect and dynamic

corpus/krapavin2000-test/627645.txt
connectionist
neuronal
microfeature
connectionism
inferences
reasoning
neural
plausible
vague
structuring
fuzzy
expert
massively
mundane
athematics
neurally
echanical
athematical
ghalwash
similarity
defence
pdp
analogical
possibilistic
chunking
inference
recency
desiderata
samuel
commonsense
skill
robotic
feedforward
backpropagation
ind
multilayer
logic
brain
marker
facilitated
integrating
replica
domains
sensible
abstractin
society
discrete
chan
engines
linguistic
parsing
memories
inheritance
deduced
learning
logics
coming
acquisition
associative
satisfaction
theories
semantically
similarities
utility
conceptual
incorporating
engine
concepts
inspired
mixed
networks
connecting
incorrect
primitives
rules
refinement
encoded
intelligent
universal
core
evidence
symbolic
recognition
bases
plays
intelligence
designing
frame
interaction
links
accordingly
passing
enable
proving
probabilistic
adaptive
matching
principle
december
carried
network
continuous
beyond
levels
approximate
rule
selection
dependent
role
produces
november
nodes
modeling
concept
constraint
march
engineering
features
illustrate
propose
representing
explicitly
group
account
ieee
transactions
representation
conclusions
domain
scheme
z
one
r
introduction
tr
b
via
parallel
theorem
knowledge
examples
context
able
w
models
theory
consists
useful
research
sets
take
level
application
applied
presented
important
k
ctr
data
system
several
many
first
paper
v
neuronal models
discrete neuronal
structuring knowledge
plausible reasoning
connectionist model
expert systems
massively parallel
knowledge based
associative memories
parsing fuzzy
context symbolic
dependent representation
connectionism neurally
universal backpropagation
connecting concepts
recency inference
logic marker
integrating linguistic
bases applied
accordingly examples
fuzzy logics
multilayer feedforward
parallel parsing
modeling context
microfeature based
model rules
z ghalwash
model principle
beyond associative
knowledge recognition
integrating knowledge
chan integrating
important desiderata
microfeature nodes
mundane reasoning
conceptual knowledge
networks features
systems integrating
sensible conclusions
samuel w
conclusions accordingly
networks frame
parallel constraint
incorrect rules
enable useful
pdp research
similarity plays
inheritance refinement
produces sensible
inference network
links representing
theory mundane
similarity matching
marker passing
rules connectionist
plausible inferences
adaptive brain
microfeature multilayer
athematical theory
similarities beyond
evidence designing
linguistic primitives
rules connecting
designing inference
expert networks
vague domains
echanical theorem
models chunking
frame selection
representing rules
neurally inspired
representing concepts
deduced via
model inferences
connectionist knowledge
inspired massively
reasoning incorporating
robotic skill
symbolic logic
useful inferences
ind probabilistic
reasoning massively
logics neural
connectionist scheme
discrete neural
skill acquisition
via mixed
core theory
concept nodes
incorporating rules
sets fuzzy
neural networks
connectionist expert
based replica
approximate domain
analogical reasoning
learning context
domains b
mixed similarity
based neural
explicitly encoded
similarity similarity
k chan
inference engines
neural representation
context dependent
semantically incorrect
levels one
representation ieee
commonsense reasoning
ctr z
backpropagation learning
parallel model
level based
domain theories
november december
feedforward networks
continuous domains
applied intelligence
engines based
several domains
p 201
december 1998
rule application
based reasoning
inference engine
probabilistic reasoning
many important
nodes representing
discrete neuronal models
knowledge in vague
enable useful inferences
many important desiderata
expert networks frame
chan integrating linguistic
two levels one
neurally inspired massively
p 157 175
integrating linguistic primitives
reasoning incorporating rules
logic an introduction
recognition of semantically
dependent representation ieee
parallel constraint satisfaction
model for structuring
recency inference engine
nodes and microfeature
memories the athematics
reasoning massively parallel
theory of evidence
primitives in learning
reasoning the society
satisfaction an introduction
intelligence v 9
integrating knowledge based
concepts and links
connectionist knowledge bases
inferences are facilitated
microfeature multilayer feedforward
bases applied intelligence
model of rule
vague and continuous
systems integrating knowledge
analogical reasoning massively
logic marker passing
sets fuzzy logic
possibilistic and fuzzy
society of ind
rules and similarities
matching and rule
learning in expert
facilitated and knowledge
via mixed similarity
ind probabilistic reasoning
november december 1998
parsing fuzzy sets
neuronal models chunking
group a athematical
brain in defence
rules and connectionism
semantically incorrect rules
core theory mundane
mixed similarity matching
multilayer feedforward networks
networks are universal
theory mundane reasoning
inferences the model
robotic skill acquisition
domains where similarity
networks frame selection
inference engines based
domains a abstractin
application the model
scheme for modeling
systems and neural
conclusions accordingly examples
logics neural representation
beyond associative memories
incorrect rules connectionist
parallel parsing fuzzy
similarity and analogical
athematics of inheritance
logic of plausible
december 1998 samuel
microfeature based replica
model in structuring
ctr z ghalwash
discrete neural network
neural networks features
massively parallel model
universal backpropagation learning
samuel w k
knowledge bases applied
commonsense reasoning incorporating
pdp research group
echanical theorem proving
representing rules connecting
learning context dependent
desiderata of plausible
introduction to expert
connectionism the discrete
reasoning and produces
designing inference engines
evidence designing inference
context dependent representation
model of commonsense
inspired massively parallel
produces sensible conclusions
proving the logic
r a connectionist
passing and microfeature
knowledge to enable
deduced via mixed
role in coming
modeling context symbolic
rules connecting concepts
logic and echanical
sensible conclusions accordingly
networks for robotic
p 201 215
domains b r

corpus/krapavin2000-test/1007540.txt
selector
mode
steering
robots
robot
modes
controller
team
training
teams
tournament
battery
upgraded
radio
environmental
program
saver
enemy
brightness
rand
spoofing
selectors
droid
battle
deceptive
materials
wars
attack
programmer
gps
sleep
raw
jamming
learners
laptop
coded
runs
executions
counterexamples
score
competition
unanticipated
programs
behaviors
situations
controllers
old
reboot
refactoring
unexpected
ore
allies
suite
terrain
preconditions
nearby
profile
operational
augmented
games
simulates
software
rank
matches
chooses
profiling
learner
operating
upgrades
rendezvous
army
augmentation
quantities
modalities
designers
human
daikon
damage
modeling
centralized
selecting
display
routers
adaptability
invariants
detection
abstraction
tournaments
dcpower
rebooting
ncnb
enemies
scouting
game
train
participants
messages
mit
abstractions
anomaly
alternately
bad
throws
damaged
radios
contest
refactored
unforeseen
reboots
richer
invoked
failures
wrote
optimizations
policy
additionally
ranking
anticipated
load
phones
unmodified
foresee
replay
correlating
circumstance
aliased
inputs
bugs
augmenting
hardware
generalizes
instructions
circumstances
developers
policies
switch
supscrpt
execu
wished
combat
dissipation
behaved
int
selects
bias
reflections
anticipate
worthwhile
environments
resources
augment
home
render
inclusive
vironment
attacking
particularly
creating
dc
unable
runtime
column
match
maps
learning
upgrade
utilizes
meeting
se
specialized
decomposable
base
default
switching
pick
power
environment
accommodates
selection
denial
won
month
hypothesize
indicate
transitions
applicability
poorly
abilities
coverage
expert
signal
outperformed
interference
location
mode selector
program steering
new mode
training runs
modeling step
original mode
mode selection
multi mode
battery 0
raw materials
original program
control programs
control program
saver mode
power saver
change rand
program original
battery 1
mode selectors
original upgraded
standard mode
upgraded change
robot control
program state
droid wars
deceptive gps
change simulates
environmental changes
hard coded
new maps
column gives
new environments
selector may
environmental change
sleep mode
machine learners
old mode
old one
operating conditions
test suite
invariant detection
hardware failures
new controller
value profiling
current program
per mode
mode power
steering technique
original programs
laptop display
profile directed
radio spoofing
original controller
radio jamming
steering process
new environment
operational abstractions
resulting models
operational abstraction
dynamic invariant
training data
target system
run time
different modes
applying program
selector chooses
increased resources
mode transitions
centralized intelligence
among modes
systems built
mode program
mode brightness
require designers
controller augmentation
dc power
random mode
original environment
brightness battery
mode software
mode system
mode sleep
signal strength
interactive program
directed optimization
video games
called program
appropriate mode
anomaly detection
code coverage
program states
sub optimal
method calls
selecting among
machine learning
new mode selector
original mode selector
original upgraded change
robot control programs
battery 1 0
power saver mode
upgraded change rand
program original upgraded
battery 0 2
old mode selector
environmental change simulates
mode selector may
current program state
standard mode power
program steering process
program steering technique
mode power saver
new mode selectors
dynamic invariant detection
systems built using
sleep mode brightness
profile directed optimization
multi mode software
mode sleep mode
using such approaches
mode brightness battery
interactive program steering
called program steering
mode selector chooses
multi mode system
changes in operating
augment the original
saver mode sleep
random mode selector
applying program steering
software controlled radios
specification based analysis
program steering might
model and scheduling
change rand radio
use of self
optimization and synthesis
good respectively bad
object to render
round robin tournament
use the new
represents a mode
invokes the new
steering program steering
bibliography of interactive
efficiently under normal
droid wars competition
accommodates unexpected performance
may also indicate
instance a particular
information to assist
dissipation and signal
among existing modes
program steering tool
induced by reflections
computing value profiling
data by running
battery 0 0
weights to different
chooses a mode
lines column gives
selects the mode
state program steering
teams with centralized
pair of teams
selector is richer
range of changes

corpus/krapavin2000-test/631174.txt
conversion
units
meter
radar
conversions
dimension
meters
numeric
kilogram
glisp
si
dimsizes
simplifyunit
unit
convert
mass
coercion
altitude
dimvals
kilograms
dimint
quantity
lisp
aircraft
vip
simplification
quotient
foot
pound
feet
compiler
loveman
relpos
joule
karr
force
dimbias
decimal
measurement
converted
numerator
newton
diff
atlas
novak
integer
checking
temperature
books
substance
multiplication
eme
pounds
gasoline
utm
gallons
watt
volt
quantities
denominator
unequal
arithmetic
radians
dimensions
energy
factors
powers
shaft
syst
gldefun
money
reuse
languages
programmer
integers
sz
idl
legitimate
field
encoding
composite
synonyms
vectors
overflow
acre
centimeter
cunis
kilowatt
slug
metrication
dimensionless
comet
cutm
gev
horvath
ounce
horsepower
newtons
parsec
incorrect
subtraction
symbolic
sqrt
converting
generic
lists
expansion
east
triangle
ada
multipliers
encoder
tables
nil
motion
compile
multiplied
constants
angle
physical
utexas
nano
flattened
inch
synonym
english
procedures
language
unusual
syntax
pulse
simplified
physics
fig
mega
kinematics
floating
automatic
arguments
division
factor
multiply
menu
book
ontology
pi
atm
abbreviations
specification
compiled
software
base
tradition
transmission
scalar
source
accuracy
ftp
hour
packages
kg
strict
dimensional
verified
particle
gordon
dividing
measurements
validating
product
bit
sorted
allowable
runtime
requested
vector
returned
hypotenuse
calculators
raya
luminosity
overlook
defderivedunits
cliche
glcoerceunits
tarun
nanosecond
fahrenheit
farad
schulz
hilfinger
tablespoons
ampere
conversion factor
unit conversion
second second
dimension integer
conversion factors
dimension vectors
dimensional analysis
base units
dimension integers
source unit
dimension vector
meter second
si system
unit conversions
units real
desired unit
numeric conversion
unit simplification
simple unit
unit system
input unit
time diff
loveman 15
pound force
meter meter
generic procedures
integer encoding
standard unit
programming languages
dimension checking
corresponding dimension
real meters
include units
kilogram meter
base quantities
composite unit
automatic coercion
altitude radar
unit checking
bit integer
field size
numeric values
factor f
unit systems
units integer
si units
numeric type
abstract unit
unit must
hand argument
convert units
goal system
new unit
simplifyunit joule
mass units
glisp language
numeric quantity
numeric constant
two products
eme international
x units
dimint v
equivalent combination
radar angle
simple units
goal units
product lists
syst eme
software reuse
units must
conversion algorithms
type specification
generic procedure
per unit
data types
one unit
result type
addition subtraction
output unit
units of measurement
second second second
conversion of units
system of units
combination of units
units as part
karr and loveman
numeric conversion factor
meter second second
numerator and denominator
units real meters
checking and conversion
unit to another
conversion factor f
quotient of units
unit for example
shown in fig
units in programming
inclusion of units
coercion of units
product or quotient
conversion from mass
factor and dimension
convert any combination
quotient of two
terms of base
syst eme international
conversion is legitimate
combinations of units
kilograms to meters
kind of unit
unit is meter
source and goal
speed of light
number of units
conversion and one
making a new
meter meter second
dimint u dimint
expressed in si
sin function may
meter meter kilogram
quantities and units
integer 2 pi
atlas language 5
gallons of gasoline
time diff aircraft
unit conversion may
one scalar operation
units when necessary
x units real
multiply or divide
languages allow coercion
units for example
use of units
unit for conversion
units the dimension
part of data
diff aircraft altitude
left hand argument
example the dimension
altitude radar altitude
b if unit
subtraction and comparison
result of nil
real meters y
half the input
conversion may also

corpus/krapavin2000-test/1012676.txt
metering
secret
clients
realizing
sharing
corrupt
audit
schemes
server
servers
agency
qualified
lsss
frame
client
coalition
visits
gamma
visited
frames
ker
parties
secrets
ideal
visiting
access
web
pinkas
ads
optimality
ae
secure
advertising
sigma
dealer
stinson
jc
participant
shares
initialization
auditing
visit
pricing
naor
mappings
rate
lssss
nishizeki
coupons
auditable
brickell
explication
monotone
money
participants
surjective
gf
absolutely
sites
advertisers
ito
lightweight
proofs
saito
jackson
capital
dv
substructures
simmons
bounds
lncs
duals
accounting
letter
shamir
subsets
receives
security
reconstruct
algebraic
indices
threshold
scheme
pi
assisted
jf
distributes
received
cardinality
dim
log
attained
nuovi
lighweight
misure
nuove
compartmented
karchmer
ecnica
leichter
aplicada
donate
polit
sul
sicuro
attaining
departament
pubblicit
blakley
ormonotone
tigh
afterwards
random
vol
distributing
relies
interaction
benaloh
revenues
inflating
masucci
sss
reciprocally
fpr
atica
decomposition
pp
field
universitat
franklin
pooling
newspaper
matem
catalunya
enables
prime
martin
phase
besides
malkhi
wigderson
online
reconstruction
count
advised
equiprobable
jcj
sends
pay
realized
advertisements
mx
isps
geometric
share
verifiable
authorized
ffl
exposure
hospitality
constituted
oe
map
relationship
enable
fag
supremum
consult
honest
boldface
scenario
dual
restate
realizes
charged
showed
companies
kernel
jp
barcelona
collected
cn
shannon
satisfies
communication
passed
helping
family
concepts
author
spain
multilevel
spaces
secret sharing
access structure
metering schemes
sharing schemes
metering scheme
scheme realizing
sharing scheme
linear secret
structure gamma
time frame
audit agency
information rate
time frames
corrupt servers
variable associated
information distributed
access structures
schemes realizing
corrupt server
random variable
client c
corrupt clients
qualified set
optimal information
initialization phase
algebraic approach
linear map
log jc
communication complexity
linear algebraic
design metering
qualified subset
relies upon
given access
clients c
scheme satisfies
definition 2
linear mappings
new bounds
web sites
finite field
linear mapping
ideal linear
structure namely
clients x
geometric secret
phase ffl
ae c
optimal metering
threshold metering
schemes obtained
secrets p
gf q
satisfies property
scheme according
rate ae
proof p
general access
properties provide
property 2
us suppose
ae gamma
log ae
information known
vector space
information received
server receives
lower bounds
method relies
new lower
secret sharing schemes
secret sharing scheme
access structure gamma
linear secret sharing
metering scheme realizing
server s j
sharing scheme realizing
random variable associated
realizing the access
construct a metering
realizing any access
realizing an access
set of clients
metering schemes realizing
schemes and secret
optimal information rate
definition 2 1
linear algebraic approach
relationship between metering
complexity of metering
given access structure
method to construct
measure the interaction
n m c
j the random
design metering schemes
clients in x
distributed to clients
set of secrets
c s metering
j in time
upon the optimality
clients and servers
approach to design
bounds the optimality
naor and pinkas
compute its proof
gamma it holds
geometric secret sharing
absolutely no information
metering schemes obtained
schemes these properties
scheme satisfies property
provide some new
p t j
b in time
general access structures
subset of clients
servers and let
compute the proof
compute the information
method relies upon
threshold metering schemes
x 62 gamma
schemes with pricing
information rate ae
subsets of clients

corpus/krapavin2000-test/611413.txt
delay
link
probes
multicast
estimator
inferred
delays
links
packet
estimated
cumulative
measurements
sample
bin
ff
ms
bfl
traffic
inference
probe
variance
distributions
deviation
simulations
correlation
tcp
receivers
internet
udp
leaf
measurement
topology
packets
correlations
accuracy
convergence
complement
mtrace
median
tomography
foreach
unicast
absolute
tree
confidence
congestion
vs
infer
dynamics
plot
cooperation
rms
std
interior
dependence
network
receiver
differentiable
largest
fl
spatial
density
duffield
bff
binned
pathchar
estimates
independence
estimate
queueing
loss
child
asymptotically
asymptotic
converges
intervals
lag
node
simulation
queuing
branching
inaccuracies
presti
apportion
ipma
calibrating
topologies
utilization
francesco
parent
continuously
vertical
lost
logical
phenomenology
discretize
timescale
probabilities
agreement
surely
experienced
root
diagnosing
monitoring
violations
assessing
depth
internal
hop
mea
ttl
descend
ton
accrued
towsley
persistent
comprising
comprises
background
paths
grows
felix
interarrival
gamma
seconds
bandwidth
hosts
verified
capacity
suited
bottleneck
children
postpone
proportionally
shed
presence
characteristics
normalized
rate
laplace
transit
routing
load
ns
representative
losses
experience
source
spread
networking
parametric
fi
traversing
dictated
bins
diagnosis
interval
averages
variances
lo
discrete
convolution
measured
sec
ip
canonical
disabled
adopted
versus
empirical
injective
covariance
experiment
networks
predicted
estimators
vacirca
estimated link
link 1
ff k
multicast tree
delay ms
delay distribution
delay c
average delay
delay distributions
d f
vs sample
f sample
link 6
ms estimated
estimated vs
cumulative density
function delay
sample node
link delay
link 11
sample link
per link
largest absolute
cumulative delay
bin size
b ff
sample complement
end measurements
absolute deviation
link 3
logical multicast
c d
end delay
multicast based
inferred distributions
model link
link delays
distribution estimator
spatial correlation
probes link
node k
density function
multicast traffic
estimator variance
bin sizes
f k
network elements
y k
packet delay
model simulation
branching ratio
based inference
sample average
leaf delays
tcp udp
network internal
k 0
sample c
average delays
b figure
ms n
absolute vertical
link 8
minimum median
simulation topology
vertical deviation
n probes
link 9
sample distributions
actual distributions
simulations computed
inferred values
estimated distribution
median minimum
internal delay
maximum largest
continuously differentiable
confidence interval
size q
confidence intervals
link k
delay measurements
maximum median
background traffic
strongly consistent
tree depth
two leaf
statistical properties
fi k
minimum delay
measured end
common link
multicast probes
fixed delays
internal approach
interior links
delay model
udp simulations
loss estimator
largest deviation
rms normalized
link 5
asymptotically normal
different bin
normalized error
end to end
c d f
delay c d
vs sample node
ms estimated vs
n of probes
d f sample
function delay ms
density function delay
cumulative density function
estimated vs sample
delay ms estimated
f sample complement
b ff k
logical multicast tree
largest absolute deviation
delay distribution estimator
probes link 1
delay and loss
number of probes
cumulative delay c
link 1 estimated
b a k
source to leaf
estimated link 1
sample c d
inferred and sample
ff k 1
per link delays
bin size q
link by link
values in f0
link 6 estimated
inference of network
ff k 0
link 1 sample
estimated link 11
average delay ms
multicast based inference
estimated link 6
link 11 estimated
maximum median minimum
absolute vertical deviation
largest absolute vertical
topology of figure
rate of convergence
sample average delay
presence of temporal
y k l
estimated and sample
deviation in 100
k 2 v
gamma a 1
y k m
presence of spatial
rms normalized error
k 1 b
delay ms n
links as function
computed over 100
link 1 link
cumulative delay distributions
cooperation of network
tcp udp simulations
different bin sizes
maximum largest absolute
network internal delay
presence of significant
f k 0
k 2 u
function of n

corpus/krapavin2000-test/628679.txt
affine
gramian
frames
eq
shape
acquisition
motion
invar
depth
camera
invariant
images
perspective
discrimination
orthonormal
coplanar
similarity
frame
image
pose
trajectories
multiframe
matrix
coordinates
aff
recognition
weak
invariance
rigid
unfamiliar
origin
factorization
fifteen
frm
criterion
qr
transformations
tracked
views
cholesky
distortions
dotted
centered
singular
calibration
overconstrained
quadratic
object
curves
projection
solid
reconstruction
columns
basis
ave
ball
submatrix
incremental
centering
transformation
3d
fig
pong
theta
umass
ponce
mms
inigo
svd
column
orientation
pivoting
ratio
matching
rows
optional
five
dashed
ground
translation
truth
rotation
definite
incrementally
ninety
residues
nonlinear
noise
isotropic
euclidean
rotational
entries
reference
periphery
discriminates
pseudoinverse
measurements
thirty
rotated
tracks
scaling
decomposition
translations
lens
extrapolation
basri
ping
representations
norm
errors
rot
feet
mn
familiar
sequences
measurement
ullman
collects
kalman
pt
viewer
orthographic
subscripts
2d
box
factorizations
angles
est
favorably
interpolation
visual
estimation
mirror
depict
lend
specifically
centroid
ranged
row
curve
stage
nonzero
subjects
poor
tracking
trajectory
matrices
coordinate
rm
vision
rotating
hajder
chequered
amherst
heuristical
rothganger
rangefinders
pocs
christy
noncoplanar
boufama
youcef
genc
perspectivity
zest
yakup
wmn
cosines
toumi
svetlana
chetverikov
markerless
necker
sixty
strikes
horaud
cordelia
reliably
vectors
avoids
dimensional
perturbation
rotations
homogeneous
gave
combinations
imaging
bad
jean
equations
sony
contaminated
basis points
weak perspective
similarity invariant
invariant representation
discrimination ratio
affine shape
good basis
three basis
shape matrix
depth computation
gramian g
five frames
theta 3
frame m
unfamiliar views
quadratic criterion
w b
shape representation
invariant shape
similarity transformations
reference system
affine transformations
gramian matrix
linear criterion
model acquisition
first frame
perspective projection
image measurements
eq 5
random sequence
three dimensional
solid curves
value decomposition
singular value
fifteen frames
frame discrimination
centered image
selected basis
rigid invar
aff invar
affine transformation
qr factorization
image sequences
matrix g
ground truth
p b
frames used
linear system
relative errors
measurement matrix
depth values
eq 7
see eq
eq 11
linear combination
affine invariant
object points
z real
matching measure
column pivoting
image trajectories
representation computed
pong ball
similarity invariance
reference origin
thirty frames
perspective approximation
curve uses
invar aff
box sequence
matching criterion
three selected
j k
poor basis
new images
dotted curves
computation using
linear combinations
positive definite
images used
dimensional coordinates
unit norm
eq 3
first five
matrix w
basis vector
model matching
truth data
ping pong
fig 2b
camera calibration
coordinate system
eq 8
depth map
similarity invariant representation
three basis points
affine shape matrix
respect to similarity
used for acquisition
frames were used
singular value decomposition
invariant with respect
combination of three
frame discrimination ratio
similarity invariant shape
depth computation using
theta 3 matrix
representation a g
z t z
points in space
sequence of images
structure from motion
curves in fig
three selected basis
invariance with respect
errors in depth
invariant shape representation
p of eq
first five frames
factorization with column
linear and incremental
selected basis points
ping pong ball
added to w
equations in 11
three dimensional coordinates
image to model
points i j
reported in 25
used for model
ground truth data
shape and motion
therefore weak perspective
determine the gramian
centered image measurements
shows the trajectories
j inigo thomas
point and compared
new orthonormal basis
discrimination ratio 1
criterion the situation
lend themselves favorably
unlike most algorithms
coordinates of points
rigid invar aff
invar aff invar
model matching measure
simple linear algorithm
compute a depth
compute a similarity
basis the solid
without camera calibration
first frame ranged
large perspective distortions
ratio 1 6
pt pose rigid
centered image measurement
ratio true random
wide lens camera
theta 3 identity
algorithms our algorithm

corpus/krapavin2000-test/1008415.txt
seat
seats
accommodating
requests
intervals
station
competitive
reservation
request
price
interval
stations
fair
passenger
accommodated
nrequests
adversary
accepted
ntimes
decit
accommodate
train
rst
randomized
late
sequences
mod
coloring
tickets
boyar
ratio
ticket
oblivious
rejected
surplus
minft
groups
joan
satised
reservations
placed
gap
fit
subintervals
group
early
alcom
bungalows
accommodates
fig
asymptotic
extra
vacation
quests
dened
prob
travels
dierent
larsen
dotted
deterministic
pricing
asymptotically
optical
programme
eu
congruent
ist
fall
calculated
ext
divisible
adversaries
sigact
jiang
fraction
tao
proceeds
processed
expects
1d
overlaps
conguration
unit
trip
people
expectations
colors
clique
dextrous
unnamed
minimums
amortization
earns
journey
knrequests
accom
bering
ucr
stee
reassign
competive
fths
lene
morten
favrholdt
income
cito
chrobak
modated
scheduling
fairness
vertical
routing
giving
kim
unsatised
ticketing
passengers
bach
nishing
reestablish
krarup
fich
purchases
faith
route
receive
tight
news
grant
concrete
denmark
earned
sold
refuse
unoccupied
wavelengths
corollary
dominates
overlap
ratios
marked
spill
traveled
purchased
line algorithm
accommodating sequences
seat reservation
unit price
reservation problem
price problem
competitive ratio
seat 1
extra intervals
o line
seat 2
k mod
first fit
optimal o
request sequence
starting station
start station
original interval
e interval
form 4s
two intervals
request r
price seat
two seats
adversary proceeds
interval 4s
intervals 6i
fair deterministic
accommodating ratio
late group
sequences proof
early groups
requests r
rejected interval
rst interval
early group
two requests
joan boyar
expected number
k competitive
fair algorithms
problem k
rejected intervals
expected fraction
interval graph
oblivious adversary
whose starting
randomized algorithms
f k
additional requests
interval 6i
original intervals
late groups
requests accommodated
end station
fair randomized
fair o
station minft
request k
three requests
asymptotic upper
requests accepted
optimal fair
ntimes ntimes
m seats
early late
associated rejected
randomized fair
upper bound
dotted line
deterministic algorithms
next interval
call control
competitive even
interval scheduling
next group
vertical dotted
theorem 3
seat reservation problem
unit price problem
o line algorithm
optimal o line
ratio on accommodating
even on accommodating
requests in u
competitive on accommodating
unit price seat
accommodating sequences proof
fair on line
price seat reservation
number of requests
sequence of requests
randomized on line
requests r 1
f k competitive
number of seats
receive the interval
empty from station
price problem k
algorithm can accommodate
fair o line
fail to accommodate
seat 1 request
minft t 1
optimal fair o
accommodated by random
problem the seat
requests are satised
accommodate all requests
whose starting station
asymptotic upper bound
k competitive even
people who want
vertical dotted line
theorem 3 1
number of people
q i seats
k mod 9k
ntimes for ntimes
algorithm will accommodate
investigate the competitive
request but fail
k mod 14k
denote the request
n the optimal
k mod algorithm
satised on seat
consists of either
fall into cases
give the request
form 4s 5
compared to n
sequences the competitive
interval which prevents
late early groups
line algorithm accommodates

corpus/krapavin2000-test/631115.txt
prover
stack
newstack
constructor
specifications
concat
rewriting
accumulator
inductive
axioms
rewrite
lemmas
const
specification
pf
stmt
constructors
recenter
pntr
equational
proofs
pop
circle
weakest
elem
precondition
annotations
verification
nat
conjunct
generic
push
chunk
larch
wp
subtype
template
termination
completeness
arguments
underspecification
isnewstack
shape
induction
double
confluence
superclass
recursive
subprogram
abstract
correctness
stripping
fertilize
accumulation
algebraic
inductions
tuples
drop
reverse
lp
fertilized
overspecification
center
chunks
subclass
inline
incompleteness
symbols
sides
theorems
inheritance
antecedent
radius
void
strategies
loop
axiom
stacks
exponentiation
skolem
axiomatize
hoare
equations
proving
confluent
array
instantiations
replaces
truth
virtual
successor
obligations
postcondition
discrepancies
canonical
expressiveness
automated
subtyping
naturals
undecidable
enumeration
instantiated
units
sufficiently
tactic
underspecified
alphard
bendix
huet
natarray
stepwise
annotate
automatically
sort
reasoning
proved
member
minimization
subclasses
power
syntactic
tasks
decrementing
induct
isempty
completion
hints
reversal
statements
designing
outermost
statement
forever
hypothesizes
exempt
implementations
manipulate
validation
return
init
max
peculiarity
monoid
unsolvable
formulas
lack
complexities
semantic
annotated
formula
postconditions
templates
verify
oriented
portions
body
flaws
underflow
boyer
tactics
annotating
obligation
permit
formal
entails
programs
instances
expressive
topmost
subterm
associative
generalization
rewritten
crucial
abstraction
concepts
program
chose
supplied
symbol
knuth
subexpression
guidance
reduction
languages
factoring
attempts
axiomatic
package
removes
public
concrete
moore
abstractions
move
power function
sufficient completeness
recursive reduction
theorem prover
term rewriting
design strategies
sufficiently complete
weakest precondition
type stack
power functions
left sides
const return
defined operations
left side
rewrite system
q pntr
program units
constructor based
equational reasoning
return center
subprogram parameters
constructor enumeration
inductive variable
theta nat
constructor terms
wp w
const point
abstract data
right side
rewriting systems
data types
data type
inductive hypothesis
virtual double
next q
generic formal
abstract properties
binary choice
inductive variables
rewrite systems
generic program
abstract class
abstract base
constructor c
proving theorems
rewrite rules
types generic
function pf
procedure pop
defined operation
syntactic properties
manipulate objects
nat theta
type shape
program components
inline void
verification tasks
recursive constructors
pure virtual
crucial properties
type induction
consistent extension
body stmt
critical pairs
stack newstack
new templates
templates one
center const
rewrite rule
example 2
object oriented
base classes
representation mapping
verification problems
inductive arguments
algebraic specifications
completely defined
program correctness
remaining arguments
type parameters
formal proofs
equational specification
actual parameters
algebraic specification
verification techniques
const return center
wp w r
abstract data types
discussed in example
canonical and sufficiently
set of tuples
term rewriting systems
combination of arguments
data type induction
new templates one
generic program units
constructor based systems
tuples of remaining
theta nat theta
nat theta nat
tuples of arguments
rewriting and induction
lack of expressiveness
complete and consistent
abstract base classes
attempt to prove
extend s 0
identity of concat
systems rewriting systems
const point c
hoare s system
tuples of constructor
new incompleteness result
reductions abstract properties
continue by cases
templates one associated
reduced to true
step is associative
replaces the selected
lemma replaces instances
calculate wp w
types generic program
recursive reduction strategies
result for hoare
shared language specifications
strategies for rewrite
operations which manipulate
using the binary
generic formal subprogram
e we replace
center const return
power function pf
function of stmt
since the sort
generic subprogram parameters
data types generic
first three instantiations
two new templates
objects of type
used to rewrite
annotating abstract base
show its application
return center y
axioms are developed
elem return elem

corpus/krapavin2000-test/1005395.txt
vel
event
individuals
verb
axioms
events
hh
history
token
nouns
episode
galton
noun
histories
episodes
quantication
davidson
axiom
calculus
temporal
tense
ai
ti
count
propositions
verbs
entities
dierent
realised
denotation
nominal
dene
prog
shoelace
punctual
allen
logic
operators
world
semantics
ontology
shanahan
hayes
logical
tokens
ctl
denable
frame
quantier
arti
sublanguages
ary
expressions
logics
dened
formalism
assigns
sconfp
gclock
formalisms
intensional
ship
mccarthy
expressive
occurrence
observable
subjective
quantied
formulae
modal
tenses
uential
propositional
action
interval
proposition
participation
perf
vocabulary
worlds
john
atomic
girls
relations
semantic
inferences
representations
reasoning
intervals
leg
obey
branching
intertia
kamp
randell
aspect
precedes
causality
tuple
index
dense
uence
truth
tuples
girl
oles
axiomatisation
fluents
vr
moller
wood
denoting
modalities
modality
tie
overlaps
obeys
eat
woman
pros
compound
modelled
specic
denitions
mcdermott
apple
causation
sergot
kowalski
myampersandldquo
language
predicate
talking
president
commonsense
identity
operator
predicates
unifying
picks
universe
settled
specically
substitute
occurrences
static
versatile
characterise
constructs
symbols
denotations
radical
nishes
governing
co
expression
incorporates
employ
suciently
indices
la
abstraction
spatial
accessibility
quantiers
extensional
strips
burns
theories
specied
nonmonotonic
relationships
syntactic
describing
phrase
meets
axiomatic
trans
entity
situation
derivable
analyses
individual
amongst
talk
meanings
combine
meaning
actions
indivindual
accidents
event types
event type
count nouns
event token
count noun
history tree
hh ti
type e
event calculus
situation calculus
index point
actual history
within vel
time points
frame problem
event tokens
index hh
vel frame
possible world
time point
world state
co realised
aspect operators
non logical
ary verb
token variable
event abstraction
n ary
time structure
logical form
type expressions
axiom system
end points
give axioms
punctual event
occurs relation
logical symbol
prog e
ai representations
event logic
static relations
vel includes
world states
galton 1984
john tie
subjective event
trans world
logic vel
nominal type
world identity
actual state
formal semantics
dierent ways
temporal relationships
con uence
partial state
hayes 1969
maximal consistent
individual concepts
every index
calculus mccarthy
logical functions
n tuples
history h
expressive power
dynamic logic
time variable
type c
h 0
m h
event occurs
ary relation
tree structure
relation holds
index hh ti
time and events
event token variable
variable a assigns
event type expressions
system for vel
tuple of individuals
event of type
n ary verb
set of individuals
subjective event types
variety of dierent
mccarthy and hayes
tie his shoelace
history tree structure
trans world identity
sublanguages of vel
action and time
theory of action
punctual event types
n ary relation
situation calculus mccarthy
kowalski and sergot
tense and aspect
really abstract concurrent
kind of quantier
non logical symbol
e g hayes
history h 0
every index point
point of evaluation
means that denotes
point an n
logic of occurrence
denotes the actual
ary verb 2
many ai representations
terms of conditions
world identity criteria
power of ctl
use the form
standard s5 axioms
form prog e
e which says
kinds of event
count noun picks
token of l
entities at dierent
verb is associated
event logic vel
stand on one
obeys the standard
temporal ordering relation
logic the frame
fully formal semantics
tuples of individuals

corpus/krapavin2000-test/1039491.txt
ld
gossip
xr
respecting
resource
disc
closest
alarm
hr
ball
astrolabe
holder
protocol
propagation
fa
temporal
message
strictly
messages
eh
monotone
node
distance
flooding
probability
discs
spreading
resources
believes
balls
disappearance
diameter
protocols
poly
learn
network
spread
pep
demers
interval
path
exponent
induction
guarantee
nodes
location
radius
completing
erent
pr
logarithmic
holders
voronoi
copy
rumor
propagated
rapidly
knows
inverse
round
polynomial
axioms
ciently
mechanisms
renesse
regimented
epidemic
paths
density
appearance
sensor
positioned
hypothesis
outdated
communicate
away
event
leaf
uniform
disappear
edge
su
scalability
partner
gossiping
transmits
nearby
quickly
held
mass
learns
metric
heard
sent
originating
events
reliability
guarantees
randomized
di
calls
region
spatial
labels
dimensions
underlying
concatenated
strengthening
claimed
subtree
closer
delay
infinite
deterministic
stamp
ancestors
plane
neighbor
piece
enter
identity
inductive
lemma
smallest
histories
communicates
dissemination
randomization
liveness
departure
labeled
filling
destination
log
propagate
communication
inform
safety
scalable
subpaths
disappearing
detours
alerted
nearest
sensors
acquire
broadcasting
vertices
logarithm
monotonically
forwards
disjoint
leaves
recurrence
choices
normalizing
exchanging
lie
hosts
origin
received
chlebus
originator
dariusz
subpath
label
bounding
service
fix
crucial
collections
qualitative
rmative
stamped
wish
send
approximation
calling
edges
reach
replicated
abnormal
kowalski
concatenate
alert
outset
traveled
transitional
lattice
rooted
bounds
passes
conjecture
phrased
bimodal
ld ld
time respecting
ld d
closest resource
resource location
temporal network
strictly time
gossip algorithm
x path
respecting path
resource holder
node x
x x
high probability
gossip algorithms
fa d
distance d
hr b
inverse polynomial
node u
least 1
d ld
respecting x
propagation time
polynomial gossip
uniform gossip
uniform density
network hr
f h
d 1
poly logarithmic
disc d
path p
h k
point sets
alarm state
nodes communicate
free x
x believes
d d
d x
h d
r d
r x
nodes x
time interval
d o
let x
containing x
function h
ball b
approximation guarantee
non monotone
new information
induction hypothesis
r ld
neighbor flooding
xr x
events f
ld 1
monotone resource
k containing
radius k
rapidly learn
underlying gossip
spatial gossip
u close
resource within
message x
log d
diameter d
g k
x r
c x
point communication
k e
higher dimensions
e e
point x
o d
two nodes
network g
path distance
x throughout
node v
n x
time step
y 3
h e
network h
location problem
message m
free path
x b
point set
simple protocol
theorem 2
lemma 2
ld ld ld
time out free
strictly time respecting
v i 1
time respecting path
time out function
x x path
least 1 ld
ld d 1
probability at least
ld ld d
time respecting x
respecting x x
x and x
temporal network hr
xr at time
contains a strictly
inverse polynomial gossip
ld d ld
d x x
contains a time
b of diameter
h k e
f h k
polynomial in log
theorem 2 1
containing both x
k e e
polynomial gossip algorithms
f h e
d ld d
d d x
resource to x
respecting path p
nodes x x
believes in xr
network hr b
distance d d
theorem 1 1
k x x
x x b
x x r
nodes at distance
close to x
resource at distance
density in r
d o d
free x x
resource at time
resource location problem
xr x path
node u close
k containing x
d with high
temporal network h
monotone resource location
events f h
temporal network g
probability in time
lemma 2 3
x to x
o log 1
x with high
log 1 d
completing the proof
two nodes x
x at time
ball of radius
let t fa
non monotone resource
disc d d
xr and x
y c x
closest resource holder
e u u
xr to x
d 1 ld
xr a resource
information is spread
x r let
node u chooses
closest resource within
f a d
radius k containing
obtain that ld

corpus/krapavin2000-test/626977.txt
tmr
rshw
rhwr
permanent
faults
voting
fault
failure
voter
redundancy
unsuccessful
faulty
probabilities
reconfiguration
rshws
voters
module
spares
modules
retry
nominal
recovery
failures
transient
phi
mnr
likelihoods
comparator
disappearance
modular
detection
fs
ovrs
ovr
occurrence
pdf
transition
km
policy
disagreement
ftmp
retries
switching
recover
triple
rollback
tolerant
vmp
microcomputer
votings
merger
markov
reliability
coincident
hardware
hours
inducing
omega
renewed
evolved
prior
fig
figs
oe
sm
transitions
spare
ij
disappear
checkpointing
chain
detected
resynchronizing
koren
watchdog
hagbae
pmn
task
recovers
detectors
bayes
kim
shin
multiprocessor
successful
nonfaulty
healthy
purging
effects
simplified
processor
simplex
replacement
caused
resynchronization
comparators
upon
restart
reload
eq
instruction
adaptive
reconfigure
resetting
overhead
buses
estimating
frequent
costs
simulations
execution
self
probability
spatial
infrequent
laplace
persistence
majority
manifest
rates
redundant
accurately
arrival
units
diagnosis
unlimited
occurrences
detecting
merged
kang
masks
likewise
tasks
allowable
occurred
estimated
prob
effective
mismatch
minimizing
ccoincident
redun
kolmogrov
kook
tfa
recoverying
jpl
rhwrs
chuck
dancy
collectors
naresh
triplicated
currence
metra
intercheckpoint
meissner
demerit
oereconfiguration
hasty
mmp
nonpermanent
byonghyo
shanbhag
cazeaux
transited
byung
mask
paths
tolerate
shift
tolerance
star
recovering
controller
recovered
erroneous
persistency
fij
hfa
daniele
rollbacks
cecilia
rail
standby
sojourn
hypercube
chip
hybrid
priori
update
gammaf
tmr failure
tmr system
permanent faults
non permanent
permanent fault
possible states
tmr failures
upon detection
task execution
unsuccessful rshw
time x
phi phi
system state
faulty module
modular redundancy
x f
triple modular
fault state
system reconfiguration
chain model
prior state
execution time
re execution
nominal task
expected cost
transition probabilities
fault states
tmr systems
spatial redundancy
switching operation
two voters
retry policy
omega omega
method 1
faulty modules
time overhead
markov chain
multiple module
voting policy
occurrence rate
rshw becomes
voting failure
simplified markov
tmr structure
voting interval
frequent voting
time redundancy
adaptive method
fault parameters
nominal execution
voter fault
rhwr based
transient faults
optimal recovery
possible fault
c ij
prior probabilities
state model
oe oe
method 2
transition matrix
bayes theorem
fault tolerant
failure detection
state probabilities
c vmp
module replacement
rshw upon
general rollback
unsuccessful rshws
module faults
x increases
one rshw
voting time
instruction retry
optimal voting
failure possible
path j
th voting
model fs
without estimating
failure increases
fault modules
fault detection
coincident faults
fs 1
fs 0
sub paths
re executed
prior states
fault occurrence
fig 3
type ii
self checking
transient fault
processing modules
expected costs
eq 3
p n
hardware cost
e gamma
rshw and rhwr
non permanent faults
task execution time
phi phi phi
time x f
cost of rshw
non permanent fault
markov chain model
nominal task execution
occurrence of permanent
execution time x
triple modular redundancy
omega omega omega
possible fault states
behavior of non
estimating the system
simplified markov chain
model in fig
number of unsuccessful
time of voting
nominal execution time
rshw or rhwr
number of spares
states at time
due to multiple
gamma 1 th
multiple module faults
caused the tmr
number of rshws
e gamma 2
increases with x
back off time
detecting a tmr
one faulty module
gamma 2 n
failure possible states
permanent fault modules
state model fs
tmr failure increases
rshw becomes larger
tmr failure detection
oe oe oe
units of time
p and r
x i2f2 5
x without estimating
detected and recovered
x f evolved
using triple modular
cost of rhwr
modular tmr multiprocessor
time and hardware
multi voting policy
type ii failure
c 1 k
ii and type
probability of permanent
re executed without
faults in different
costs of rshw
modular redundancy fault

corpus/krapavin2000-test/1038162.txt
privacy
byclass
salary
perturbed
reconstruction
attribute
randomized
training
classifier
accuracy
split
records
mining
reconstructed
randomization
gaussian
gini
width
intervals
interval
reconstruct
perturbation
reconstructing
discretization
security
disclosure
distributions
statistical
age
confidence
respondents
unperturbed
mid
distortion
willing
classification
randomizing
posterior
protection
concerns
confidential
plateau
ffl
growth
databases
classifiers
users
correcting
preserving
ipn
hyears
elevel
digitalme
passport
zipcode
attributes
density
theta
decision
hvalue
divulge
web
fx
estimated
uniform
uniformly
credit
swapping
categorical
risk
secure
tributes
iid
estimate
partition
tree
denominator
statistics
fy
suppression
queries
partitioning
induce
marginally
inducing
cumulative
distribu
realizations
splits
surface
perturbations
quantifying
pr
noise
axis
person
query
bias
mutually
sensitive
estimates
belonging
record
ip
lies
database
stopping
successive
goodness
sanen
impetus
hesitation
wor
cranor
tomasz
resounding
hallway
fundamentalists
protective
omniscience
freebies
diligently
imielin
buried
trainingdata
doxes
zipcodes
jorma
economist
truste
infrence
classifi
missioner
dominantly
randomize
ldv
aggregations
dissociation
seal
snoopers
discretized
cubes
preventing
empirically
estimator
precision
closer
bayes
original distribution
decision tree
split point
privacy level
statistical databases
split points
data mining
perturbed training
training data
original data
privacy preserving
records attribute
randomized data
value original
original byclass
byclass global
value distortion
accuracy privacy
growth phase
classification model
original randomized
accuracy original
level original
original accuracy
tree classifiers
density function
attribute value
interval width
theta 2ff
induce decision
individual records
reconstruction procedure
privacy protection
reconstruct distributions
ffl may
theta oe
credit risk
candidate split
local algorithms
random variable
true value
value x
statistical database
certain fields
perturbed data
mid point
privacy concerns
uniformly chosen
theta w
uniformly distributed
x lies
true values
functions 2
classification accuracy
distribution function
data value
f 0
entire range
data swapping
privacy levels
iid random
perturbed value
ffl byclass
theta salary
disclosure occurs
reconstructing original
accuracy numbers
successive estimates
gini index
adding noise
distortion return
five split
privacy offered
disjoint mutually
protection measures
global accuracy
gini split
z ipn
reconstructed distribution
age 25
preserving methods
original distributions
query restriction
using perturbed
tree classification
preserving data
fields ffl
tree growth
data records
value drawn
privacy gaussian
users privacy
value class
find five
decision surface
randomized number
randomized reconstructed
global randomized
gaussian provides
distributions separately
preserving privacy
family includes
net users
records belonging
partial disclosure
salary 50k
reconstructed data
online privacy
randomizing function
quantifying privacy
successive queries
c confidence
tree classifier
uniform perturbation
look easy
interval i p
amount of privacy
byclass and local
value original randomized
records attribute value
perturbed training data
accuracy privacy level
original byclass global
attribute value original
accuracy original byclass
privacy level original
reconstructing the original
number of records
decision tree classifiers
cannot be estimated
density function f
willing to provide
interval of width
estimated with 95
data by class
close to original
values of certain
partitioning the data
number of intervals
function f 0
level original accuracy
original randomized number
induce decision tree
distribution we consider
theta w 0
certain fields ffl
query e g
original randomized reconstructed
advantage of reconstruction
privacy at higher
value distortion return
reconstructing original distribution
result of inducing
original data even
point of interval
tree growth phase
privacy the algorithms
decision tree classifier
realizations of n
privacy preserving data
shows the privacy
original accuracy privacy
five split points
confidence any closer
points on salary
develop accurate models
byclass global randomized
privacy preserving methods
using the reconstructed
decision tree using
decision tree classification
posterior distribution function
estimate the posterior
true value cannot
building decision tree
reconstructed data ffl
theta 2ff 0
byclass global accuracy
global accuracy original
value class membership
axis the accuracy
privacy protection measures
ffl we approximate
preserving data mining
inducing the classifier
pr 0 x
distribution and stop
class and reconstruct
value x lies
using randomized data
random value drawn
split the training
correcting for randomization
find five split
fields ffl may
candidate split point
number of points
p i e

corpus/krapavin2000-test/1035549.txt
ow
balanced
permutation
knapsack
mixing
walk
permutations
weights
fw
items
uniform
hyperplanes
uniformity
unif
sm
fpras
balance
multicommodity
pr
poly
rst
weight
hyperplane
prw
plainly
dene
denition
jw
wy
hypercube
cm
xed
wx
stage
ja
strongly
ik
fake
mix
vertices
paths
cube
interleave
intervals
exp
padded
almost
polynomial
sums
su
random
jlj
berkeley
item
satises
counting
ows
carrying
lie
sampling
markov
sevast
hoeding
yanov
grinberg
truncated
exponent
remark
ciently
symmetric
indices
event
uctuations
dened
route
walks
fix
chains
cq
specied
ju
combinatorial
projections
geodesic
aggregated
z
quoted
technical
ces
stages
dimensions
path
lemma
cardinality
rapidly
specically
probability
shall
contribution
rapid
feasible
vertex
quantity
claim
2d
coordinate
move
ng
edge
ratio
conditioning
complications
periodicity
dimension
vectors
rearranging
symmetrically
jsj
enumeration
sign
truncation
bounded
geometric
bg
spread
delete
onto
segment
kg
encoding
bottlenecks
plugging
uniformly
holding
converges
solutions
monte
bn
capacity
sketch
trick
hall
ingredient
intermediate
jv
nothing
dierence
dimensional
variation
nonetheless
polynomially
probabilities
goodness
stay
diaconis
xand
jxy
xwith
uctuate
ysimultaneously
truncations
contruct
6dc
1do
permution
deceptively
3dc
esh
permanents
persi
steinitz
xy
index
likelihood
email
geometrically
cubes
signs
interval
carlo
almost uniform
balanced almost
uniform permutation
random walk
mixing time
uniform permutations
ow f
knapsack problem
weights fw
balanced permutation
pr unif
stage 2
permutation 2
z 0x
let fw
poly n
ow along
z 0
multicommodity ow
z w
z k
good ow
d balanced
almost uniformity
balance property
balance condition
ratio case
bounded ratio
random permutation
p d
e p2
every k
x y
strongly balanced
ow carrying
ik ik
symmetric random
rapidly mixing
index order
f z
pair x
y 1
uniform distribution
q 1
cm 1
uniformity property
feasible solutions
encoding z
rapid mixing
wx wy
computing j
edge z
stage 1
partial sums
g q
x 1
o n
xed number
j k
unit ow
cube f0
k 1
variation distance
arbitrary weights
almost uniformly
pairs x
range 1
r d
k m
c 0
multiple hyperplanes
true element
processing random
knapsack solutions
m wx
knapsack capacity
though see
m uniform
onto v
balanced permutations
rst q
symmetric dierence
satisfy 25
interleave 1
arbitrary vertices
carrying path
padded sequence
wy k
strongly cm
given edge
hypercube f0
dimension d
x fig
vertices x
l f
constant c
let 1
constant b
su ciently
d m
balanced almost uniform
almost uniform permutation
almost uniform permutations
x to y
u a r
balanced with respect
ow from x
fw i g
path from x
bounded ratio case
e p2 z
walk on g
range 1 b
cm 1 2
permutation 2 sm
symmetric random walk
f i g
set of weights
g q 1
fpras for computing
encoding z 0
element from h
j k 1
edge z w
move to x
bound the ow
ik ik ik
theorem 2 1
cube f0 1g
c 0 d
pair of vertices
number of items
z k 1
pair x y
along the path
theorem 5 2
theorem 3 3
theorem 6 3
let x y
wy k 2
number of hyperplanes
construction of balanced
z 0x m
permutation in sm
sm is balanced
wx wy k
poly n j
pre processing random
stage 2 paths
unit ow along
multicommodity ow f
k 2 z
unit of ow
contribution to f
m wx wy
strongly cm 1
k with 1
ciently large m
c d balanced
items from x
uniformity condition 2
rst q 1
q 1 intervals
strongly balanced permutation
sequence in 19
ow carrying path
hypercube f0 1g
processing random walk
along any edge
weight of x
z k z
see the remark
exp 2 2
uniform random permutation

corpus/krapavin2000-test/637371.txt
iag
tiam
lb
interval
gradtest
minimizers
casado
sergeyev
martinez
rejected
ya
intervals
minimizer
univariate
multiextremal
garcia
nal
monotonicity
rangeup
tg
gradient
lipschitz
tm
inclusion
dierentiable
enclosure
evaluations
ualm
funct
subintervals
subdivision
rejection
elimination
derivative
cut
working
division
bounding
novgorod
nde
nfe
minflb
nizhni
deis
midpoint
objective
termination
optimization
fx
mail
slopes
criterion
fg
shortened
minimization
slope
nishes
boxes
continuously
fullled
save
traditional
bounds
subdivided
numerical
accelerate
spain
graphically
davinci
diago
vink
jamartin
mdashlthe
ministerio
almera
educacion
fulll
cultura
fxnv
iron
xnv
leo
cutotest
lagouanelle
maxff
calabria
csendes
tibor
kite
hendrix
yaro
russia
miro
unical
igo
rule
sin
es
lists
evaluated
graphical
inma
rende
fsg
della
nonsmooth
universita
rst
stored
realization
satised
branch
isi
disposition
lling
tams
hereinafter
comment
head
global
cicyt
subregion
subinterval
arithmetic
piece
bottom
speedup
margins
optimiza
dierent
graphs
cnr
column
louis
fig
criteria
electronics
return
yellow
basics
gures
bridging
initialization
elaborated
depict
rejecting
bisection
blue
selection
tests
else
newton
adaptively
initializing
inherit
built
search
si
stopping
signicantly
eliminated
dened
colored
jointly
lb x
support functions
interval x
interval analysis
f x
global optimization
x lb
support function
x f
z x
new support
analysis global
m x
global minimizers
f z
hand graph
intervals x
f 0
g casado
working list
garcia j
d sergeyev
monotonicity test
ya d
f m
gradtest procedure
cut o
objective function
division rule
f lb
o test
nal list
tm tg
global minimization
gradient test
inclusion function
global minimizer
test functions
gradient information
x g
iag algorithm
traditional interval
rule line
save fx
nal lists
bound f
l g
minimization algorithm
new interval
interval v
using gradient
w x
list q
dierentiable function
information 1
lower bound
function f
list l
optimization algorithm
lower bounds
bounding rule
analysis support
univariate functions
x line
fx f
algorithm iag
tiam algorithm
search information
ualm es
f f
continuously dierentiable
problem 1
elimination rule
contain global
function evaluations
rst derivative
x 2
new algorithm
interval arithmetic
better lower
selection rule
e mail
condition f
global minimum
algorithm using
ordering criterion
minflb x
two subintervals
interval evaluations
interval function
lists line
iag right
lb c
enclosure f
return q
tiam left
rangeup test
univariate global
termination rule
x stored
real range
see lower
multiextremal univariate
bound global
information iag
nizhni novgorod
subdivision point
o tests
algorithm nishes
clearly shown
satised line
multiextremal test
elimination rules
analysis interval
lipschitz global
global search
algorithms tiam
analysis branch
g __
f minflb
bottom graphs
f __
inclusion functions
works almost
left hand
f 0 x
x lb x
f z x
f m x
interval analysis global
f x f
j a martinez
casado i garcia
ya d sergeyev
new support functions
martinez and ya
l g casado
bound of f
using gradient information
lb x f
global minimization algorithm
tiam and iag
global optimization algorithm
cut o test
lb x lb
left hand graph
x is used
problem 1 1
f lb x
working list l
traditional interval analysis
analysis global minimization
working and nal
nal list q
lb x g
information 1 2
table 4 2
new interval analysis
analysis global optimization
x and f
x over x
continuously dierentiable function
dierentiable function f
figure 2 1
lower bound f
select an interval
paper a new
new support function
contain any global
algorithm using gradient
m x f
z x g
minimization algorithm using
contain global minimizers
fx f x
global optimization algorithms
right hand graph
interval analysis support
bound f z
x from 2
bounds for f
figures 4 1
x f z
z x lb
value of f
objective function f
function d x
number of interval
theorem 2 2
function f x
figure 3 1
point x 2
x 2 x
see for example
algorithms for function
way to calculate
develop more powerful
interval analysis branch
accelerate the search
x for f
hand graph algorithms
x s f
cut o tests
c of f
f f v
set of multiextremal
tiam left hand
support functions using
graph and iag
interval in r
x on x
lipschitz global optimization
set to f
test when f
f minflb x
functions for multiextremal
functions are based
presented the new
iag right hand

corpus/krapavin2000-test/1017794.txt
fft
fun
rets
dir
bind
staging
monadic
staged
rap
circuits
fftw
liftcm
generators
zy
circuit
abstract
optimizations
retn
ys
rec
metaocaml
lit
zx
interpretation
mg
merge
floating
xs
multiplication
conc
multiplications
hardware
posteriori
double
float
stage
exp
ret
platform
expressivity
maybevalue
fpgas
safl
languages
resource
additions
reconfigurable
ta
monads
code
generator
sv
duplication
configurable
annotations
manifest
mvconc
quotations
tukey
unstaged
cooley
verilog
ruby
ms
verifying
programmer
deployment
ocaml
concretization
mv
untyped
generation
fragment
constructs
operator
quadrant
fourier
abstraction
escaped
codelets
emir
csh
hardwarec
hml
hydra
herrmann
typed
language
brackets
avoids
unnecessary
tagged
static
haskell
realizable
avoiding
style
arithmetic
comprehending
asts
kiselyov
microarchitectural
inspecting
pi
escapes
cbn
subtractions
expressive
literal
bool
val
combinatorial
bindings
match
cf
temporaries
datatypes
cos
correctness
mult
specialisation
oleg
computations
recurrence
concrete
aware
library
verified
trivial
operators
programmable
naively
boundedness
safety
datatype
butterfly
interfaces
express
christoph
gcc
ensuring
functional
transform
generic
viz
worlds
variant
discriminate
mul
intensional
guarantees
programs
unity
lift
int
losing
gate
else
compiler
verification
sa
refinements
classifiers
imaginary
seeking
reusable
abstract interpretation
generated code
double double
let rec
bind rets
x z1
fun x
mg l1
rap languages
bind mg
code value
bind liftcm
floating point
multi stage
input vector
resource bounded
hardware description
deployment platform
staging constructs
aware programming
monadic style
resource aware
y fun
combinatorial circuits
complex arithmetic
type system
bind f
y ys
posteriori optimizations
match l1
dir n
dir l1
configurable computing
manifest interfaces
b _
fun zx
zy b
fun z1
exp dir
fun zy
multiplications additions
point multiplications
zx bind
efficient circuits
fft function
rec mg
static type
fast fourier
abstract type
development platform
xs y
power n
code fragment
generation time
languages provide
abstract domain
x x
x xs
code duplication
partial evaluation
second stage
description languages
cooley tukey
mg xs
retn v
stage computation
rets zx
type circuit
liftcm retn_va
tukey recurrence
look inside
programming rap
generated circuits
stage programming
fft circuits
concrete type
b rets
minimal example
specific optimizations
generated programs
else l
ys j
x exp
circuit realizable
monadic sharing
liftcm retn_v
zy bind
merge dir
dir y0
merge ms
staging annotations
reconfigurable hardware
monadic library
fft ms
fft dir
merge mv
ys bind
fft algorithm
fourier transform
domain specific
type systems
xs ys
list length
code type
program generators
single assignment
complex number
abstraction mechanisms
hardware design
j y
one one
rap type
mvconc x
fun y
code resulting
connect operator
trivial operations
generated computations
double double double
x z1 fun
mg l1 l2
resource aware programming
use of abstract
fast fourier transform
dir n j
zx bind rets
language for hardware
xs y ys
zy b _
fun zx bind
let rec mg
floating point multiplications
match l1 l2
fun z1 bind
x xs y
dir l1 let
zx a zy
rec mg l1
n j y
hardware description languages
y ys bind
cooley tukey recurrence
xs ys j
zy bind mg
b rets zx
y fun z1
bind mg l1
j y fun
mg xs ys
generated by fftw
bind mg xs
b _ rets
programming v 62
rets in bind
multi stage programming
avoid the generation
fun a b
bind liftcm retn_v
dir y0 y1
aware programming rap
bind liftcm retn_va
l if list
j 1 fun
ys j 1
domain specific optimizations
fun zy bind
generate the code
number of floating
x x x
computer programming v
section 2 1
science of computer
avoiding code duplication
advantage of configurable
round off errors
languages are primarily
power n 1
rec power n
x fun x
single assignment programming
use abstract interpretation
circuits by refinement
treat the tool
embedding a microarchitectural
int __fun_def double
solutions in configurable
else x power
language within haskell
bind f e
e fun y0
rets sub_s x
space and functional
add staging annotations
x power n
non standard run
complex arithmetic functions
mapping a single
circuits are correct
defined as let
fun y bind
exp dir pi
l in bind
bind rets mult_s
o fun y1
staged fft function
known at generation
language to reconfigurable
x any 1
l else l
array of four
sound reduction semantics
computes the fft

corpus/krapavin2000-test/631158.txt
jobs
sites
eg
underloaded
overloaded
queuing
site
underload
sharable
ol
queue
ul
overload
sharing
job
load
rommel
transferred
usefully
intensity
plbs
coefficient
traffic
plots
bulk
arrival
transform
balancing
probability
sums
eq
homogeneity
distributions
disciplines
vs
binomial
plotted
designers
arrivals
expectation
service
queues
melman
nul
ohio
underloads
expression
homogeneous
random
livny
formula
il
normal
expressions
peak
conditional
analysts
combinations
singhal
normality
normalized
potential
varied
markovian
ith
attains
interpretations
across
rb
cpus
accept
observation
fluctuations
transfer
tends
identically
law
transforms
numerical
simultaneous
rewrite
professor
observations
success
peaks
systsems
trinomial
tul
backlog
shivaratri
supportive
implementers
gratefulness
nagaraja
coefficients
insight
shall
independence
comprising
denominator
discipline
rate
polynomial
ineligible
krueger
nol
staunch
mukesh
distribution
putting
tend
cumulative
pieces
sriram
director
imbalances
profitably
insights
summation
event
quantify
researched
unimodal
tol
bz
approximations
probabilities
shared
bimodal
equiprobable
lightly
extrapolating
feasibly
overloads
exceedingly
iyengar
sanity
happen
likewise
excess
truncating
informatics
sharper
clarity
geometric
negative
stochastically
obtainable
recursions
plot
markov
quantity
jack
instances
arrive
improvement
calculated
medicine
shift
readily
modeled
serviced
encouragement
laplace
summand
invert
noteworthy
striking
truncation
nl
queued
indebted
specialize
integers
predict
middle
wherever
college
accurately
curves
definitions
wasted
anticipated
recursive
measures
potentially
exact
seldom
capacity
keeping
derivable
attain
communications
kth
transferring
confusion
load sharing
sharable jobs
j c
traffic intensity
queue size
random variable
job sharing
sharing coefficient
z transform
m 1
queuing models
m x
x m
vs r
underloaded sites
m m
eg vs
probability distribution
p g
mean number
overloaded sites
theorem 1
following expression
size distribution
conditional random
p ol
p ul
independent instances
general formula
distributed system
load balancing
m d
across sites
definition 13
random variables
overloaded site
bulk size
job arrival
negative binomial
balancing success
ith power
system parameters
l h
g 0
queuing model
n l
h increases
exact expressions
g k
system performance
observation 7
overall system
three queuing
j sites
n ul
variable q
job transfer
usefully transferred
il k
important queuing
success plbs
particular queuing
n ol
queuing disciplines
total underload
c vs
transferred jobs
size random
various combinations
d 1
observation 8
following expressions
distributed computing
system designers
probability distributions
definition 12
transform methods
negative random
system denoted
transferred across
service time
arrival rate
exact expression
number of jobs
x m 1
number of sharable
distribution of g
m 1 queue
m 1 case
m m 1
m x m
potential for load
job sharing coefficient
theorem 1 b
l and h
m d 1
eg vs r
queue size distribution
p g k
n 1 l
eg and j
load balancing success
probability of load
expression in theorem
plots of eg
overall system performance
values of r
compute the probability
conditional random variable
transferred across sites
size random variable
important queuing models
using this expression
sites are normal
d 1 queue
calculated from definition
including a general
normal or underloaded
overload and underload
n l h
ul and p
random variable q
p g 0
usefully be shared
c vs r
j c vs
sharing in distributed
need for load
q i l
arrival and service
small or zero
balancing success plbs
queue is given
job arrival rate
usefully be transferred
obtain the following
negative random variable
distributed computing system
g n 1
non negative random
computing the distribution
distributed computing systems

corpus/krapavin2000-test/631072.txt
shielded
exceptions
handler
exception
resume
fp
strict
psml
functional
handlers
gerald
esc
handling
shield
terminate
raised
axiom
languages
subexpressions
strictness
exceptional
object
lazy
effecting
ascii
notations
propagation
prioritizing
constructs
association
alex
subexp
isv
persistent
hyper
ml
objects
referential
hx
primitive
module
semantics
cure
laws
shielding
programmed
raises
phi
activation
transparency
runtime
algebraic
deterministic
yemini
hfunc
liberated
negate
law
lastly
signals
axioms
raising
invoker
backus
reeves
circled
partially
fl
id
asc
actors
unanticipated
embed
abnormal
illegal
berry
style
propagates
append
fault
composition
behaves
firewalls
incorporating
priorities
signal
undesired
invoked
vi
handled
embedding
neumann
imperative
ad
identity
applicative
iii
res
transfer
proach
inhibited
bad
iv
retry
retaining
normal
axiomatic
commutativity
string
detected
functionals
successes
programmer
author
von
deals
conventional
atom
active
tolerant
fully
zee
curable
broadened
cured
sume
ceptions
defni
anurag
takeshi
influx
dler
ogasawara
micronet
minimalistic
bretz
ffitl
edo
nicholl
conflict
operating
preliminaries
grams
forms
language
raise
concise
null
tolerance
vii
invocation
flow
discard
treating
hideaki
shields
ald
ule
indeterminate
germane
negates
nate
wadler
expository
prioritizes
nakatani
komatsu
toshio
namei
sequentializing
ger
transforms
enforcing
unexpected
completion
conversion
insert
operator
canada
henceforth
proposals
software
retain
lan
regained
exception handling
resume exceptions
non strict
shielded objects
functional languages
resume exception
input object
exception e
strict functions
functional forms
shielded object
object x
terminate exception
handler functions
handler function
exception handlers
fully shielded
partially shielded
terminate exceptions
primitive functions
active domain
defined exceptions
deterministic behavior
psml 6
exception objects
activation point
system defined
fp functions
esc e
hyper strictness
handler h
using axiom
ad f
fp programs
gerald 9
ml 7
control transfer
referential transparency
strict semantics
function f
handling constructs
new constructs
algebraic properties
x e
functions operating
completely shielded
exception object
prioritizing exceptions
introduce hyper
exception values
association point
alex 3
persistent nature
add subexp
identity domain
level exception
incorporating exception
fundamental conflict
choice operator
axiom 2
runtime test
lines similar
select function
function id
mathematical properties
lazy functional
identity function
algebraic laws
input objects
functional programming
standard ml
software fault
control flow
execution model
handling construct
expression oriented
conventional view
e isv
signal bad
backus fp
axiomatic treatment
hyper strict
functional lan
fl language
select tail
transforms non
form hx
tolerant tools
exception name
non persistent
treat exceptions
fp program
embedding exception
handle bad
exceptions however
invocation chain
non strict functions
properties of functional
terminate and resume
functions and functional
means of effecting
system defined exceptions
exception handling constructs
effecting a control
partially shielded objects
notations for exception
e is raised
laws of fp
functions into strict
semantics of fp
fully shielded object
introduce hyper strictness
view of exceptions
functions of fp
lower level exception
handlers in functional
handling in fp
non strict semantics
like the identity
exception is raised
software fault tolerance
domain of f
values to handle
completion of h
construct for functional
notations for programming
list of successes
handlers in fp
dynamic invocation chain
fault tolerant tools
transforms non strict
reeves et al
strict with respect
model of yemini
raises a resume
functional or applicative
expression oriented language
provides an exceptional
string of numbers
incorporating exception handlers
exceptions in functional
bad by x
view of treating
exception is allowed
control flow oriented
priorities to exceptions
using axiom 2
system defined exception
deterministic program behavior
runtime test b
partially shielded object
exception e isv
x 0 terminate
exceptions are raised
partially or fully
conventional control flow
yemini and berry
completely shielded objects
parallel execution model
nature of exception

corpus/krapavin2000-test/1016897.txt
ospf
heurospf
routing
unitospf
arcs
arc
invcapospf
flow
utilization
worldnet
phi
jxj
weight
capacity
randomospf
demand
tabu
opt
backbone
waxman
shortest
weights
canonical
capacities
destination
neighborhood
max
hashing
clause
diversification
mpls
paths
demands
loads
splitting
packet
evenly
satisfiable
oblivious
inapproximability
load
hardness
uncap
going
traffic
units
zegura
routings
links
psi
hash
cycling
heuristic
fx
np
calvert
cisco
internetworks
congested
flows
commodity
settings
outgoing
heuristics
splits
zemel
optospf
woodruff
search
literals
synthetic
recommended
rodrigues
router
collisions
internet
escape
descent
astad
dijkstra
leading
visited
projected
congestion
clauses
graphs
glover
optimizing
setting
assignment
leaving
inversely
ramakrishnan
moves
normalized
jjxj
aly
otchel
ffc
tecchiolli
wess
capacitated
bley
concrete
network
iv
intra
optimize
iterations
uncapacitated
resorted
awduche
jp
balancing
path
incoming
gap
goes
occurrences
rexford
evening
battiti
tables
associate
sent
exploration
sat
node
clever
proportional
gammaffi
pretty
vx
guiding
morning
stays
objective
maximal
gets
split
tx
jq
scalings
optimality
secondary
hard
nodes
spreads
sx
attributes
encountered
link
distance
fi
primes
distances
drawback
piecewise
vendor
protocol
scaled
leaf
approaching
winner
networks
cope
arriving
schemes
solutions
decrease
closer
unit
spots
jn
jennifer
universal
ff
hour
max utilization
weight setting
ospf routing
local search
canonical flow
general routing
unitospf heurospf
worldnet backbone
ospf weight
jxj units
search heuristic
p c
tabu search
shortest paths
cost function
demand matrix
invcapospf unitospf
weight settings
f x
v x
heurospf opt0
demand invcapospf
opt figure
utilization demand
heurospf opt
clause c
q x
optimal general
setting problem
function phi
weight equal
shortest path
even splitting
c fx
routing problem
normalized cost
optimal ospf
cost demand
non canonical
demand unitospf
waxman graphs
np hard
traffic flow
ospf weights
splitting flow
node u
flow corresponding
neighborhood structure
commodity flow
cost phi
packet cost
optimizing ospf
flow going
flow leads
phi uncap
satisfiable assignment
hashing tables
multi commodity
w 0
paths going
v w
single weight
cost functions
oblivious heuristics
leaving u
improving moves
non improving
destination pair
level graphs
neighborhood exploration
capacity jxj
source destination
optimal cost
u v
current solution
unit weight
level graph
intra domain
cost factor
theorem 4
bit integer
traffic engineering
units of flow
ospf weight setting
local search heuristic
invcapospf unitospf heurospf
unit of flow
max utilization demand
heurospf opt0 20
demand invcapospf unitospf
unitospf heurospf opt
unitospf heurospf opt0
heurospf opt figure
p c fx
general routing problem
cost function phi
weight setting problem
demand unitospf heurospf
x or f
x t x
optimal general routing
psi a l
multi commodity flow
utilization demand invcapospf
going through f
non canonical flow
hard to optimize
arc a 2
path p c
within a factor
optimal ospf routing
source destination pair
clause has 3
optimizing ospf weights
setting with respect
h a w
cost demand invcapospf
v x f
non improving moves
graphs in figures
graph with 50
decrease in cost
utilization demand unitospf
recommended by cisco
graph with 100
flow are sent
equal to 3
dijkstra s algorithm
hard to find
canonical flow corresponding
commodity flow routing
woodruff and zemel
concrete objective function
optimize the ospf
instance of max
evenly splitting flow
paths p c
demand matrix d

corpus/krapavin2000-test/1013757.txt
npmv
pmf
safe
nondeterministic
recursion
bellantoni
jxj
leivant
multifunctions
rm
minimization
seqbnd
dened
polymax
fp
recursive
nml
conguration
computable
thm
np
cobham
dene
denition
denable
primitive
polynomial
poly
multifunction
conp
mod
composition
brn
analog
cook
rec
accepting
srn
witnessing
oracle
register
guess
honest
instructions
mach
reject
contents
jyj
bwm
arguments
rejects
characterizations
analogy
polytime
nite
successors
denitions
bits
accept
jwj
bounded
proposition
characterization
jxjjyj
smash
honesty
ado
undened
tier
oracles
registers
weak
congurations
denes
swm
jzj
jmj
accepts
operator
hierarchy
partial
computability
selman
verication
pr
totality
dom
characteristic
kleene
induction
quantier
jej
ought
acc
jy
nondeterministically
tape
reverse
projections
transition
sharply
halts
normal
mention
enters
instruction
coding
implicit
asserts
hx
closed
reducible
prop
identied
predicate
unproblematic
totalize
tiering
ramied
shines
jnj
philosophically
balcazar
gabarro
spreen
impredicatively
maxfjajg
iaz
stahl
jzjp
unpleasantness
jj
deterministically
executing
tm
somehow
specically
fy
analogous
outputs
valued
bit
predecessor
cfg
onward
reinforced
naturality
reinforce
rej
jvj
impredicative
jtj
semicolon
ministic
ran
turing
rst
predicates
schemes
predicative
nullary
ate
stores
theoretic
operators
unnatural
rosser
subtlety
arithmetic
yi
ranges
simultaneous
backed
yg
verications
verbatim
retrospect
z
dierent
codes
direction
resources
referring
identication
arguing
deter
jz
multivalued
delimit
machines
dierence
resource
safe recursion
partial recursive
recursive functions
state d
nondeterministic rm
p jxj
polynomial time
primitive recursive
seqbnd e
weak minimization
poly bounded
minimization operator
input x
polymax bounded
np conp
nondeterministic safe
time computable
x 7
bounded recursion
computation sequence
c safe
run m
safe arguments
x z
mod 2
smallest class
safe composition
thm 3
f x
partial functions
nondeterministic recursion
q jxj
nondeterministic state
bounded witnessing
safe weak
jxj j
normal arguments
e nml
total multifunctions
binary successors
register machine
primitive recursion
higher type
reverse direction
functions denable
partial function
total functions
single valued
m accepts
functions computable
low order
composition brn
rm m
type computability
tier 0
bounded version
leivant 6
total minimization
implicit computational
guess y
recursive sets
d a0
class npmv
j seqbnd
total multifunction
poly checking
polynomial q
forward direction
direction suppose
nondeterministic polynomial
resource free
z mod
b mod
order bits
compute x
states d
accepting computation
e p
z 7
accepting state
length p
nite set
partial recursive functions
recursion on notation
x 7 y
nondeterministic safe recursion
dened by safe
primitive recursive functions
x a 2
seqbnd e p
e p jxj
m on input
polynomial time computable
x a b
change to state
p jxj j
dened by bounded
state d k
class of total
class of pmf
safe weak minimization
mod 2 7
bellantoni and cook
suppose that x
suppose that 2
higher type computability
j seqbnd e
output of x
nondeterministic rm m
accept and output
z 7 y
bounded on x
successors s 0
x a c
accepts with output
version of minimization
x a 7
conguration of n
contents of 0
implicit computational complexity
bounded or safe
m on x
reverse direction suppose
characterization of fp
denable in c
length p jxj
class of partial
nondeterministic polynomial time
low order bits
bounded by q
closed under composition
denition of c
f x z
exactly the total
npmv i 2
containing b 0
every nondeterministic state
z seqbnd e
x is undened
described by e
proof of thm
new recursion theoretic
repeated any number
rm with code
simultaneous safe recursion

corpus/krapavin2000-test/633623.txt
parking
cars
excursions
excursion
coalescent
brownian
car
law
surely
places
aldous
prole
convergence
biased
permutation
bridge
flajolet
widths
pitman
conned
jumps
probing
additive
hashing
weakly
rst
uniformly
ne
fragmentation
empirical
skorohod
chassaing
bntc
converges
shall
resp
block
blocks
pr
lim
subsection
place
entails
park
proposition
bertoin
coalescence
dnu
yor
marckert
equiprobable
stochastic
owing
sup
lemma
uniform
giant
pittel
parks
random
nx
dirichlet
knuth
philippe
statistics
conditional
vague
sizes
tried
multiplicative
normalized
doob
chronology
subordinator
exchangeable
louchard
dickman
metaphore
riordan
bruxelles
subordinators
perman
gaussian
schemes
equivalently
denes
borel
cantelli
harmless
poisson
yielding
simplex
universite
incidentally
width
combinatorial
fv
birth
topology
induction
theorems
density
insures
lebesgue
continuity
logarithmically
enlarge
minded
nally
occupied
largest
normalised
joint
sample
exp
innitely
consequence
motion
dened
processes
sure
continuum
successively
asserted
almost
emergence
xm
regards
continuous
giving
xn
dene
mathematical
bn
insertions
xi
probable
proves
sorted
empty
ci
du
cf
iii
concerning
cameron
triomphe
shepp
dnxe
noncomputer
ofn
wellner
parked
plaine
shorack
cafe
ulb
cartan
bvd
talg
asnelles
binomially
straddles
elie
csorgo
rossler
alea
chassain
poblete
laurencot
salvy
chp
iecn
acording
combinatorists
exchangeability
desintegration
francon
dkw
kingman
charasteristic
riviera
svante
vervaat
cedex
libre
vandoeuvre
corrolary
revesz
verwaat
car c
parking schemes
additive coalescent
n places
almost surely
size biased
theorem 1
brownian excursion
place k
parking scheme
z n
n k
lemma 5
biased permutation
empty place
uniform convergence
v n
block containing
brownian bridge
linear probing
h n
containing car
n cars
standard additive
proposition 5
conditional law
subsection 5
empirical process
conned parking
fragmentation process
empirical processes
u k
k k1
standard gaussian
u m
random graph
normalized brownian
multiplicative coalescent
e n
random permutation
theorem 4
uniform random
random variables
r 1
c 1
h k
current minimum
n m
bntc n
random discrete
remaining cars
converges weakly
k cars
d ne
m bntc
almost sure
poisson dirichlet
k 2kn
relation 5
y 1
mathematical statistics
sequence u
h v
brownian motion
f n
uniformly distributed
u 1
n converges
lim n
m k
m n
shall prove
marckert chassaing
sample paths
sure convergence
vague topology
given car
converges uniformly
aldous pitman
z 1f
uniformly continuous
independent uniform
excursion e
stochastic additive
cars parking
bounded uniformly
place 1
flajolet et
prole associated
order statistics
y k
k n
z z
largest block
hashing table
k places
n e
n d
x 1
n n
random variable
b 1
car c 1
size biased permutation
theorem 4 1
proof of theorem
widths of excursions
cars on n
standard additive coalescent
block containing car
containing car c
theorem 1 3
theorem 1 2
sizes of blocks
theorem 1 4
lemma 5 12
uniform random variables
number of cars
excursions of z
normalized brownian excursion
cars that tried
theorem 1 1
independent of e
r 1 n
n d ne
convergence of z
h v n
excursion of e
convergence of sizes
due to 5
space a sequence
excursions of h
m bntc n
hashing with linear
u k 2kn
sequence of widths
sizes of excursions
excursions of e
proof of lemma
n k 1
distributed on 0
lemma 5 9
lemma 5 11
theorem 1 6
subsection 5 2
sequence of independent
proposition 5 3
sequence of sizes
conned parking schemes
gaussian and independent
line of proof
paths of e
bounded uniformly continuous
independent uniform random
processes of mathematical
z 1f x
stochastic additive coalescent
decomposition of sample
almost sure convergence
random variables u
giving the factor
flajolet et al
y k n
uniformly continuous function
theorem 1 5
n to z
brownian excursion e
conned parking scheme
uniform on 0
car c k
block of cars
almost any uniformly
blocks of cars
theorem 5 1
theorem 2 1
v n n
lemma 5 8
k is empty
lemma 5 10
n e n
lemma 4 2
e n n
due to lemma
proposition 5 4
lemma 2 2
proposition 5 2
theorem 3 1

corpus/krapavin2000-test/1014970.txt
primal
dual
routers
byers
lps
lp
feasible
router
connections
flow
agents
ln
bartal
raz
xl
rounds
nm
approximation
luby
opt
makers
yl
feasibility
connection
agent
nisan
phase
od
iteration
inequality
sequential
monotonically
amax
polylogarithmic
papadimitriou
claims
ratio
tradeo
claim
optimum
centralized
precondition
yannakakis
technion
solutions
phases
normalized
israel
ect
neighbors
logarithmic
serial
globally
azar
distributively
initialize
iterations
policies
completes
packing
ij
awerbuch
transmits
convert
rates
message
intermediate
round
repeatedly
network
amin
multicommodity
objectives
running
administrator
atm
objective
final
quality
berkeley
fractional
capacities
competitive
broadcast
cs
duality
deadlock
polynomially
min
routes
corollary
lemma
yairb
formulative
huji
dorit
shmoys
accrues
intranetwork
sicomp
safe
trials
fairness
program
ciently
rate
initialization
routing
transformation
termination
programs
boston
binational
una
regulating
liated
recombine
hebrew
depiction
hochbaum
haifa
stated
il
share
substituting
pp
incident
ending
flows
bandwidth
clarifies
regulatory
inject
awaiting
jerusalem
associate
communicate
send
multiplicative
runs
instant
revenue
emulating
upcoming
tardos
allocation
bounds
department
eliminates
terminates
danny
iq
ncr
panel
stimulating
subprogram
multiplying
fast
ac
dividing
throughput
karp
subprograms
informing
complicating
understandable
dick
ecting
unsatisfied
packet
passing
constituting
christos
plotkin
simplifications
act
working
cient
obtains
establishing
bottleneck
mentation
retransmissions
imple
erations
implemen
implementable
programming
scaled
settings
neighboring
violated
paying
complications
bu
subdivide
proving
positive linear
primal feasible
y j
flow control
approximation ratio
dual feasible
fast approximation
primal variables
ln m
d raz
y bartal
bartal j
positive lps
feasible solution
feasible solutions
dual variables
connection j
w byers
approximation algorithms
claim 2
final inequality
linear program
linear programs
linear programming
g q
running time
o nm
fact 2
r ln
primal variable
inequality holds
j w
intermediate primal
standard form
r r
solution y
special form
distributed algorithm
sequential case
normalized form
decision makers
local information
nm ln
distributed decision
approximately solving
phase number
dual feasibility
primal agent
distributed setting
variables y
local communication
global objective
increase monotonically
o r
y y
control policies
generate feasible
may broadcast
dual agents
safe algorithm
router update
claims 2
globally known
xl r
dual agent
intermediate dual
feasible r
distributed rounds
distributed model
global objectives
r time
global operations
fast distributed
polylogarithmic number
r approximation
optimal solution
algorithm produces
ratio obtained
centralized algorithm
sequential implementation
rate based
current phase
theorem 2
per phase
desired approximation
approximation algorithm
programming solution
first inequality
lp z
distributed case
case knowledge
optimum primal
logarithmic approximation
final primal
fast approximation algorithms
algorithms for positive
byers and d
y bartal j
j w byers
bartal j w
positive linear programs
connections and routers
primal feasible solution
r ln m
variables y j
primal and dual
theorem 2 1
positive linear programming
final inequality holds
solutions to positive
figure 2 1
number of rounds
dual feasible solutions
y y y
number of phases
primal feasible solutions
flow control policies
claim 2 8
positive linear program
nm ln m
dual variables x
o nm ln
feasible for z
distributed decision makers
solution for z
primal variables y
dual feasible solution
solution y j
papadimitriou and yannakakis
o r 1
approximation ratio obtained
feasible r approximation
claim 2 7
ln m r
m the algorithm
number of connections
values of dual
algorithm of luby
claims 2 7
fact 2 5
generate feasible solutions
feasible solution y
intermediate dual feasible
bound the approximation
r r r
stated in theorem
linear programming solution
fact 2 4
number of iterations
e r r
let x denote
denote the value
proof of claim
runs in o
take a feasible
turn to bound
solutions are necessarily
transformation to special
sequence of inequalities
m r time
fact 2 6
values of primal
optimum primal linear
extend their model
linear program lp

corpus/krapavin2000-test/1017779.txt
rem
event
algebra
events
composite
primitive
laws
occurrences
restriction
stream
expressions
policy
neg
occurrence
streams
subexpression
semantics
ak
detected
subexpressions
detection
instances
algebraic
reactive
operators
snoop
instant
erent
temporal
detecting
invalidated
identifier
negation
operator
algebras
foreach
expression
comply
react
timber
frp
trivially
resources
di
informally
refered
samos
esterel
alarm
disjunction
declarative
dis
interval
timing
logic
temperature
ode
justify
facilitate
resource
pressions
ciency
cient
auxiliary
button
conditionals
notified
identifiers
restrictions
extent
store
calculus
intuitive
propagated
interpretation
conjunction
active
reasoning
reaction
simultaneous
transformed
formal
sequences
correctly
petri
timeout
targets
nested
intuition
fee
meaning
responds
solicitor
anchez
lished
curs
substitutive
consecu
augusto
timebase
compose
mn
instantaneous
dom
accordance
policies
transformation
equivalence
permission
unintended
subex
alent
unintuitive
dices
estab
subexpres
galton
occurring
imperative
driven
violation
criteria
scenario
stating
singleton
ect
automata
semantically
occurences
repeatability
pressed
subscribe
alge
valid
statically
contradicts
proofs
erties
bra
reactions
stances
occured
primer
limitations
external
semantic
stored
detect
alarms
remembered
duction
databases
conditional
junction
pisa
expiration
equiv
behaviour
else
correlation
occurred
specification
copies
organised
clarified
oc
temporally
simplify
formalise
consumers
unrolled
expressive
separation
conformance
dition
reacts
mechanism
labeled
limited
stant
detectable
congruence
unified
presentation
formally
understand
database
attached
recursively
unsuitable
responding
retaining
eral
carefully
restriction policy
event stream
composite events
event expressions
current instance
event streams
primitive event
algebra semantics
primitive events
composite event
temporal restriction
event expression
event instance
start time
event detection
rem e
maximum start
equivalent expressions
limited resources
algebraic laws
event instances
transformation algorithm
event occurrences
application logic
event algebra
time instant
algebraic properties
limited memory
facilitate formal
u neg
end u
start u
event algebras
end time
di erent
formal reasoning
single event
interval based
active databases
foreach e
operators comply
event patterns
rem dis
identifier p
following laws
u start
valid restriction
rem neg
restriction policies
detected event
end e
e j
declarative semantics
detection mechanism
event specification
event types
event type
end times
reactive systems
b b
specification language
e cient
whole rather
many expressions
disjunction operator
specifying timing
treated uniformly
laws hold
stream specified
output instance
transformed expression
expression equivalence
memory complexity
primitive instance
temperature alarm
matching instance
semantics described
detection algebra
intuition finally
b a b
instance of b
maximum start time
definition of rem
restriction is applied
detected with limited
number of algebraic
facilitate formal reasoning
extent the operators
start t start
justify the algebra
reasoning and justify
primitive event stream
e in q
event specification language
start of time
semantics by showing
start u start
algebra is defined
instances of b
laws that facilitate
comply with intuition
denoted a b
instance of e
set is empty
algorithm for detecting
start and end
di erent operator
individual operator occurrences
approaches to event
separate the mechanism
detected event occurrences
j end e
formal restriction policy
refered to 3
identifier p p
computes an event
handle this type
event stream specified
dis a j

corpus/krapavin2000-test/1014985.txt
adornments
termination
acceptability
ld
symbolic
guard
predicate
tuned
atom
interargument
adorned
atoms
prolog
prefix
clause
normalised
mappings
ag
numerical
rel
denominators
queries
inferring
inference
clauses
query
adorning
arguments
infers
analyse
recursive
program
positions
integer
subgoals
mapping
computations
predicates
continued
fq
terminates
schreye
numbervars
terminating
finiteness
head
inequalities
definite
conjunct
logic
dershowitz
adornment
mutually
atomic
aq
collect
acceptable
body
apt
naturals
characterise
programs
maximal
transformation
disjunction
occuring
argument
declarative
unify
arithmetic
disjunctions
appearing
corollary
terminate
hints
integers
prefixes
traversing
transformed
inequality
ground
ap
behaviour
decreases
notions
conjunctions
cocco
goa
acceptabil
irrel
fcollect
integerg
temination
decorte
situating
analysers
evant
serebrenik
bossi
oeg
descent
founded
arity
rule
heads
partially
orderings
floating
automatic
fc
calls
extensions
integrating
norm
counterparts
sld
adorn
sumed
proving
inferred
correctness
fa
fr
munity
subgoal
arithmetics
ackermann
initialised
foe
foundedness
plied
analyser
occured
relaying
characterisations
defining
derivation
danny
generalises
summarises
oscillating
incorporating
correctly
infer
vacuously
unfold
attracted
organised
constraint
integration
coefficients
qg
formalise
conjuncts
satisfiability
extending
methodology
ae
negations
tations
unified
combine
preserved
superscripts
analysed
loops
infinite
ditions
corollaries
characterised
compu
rejecting
ready
primitive
gcd
redefined
fixpoint
ideal
position
inherited
pg
overcoming
gorithm
level mapping
integer argument
guard tuned
numerical computations
level mappings
argument positions
let p
p ag
termination condition
program p
p x
termination analysis
x 1000
symbolic conditions
partially normalised
symbolic condition
argument position
rel q
integer arguments
logic programs
call p
maximal prefix
c p
p x1
atomic queries
automatic termination
tuned set
termination inference
program let
predicate p
termination conditions
m p
proving termination
every rule
prove termination
let q
ld terminating
analyse correctly
inferring termination
correctly examples
adornments let
position denominators
known framework
integer computations
integer inequality
interargument relations
p gamma1000
called integer
mutually recursive
p q
integer variables
p 1
first clause
extended program
definite program
x gamma1
ag q
following program
practical issues
transformed program
atom p
program obtained
rule r
allows one
following notion
constraint logic
example 2
condition c
q m
example 6
integer inequalities
right selection
implies termination
interargument relation
tuned sets
recursive cases
report termination
symbolic counterparts
infers adornments
acceptability condition
transformation formally
fa j
tuned 2
ld tree
examples appearing
numerical loops
c rel
unify numbervars
programs depending
mapping pairs
ground unify
adornments presented
x terminates
normalised program
adorning process
natural level
thus termination
set of adornments
integer argument positions
acceptable with respect
p 1 x
sets of adornments
guard tuned set
predicate in p
integer argument position
p a 2
every rule r
set of atomic
respect to p
let p ag
analysis of numerical
argument position denominators
m p ag
well known framework
analyse correctly examples
q m p
p ag q
p gamma1000 x
understanding of termination
p is ld
arguments of p
x 1000 n
program let q
p is called
program and let
program is obtained
body of r
program with respect
query and let
obtained as described
first order built
example 6 12
acceptability with respect
adornments a p
call p x1
conditions for numerical
approaches to termination
called integer argument
symbolic condition c
transformation that allows
set 5 6
recursive call p
program let p
framework of acceptability
guard tuned sets
right selection rule
call to process
terminates with respect
traversing the rule
adornments for p
argument positions denominators
termination inference problem
termination of numerical
ground unify numbervars
clause is applicable
q are mutually
inference of adornments
respect to fq
atom and let
example 2 continued
q a w

corpus/krapavin2000-test/627655.txt
chain
buffered
evaluable
recursions
split
cons
recursion
bbf
zs
predicate
query
binding
predicates
finiteness
magic
ffb
adorned
exit
compiled
finitely
isort
qsort
edb
evaluability
bf
portion
xxs
propagation
append
deductive
xbs
rectified
recursive
xs
fare
functional
dtime
bbff
xls
country
merged
bs
derives
parent
idb
parents
ls
insert
join
littles
scsg
bigs
normalized
bindings
logicbase
generating
departure
nonlinear
evaluated
subchains
atime
portions
evaluation
rule
nonrecursive
bb
bff
body
deduction
chains
pushing
termination
birth
logic
arr
dep
bbb
nested
selective
travel
database
relatives
flights
infinitely
judgement
linkages
ottawa
adornment
counting
instantiated
rules
rationale
expansion
linkage
uninstantiated
patching
proceeds
instantiation
buffering
fb
hx
ffl
partition
delayed
nw
fbfff
fno
fbb
xy
compilation
pushed
plan
efficiency
intermediate
datalog
programs
quantitative
weak
vancouver
fi
path
linearly
nonlinearly
fbf
fraser
patched
subchain
adorn
primitive
constraint
transitive
relations
instantiations
horn
fff
splits
demonstrates
propagated
subgoal
terminates
derivation
cyclic
closure
naive
plans
threshold
ldl
sg
examined
finite
passed
facilitates
ff
answers
transformation
nx
attribute
ratio
evaluator
databases
iterative
shares
iteration
constants
gamma
efficiently
tuples
arguments
executes
intensive
unification
selectivity
examine
confined
expanded
transformed
computability
highly
cross
simon
forms
head
instantiate
constructors
shared
connected
monotonicity
nonfinitely
lex
bfb
nqueens
thetaff
gammaisort
fnolist
terminable
aditi
aaai
chain split
split evaluation
chain generating
generating path
chain recursion
finitely evaluable
binding propagation
magic sets
query evaluation
exit portion
linear recursion
buffered portion
buffered chain
n chain
chain following
based chain
finite evaluability
bbf x
buffered values
exit rule
rule set
recursive rule
cons x
functional predicate
evaluation techniques
single chain
partial evaluation
evaluation technique
logic programs
expansion ratio
efficiency based
cons ffb
cons bbf
nested linear
merged parents
join expansion
linear recursions
partition bbff
bf x
y zs
append u
linearly recursive
compiled chain
rule 4
two portions
function free
query constraints
propagation rules
insert bbf
cons cons
ffb x
nonlinear recursions
chain level
multi chain
deduction level
finiteness constraint
chain recursions
infinitely evaluable
deductive database
recursive query
compiled form
x parent
evaluation plan
y y
functional recursions
finiteness constraints
parent bf
recursion input
connected predicates
split partial
xxs y
compiled functional
chain predicate
level finite
functional predicates
query gamma
zs cons
xs xxs
query binding
finiteness based
gamma append
query analysis
deductive databases
evaluated first
intermediate relations
ff w
algorithm 2
evaluation efficiency
functional recursion
zs y
evaluated portion
parent fb
bb y
highly selective
fb y
finite evaluation
evaluable portion
level idb
edb predicate
y xls
split magic
following evaluation
departure end
construction function
u predicate
nonlinear recursion
hx y
evaluation may
regular chain
sub chain
b portion
functional single
qsort bf
merged cons
isort bf
chain based
sets evaluation
recursive predicate
x xs
x 1
efficient query
based query
evaluable predicates
chain forms
semi naive
highly regular
list construction
cross product
chain split evaluation
chain generating path
based chain split
buffered chain split
n chain recursion
single chain recursion
join expansion ratio
efficiency based chain
bbf x y
cons ffb x
adorned with b
y s y
cons bbf x
level finite evaluability
split partial evaluation
chain level finite
chain split partial
split evaluation techniques
finiteness based chain
insert bbf x
parent bf x
x xs xxs
y y 1
recursive query evaluation
query evaluation technique
split into two
split magic sets
functional single chain
bf x parent
nested linear recursions
parent fb y
chain recursion input
set of connected
list construction function
append u v
cons x 1
query evaluation plan
compiled functional single
semi naive evaluation
binding propagation rules
threshold the binding
query is finitely
rule set f
based on chain
chain split magic
demonstrates that chain
fb y y
ffb x xs
magic sets evaluation
ffl the evaluation
efficient query evaluation
example 1 2
algorithm 2 1
shown in 1
v a b
set of predicates
proceeds as follows
kinds of recursions
linearly recursive rule
level idb predicates
x bb y
query binding propagation
nested linearly recursive
evaluation of query
chain following threshold
partition bbff xxs
immediately evaluable portion
x parent fb
parent i x
lower level idb
predicate cons x
detailed quantitative analysis
query evaluation plans
function free linear
query instantiation information
littles ls qsort
splits a chain
highly regular chain
split evaluation may
rules a recursion
y i pairs

corpus/krapavin2000-test/1038132.txt
researchindex
recommenders
document
entropy
documents
maxent
recommendations
recommender
bigrams
mixture
markov
predictions
similarity
multinomial
recommendation
clustering
prev
clusters
cluster
recommending
web
lawrence
correlation
requests
collaborative
giles
bins
height
training
nec
triggers
topically
citation
hits
predictors
multinomials
filtering
engines
navigation
session
bigram
requested
goodman
history
cited
merge
citeseer
bibliography
mixtures
unassigned
greedy
em
sessions
cites
learned
nc
users
citations
months
prediction
bin
browsing
hit
ps
uid
comp
homepages
researchin
multmix
pagegather
probabilistic
mix
sentence
online
site
learning
gz
broke
sequences
heights
offline
dex
kt
pennock
content
sparse
coverage
co
text
ratios
recency
employing
accesses
wealth
docs
expectation
searching
accurate
steve
engine
items
statistics
competing
docu
reasonably
counts
fitting
interactions
recommends
traffic
download
displays
shot
attractive
preprocessing
visited
scoring
dimensionality
statistic
accessed
features
logs
interests
nj
solely
article
frequency
megabytes
assessing
trigger
days
discarding
occurred
currently
com
screen
normalization
iii
predictor
expectations
mobasher
visitation
rdf
lawren
yanzan
nomials
manavoglu
uwaterloo
rsearchindex
darya
bamshad
claclark
contaminate
plg
ponder
indexable
balabanovic
djvu
pubdl
researchiindex
wwwmetrics
attractively
changedriven
eberhart
menders
subsession
hpsearch
wysiwyg
subsessions
aposteriori
pavlov
unclustered
maximum entropy
d next
similarity based
based recommenders
next h
document requests
entropy model
researchindex merge
entropy models
multinomial models
d prev
collaborative filtering
entropy approach
average height
co citation
current document
history h
active bibliography
topically related
user navigation
markov model
next d
order markov
individual similarity
p d
per user
markov models
training data
researchindex data
maxent approach
ordered sequences
based predictors
recommenders currently
goodman 3
sentence similarity
nec com
top features
test data
document number
next document
lawrence giles
em algorithm
document d
probabilistic models
requests per
correlation maxent
related clusters
markov terms
merge fig
term interactions
document accesses
model long
bins 1
greedy clustering
merge recommender
different clusters
candidate set
model p
search engines
data sequences
hit ratios
currently available
steve lawrence
wide web
world wide
single component
section iii
related documents
high dimensional
make predictions
model based
clustering based
using maximum
long term
data set
maxent learning
document details
recommending system
ps gz
months worth
visited document
multmix 60
average heights
maxent model
http citeseer
citeseer nj
models correlation
researchin dex
entropy maxent
multinomial mixture
bigram counts
l giles
markov 1
user accesses
based recommendation
generating online
models learned
researchindex recommenders
user document
combining predictions
nj nec
similarity based recommenders
d next h
maximum entropy model
maximum entropy models
mixture of markov
p d next
maximum entropy approach
d next d
next d next
sequences of document
individual similarity based
first order markov
mixture of multinomials
based recommenders currently
mixture of multinomial
requests per user
similarity based predictors
markov and multinomial
searching the world
order markov terms
recommenders with respect
researchindex merge fig
interactions and dependencies
long term interactions
collection of ordered
model long term
c d next
recommenders currently available
researchindex merge recommender
using maximum entropy
available in researchindex
bins 1 5
users who viewed
documents in h
topically related clusters
height of predictions
based on user
number of documents
world wide web
number of clusters
using the em
recommenders with similar
http citeseer nj
document number h
c l giles
documents that occurred
greedy clustering algorithm
ratio of hits
contains over 470
maxent multmix 60
last observed document
distribution p d
sequence of document
model p d
low order statistics
lawrence and c
document details page
computer science papers
user navigation patterns
volume web servers
component markov model
markov 1 comp
h p c
entropy maxent approach
correlation maxent multmix
nj nec com
single component markov
generating online recommendations
results and comparisons
model based collaborative
learned in different
conditional maximum entropy
mix of markov
comp researchindex merge
d next c
citeseer nj nec
p cluster h
maximum entropy maxent
approach for generating
number of document
typical screen shot
bigrams or first
used in researchindex
regular markov model
d prev d
recommendations in researchindex
probabilistic model p
high volume web
within the bin
prev d next
document in h
nec com lawrence98searching
com lawrence98searching html
page in researchindex

corpus/krapavin2000-test/1035755.txt
token
processor
superstabilizing
superstabilization
legitimate
registers
fault
protocol
passage
circulation
stabilizing
stabilization
register
latent
mutex
transient
exclusion
faults
ring
predicate
mutual
unidirectional
rounds
lc
masking
round
legitimacy
processors
holders
minor
protocols
oe
faulty
bidirectional
critical
illegitimate
holder
writes
counter
nonmasking
convergence
corrupt
circulate
segment
counters
circulates
tokens
tolerance
waiting
dijkstra
correcting
cycle
inflicted
spliced
fifi
unidirectionally
latency
passing
handshake
ij
reconfigurations
trval
detectably
corrective
ffff
mask
recovery
impossibility
reads
interrupts
reading
ffi
splicing
writer
correction
lw
exceptional
fffi
read
infinitely
fields
containment
severe
self
atomic
tolerant
fiff
hive
holding
corrupts
toggles
multireader
spurious
fl
safety
subsegment
supervisor
fi
internal
major
sequel
program
refinement
simultaneous
strategy
appendix
executes
specifies
optimum
history
multivalued
contradiction
corruption
regular
segments
safe
execute
concatenation
tolerances
reactive
waits
lemma
layered
subsequent
detectable
reconfiguration
worst
injected
lg
observes
gamma
located
closure
contradicts
pr
ff
differs
encryption
stabilize
passed
asynchronously
liveness
subsection
understood
statements
voting
quantification
dummy
propagate
specification
unidirec
eiichiro
failstop
toshimitsu
enabledness
stabiliz
masuzawa
invalidly
crd
illegitimacy
dummies
affair
superstabiliza
bilizing
colocated
underscored
processor local
local fault
legitimate state
passage predicate
critical section
token circulation
mutual exclusion
minor token
major token
transient fault
superstabilization time
local faults
state oe
latent protocol
exclusion protocol
program counter
faulty state
processor zero
transient faults
token passing
superstabilizing protocol
token holders
token holder
mutex passage
perform critical
linear round
output registers
stabilization time
waiting strategy
input registers
processor j
program counters
internal variables
stabilizing mutual
n latent
computation starting
r ij
reading model
state reading
c variable
computation segment
token value
minor tokens
superstabilizing mutual
register protocol
superstabilizing protocols
legitimate states
o 1
processor p
processor step
two registers
token values
mutex protocol
bidirectional protocol
fault masking
local state
one processor
register r
two processors
self stabilizing
fault tolerance
r p
correcting strategy
latent unidirectional
n register
one register
round zero
spliced corrupt
corrupt state
severe transient
q ffi
gamma 1
oe 0
k state
masking fault
handshake mechanism
token circulates
unidirectional ring
stabilizing protocols
see appendix
history variables
self stabilization
global state
o n
processor local fault
processor local faults
protocol of figure
mutual exclusion protocol
mutex passage predicate
perform critical section
stabilizing mutual exclusion
processor i 1
state reading model
superstabilizing mutual exclusion
superstabilizing with respect
o 1 superstabilization
appendix for proof
writes to r
protocol is superstabilizing
stabilizing with respect
problem of mutual
ring of processors
number of registers
register r ij
protocol is optimal
fault of type
state of processor
protocol of section
spliced corrupt state
legitimate state oe
following a processor
state in l
proof by contradiction
o 1 rounds
respect to p
fields r ij
cycle of processor
stronger passage predicate
regular 1 latent
processors are token
set the program
token passing registers
impossible to prevent
protocol for processor
self stabilizing mutual
n latent protocol
minor token circulation
dijkstra s protocol
within o 1
consists of processor
j its input
registers of processor
protocol is stabilizing
uses a waiting
token from processor
complete token circulation
major and minor
steps of p
arbitrary initial state

corpus/krapavin2000-test/1039411.txt
leda
processors
processor
tcomm
seismic
scatter
merlin
mpich
rational
mpi
dinadan
load
sekhmet
balancing
comp
items
root
pellinore
caseb
bandwidth
opt
heterogeneous
ray
date
wave
duration
grids
captor
raydata
globus
piii
seven
rounding
grid
ordering
earth
balance
policy
divisible
collective
rat
balanced
descending
affine
tomography
slave
rbuff
cines
hypocenter
rating
comm
share
velocity
sign
receives
magpie
metacomputing
earthquake
experiment
bandwidths
finish
cons
master
communication
endings
ranks
floor
tasking
stair
receive
ascending
int
performances
proces
scheduling
earliest
execution
cessors
waves
send
resp
library
ceiling
geographically
jej
latest
strictly
speeds
tracing
heuristic
heterogeneity
pcs
homogeneous
mips
weather
libraries
static
velocities
network
whole
passing
receiving
begins
round
bn
nil
hypotheses
sorted
integer
clever
destination
sgi
platforms
parameterized
apples
geophysical
rior
heteroge
neous
payed
celeron
piplib
intrusive
increas
reworking
pipmp
communicator
excepted
geophysics
heuris
mated
overesti
seismograms
blueprint
nearest
mesh
instantaneous
year
scientific
outlines
whatever
decreasing
served
hypothesis
links
travel
origin
athlon
personnal
tributions
scatters
pip
mer
plus
ending
shares
indication
consequences
shipped
ecution
amd
contentions
aci
equation
message
infrastructure
sol
throughputs
sor
disseminate
rock
mbit
xp
reconstructs
hub
spawn
delimited
distributions
characteristics
idle
algebra
simultaneous
wavefront
sors
spmd
root processor
leda leda
rational solution
data items
processors end
load balancing
optimal rational
execution time
scatter operation
scatter operations
functions tcomm
empty share
n data
p p
ordering policy
mpich g2
processor ordering
load balance
p 1
processor p
execution duration
integer solution
velocity model
end date
processor receives
algorithm 1
processors p
rounding scheme
root process
n 0
static load
load balanced
whole set
network links
heterogeneous processors
dinadan total
ray paths
rat opt
comm time
whole execution
caseb pellinore
descending bandwidth
whole work
merlin merlin
tcomm j
pellinore sekhmet
int opt
sekhmet seven
seven seven
parallel computer
p processors
time amount
solution d
solution n
balanced execution
time comm
d p
algebra algorithms
master slave
sends data
non empty
distribution n
processor sends
source code
cost d
p k
message passing
decreasing order
dynamic load
ray tracing
y y
communication functions
constrained parallel
p cons
merlin dinadan
origin 3800
original application
exploiting hierarchy
whole end
wave type
seismic events
clever distributions
seismic waves
seismic tomography
weather service
grid characteristics
integer distribution
seismic wave
total duration
simultaneous endings
replacing mpi_scatter
comp j
linear communication
year 1999
operations follows
code rewriting
rational distribution
processor connected
best rational
initial velocity
data caseb
ordered last
communication constrained
leda merlin
optimal distribution
processor grids
heterogeneous cluster
destination processors
globus 9
applications designed
mpi start
leda leda leda
optimal rational solution
comp i n
tcomm i n
non empty share
n data items
receives a non
end their computation
computation and communication
p p 1
static load balancing
true for p
processors in turn
comm time amount
begins its communication
caseb pellinore sekhmet
n 1 data
processor ordering policy
pellinore sekhmet seven
root processor sends
obtain an integer
dinadan total time
presented on figure
set of seismic
time comm time
n are linear
processor sends data
total time comm
data to processors
processors p 2
linear algebra algorithms
set of data
linear in n
exists an optimal
amount of data
set of processors
communication and computation
parallel computer networks
heterogeneous processor grids
communication constrained parallel
seven leda leda
algorithms for communication
initial velocity model
rounding scheme described
execution with nodes
events of year
strategies for master
ordered in decreasing
distribution n 1
follows the processors
optimize collective operation
items to p
study the sign
processor with except
mpi a message
leda leda merlin

corpus/krapavin2000-test/1015505.txt
eid
sid
sids
eids
ip
intermediaries
resolution
middleboxes
delegation
host
dns
flat
namespace
names
transport
naming
internet
identifiers
infrastructure
endpoint
service
peer
dhts
addresses
services
hosts
mail
fara
dht
namespaces
intermediary
layer
packets
destination
routing
hip
triad
layers
proposals
uip
packet
delegate
mobility
architecture
endpoints
identifier
nats
resolve
proposal
web
destinations
resolves
borrow
architectural
firewall
overlay
persistent
network
homing
homed
protocol
server
indirection
protocols
principle
receiver
adus
administrative
lookup
tcp
principles
sender
name
urn
overlays
security
gateway
urls
org
session
mobile
denial
address
named
descriptors
protection
nimrod
rsps
unmanaged
adu
sfr
http
persistently
today
triples
triple
trust
entity
smtp
pathname
ani
delegated
routers
logically
layered
recipient
resolving
party
functionality
addressing
binding
port
envision
dos
abc
destined
handles
descriptor
cryptographic
deploy
firewalls
globe
bind
isps
attacks
router
proxies
scalable
send
location
saltzer
napts
interposition
troubling
unfriendly
jpg
conviction
diaries
ipnl
interme
peernet
architecturally
oceanstore
entities
connections
networking
home
connection
behalf
opaque
innocuous
owners
uld
shield
virus
genre
adherence
alterations
invoked
clients
authority
tied
economic
owner
seemingly
readable
interposed
scalably
ephemeral
genres
aren
resolver
sos
identifies
motivations
intended
header
bindings
caching
meta
semantics
frastructure
prematurely
chord
shenker
reconsidering
hash
controlled
initiate
forwarding
deployment
ip addresses
ip address
resolution infrastructure
flat names
eid resolution
e mail
flat namespace
resolution layer
sid resolution
user level
network level
principle 1
level descriptors
network elements
name resolution
domain names
eid level
eid e
naming layers
mail addresses
design principles
naming architecture
resolution service
transport protocols
transport protocol
network handles
service identifiers
abc org
level descriptor
multi homing
multi homed
endpoint identifiers
dns names
host identifiers
destination eid
host software
persistent names
web server
application level
open network
ip layer
resolution step
layered naming
third party
end host
principle 3
internet architecture
first class
level delegation
tables dhts
transport port
principle 4
network locations
new naming
internet mobility
eid layer
global namespaces
internet indirection
indirection infrastructure
sid level
resolution layers
distributed hash
host identity
smart packets
delegated host
level intermediaries
urn literature
user domain
globe project
peer overlays
principle 2
internet protocol
gain access
host mobility
project 4
ip routing
resource names
mail server
dns based
design principle
general principles
network architecture
web page
every packet
end hosts
services and data
peer to peer
sids and eids
user level descriptors
data and services
eid resolution layer
borrow the idea
e mail addresses
user level descriptor
open network handles
mobility and multi
denial of service
hash tables dhts
sid resolution layer
internet indirection infrastructure
globe project 4
protection against denial
service or data
distributed hash tables
new naming layers
end host identifiers
sequences of destinations
layered naming architecture
end to end
section 3 2
dns based names
packets are logically
application level intermediaries
sequence of intermediaries
resolution service ip
eid to ip
role of names
today s middleboxes
intermediaries the source
service and data
resolves the eid
eid level delegation
using eid resolution
might use multiple
urn literature 23
literature 23 50
network handles 37
dynamic network architecture
four basic design
host s home
class internet objects
reconsidering internet mobility
auxiliary mapping service
name resolution infrastructure
namespaces dns names
us to claim
host identity protocol
mobile ip 34
use multiple triples
management from file
looking up data
bind to eids
send the e
returned ip addresses
semantics of ip
location and identity
sequence of sids
networks september 02
semantic free referencing
issue of naming
multi homed hosts
layer to re
recipient controlled delegation
use a layer
level the delegation
third party service

corpus/krapavin2000-test/1029199.txt
mix
ases
mixmaster
tor
anonymity
exit
alice
routing
attacks
route
bgp
internet
independence
paths
onion
routes
adversary
isp
sender
traffic
entry
provider
topologies
traverse
router
replacement
destination
senders
customer
tier
isps
network
hop
hops
dsl
topology
ip
prefix
receiver
mixes
peer
path
remailer
peers
networks
traceroute
providers
diversity
links
latency
location
receivers
bob
node
tarzan
morphmix
prefixes
initiator
cable
modem
located
advertise
hosts
nodes
packets
peering
routers
tables
traceroutes
routeviews
speakeasy
verio
aol
abovenet
mixminion
readvertise
learned
bilateral
newborn
akamai
sprint
likelihood
passive
inc
recipient
endpoint
responder
reverse
autonomous
inferring
deployed
vulnerability
net
passively
disclosure
administrative
seeing
customers
relationships
uunet
jurisdictions
comscore
indymedia
llc
comcast
trickle
pinger
anonymizer
babel
metrix
mao
owns
selection
threat
gateway
intra
enforcement
pays
observes
vulnerable
discover
freedom
ebgp
inbound
ibgp
eavesdropping
engender
curious
attack
operated
locations
tination
dispersal
collude
prevalence
untraceable
suspicion
outbound
cnn
security
server
advertises
relaying
countries
feeds
communications
oregon
selects
directory
placement
servers
websites
web
observe
host
learns
flood
upstream
notoriously
mature
forward
fraction
link
hosting
recipients
reasonably
border
messages
likely
disjoint
export
mix network
location independence
level path
mix networks
mix nodes
routing table
exit node
level paths
anonymity networks
mixmaster nodes
network path
node selection
mix node
tor nodes
node pairs
onion routing
level topology
exit paths
replacement mixmaster
exit nodes
tier 1
ip address
bgp routing
nodes without
tor network
without replacement
routing tables
existing mix
traffic analysis
low latency
anonymity network
cable modem
customer provider
reverse paths
latency networks
entry node
hop path
routes learned
replacement tor
mix hops
node replacement
four hop
network paths
two ases
hops tor
mix paths
replacement figure
endpoint attacks
route server
edge networks
intra network
high latency
net work
mix net
selection algorithms
internet routing
two arbitrary
node placement
best route
next hop
via one
route traffic
web mixes
latency systems
mix path
alice must
path estimation
location diversity
chosen exit
prefix 18
independence metric
provider customer
peer 1
peer 2
path properties
internet topology
entry exit
path 0
directory servers
entry and exit
mix network path
mixmaster and tor
nodes without replacement
replacement mixmaster nodes
nodes with replacement
tor and mixmaster
senders and receivers
tier 1 isp
able to observe
mix node pairs
tor nodes without
number of mix
bgp routing table
replacement tor nodes
probability of one
mixmaster nodes without
one as seeing
mix hops tor
fraction of paths
without replacement mixmaster
four hop path
mix network paths
existing mix networks
mix net work
node selection algorithms
without replacement figure
hops tor nodes
tier 1 isps
low latency networks
nodes to avoid
sequence of ases
prefix 18 0
analysis of onion
chosen exit node
achieve location independence
two arbitrary hosts
entry exit node
attacks on low
underlying as level
observe all links
network path 0
path between two
sender and receiver
forward and reverse
paths that traverse
learned from one
border gateway protocol
routing table entry

corpus/krapavin2000-test/1024022.txt
bipartite
bipartiteness
vertices
vertex
queries
testing
graphs
odd
walks
edges
dense
deg
reg
walk
neighbor
ddeg
mmax
degree
avg
poly
rejects
query
sparse
incidence
cycle
colorability
dmax
uniformly
adjacency
edge
sided
reject
tilde
expanders
accepts
sampling
sufficiently
krivelevich
neigbhor
distance
item
accept
emulate
subgraph
alon
matchings
violating
min
degrees
dn
expander
acyclicity
gen
probability
sqrt
asks
roughly
log
lists
certificate
incident
tester
regular
gap
neighbors
prof
modifications
constructions
nonetheless
extremes
corollary
randomly
dpoly
tali
noga
ommitted
krivelev
bipratite
npoly
obtains
fraction
shall
probe
distributions
partition
selecting
cdot
venture
aviv
tight
specifically
necessity
ramanujan
dana
tau
subsection
sample
probabilistic
pr
tel
conjectures
indepen
dently
emulating
confronted
harm
external
selects
bounded
freeness
decouple
suitable
exhibit
returns
quadruples
kaufman
builds
outputs
allowed
emulation
polylog
land
depart
matrix
random
establishing
quadruple
regularized
supervision
seventeenth
2d
linked
aids
tightness
ron
th
de
almost
underlies
dd
miami
loops
distinguish
proofs
sublinear
artifact
israel
items
ph
bridge
entries
siam
adapts
perfect
ju
running
je
seeking
transformation
seeing
thesis
rm
stays
amortized
gaps
clique
returned
asking
subgraphs
eigenvalues
traced
aside
michael
densities
prepared
directed
parity
preferable
predetermined
cycles
traverses
traversed
florida
significantly
bounds
suffice
detected
transformed
il
undirected
relying
g 0
testing bipartiteness
odd cycle
vertex pair
test bipartite
property p
pair queries
average degree
bounded degree
bipartite reg
query complexity
neighbor queries
d avg
dense graphs
odd length
o min
every graph
graph g
poly log
incidence lists
th neighbor
degree graphs
testing algorithm
random walks
algorithm test
deg v
lower bound
length cycle
general graphs
property testing
ddeg v
degree incidence
length poly
lists model
regular graphs
d n
distance parameter
sided error
edges m
adjacency matrix
maximum degree
least 2
v de
multiple edges
m g
min queries
avg g
returns found
query access
almost regular
log n
g n
x v
n vertices
h v
perform queries
testing algorithms
graph properties
almost uniformly
generated according
n d
graph property
k colorability
procedure sample
starting vertices
testing sparse
testing properties
matrix model
bipartite gen
v d
sufficiently large
algorithm may
two distributions
g contains
paper 12
sample vertices
probabilistic construction
graph generated
algorithm rejects
accepts every
p g
degree d
sparse graphs
queries allowed
testing graph
vertex v
actual number
every vertex
constant degree
e p
bound holds
graphs whose
given distance
o n
theorem 3
upper bound
far from bipartite
number of edges
vertex pair queries
test bipartite reg
type of queries
complexity of testing
bipartite with respect
poly log n
algorithm test bipartite
least 2 3
bounded degree graphs
odd length cycle
probability at least
ddeg v de
bounded degree incidence
complexity and running
length poly log
degree incidence lists
deg v d
e p g
construction of g
incidence lists model
uniformly in g
g is far
problem of testing
according to g
notion of distance
cycle s returns
access to g
found then output
queries in g
g n d
d avg g
o min queries
queries and vertex
rejects with probability
g is bipartite
every graph g
number of vertices
cycle of length
g n 2
degree in g
v in g
n 2 d
bounds for testing
graph generated according
reg on g
rejects a graph
equivalent to sampling
graph property p
given distance parameter
uniformly from g
test bipartite gen
obtains the property
adjacency matrix model
bipartiteness in general
algorithm that asks
given query access
graph is bipartite
graph g 0
vertices in g
graph is said
one sided error
testing graph properties
define a graph
n 2 n
vertex in g
n 1 5
n 2 m
neighbors of v
respect to m
reduce the problem

corpus/krapavin2000-test/606910.txt
stream
pi
cut
string
streams
sequent
substream
subproof
formulas
substrings
cuts
axioms
strings
contraction
axiom
elimination
proofs
substring
lying
focal
bifurcation
logical
wn
contractions
subproofs
vertex
paths
occurrences
flow
sequents
wab
defocussing
arithmetical
focussing
compact
disrupted
bridge
propositional
branching
lk
formula
atomic
combinatorics
shall
wb
jr
passes
height
rewriting
proposition
occurrence
duplicated
concatenation
rules
girard
bridges
edges
rule
wa
constituted
weak
distinguished
buss
stretched
algebraic
pass
passing
directed
fp
topological
duplication
acyclic
apology
preceeds
implicitness
connectives
transformation
unary
bundle
extremal
chain
commutativity
remark
combinatorial
symbols
linked
exponential
provability
antecedents
extremes
induction
calculus
subgraphs
bar
cyclic
distributivity
pushed
commutative
cycles
graphs
permuted
belong
reader
depart
belonging
intriguing
structural
permutation
edge
undecidability
logically
formalized
associative
associativity
decomposition
purely
quantifiers
analysed
graphic
labelled
lie
interaction
shrink
deduction
additive
logic
path
induces
speak
consequent
parenthesis
universally
expansion
evolution
topology
describing
symmetry
predicate
bifurcate
substreams
outcoming
defo
falsifies
regnier
danos
ssatisfying
pinpoints
cussing
treatement
unhappy
emphazised
lafont
picture
quantified
looks
oriented
horizontal
manipulation
transformed
intruiging
gentzen
explicit
diagrams
induce
induced
ending
logical flow
pi 0
cut elimination
string associated
flow graph
b b
cut formulas
proof pi
stream p
input vertex
cut formula
stream structure
output vertex
end sequent
w 1
compact string
focal pairs
string w
w 0
f rule
cut free
form w
string b
b 2
p pi
side formulas
cut rule
rules r1
branching point
cut edge
pi w2
subproofs pi
definition 11
flow graphs
stream passes
w 2
rewriting rules
wn wn
stream might
pi w1
free proof
form b
v w
let w
w 3
cut edges
pi 1
arithmetical value
explicit string
acyclic directed
substream passing
axiom edges
wa wab
sequent f
f rules
passes twice
wab wb
streams p
formal proofs
logical rules
topological structure
last rule
b m
f 2
weak formulas
theorem 26
directed paths
might pass
example 22
branching points
negative occurrence
w wn
f x
logical connectives
atomic formulas
let pi
distinguished formulas
logical flow graph
b b b
procedure of cut
form w 1
associated to p
b 2 b
b b 2
w 1 w
compact string associated
cut free proof
equivalent to b
w 3 w
p pi 0
proof of f
rules r1 r7
elimination of cuts
logical flow graphs
rule is applied
operation of bifurcation
based on v
w is equivalent
decomposition of p
one input vertex
wa wab wb
extension of p
node of p
number of paths
f f x
w are strings
path passes twice
describes a substream
transformation of streams
rule of pi
operation of concatenation
cut is applied
subproofs pi 0
input vertex output
subproof pi 0
step of elimination
acyclic directed graph
cut free proofs
vertex output vertex
streams of proofs
chain of focal

corpus/krapavin2000-test/628687.txt
modal
strain
wrench
correspondences
deformations
eigenmodes
modes
shape
prototype
shapes
stiffness
deformation
mode
align
energy
eigenvectors
displacements
correspondence
displacement
hammer
mass
recognition
nonrigid
feature
amplitudes
bent
interpolation
contour
image
rigid
silhouette
deformable
alignment
matching
fem
affinity
elastic
warp
material
airplane
wrenches
matched
equilibrium
airplanes
galerkin
matrix
nodal
body
vision
frequency
strongest
affinities
coordinate
ended
vibration
planes
ik
interpolants
matrices
rotation
silhouettes
wing
deforming
jl
unmatched
defor
recovered
images
eigenmode
viewpoints
descriptions
morphing
canonical
orientation
phi
eigen
deform
damping
features
dickinson
saab
match
stretched
object
aligned
parameterization
viewpoint
sven
brady
physically
resolution
symmetry
strains
hammers
distinctiveness
ght
shokoufandeh
eigenshapes
similarity
intelligence
sampling
springs
views
tools
shapiro
surface
conforming
gaussians
aa
noise
physical
mations
eigenspace
karhunen
kl
recovering
generalized
2d
quaternion
cloud
pear
gaussian
oe
principal
matches
objects
aligning
loads
discarding
vectors
clouds
percent
describing
terpolants
tilted
macrini
fuselage
cub
crescent
orthonormalized
eigendecomposition
regroup
piper
eigensnakes
cars
locations
reliably
ject
distinctive
eq
rotations
formulation
proximity
polar
signature
fig
bb
forces
eigenproblem
volkswagen
siddiqi
thinned
surgery
kaleem
nonconforming
truncation
tracking
retrieval
centroid
ali
tog
interpolated
centered
amplitude
invariant
appearance
virtual
upright
hough
dobkin
inertia
vw
isoparametric
graphics
columns
3d
rotated
dy
motion
dimensionality
finger
funkhouser
snake
deforms
weigh
eve
hancock
sclaroff
spring
extracted
strain energy
feature points
finite element
modal matching
modal strain
low order
mode amplitudes
mode shape
frequency modes
similar shapes
modal deformations
bent wrench
modal displacements
order modes
rigid body
stiffness matrices
body modes
prototype wrench
canonical descriptions
hand tools
coordinate system
contour points
elastic body
nonrigid modes
interpolation matrix
machine intelligence
pattern analysis
feature point
object recognition
physically based
intelligence v
feature correspondences
two planes
strongest corresponding
generalized feature
two similar
higher frequency
interpolation functions
affinity matrix
element model
energy needed
feature data
shape functions
stiffness matrix
computer vision
shape vector
modal deformation
mode number
mass matrices
single ended
modes computed
nodal point
shape vectors
simple physical
displacements u
two percent
modes describe
ended wrench
non rigid
feature locations
shape description
prototype object
different hand
material properties
body centered
understanding v
k l
two shapes
lower resolution
image understanding
high frequency
higher resolution
low frequency
different views
data points
number amplitude
interpolated modal
large rotations
element nodes
frequency ordered
target airplanes
aligned prototype
modes z
loads r
first 22
top points
feature connectivity
ali shokoufandeh
displacement signature
modal matrix
ended wrenches
silhouette correspondences
material matrix
intermediate deformations
equilibrium problem
silhouette points
unmatched nodes
tree shapes
eigenvectors oe
different planes
needed to align
modal strain energy
mass and stiffness
ik a jl
rigid body modes
higher frequency modes
l a ik
correspondences are shown
analysis and machine
transactions on pattern
machine intelligence v
align the two
stiffness and mass
low order modes
warp the prototype
finite element model
number of feature
mode shape vector
used in building
frequency of vibration
frequency modes describe
energy that results
shapiro and brady
tool is shown
terms of modal
deforming the prototype
different hand tools
mode shape vectors
next most similar
results from deforming
g k x
image understanding v
vision and image
sets of features
cloud of feature
terms of deformations
ordering of shape
g l x
elements of k
two dimensional problem
strongest corresponding contour
points were sampled
form k l
us to recognize
direction of displacement
aligned with little
correspondences were computed
recovering the modal
global to local
points were found
energy to compare
ordered by increasing
correspondences are found
corresponding contour points
finite element nodes
mode number amplitude
correspondence and recognition
using the first
finite element method
solving the dynamic
x g l
non rigid motion
c d fig
number of data
closed form solution

corpus/krapavin2000-test/628293.txt
documents
subrange
engines
engine
document
nodoc
query
weight
normalized
database
metasearch
mw
avgsim
mismatch
similarity
weights
usefulness
subranges
representatives
ggloss
similarities
estimation
percentile
representative
queries
databases
weiyi
internet
deviation
byte
match
clement
estimated
quadruplets
mnw
combined
search
correlation
meng
threshold
sim
lup
king
median
retrieval
probability
yu
ft
ij
zonghuan
stanford
bytes
thresholds
estimating
text
cosine
est
useless
ith
substantially
inaccuracy
retrieved
probabilities
submitted
largest
broker
statistical
wu
ranking
collections
lazarsfeld
zhuogang
wmj
usefulnesses
metadata
triplets
searching
occurrences
liu
retrieve
estimate
dependencies
polynomial
percentage
accurate
bahadur
gloss
jk
bits
dot
phrases
web
tell
occupies
um
users
percentages
coefficient
estimates
disjoint
oe
rank
returned
generating
virginia
identify
incorporating
descending
deviations
downloaded
tables
identifying
adjacent
experimental
columns
medians
accuracy
searched
criteria
frequency
identification
mclean
average
moderately
phrase
proposal
meta
submit
ease
expanded
kong
polynomials
potentially
content
rg
ninth
norms
reasonably
normalization
abstractsearching
kup
savvysearch
moshiri
wensheng
hrd
resulr
kazemian
crestani
maryam
majid
losee
santoso
gravano
hosein
archies
metasearching
webfusion
relatedness
inhomogeneity
invokable
prasoon
restrictiveness
wmi
adrain
piroozmand
keyhanipour
webcrawler
aliweb
zipfian
netnews
roanoke
kthen
dependency
maximum normalized
normalized weight
search engine
search engines
match mismatch
subrange based
mismatch d
combined term
database representative
term weight
estimation method
high correlation
single term
normalized weights
d n
n d
average weight
metasearch engine
one byte
term weights
normalized term
similarity function
database d
standard deviation
useful documents
identify d1
similar documents
documents containing
generating function
database representatives
subrange contains
mw 1
term queries
useful based
basic method
based method
weiyi meng
given query
estimation methods
distinct terms
clement yu
metasearch engines
query term
two terms
previous method
u match
useful search
global similarity
true nodoc
first subrange
query q
statistical method
text databases
document d
different estimation
term query
experimental results
new subrange
large sim
second subrange
correlation case
term method
similarities greater
based estimation
potentially useful
cosine function
uniform weight
king lup
lup liu
information retrieval
term j
whose similarities
correlation approach
internet queries
highest subrange
database d1
mw 2
sim q
containing term
ith term
mnw ij
estimated probability
local search
m distinct
maximum normalized weight
mismatch d n
match mismatch d
d n d
number of documents
d s table
subrange based method
document in d
normalized term weight
maximum normalized weights
d s match
single term queries
queries that identify
maximum normalized term
estimation methods using
terms in ft
u match mismatch
database d 1
subrange based estimation
different estimation methods
global similarity function
using one byte
method t u
useful search engines
weight of term
high correlation case
documents with similarities
documents in d
combined term method
estimate the usefulness
d has similarity
m distinct terms
set of documents
comparison of different
king lup liu
term t j
nodoc and avgsim
coefficient of x
sim q d
database with m
estimating the usefulness
weight and standard
single term query
subrange based approach
probability that term
uses one byte
weights from w
d has exactly
local similarity function
high correlation approach
based estimation method
exactly the terms
using 4 bits
number of useful

corpus/krapavin2000-test/1039285.txt
ground
stabilization
stabilizing
self
chains
inactive
chain
oe
rewrite
br
dershowitz
fw
word
derivations
infinite
substitution
hoepman
derivation
transducer
soe
fidg
debas
string
configurations
sigma
beauquier
top
rewriting
substitutions
legitimate
reducible
unification
ring
inact
convergence
cyclic
ghosh
termination
ds
gamma
wn
rules
resp
reductions
iff
dr
xry
rule
quasi
successors
minimally
middle
active
configuration
successor
unifiers
lefthand
labelled
xr
righthand
terminating
reduction
act
letter
proving
substring
compositionality
delta
infinitely
pqr
nonvariable
overapproximation
minimal
preserving
instantiations
schemes
uw
rings
rightmost
tops
old
dijkstra
vn
strictly
regular
id
generalized
ug
languages
bottom
lwm
belated
simplifiers
xpqry
commutation
uwv
tribulation
neighbouring
generalization
exercise
strings
orientation
fairness
transitions
norm
subareas
toe
triumph
election
breaks
spite
xn
adapts
nonnull
generation
wa
proves
herman
demon
delimited
appearing
leftmost
narrowing
subword
transducers
sequences
disregard
henceforth
ending
replacing
decreases
associativity
upwards
cycle
counterpart
discarded
remark
manipulates
terminate
proposition
letters
accepted
upward
od
hs
passing
perspectives
pq
focusing
reaching
exhibiting
iteratively
replaces
modulo
lifting
leader
suffix
norms
disappear
deadlock
lemma
positions
instanciated
legitimitate
ssertional
orities
fwg
pathes
unwvn
withfwg
self stabilization
self stabilizing
top chain
ground word
ground derivation
gamma gamma
minimal reduction
top rule
infinite ground
rewrite systems
derivation via
w 0
string rewrite
top chains
quasi cyclic
stabilizing systems
reducible via
first order
regular languages
rule r
act gamma
dr fidg
order scheme
chain generation
infinite derivation
inactive steps
using fw
beauquier debas
word w
r oe
via r
using oe
via m
proving convergence
stabilizing w
cyclic top
minimal reductions
gamma top
soe r
generalized successor
infinite derivations
ground scheme
state algorithm
substitution oe
edge labelled
rewrite system
oe 6
strictly decreases
oe 2
middle rules
minimal top
ring orientation
legitimate configurations
reduction chains
derivation delta
substitutions oe
prove self
inact gamma
rewriting systems
norm function
r using
active area
infinitely often
l 2
order word
string rewriting
br preserving
ground substitution
reduction chain
fw w0g
fw w
inactive area
middle rule
variable words
bottom rule
top rules
generalization process
closed via
y xry
active ground
chain via
top letter
cycle property
successor via
minimally reducible
reduced form
order variables
generation procedure
w r
finite number
graph construction
non increasing
oe 0
regular sets
labelled r
l iff
form u
m 4
form w
rule e
graph rewriting
infinite path
stabilizing iff
unification problem
reaching l
infinite chains
debas system
stabilizing ring
gives generalized
self stabilizing systems
infinite ground derivation
ground word w
string rewrite systems
act gamma gamma
oe 2 dr
stabilizing w r
quasi cyclic top
oe 6 id
via s 0
self stabilizing w
r using oe
via r using
r t l
system s 0
cyclic top chain
prove self stabilization
inact gamma gamma
ground derivation via
gamma gamma gamma
top chain via
active ground derivation
one variable words
ground derivation delta
x y xry
edge labelled r
exercise in proving
via m 4
substitution oe 2
l is closed
infinitely often except
convergence of self
stabilizing ring orientation
minimally reducible via
self stabilizing ring
rule r x
gamma gamma t4
system is self
old s old
self stabilizing iff
measure that strictly
configuration of l
made of rules
via a rule
number of inactive
middle rule r
beauquier debas system
new s old
fw w 0
ground cyclic derivation
first order rewriting
w 0 r
first order scheme
gamma gamma w
oe 0m1 oe
generalized successor via
generalized minimal top
set of substitutions
number of breaks
example for rule
top s infinitely
proof of self
sigma and w
chain over words
element of sigma
f f f
applying a rule
set of legitimate
self stabilizing algorithm

corpus/krapavin2000-test/1007977.txt
inorder
spine
preorder
fold
bftf
roll
flatten
forest
tip
preorderf
traversal
converse
breadth
reductivity
revzip
ziptree
zipforest
rebuild
inversion
haspreorder
execwith
tree
invert
height
foundedness
reductive
concat
surjective
xok
bft
prefix
xs
exec
commands
ys
hylomorphism
prefixok
trees
functor
datatypes
datatype
aforest
rbr
coreflexive
labelling
traversals
dom
subtrees
generalised
fst
jointly
strings
heights
lookahead
snd
fusion
fuse
okasaki
isnext
moor
newtree
cpy
inverse
relational
ws
string
bin
lbr
folds
unfold
id
fork
forests
bs
inverses
inverted
int
foldtree
spinei
coreflexives
foldrn
demonic
su
founded
parsing
parse
exercise
inverting
lists
map
join
specification
font
tupling
determinism
boldface
xu
derivation
haskell
ins
del
deterministically
bfl
printing
invariant
list
loop
add
character
cons
rebuilding
init
ran
ok
minsplit
flattenf
zipping
foldr
monotype
relator
doornbos
rollpf
flattens
xof
angelic
zipped
minadd
issu
deques
building
monotonic
eq
converts
functional
edit
ht
knuth
dijkstra
upwards
invent
catamorphism
catamorphisms
backhouse
tournament
talked
char
imperative
optimised
inr
inl
flattening
says
move
erent
labelled
internally
backwards
tail
greedy
contravariant
cursor
tips
duplicated
reflexive
reader
monotonicity
calculus
di
bird
homomorphisms
wraps
admitting
locate
postcondition
optimise
consumed
apparently
fs
command
relations
valued
factored
ta
isomorphism
binary
implementable
cat
folding
fig
conversion
cult
wider
recursive
generalise
fa
theories
generalisation
termination
reverse
refinement
breadth first
f well
x us
preorder traversal
jointly surjective
function theorem
f reductive
inorder traversal
program inversion
first labelling
well foundedness
given list
building trees
su xok
spine tree
xok x
inorder roll
partial function
e f
haspreorder x
left spine
base functor
concat map
minimum height
f reductivity
prefixok x
first traversal
data tree
map snd
preorderf map
snd us
relation add
fold fusion
tip tree
zipforest bftf
su x
empty lists
two strings
valued binary
binary tree
b d
tree whose
relation r
boldface font
vs ws
bs us
since dom
fork preorder
greedy theorem
tip valued
lookahead x
de moor
following datatype
theorem 3
non deterministically
functor f
last x
refinement calculus
well founded
two trees
binary trees
theorem 1
r f
new node
non determinism
preorder inorder
converse operation
edit problem
duplicated elements
fusion theorem
spine representation
roll vs
map flatten
type aforest
flatten roll
empty strings
generalised theorem
us su
map fst
bin b
b bs
tree int
source string
xu x
relational fold
fold function
ok x
rebuild x
string edit
inorder traversals
labelled binary
fst us
us newtree
dom r
d e
height x
breadth first labelling
su xok x
f well foundedness
breadth first traversal
c a e
revzip a f
tree a tree
non empty lists
preorderf map snd
map snd us
f a b
d e f
b d c
e f b
r a b
tip valued binary
r is f
building a tree
valued binary tree
f well founded
sequence of commands
adding a new
rebuilding a tree
algebra of programming
spine a tree
fork preorder inorder
roll vs ws
fold fusion theorem
bin a x
xok x us
map fst us
newtree a xu
add a xu
concat map flatten
along the left
inorder and preorder
preorderf t u
us su xok
tree int int
x us su
string edit problem
along the spine
prefixok x us
linear time algorithm
f r f
list of labels
trees with minimum
f a x
f b d
b d e
reader is referred
c d e
u v w
x i 1
breadth first order
y non deterministically
write the inverse
label a tree
inversion and strongest
concat map cons
printing and parsing
maps a list

corpus/krapavin2000-test/606695.txt
wcsl
stability
cos
sin
switched
switching
lyapunov
homogeneous
trajectory
controller
margaliot
holcman
rh
law
origin
rv
clockwise
unstable
stabilizing
ugas
polar
asymptotically
trajectories
closed
sgn
rotates
rst
contours
su
cient
dv
const
bxg
rapoport
pyatnitskiy
es
integral
homogeneity
integrals
satises
veriable
stable
fax
designing
coordinates
destabilizing
encircling
langholz
stabilized
dynamical
unbounded
contour
denition
characterization
asymptotic
weizmann
nonlinear
rotate
boundary
counter
dene
radially
dierential
lemma
nd
fig
equilibrium
positively
chapter
convex
admits
stabilizes
transforming
zeros
df
invariant
converse
hamiltonian
yields
dierentiable
numerically
generalized
uncertain
israel
eq
contradiction
curve
stabilize
converges
perturbed
appendix
cone
stay
rotating
stableg
michaelm
homo
theless
dieren
liberzon
polysystems
geneous
variartional
polytopic
jj
direction
novel
electrical
ln
around
jump
absolute
filippov
integrand
aviv
fillipov
rehovot
nonquadratic
popov
il
piecewise
concatenation
analyzing
xed
fa
regained
rmative
tial
tau
jjf
spiral
wisdom
tel
actuators
rection
morse
depicts
singular
dened
di
banach
dierentiate
constructive
verify
ac
analyze
recipe
attains
eng
stabilization
verifiable
collinear
explicit
globally
undergo
economics
regime
ay
digit
cult
notations
feedback
inclusions
innitely
pushes
nt
synthesize
absolutely
norm
denite
solutions
substituting
geometrical
matrix
bilinear
hybrid
xg
characterizations
swap
deriving
detecting
smallest
synthesizing
elds
tan
parameterization
switching law
homogeneous systems
order switched
switched homogeneous
switching controller
system _
cos sin
switched linear
second order
solution corresponding
asymptotically stable
generalized rst
rst integral
m margaliot
d holcman
stability analysis
sin cos
lyapunov function
clockwise direction
invariant set
rh f
cient stability
closed trajectory
h x
g x
unstable solution
closed solution
polar coordinates
linear systems
su cient
switched systems
asymptotic stability
r _
stability condition
f x
counter clockwise
sin sin
line l
r sin
f g
function v
v x
rotates around
x g
cos j
rv x
homogeneous functions
absolute stability
stabilizing switching
lyapunov theorem
x 2
lemma 5
g 2
x 0
r 2
n f0g
j r
see 5
whose proof
every solution
positively homogeneous
case switching
veriable necessary
converse lyapunov
fax bxg
order homogeneous
satises _
explicit lyapunov
contour h
stability problem
easily veriable
order systems
rst integrals
es n
get _
assumption 1
sin r
stability conditions
trajectory x
smallest k
closed curve
sin j
lemma whose
theorem 5
solution x
equilibrium point
fig 5
switching stability
since rh
common lyapunov
unstable systems
contours const
destabilizing switching
solution rotates
rh g
radially unbounded
scaling see
curve encircling
order switched homogeneous
switched homogeneous systems
second order switched
switched linear systems
around the origin
holcman and m
f g 2
necessary and su
corresponding to wcsl
su cient stability
cos sin sin
cient stability condition
generalized rst integral
analyze the stability
counter clockwise direction
solution of _
x g x
consider the system
solution of 2
designing a stabilizing
sin cos j
designing a switching
algorithm for designing
stabilizing switching controller
along the trajectories
rh f x
boundary of stability
coordinates we get
denition of wcsl
r 2 n
yields a closed
g x 0
sin sin cos
theorem 5 6
generalized rst integrals
absolute stability problem
worst case switching
second order homogeneous
functions of degree
rv x g
problem of analyzing
f 2 es
sin j r
r sin cos
cos sin j
easily veriable necessary
trajectories of 3
see 5 1
j r sin
order homogeneous systems
system 2 3
explicit lyapunov function
pyatnitskiy and rapoport
converse lyapunov theorem
x t converges
cos j r
x is homogeneous
lyapunov function v
case switching law
f x g
x 2 r
stability of 2
analyzing the stability
function v x
lemma whose proof
lemma 5 5
f and g
theorem 5 3
easy to verify
proof of lemma
x and g
lemma 5 4
x 2 d
proof is given
theorem 7 1
lemma 5 2
may be seen
r in 5
closed curve encircling
law that yields
smallest k 0
detecting the boundary
exists a switching
margaliot and langholz
r _ cos

corpus/krapavin2000-test/1030096.txt
fuzzy
fsk
extractor
secret
adversary
challenger
outsider
perturbation
alice
extractors
sketch
public
perturbations
security
insider
attacks
private
gen
reg
secure
string
attack
fuz
entropy
randomness
bob
cpa
permutation
cor
biometric
isometric
biometrics
hamming
sketches
queries
pbk
strings
permutations
drs
dodis
unconditionally
privacy
secrets
leak
constructions
randomization
nonce
codeword
oracle
codes
authentication
randomized
decisional
trent
subcode
generic
password
jw
codewords
word
game
challenge
correction
displacement
ciently
attacker
regeneration
family
ext
query
noisy
oracles
amplification
sketching
metric
symmetry
pivot
bobs
wattenberg
unconditional
leaks
claims
adaptively
computable
transitive
subgroup
juels
imperfectly
codebook
ind
reusable
signature
decoding
certificate
distance
responds
honestly
commitment
certification
random
biased
char
admissible
anything
signatures
keys
extraction
pos
adaptive
outputs
correcting
certificates
script
authenticate
break
bits
superconcentrators
adva
cma
subcodes
assigmnents
hardening
vote
insecure
character
ow
edit
stringent
unforgeable
authenticates
keystroke
dishonest
counterexample
protocol
cryptographic
uf
text
authentic
cryptographically
extracted
notions
fresh
code
computationally
deterministically
reuse
extractions
flawed
vulnerability
reminds
winning
withstand
equipped
maps
bit
cient
compliant
protecting
existentially
notion
min
su
appendix
reveal
preparation
sends
legitimate
manageable
erent
thereof
mirror
hash
di
vicinity
uniformly
machinery
imperfect
recover
edition
radius
remote
theoretic
hidden
spaces
indistinguishable
inputs
harden
colludes
namics
fuzzy sketch
fuzzy extractor
chosen perturbation
fsk w
m m
private string
public string
fuzzy extractors
w m
fsk cor
string q
secret w
fuzzy secret
perturbation attacks
fuz cpa
fuzzy sketches
min entropy
gen reg
word w
public strings
secure fuzzy
randomness extractor
generic fuzzy
private queries
w w
permutation based
code c
jw drs
gen w
perturbation attack
outsider security
function fsk
outsider chosen
cpa adversary
input w
error correction
unconditionally secure
permutation group
space m
d w
outsider secure
q pivot
insider chosen
extractor gen
dodis et
al drs04
isometric permutations
bits r
variable w
outsider attacks
ciently computable
random oracle
private key
random variable
private strings
chosen perturbations
q public
secret word
fuzzy commitment
outsider attack
hamming metric
perturbation security
strings q
insider security
private query
ow fuz
decisional version
adaptive outsider
ind fuz
sketch fsk
privacy amplification
minimum displacement
public queries
linear codes
adaptive chosen
w r
e ciently
input word
random bits
metric space
m k
log 2
random oracles
element w
generic construction
authentication protocol
q q
challenger runs
given b
linear code
p w
commitment scheme
average min
fuzzy secrets
extracted private
isometric permutation
admissible perturbations
sketching function
randomization strings
codeword w
theoretic security
pivot 0
q gen
d code
perturbation d
challenge public
public query
made adaptively
fresh random
adaptive insider
w fsk
juels wattenberg
fuzzy extraction
statistical distance
entropy m
transitive isometric
drs construction
sketch construction
zero storage
n k
metric d
m t fuzzy
chosen perturbation attacks
m m m
public string q
sketches and extractors
d w w
generic fuzzy sketch
outsider chosen perturbation
fuz cpa adversary
random variable w
adaptive chosen perturbation
n k d
extractor gen reg
et al drs04
outsider secure fuzzy
metric space m
insider chosen perturbation
fuzzy extractor gen
dodis et al
input word w
word w m
chosen perturbation attack
k t code
e ciently computable
secure fuzzy extractor
element w m
ow fuz cpa
secret word w
queries the adversary
public strings q
adaptive outsider chosen
secure against outsider
ind fuz cpa
fsk w r
random bits r
strings q 1
family of perturbations
fuzzy sketch fsk
construction of section
log 2 p
secure against adaptive
q 1 q
function fsk w
d m m
chosen perturbation security
fuzzy sketch construction
jw drs construction
fsk w fsk
notion of symmetry
fuzzy commitment scheme
variable w m
average min entropy
chooses a perturbation
w fsk w
value of fsk
used multiple times
information about w
transitive isometric permutation
space m let
challenge public string
q gen w
sketch fsk cor
secure fuzzy sketch
permutations in m
adaptive insider chosen
isometric permutation group
maps any element
k d code
q pivot 0
information theoretic security
challenger the challenger
min entropy m
section 3 3
holds that d
follows the adversary
w r r
w c r
refer to appendix
queries are made
fsk w captures

corpus/krapavin2000-test/1009186.txt
powerset
algebra
sparse
relational
nested
nonemptiness
flat
expressible
paredaens
database
suciu
nesting
gebra
schema
fixpoint
proposition
expressions
equa
equations
parity
databases
expression
query
delta
transitive
fxg
fagin
sparsity
closure
operator
equation
kolaitis
fewp
sym
fragment
np
alge
unambiguous
equals
bra
frg
deed
polynomial
subgroup
liebeck
wonder
names
vianu
abiteboul
primitive
pi
analogue
schemas
permutation
unnesting
polynomially
tuples
asking
appendix
jrj
sentence
alt
automorphism
enumerate
operators
ary
tc
monadic
singleton
logic
rid
occurring
relation
relations
strategy
cardinality
rg
innermost
intermediate
fx
undecidable
assum
hillebrand
roundabout
blows
wel
detective
biguous
bochert
ebbinghaus
imprimitive
disequations
disequation
directness
jaut
vdb
aszl
gyssens
frivolous
contri
flum
grumbach
erful
arity
complements
theta
name
invoking
remark
tuple
existential
solutions
accepting
fragments
constructs
equality
unnest
jgj
unam
aut
gucht
turing
permutations
alternating
neighbors
fr
rediscovered
disguise
definability
babai
crux
unresolved
elegant
enumeration
nothing
gin
automorphisms
conjecture
sufficiently
showed
duction
definable
formu
stars
talking
symbol
disallow
pow
recalls
finite
uation
deterministic
introduces
tg
strictness
closures
oe
express
evaluates
lation
argu
recognizable
inclusions
transitively
standpoint
guages
augmented
clutter
invert
merely
decided
subexpression
stem
bution
spectra
quantifier
conversely
equivalently
recursively
las
conjectured
ready
stands
atomic
ask
exponential
nested relational
equation algebra
relational algebra
powerset algebra
algebra expression
sparse equations
algebra expressions
finite domain
natural evaluation
database b
expression e
polynomial space
relation names
evaluation strategy
free e
relation variables
sparse equation
relation name
nonemptiness problem
transitive closure
al gebra
sparse powerset
fixpoint query
parity query
powerset operator
relational databases
e 1
domain d
type 0
algebra equation
nesting operator
equation expression
solution operator
order logic
e 2
form e
flat relational
using sparse
equation e
proposition 7
input database
recursively evaluating
powerset expression
every fixpoint
logic sentence
sym d
equations occurring
flat variable
space fragment
asking whether
equality type
occur free
relation variable
define definition
database schema
permutation groups
evaluating e
finite model
alge bra
set delta
r equals
intermediate results
equa tion
pi r
fixed set
equa tions
database schemas
polynomially many
given database
query language
power set
model theory
solution set
e b
let r
polynomial size
e 6
relation r
natural strategy
existential second
expression proof
solution expression
powerset expressions
suciu paredaens
expressible using
r ary
np properties
sparse fragment
nonemptiness problems
theorem fag74
many accepting
paredaens sp97
variable equation
algebra proposition
algebra either
flat databases
e tc
proposition given
expression sparse
equation alge
flat schema
space powerset
nested relational algebra
algebra expression e
natural evaluation strategy
equation algebra expression
relational algebra expression
finite domain d
nested relational databases
relation of type
equation algebra expressions
sparse equation expression
write a relational
fagin s theorem
relational algebra equation
suciu and paredaens
given a database
recursively evaluating e
fixed set delta
equals the relation
using sparse equations
b with finite
powerset algebra expressions
r 0 tuples
powerset algebra expression
order logic sentence
strategy for equation
every fixpoint query
subgroup of sym
sparse powerset expression
polynomial space fragment
one can write
form f x
finite model theory
first order logic
proposition 6 1
equation al gebra
polynomially many accepting
equation algebra either
theorem to nested
extension of fagin
flat relational databases
space powerset algebra
enumerate all databases
proposition 7 2
e b equals
showed that transitive
polynomial space powerset
many accepting computations
name of type
e free e
flat relational algebra
strategy to evaluate
e b one
nested relational data
nested relational al
sentence is true
theorem fag74 ef95
computational complexity theory
nesting is expressible

corpus/krapavin2000-test/1011479.txt
loc
predomain
leino
st
abadi
denotational
specifications
calculus
thetast
val
imperative
fixpoint
object
logic
oe
phi
specification
bm
rec
flat
predomains
calculi
scott
hoare
predicate
functional
recursive
id
monotonic
denotationally
recl
tm
admissible
semantics
store
cit
mild
cardelli
existence
untyped
ob
pitts
predicates
induction
soundness
logics
recursion
counterexamples
thetarec
bval
ocl
predom
closures
fields
theta
inv
formation
reasoning
oriented
resp
languages
transition
algol
predi
modelling
uniqueness
spec
record
interpretation
families
objects
garbage
cates
diverges
field
creation
java
ject
update
invariants
realizations
countable
closed
typed
ambient
employing
invariant
ae
machinery
finds
precondition
op
fresh
indisputable
recm
schwinghammer
thetao
dubious
endo
bifree
coalgebraic
gested
nuffield
evid
stval
reus
sug
hv
freyd
definedness
knaster
thetaa
endomap
tarski
letx
variant
recursively
verifying
alter
assertions
grams
inheritance
accordance
domains
iii
coinduction
cristiano
exemplify
gously
mysterious
hearn
notationally
calcagno
lcf
oei
prospective
handy
bifunctor
parison
records
operational
sake
continuous
relational
var
awkward
embarking
uncountable
viously
derivability
inclined
nineties
presupposes
characterising
nonempty
obvi
aliases
employ
lattice
labels
semantic
syntax
simplifies
distinguish
fixpoints
conceive
clone
reminds
smalltalk
wp
locations
extensions
validity
greatest
implication
programs
adaption
pcf
fication
fulfilling
specifica
clarified
overriding
ful
bernhard
plementation
object calculus
object specifications
abadi leino
imperative object
f st
e o
e oe
scott closed
object calculi
leino logic
rec loc
st e
loc thetast
fixpoint induction
o m
e e
functional object
theta st
denotational semantics
transition specifications
method update
flat predomain
p o
oe 0
f e
flat part
m o
object oriented
o 0
p e
admissible predicate
recursive object
condition iii
theorem 4
partial continuous
functional case
phi y
recursive type
oriented programs
object logic
condition y
p id
existence theorem
o o
basic values
oe 00
val theta
st val
object formation
phi satisfies
domain equations
loc theta
object expression
non flat
op theta
order store
relational properties
val thetast
method closures
loc cit
st m2m
object specification
hoare calculus
interpretation within
recursive objects
oe m
oriented languages
environment ae
program logic
introduction rule
presented approach
mild assumptions
induction principle
n w
v id
o thus
oe n
object creation
logic 2
recursive types
class based
w r
method m
definition 3
m e
recursively defined
verifying java
constrained design
store oe
natural counterexamples
recursively specified
alter data
domain equation
o 2a
field update
defined predomain
f val
needs recursion
p ffi
calculus without
programs recursive
greatest fixpoint
loc ob
java realizations
theta val
algol like
imperative untyped
loc rec
l loc
loc n
ocl constrained
guarantee existence
abadi cardelli
bm x
loc val
result specifications
untyped object
programming logics
thetast val
cates resp
f e e
e e o
abadi leino logic
imperative object calculus
f st e
logic of object
o m o
notion of specification
unique s 2
e o m
functional object calculus
st e e
object oriented programs
e oe 0
theorem 4 4
show that f
oe 0 n
calculus of 1
store i e
loc theta st
val theta st
o m e
logic of recursive
theta st m2m
functional and imperative
e v id
higher order store
oe n w
logic of predomains
within the recursively
environment ae 2
m o 0
m e o
theorem 4 2
object oriented languages
exists a unique
e e oe
properties of domains
o p o
p o p
e f e
properties of objects
y 2 l
lemma 7 1
definition 3 3
garbage and program
st theta val
quite in accordance
e oe n
untyped object calculus
call method update
fixpoint induction principle
phi y x
l loc st
rec loc rec
also suggests extensions
partial continuous functions
induction hypothesis p
object calculus without
e o 2a
fixpoint of phi
classes in algol
y of theorem
recursively defined predomain
st loc thetast
method call method
interpretation of object
loc rec f
p ffi e
w oe 0
recursive object types
simple imperative languages
predicates and families
thetast val thetast
oriented programs recursive
logics for object
functional object specifications
theta val theta
f by y
st with provided
alter data structures
imperative object specifications
n w e
finds its interpretation
existence of specifications
one needs recursion
constrained design models
verifying java realizations
n w oe

corpus/krapavin2000-test/1016210.txt
junta
vr
sided
variation
juntas
coordinates
walk
queries
detectable
permutation
probability
adaptive
rejects
independence
partition
testing
boolean
denition
accepts
subsets
dn
accept
testable
rst
fourier
blocks
nz
jj
walks
kp
dependency
xj
summand
coordinate
reject
proposition
learning
regards
ur
distributions
soundness
singletons
monotonicity
cherno
block
claim
pcp
rejected
declared
isolated
negligible
degenerate
multiplicand
iterations
ces
su
query
dependence
random
donation
passes
cients
coe
pac
tests
abound
jij
subsection
proven
pr
supposedly
dened
monomial
expectation
uniformly
satises
accepted
lemma
ln
checkable
xed
chebyshev
poset
discard
poly
quadratic
randomly
detected
inequality
logarithmic
summands
log
permutations
ciently
deviation
inputs
jsj
contrary
fraction
monotone
proofs
characterizations
dene
polynomials
ja
probabilistically
summing
dominated
convolution
appendix
attribute
induced
equals
agrees
polynomially
ert
dictators
showa
proclaiming
qit
rubinfeld
qdenes
gutfreund
ncoordinates
qwe
farness
cidence
uninformed
withapplications
hardness
harmonic
irrelevant
combinatorial
dier
odd
induction
biased
picks
shift
specically
characters
detect
advance
threshold
formulae
completeness
cient
equidistributed
abusing
undiscarded
sudan
amplication
uential
subcubes
sidedness
subcube
bounded
fix
averaging
said
tilde
cayley
approxima
goldwasser
chockler
amplied
walsh
compact
dominates
cube
relaxed
discarded
subspace
k junta
vr f
independence test
adaptive test
size test
non adaptive
z q
least 2
sided test
two sided
test rejects
b l
jj j
junta test
negligible variation
random walk
probability 1
least 1
testing algorithm
boolean function
whose variation
variation free
property testing
step distribution
unique variation
detectable subsets
least k
f j
high probability
non negligible
distribution p
sided error
function h
n f1
declared variation
j nz
nz x
h iterations
ur f
fourier coe
function f
query complexity
v j
lower bound
testing algorithms
f passes
xj j
q queries
proposition 3
j 2
boolean functions
d p
error probability
every k
least 3
quadratic dependency
n boolean
test accepts
returns accept
invariant shift
partition whose
sided non
compact analysis
g xj
q 2
q 1
o k
lemma 3
j k
z x
k subsets
one sided
p x
queries required
satises p
adaptive testing
queries made
accepts every
approximation parameter
distributions d
probability at least
least 2 3
number of queries
vr f j
variation at least
f j 2
two sided test
non negligible variation
test with probability
jj j k
z q 2
dependency on k
variation of f
lemma 3 3
according to k
non adaptive test
k junta test
linear in 1
permutation of g
probability 1 2
x 2 f0
least 3 4
f is independent
least 1 1
rejected with probability
every k junta
found to depend
step distribution p
fourier coe cients
v j nz
number of detectable
n f1 1g
reject the input
j nz x
testing that f
contains i j
declared variation free
least 1 2
z q 1
set of coordinates
p t 2
sided non adaptive
depend on b
walk on z
j 2 assume
dominated by j
kp t p
size test rejects
partition whose variation
prove that jj
g xj j
distributions d p
log 2 r
junta with probability
least a 1
properties of boolean
test returns accept
p and dn
accepts with probability
uniformly from f0
let f f0
permutation of h
accepts every k
every i 2

corpus/krapavin2000-test/1030130.txt
hibe
fs
sk
encryption
id
secret
mhibe
keys
secure
hospital
public
pkg
pke
security
adversary
decryption
tuple
ciphertext
challenger
bdh
doctor
decrypt
broadcast
forward
bob
period
ibe
setup
identities
private
identity
encrypted
keygen
encrypt
collusion
canetti
hierarchy
msk
parse
usk
secrecy
periods
qw
entity
joining
katz
week
oblivious
silverberg
joins
halevi
gentry
resistant
bilinear
hellman
pk
er
params
child
obliviousness
root
reg
ancestors
hierarchical
pkgs
message
oracles
school
users
roles
provider
enc
boneh
communications
protokey
ig
sw
eve
ancestor
key
revoked
oracle
master
revocation
gs
parent
scheme
schemes
corrupt
joined
autonomously
encrypting
fujisaki
rbac
protokeys
sender
queries
secrets
cryptographic
tuples
upd
decrypted
hash
exposure
query
di
children
alice
scalable
responds
manager
recipient
challenged
plaintext
franklin
prefix
generator
adaptively
bf
okamoto
protects
content
compromise
center
targets
cryptography
outputs
erase
subtree
paring
fazio
halevy
dec
erased
update
role
signature
erases
plaintexts
lsd
lesson
dodis
credentials
attack
axis
pairing
appendix
guess
stateless
collude
evolves
challenge
runs
authentication
game
hierarchies
erent
node
individuals
nonadaptive
helper
lends
join
complexities
evolve
members
pairings
refresh
labeled
organizations
shamir
attacking
admissible
subsets
past
recipients
bp
authorized
wishes
entities
bellare
knows
log
leaf
tracing
compromised
cp
newly
grid
sends
receiver
evolved
fs hibe
hibe scheme
id tuple
forward secure
based encryption
public key
time period
id 1
id h
broadcast encryption
secret key
mhibe scheme
identity based
fs pke
level setup
encryption scheme
secret keys
sk w
key sk
tuple id
hierarchical identity
forward security
time periods
secure public
root pkg
joining time
id based
w h
identity set
pke scheme
hospital er
private key
lower level
multiple hierarchical
secure hibe
o h
encryption fs
key broadcast
hierarchical id
er doctor
collusion resistant
hibe 22
time oblivious
qw h
current time
chosen ciphertext
di e
private keys
id tuples
week 1
hospital school
h 1
forward secrecy
r max
e hellman
secure communications
secure hierarchical
root setup
dynamic joins
january week
bilinear di
phase 1
random oracle
oracle model
key generation
sk 0
multiple roles
h log
key update
node w
random oracles
key pk
generation time
setup algorithm
multiple identities
canetti halevi
public parameters
sw h
pke 13
compute next
ciphertext security
h associated
master secret
school manager
scalable forward
periods n
content provider
key msk
encryption mhibe
g 1
binary tree
z q
key encryption
access control
role based
scheme ii
time hierarchy
level h
key usk
adversary issues
parameter generator
setup queries
bdh parameter
silverberg 22
doctor hospital
secure broadcast
newly joined
bdh problem
way security
hibe schemes
value sk
fs hibe scheme
id 1 id
identity based encryption
lower level setup
fs be scheme
sk i h
tuple id 1
hierarchical identity based
secure public key
forward secure public
id tuple id
fs pke scheme
sk w h
forward secure hibe
id based encryption
key broadcast encryption
based encryption scheme
hospital er doctor
hierarchical id based
joining time oblivious
public key broadcast
secure hibe scheme
broadcast encryption scheme
di e hellman
random oracle model
key be scheme
h log n
o h log
key generation time
hibe 22 scheme
bilinear di e
usk t u
forward secure hierarchical
current time period
number of time
public key pk
secret key sk
broadcast encryption fs
scalable forward secure
time o h
chosen ciphertext security
multiple hierarchical identity
fs pke 13
time periods n
based encryption mhibe
encryption mhibe scheme
hospital school manager
halevi and katz
key update time
public key encryption
role based access
associated with time
based access control
pke scheme 13
o h m
next time period
bdh parameter generator
secure broadcast encryption
er doctor hospital
n o h
algorithm of fs
january week 1
sk t h
one way security
doctor hospital school
message is encrypted
w h 1
input the public
level setup queries
sk 0 1
multiple hierarchical id
secret key msk
canetti et al
scheme by canetti
forward secure broadcast
master secret key
gentry and silverberg
beginning of time
joining time obliviousness
period t n
user s secret
hierarchy e g
time of fs
takes as input
security parameter k
b 0 1
cannot be achieved
communications with entities
time hierarchy e

corpus/krapavin2000-test/1013820.txt
mts
mix
elgamal
voting
voters
authorities
voter
ballot
jury
tally
ballots
honest
bulletin
secret
votes
encryption
authority
electronic
election
dkg
vote
parties
homomorphic
board
dishonest
protocol
cast
privacy
verifiable
ciphertexts
jurors
adversary
elections
public
secure
verifiability
cryptosystem
sect
cramer
jakobsson
proposals
dex
disclose
ciphertext
hirt
sako
party
participants
permutation
cryptographic
verifier
civil
abe
implied
overwhelming
private
receipt
nk
besides
mixing
communicational
verdict
mtss
posting
tallying
deliberate
publicly
diffie
security
channel
membership
hellman
schemes
proposal
posts
tallies
interactive
henceforth
unconditionally
anonymous
jointly
validity
shares
pi
concerning
encryptions
designated
servers
chaum
member
permute
randomization
insures
declared
phase
observers
hide
schoenmakers
conicyt
deliberations
kurosawa
fondap
discloses
eligibility
chile
juries
verification
committee
government
emitted
undesirable
robustness
desires
revealing
participant
relies
correctly
belongs
threshold
witness
succeeds
criminal
verifiers
wallet
fondecyt
onion
cipher
decrypting
logarithms
malicious
robust
pedersen
coalition
accompany
canceled
untraceable
matem
suffices
universally
gennaro
desmedt
cryptographically
hiding
dept
decryption
coerced
homomorphisms
disruption
universal
sized
formed
exceeds
permuted
provers
shuffle
multiparty
rsa
sell
drop
signatures
protocols
primes
securely
cryptosystems
authorized
ff
equality
lhs
verifying
nothing
tracing
networks
la
batches
breaking
letting
stress
completeness
scoring
proofs
negligible
judge
twelve
contradict
outputs
bulletin board
mix network
election scheme
electronic voting
basic mts
mix networks
mix phase
jury voting
voting schemes
elgamal encryption
work performed
verification phase
electronic election
dkg protocol
voting scheme
non interactive
anonymous channel
final tally
homomorphic encryption
x l
zero knowledge
interactive proof
verifier zero
dishonest authorities
verifiable secret
elgamal ciphertexts
honest verifier
declared valid
output phase
receipt free
l 6
z q
information concerning
security parameter
proof pi
overwhelming probability
electronic jury
jointly generate
robust threshold
abe abe98
correctly formed
universal verifiability
dex protocol
designated area
honest authorities
mix servers
elgamal cryptosystem
cramer et
voting protocol
o nk
public key
party computation
m l
diffie hellman
elgamal re
vote tally
mts proposal
testing scheme
universally verifiable
scheme mts
correctly emitted
henceforth refer
network proposals
proposal relies
communicational complexity
ballot elections
voting phase
concerning electronic
emitted ballots
posting y
civil case
ballots besides
secret ballot
formed ballot
research concerning
efficient anonymous
public value
formed ballots
re encryption
knowledge proof
l 2r
k bit
sect 3
every l
negligible probability
one desires
randomly permute
membership testing
parallel lines
l m
secure multi
o k
discrete logarithms
computational work
h belongs
fixed sequence
electronic voting schemes
electronic election scheme
besides that implied
non interactive proof
proof of knowledge
honest verifier zero
verifier zero knowledge
x l 6
hirt and sako
cramer et al
electronic jury voting
list of elgamal
order to hide
proof of validity
voter s protocol
implied by whether
proposed in cgs97
secret ballot elections
zero knowledge proof
correctly formed ballots
jury voting protocol
correctly emitted ballots
mix network proposals
concerning electronic voting
efficient anonymous channel
testing scheme mts
succeeds in learning
two parallel lines
elgamal re encryption
based on mix
proof as proof
randomization and permutation
research concerning electronic
membership testing scheme
l 2r z
may be undesirable
lines of research
secure multi party
case t 2
security parameter k
multi party computation
sequence of integers
phase is o
mn n k
application to electronic
sake we review
basic mts proposal
log g y
j l 2r
publicly verifiable secret
k per voter
protocol is linear
o k per
subgroup g q
tallying the votes
equalities in 1
fondap in applied
multiparty unconditionally secure
simple publicly verifiable
work is proportional
concerning the tally
public value y
jakobsson and desmedt
pre specified set
jury voting scheme
proofs of partial
mathematics 1999 2000
indeed a valid

corpus/krapavin2000-test/628779.txt
coe
cients
pose
invariants
jk
rotation
recognition
estimation
algebraic
noise
shapes
curve
conic
curves
polynomial
euclidean
guitar
shape
center
std
angle
linearcenter
ip
colored
conics
dev
translation
perturbations
missing
polynomials
invariant
cubic
hawk
butter
tting
ips
deviation
2d
deviations
silhouette
centers
mig
sky
cubics
centering
rotations
rotated
degree
cient
recognizer
descriptors
alignment
subspaces
transformation
intrinsic
jj
pixels
sec
ts
arg
covariant
dierent
rst
stable
covariance
angles
angular
fig
monomials
undergone
centered
vision
scatter
percentage
orientation
deformations
perturbed
transformations
jc
radians
dened
patches
fourier
pims
weightings
quartics
radiuses
ne
accurate
indexing
3d
variability
gaussian
realizations
coordinate
database
transformed
superquadrics
radian
representations
degrees
stability
kimia
bayesian
parameterization
imaginary
translations
expansion
simplication
silhouettes
kn
estimate
implicit
diagonal
origin
species
iterated
sin
zz
iterations
dierence
discriminating
airplane
matrix
butterfly
query
careful
squared
occlusions
iterative
estimated
discrimination
homogeneous
invariance
preceding
benjamin
transforms
squares
noisy
geometric
deduce
benet
exploitation
binomial
splines
surfaces
training
followed
quadratic
realized
superimposed
nonlinear
curvature
occlusion
cosine
gradient
cos
normalization
messy
unaected
tarel
rocquencourt
inaccurately
bitangeants
domaine
wolovich
unparalleled
malah
cem
ections
sizeable
drawer
shes
barzohar
coefcients
nsalan
voluceau
helzer
coefficients
accuracy
turns
vectors
similarity
queries
perturbation
taylor
pose estimation
coe cients
complex representation
algebraic curve
polynomial coe
missing data
algebraic curves
c jk
shape recognition
colored noise
th degree
coe cient
std dev
pose independent
sky hawk
complete set
standard deviation
euclidean transformation
cient vector
euclidean transformations
standard deviations
implicit polynomial
rotation invariants
butter y
invariant recognition
degree polynomials
cients c
arg c
pose invariant
rotation estimation
data set
c 0
2d curves
independent shape
polynomial curves
deviations 0
colored gaussian
curve data
jk j
ip coe
intrinsic center
careful comparison
shape data
accurate pose
noise std
euclidean center
sec 2
sec 3
degree n
estimation based
fourier descriptors
invariant shape
complex coe
fast accurate
coordinate system
random starting
z z
recognition based
starting points
complex polynomial
leading form
3d surfaces
j kn
similar std
maximum accuracy
c jj
relative angles
angular invariants
complex basis
invariant object
euclidean invariants
noise missing
independent recognition
l jk
angle estimation
real polynomial
d l
vector c
degree polynomial
dimensional subspaces
translation estimation
single computation
rotation invariant
independent invariants
c 11
f n
linear functions
imaginary parts
degree 4
2d shape
covariance matrix
object recognition
computer vision
relative orientation
new basis
polynomial coe cients
coe cient vector
coe cients c
representation of algebraic
th degree polynomials
set of invariants
fast accurate pose
independent shape recognition
followed by rotation
ip coe cients
pose independent shape
percentage of missing
standard deviations 0
random starting points
sec 2 2
queries by example
curves and 3d
pose estimation based
noise std dev
noise missing data
dev is 0
conics and cubics
k j kn
function of increasing
cubics under rotation
d l z
center t center
pose independent recognition
rotation is 1
similar std dev
invariant shape recognition
expansion we obtain
set of independent
shown in fig
deviation of 0
translation and rotation
real and imaginary
c and c
e i j
way to compute
comparison of aligned
jc jk j
algebraic 2d curves
data 20 missing
std dev x
representation of ips
degree ip curves
set of rotation
emphasis the fact
may have undergone
values are std
proposed pose estimation
estimation between two
sec 3 2
polynomial coe cient
polynomial f n
butter y 0
error noise std
deviations 0 05
centering is invariant
capture the global
radiuses 2 2
derive a complete
system this centering
accurate pose independent
c jk e

corpus/krapavin2000-test/631068.txt
duas
adequacy
coverage
effectiveness
subjects
adequate
exposing
testing
criterion
criteria
edges
dua
null
textfmt
expose
yes
regression
asset
detm
covered
universe
transpose
frankl
associations
weyuker
buggyfind
logistic
hamlet
duran
ntafos
experiment
exposes
determinant
software
executable
sigsoft
confidence
exposed
flow
effective
program
ludcmp
subj
rothermel
vs
pascal
fault
subject
detecting
programs
instrumented
nine
proportion
gregg
error
unexecutable
extent
proportions
randomly
box
errors
percentage
engineering
hypothesis
phyllis
cover
juristo
notes
ability
empirical
weiss
practitioners
package
lu
moreno
harrold
gerhart
subdomains
positively
outputs
vegas
subsumes
bev
littlewood
burnett
goodenough
black
generation
faults
strigini
matrices
matrix
branch
white
assessing
dick
strate
text
portland
missing
detect
gies
sira
backsolving
landi
logit
labiche
statistical
infeasible
lorenzo
likelihood
questions
failure
studies
mutation
margaret
inversion
tosem
erroneous
statistically
ryder
briand
blanks
instrumenting
stubblebine
devanbu
dupuis
tse
hunter
ffl
prob
demands
comparing
bug
five
demillo
lixin
mutants
executed
seeded
testers
misleading
specification
singular
wong
goodness
oregon
comparisons
selection
eric
significance
basili
mathur
inspire
mary
sample
detects
likely
paths
inputs
test sets
test set
adequate test
adequacy criteria
null criterion
adequacy criterion
subject programs
adequate sets
yes 0
software engineering
subject program
test generation
edges adequate
data flow
detecting ability
c adequate
vs 0
dua coverage
uses adequate
test data
use associations
definition use
test case
flow testing
test cases
logistic regression
software testing
criterion c1
null adequate
missing path
executable duas
nine subjects
fault detecting
generated test
testing criteria
set size
error detecting
generation strategy
edge coverage
error exposing
edges duas
program testing
acm sigsoft
random testing
partition testing
edges criterion
edges covered
exposing ability
testing techniques
uses criterion
data adequacy
increased effectiveness
prob exposing
duas covered
set exposes
satisfy c2
algorithm 408
hypothesis testing
testing methods
white box
executable edges
null hypothesis
set sizes
software test
engineering v
notes v
sigsoft software
engineering notes
larger test
gregg rothermel
similar size
branch testing
response variable
satisfy criterion
coverage vs
position f
vs prob
lu decomposition
criterion c
given test
randomly generated
black box
random test
error increases
path testing
set satisfies
adequate test sets
expose an error
c adequate test
edges adequate sets
test set size
adequate test set
exposes an error
definition use associations
data flow testing
test generation strategy
uses adequate test
subjects all uses
generated test sets
error detecting ability
comparison of criteria
exposing an error
software engineering v
transactions on software
likely to detect
error exposing ability
effective than null
comparing the effectiveness
test set sizes
fault detecting ability
detect an error
f s c
test data adequacy
coverage and effectiveness
larger test sets
probability of exposing
test set exposes
exposed an error
data adequacy criteria
randomly generated test
edges all uses
sets that cover
sets that satisfy
software engineering notes
engineering notes v
acm sigsoft software
sigsoft software engineering
flow testing criteria
duran and ntafos
conference on software
relationship between coverage
vs all uses
satisfy criterion c1
effective than c2
associations or edges
edges or duas
significantly more effective
frankl and weyuker
test set satisfies
criteria for fixed
coverage vs prob
null adequate sets
effectiveness of criterion
vs prob exposing
sparse matrix package
sets of similar
given test set
test generation techniques
edges adequate test
software engineering p
likely to expose
ability of testing
program s flow
one test case

corpus/krapavin2000-test/634745.txt
determiners
determiner
mon
students
drank
beer
glass
monotonicity
collective
atom
plural
sentence
gqt
dfit
witness
ptriv
quantification
dalrymple
operator
scha
rtriv
existential
plurals
sentences
benthem
monotone
count
conservativity
quantifiers
atoms
distributive
five
downward
predicates
conservative
smiled
triviality
roommates
van
denotation
happy
article
shifting
quantifier
ltriv
upward
der
student
denotations
bc
collectivity
winter
entities
fitting
wit
entailments
polarity
argument
pi
reciprocal
collections
drink
hungry
counting
neutral
arguments
distributivity
definite
coffee
atomic
iff
predicate
lifting
barwise
cooperated
keenan
sisters
colleagues
conjunct
hit
truth
undesired
noun
shop
montague
men
whole
linguistic
meanings
rich
friends
plurality
yesterday
preserved
nominal
girls
preservation
singular
verb
dark
ve
theories
participated
schwarzschild
licenses
ahl
drinking
westerst
nps
cars
proposal
imposes
permutation
problematic
met
treatment
empirical
cooper
man
saw
familiar
linguistically
haifa
gqs
people
proposes
erator
articles
language
colleague
asymmetries
reformulation
interpretation
couples
sing
nouns
empirically
reflects
phenomena
implication
requirement
preserves
grammar
tautology
functors
trivial
entailment
meaning
singletons
treatments
reformulate
intuitions
participation
composition
contemporary
readings
semantics
intersection
reconsider
equivalences
derives
entail
phrase
members
operators
sang
blue
israel
lifted
items
seemingly
cons
ja
interacts
ever
came
cf
expressions
respects
treated
semantic
iota
reviewer
fauconnier
sneezed
bauerle
whole glass
beer together
monotonicity properties
exactly five
atom atom
determiner d
mon mon
atom determiner
students drank
five students
set determiner
left argument
collective predicates
dalrymple et
collective quantification
count d
type shifting
collective determiners
n operator
right argument
set set
plural determiners
atomic entities
determiner fitting
van benthem
natural language
witness operator
dfit operator
bc operator
van der
e operator
mon determiners
downward monotone
existential requirement
count operator
non ptriv
standard gqt
collective predicate
atom set
right monotone
left monotonicity
rich students
definite article
second argument
witness set
counting process
b e
exactly 5
bounded composition
atom determiners
non preservation
conservative atom
witness condition
either mon
student 0
first argument
fact 7
monotonicity loss
determiner count
generalized quantifier
sub process
right trivial
set determiners
negative polarity
global determiner
fitting operator
man 0
always preserved
distributive predicates
dark beer
coffee shop
left right
domain e
let d
power set
operator let
sentence 6
generalized quantifiers
winter 1998
non monotonicity
composition operator
truth value
monotonicity property
glass of beer
drank a whole
atom atom determiner
dalrymple et al
exactly five students
determiner over e
set set determiner
d over e
atom determiner d
properties of determiners
sets of atoms
set of atoms
d is non
mon or mon
sets of atomic
quantification in natural
five students drank
d is mon
students who drank
exactly 5 0
students who ve
ve been roommates
conservative atom atom
atom atom determiners
atom set determiner
set of sets
less than five
e the corresponding
determiner fitting operator
determiner count d
set determiner count
d is pi
glass of dark
properties of collective
students are happy
global determiner d
bounded composition operator
dark beer together
mon and mon
classes of determiners
sets of students
e and b
subsets of e
d s n
determiners that satisfy
winter 1998 2001
operator let d
drink beer 0
number of students
participated in sets
argument e g
set of students
van benthem problem
beer together b
every conservative atom
determiners in gqt

corpus/krapavin2000-test/1039903.txt
eu
ln
multiplicity
dn
oscillation
compositions
kn
composition
wilf
pittel
erd
fristedt
partitions
asymptotics
savage
corteel
asymptotic
letting
lehner
os
unconditional
expectation
oscillations
tildas
edn
dx
bernoulli
rice
rhs
sizes
equidistributed
infty
sinh
amplitude
randomly
approximating
probability
conjectures
oscillates
lim
expectations
partition
trials
integer
mt
random
sums
alternating
sn
concentrated
opened
fourier
substitution
dotted
parts
binomial
successes
asymptotically
positions
hitczenko
rightarrow
schmutz
goverened
devoting
eisenberg
stengle
lehigh
esz
thatx
kirschenhofer
unrepeated
substantiating
givesx
reasonble
kng
tossings
thanm
varialble
teel
coefficients
dt
integral
equipped
uniformly
limiting
lambda
ffiu
legality
semester
oscillatory
uncovers
pawe
oscillate
gratitude
winners
nonnegligible
enyi
goh
unexpected
stirling
herbert
approxima
mellin
walsh
gamma
head
sup
event
sequences
log
culminated
purposely
sigma
integers
probabilities
gilbert
equip
investment
bennett
goes
exhibits
summing
recurrences
nonsymmetric
andrews
heavily
estimate
around
multiplicities
hadamard
phenomenon
dominating
ev
hospitality
integrals
summands
story
suffices
argument
confirming
desires
questionable
jen
rate
fluctuations
gamman
waiting
merely
knuth
jeremy
probabilistic
exceeding
reproduce
multiset
hung
tight
negligible
conquer
repetitive
artifact
tricky
losing
nth
coarser
xn
tie
unordered
theta
convergence
bringing
inf
ignored
runs
cor
contrasts
author
du
ninth
u m
part sizes
part size
multiplicity m
m dn
m ln
ln 2
chosen part
eu n
random composition
distinct part
integer n
ln n
sum 10
different part
eu m
randomly chosen
erd os
integer partitions
pittel savage
unconditional probability
z k0
dn kn
approximating sum
corteel pittel
upon substitution
multiplicity three
dn u
n dotted
alternating sums
p a_n
x dx
log 2
bernoulli trials
k n
m n
random partition
uniform probability
n n
last part
q gamma
m increases
probability measure
head runs
e gamma2
random compositions
bound 11
concentrated around
heavily concentrated
mt dt
two expectations
latter expression
polynomial rate
called parts
eu 1
ratio u
approximate eu
eu 5
kn log
limiting distribution
exhibits oscillations
lehner 5
second probability
n p
theta 1
random variables
independent bernoulli
first probability
number 10
c n
fourier coefficients
random partitions
geometric random
fixed integer
n since
p f
lim sup
fixed m
sizes 1
selected uniformly
positive integers
expected value
first term
waiting times
approaches 1
size j
actual value
namely 1
around 1
value 1
choose k
u m dn
m ln 2
randomly chosen part
chosen part size
number of parts
distinct part sizes
different part sizes
u m n
oscillation of eu
sum over j
c 1 m
number of distinct
uniform probability measure
z k0 1
approximating sum 10
os and lehner
dn u m
comparison of eu
m dn u
p a_n m
compositions of n
dn i u
value 1 m
corteel pittel savage
dotted the approximating
n has multiplicity
log 2 n
uniformly at random
goes to 0
j 2 u
c 2 m
n n n
denote the number
m as n
kn log 2
set of part
choose k n
savage and wilf
dn i dn
independent bernoulli trials
around 1 m
size has multiplicity
ln n p
around the value
part sizes 1
fristedt s result
ratio u m
f x dx
order to bound
dn is heavily
correspondence between compositions
limit but exhibits
parts of multiplicity
multiplicity of parts
structure of random
behavior of eu
os and r
choosing a part
behavior of ln
eu about 1
kn t kn
composition is chosen
case of partitions
rhs of 3
j has multiplicity
go to 0
sizes 1 2
p j 2
term in 5

corpus/krapavin2000-test/626918.txt
mpi
cold
trace
caches
cache
megabyte
sampling
initmr
instructions
traces
samples
bias
bits
misses
cones
sample
references
million
sor
miss
instruction
intervals
interval
mapped
megabytes
stitch
fetches
fraction
lin
filtered
wood
associative
secondary
eeckhout
lieven
sampled
prefetch
estimates
simulate
confidence
workloads
byte
bosschere
mitigate
simulation
associativity
pid
win
prime
coefficient
koen
meets
variation
lengths
multiprogramming
estimate
displays
slice
percent
billion
eight
lockup
mache
compaction
indexing
cone
overestimate
instruc
half
memories
award
workload
prefetching
warm
millions
asterisk
driven
dagger
wrl
przybylski
borg
laha
associativities
titan
spl
stitching
puzak
coefficients
hierarchies
ratios
estimating
primary
virtual
calculate
calculating
vertical
unbiased
tv
equipment
filter
marked
locality
predicts
hashing
referenced
selecting
accurate
microarchitecture
awarded
corporation
sigmetrics
replacement
billions
buffers
indexed
disadvantage
examines
initialized
western
kilobytes
display
direct
cpu
adve
axis
predict
multiprogrammed
accurately
contiguous
index
category
meet
underestimate
blocks
simulations
wisconsin
laboratories
fill
horizontal
les
percentile
switch
hierarchy
risc
address
biases
prefix
operating
multi
accuracy
block
examine
temporal
foundation
slices
bell
overcoming
bytes
cray
recording
bit
ratio
fetch
reference
configurations
tens
graduate
addresses
alumni
toomula
cold start
set sampling
full trace
constant bits
time sampling
direct mapped
mpi long
megabyte caches
start bias
multi megabyte
million instructions
sampling goal
interval lengths
instructions method
mapped cache
cache performance
start techniques
set samples
instruction fetches
bits method
trace mpi
megabyte direct
way set
cache state
confidence intervals
four way
true mpi
start misses
wood et
filtered trace
index bits
initmr estimates
set associative
initial cache
interval length
bits samples
trace sampling
mapped caches
sampled instructions
selecting sets
byte blocks
per instruction
miss ratio
start technique
cache sizes
trace data
associative caches
secondary caches
miss ratios
lieven eeckhout
mpi estimates
mpi initmr
million instruction
size mpi
primary cache
eight traces
lin table
trace driven
trace size
least 90
secondary cache
misses per
per set
trace compaction
virtual indexing
win 10
five cold
instruction intervals
table displays
percent fraction
trace interval
four interval
set sample
mitigate cold
long 1000
accurate low
long traces
tree lin
address bits
cold half
use virtual
pid hashing
de bosschere
koen de
overestimate mpi
sampling coefficients
associative cache
sizes 1
sampling techniques
bits 11
address traces
full sets
cost methods
cold start bias
multi megabyte caches
direct mapped cache
cold start techniques
megabyte direct mapped
constant bits method
fraction of full
way set associative
coefficient of variation
cold start misses
wood et al
full trace mpi
initial cache state
direct mapped caches
constant bits samples
cold start technique
coefficients of variation
meets the 10
meet the 10
cones for mpi
set associative caches
misses per instruction
estimate to full
sampled instructions method
cache sizes 1
sizes 1 4
fraction of sets
four way set
traces and caches
sets in sample
mpi initmr estimates
trace mpi initmr
trace size mpi
mpi long 1000
tree lin table
accurate low cost
cache memory systems
sample s mpi
mapped and four
million instruction intervals
set sampling coefficients
low cost methods
sor and lin
full trace data
mitigate cold start
bits 11 8
trace sampling techniques
win 10 win
evaluation of cache
use virtual indexing
two way set
five cold start
koen de bosschere
methods for performance
four interval lengths
trace driven simulation
cold half prime
examine how well
sets at random
full trace data10ratio
traces four interval
millions of instructions
eeckhout koen de
billion reference traces
likely to miss
sets that share
alternative secondary caches
estimate the mpi
selecting the sets
effective than time
calculating the mpi
data initmr estimates
mapped cache sizes
prime stitch initmr

corpus/krapavin2000-test/628095.txt
datalog
lp
disjunctive
sch
stable
brave
abduction
weak
courses
phi
abductive
ground
ts
incompatible
priorities
negation
disjunction
semantics
literal
qbfs
vee
hcf
prioritization
clique
delta
logic
reasoning
cardinality
qbf
notgreater
sigma
slots
strong
oracle
stratified
neg
net
oe
lpap
sm
hyp
hardness
constraints
programs
resp
rm
maxh
literals
col
eiter
obs
cliques
lexicographically
fragments
atom
expressive
explanations
pr
violated
prioritized
francesco
greco
disallowed
truth
program
hypotheses
persons
skills
married
desiderata
propositional
fragment
tronger
unstratified
3dnf
deciding
cautious
atoms
guess
encoding
constraint
np
integrity
head
coloring
expressiveness
planning
employees
assign
polynomial
minimality
deductive
guesses
priority
incompatibilities
gottlob
leone
commonsense
joined
explanation
scheduling
instances
express
cont
relevance
colors
slot
tompits
appendixb
fink
exams
pdeciding
weakly
language
nicola
admit
expresses
existential
succ
satisfied
databases
membership
cliq
appendixa
garro
ricca
overlappings
preferred
vertices
candidate
classical
proj
palopoli
scarcello
pfeifer
perri
simona
assignment
odd
strongest
hx
fbg
supposing
luigi
lifschitz
mildly
circumscription
unusable
skeptical
infers
hierarchy
strongly
preference
preferable
disallow
alfredo
skill
sergio
gelfond
understand
interestingly
gramming
constructible
georg
overlapping
iff
interpretation
gerald
fulfills
preferably
declarative
employee
herbrand
programming
foundations
agents
gi
appearing
minimize
ai
completeness
turns
jp
discards
encode
thomas
normal
mm
coincides
syntactical
log
clause
minimal
approx
offline
datalog c
weak constraints
stable model
delta p
stable models
strong constraints
lp phi
brave reasoning
incompatible courses
weak constraint
disjunctive datalog
logic programming
model semantics
strong constraint
p sch
sigma p
minimum cardinality
c program
p net
pr p
program lp
time slots
rm datalog
vee neg
ts 1
ts 2
datalog vee
ground semantics
disjunctive logic
program p
ts 3
assign x
w r
model m
v lp
strongly incompatible
true w
hcf disjunction
x ts
sm v
violated instances
datalog programs
literal q
rule r
logic programs
h p
datalog program
oe x
c 0
clique c
truth assignment
knowledge representation
positive program
neg c
complexity results
o log
w 3
c programs
constraint w
p 3
complete problems
log n
p m
polynomial hierarchy
different priorities
lp 2
stratified negation
p o
w 1
expressive power
lp net
phi oe
priorities among
minimum truth
ground lp
candidate model
lp sch
lexicographically minimum
lp satisfying
maxh p
see lines
input deciding
theorem 19
optimization problems
following program
deciding whether
graph theory
based problems
interpretation m
max clique
propositional case
assignment oe
disjunctive programs
abductive logic
thomas eiter
ground instances
whether q
theorem 17
polynomial time
logic program
x n
p 0
r 0
p complete
theorem 21
w 2
lp p
input facts
cardinality criterion
col x
datalog c program
delta p 3
number of violated
stable model semantics
q is true
stable model m
models of lp
datalog vee neg
rm datalog vee
h p m
model of p
constraints in w
datalog c programs
o log n
sm v lp
p a sch
true w r
v lp phi
delta p o
m of lp
weak constraint w
model of lp
assign x ts
given a datalog
p o log
models of p
q as input
sigma p 2
p 3 o
ts 1 ts
vee neg c
r t m
minimize the number
complexity of datalog
lp a sch
sch of section
knowledge based problems
semantics for disjunctive
deciding whether q
exists a stable
delta p complete
lexicographically minimum truth
model for lp
constraint w 1
truth assignment oe
datalog by constraints
complexity of brave
input deciding whether
instances of weak
courses to time
reasoning on datalog
instances of w
minimum truth assignment
solutions of p
logic programming v
practice of logic
disjunctive logic programming
rule r 1
planning graph theory
complexity of reasoning
ts 3 course
strongly incompatible courses
ts 3 ts
p is delta
program literal q
false w r
abductive logic programming
disjunctive logic pro
datalog program lp
minimum cardinality criterion
lp p sch
p 3 complete
ts 1 assign
x ts 2
c program literal
finally the weak
oe x n
ts 2 assign
reasoning is delta
semantics of disjunctive
program p sch
x ts 3
easy to understand
theory and practice
number of calls

corpus/krapavin2000-test/626956.txt
lapack
sticky
rcond
nan
strsv
exception
exceptions
arithmetic
flags
overflow
triangular
speedups
blas
floating
trap
sgecon
handling
decstation
eigenvectors
eigenvalues
dec
underflow
nans
ctrevc
sbdsqr
slower
cm
quit
cray
ill
matrices
infinity
speed
alpha
ov
bisect
bisection
routine
conditioned
tridiagonal
clatrs
strcon
sgbcon
spocon
routines
fortran
endif
reciprocal
matrix
eigenvector
eigenvalue
jja
unexceptional
ctrsv
slatrs
slow
scalings
mips
subprograms
sparcstation
speeds
endfor
kahan
count
division
nonsticky
jjxjj
cgeev
infinities
inderjit
denormals
algebra
speedup
cc
estimation
calling
cleared
dhillon
singular
scaling
algo
default
bits
toms
bidiagonal
numerical
slowly
conventional
manual
invalid
exceptional
traps
chip
gammat
machines
inner
sparc
symmetric
paradigm
attained
megaflops
pivmin
signbit
demmel
denormalized
sstebz
exceptionreset
denormal
status
oe
subroutine
unstable
precision
answer
pivot
risc
norm
ipx
buggy
sun
hessenberg
fastest
grained
rare
terribly
flag
solve
else
abort
jj
handles
rot
reliably
quickly
testing
unpleasant
amortize
jz
raised
pipelined
ranging
solving
costs
tests
growth
spent
slowdown
mp
scaled
pivoting
fast
diagonal
badly
multiplies
moderately
cpu
instructions
prefix
loop
inexact
lessons
ranged
register
dense
granularity
subroutines
calls
unlikely
ae
seldom
recompute
codes
pipelining
enormous
scales
optimized
transpose
occurred
stopping
reasonably
incorrectly
gammapivmin
trapenable
inadvisable
deserved
weitek
christof
exception handling
full speed
condition estimation
sticky flags
speed full
floating point
infinity arithmetic
dec 5000
exception occurs
cm 5
rcond 0
algorithm 2
decstation 5000
ieee standard
ill conditioned
symmetric tridiagonal
linear algebra
dec alpha
exceptions occur
cray c90
calling strsv
conventional arithmetic
triangular system
basic linear
triangular solve
trap handling
numerical algorithms
using algorithm
algorithm 7
point arithmetic
algorithm 4
algebra subprograms
phase 2
condition number
algorithm 1
triangular systems
sun 4
lapack routine
fast exception
nan arithmetic
slow dec
exception bits
fast dec
using exception
solve calling
blas routine
quit endif
testing sticky
bisection algorithms
ieee arithmetic
slower cc
computing u
inner loop
algorithms 3
algorithm 6
eigenvector computation
triangular matrices
phase 1
lower triangular
eigenvalues less
g un
sticky bits
speed manual
else solve
complex matrix
routine strsv
pivot growth
tridiagonal eigenvalue
count oe
general complex
status flag
endfor return
matrix dimension
nonsticky exception
overflow division
quit else
slower full
parallel prefix
via exception
count function
computing eigenvectors
solve triangular
lapack library
return c
normal arithmetic
slow decstation
oe endfor
times slower
point operations
linear systems
without exception
bisection algorithm
right eigenvectors
optimized blas
jj 1
avoid overflow
mips r3000
one norm
endif else
common case
upper triangular
complex matrices
software toms
toms v
max n
error bound
singular value
point number
mathematical software
speed full speed
full speed full
rcond 0 quit
except then rcond
occurs when computing
nan and infinity
division by zero
strsv if except
basic linear algebra
floating point arithmetic
sun 4 260
linear algebra subprograms
n by n
fast dec 5000
testing sticky flags
fast exception handling
slow dec 5000
using exception handling
solve calling strsv
number of eigenvalues
floating point operations
finding the eigenvalues
triangular system 3
tridiagonal eigenvalue problem
general complex matrices
blas routine strsv
used in lapack
tests and scalings
endfor return c
equal to oe
eigenvectors of general
quit endif else
max n 3
oe endfor return
arithmetic with nans
chip as cpu
full speed manual
zero and invalid
test for exceptions
slower full speed
via exception handling
n 3 ae
without exception handling
speed of nan
nonsticky exception bits
fast as conventional
estimation and eigenvector
symmetric tridiagonal eigenvalue
software toms v
mathematical software toms
using algorithm 2
symmetric tridiagonal matrix
floating point number
transactions on mathematical
numerical linear algebra
need to solve
algorithms for solving
arithmetic with denormalized
report performance results
x would overflow
user level trap
exception handling section
numerical algorithms via
jx i j
time of 0
inside algorithm 2
subprograms for fortran
estimate jja gamma1
j where jz
slower f77 full
unexceptional floating point
faster numerical algorithms
algorithms via exception
ieee single precision
use in condition
arithmetic with sigma1
long excluding comments
longer than phase
rcond 1 ov
mp el 2
floating point operation
avoid all exceptions
conventional unexceptional floating

corpus/krapavin2000-test/631132.txt
usage
certification
profile
reuse
reliability
shy
certified
mtbf
reused
certify
chart
profiles
probabilities
failure
behaviour
modelling
software
services
module
acceptance
vii
service
reusable
rejection
stimulus
markov
repository
musa
dial
tnorm
certifica
hypothesis
transition
accepted
users
external
objective
component
constituents
changed
testing
failures
conformity
dials
wohlin
runeson
osman
poore
balci
complemented
chain
hierarchy
adjustments
confidence
probable
structural
correction
idle
resetting
concluded
events
script
growth
calculations
rejected
development
labs
telecommunication
compo
operational
faults
chapter
emphasized
stored
article
appended
configurations
perceived
certifi
cific
hendrick
peraphon
severities
sheppard
sophatsathit
graeme
traceability
nance
marketed
tification
nakkrasae
antonellis
ormsby
sathit
accreditation
developmental
brantestam
modularity
fall
corrected
predetermined
adjustment
developing
attached
castano
interdependence
condon
prechelt
dunn
pernici
certi
walcelio
fied
melo
emam
cer
reset
emerging
ring
indirectly
predictions
composed
chains
measures
profiled
personnel
horizons
whittaker
ischia
spective
tichy
knight
helen
tomacs
nent
rework
receiver
modelled
reliable
disadvantage
zhuge
markets
khaled
exceptionally
richardson
assess
drawn
plotted
concerning
fault
normalized
basili
calendar
ures
fulfil
certifying
johan
engineering
impossible
region
spe
whilst
links
lutz
arthur
ponents
interdependent
digit
administration
usage model
usage profile
software components
behaviour level
usage models
hypothesis certification
certification model
vii certification
shy model
usage profiles
control chart
reliability measure
failure data
component certification
usage modelling
user types
test cases
user type
new usage
service s1
expected usage
reliability measures
usage testing
usage level
failure time
reusable components
reused without
external user
certifica tion
level usage
shy models
reused component
mtbf requirement
different usage
level user
structural usage
state hierarchy
software systems
software reliability
reliability growth
points fall
given degree
external view
software engineering
type level
module m
system configurations
components must
chapter 5
markov chain
also means
model must
reliability level
user b
hierarchy model
service usage
future reliability
model parts
components system
operational profile
q labs
external users
system context
time tnorm
parts hence
test script
failure types
components also
new profile
arbitrary usage
modelling 3
actual usage
component developed
usage state
system constituents
new certification
entire usage
failure number
dials b
required mtbf
modelling usage
certification of software
hypothesis certification model
profile the usage
model and usage
certification of components
user type level
different usage profiles
usage model must
development with reuse
new usage profile
behaviour level usage
reuse of components
acceptance or rejection
generation of test
must be derived
makes it possible
degree of confidence
usage modelling 3
changed to s2
characteristics usage model
new certification must
actual usage profile
quality of software
profile the reliability
software components proceedings
et al musa87
must be certified
assignment of probabilities
modelling of software
therefore the usage
shy usage model
component the usage
number is drawn
component is stored
state hierarchy model
different system configurations
components also means
software components 5
software reuse emerging
simple example usage
another usage profile
failure time tnorm
user of type
drawn for example
transition from idle
specific reliability level
collection of failure
level user type
execution of test
cases and collection
normalized failure time
software components system
reuse emerging technology
developed for reuse
reliability measure stored
usage level user

corpus/krapavin2000-test/627400.txt
ldl
prolog
query
manager
pcg
fixpoint
anc
deductive
marc
database
recursive
optimizer
predicate
relational
logic
pipelined
recursion
horn
compile
materialized
ull
declarative
salad
tuples
compilation
rewriting
lazy
compiler
fad
queries
backtracking
cliques
databases
language
rule
magic
existential
sg
dredging
backtrackable
enhancer
rpcg
experience
datalog
tuple
safety
semantics
rules
grandma
unification
navigational
constructs
join
pushing
dbmss
employee
education
compiled
predicates
languages
executions
clique
sql
shtz
admin
llo
externals
divesh
rigel
modules
intelligent
negation
updates
arguments
execution
nats
leon
harvard
segev
coral
raghu
procedural
expressive
sigmod
naive
unnecessary
backtrack
exit
bases
adornment
reentrant
srivastava
unsafe
goals
sudarshan
usability
ease
college
schema
idempotence
zaniolo
greedily
arie
recast
programmer
record
counting
parents
migrated
translator
fm
responsible
efficiently
superfluous
ramakrishnan
materialization
prototype
annotations
keot
stonebraker
krza
peephole
veko
bnst
nakr
seasons
recounts
seshadri
parent
pushed
generator
elimination
joe
optimizing
duplicates
relations
selection
functionality
stratification
chaining
convoy
educe
sld
seminaive
carol
domenico
kms
mengchi
amateur
universality
harnessing
poulovassilis
bmsu
ambriola
alexandra
commutativity
prototyping
rapid
occurrence
descriptor
antonella
praveen
conducive
enumerative
adorned
safe
school
ancestor
binding
grouping
strategies
zhao
management
annealing
migration
nested
intensive
jiawei
vincenzo
evaluable
determinism
clauses
calculus
termination
interface
external
committed
founded
cyclic
fact manager
query form
pipelined execution
intelligent backtracking
compile time
deductive databases
run time
ldl compiler
data language
bound arguments
lazy pipelined
materialized execution
predicate occurrence
set terms
unique representation
counting method
get next
recursive clique
rule set
ldl system
anc x
lazy materialized
anc marc
logic data
recursive cliques
recursive query
semi naive
logic based
declarative semantics
execution strategy
rule based
logic programs
execution space
single fixpoint
data dredging
z anc
generalized counting
complex terms
fm get
form manager
efficient execution
non recursive
relational databases
language ldl
recursive queries
code generator
rule rewriting
expressive power
logic programming
complex objects
database system
data engineering
fixpoint computation
magic set
recursive rules
relational algebra
database systems
employee name
query optimization
programmer must
horn clause
recursive rule
data bases
j leon
ldl queries
leon zhao
manager provides
constant migration
ldl implementation
derived relations
superfluous work
college harvard
segev j
connection graph
non horn
rule transformation
next tuple
domain calculus
horn constructs
divesh srivastava
ramakrishnan divesh
predicate connection
arie segev
backtrack point
execution strategies
answer justification
naive fixpoint
name joe
module types
compilation techniques
deductive database
horn clauses
execution model
user interface
query language
record v
sigmod record
data intensive
intensive applications
engineering v
logic queries
relational dbmss
processing strategies
get first
logic database
application language
raghu ramakrishnan
rule manager
binding pattern
ldl programs
various execution
database query
based language
programming language
logic data language
knowledge and data
ease of use
generalized counting method
lazy materialized execution
data language ldl
query form manager
lazy pipelined execution
rule for p
data engineering v
transactions on knowledge
large data bases
data and knowledge
data intensive applications
run time 3
tuples in p2
use of ldl
semi naive fixpoint
rule transformation techniques
employee name joe
magic set method
rule for r
non horn constructs
segev j leon
j leon zhao
ramakrishnan divesh srivastava
commutativity and idempotence
fact manager provides
raghu ramakrishnan divesh
predicate connection graph
rules and goals
arie segev j
anc x z
srivastava s sudarshan
sigmod record v
acm sigmod record
n 2 p
propagation of selection
query processing strategies
recursive query processing
logic based language
engineering v 7
database query language
data bases p
minimum cost execution
compiled query form
rule to ensure
base and derived
towards a real
horn clause language
pushed into recursion
sg marc x
recursively defined relations
optimizing existential datalog
z anc x
harvard bs math
similarly the fact
containing set terms
language ldl system
answer justification capability
updates in rigel
smalltalk a database
views and updates
prolog a database
manager section 3
june 1 1993
z anc marc
modules and externals
appropriate execution strategy
rules are compiled
marc z anc
safe and efficient
existential datalog queries
tuple in p2
anc marc z
data abstraction views
constant migration step
relation say rp2
bs math 1971
efficient and portable
next backtrack point
easy to develop

corpus/krapavin2000-test/1022335.txt
lh
father
sublabel
label
animal
terminological
kb
resolution
sorted
pn
sort
symbols
hierarchy
lb
sorts
ancestor
fn
human
predicates
kaneiwa
labels
unary
subsort
tom
formulas
llb
subordinate
hierarchical
parent
john
labeled
mother
signature
deduction
assertional
substitution
substitutions
predicate
usages
lottery
daughter
clause
child
descendant
mgu
erent
logic
ary
clausal
son
hierarchies
won
subpredicate
terml
roles
ken
inconsistent
declaration
om
symbol
declarations
reasoning
clauses
interpreted
constants
bird
interpretation
lucky
names
individuals
sublabels
tojo
language
elimination
di
rules
unifier
beierle
formula
atomic
semantically
relationships
relations
inference
expressions
rela
rule
satisfiable
walking
un
conceivable
kinds
replacements
proposition
lexical
xm
expresses
hierarchically
diversity
complicated
fig
employed
formality
steamroller
culture
attributive
actualizes
fbr
undescribed
olution
kayamori
iucludes
superlabels
base
sentence
regarded
viewpoint
login
subsorts
inconsis
schubert
refutation
variously
occurring
interacting
logics
languages
satisfaction
rigorous
exclusive
negation
relabeled
derivability
tent
cohn
vl
advancement
informational
inductively
nonempty
semantics
pragmatics
reflexivity
lattice
semantic
logical
syntax
ontologies
relation
consistently
usefully
concisely
mere
chy
redesign
enrich
ministry
sports
insu
flexibly
hierar
composed
enriched
partially
res
sis
conciseness
denotation
ordinary
enhanced
recognizes
entail
conforms
defer
unification
separated
classifies
compositions
role
losing
spectively
develop
query
binary
straightforwardly
investigates
education
derivable
declare
conform
embed
respec
tively
gained
derivation
formalisms
label based
l pn
resolution system
label hierarchy
labeled signature
l fn
sort hierarchy
hierarchical resolution
order sorted
sorted resolution
l p1
terminological knowledge
sorted logic
resolution rules
based language
label terms
based formulas
sublabel relations
x l
knowledge base
kb lh
labeled substitution
sublabel relation
lh structure
lh interpretation
label formulas
sort predicates
lh model
hierarchical relationships
labeled substitutions
l lb
constants functions
assertional knowledge
empty clause
let lh
hierarchical representation
ken kaneiwa
sorted substitution
sort symbols
child father
unary predicates
elimination rule
symbol names
base kb
father mother
unary predicate
n ary
subset relation
mother son
complicated sublabel
john human
terminological hierarchy
sort l
label clauses
sublabel rule
animal ancestor
language llb
pn l
subordinate relations
label clause
di erent
l c
son daughter
subsort relation
parent child
ancestor p2
un u
signature lh
sorts constants
daughter john
hierarchy lh
deduction rules
relation l
ary predicates
john c
ancestor descendant
human animal
binary predicates
inconsistent set
fn l
simple sublabel
resolution rule
deduction rule
based expressions
sorted substitutions
role symbols
animal lb
sorted variable
human human
john tom
label father
subpredicate relation
label formula
hierarchical expressions
subordinate relation
unary function
erent kinds
animal p1
tom human
human won
father parent
ancestor animal
based sort
predicate symbols
proposition 5
c f
descendant parent
various symbols
function symbols
erent types
label based language
order sorted logic
hierarchical resolution rules
label based formulas
formulas in hierarchical
resolution for label
sorted resolution system
kinds of symbols
l s d
logic with sort
knowledge base kb
types of subordinate
parent child father
symbols of labels
mother son daughter
complicated sublabel relations
father mother son
order sorted resolution
child father mother
c f p
terms and formulas
functions and predicates
u 1 un
based language llb
labeled signature lh
son daughter john
animal ancestor descendant
sorts constants functions
label hierarchy lh
l pn l
l p1 l
u i l
substitutions and hierarchical
n ary predicates
u u 1
base if kb
derive the empty
label based expressions
set of sort
knowledge and assertional
label based sort
simple sublabel relations
system for label
pn l pn
john and tom
daughter john tom
predicates and sorts
hierarchical resolution system
descendant parent child
hierarchical relationships among
di erent kinds
usages of labels
based sort hierarchy
roles of symbols
l 1 l
set of labels
set of label
ancestor descendant parent
sets of individuals
di erent types
representation and reasoning
proposition 5 2
present a label
expression of sort
first order symbols
terminological hierarchy section
kaneiwa and tojo
ancestor descendant human
together with assertional
resolution system without

corpus/krapavin2000-test/629396.txt
speedup
ksr
uniprocessor
scalability
subcache
processors
superlinear
eq
scaled
isospeed
cache
mflops
sequential
generalized
speed
ring
traditional
virtual
asymptotic
processor
remote
unitary
householder
memory
shared
kendall
rlsp
isoefficiency
xian
speedups
engine
theta
efficiency
proportionally
inefficient
slalom
mbytes
sizeup
regularized
rings
scaleup
matrix
ratio
cycles
machines
computers
scalable
superlin
burg
reform
stablized
scalabilities
allcache
intensive
fig
maspar
doubled
measurement
metric
parallelism
latency
access
iso
scientific
metrics
elapsed
equals
squares
givens
unscaled
ncube
quotient
influence
hierarchy
shifting
measured
fat
gbytes
scales
factorization
cornell
puters
se
profile
paragon
inefficiency
fits
slows
slower
bounded
accommodated
deficiency
sun
unity
group
analytic
cm
solved
perfect
cubic
benchmark
square
engines
platforms
solving
gpst
pantano
abstractgeneralized
dorder
consedered
debatable
jogalekar
processers
commonly
timing
achieves
clock
floating
consumed
fixing
intel
machine
passing
industries
tmc
superlinearity
agencies
credits
patterned
malloc
prasad
fahringer
woodside
inflated
deductions
gustafson
offset
revealed
ideal
speeds
excellent
finish
cause
measures
grand
sandia
enjoyed
jianping
advancement
unprecedented
amdahl
unmeasurable
extremely
causes
instruction
numerical
big
arena
unlikely
seven
locate
targeting
skill
elusive
porting
technology
maintained
significantly
increased
columns
flops
connecting
absolute
equality
government
murray
cessing
noticeably
wonder
efficiencies
kbytes
simulators
segments
sparse
calculated
qr
tridiagonal
search
generalized speedup
traditional speedup
ksr 1
memory bounded
problem size
fixed time
shared virtual
virtual memory
asymptotic speed
scaled speedup
superlinear speedup
bounded speedup
sequential processing
group 0
sequential speed
theta theta
parallel processing
isospeed scalability
relative speedup
memory access
c p
remote access
single processor
time generalized
average speed
scaled problem
uniprocessor efficiency
local cache
w 0
remote memory
ring 0
parallel speed
fixed size
generalized efficiency
local memory
search engine
memory machines
parallel computers
work w
access time
uniprocessor cost
scalability 12
multiple processors
time speedup
execution time
kendall square
parallel computer
ring ring
size speedup
bounded generalized
uniprocessor speed
speedup given
computational speed
ring 1
square ksr
algorithm machine
regularized least
traditional scaled
processors increases
virtual address
sequential algorithm
memory hierarchy
increases proportionally
local ring
engine 0
p processors
computation intensive
group 1
large problem
cost ratio
processor cycles
system size
local access
asymptotic cost
measured superlinear
absolute speedup
machine combination
work types
profile shifting
speedup 3
access ratio
machine clock
size traditional
uniprocessor execution
unitary speedup
reasonable measurement
bounded scaleup
householder transformation
problem sizes
large problems
memory machine
eq 6
intensive applications
distributed memory
one processor
sequential execution
parallel work
scientific application
clock rate
analytic model
equals one
simple analytic
parallel execution
parallel system
size increases
passing model
timing results
performance metrics
shared memory
sequential time
parallel algorithm
shared virtual memory
group 0 cache
memory bounded speedup
number of processors
theta theta theta
virtual memory machines
fixed time generalized
time generalized speedup
ksr 1 parallel
speedup is linear
p i w
fixed time speedup
speedup is unitary
speedup is defined
traditional scaled speedup
scalability 12 equals
regularized least squares
group 1 cache
xian he sun
speed over sequential
p s w
time of per
speedup the scaled
kendall square ksr
defined as parallel
causes of superlinear
bounded generalized speedup
square ksr 1
memory bounded generalized
fixed size speedup
search engine 0
problem size increases
remote memory access
processors are active
c s w
time and memory
problem is solved
memory bounded scaleup
may not equal
algorithm machine combination
cache and group
virtual memory machine
remote access ratio
machine clock rate
computation intensive applications
measured superlinear speedup
local ring ring
virtual address space
size traditional speedup
ring ring 0
simple analytic model
shared virtual address
memory access time
sequential execution time
speedup the speedup
parallel execution time
mbytes of local
message passing model
shared memory model
shown in fig
sequential and parallel
cost is fixed
matrix is increased
size increases proportionally
scaleup then memory
define the uniprocessor
problem size w
search engine se
speeds for different
speed is defined
analytic model 4
existing performance metrics
processors generalized speedup

corpus/krapavin2000-test/628823.txt
mvc
cluster
clusters
gmm
plateaus
plateau
variance
clustering
samples
border
outliers
candidates
tendency
partitional
tendencies
nearest
criterion
hit
foreigners
neighborhood
strength
segmentation
epochs
towns
furthest
sample
iris
outer
german
gaussian
fig
annealing
expansion
constraint
assessment
rank
genetic
prominent
mixtures
neighbors
lumped
ms
em
delft
veenman
greed
reinders
asok
dga
neighbor
homogeneity
neighboring
displayed
foreign
unite
square
fuzzy
clusterings
rajagopalan
maximisation
stochastic
likelihood
fastest
accordingly
statistical
inner
cordingly
mates
venkatesh
colored
grey
certainly
collect
optimum
discover
originating
defect
hypothesized
squared
cumulative
ranking
max
display
unsupervised
occasional
recognition
simulated
convergence
locality
evolutionary
varied
candidate
image
tarroux
irises
eucledian
arguable
mediamatics
coevolutionary
andrey
foreigner
selectionist
samsi
amador
classifier
impose
joint
optimization
ray
union
rohan
rion
jhin
precautions
mayer
butions
sian
wende
varying
putting
displays
curve
priori
circular
isolated
knee
copes
agglomerative
crite
artificial
isolation
undesirable
dencies
demarcation
concatenate
constellation
seeded
inhomogeneous
distributions
predefined
expresses
removal
significant
proper
marcel
isolates
bors
robust
lists
merged
gain
validity
ac
separate
statistics
nonparametric
optima
conceptually
growing
distance
resemblance
oscillations
disrupt
epoch
act
randomly
fractal
rating
neigh
ga
leading
textured
mutation
centroids
skipping
rearranged
prevent
categorized
homogeneous
k means
mvc algorithm
variance constraint
data set
gmm algorithm
means algorithm
expansion candidates
j e
maximum variance
constraint parameter
outer border
gmm method
cluster tendency
square error
cluster tendencies
rank list
statistical results
error criterion
hit m
method parameter
means table
ms k
parameter hit
cluster c
image segmentation
tendency assessment
significant plateau
inner border
real structure
clustering result
german towns
means model
variance cluster
time ms
optimization process
cluster algorithm
similar 2
iris data
points points
d gaussian
k nearest
one cluster
m time
hit rate
simulated annealing
partitional cluster
significant plateaus
curve resulting
mixtures modeling
cluster algorithms
prominent plateaus
nearest foreigners
border b
discover cluster
c display
means k
joint variance
towns data
cluster variance
maximum plateau
plateau strength
grey colored
neighboring cluster
cluster neighborhood
colored cluster
data sets
corresponding clustering
e max
gaussian mixtures
see fig
nearest neighbors
x c
separate clusters
gaussian distributions
computation time
th order
respectively 3
em algorithm
modeling gmm
cluster models
cluster mates
cluster mvc
mvc method
rank lists
symbolic time
cluster instead
individual clusters
cluster mean
fuzzy clustering
cluster sample
constraint instead
j veenman
gaussian clusters
neighboring samples
criterion optimum
cluster model
hypothesized clusters
local criterion
neighbor ranking
clusters act
e plateaus
k means algorithm
number of clusters
means and gmm
e and m
time ms k
k means table
method parameter hit
variance constraint parameter
hit m time
parameter hit m
ms k means
applying the algorithms
m time ms
maximum variance constraint
results of applying
square error criterion
maximum variance cluster
resulting from varying
similar 2 d
m are displayed
set of expansion
iris data set
able to find
towns data set
discover cluster tendencies
gaussian mixtures modeling
number of epochs
cluster with respectively
d gaussian distributions
k means model
maximum plateau strength
german towns data
grey colored cluster
varied the 2
k means k
ranking for sample
points points points
means k means
cluster tendency assessment
outer border b
k nearest foreigners
number of candidates
n x y
b j e
constraint in order
squared error criterion
set is shown
sum of squared
f n x
fig 4 b
modeling gmm method
g x q
x in y
robust in finding
mvc algorithm may
nearest neighbors method
samples in c
matches the samples
display the neighborhood
notion of foreign
act in parallel
symbolic time series
furthest cluster mates

corpus/krapavin2000-test/627126.txt
edt
sn
broadcasting
star
subtree
fault
spanning
multinode
spg
tolerant
necklace
spt
transmissions
scattering
node
subtrees
parent
messages
disjoint
message
tolerance
children
mx
rooted
hypercube
rotation
edge
port
edth
interconnection
wishes
symbol
trees
mxn
necklaces
misplaced
exchange
rotations
receives
adjacent
translation
shortest
network
cyclically
neighbor
broadcast
unfolded
nodes
edges
dimension
packets
pancake
pipelined
symbols
ng
dimensions
paths
transmitted
abderezak
touzene
cn
communication
transmit
cycle
degree
belongs
destined
consequence
hypercubes
source
ports
incident
cube
gamma
specificly
minimumnumber
transmits
forwards
controlling
faulty
transmission
lemma
lengths
neighbors
connected
fujita
satoshi
diameter
simultaneously
processors
depth
routing
breadth
excluding
performances
asymptotically
ll
operate
shuffle
send
grouped
networks
root
subsection
butterfly
permutation
topology
tree
conflicts
sends
net
fourier
cycles
election
acknowledgement
communicated
multicomputers
occupies
pipelining
dim
graphs
computers
bidirectional
spans
enclosed
destination
abstractdata
rectangulars
lih
rescigno
allport
substar
whishes
calligraphic
laceability
carlson
jianer
reliability
avoidance
soon
li
child
position
originating
bounds
analytically
biing
schematical
fkg
monien
burkhard
sublogarithmic
factorials
chyun
sth
transposing
distance
ae
utilized
kuan
hsing
tsai
hamiltonians
bradley
edge disjoint
node broadcasting
single node
disjoint spanning
spanning trees
fault tolerant
multiple edge
m messages
node scattering
star network
multinode broadcasting
broadcasting algorithm
message transmissions
tolerant single
source node
node receives
transmissions required
fault tolerance
total exchange
node h
node wishes
tolerant algorithms
n gamma
tolerant multinode
communication algorithms
n gamma1
nodes adjacent
trees structure
port assumption
d mx
gamma 1
disjoint subtrees
broadcasting d
cycle notation
parallel paths
communication assumption
parent edt
n l
star graph
symbol 1
children nodes
interconnection network
port communication
hypercube network
o mxn
edt h
optimal single
shortest path
spanning tree
optimal since
path tree
example node
m fault
different edge
star graphs
optimal communication
misplaced symbol
tolerant total
tolerant communication
sn o
broadcast m
h rooted
children edt
broadcasting single
time required
r k
dimension k
lower bounds
m n
star interconnection
scattering algorithm
time step
d m
k gamma2
distinct messages
transmissions single
cn o
mx 2
disjoint subtree
rotation operation
symbol cyclically
parent spg
separately 1
first misplaced
exchange problems
children spt
broadcasting multinode
different dimensions
message transmission
data communication
part separately
single node broadcasting
disjoint spanning trees
edge disjoint spanning
multiple edge disjoint
edt i n
single node scattering
subtree t edt
nodes of sn
tolerant single node
fault tolerant single
message transmissions required
number of message
degree of fault
node broadcasting algorithm
l i n
n gamma 1
fault tolerant algorithms
translation with respect
fault tolerant multinode
tolerant multinode broadcasting
node i n
m n gamma
edt i l
h of sn
spanning trees structure
respect to h
communication and fault
edge disjoint subtrees
connected to subtree
b 3 n
optimal single node
subtrees t edt
algorithm to complete
operation of translation
m fault tolerant
port communication assumption
spg i n
edge of dimension
scattering and total
shortest path tree
rooted at node
parent and children
wishes to broadcast
multinode broadcasting single
subtree t edth
broadcast m messages
node scattering algorithm
node i 2
r k gamma2
node broadcasting d
wishes to send
edt i 4
fault tolerant communication
fault tolerant total
tolerant total exchange
broadcasting single node
controlling the degree
wishes to transmit
edt h rooted
respectively through subtrees
different edge disjoint
root of multiple
k n respectively
part separately 1
n of sn
first misplaced symbol
spg i l
number of transmissions
tolerant communication algorithms
n l l
using the operation
broadcasting multinode broadcasting
edge in dimension
nodes r k
message through paths
prove each part
right of symbol
node of sn

corpus/krapavin2000-test/628197.txt
sectors
cav
clv
qualifying
sector
disks
disk
zcav
proximal
tracks
cylinders
rotational
magnetic
zone
head
track
optical
seek
platter
settle
velocity
window
angular
transfer
proxw
spiral
zones
storage
command
technologies
ms
laser
concentric
revolution
cylinder
switch
comprehensive
zoned
devices
missed
analytical
delay
drive
lying
headswitch
platters
scanned
seeks
capacities
controller
capacity
beneath
retrieval
backward
cache
accesses
radial
device
qualifies
termed
beam
intersector
diversion
drives
tertiary
striping
successive
read
unifying
middle
rot
surface
format
velocities
target
admission
retrieved
distance
region
outer
innermost
recording
validated
multimedia
video
products
champion
csb
forward
kb
paid
block
sy
rom
hp
workloads
modeled
pick
accessed
outermost
blocks
placement
optimizer
request
delays
rel
cs
access
gap
deltap
inforwards
jukeboxes
offness
diverted
plattered
csm
diverting
recordable
diverts
technology
requests
brought
qualify
paying
indexed
reaching
const
surfaces
secondary
analytically
modeling
beginnings
hitachi
kz
retrieving
estimating
readable
average
spirals
resynchronization
fundamental
contribute
departure
controllers
simulation
cd
queuing
inch
branched
traveled
gammaj
nc
offs
bypass
heads
rate
forwards
rates
mass
scanning
landing
rob
scan
jump
costs
underneath
query
reside
modern
speed
acceleration
characteristics
validation
positions
position
insights
switches
arm
servers
reach
wait
mention
simulator
arrives
usenix
additionally
synchronization
hybrid
simulated
reads
verification
impacts
backwards
proximal window
qualifying sectors
head switch
zcav disk
rotational delay
seek cost
optical disks
magnetic disks
qualifying cylinders
clv cav
angular velocity
window cost
command processing
switch cost
cav disk
th zone
cache missed
successive qualifying
settle cost
cost proxw
qualifying tracks
zone z
total average
clv disk
track capacity
qualifying sector
target track
disk technologies
comprehensive model
transfer cost
transfer rate
read sector
zcav disks
sectors per
sectors n
expected number
storage capacities
missed qualifying
seek operation
cav disks
forward access
n sectors
target sector
window access
sector time
per track
storage devices
ms number
radial line
access region
cav clv
middle region
performance behavior
backward access
concentric tracks
linear velocity
sectors scanned
clv disks
processing time
retrieval cost
distance j
cost seek
spiral track
existing disk
disk products
disk technology
rotational delays
admission controller
cav magnetic
optical disk
clv optical
storage capacity
transfer rates
rotational speed
delay rot
cav part
single spiral
average rotational
laser beam
cost ms
magnetic cav
first sector
z cost
disk head
two successive
linear phase
access cost
performance model
disk storage
randomly distributed
possible future
head position
backward accesses
average head
linear velocities
n zcav
outer tracks
random workloads
average proximal
cost transfer
forward accesses
first qualifying
j qualifying
pick n
hybrid disk
window accesses
disk simulated
disk surface
device technologies
full revolution
multi spiral
line indexed
expected head
gap j
number of sectors
proximal window cost
head switch cost
command processing time
number of qualifying
qualifying sectors n
read sector time
sectors per track
proximal window access
missed qualifying sectors
cache missed qualifying
number of cache
two successive qualifying
successive qualifying cylinders
number of cylinders
number of tracks
r p m
clv cav disk
cost ms number
cav magnetic disks
seeks at distance
read a sector
single spiral track
constant or variable
proximal window size
radial line indexed
average rotational delay
j qualifying sectors
average seek cost
successive qualifying sectors
beneath the head
first qualifying sector
pick n sectors
sectors n zcav
clv cav disks
forward access region
cost is cost
average head switch
proximal window accesses
z cost proxw
average proximal window
n zcav disk
zcav disk simulated
z i z
clv optical disks
time to read
cav and clv
clv and clv
number of head
expected retrieval cost
scanned before reaching
rates and storage
cav and cav
disks with respect
set of concentric
proxw in j
storage capacity sector
total average cost
mass storage systems
constant linear velocity
possible future technologies
capacities and transfer
seek at distance
constant angular velocity
total average head

corpus/krapavin2000-test/631250.txt
faults
release
modules
fault
metrics
cyclomatic
prone
loc
pareto
hypotheses
basili
post
pericone
module
testing
hypothesis
density
fenton
software
sigff
predictors
failures
operational
kloc
alberg
densities
releases
pre
discovered
defect
empirical
incidence
evidence
proportion
pfleeger
ostrand
hatton
ohlsson
scatterplots
weyuker
proneness
prediction
relating
scatter
elaine
perricone
organisation
benchmarking
ft
cmm
graphed
munson
adams
neil
phases
predictor
prerelease
normalised
published
st
predicting
si
engineering
studies
failure
repeatable
predict
dot
companies
khoshgoftaar
koru
mccabe
postrelease
interphase
compton
responsible
quality
reveal
bell
norman
op
popularly
emam
defects
constitute
explanatory
strong
martin
early
thomas
trends
tended
robert
rel
industrial
believed
versus
misleading
causal
collected
absolute
sada
zuse
tomaszewski
dearth
alshayeb
kanoun
curiously
gwendolyn
inspections
shesh
walton
paulish
fdl
nishith
benlarbi
grahn
underpin
withrow
khosghoftaar
gunes
lundberg
moeller
kitchenham
accumalated
reliability
traced
correlates
sigsoft
metric
principle
extracted
analysed
development
popular
percentage
plots
piotr
rai
hkan
factory
warnings
ada
months
accumulated
diagrams
plot
goel
predictability
organisations
quantitative
sdl
woo
khaled
company
valuable
broadly
el
remarkable
lars
flawed
ramifications
tian
dangerous
commercial
notably
tested
subsequent
correlation
evolution
uml
mohammad
softwarepractice
dependability
trend
economics
legacy
effort
release n
post release
fault density
pre release
fault prone
release faults
prone modules
complexity metrics
cyclomatic complexity
software engineering
faults discovered
operational faults
modules contain
fault densities
release fault
higher incidence
system test
hypotheses relating
size metrics
release testing
pareto principle
fault data
good predictors
module size
small proportion
hypothesis 1a
hypothesis 4
failure prone
function test
dot represents
small number
system size
pericone 1984
per kloc
thomas j
j ostrand
early fault
strong evidence
elaine j
j weyuker
modules constitute
software quality
martin neil
fault prediction
engineering hypotheses
ostrand elaine
simple size
design metrics
m bell
faults per
failure data
scatter plots
implies higher
complexity figure
robert m
software system
testing phases
faults faults
code size
later fault
predict later
rel n
normalised data
major releases
dependent variable
subsequent major
absolute number
hypothesis 5
hatton 1997
testing ft
alberg 1996
n 1
software development
faults figure
function testing
testing effort
fault proneness
software v
good predictor
engineering p
scatter plot
roughly constant
engineering v
release n 1
fault prone modules
post release faults
number of modules
fault and failure
faults in system
basili and pericone
incidence of faults
pre release faults
number of faults
pre release testing
release fault density
faults and failures
loc are good
represents a module
failure prone modules
pre and post
pre release fault
post release fault
distribution of faults
thomas j ostrand
elaine j weyuker
evidence to support
lines of code
robert m bell
testing and operation
ostrand elaine j
implies higher incidence
early fault data
software engineering hypotheses
faults for release
discovered during pre
proportion of modules
j ostrand elaine
faults in function
ft and st
basili and perricone
software engineering v
use of early
predict later fault
fenton and pfleeger
testing and operational
metrics are better
si and op
phases of testing
constant between subsequent
predictors of fault
stable and repeatable
subsequent major releases
predictor of fault
principle of distribution
cyclomatic complexity figure
occur in modules
transactions on software
data to predict
systems and software
number of pre
journal of systems
release n see
faults per kloc
modules which account
metrics for fault
simple size metrics
popular complexity metrics
n see figure
n release n
prone post release
similar fault densities
broadly similar fault
densities at similar
j weyuker robert

corpus/krapavin2000-test/637568.txt
breakpoint
inversion
genes
genomes
iebp
ede
inversions
genome
transpositions
phylogeny
grappa
distances
evolutionary
estimators
nj
phylogenetic
gene
events
score
distance
warnow
chloroplast
evolution
moret
datasets
pairwise
bp
phylogenies
circular
trees
inv
inverted
joining
nadeau
transposition
tsp
scoring
bounding
campanulaceae
parsimony
rearrangements
speedup
breakpoints
rearrangement
estimator
tree
edit
dataset
reconstructing
neighbor
pruning
mitochondrial
scored
false
layered
orderings
negatives
rates
sankoff
bipartitions
tang
swap
chromosome
supercluster
hours
dna
plants
reversals
leaf
taylor
pruned
additive
triplet
plotted
wang
equiprobable
ordering
reconstruct
signed
scenario
rate
phylogenetics
ismb
bpanalysis
blanchette
ancient
taxa
tandy
inver
cabbage
turnip
bipartition
genomic
estimating
reconstruction
hundred
trend
positives
median
estimates
buckets
permutations
bins
scores
remarkably
accuracy
reconstructions
travelling
sorting
million
equally
robustness
absolute
mismatched
percentage
topological
nearly
algorithmics
fig
format
parsimonious
nonparametric
animal
exact
edge
estimate
tighten
land
leaves
underestimate
mp
edges
accurate
heuristic
efficacy
confirming
suite
probabilities
prune
likely
negative
topologically
bernard
ran
remedy
matrix
simulated
obeys
robust
consecutively
experimental
bounds
plots
analyses
instances
speedups
correlation
coordinate
plot
eliminated
np
corollary
normalized
wabi
caprara
eriksen
bluebell
embraced
atteson
outgroup
pensive
interleaf
meetings
dcaf
worsening
systematics
iepb
mitochondria
deb
attested
logeny
biologists
vascular
tanspositions
strandedness
fruition
lucile
inversion distance
distance estimators
pairwise inversion
actual number
maximum pairwise
neighbor joining
exact iebp
true evolutionary
inversion length
gene order
breakpoint phylogeny
false negative
distance actual
inversion distances
negative rate
breakpoint score
inverted transpositions
evolutionary distance
iebp distance
distance relative
breakpoint distance
layered search
circular ordering
events actual
ede distances
absolute difference
genes 11
inv distance
true tree
moret tang
breakpoint distances
tang wang
phylogeny problem
events absolute
evolutionary events
distance false
order data
nadeau taylor
inversions transpositions
taylor model
model tree
reconstructing phylogenies
nj tree
tree score
relative probabilities
nj ede
tsp instances
likely events
lower bound
evolutionary distances
equally likely
circular orderings
three estimators
rearrangement events
topological accuracy
b transpositions
relative breakpoint
genome rearrangements
tree space
difference actual
relative inversion
joining method
c equally
distance based
three distance
upper bound
coordinate values
false negatives
true distance
edit distance
maximum parsimony
remarkably robust
events inversions
many trees
bp distance
chloroplast dna
various distance
pruning rate
tree leaf
bins according
phylogenetic inference
ede distance
phylogenetic analyses
additive matrix
hundred million
normalized maximum
b inv
leaf distances
grappa software
likely number
events fig
genome rearrangement
inv distances
e ede
genes fig
deviation plots
distance estimator
software suite
nj methods
c iebp
d exact
distance b
distance fig
events c
phylogeny reconstruction
g b
x coordinate
number of events
pairwise inversion distance
maximum pairwise inversion
distance actual number
false negative rate
inversion distance relative
true evolutionary distance
transpositions and inverted
events actual number
breakpoint or inversion
number of genes
rates of evolution
rate of evolution
genes 11 021
distance false negative
moret tang wang
inversion only scenario
gene order data
number of inversions
wang and warnow
inversion distance false
events absolute difference
model of evolution
nadeau taylor model
inv distance actual
equally likely events
transpositions only c
distance relative breakpoint
x coordinate values
models of evolution
breakpoint phylogeny problem
neighbor joining method
c equally likely
number of evolutionary
inversions only b
relative inversion length
number of breakpoints
percentage of trees
true evolutionary distances
difference actual number
phylogenies from gene
absolute difference actual
relative breakpoint score
exact iebp distance
inversion and breakpoint
three distance estimators
distance relative inversion
distances and three
ede distance fig
events inversions transpositions
guaranteed to reconstruct
events a bp
iebp distance d
distance e ede
one hundred million
grappa software suite
numbers of genes
number of genomes
sorting by reversals
methods under various
leaf to leaf
values the bp
distance based methods
normalized maximum pairwise
datasets are divided
b inv distance
bp or inv
bp distance b
likely events fig
distance d exact
events c iebp
iebp distance e
d exact iebp
divided into bins
c iebp distance
various distance estimators
e ede distance
true distance estimators
distance b inv
numbers of genomes
standard deviation plots
mean and standard
g a g
types of events
number of false
inversion length 37
reconstruct the true
distance for 10

corpus/krapavin2000-test/627843.txt
rp
bucket
dp
overflow
aggregation
tuples
partitioning
gridfile
partitions
ov
canmerge
overflows
cuts
grid
cfd
sw
utilization
rectilinear
utilizations
nw
buckets
directory
bulk
loading
skewed
dimension
gridfiles
tuple
se
merge
bin
ne
li
tov
blocksover
quadrants
plot
bins
subranges
aggregate
files
cut
precalculated
subdirectory
precalculation
page
bytes
attribute
mega
unstructured
seconds
partition
session
directories
sparse
blocks
headed
column
theta
fit
strip
coordinates
axis
multiattribute
subdirectories
maxfp
overflowed
sorting
aggregating
occupancy
lowerbound
uninterested
buddy
square
hours
file
spaced
post
discovered
nicol
uniformly
disk
columns
horizontal
orders
sampling
plotted
seeks
seek
varied
byte
attributes
creating
capacity
spent
tg
indexing
coordinate
faster
indexed
magnitude
lacking
phase
physical
synthetic
pairing
highly
minimizes
optimality
poor
megabytes
reals
created
qualified
fluid
fetch
runtime
versus
finds
significantly
quickly
unchanging
effectual
expermental
airflows
probalistic
unstructure
pmr
multikey
expend
aydt
precalculating
symetric
ruth
retrivial
positionally
reword
gisli
logarithmic
rectangle
regions
pre
exposition
conduct
vertical
recursion
majority
groups
conversely
irregular
unravel
wings
rotem
subrange
hjaltason
lization
neglects
uti
dora
rundensteiner
geoinformatica
presume
rp algorithm
dp algorithm
bucket utilization
data sets
total overflow
li et
data set
cfd data
ov 1
bulk loading
rectilinear partitioning
bucket utilizations
aggregation phase
grid directory
se j
fixed partitioning
dp dp2
partitioning algorithm
o p
per page
average bucket
tuple size
grid files
dynamic programming
tuples per
aggregation post
pre aggregation
overflow free
post aggregation
call merge
ne se
partitioning session
nw ne
partitions pre
highly skewed
aggregation algorithm
bucket capacity
unique attribute
ne j
rp algorithms
maximum domain
physical partitioning
grid file
sw j
computation time
algorithm required
nw sw
sw se
algorithm dp
tuple data
canmerge nw
tuples fit
merge nw
sparse relative
u 2
r k
skewed data
domain value
fit per
one dimension
uniformly distributed
mega bytes
two phase
run time
four orders
phase bulk
seconds versus
cut set
new blocks
utilization bucket
overflow equals
columns headed
grid cfd
aggregation partitions
byte tuples
logical partitioning
tov 1
partitions needed
overflow blocks
et al
present results
distributed data
n theta
p time
c 1
attribute values
one bucket
unique values
log u
phase algorithm
partitioning given
partitions p
bucket overflows
unstructured grid
size increases
programming solution
theta n
number of partitions
number of tuples
li et al
cfd data sets
number of unique
pre aggregation post
j then call
aggregation post aggregation
tuples per page
partitions pre aggregation
k 1 j
unique attribute values
r k 1
o p 2
uniformly distributed data
call merge nw
plot the computation
dp and dp2
set of cuts
rp algorithm dp
dp dp2 algorithm
nw sw j
rectilinear partitioning algorithm
average bucket utilizations
tuples fit per
nw ne j
sw se j
tuple size increases
maximum domain value
ne se j
relative to n
given a fixed
bucket utilization bucket
fit per page
number of subranges
average bucket utilization
axis is logarithmic
j 1 aggregate
present the utilizations
unstructured grid cfd
o p time
highly skewed data
sorting the tuples
algorithm for bulk
post aggregation partitions
two phase bulk
utilization bucket utilization
tuple data set
cuts in one
tov 1 1
algorithm dp algorithm
aggregation partitions pre
n theta n
side of figure
orders of magnitude
two phase algorithm
dynamic programming solution
algorithm is used
find the smallest
synthetic data sets
versus the number
define the first
set into r
algorithm of li
times more computation
find c 2
retrieval of subsets
loading data sets
nw ne se
maxfp 2 u

corpus/krapavin2000-test/1011820.txt
gke
ideal
sys
adversary
protocol
servers
server
tc
session
sk
consensus
id
secure
hybrid
cons
crash
crashed
security
adv
break
resilient
cor
secrecy
opt
asynchronous
gcs
corruption
agreement
messages
ins
coin
exchange
protocols
resilience
trusted
rounds
fs
configuration
attacks
message
connections
keys
secret
ppt
net
crashes
authenticated
outputs
indistinguishable
um
tag
round
pseudorandom
tolerates
tape
versary
black
host
service
group
authentic
configured
cachin
pfitzmann
idjcs
halts
itm
box
encryption
contribution
th
steiner
receives
waidner
simulator
public
forward
byzantine
complexities
delivered
enc
canetti
party
failures
composable
key
joint
string
master
diffie
stage
attack
breaks
delivers
tocol
katz
hellman
tapes
interface
composition
tcn
bresson
gcss
fvar
bit
comprises
receiving
nish
tolerate
adversaries
ij
rekeying
fstate
dealer
contributory
sends
connects
detector
reactive
finish
connection
shares
cryptographic
var
ensembles
interacts
liveness
send
sent
received
universally
mes
scheduler
internal
learn
feeds
happens
sub
sim
adds
argue
activated
outputting
terminate
chooses
yung
distinguishable
share
configurations
coins
rabin
tolerant
provably
simulated
proposes
live
amir
slowest
computes
communication
un
participate
suffices
network
idealized
member
modular
terminates
encrypted
anymore
oracles
purely
computationally
sages
members
tolerating
proceeds
adaptively
constructive
repeatedly
detects
investigate
authentication
schedule
interact
weak
init
ad
broken
sys real
system sys
gke protocol
real n
sys ideal
session key
ideal system
consensus protocol
group key
every server
key exchange
session id
sys hybrid
key agreement
real system
th gke
key sk
ideal f
corruption model
tc servers
break ins
non crashed
cons n
hybrid cons
trusted host
server m
hybrid system
user h
th cons
crashed servers
gke n
tag id
servers crash
tc resilient
forward secrecy
sub system
ideal gke
service f
ideal k
fs gke
adv th
server j
exchange protocol
ideal service
optimal resilience
ideal g
resilient consensus
hybrid run
host th
adv net
black box
internal state
ideal configuration
joint view
real configuration
contribution values
th fs
strong corruption
among non
gke protocols
protocol 0
v ideal
n tc
connection cor
resilient gke
b resilient
upon receiving
forward secure
conference key
id v
bit string
messages among
session keys
f n
contribution y
sub protocol
protocol coin
tolerates tc
adversary delivers
master scheduler
n 2tc
network net
ppt itm
resilient group
var k
id provided
weak corruption
m receives
round complexity
contribution value
ideal run
pseudorandom function
purely asynchronous
ad versary
single session
asynchronous reactive
authenticated group
composition theorem
value y
first stage
group communication
communication rounds
sys real n
system sys real
group key exchange
system sys ideal
real system sys
ideal system sys
sys hybrid cons
view of h
secure as sys
sys ideal f
adversary a ideal
non crashed servers
ideal f n
hybrid system sys
sys ideal gke
adversary a real
system sys hybrid
tc servers crash
h a real
session key sk
key exchange protocol
sys ideal g
trusted host th
hybrid cons n
sub system sys
th fs gke
resilient consensus protocol
tc t b
among non crashed
session with tag
strong corruption model
tc resilient consensus
resilient gke protocol
configured with h
n 2 messages
run of sys
weak corruption model
number of break
delivers all messages
servers in m
b resilient gke
th gke n
v ideal k
crash the following
ideal g n
messages among non
resilient group key
solution for gke
un t c
computes the session
asynchronous reactive systems
tc resilient group
connections to adv
sys hybrid g
connections are used
h a ideal
protocol a tc
system for consensus
starts a session
start a session
ideal cons n
gke with failures
contribution value y
black box simulation
provide forward secrecy
cachin et al

corpus/krapavin2000-test/628097.txt
covert
transaction
lock
secure
security
channel
aborted
mutual
miss
priority
deadline
submits
commits
channels
concurrency
percentage
locking
commit
arrival
purge
tick
interference
holders
deadlock
abort
aborts
actions
timeliness
vwl
database
conflicting
multilevel
arrives
protocol
releases
tl
cputime
dba
schedule
fidelity
aborting
scheduler
requester
offs
option
noise
disk
sang
deadlines
son
waits
entropy
lapadula
violations
timing
feedback
surprise
granted
blocked
transmitter
quanta
clearance
cognizance
ddmp
disktime
action
rl
conflicts
serialization
subcases
delta
request
trade
subjects
mls
submitted
virtual
violation
upgraded
transactions
probability
committed
release
priorities
capacity
scheduling
prior
cpu
uncertainty
collaborating
kyoung
read
item
bell
malicious
arrivals
degrading
multiversion
delayed
recovery
transmit
ax
transmission
enforce
receiver
probabilities
bufprob
dmp
vql
readlock
transize
arrirate
unlocked
minslack
conflict
th
randomness
msec
subject
interfere
transferred
hp
schedulers
databases
slack
holding
delay
hline
vrbsky
covertly
scheduled
submit
policy
page
cache
designer
noiseless
stankovic
cnt
vw
locks
kang
resultant
vs
requirements
arrive
allowable
classification
schedules
rolled
collaborate
permissible
access
interferes
conveyed
lesser
factors
held
submitting
sent
requests
maintained
queueing
phase
reads
prob
ahmed
dbmss
arise
duration
arrived
violated
firm
compromised
signaling
thereby
rate
enforcement
intends
contention
sends
alternately
serializability
send
rates
object
event
correctness
restarted
locked
quantum
pl
deadlocks
trans
covert channel
mutual information
miss percentage
covert channels
low user
real time
access class
high user
concurrency control
level transaction
low transaction
deadline miss
probability q
high priority
locking protocol
secure concurrency
secure 2pl
secure two
lower access
phase locking
two phase
low priority
high transaction
time database
non interference
higher access
control mechanism
channel analysis
secure real
desired miss
virtual lock
abort commit
delay security
feedback control
secure database
level actions
multilevel secure
level transactions
user aborts
purge p
priority transaction
transaction submits
secure option
basic two
time secure
h son
sang h
time requirements
lock holding
data operation
lock holders
low level
database systems
high level
following cases
trade offs
commits prior
always aborted
aborts considering
error bit
r capacity
value security
output schedule
rl 1
recovery security
earlier deadline
real lock
higher level
arrival rates
write lock
data item
p 6
time databases
data object
bell lapadula
vs r
lock prior
w 2
serialization order
user sends
information transferred
security requirements
time concurrency
read lock
lock request
disk access
correctness criteria
arrival rate
conflicting lock
multiversion locking
greater priority
deadline miss percentage
two phase locking
secure two phase
lower access class
lock on x
secure concurrency control
phase locking protocol
value of q
higher access class
low level transaction
aborted by th
real time database
secure real time
high level transaction
covert channel analysis
desired miss percentage
real time requirements
transaction t 1
l with probability
purge p l
low user aborts
basic two phase
submits a read
real time secure
security and real
information i vs
aborted for high
sang h son
w 2 x
high level transactions
th with probability
time secure concurrency
rl 1 x
low transaction submits
high user sends
feedback control mechanism
user aborts considering
high priority transaction
amount of mutual
releases the lock
mutual information transferred
real time databases
time database systems
concurrency control mechanism
r 1 x
q and r
time concurrency control
p i x
real time concurrency
studied in section
value of r
allowed to set
r 1 0
time and security
secure database systems
transaction t 4
lock holding transaction
user sends 0
subject classification levels
multiversion locking protocol
purge s l
time database system
criteria for secure
following subcases arise
resultant covert channel
concurrency control approaches
vwl 2 x
r when low
security and timeliness
lock and commits
higher level actions
tick the low

corpus/krapavin2000-test/636581.txt
sperner
facet
simplices
polytope
simplex
pebble
facets
simplicial
cells
nerve
polytopes
gf
chamber
triangulation
vertices
gk
cell
polytopal
degenerate
labels
label
loera
labelling
face
ag
peterson
ridges
pebbles
adjacent
constructive
interior
atanassov
labelled
convex
parity
ridge
endpoints
spanned
cover
lemma
chambers
vertex
hull
conjecture
triangulations
homology
qf
carried
paths
jg
brouwer
combinatorial
covering
boundary
odd
carries
dimension
pentagon
iv
jl
dene
subgraph
degree
connected
math
borders
stacked
su
triangulated
shaded
oxford
magdalen
basepoint
bdry
beweis
simplexity
dissections
specic
suces
isomorphisms
map
ker
inductive
corollary
loops
arguments
labellings
ags
induct
polyhedra
nitely
hexagon
denition
dark
ng
meets
vj
sign
cardinality
freund
hyperbolic
degeneracy
carr
proposition
analogs
counts
consist
locating
omits
nd
faces
identity
polyhedron
surjective
innitely
dened
shares
pivoting
davis
collection
vn
manifolds
counted
regular
intersect
contained
fully
path
repeated
light
college
dimensional
de
rst
connect
satises
fv
labeled
intersection
iii
determinant
studia
threlfall
deloera
billera
alekseyevskaya
hungar
hungarica
seifert
topes
plices
fame
prescott
echelon
expositions
elisha
mudd
hmc
excision
fixpunktsatzes
claremont
ucdavis
meunier
darkly
neuer
anely
endpoint
subgraphs
nite
lemmas
proofs
italic
statement
dierent
commutative
gure
nodes
claim
triangles
component
images
volumes
subsequence
mathematics
full cells
full cell
polytope p
pebble set
n d
d polytope
label set
d simplex
nerve graph
facet f
g f
non degenerate
full facets
degenerate full
g 0
sperner labelling
full facet
degree 1
polytopal sperner
face f
graph g
component g
loera e
de loera
sperner labelled
d full
e peterson
ag f
label sets
f r
e su
cell graph
f k
constructive proof
k simplex
path following
labelled triangulation
repeated label
graph gk
d 1
non constructive
map f
f 1
base facet
fully d
one repeated
components g
ag graph
d labels
d vertices
connected component
derived graph
l f
f e
q 0
k face
d simplices
two full
least n
degree 2
convex hull
one pebble
identity map
whose label
q f
must contain
theorem 1
exactly two
simplex spanned
homology groups
d labeled
simplicial facet
every facet
pebble sets
labels carried
two facets
graph gf
whose endpoints
c p
one full
theorem 22
dimension d
f d
connected components
inductive hypothesis
sperner s lemma
n d polytope
nerve graph g
g f r
non degenerate full
vertices of p
f of p
boundary of p
peterson and f
j a de
de loera e
n d full
loera e peterson
full cell graph
f e su
d full cells
least n d
g of g
sperner labelled triangulation
facet of p
d polytope p
cover of p
spanned by vertices
derived graph gk
non constructive proof
degenerate full cell
parity of g
one repeated label
f k 1
nodes in g
component of g
number of full
labels in l
exactly one repeated
cell graph g
face f k
connected components g
simplices of p
loops or paths
degenerate full cells
size d 1
p i 0
simplex with exactly
one full cell
size n d
simplex is carried
two full facets
facets in f
fully d labeled
cells in f
nodes of g
graph g 0
must be odd
let g f
label set containing
exactly two facets
edge f 1
carried by f
full cells proof
label sets contain
facets of p
g f k
d simplex spanned
reduced homology groups
k face f

corpus/krapavin2000-test/628123.txt
pulsing
ssn
constituents
stm
constituent
ssns
parse
sentence
connectionist
tsvb
parent
units
word
corpus
tag
sentences
activation
grandparent
parsing
parser
srn
noun
period
generalise
synchrony
tags
henderson
verb
generalisations
phases
learning
vbd
outputs
sibling
generalisation
training
syntactic
srns
susanne
article
pcfg
relationships
recurrent
structural
grammars
parsers
mary
loves
network
child
vvd
trainingepochs
bpts
percentagecorrect
dependency
layer
precision
phrase
trained
neural
systematicity
outputting
linguistic
occurring
text
grammatical
entity
learn
vp
lengths
statistical
networks
bptt
regularities
representations
phrases
toy
grammar
activations
trainable
structured
phase
ability
preparsed
incremental
train
language
binding
queue
dependencies
linguistically
entities
backpropagation
output
english
architectures
layers
across
inputs
naturally
holistic
unit
pulses
symbol
periods
temporal
np
chased
hayward
hadley
constituency
leeds
lancaster
pcfgs
corpora
gps
nn
unfolded
linguistics
learned
preorder
incrementally
hebbian
constructions
cross
james
john
encoding
adjustments
adjective
died
rat
neuroscience
bank
unbounded
encode
confluent
percentage
jj
manifested
learnt
specifies
letter
learns
dog
verbs
grounds
representational
tree
rectangles
cat
cognitive
label
feed
target
correlates
drawn
probabilities
architecture
parsed
forgotten
specify
net
sigmoid
abilities
experiments
coverage
link
siblings
banks
clauses
association
mechanism
occupies
hierarchical
explores
fundamentally
uk
head
broad
weights
green
decoding
thereby
degrades
fernand
unmotivated
psycholinguistic
word tag
non pulsing
pulsing units
occurring text
time period
pulsing input
word tags
parse tree
naturally occurring
natural language
structural relationships
output units
synchrony networks
simple synchrony
parent child
language learning
pulsing unit
noun phrase
input units
o n
child relationships
structural constituents
precision recall
term memory
generalise across
pulsing inputs
basic ssn
tsvb networks
ssn architectures
structured output
syntactic parsing
short term
output activation
output representations
james henderson
trainingepochs percentagecorrect
ssn architecture
phase p
generalisation ability
connectionist network
current word
networks ssns
one constituent
sentences drawn
unit j
output unit
average precision
connectionist architecture
correct constituents
ssn parser
words fit
parent output
statistical parsers
stm length
constituent 2
constituent structure
stm mechanism
output specifies
standard connectionist
temporal synchrony
constituent level
susanne corpus
sibling output
noun phrases
constituent 3
layer train
connectionist language
distributed representation
input unit
period 1
context free
output representation
syntactic structures
corpus used
new phase
connectionist networks
fit together
statistical language
simple recurrent
parse trees
structure representing
period 5
grandparent parent
average sentence
stm lengths
across syntactic
pulsing pulsing
synchrony variable
memory stm
simple srn
dependency length
context unit
pulsing output
parsing natural
dependency lengths
form constituents
language parsing
test units
standard task
naturally occurring text
non pulsing units
simple synchrony networks
corpus of naturally
pulsing input units
short term memory
parent child relationships
ability to generalise
number of words
learning to parse
average precision recall
number of constituents
tag s parent
o n 2
synchrony networks ssns
set of constituents
non pulsing unit
learn to parse
basic ssn architecture
words fit together
non pulsing input
hierarchical structure representing
allows the ssn
connectionist language learning
precision and recall
statistical language learning
number of correct
together to form
period and phase
n 2 speed
generalise over constituents
enables the ssn
n 2 structural
parsing natural language
natural language parsing
synchrony variable binding
parent of constituent
across structural constituents
current word tag
parent child relationship
english sentences drawn
effects of stm
average sentence length
sequence of input
shows the activation
phases to represent
type of unit
term memory stm
temporal synchrony variable
input output representation
use of phases
p at time
architecture to linear
pattern for symbol
ssns for learning
pulsing unit j
receive the pattern
units in every
length of dependency
non pulsing pulsing
structured output representations
ssn s performance
association for computational
parsing of natural
context free grammars
natural language sentences

corpus/krapavin2000-test/1024079.txt
colamd
factorization
amdbar
colmmd
matlab
pivot
sparse
amd
row
symamd
pivoting
matrices
cholesky
ordering
superlu
nonzeros
column
symbolic
orderings
absorption
deciency
nonzero
super
symmmd
matrix
nonsymmetric
lu
rows
kr
columns
permuted
aggressive
metric
multifrontal
elimination
kc
dense
fkg
interchanges
factorize
toms
netlib
ll
symmetric
sparsity
uid
twotone
preordering
rothberg
goodwin
permutation
aq
nite
median
diagonal
oating
outer
triangular
gaussian
unsymmetric
numerical
pwt
3dtube
gran
entries
gilbert
pattern
factorized
struct
hall
ata
householder
pds
aect
qr
update
chemical
discarded
aa
submatrix
frg
saad
degree
rectangular
ansi
approximate
blas
supernodal
nfkg
mathworks
callable
larimore
gearbox
ufl
unassembled
markowitz
airlift
quality
ng
ow
davis
nonsingular
cancellation
nds
grimes
harwell
cise
jaj
external
lc
degrees
fill
timothy
nnz
nding
iso
storage
dynamics
sixteen
dissection
package
www
representative
product
http
mathematical
die
faster
square
routine
florida
navier
ia
stokes
routines
george
modied
cfd
org
partial
superior
gave
ij
military
transposition
tested
irreducible
supercomputers
factors
bug
subsequent
ja
ju
regardless
solely
requiring
du
jc
quotient
costly
pressure
count
doron
pressurized
duff
enseeiht
isothermal
kaess
umfpack
bova
partial pivoting
column ordering
ordering algorithm
pivot row
cholesky factorization
aggressive row
row absorption
symbolic factorization
lu factorization
symbolic update
ordering time
amd metric
row degree
minimum degree
column c
outer product
ordering quality
sparse matrix
symbolic lu
external row
super columns
better orderings
matlab metric
colamd colmmd
sparse partial
numerical factorization
nonzero entries
gaussian elimination
symmetric matrices
nite element
mathematical software
multiple elimination
colmmd amdbar
pivot column
row interchanges
nonzero pattern
super column
kr r
approximate minimum
factorization algorithm
column k
nonsymmetric matrices
rectangular matrices
r k
permutation p
software toms
toms v
c k
factorization time
degree algorithm
colamd ordering
ordering q
strong hall
zero free
row ordering
uid dynamics
approximate deciency
square nonsymmetric
free diagonal
degree ordering
test set
row k
row r
step k
row permutation
kc c
sparse cholesky
l k
super row
symmmd amdbar
symamd symmmd
amd approximation
multifrontal method
colmmd ordering
symmetric ordering
initial matlab
super rows
computational uid
n fkg
matrix colamd
column j
r r
sparse gaussian
th pivot
pivot rows
chemical process
sparse matrices
k th
oating point
point operations
linear programming
k 1
column preordering
dense row
nonzero patterns
initial metric
amdbar mc47bd
initial aggressive
pattern multifrontal
median result
amd row
pds 20
median time
ordering methods
product step
arbitrary row
ansi iso
candidate pivot
y saad
matlab approximation
matrices colamd
e rothberg
seconds matrix
result relative
process separation
aggressive row absorption
symbolic lu factorization
sparse partial pivoting
external row degree
colamd colmmd amdbar
kr r k
number of nonzeros
l and u
elimination with partial
software toms v
mathematical software toms
transactions on mathematical
minimum degree algorithm
minimum degree ordering
approximate minimum degree
kc c k
nonzeros in l
square nonsymmetric matrices
degree ordering algorithm
lu factorization algorithm
zero free diagonal
sparse cholesky factorization
matrix colamd colmmd
kr i k
initial matlab metric
column ordering q
k th pivot
row permutation p
symamd symmmd amdbar
amdbar and mc47bd
sparse gaussian elimination
colamd and symamd
computational uid dynamics
k of u
linear programming problems
c to minimize
oating point operations
used by matlab
row ordering p
operations to factorize
timothy a davis
median time relative
matlab s colmmd
k of l
compute the sparse
th pivot row
outer product step
k n fkg
colamd ordering algorithm
symmmd amdbar mc47bd
sparse matrix product
colamd and colmmd
patterns of l
george and ng
median result relative
initial aggressive row
ordering of m
toms v 30
super row r
pattern multifrontal method
chemical process separation
rows and columns
relative to 1
l k n
amount of ll
p is selected
solution of large
every three stages
node selection strategies
bound the pattern
nonsymmetric matrices rectangular
kr i n
toms v 33
matrices rectangular matrices
factorization and ordering
computes the factorization
since it gave
university of florida
candidate pivot rows
k by kr
ordering quality nonzeros
matrices matrix n

corpus/krapavin2000-test/1039329.txt
quantum
pir
ldcs
decodable
decoder
ldc
server
trevisan
query
codes
classical
codeword
queries
lqdc
pirs
qubit
bit
katz
lqdcs
smooth
xor
cj
ja
answers
locally
ju
beimel
recovery
decoding
randomness
corrupted
private
bits
recover
ji
retrieval
ldec
goldreich
qubits
servers
codewords
probability
positions
bounds
measurement
outputs
hadamard
outcome
entanglement
rst
nayak
ldecs
obata
qpir
gasarch
extractors
alphabets
exponential
code
unitary
pcps
semidenite
jji
jbi
hyer
correcting
workspace
schemes
string
subexponential
log
pr
answer
strings
recovered
superposition
ib
pure
queried
amplitudes
ist
correctors
ashwin
publishable
beigel
chor
multioracle
bitvectors
jcijji
gisin
orthonormal
communication
denition
polynomials
alphabet
klauck
fortnow
interrogation
oracle
sends
amplitude
adaptively
tuple
buhrman
copies
bpp
hj
jbj
erasure
success
signicantly
smoothness
tuples
mann
exptime
parity
ln
disjointness
mixed
random
lemma
reduction
polylogarithmic
bx
adaptive
inner
alice
pseudorandom
sen
guess
averaging
privacy
gf
extract
density
bob
luca
fraction
operators
binary
hamming
ce
secret
averaged
xed
querying
round
membership
evolves
straightforwardly
certainty
tensor
getting
resilient
reals
appendix
somewhat
subsystems
cryptography
agreement
uniform
hiding
indices
uncorrupted
bitpositions
jjihjj
renner
resq
fet
jcss
wehner
jri
superpolynomial
ijbi
sasson
hji
pranab
gkst
queryp
tradeos
postdoc
server pir
locally decodable
recovery probability
pir scheme
decodable codes
smooth code
private information
bit answers
pir schemes
access code
lower bounds
ju x
decodable code
random access
quantum random
ja x
best known
lower bound
classical 2
query ldcs
exponential lower
quantum pir
recover x
quantum query
communication complexity
information retrieval
query locally
c x
bit queries
q tuple
classical queries
m qubit
known classical
beimel et
smooth codes
server pirs
goldreich et
trevisan 21
quantum decodable
query ldc
query lqdc
q queries
one quantum
log m
classical pir
quantum decoder
quantum queries
c smooth
density matrix
state ju
answer length
control bit
locally quantum
probability 1
log n
q 1
q 2
state ji
one query
basis states
quantum computing
qubit state
n bit
success probability
outputs 1
decoding algorithm
y m
bit strings
q tuples
quantum argument
query lqdcs
hadamard code
corrupted codeword
adaptive queries
queried bits
classical proof
bit x
known ldcs
quantum server
et al
o n
quantum state
quantum computer
q locally
known upper
m bit
bit string
user sends
better lower
two queries
upper bounds
optimal lower
probability 11
good q
pure states
larger answers
classical decoder
binary 2
bit answer
ja ib
pure state
strings x
quantum 2
perfect recovery
non adaptively
polynomial lower
exactly 11
katz trevisan
private information retrieval
random access code
locally decodable codes
server pir scheme
quantum random access
classical 2 server
katz and trevisan
exponential lower bound
locally decodable code
query locally decodable
goldreich et al
one quantum query
bounds for 2
beimel et al
best known classical
server pir schemes
o n 1
locally quantum decodable
c smooth code
state ju x
bound for 2
number of queries
best known ldcs
code for x
ldcs with q
q c smooth
known upper bounds
k 2 servers
n 3 10
n bit strings
bound for 1
better lower bounds
m y m
complexity of set
best known upper
optimal lower bounds
n lower bound
least 1 2
bit strings x
codes and private
extend our lower
smoothness of c
decodable codes via
code c 0
quantum 2 server
exactly 11 14
codewords c x
c x j
communication complexity o
improve the polynomial
recovered with probability
answers and recovery
classical lower bounds
classical and quantum
known classical 2
bits of x
probability of output
q locally decodable
quantum decodable codes
information retrieval pir
quantum decodable code
best known bounds
schemes with 1
via a quantum
polynomial lower bounds
good q tuple
user s randomness
probability 11 14
qubit state ju
complexity o n
et al 8
et al 20
probability 1 2

corpus/krapavin2000-test/629361.txt
embedding
std
xor
cube
torus
multicomputer
dilation
hypercube
toruses
embeddings
ring
onto
distances
cc
clockwise
multicomputers
rings
byweight
meshes
counterclockwise
hypercubes
neighbor
load
links
dimension
mesh
interconnection
topology
neighbors
mod
dimensions
spectrum
distance
ave
node
vertices
dimensional
spague
processes
labeled
fft
topologies
longest
dc
squared
waiting
proven
lemma
averagedistance
communication
executing
cubes
metrics
nodes
matic
lai
numbering
finish
intervals
dilations
vertex
communicate
corollary
shortest
mapped
outperforms
processors
minimizes
tic
duration
obviously
stage
periods
focuses
modelled
choi
link
stages
wrap
communicates
routed
average
bit
clarity
interconnected
concentrates
hop
centers
wohlmuth
tarkov
wwith
gonzlez
cerio
mun
jaeyoung
indistinctly
karci
youngsong
lindenberg
1distances
consequence
lemmas
period
routing
mapping
tasks
excepting
cepba
mayer
daz
kohonen
undirected
label
expressions
lowest
proposals
execution
conflicts
radix
mikhail
valero
hyung
garca
isoperimetric
expression
minimizing
sorts
says
exchange
target
message
cf
executed
hopes
harper
cicyt
friedrich
tori
otto
scalable
embedded
labels
scalability
abstractmany
optimality
loaded
bw
edge
destination
emulation
ministry
restated
interconnect
luis
interchanged
matter
frequently
sorting
activity
arrive
allocated
contribute
move
odd
reviewing
euromicro
constitute
configurable
tackled
periodic
extensively
bijective
symmetrical
tuples
miguel
atlanta
barcelona
corollaries
injection
ready
imply
phase
wait
negligible
tao
d cube
std n
xor embedding
n std
standard embedding
cube algorithm
constant distances
cc d
cube onto
d 1
std d
dimensional torus
f d
c dimensional
cube algorithms
d n
average distance
d 2
n j
k mod
j n
d nodes
links dilation
dilation spectrum
hypercubes onto
d c
mod 2
n w
xor d
d std
c n
w c
minimum load
distances d
f xor
byweight embedding
xor embeddings
xor n
communication topology
every process
node n
average load
waiting intervals
longest dilation
algorithm onto
embedding f
execution time
one dimensional
interconnection topology
total dilation
communication component
whose dilation
communication tasks
dc c
hypercube onto
called xor
node c
n k
d processes
links whose
node due
d j
d k
point links
onto rings
n xor
embedded onto
neighbor processes
target multicomputer
onto toruses
onto meshes
torus multicomputers
dimensional meshes
mapping function
process n
mapped onto
dimensional mesh
n elements
hypercube communication
parallel algorithms
graph represent
distances must
k n
x k
interconnection topologies
n std n
std n std
d cube algorithm
cc d cube
embedding with constant
f d n
onto a ring
n j n
d cube onto
d cube algorithms
mod 2 d
n i n
k mod 2
n w c
c dimensional torus
embedding is optimal
links dilation spectrum
d 2 d
constant distances d
d 1 d
ring with 2
embeddings with constant
x k mod
one dimensional torus
counterclockwise in relation
n k n
due to links
relation to n
clockwise in relation
embedding on rings
n std d
let f d
d i d
d i n
mesh or torus
dc c dimensional
optimal for meshes
called xor embedding
std d std
links whose dilation
d n v
d std d
least 2 d
k c n
d c d
c n j
point to point
onto a 2
d n w
d n std
hypercube communication topology
hypercubes onto toruses
neighbor in dimension
h d n
std n figure
links with dilation
algorithms with hypercube
std d n
due to communication
relation to f
hypercubes onto rings
meshes and toruses
std d 2
cube algorithm onto
maximum and minimum
j c n
d n k
d 1 0
problem of embedding
different performance metrics
set of different
n i c
graph which represents
two dimensional meshes

corpus/krapavin2000-test/634756.txt
egenet
layout
plm
adjustment
fsa
quad
overlapping
solver
penalize
lagrangian
layouts
overlap
dyn
mental
genet
constrained
scaling
multiplier
opt
quadratic
modied
orthogonal
satisfaction
gls
misue
eades
preserve
nd
constraint
lagrange
drawing
csp
endif
scale
bmx
endfor
disjunctive
revise
oo
optimization
nite
ij
node
reset
minima
neighbours
csps
adjusted
rst
dene
minval
mincost
bestcost
bmy
solvers
constraints
ordering
mx
stepsize
predened
neighbour
initialize
remove
nds
shrunk
optimum
stopping
augmented
penalties
aesthetic
multipliers
unnecessarily
resource
exceeded
labels
minimize
preserves
vars
satised
continuous
penalty
force
objective
crossing
mch
busting
minimimizing
aesthetically
disadvantage
horizontal
exibility
ciency
pleasing
lai
convex
updating
preserving
direction
anchored
perm
violated
jv
ciently
nodes
static
label
eect
removing
heuristic
search
dierent
dimension
graphs
invokes
solving
scan
australia
oating
simplest
map
fourth
domains
sampling
pseudo
halt
coordinates
factors
huang
vertical
positions
solve
strengthened
var
ranges
nding
modify
display
animated
enlarged
australasian
norm
cpu
labelled
mu
orthogonality
removes
height
position
xed
neural
placement
convergence
fastest
violations
modication
dy
handle
edge
wei
empirical
dierence
iterates
spring
symmetry
formulating
normalized
nikola
reoptimizations
besti
microgenetic
wanchun
justment
dsz
langrangian
sajeev
cryptarithmetic
lyons
fteen
abutt
nikolov
omax
tunneling
lmms
counteracting
readablity
lapping
junbin
rightwards
modica
layout adjustment
node overlapping
adjustment problem
constrained optimization
orthogonal ordering
initial layout
graph layout
egenet solver
modied egenet
local search
best layout
continuous constrained
new layout
overlap constraints
original egenet
mental map
plm figure
uniform scaling
quadratic programming
graph 8
d layout
augmented cost
egenet opt
scale fsa
f layout
optimization problem
c layout
satisfaction problems
graph drawing
scale c
fsa d
adjusted layout
egenet f
remove node
quad e
adjustment problems
e layout
resulting layouts
resource limit
cost function
original graph
x direction
optimization problems
c oo
optimization function
dynamic layout
fsa quad
node v
cost z
y direction
multiplier methods
graph 9
constraint satisfaction
objective function
scaling factors
local minimum
egenet approach
egenet network
b layout
convex quadratic
removing node
egenet model
penalize opt
misue et
sampling size
domain sampling
penalize ctr
overlap constraint
solution found
best solution
c y
quadratic solver
graph 7
x 0
f z
graph 1
local minima
search methods
force scan
layout since
overlapping nodes
overlapping constraints
normalized optimization
right horizontal
plm gives
quad egenet
c x
y directions
lagrangian multiplier
lagrangian method
original structure
scan algorithm
graph 6
z b
z v
constraints c
active set
m x
node labels
node label
linear constraint
revise bounds
worst layout
solution cost
initialize vars
var order
label overlap
plm solver
resulting layout
peter eades
static layout
tree layout
mx ij
layout adjustment problem
egenet and plm
constrained optimization problem
layout with egenet
layout with plm
layout with quad
augmented cost function
layout with scale
layout with fsa
continuous constrained optimization
initial and resulting
layout adjustment problems
layouts for graph
egenet f layout
scale c layout
quad e layout
fsa d layout
scale fsa quad
remove node overlapping
constrained optimization problems
x and y
subject to c
local search methods
solve the layout
removing node overlapping
misue et al
approach to layout
domain sampling size
best solution found
constraint satisfaction problems
user s mental
force scan algorithm
graph s orthogonal
dynamic layout adjustment
fsa quad egenet
scale and fsa
modied egenet solver
c no x
node overlapping constraints
value of dyn
u is su
represents a solution
gives the best
solution is found
lagrangian multiplier methods
overlapping while preserving
preserve the orthogonal
original egenet solver
uniform scaling approach
local search method
dynamic graph layout
normalized optimization function
preserving the user
existing graph layout
towards the solution
pseudo lagrangian method
node label overlap
produces the best
orthogonal ordering constraints
graph layout adjustment
overlapping in graph
egenet opt invokes
original egenet model
static layout adjustment
nds a solution
v or u
right of v
active set method
x 0 v

corpus/krapavin2000-test/629269.txt
predicates
lcmvector
predicate
wcp
conjunctive
lcmvectors
checker
lp
incomparable
debugger
detection
newchanged
utddb
roc
weak
unstable
message
lin
snapshots
debugging
processes
garg
monitor
stutter
detect
trace
programmer
queue
maxu
sent
chandy
inc
vijay
snapshot
firstflag
lamport
coordinator
fifo
disjunctive
messages
stable
austin
queues
detecting
bool
kshemkalyani
ks
suffix
causal
events
debug
ajay
head
breakpoints
adversary
detected
logic
changed
exclusion
happened
timestamps
timestamp
hoagland
hurfin
spezialetti
kashyap
skt
sujatha
clocks
boolean
sequences
detects
marzullo
waldecker
punit
comparisons
actions
program
vectors
decentralized
pred
var
mutual
raynal
send
checking
traces
kulkarni
formulas
global
programs
deduce
kearns
heads
received
became
bryan
sandeep
prog
receive
jay
msg
chandra
conjuncts
speeds
orders
critical
consistent
detectable
michel
greg
cooper
strong
miller
choi
halting
csp
fig
conjunction
id
false
monitors
offline
channels
checks
mg
chin
petri
texas
formula
decomposed
concurrent
analyzer
iff
resettable
decentralizing
lpm
chiou
korfhage
ddb
spuriously
truthness
karun
earlieralgorithms
indebugging
haban
plouzeau
apredicate
navy
bouge
thepredicate
willard
pazel
replays
mattern
rcvd
myre
biyani
weigel
deletehead
decentralization
discussdetection
lcmvec
trw
nonchecker
thomborson
loon
dbg
gdo
predicateslocal
pine
tomlinson
itbecomes
incompara
bythe
excessiveoverhead
decentralize
conjunctivepredicates
assistantship
schlumberger
jchanged
thatare
explosion
sends
clock
weak conjunctive
global sequence
local predicates
checker process
distributed program
conjunctive predicates
global state
global predicates
process p
distributed programs
local predicate
run r
p roc
global predicate
conjunctive predicate
unstable predicates
global sequences
distributed run
distributed debugger
distributed systems
k garg
predicate detection
global states
non checker
vijay k
message path
checker processes
stable predicates
application process
lp 1
different processes
boolean expression
lin lin
p j
distributed computations
sent message
became true
local pred
predicates detection
recently sent
pure conjunction
repeated snapshots
program message
time vectors
trace r
lin j
stable predicate
local actions
detect even
program messages
two lcmvectors
unstable predicate
f semantics
relational global
disjunctive predicates
mutual exclusion
atomic sequences
message id
detecting atomic
predicates ieee
d kshemkalyani
ajay d
total orders
e 3
queue q
partial order
message complexity
predicate may
state g
become true
efficient distributed
distributed snapshots
q j
local states
following holds
program may
linear r
changed newchanged
suffix g
possible global
recognizing event
lp j
systems detecting
weak conjunctive predicates
predicates in distributed
weak conjunctive predicate
detection of global
vijay k garg
predicate is true
detection of weak
expression of local
number of comparisons
chandy and lamport
conjunction of local
detection of unstable
process p j
recently sent message
lp 1 lp
snapshots in distributed
relational global predicates
e 3 lp
non checker processes
stutter of r
detecting atomic sequences
algorithms for detection
sequences of predicates
global state g
predicates ieee transactions
predicates are true
ajay d kshemkalyani
consider a distributed
head of q
class of predicates
algorithm to detect
set of global
parallel and distributed
predicate is one
programs consistent detection
propositional linear temporal
relationship to petri
systems detecting atomic
detect even unstable
deduce that 8
orders for parallel
debugging concurrent programs
detect strong conjunctive
wcp is satisfied
many total orders
g f semantics
punit chandra ajay
distributed systems detecting
miller and choi
algorithms detect even
roc t u
semantics of e
concurrent regular expressions
set of incomparable
detecting relational global
implementation in csp

corpus/krapavin2000-test/1016052.txt
quicksort
parametric
roots
sorting
cole
echet
megiddo
comparisons
nlogn
godau
spawn
polygonal
logp
fr
cgal
batch
batches
generic
outcome
bitonic
alt
pivot
logn
search
pt
aks
mn
resolve
resolving
median
decision
array
valiant
curves
sort
mnlog
collect
running
member
batching
resolved
scheduler
suspending
registered
ellipses
calls
permuting
polynomials
resuming
geometric
leash
solves
concrete
parallelism
distance
curve
binary
processes
lie
slope
sharir
monotonous
progressively
interval
intersections
resume
void
serial
iterations
fashion
optimization
complicated
arrays
toledo
abort
invocations
care
diagram
batched
slowing
implementing
items
double
resumed
dog
sub
euclidean
finished
representable
walking
doesn
considerably
suspended
merge
diameter
lg
agarwal
processors
monotone
sign
isn
squares
public
pointers
repetitions
progresses
tells
asymptotic
randomization
explain
attain
advocated
advice
root
sorted
tutorial
hidden
crewpram
erew
schwerdt
clogn
commanded
preparata
fortu
lognloglogn
shame
theoreticians
logk
stw
seem
drawbacks
italic
suffices
collision
child
moving
proximity
illustration
recursion
gave
cited
critical
man
uif
leda
disrupts
frchet
late
fewer
implement
boundaries
randomly
leiserson
logm
pram
nately
cormen
workings
spawned
consecutive
unknown
sorts
collecting
rivest
commented
parametric search
based parametric
sorting based
generic algorithm
fr echet
binary search
echet distance
sorting algorithms
o nlogn
running time
polygonal curves
decision problem
decision process
search fashion
parallel sorting
pivot element
quicksort based
o pt
parallel steps
sub array
two sorting
spawn new
pt p
distance problem
l l
bitonic sort
expected running
p l
sub arrays
decision algorithm
aks network
long double
search framework
two polygonal
godau 3
sorting algorithm
critical values
f l
running times
cole 9
implementing algorithms
optimization 9
roots associated
slope selection
polygonal curve
takes care
value l
geometric optimization
comparisons made
use quicksort
p j
o mn
search approach
three functions
member functions
concrete version
input size
progressively smaller
o logp
technique 16
megiddo 16
moving points
roots r
associated roots
number type
consecutive roots
o mnlog
parallel merge
minimum diameter
randomly permuting
often suggested
search 0
batch comparisons
child processes
optimization technique
merge sort
class derived
member function
n processors
l 0
sorting networks
o notation
o logn
seem reasonable
o n
based parametric search
sorting based parametric
fr echet distance
cole s optimization
binary search fashion
alt and godau
applications of parametric
number of calls
two sorting algorithms
o pt p
expected running time
parallel sorting algorithms
number of roots
quicksort based parametric
parametric search framework
functions in line
two polygonal curves
roots of p
resolve the comparisons
based on parametric
binary search approach
echet distance problem
o n processors
algorithm in sorting
value of l
determine the outcome
p t p
p and q
show that quicksort
two consecutive roots
cole 9 shows
median of lines
binary search 0
time of parametric
parallel merge sort
decision problem p
solves the decision
reasonable in practice
roots are uniformly
permuting the input
batch of roots
bounds on l
batching of comparisons
derived from comparison_base
conditions that seem
computing the fr
known to lie
l l 0
l is known
determines the outcome
use the framework
l l l
l is true
p l 0
paper we show

corpus/krapavin2000-test/1016490.txt
iso
surface
shrinkwrap
triangles
abc
curvature
triangulation
triangle
sphere
deltav
saddle
radius
penguin
surfaces
nowhere
voxel
ok
wyvill
skeleton
fi
unacceptable
fepts
edges
vertex
curve
rv
skeletal
raphson
acceptability
vertices
bloomentha
tesselation
mesh
penetrate
polygonisation
acceptable
newton
polygons
equilateral
spheres
edge
fflfi
splitting
plane
subdivided
adaptive
iterations
split
gradient
sectors
na
evaluations
samples
topological
ffl
nb
homeomorphic
thick
ab
gradually
round
ae
cubic
triangulated
ci
extremes
perpendicular
sufficiently
unlabel
fept
planes
ffi
normals
midpoint
sin
shape
spherical
plate
ray
nishimura
convex
intersecting
polygon
curved
shrink
bill
tracing
geometry
gorithm
blended
grad
bloomenthal
rubbery
convergence
segments
modelling
move
robustness
flat
quantitative
minimise
sampling
smooth
gradients
accuracy
depicted
designates
taylor
geometric
sector
tetrahedron
centres
normalised
fig
offset
adaptivity
appendix
holes
regions
lay
cube
approximated
away
submission
ning
triangular
regards
multipliers
unnecessarily
elsewhere
phi
1d
deformations
cylinder
vicinity
neighbourhood
animation
beforehand
intersected
behaviour
expansion
coordinate
stays
nc
visualise
onalised
perpendicularity
falsi
guin
polygonomial
topologicalchanges
additionaladvantage
tesselating
ruptures
cwamvo
coherant
bloomental
polyg
jeopardize
minkowsky
calgary
oversized
octtree
minimisation
culated
artihmetic
wards
kees
protruded
comparitive
overveld
occtree
cubical
rupture
polygonizing
eut
slender
regula
graphicsjungle
shrinkingof
polygonisationof
polynomialsare
cylindrically
sederberg
accpetable
porcess
iso surface
fi k
triangle abc
iso surfaces
n steps
curvature radius
v r
shrinkwrap algorithm
v 0
triangulation ok
ok shrinkwrap
non acceptable
saddle point
radius fi
radius ae
iso value
newton raphson
function v
r saddle
short edges
unacceptable edges
wyvill 86
rv r
surface cannot
local curvature
voxel based
function evaluations
normal vectors
topological changes
split edges
edge ab
sphere round
scale structure
underlying surface
acceptable edge
surface v
color plate
per triangle
shrinkwrap 3
v saddle
fflfi k
adaptive triangulation
splitting edges
polygonisation algorithms
offset surface
thick curve
skeletal elements
shrinkwrap process
convex polygons
r v
v e
ray tracing
phi p
point m
points line
statement s1
sufficiently close
v d
line segments
v v
triangular mesh
point r
taylor expansion
adaptive algorithm
value v
algorithm ffl
appendix b
make quantitative
three spheres
dashed thick
shrinkwrap 4
quantitative statements
voxel boundaries
skeleton elements
value fi
skeleton element
fig 1f
vertices onto
many unnecessary
shape detail
initially unacceptable
great train
equilateral triangles
e grad
shrinkwrap 2
average curvature
b topological
nowhere smaller
circle sectors
paper self
coarse outline
triangulation shrinkwrap
affine arithmetic
incomplete triangulation
new triangles
next v
higher iso
cannot penetrate
new unacceptable
v 0 k
triangulation ok shrinkwrap
ae i v
radius fi k
b and c
number of triangles
function v r
value of v
large scale structure
sphere with radius
iso surface cannot
value for fi
class of iso
ok shrinkwrap 3
points line segments
v r v
v v r
collection of points
number of fepts
away than fi
unacceptable edges may
values v 0
final iso surface
surface cannot penetrate
surface has nowhere
k and centres
value of deltav
segments and convex
value v saddle
abc is bounded
paper self contained
grad v v
v e grad
since the iso
intersecting the surface
edges and triangles
make this paper
give a coarse
value for n
b topological changes
approximated by abc
spheres with radius
great train rubbery
comparison with earlier
incomplete triangulation shrinkwrap
nowhere further away
higher iso value
split but new
next higher iso
triangulation shrinkwrap 2
surface for every
appendix b topological
initially unacceptable edges
distance fflfi k
less than fi
voxel based methods

corpus/krapavin2000-test/1011810.txt
stably
population
agents
agent
live
computable
timer
leader
interactions
batons
counter
sensors
counters
predicates
baton
protocol
flock
interaction
sensor
turing
conjugating
semilinear
bit
encounters
protocols
birds
parity
predicate
stabilizes
elevated
fn
ra
configuration
randomized
multiset
zeroing
configurations
petri
nondeterministic
automata
stable
initiator
responder
convention
transition
quotient
transitions
reachable
catalytic
tokens
encounter
fairness
wireless
stabilize
gn
temperatures
marks
winner
modulo
encoding
urn
majority
simulated
populations
su
alert
complementation
outputs
sensing
pn
inputs
eventually
rl
nonzero
expressible
signal
computes
passively
interact
probability
members
sampling
bits
output
eisenstat
bigraphical
yc
erent
intriguing
decrement
assignments
conventions
mobile
communicate
initialization
tape
chemical
assignment
nets
loser
interac
cx
plete
halts
aggregation
nl
integers
infinitely
pairing
waits
simulates
machines
temperature
decrements
complementing
boolean
simulate
weakly
di
bird
alphabets
swaps
mobility
station
sketch
integer
simulating
characterization
copies
kp
capacity
symbols
interacting
increment
power
subterm
weakest
arithmetic
ciently
count
flips
symbol
net
questions
log
computa
maps
blank
decidability
atomic
communicating
mod
valued
hn
pairwise
cient
stopped
capable
families
machine
enabled
lightweight
swapping
severely
expressions
fee
coordinates
computations
bile
crippling
teractions
pritchard
parikh
diamadi
tersection
usely
volzer
ginsburg
respon
boudol
conven
tually
subpopulations
catalyst
vices
egecioglu
zafiropulo
subprotocol
live bit
stably computable
population protocol
population protocols
stably computes
bit equal
interaction graph
computable predicates
data bit
stable computation
counter machine
global start
start signal
turing machine
conjugating automata
timer k
integer quotient
least 5
every agent
finite state
input assignment
configuration c
population configurations
semilinear sets
ra x
source counter
output assignment
predicate output
transition function
high probability
two agents
initialization phase
leader encounters
output convention
predicates computable
randomized turing
encoding convention
agent u
population configuration
expected total
log n
expected number
computational power
state agents
n k
single valued
expression language
abstract machine
fairness condition
input x
sensor networks
based input
stably computed
output map
let fn
population members
sensor values
c reachable
input map
remainder modulo
agents assigned
p rl
chemical abstract
random pairing
alert state
unique leader
capacity o
assignment x
elevated temperatures
atomic expressions
space turing
randomized population
input assignments
stably compute
output assignments
population pn
nonzero constant
o 1
probability 1
one agent
correct answer
infinitely often
output encoding
pairwise interactions
live bit equal
number of interactions
stably computable predicates
agent with live
global start signal
probability of error
number of 1
equal to 1
ra x y
graph is complete
expected total number
sets its live
predicate output convention
randomized turing machine
fn and gn
model of conjugating
timer k times
computable by population
agents with live
bit to 0
count to five
encounters the timer
input and output
whether at least
finite state agents
every other agent
flock of birds
n k 1
o 1 counters
protocol a stably
function or predicate
families of boolean
m and 3
chemical abstract machine
stabilizes to output
define a model
interaction that involves
randomized population protocol
quotient of m
agent based input
mod 2 sum
one other agent
counters of capacity
capacity o n
condition on interactions
computes a predicate
machine with o
input assignment x
closed under complementation
power of stable
reachable from c
whether the number
input output relation
say that c
x y holds
set of predicates

corpus/krapavin2000-test/1028478.txt
signature
signatures
elliptic
cdh
hellman
security
gdh
curves
bilinear
weil
co
prime
dsa
curve
supersingular
maptogroup
pairing
multiplier
hash
public
hp
eld
subgroup
mov
di
tate
verication
forger
ddh
forgery
oracle
discrete
groups
computable
message
isomorphism
automorphism
aggregate
abort
keygen
gap
degenerate
secure
attack
batch
breaks
queries
log
pairings
private
tuple
genus
rsa
hm
short
secret
bits
challenger
map
koblitz
galbraith
ateniese
balasubramanian
nite
alexandria
logarithms
query
adv
bit
issued
je
coppersmith
responds
messages
dlog
signing
party
brie
dened
cryptographic
dene
ciently
abelian
shares
attacks
maps
varieties
cryptosystems
pfdh
cdha
pederson
hqi
baretto
sieve
descent
existentially
characteristic
verifying
trace
insecure
denition
existential
pk
exponentiation
linearly
defeating
undeniable
silverberg
unforgeable
publishes
authority
multipliers
su
giuseppe
multiplication
group
va
sig
generator
cryptography
chaum
aggregated
digital
jacobian
ij
coin
okamoto
families
intractable
generic
logarithm
specically
invalid
keys
intractability
resembles
onto
succeeds
rst
tosses
subgroups
pick
culty
threshold
accept
probability
discriminant
homomorphism
modulus
dierent
game
sign
veri
pr
divide
divides
failure
verify
approximately
instantiations
wins
valid
users
cient
divisor
elds
veried
random
ci
believed
trusted
reducible
share
pm
people
communications
parties
jg
hyperelliptic
miyaji
kuhlman
ecdsa
unforgeability
diffiehellman
moni
renfro
certicates
postcard
patarin
ghs
f q
signature scheme
discrete log
di e
e hellman
e f
elliptic curve
order p
elliptic curves
g 1
short signatures
co cdh
co di
co gdh
log problem
security multiplier
gdh groups
bilinear map
prime order
g 2
algorithm b
signature queries
public key
nite eld
gap di
weil pairing
h list
tr q
group pair
h 0
random oracle
curve e
maptogroup h
cdh problem
hellman groups
private key
chosen message
n signatures
f 3
message m
hellman problem
hash function
signature length
signature query
supersingular curves
z p
non supersingular
e p
short signature
bilinear maps
decision co
tate pairing
trace map
gdh group
message signature
largest prime
computational co
message attack
computable isomorphism
non degenerate
h m
m f
f 0
log algorithm
ciently computable
linearly independent
distinct messages
let e
signature pair
mov reduction
certain elliptic
supersingular elliptic
bit prime
domain hash
dsa signatures
je f
aggregate signatures
hellman group
weil descent
aggregate signature
batch verication
hellman tuple
generic discrete
supersingular curve
signature schemes
map e
q 6
oracle model
tuple hm
full domain
h queries
q h
secret key
time unit
computational di
approximately 2
complex multiplication
pick random
output invalid
subgroup hp
bilinear group
key v
signature verication
dsa using
message recovery
constructing short
co ddh
gdh signatures
abelian varieties
e f q
di e hellman
co di e
discrete log problem
prime order p
gap di e
let e f
e hellman problem
co gdh groups
maptogroup h 0
e hellman groups
curve e f
e f 3
m 2 f0
co cdh problem
point of prime
message m 2
chosen message attack
computational co di
tr q 6
decision co di
q 6 o
point of order
e ciently computable
points in e
bilinear map e
independent of p
discrete log algorithm
generic discrete log
dened by y
computational di e
f 3 6
supersingular elliptic curves
full domain hash
message signature pair
f q r
problem in f
e hellman tuple
e hellman group
random oracle model
one time unit
theorem 3 2
c g 1
q of order
generator of g
signature on m
level of security
breaks computational co
je f q
gdh group pair
h 0 hash
v 2 g
curve and let
used for short
non supersingular curves
ciently computable isomorphism
public key v
p in e
q f0 1g
signatures on distinct
key is x
subgroup of e
bilinear group pair
adaptive chosen message
key is v
mov reduction maps
non supersingular elliptic
failure and terminates
eld of characteristic
log in g

corpus/krapavin2000-test/1024018.txt
prs
circuits
circuit
gate
poly
acyclic
gates
slp
polynomials
eval
delta
idempotent
polynomial
replacement
accepting
deterministic
counting
subcircuit
idem
fictive
mineval
pc
np
psi
thetag
wurzburg
hardness
sect
straight
phi
pspace
representations
arithmetic
monomials
trees
maxeval
membership
subcircuits
nonterminal
fp
depth
informatik
venkateswaran
cvp
subtrees
instructions
sa
corp
ef
wires
exponential
universitat
inputs
lemma
stockmeyer
ch
boolean
multivariate
incoming
primes
reductions
subtree
unwinding
exerzierplatz
ebec
subsect
wuerzburg
montr
allender
rules
surprise
ke
meyer
replace
unary
theoretische
unwind
resp
iff
logarithmic
coefficients
nonnegative
eal
divisors
sos
evaluates
finitely
containment
evaluate
dfg
succinctness
upcoming
formulas
reflexive
instruction
clause
versa
monomial
qu
logspace
paths
modulo
derivations
vice
witnessing
diophantine
fi
counts
equivalence
fx
predecessor
pt
log
wagner
member
questions
nondeterministically
wire
maximization
prime
uni
unambiguous
edges
analogously
predecessors
ki
nontrivial
integer
evaluating
stratified
conjunctive
families
theta
permanent
formula
transitive
triggers
logcfl
dimatia
tompa
mckenzie
dspace
prss
caussinus
inessential
massaged
fcar
umontreal
erationnelle
aab
ville
kosub
renumbering
inequivalence
vy
iro
reexpress
vollmer
nump
cup
retarded
removement
tubingen
unambiguity
proof circuits
acyclic prs
proof trees
simple deterministic
circuit c
replacement systems
simple acyclic
output gate
polynomial replacement
input x
simple prs
counting proof
eval delta
range delta
poly delta
straight line
p complete
lemma 5
deterministic prs
gate g
membership problems
line program
arithmetic circuits
theorem 6
boolean circuit
line programs
variable membership
slp representation
integer circuit
idempotent simple
accepting subtrees
np complete
polynomial p
arithmetic circuit
f thetag
gates v
c x
n inputs
sect 3
m c
let delta
accepting subtree
thetag circuits
accepting paths
ef representation
every gate
prs delta
representations 1
logarithmic space
incoming edges
f g
acyclic systems
counts proof
phi p
x j
replace every
definition 5
many one
statement 2
variables x
sa h
replacement system
describe p
circuit value
gates level
integer circuits
n member
unique polynomial
mineval delta
one reduction
proof circuit
many representations
start polynomial
eval problem
nonterminal variable
pc fact
idempotent systems
c c
hand side
input variables
left hand
delta 2
systems definition
integer coefficients
full representation
hardness follows
one polynomial
integer expressions
representation p
input gates
depth 4
every simple
fi fi
deterministic and acyclic
number of proof
polynomial replacement systems
straight line program
simple and deterministic
simple acyclic prs
counting proof circuits
poly s poly
straight line programs
complete under log
idempotent simple deterministic
variable membership problems
simple and acyclic
number of accepting
lemma 5 7
boolean circuit c
f thetag circuits
trees and proof
lemma 5 13
evaluate to 1
computed in logarithmic
p a psi
c on input
gates of c
sum of monomials
range s range
c c x
lemma 5 8
theorem 6 2
delta and eval
range is np
circuit value problem
u v x
counting proof trees
np complete 3
given a circuit
p 2 poly
essential in p
j has incoming
circuits is p
representations of polynomials
representations 1 poly
counts proof circuits
systems definition 5
replace every x
replacement systems definition
stockmeyer and meyer
circuits of c
many one reduction
every x r
left hand side
evaluates to 1
circuit with n
complete for p
element is obtained
exists a simple
give a reduction
theorem 6 1
reflexive and transitive

corpus/krapavin2000-test/1008136.txt
ritz
lbd
lanczos
singular
irlanb
bidiagonalization
harmonic
bidiagonal
restarted
triplets
deflation
eigenvalues
tol
eigenvalue
restarts
arnoldi
aa
reorthogonalization
jdqz
matrices
factorization
residual
matrix
implicitly
matlab
shifts
refined
qr
irbleigs
convergence
pseudospectra
odt
irblsvds
smallest
converged
svd
sparse
davidson
implicit
tridiagonal
arpack
eigenproblems
restarting
hermitian
augmented
ective
eigensolvers
eignum
bulgechasing
sleijpen
symmetric
givens
restart
krylov
jacobi
shift
kahan
larsen
hessenberg
tolerance
golub
norm
blsz
vorst
svds
sorensen
propack
grcar
lr
av
orthonormal
runtimes
rank
rr
sec
clustered
triangular
subdiagonal
vectors
bases
vis
subspaces
approximations
reorthogonalize
reichel
jwph
nbls
normest
calvetti
qz
jmax
petrov
atel
baglama
neuch
eigs
stability
noting
clustering
diagonal
codes
owes
pseudospectrum
purging
squaring
jmin
orthogonal
orthogonality
inexact
numerical
bulge
uncontrollability
worth
subspace
ill
cf
conditioned
enhance
min
dw
nonsymmetric
galerkin
updated
decomposition
rescaling
cholesky
squared
approximate
abs
dimension
invert
van
eigenvectors
jia
shifted
depict
digits
century
squares
eigenvector
math
remedy
frameworks
seek
unitary
inverse
rotation
acknowledged
seeking
permit
largest
decompositions
nonsquare
deflated
bidiagonaliza
stathopoulos
pseudoiverse
maxit
pmaa
bqr
irlbsvds
premultiply
irbl
dooren
grimme
jbaglama
disuss
hochstenbach
eigendecompositions
aggravate
lsqr
errikos
bidiago
hypatia
hercma
pencils
kontoghiorghes
aspired
comptutation
fokkema
deflating
bodossaki
ruu
contine
ritz values
harmonic ritz
singular values
smallest singular
implicitly restarted
singular triplets
lanczos bidiagonalization
tol 1e
singular value
l 1
augmented matrix
starting vector
convergence tolerance
lanczos factorization
restarted lbd
refined residual
b l
lower bidiagonal
partial reorthogonalization
matrix c
u l
bidiagonal matrix
eigenvalue problems
large sparse
restarted lanczos
singular vector
restarted arnoldi
relative error
jacobi davidson
ritz vector
qr steps
implicit restarting
tolerance tol
sparse matrices
refined singular
lbd algorithm
approximate singular
lbd factorization
symmetric eigenvalue
e ective
rank one
v l
right singular
c l
irbleigs irblsvds
ritz value
symmetric eigensolvers
error ritz
matrix free
implicit qr
ritz shifts
ritz harmonic
refined ritz
restarts relative
singular vectors
condition numbers
tridiagonal matrix
y l
numerical experiments
eigenvalue problem
upper bidiagonal
lanczos method
upper hessenberg
diagonal matrices
sec 8
c m
matrix b
l y
worth noting
value decomposition
one modification
aa u
inexact inverse
orthogonality among
givens rotation
either aa
matlab codes
davidson type
ritz number
lanczos applied
bases u
shifted qr
deflation techniques
implicit shifts
implicitly shifted
small singular
implicit restarts
symmetric rank
aa 1
applied directly
large matrices
following relations
special structure
bidiagonal form
b k
basis vectors
lower triangular
search space
z c
arnoldi methods
y r
matrix algorithms
convergence behavior
ill conditioned
compute one
therefore b
harmonic ritz values
smallest singular values
smallest singular triplets
augmented matrix c
implicitly restarted lbd
number of restarts
smallest singular value
u l 1
implicitly restarted lanczos
implicitly restarted arnoldi
convergence tolerance tol
tolerance tol 1e
large sparse matrices
triplets of large
implicit qr steps
steps of lbd
tol 1e 6
tol 1e 8
bidiagonal matrix b
values of aa
error ritz harmonic
tol 1e 10
ritz harmonic ritz
equivalent to implicitly
right singular vector
restarts relative error
z c l
sec 8 6
relative error ritz
refined ritz vector
c l 1
computation of pseudospectra
c m n
e l 1
singular value decomposition
harmonic ritz number
set to tol
rank one modification
symmetric eigenvalue problem
behavior of irlanb
matrix b k
bidiagonalization with partial
symmetric rank one
implicitly shifted qr
matrix a c
tolerance was set
lbd is equivalent
refined singular vectors
irlanb with harmonic
approximate singular values
l 1 e
computing the smallest
equivalent to lanczos
compute the eigenvalues
values of l
methods for large
jacobi davidson iteration
application of polynomial
step arnoldi method
partial singular value
starting vector u
k step arnoldi
eigenvalues of c
pseudospectra of large
restarted lanczos bidiagonalization
right refined singular
compute the harmonic
small singular triplets
obtain a lanczos
upper bidiagonal matrix
shift and invert
petrov galerkin condition
values of large
implicitly restarted block
orthogonal deflation transformation
algorithm we call
b l 1
matrices using odt
experiments with irlanb

corpus/krapavin2000-test/631246.txt
controller
breaker
breakers
circuit
transformer
sigali
signal
fault
pds
station
attractivity
departure
objectives
faults
controllable
dynamical
sensors
voltage
cells
upstream
req
synthesis
polynomial
opened
invariance
cell
uncontrollable
visibility
plant
admissible
event
prop
boolean
arrival
controllers
propagation
dep
verification
cb
signals
closing
reqopen
insuring
downstream
zx
instant
triples
link
electric
opening
rc
default
events
reachability
physical
power
synthesize
specification
false
algebraic
interruption
hospital
double
synthesized
arr
controlled
bdd
trajectory
compatible
concerns
coded
reqclose
zclose
lectricit
subprocesses
clocks
encode
file
clock
instants
picked
named
booleans
primitive
synchronous
sc
equations
absent
evolves
behaviors
lem
equational
sequel
dangerous
polynomials
trajectories
ideals
compiler
open
chao
confirmation
varieties
maximal
material
establishment
reachable
translation
requirements
interpreted
appearance
sensor
kai
yong
translated
cai
closed
manipulates
triple
yuan
processes
methodology
solutions
supplies
logical
informed
init
prob
disappear
transient
safety
controls
checked
abstraction
composition
homopolar
quations
wattmetric
openlink
pz
paren
gali
electrocute
supervisory
setstates
tractivity
wenhui
currents
rwc
reorganized
syrf
evolve
specifies
duration
allocated
instantaneous
importance
proposition
fig
diagram
receives
definitively
verif
deprived
phisms
contrario
spontaneously
electricity
emption
reopened
reactivity
xng
costumers
encoded
incremental
language
objective
requests
encodes
strict
classical
circuit breaker
circuit breakers
transformer station
control objectives
power transformer
polynomial dynamical
signal program
order relation
controller synthesis
state x
z 3z
station controller
control u
controlled system
signal language
dynamical system
state variable
physical fault
two faults
initial states
boolean prop
req open
power propagation
departure level
fault propagation
states e
set states
discrete event
req close
fault link
fault dep
station network
invariance reachability
synthesis methodology
verification objectives
controller c
double fault
different circuit
fault visibility
link circuit
event y
boolean error
double faults
event systems
different cells
state variables
cost function
dynamical systems
link level
cell 1
x 0
polynomial relation
departure circuit
upstream circuit
controller insuring
arrival level
high voltage
departure cell
default false
signal programs
controller using
system evolves
arrival cell
logical abstraction
polynomial dynamic
next instant
system sc
departure cells
cost allocated
closing requests
traditional control
dep 1
fault exists
relation c
value true
c x
q x
physical model
triple x
local controllers
primitive operators
main process
control synthesis
strict order
event variables
polynomial equations
signal x
polynomial c
non boolean
order relations
c defined
states f
data flow
using algebraic
optimal control
power transformer station
set of states
transformer station controller
polynomial dynamical system
breaker is opened
specified in signal
polynomial dynamical systems
discrete event systems
different circuit breakers
transformer station network
prop is true
interpreted by sigali
controller synthesis methodology
order relation c
y in x
specification in signal
error is true
strict order relation
upstream circuit breakers
compatible with y
departure cell 1
breakers are closed
c x 0
present and true
control of discrete
control of polynomial
link circuit breaker
station controller using
value of x
terms of polynomial
opening and closing
relation a c
takes the value
controlled system sc
control verification objectives
propagation and visibility
process power propagation
sigali that checks
fault is picked
true and close
yong chao li
non boolean expressions
receives the event
default when faultdep2
fault dep 1
terms of polynomials
compute a controller
fault prob lem
traditional control objectives
true when two
corresponding circuit breaker
account the importance

corpus/krapavin2000-test/611430.txt
image
skeletons
iatg
skeleton
dcg
parallelism
operators
char
images
void
unsigned
stereo
baseline
triadic
processors
monadic
dyadic
neighborhood
pixels
imagepointdist
taskb
taska
master
pixel
task
ups
host
lters
disparity
vision
mpi
tasks
int
imaging
compositing
destination
operator
lter
algorithmic
convolution
redistribution
proling
imagewindowdist
processor
dierent
window
cameras
mdg
dierence
mixed
scheduling
shifted
precedence
ltering
squared
alpha
nonlinear
snopt
plaza
parallelized
headers
communication
fortran
kernel
pure
sobel
tted
cpr
ecient
restoration
ref
subtract
horizontally
preemptively
panda
myrinet
rst
costs
exploiting
subtraction
stripe
blend
executing
surrounding
exec
alu
ow
library
dene
processed
predicted
das
allocated
pcs
laplace
classication
edges
fig
speed
node
dicult
multicomputers
sequential
create
lm
linux
coding
win
eort
speedups
num
acyclic
balanced
versus
pictures
paradigm
arithmetic
aldist
imageglobaldist
blood
proled
pararameter
serot
disscus
seinstra
approac
ideea
valencia
ral
imageglob
tsas
erators
koelma
bagdanov
crispening
moddeling
mnkl
tabulate
asci
attened
name
moved
rendered
macro
eld
source
pentium
pipelined
critical
multiply
blurring
orca
ampl
assembles
angiography
hyperspectral
okutomi
webb
formula
stands
achievable
emerged
nodes
rendering
corner
reference
image processing
task parallel
data parallelism
data parallel
baseline stereo
point operators
task parallelism
dcg skeleton
multi baseline
n char
global operators
processing operators
unsigned int
stereo vision
level image
int n
image operators
parallel approach
neighborhood operators
parallel framework
void im_op
algorithmic skeletons
parallel image
application task
vision application
output void
using skeletons
task graph
mixed task
low level
image application
char name1
char name2
processing application
output image
d x
one input
speed ups
constant d
processors executing
source image
destination image
input images
operators one
communication time
parallel programming
processed area
char name
image operator
master 0
pure task
dyadic point
host processor
source images
processing user
destination pixel
distributed memory
input image
reference image
processing environment
input output
char name3
nonlinear lters
image master
function operation
graph iatg
monadic image
processing operator
average area
monadic point
point neighborhood
d pixels
image operations
fortran m
neighborhood operator
processor tasks
computer imaging
disparity image
match images
operations function
tasks image
name void
either pure
ups obtained
squared dierence
critical path
data d
task number
two source
dierent image
new output
host processors
application described
one output
execution time
distribution scheme
processors allocated
communication costs
convolution kernel
image d
entire image
parallel environment
framework based
parallel tasks
point communication
two dimensional
processing applications
sequential code
well balanced
image point
parallel code
monadic operations
operator applied
task taska
master master
parallelism 7
processing library
win void
triadic point
taskb processors
operations monadic
macro data
operators takes
imagepointdist 1io
node approach
char name4
adding data
non preemptively
data and task
task and data
baseline stereo vision
multi baseline stereo
low level image
int n char
image processing operators
unsigned int n
level image processing
application task graph
stereo vision application
parallel image processing
constant d x
void im_op dcg
image processing application
char name1 char
task parallel framework
n char name1
image application task
operators one input
data parallel approach
skeleton for monadic
one input output
image processing user
image processing environment
task parallel approach
dyadic point operators
one output void
n char name
number of processors
pure task parallelism
task parallel environment
two source images
image processing operator
level image operators
speed ups obtained
name void im_op
task graph iatg
operations function operation
skeleton for neighborhood
new output image
h k l
input output void
char name2 char
parallel framework based
operators we assigned
char name void
monadic point operators
neighborhood and global
point operators one
set of processors
f m n
distributed memory system
image processing applications
data parallel programming
window win void
point operators takes
parallelism 7 8
exploiting mixed task
compared to either
monadic dyadic point
skeleton for global
pro 200mhz pcs
neighborhood operator original
processors executing task
image an example
char name3 char
top left corner
node 1 node
d pixels task
operations monadic image
c using mpi
executing taskb processors
mpi panda library
parallelism has emerged
either pure task
connected through myrinet
image operations function
pure data parallelism
panda library 19
vision application described
classication of low
parallelism is limited
rendered separately possibly
large computational problems
model for integrated
processed image master
dyadic image operators
node 2 node
image and two
ram running linux
dierent image sizes
monadic image operations
performance thus exploiting

corpus/krapavin2000-test/637151.txt
defective
oca
cell
intact
cells
cas
cellular
recognizable
defects
ca
leftmost
counter
rt
ocas
arrays
sd
mo
tolerant
dd
automata
ow
fault
conguration
signal
recognition
constructor
registers
diagnosis
neighbor
capabilities
links
nite
strings
failures
leftmoving
rightmost
rst
transition
string
lengths
array
reliable
link
massively
nonuniform
recognizes
congurations
corollary
signals
devices
synchronization
nal
neighbors
jwj
regions
adjacent
transmit
carry
transmitted
misoperations
squad
sequel
compensated
inclusions
arrives
register
conserved
interacting
signicant
reversal
hs
repair
subroutines
denition
stop
constructors
shift
waiting
failure
pushdown
static
overflow
computations
ows
resp
dene
constructible
stores
se
symbols
receives
reset
recognized
regain
cf
ng
self
simulates
enlarged
contents
ai
nonempty
depicted
syntactical
device
enters
arrival
concerned
circuit
recognize
received
successor
nondeterminism
counters
interconnected
establishes
broken
dened
incapacitate
inheres
invalids
stepg
trellis
bidirectionality
homogenously
bounces
fww
misoperation
nearest
fail
marking
adapt
delay
symbol
reliably
correspondingly
prepared
boundary
compensate
unreliable
admissible
invalid
equivalence
formalization
needless
incrementation
characterizable
subarray
subsequently
behave
marks
latest
strictly
ring
wider
relax
indication
nobody
mapping
speed
track
language
ne
simulation
binary
lt
organisms
tomata
nization
compression
eect
lim
bit
positions
recognizers
word
sends
indicated
satises
region
modulo
located
intensively
signaled
distinguishable
adaption
belong
synchro
synchronously
enlarge
simulated
receive
jdj
neumann
digit
strictness
joint
investigated
defective cells
defective cell
leftmost cell
l rt
real time
sd ca
cellular automata
cellular arrays
time constructor
b cells
fault tolerant
intact cells
way arrays
defective regions
two way
time recognizable
transition function
way cellular
cellular array
dd ca
mo ca
mo cas
intact cell
information ow
dynamic defects
time step
link failures
recognition capabilities
intact neighbor
stop signal
self diagnosis
rt oca
counter c
local transition
one way
sd cas
signal arrives
static defects
additional registers
shift right
o ca
computation result
time steps
adjacent cells
counter value
right counter
string sets
defective region
boundary state
signicant bit
defective links
intact one
actual computation
computation would
binary counter
tolerant real
nite state
cf figure
input symbols
right neighbor
every time
oca counter
new defects
rt mo
leftmoving signal
tolerant computations
intact ones
cell cannot
diagnosis circuit
received counter
twice real
tolerant recognizable
adjacent defective
conguration c
hs ai
least signicant
next intact
time constructors
reliable computations
binary oca
oca l
way array
cell states
cell enters
modify information
defective cellular
input string
massively parallel
register contents
speed 1
cannot modify
b cell
receive information
nite nonempty
cell f
real time recognizable
c t 1
local transition function
l rt oca
within the b
one way arrays
c 0 w
way cellular array
two way arrays
one way cellular
within the rst
shift right counter
stop signal arrives
every time step
able to transmit
tolerant real time
fault tolerant real
set of strings
f f f
overall computation result
self diagnosis circuit
enters a nal
constructor for 2
twice real time
nite nonempty set
leftmost cell enters
arrays with dynamic
counter c 2
oca l rt
cells are intact
set is fault
cannot modify information
n a cells
regions are bounded
received counter value
way cellular automata
cell cannot modify
least signicant bit
fault tolerant computations
rt oca l
two way cellular
defective cell cannot
boundary state 3
rt mo ca
set of cell
fault tolerant recognizable
intact one way
nite state machine
way information ow
l rt mo
set is real
right to left
belong to l
broken into two
increased by 1
time 2 2
m 2 n

corpus/krapavin2000-test/628025.txt
interestingness
actionable
patterns
discovered
unexpected
yes
attribute
ranking
subjective
consequent
fuzzy
unexpectedness
discovery
confirming
matching
attr
mining
pattern
match
action
ranked
rank
actionability
consequents
beliefs
killed
kefir
feelings
actions
contradictory
unanticipated
bing
conditional
injury
database
discover
belief
names
propositions
measures
act
sigkdd
novelty
uninteresting
rankings
contradicting
finding
linguistic
expectations
saroj
wynne
educate
kaidi
benkler
opu
junct
universe
cut
proposition
membership
weimin
semantic
degrees
degree
expects
interests
specified
huge
philadelphia
comprehend
ops
formulas
objective
association
asking
significance
grade
old
confirm
intuitive
deviations
overwhelmed
accident
conformity
oxford
findings
poor
soft
health
continuous
install
confidentiality
cameras
user
useless
liu
hsu
coverage
experts
something
slow
listed
xiao
expectation
production
name
databases
explanation
parts
zhao
ranks
visibility
recommended
interactive
jeffrey
meanings
people
kth
explora
sugato
susumu
horiguchi
underweight
conformities
joydeep
actionabilities
hwee
pasupuleti
discoverable
krupakar
disocvery
discourse
angeline
liqiang
phan
pa
rules
operators
classification
discrete
handbook
press
age
mooney
evidences
shekar
geng
modifiable
talip
quintuple
fashions
bends
minh
healthcare
inoguchi
pazzani
inconclusive
bao
abstractone
insufficient
apart
asian
xindong
bharadwaj
niall
hurricane
hamilton
shichao
leng
hierachical
confidence
class yes
discovered patterns
unexpected patterns
finding unexpected
user specified
actionable patterns
specified pattern
q d
expected patterns
finding actionable
confirming user
subjective interestingness
discovered pattern
conditional parts
knowledge discovery
pattern 1
pattern 2
e j
attribute names
expected pattern
act q
user expected
matching values
data mining
patterns according
b q
proposed technique
r z
attribute values
actionable according
low matching
yes 1
yes actionable
objective measures
interesting patterns
subjective measures
consequent parts
classification patterns
yes pattern
specified action
match well
patterns discovered
matching technique
interestingness measures
fuzzy matching
action 2
contradicting user
semantic rule
ranked higher
action pattern
discrete attribute
previous knowledge
action patterns
intuitive feelings
interestingness problem
bing liu
action 1
attribute name
patterns e
two propositions
j k
fuzzy set
attribute value
killed 3
value match
matching attribute
name match
denote w
specified expected
yes class
computing w
action y
yes contradicting
higher w
yes confirming
sigkdd international
acm sigkdd
domain knowledge
huge number
patterns 3
proposed method
user patterns
pattern e
pattern b
j value
user 4
unexpected consequent
matching algorithm
ranking results
test example
user specified pattern
finding unexpected patterns
finding actionable patterns
degree of match
b q d
specified pattern 1
user s knowledge
w i j
v i j
parts of b
patterns are cut
according to user
yes actionable according
low matching values
class yes actionable
specified pattern 2
pattern 1 class
yes no 0
rank the discovered
set of patterns
confirming user specified
class yes pattern
user specified action
number of patterns
computed as follows
z i j
specified action pattern
discovered patterns according
user expected patterns
contradicting user specified
find those patterns
set of interesting
k and z
discovery and data
conference on knowledge
sigkdd international conference
acm sigkdd international
attribute name match
universe or domain
method for ranking
asking the user
discovered by q
b i whose
matching values 6
yes contradicting user
q on d
run the focus
one user specified
pattern 2 class
class yes contradicting
yes confirming user
yes class yes
types of ranking
patterns in b
action y q
degree of membership
user specified expected
class yes class
degrees of match
user expected pattern
g 4 8
value for b
fuzzy matching technique
class yes confirming
since this ranking
interested in different
knowledge or intuitive
set of expected
degrees of interestingness

corpus/krapavin2000-test/627771.txt
starburst
rule
triggered
ruleset
transaction
transition
triggering
command
rules
attachment
privilege
authorization
database
commands
emp
employees
privileges
salary
deleted
alter
inserted
sql
extensibility
active
tuple
updated
actions
delete
cascade
transitions
tuples
chimera
deactivate
production
creator
rollback
ariel
sal
procedures
employee
invoked
deletes
deactivated
module
semantics
tables
relational
commit
catalog
precedes
trigger
consistency
postgres
integrity
almaden
action
drop
concurrency
locks
clause
triggers
language
dept
mary
departments
priority
dbms
jane
sue
modifies
ffl
composite
ordering
activate
executed
hipac
paradiser
rete
ceri
priorities
net
bill
deductive
eligible
queue
create
jim
prepare
stefano
query
logged
registered
registering
mgr
old
dropped
occurred
oriented
executes
lock
revoke
attachments
insert
clauses
maintenance
issuing
sam
commits
specifies
event
execution
arrows
exclusive
loosely
select
altered
facility
databases
rpl
goce
rdl
heraclitus
trajcevski
salaries
creation
modification
log
syntax
automatically
heterogeneity
transitively
attach
references
integrating
name
depict
enforcing
coupled
management
stamp
statement
prototype
descriptor
implementing
serial
maintaining
scheuermann
subsuming
queues
expert
rolled
retrospective
unrestricted
precede
locking
processor
incremental
executing
sees
arrow
ibm
orderings
schedule
option
invokes
debugging
deriving
features
authorized
enforce
issued
referenced
obtains
materialized
integrated
identifier
rejected
upgraded
enforced
manipulating
semantic
flexible
handling
update
manipulation
creates
considers
undo
contents
created
shared
records
recovery
maintained
implied
deferred
processed
project
denotational
rule processing
rule system
starburst rule
rule execution
rule language
transition log
active database
rule set
process ruleset
rule definition
triggering operations
rule sets
transition table
transition tables
execution module
rule r
transaction rule
transaction x
process rules
rule command
triggered rules
database system
net effect
create rule
process rule
extensibility features
potential rules
rule conditions
new updated
rule catalog
rule cascade
rule list
old updated
rule condition
concurrency control
definition command
sal control
database rule
drop rule
list rule
rules process
ruleset command
production rules
tuple level
active rule
rules may
since rule
query processor
database systems
object oriented
rule name
ffl rule
event queue
composite transition
deleted employees
execution semantics
control privilege
rule attachment
control authorization
rule management
alter rule
sql select
one rule
active rules
processing information
condition evaluation
starburst rules
table function
clause specifies
arbitrary database
select statement
action execution
database state
database rules
r 2
postgres rule
updated tuples
level rule
operations occurred
rule actions
global rule
table functions
attachment type
attachment procedures
rule triggering
select emp
average salary
almaden research
ibm almaden
data modification
rule information
error handling
insert delete
statement level
integrity constraints
rule creation
follows clauses
transition information
x 1
r 1
x 2
starburst rule system
starburst rule language
transaction rule processing
rule is triggered
end of transaction
rule execution module
active database systems
rules are triggered
conditions and actions
semantics of rule
actions are executed
process rules process
rules process ruleset
rule definition command
list rule list
effect of x
within a transaction
name on table
rule s condition
rule processing information
concurrency control authorization
precedes and follows
prepare to commit
active database rules
features of starburst
process ruleset command
rules or rule
consistency if x
ibm almaden research
ruleset or process
active database rule
global rule information
triggering operations occurred
updated and old
considered and executed
least one rule
process rule command
database state transitions
rule list rule
almaden research center
condition is true
suppose a transaction
state s 1
r s condition
respect to rules
process rules command
triggered if one
state s 3
transition table references
evaluation and action
rule s triggering
postgres rule system
selected for consideration
transaction x executes
employees and departments
command is rejected
delete or update
inserted transition table
r is triggered
uses the changes
starburst query processor
management and rule
starburst s rule
must be logged
behavior of rule
composite transition since
considers every change
level rule processing
sql select statement
set of deleted
create rule command
rule system must
arbitrary database state
command invokes rule
sam and sue
sees the effect
triggered by updated

corpus/krapavin2000-test/607624.txt
hoovers
foil
hypertext
classication
knn
classiers
linked
pages
regularity
univ
competitor
classier
tagged
document
web
nb
documents
categorization
regularities
text
meta
hyperlinks
datasets
hyperlink
names
microavg
encyclopedia
page
preclassied
corpus
micro
category
averaged
webkb
precision
vocabulary
bayes
title
links
dataset
learning
company
scores
html
naive
training
macro
referencing
categories
jungyun
macroavg
youngjoong
chakrabarti
competitors
seo
score
patents
baseline
thresholding
suered
ko
representations
classification
cristo
tags
hyperlinked
classied
anchor
companies
sites
informative
curves
mining
dierent
corpora
patent
marcos
gonalves
articles
co
kernels
classifying
furnkranz
topic
neighboring
joachims
yahoo
relational
elds
crawler
reinforce
oh
exploiting
avg
neighbors
rich
pvel
svms
citations
calado
examinations
extracted
content
faculty
home
learner
break
link
noisy
ribeiro
sigir
classi
extraction
treating
label
classifiers
tasks
feature
nd
selection
retrieval
identiers
yiming
evgeniy
jinwoo
kisiel
ziviani
multistrategy
nivio
homework
gabrilovich
getoor
sication
aixin
denoyer
categorisation
brunessaux
marco
clas
predictive
management
linguistics
orleans
eective
weighting
improving
neighborhood
topically
moura
ludovic
shaul
gallinari
edleno
tagging
markovitch
dened
words
hypotheses
word
ve
hill
candidate
decisions
domains
taipei
conned
sources
peng
automated
site
specic
zhang
comparative
cosine
degradation
neto
baselines
linkage
berthier
conventional
exible
signicantly
yielded
online
trade
labels
univ 6
tagged words
linked words
competitor names
meta data
linked names
hypertext classication
text categorization
web pages
hoovers datasets
hoovers 255
nb knn
hoovers 28
co referencing
naive bayes
feature selection
classication tasks
hypertext regularities
micro averaged
referencing regularity
macro averaged
linked pages
words tagged
test document
text classication
linked documents
hypertext categorization
web page
encyclopedia regularity
even line
knn foil
title meta
break even
web sites
categorization using
youngjoong ko
chakrabarti et
meta linked
words title
preclassied regularity
names foil
data regularity
jungyun seo
microavg number
names score
recall knn
vocabulary sizes
names break
classification proceedings
recall precision
category labels
f 1
classication performance
partial co
neighboring documents
candidate categories
three classiers
category distributions
local words
text classification
class label
document classification
training documents
selected features
names nb
ko jungyun
averaged f
webkb university
regularity use
knn competitor
links per
nb competitor
linked neighbors
html title
company web
marco cristo
classication problems
foil competitor
classication decisions
html meta
university corpus
using hyperlink
thresholding strategies
linked neighborhood
features foil
rich information
using web
names competitor
words linked
information extraction
oh et
document d
information processing
trade o
words instead
journal v
local text
per company
ibm patents
foil linked
conventional text
classication scheme
joachims et
co referencing regularity
used with nb
nb and knn
linked words tagged
break even line
words tagged words
nb knn foil
words title meta
meta data regularity
tagged words title
knn and foil
names break even
title meta linked
meta linked names
chakrabarti et al
number of selected
processing and management
management an international
recall and precision
univ 6 dataset
knn and nb
partial co referencing
page only linked
foil on hoovers
classiers on univ
names foil competitor
ko jungyun seo
averaged and macro
selected features foil
competitor names score
linked names competitor
competitor names nb
classiers on hoovers
webkb university corpus
youngjoong ko jungyun
hypertext categorization using
names competitor names
precision and f
names nb competitor
tagged words instead
nb competitor names
performance of classiers
averaged f 1
competitor names foil
foil competitor names
recall knn competitor
document classification proceedings
knn competitor names
competitor names break
hypertext classication tasks
international journal v
text categorization using
oh et al
f 1 values
recall precision trade
links per page
documents neighboring class
precision microavg recall
words from linked
microavg recall knn
learning to classify
text categorization proceedings
precision macroavg recall
company web sites
using tagged words
macroavg recall knn
related web sites
precision trade o
representations for hypertext
micro averaged f
class a documents
microavg precision microavg
macroavg precision macroavg
joachims et al
n t d
strategies for text
conventional text categorization
web page used
information extraction techniques
data regularity use
n a n
classification information processing
journal v 40
links between pages
conference on research

corpus/krapavin2000-test/628133.txt
metadata
segments
news
video
unstructured
transitive
keywords
transcripts
query
segment
retrieval
retrieved
item
annotated
retrieve
composition
keyword
qs
similarity
clinton
universe
maxfd
content
items
cluster
reno
cut
transcript
structural
clustering
precision
semi
caption
fund
interview
weighting
hybrid
newscast
visuals
cuba
pope
newscasts
iraq
counsel
matched
belonging
clips
indexing
baby
foci
structured
annotation
cosine
event
match
raising
threshold
cl
comprised
ids
scene
search
clusters
leary
oprah
alabama
controversy
knife
gondola
isreal
clustered
eq
stemming
east
acquired
netanyahu
police
informedia
intern
janet
id
sibling
stories
sq
clinic
salton
cnn
union
eddie
digital
scenes
audio
frequency
matching
wild
relationships
automatic
chinese
border
creation
story
extraction
theme
witnesses
house
corpus
tf
scripts
visual
diagram
fig
siblings
structurally
queries
son
piece
object
organize
weight
candidate
text
isolate
trial
composing
indices
returned
varadero
kaczynski
captioned
karla
captioning
reporter
caffeine
mexican
raiser
nbc
genocide
elway
louise
bombing
guatemala
daryn
arrest
gay
democratic
faye
excavation
headline
awaited
okay
sights
tuker
enactment
posses
winfrey
stalemate
wachman
donated
queryable
narrative
chabot
videofile
lebanon
arafat
standoff
engaging
thematically
gore
paducah
camerawork
woodword
iraqi
sailor
johnny
santiago
kentucky
competency
officials
comedies
campaign
cbs
albright
preassembled
weapons
justice
hostage
rotorua
falcon
unstructured metadata
transitive search
news item
news items
video data
semi structured
video segments
structural metadata
structured metadata
annotated metadata
segments belonging
content metadata
related segments
four step
query cut
news event
similarity distance
metadata sets
video composition
step hybrid
similarity value
news video
union operation
retrieval technique
object id
metadata annotated
fund raising
binary relationship
automatic composition
segment weighting
query match
closed caption
process diagram
structured objects
digital video
composition system
object ids
candidate set
keyword vector
potential news
transitive cut
transcript metadata
within video
video piece
theta maxfd
segments related
independent counsel
distinct news
time relationships
increase recall
metadata based
hybrid retrieval
retrieval techniques
query q
search technique
initial segment
weight assigned
value retrieved
initial retrieval
improve recall
query matching
proposed hybrid
query processing
hybrid approach
q g
considered similar
creation time
two segments
data set
objects clustered
clustered object
metadata associated
isolate video
final weight
hybrid metadata
matched object
o leary
match final
complete unstructured
broadcast news
introduction field
caption data
associated unstructured
video based
scene interview
caption metadata
metadata object
transitive retrieval
janet reno
related segment
objects retrieve
extended cluster
segment vectors
retrieve related
highest match
retrieve additional
qs loop
corresponding semi
metadata matched
eddie price
newscast composition
segment transcripts
metadata organize
results clustering
clustered semi
newscasts based
retrieved segments
cut off threshold
semi structured metadata
set of segments
four step hybrid
semi structured objects
number of segments
initial segment weighting
among the segments
within video data
creation time relationships
set of video
hybrid retrieval technique
increase in recall
number of keywords
associated with video
video composition system
news video data
maxfd s q
techniques for video
technique is based
matched semi structured
towards a theme
d theta maxfd
information within video
different metadata sets
final video piece
structured metadata matched
structured objects retrieve
complete unstructured metadata
clustered semi structured
proposed by salton
matching a query
composition of news
segments are considered
retrieve corresponding semi
transitive search technique
query match final
closed caption metadata
closed caption data
step hybrid approach
q s g
structured metadata object
potential news items
keyword based search
retrieve all segments
final weight assigned
corresponding semi structured
metadata and structural
single news item
video data retrieval
query or 0
field scene interview
introduction field scene
item to retrieve
retrieval and composition
different retrieval techniques
match final weight
clustered object id
matched object ids
free form text
metadata to retrieve
step hybrid retrieval
associated unstructured metadata
define a binary
highest value retrieved

corpus/krapavin2000-test/1035761.txt
mut
protocols
protocol
synch
synchronizing
inhibiting
multifunction
composite
initiate
action
ff
inhibit
receptions
leader
token
en
fi
initiation
recd
actions
composition
ext
traverse
invariant
infer
initiator
unspecified
connect
superimposition
ch
liveness
enter
invariants
priority
exclusion
inhibited
site
para
initiated
message
ef
concurrently
channel
election
inhibits
mutual
establishment
initiators
multiphase
constraint
init
connection
sdata
item
disconnection
matching
receiving
credit
interleaved
sent
gamma
inferred
sites
req
sender
sends
rec
enable
ready
traversal
constraints
structuring
subproblems
avail
channels
bool
receivers
compositional
deadlock
receiver
processes
falserequest
fffg
raverse
fenter
rdata
rtoken
conflict
lemma
spend
guards
restrictions
initialization
inference
invalidate
enabled
ffig
subfunctions
terminates
messages
decomposed
specifying
safety
designing
pn
var
fff
combine
shared
active
superimposed
guard
false
inhibition
formalisms
executing
terminating
informally
incremented
phased
send
corollary
rules
combining
subtask
synchronized
component
head
statement
sequential
reachable
fusing
belongs
ri
transfer
dominates
imposing
event
incrementing
elect
communicating
executed
ab
wherein
formalism
arg
request
execution
flow
reflects
belonging
critical
win
snapshots
formulas
sending
mess
synchronzing
recr
truertoken
trueenter
folowing
fexit
falsestoken
reinitiate
trueelect
contentsm
lict
invaraint
interactions
involve
specify
discipline
modular
propositions
check
contents
permission
nized
subfunction
frequest
intial
interacting
imposed
snapshot
grant
items
id
projection
iterative
loop
structured
circulated
spective
disciplined
delivery
component protocols
composite protocol
mut 1
synch p
p q
initiate p
ff fi
synchronizing constraint
multifunction protocols
connect 1
unspecified receptions
f low
check 1
inhibiting constraint
synchronizing constraints
sent 1
enter 1
process mutual
traverse 1
inhibit p
hold 1
lemma 4
ef p
state g
liveness properties
three process
inhibiting constraints
enable p
mutual exclusion
data item
composition using
para list
traverse 2
leader 1
active p
connection establishment
terminates q
exclusion protocol
sequential composition
inference rules
loop statement
parallel composition
fi via
p terminates
var p
used used
functions concurrently
q conflict
ext 1
rec l
protocol m
composite protocols
en b
bool l
initialization action
connect 2
critical section
election protocol
flow control
interleaved execution
becomes true
leader election
protocol r
corollary 4
initial state
using synchronizing
multifunction protocol
computation associated
gamma hold
m para
recd 1
disconnection protocol
component functions
infer safety
protocols several
n process
combining connect
protocol mut
constructing multiphase
matching action
basic computation
true active
combining mut
multiple functions
ff unless
invalidate ff
token check
token gamma
data f
active q
capture id
protocol obtained
component protocol
unless fi
synch p q
mut 1 2
p and q
invariant of r
ch i j
free from unspecified
process mutual exclusion
inhibit p q
p has priority
connect 1 2
priority over q
q or p
fi in r
invariant of p
check i j
hold 1 2
check 1 3
invariant of mut
rules to infer
hold 1 3
mutual exclusion protocol
execution of p
r is free
set of constraints
leader election protocol
obtained by combining
b 2 synch
connect 2 1
p terminates q
fi in p
ff fi via
composite protocol r
check 1 2
ff is true
enter 1 2
hold i j
en a l
enter 1 3
true in g
safety and liveness
lemma lemma 4
synchronizing and inhibiting
mut 1 3
data f low
holds the token
next data item
id 1 sent
set of component
mut i j
two process mutual
two component protocols
variables in var
state g l
protocol by combining
combining mut 1
token gamma hold
sent 1 2
m para list
constraint is useful
p then ff
initiation of p
fi 2 ef
combining connect 1
en a gamma
ff unless fi
p i inhibits
belongs to synch
sent 1 3
capture id 1
true if ext
protocols which perform
refer to variables
composition of protocols
q is non
message of type
performs the function

corpus/krapavin2000-test/608356.txt
scenarios
scenario
backward
heitsch
romisch
ternary
stochastic
redistribution
simultaneous
reduction
forward
rel
weekly
cardinality
selection
mourier
fortet
load
tree
index
branching
trees
proposition
attained
xed
deleted
distances
lipschitz
supp
convex
dened
probability
metric
subtree
ng
min
norm
numerical
regular
electrical
distance
jr
recommends
deletion
nondecreasing
minimal
specic
perturbations
nitely
fast
conceptual
satises
fu
fn
discretization
altogether
formula
prescribed
indices
jg
nomially
bmbf
iwith
hourly
nondierentiable
recommendable
stochasticity
reduktion
kantorovich
handbooks
szenariob
accuracy
sorting
measures
hp
subtrees
mass
discrete
experience
motivates
nonlinearly
integrands
nfor
borel
minfd
favourable
maxf
piecewise
rst
binary
running
ending
rubinstein
pected
flg
expense
shifted
nonempty
horizon
probabilities
minf
recourse
ux
lowing
mbyte
measure
deleting
qn
german
behaviour
dierence
determining
dirac
announced
balls
stability
disregard
summands
programming
un
accurate
fk
gorithms
conrms
management
gures
prices
summand
deeply
variant
seconds
closest
opposite
turns
ecient
endowed
kl
regularly
battery
ki
reducing
tests
kg
reformulated
continuous
exhibiting
lagrangian
fol
arg
conguration
modication
selecting
finitely
concept
von
formulated
cf
formulas
quotient
duality
pessimistic
interpretation
atoms
ll
preferable
successors
hardly
closer
stable
tables
ects
propositions
dening
entering
fc
backward reduction
scenario tree
forward selection
fast forward
simultaneous backward
scenario reduction
stochastic programming
index set
n scenarios
ternary scenario
heitsch romisch
rel c
reduction algorithms
scenario sets
probability measure
set j
redistribution rule
c time
scenario trees
time rel
binary scenario
load scenario
regular binary
probability measures
c c
load process
reduced probability
probability metric
tree reduction
stochastic programs
n n
d j
running times
minimal distance
numerical experience
relative accuracy
proposition 3
r r
measure p
function c
simultaneous fast
distance scenarios
fast lower
bound distance
convex stochastic
minimal distances
rule 10
sets backward
forward bound
weekly electrical
power management
lower minimal
management model
regular ternary
number backward
electrical load
metric c
fortet mourier
xed cardinality
load tree
scenarios rel
containing n
algorithm 2
level k
tree number
measure q
original scenario
backward forward
c distance
maximum norm
minimal n
jr j
optimal reduction
r jr
branching points
initial probability
problem 11
z 1
numerical tests
computational complexity
called backward
remaining scenarios
scenarios hence
scenario generation
reduction concept
next scenario
mean shifted
optimal deletion
reduced measure
corresponding mean
non branching
fn n
considering subsets
test trees
backward type
deleted scenarios
supp p
reduced trees
reduced tree
reduction heitsch
tree 50050024
ng z
conceptual algorithm
unit mass
selection works
formula 14
reduced subtrees
optimal redistribution
shifted tree
reduced measures
fu un
reduction load
example 4
time table
running time
set fu
n holds
form min
integer program
fast forward selection
simultaneous backward reduction
scenario reduction algorithms
algorithms in stochastic
rel c time
index set j
ternary scenario tree
c time rel
binary scenario tree
time rel c
reduction of scenario
c c c
load scenario tree
r r r
scenario tree reduction
n 2 n
exists an index
scenario tree number
lower minimal n
simultaneous fast lower
fast lower minimal
weekly electrical load
binary and ternary
case that j
tree number backward
n of scenario
redistribution rule 10
r jr j
scenarios rel c
backward of simultaneous
c time table
electrical load process
forward bound distance
distance scenarios rel
containing n 2
sets backward forward
power management model
scenario sets backward
algorithm 2 4
bound distance scenarios
backward forward bound
theorem 2 1
proposition 3 1
algorithm 2 2
probability measure p
proposition 3 2
discrete probability measure
scenario tree representing
dened in 11
tree and reduced
illustrates a detail
minimum is attained
step i requires
using formula 14
u i satises
backward reduction load
n 1 redistribution
representing the weekly
subset containing n
set fu un
regular ternary scenario
d min n
optimal reduction concept
subtree t r
fu un g
higher running times
operations for determining
load tree 50050024
conceptual algorithm called
reducing a set
mean shifted tree
slightly more accurate
redistribution by 10
consider the probability
non branching points
index set fu
operations for selecting
holds that z
called forward selection
ng z 1
j having cardinality
reduced probability measures
case too 2
subsets of j
tree 50050024 48
reduced by deleting
reduction heitsch romisch
called backward reduction
corresponding mean shifted
reduction and fast
optimal redistribution rule
scenario tree 0
z i step

corpus/krapavin2000-test/627971.txt
video
retrieval
color
texture
image
visual
images
shot
multimedia
indexing
captions
shots
content
recognition
scenes
shape
segmentation
colors
spatial
videos
query
scene
features
retrieve
informix
wordnet
blue
querying
histogram
frames
text
dct
rgb
skin
extenders
semcog
blades
virage
aty
visualseek
excalibur
pixels
regions
similarity
compressed
motion
histograms
mpeg
descriptions
object
media
database
annotations
transform
web
http
queries
textures
attributes
human
detection
automatic
www
green
jacob
layout
relationships
hsi
srihari
souza
cypress
photobook
cveps
rohini
webseer
retrievalware
relational
person
shapes
tv
yellow
brain
trees
objects
face
red
rectangles
sand
zooming
tumors
blade
traina
gif
caption
intensity
digital
pixel
fabric
canvas
databases
browsing
fourier
dimensionality
keywords
ocr
dictionary
compression
extracted
feature
detect
episodes
qbic
clips
iconic
demand
commercial
dimensions
com
users
yahoo
camera
temporal
institutions
border
fractal
news
preprocessed
facial
retrieving
anchor
streams
specifies
hierarchy
registration
spectra
storage
illumination
beach
date
manually
bounding
xml
world
multidimensional
moments
movements
detector
placement
signature
detected
challenges
consequent
fields
sketch
pyramid
modal
tracking
structural
url
people
recorded
wavelet
perceived
semantic
varlamis
ruofei
commercials
iraklis
lamarque
isurf
killer
vazirgiannis
dublin
gisele
vectorial
loong
image retrieval
visual features
video retrieval
retrieve images
based image
example retrieve
content based
video indexing
motion vectors
shot change
spatial relationships
closed captions
texture elements
visual content
shape retrieval
non visual
wide web
world wide
retrieval system
color regions
structured descriptions
placement rules
data blades
shot changes
object recognition
based retrieval
user specifies
human face
compressed domain
retrieving images
r trees
feature based
http www
images based
multimedia database
object detection
user defined
retrieval systems
database systems
local features
bounding rectangles
minimum bounding
multimedia data
relational database
feature query
data blade
feature layout
defined attributes
content modeling
key term
detect objects
term dictionary
significant colors
compressed video
camera operations
texture regions
people michael
shape moments
automatic feature
sample multimedia
full motion
video segmentation
consequent frames
text recognition
motion video
localized feature
shots scenes
detect shot
video extenders
dct transform
modeling indexing
descriptions may
significant color
relevant images
sketch retrieval
efficient image
media type
texture element
semcog system
histogram comparison
color j
features play
texture window
system lchh97
color texture
demand system
shape color
visual retrievalware
images similarity
n dimensional
text retrieval
semi automatic
web based
color histograms
commercial systems
color indexing
date time
pyramid technique
automatic video
media streams
content analysis
may describe
brain tumors
retrieval methods
image video
transform coefficients
specify properties
image may
visual query
involving one
level concepts
imaging systems
example retrieve images
image and video
based image retrieval
indexing and retrieval
non visual features
texture and shape
query the user
world wide web
systems for image
multimedia on demand
video retrieval systems
color and texture
images and videos
techniques and systems
objects of interest
quality of service
minimum bounding rectangles
content based image
based on user
used to detect
feature based object
change is detected
dct transform coefficients
model based segmentation
efficient image retrieval
content modeling indexing
key term dictionary
colors in order
available for certain
full motion video
images and video
significant color regions
images which contain
user defined attributes
buffering and disk
dimensions are independent
similarity based retrieval
texture and color
video as well
scenes and episodes
locations are recorded
semcog system lchh97
dictionary is built
contents and wordnet
index and retrieve
model of video
left of c
detect shot changes
rohini and srihari
number of dimensions
features for instance
based on color
operators to specify
image retrieval system
detection and recognition
based on visual
multimedia database systems
n dimensional space
based object recognition
video compression standard
detection and tracking
storage and retrieval
analysis is used
number of pixels
relational database systems
engineering v 16

corpus/krapavin2000-test/633558.txt
quantum
alice
bob
qubit
qubits
epr
entanglement
classical
disjointness
buhrman
cleve
communication
joei
bits
protocol
unitary
gates
protocols
circuit
holevo
superdense
coin
yao
wigderson
rank
jii
query
teleportation
podolsky
einstein
grover
jozsa
disj
deutsch
channel
vegas
raz
promise
rosen
jbi
las
ip
hadamard
private
automata
coding
wolf
bounds
send
teleporting
cnot
flip
gate
unlimited
superposition
separations
sends
klauck
tapp
public
ji
separation
bit
parties
elementary
dam
communicated
toss
kremer
nielsen
rounds
amplitudes
deterministic
gavinsky
jxi
kempe
exponential
log
bi
wants
polynomials
omega
jff
discrepancy
exhibited
dmitry
communicate
share
sampling
eq
gaps
black
dense
vlsi
error
strengths
distributional
classically
ronald
transformation
gap
julia
coins
ff
receives
prior
uv
inner
joint
acting
box
applies
message
transform
flips
distributive
circuits
norm
tight
vs
ffl
outputs
phi
measurement
equality
preprint
weaknesses
boolean
thirty
jc
copying
determinism
polynomially
jointly
probability
superoperators
spooky
povms
bitstring
impressively
copier
plitudes
regev
quantummechanical
jyi
gammaly
kerenidis
physicists
iordanis
rodl
separa
gall
shor
brassard
probabilistic
security
parity
logarithm
mechanical
measuring
exact
van
suffice
provably
negates
undetermined
mehlhorn
oded
triumph
qaip
ques
hyer
ambainis
turing
bounded
round
nayak
reversible
stipulates
deltay
variant
compromises
literally
entangled
disposal
outcome
queries
communication complexity
quantum communication
classical communication
bounded error
lower bounds
epr pairs
quantum circuit
classical bits
log rank
epr pair
prior entanglement
quantum protocol
buhrman cleve
q f
rank f
unitary transformation
quantum entanglement
quantum algorithms
quantum computation
d f
error protocols
basis state
n qubits
error quantum
lower bound
classical protocol
quantum query
superdense coding
de wolf
private coin
complexity lower
quantum protocols
complexity quantum
public coin
input x
hadamard transform
quantum information
x y
f x
good lower
n bits
value f
las vegas
yao 53
two qubits
way quantum
zero error
einstein podolsky
ji b
deutsch jozsa
exact protocols
elementary gates
exponential separation
shared epr
error probability
quantum algorithm
suppose alice
f log
r 2
send n
probabilistic communication
non deterministic
query algorithm
bound techniques
query complexity
exponential gap
bob receives
quantum classical
theory quantum
unlimited prior
communication quantum
klauck 34
fast quantum
cleve wigderson
alice applies
dense coding
total f
qubit ff
classical world
share unlimited
exact quantum
bits x
alice receives
joint state
podolsky rosen
finite automata
ff 0
log n
y 2
inner product
total functions
quantum state
quantum complexity
norm 1
m qubit
bob share
transformation u
deterministic communication
quantum computing
right value
quantum automata
query quantum
gamma n
black box
van dam
n bit
omega gamma
m f
log m
small error
compute f
computes f
o 1
quantum communication complexity
alice and bob
classical communication complexity
log rank f
f x y
quantum and classical
value f x
bounded error protocols
complexity lower bounds
communication complexity lower
communication complexity quantum
f log rank
bounded error quantum
bound for disjointness
holevo s theorem
wants to send
lower bound techniques
bounds by polynomials
omega gamma n
x y 2
query quantum algorithm
unlimited prior entanglement
shared epr pairs
share unlimited prior
introduced by yao
protocol for f
good lower bound
einstein podolsky rosen
qubit ff 0
buhrman cleve wigderson
bits to bob
exact quantum protocols
separation of quantum
cleve and wigderson
right value f
n 2 qubits
quantum information theory
want to compute
f o 1
input x 2
d f log
deterministic communication complexity
non deterministic communication
bounds for quantum
input x y
complexity of set
r 2 f
f to denote
y 2 d
power of quantum
buhrman and de
zero error quantum
use q f
private vs common
via a classical
sends the result
quantum and probabilistic
security of quantum
ff 0 j1i
complexity is characterized
quantum mechanical algorithm
mapping ji b
send n bits
information theory quantum
entanglement and communication
deterministic quantum query
protocol we use
first n qubits
quantum complexity theory
bob now applies
vector of amplitudes
rank f o
deutsch jozsa problem
n bit input
maps basis state
epr pair 1
prior epr pairs
communication can sometimes
common random bits
related to distributive
survey the main
applies the unitary
y will generally
bits in communication
complexity quantum entanglement

corpus/krapavin2000-test/637236.txt
lsas
lsa
ospf
routers
router
refresh
traffic
lsar
duplicate
bdr
day
lan
eigrp
dr
lans
enterprise
ios
external
originated
areas
flooding
topology
backbone
lsars
customer
routing
area
configuration
synchronization
border
network
rtrs
flapping
april
hour
refreshes
link
monitoring
leased
triggered
flood
aman
roughan
isp
reachability
spf
lsag
rtr
asbr
bgp
internet
episodes
minutes
connectivity
files
ip
modes
shaikh
adjacencies
duplicated
regularg
dynamics
broadcast
prefixes
imported
advertisements
timer
jittered
flooded
reliable
customers
periodicity
periodic
minute
injected
premise
problematic
ethernet
operational
spectrum
deployed
greenberg
burstiness
hub
series
stability
links
synchronized
instability
saw
matthew
imports
finer
period
revealed
shortest
internal
received
failure
spikes
albert
hop
copies
freqency
flaps
impacting
withdrawing
lsags
clumped
spoke
utes
isett
priority
deployment
summary
cisco
net
site
learns
month
multicast
fig
receives
announcing
donoho
riecke
injects
originates
witnessed
injection
route
receive
remote
soft
yin
center
measurement
connected
monitor
igp
rexford
expiry
lund
fdr
originate
prefix
carsten
rebooted
asymmetries
isis
episode
ton
routes
attached
scalability
basu
learnt
conveyed
reliably
persistent
ffl
localizing
drift
vii
propagate
scope
convergence
jitter
listen
proactive
arose
vendor
protocol
nr
lr
networks
bursts
configurable
send
cycles
failing
election
driving
jennifer
servers
status
physical
negligible
plane
evidence
networking
workload
lsa traffic
change lsas
duplicate lsas
duplicate lsa
refresh lsa
lan 1
area 0
ospf domain
external lsas
enterprise network
lsas originated
lsas per
b pair
day number
refresh lsas
day april
lsas day
lsa l
per day
area 2
pair routers
non backbone
april 2002
change lsa
different routers
link state
configuration files
time series
external changes
data center
failure modes
summary lsas
total duplicate
area 3
ios 11
backbone area
ios 12
router network
router configuration
border routers
lsas received
backbone areas
refresh traffic
network lsas
flooding scope
single router
reachability information
topology graph
ospf monitoring
lan 2
customer site
broadcast network
ospf lsa
area 8
case study
per hour
border router
refresh period
power spectrum
finer time
leased lines
control plane
level flooding
customer premise
become dr
problematic router
lsas triggered
ospf areas
state advertisements
root causes
internal change
internal changes
state database
state refresh
running ios
measurement conference
lsas due
remote areas
ethernet lans
advertisements lsas
lsa propagation
router lsa
lsas change
ospf topology
series analysis
net work
two routers
routers running
soft state
total change
router r
aman shaikh
lower graph
graph shows
matthew roughan
network wide
topology changes
upper graph
case 4
ip networks
internet measurement
lsas duplicate
reliable flooding
ospf networks
total lsas
large enterprise
router lsas
two lans
router g
force case
customer reachability
duplicate lsa traffic
refresh lsa traffic
number of lsas
day april 2002
per day april
lsas day number
b pair routers
lsas in area
lsas per day
change lsa traffic
total duplicate lsas
dr and bdr
april 2002 refresh
change and duplicate
number of change
non backbone areas
bdr on lan
number of duplicate
time series analysis
change lsas due
total change lsas
cycles per hour
link state advertisements
day in april
area 2 total
lsas change lsas
level flooding scope
originated by lan2
class of lsas
refresh lsas change
rate of refresh
router network lsas
link state database
soft state refresh
state advertisements lsas
copies of lsa
internet measurement conference
finer time scale
router configuration files
number of external
routers are connected
number of routers
customer reachability information
area level flooding
significant duplicate lsa
internal change lsas
predict the rate
number of router
suggested that lsa
external change lsas
set of lsas
dr or bdr
april 2002 total
applications and databases
change lsas duplicate
lsas the class
routers running ios
running ios 12
customers are connected
duplicate lsas received
non backbone area
lsa to lsar
lsas are flooded
lsa traffic seen
area 0 router
partial failure modes
upper graph shows
shortest path tree
shows the number
injected into ospf
provides highly available
refresh lsas actual
play on lan
day the lower

corpus/krapavin2000-test/627767.txt
trie
agrep
sistrings
text
string
subtrie
dp
character
dictionary
edit
enface
characters
ukkonen
rantee
sublinear
strings
spelling
mismatches
sistring
enfold
texts
searches
searching
suffix
approximate
substrings
pm
subtries
kleen
ech
sigmaj
match
cutoff
prefix
word
tries
enf
insertions
phonetic
soundex
editdist
matching
checkers
secondary
ram
baeza
compression
echo
keywords
patricia
levenshtein
exsample
damerau
dfsearch
search
column
disallow
yates
matches
substitutions
postal
regular
else
deletions
codes
storage
entries
letter
truly
star
evaluates
errors
file
pattern
kn
preproc
adfd
abbbc
rienode
abbc
subt
sattler
typographic
childnode
saake
eike
gunter
rie
schallehn
unix
ga
ab
index
telephone
depth
license
morrison
pointerless
sane
letters
searched
uwe
wildcard
stop
substitution
allowable
insensitivity
lawler
sigma
retrieved
english
ij
exact
target
standards
suffixes
transpositions
boyer
document
storing
pages
distances
costs
alphabet
insensitive
ld
digit
dna
preprocess
bs
evaluating
anchor
kai
symbol
deletion
transposition
blank
digits
correction
mistakes
abc
pat
borrowed
columns
pointers
sample
ce
prefixes
moore
ref
traverse
scans
five
insertion
tells
sa
expression
counters
elapsed
transpose
leaf
walk
sought
inverted
correcting
bits
checker
keyboard
snet
perlberg
fho
garantee
cac
gollapudi
panigrahy
merrett
musical
sinary
aeiou
anode
lambdap
trondheim
workable
acdfbdf
bbc
rieroot
acdfb
shakespeare
matchsimile
trie search
regular expression
approximate string
dp table
approximate match
exact match
string matching
trie methods
spelling checkers
secondary storage
approximate search
j sigmaj
sample enface
trie structure
kleen star
truly sublinear
index trie
else else
search time
o m
w j
expression matching
k approximate
dictionary trie
trie algorithm
trie method
sigmaj k
enfold sample
search path
dictionary search
search algorithm
approximate searches
baeza yates
target string
pattern string
edit operations
text searching
o n
d pm
d p
o kn
echo enfold
agrep 28
large texts
suffix rantee
approximate trie
approximate regular
five texts
pm w
full regular
trie based
match algorithms
ga rantee
postal codes
english words
depth first
o k
log n
table entries
text size
row c
k mismatches
ram size
target word
string search
regular expressions
string searching
file names
suffix tree
edit distance
ab c
get c
c j
alphabet sigma
third column
best match
kn o
checkers case
since agrep
anchor symbol
stop evaluation
text w
ample x
entries ukkonen
limited approximate
soundex codes
ld ample
allowable characters
evaluate one
retrieved character
agrep scans
uwe sattler
let function
c ce
entry value
word say
levenshtein dp
space ref
time extra
editdist j
sublinear expected
text searches
ukkonen 24
many subtries
pattern character
morrison 19
patricia trie
damerau levenshtein
dictionary searches
unix standards
two letters
approximate string matching
enface same example
regular expression matching
enfold sample enface
j sigmaj k
trie search algorithm
ukkonen s algorithm
w 2 w
w j 1
k j sigmaj
k approximate string
o k j
d pm w
echo enfold sample
w 1 w
exact and approximate
m log n
o m log
approximate regular expression
insensitivity and limited
approximate search algorithm
o kn o
matching and k
means that target
retrieved character find
c ce ld
pattern ab c
sigmaj k expected
find a target
deleted for free
target string w
column to get
stop the evaluation
exact match algorithms
text w n
string being sought
sattler gunter saake
level the retrieved
sublinear expected time
trie in figure
k approximate match
max of integer
run preproc time
array 0 max
string matching solve
checkers case insensitivity
string searching algorithms
borrowed from unix
target word output
uses two bits
one place wildcard
bits per node
case run preproc
full regular expression
either 1 3
need to walk
subt rie c
time extra space
trie depth first
return if editdist
time is independent
damerau levenshtein dp
searches we set
uwe sattler gunter
schallehn kai uwe
pattern character p
kai uwe sattler
j 1 return
node do retrieve
eike schallehn kai
since the largest
largest entry value
extra space ref
approximate trie search
ld ample x
limited approximate regular
trie based method

corpus/krapavin2000-test/631019.txt
reliability
ultrareliable
coincident
ultrareliability
failure
independence
growth
hour
life
software
bug
knight
testing
bugs
quantification
fault
specimens
specimen
mission
region
hamlet
leveson
tolerance
critical
moderate
extrapolation
binomial
sys
errors
versions
dick
loglinear
replacement
years
rate
failures
hours
tolerant
safety
accelerated
littlewood
inputs
credible
morzenti
sigsoft
hardware
fi
ff
experimentation
interaction
amounts
morasca
subjected
infeasible
secs
intercept
phyllis
replicates
device
statistical
digital
probability
flaws
multiversion
engineering
theta
frankl
teams
dependability
kth
angelo
experimenter
wasserman
criticisms
shepard
inescapable
liability
keiller
amey
zeil
fail
manifest
sigada
nagel
missions
roderick
miller
annals
quantifying
protect
john
slow
subjective
discovered
electrically
voter
bev
kt
nuclear
terry
sandro
hal
debate
notes
duration
sample
experimentally
validation
portland
feasible
fails
exponential
voted
strigini
calculated
xiang
pietro
chi
predict
enables
maine
chapman
physical
erroneous
slope
establishing
verification
shanghai
lorenzo
echo
tempting
stochastic
reliable
program
hypothesis
aaron
probabilities
justified
industrial
meaningless
blum
null
removed
tester
establish
black
experiment
rates
rejecting
ada
danger
redundant
programmed
yin
inevitably
repetitive
unreasonable
outputs
failed
mitchell
removal
arrival
manuel
estimates
error
supplies
enormous
computers
china
box
reply
axiom
toronto
reformulation
extremely
ultra
brian
gammafineither
interfailure
credibility
diane
rkt
farokh
reliability growth
software reliability
per input
ultrareliable region
life critical
coincident error
failure rate
theta 10
test time
p sys
growth model
software fault
coincident errors
expected test
software engineering
moderate reliability
sample rate
growth models
life testing
interaction terms
independence assumption
tolerant software
fault tolerance
replacement case
test specimens
system failure
rate per
expected time
feasible amounts
last bug
fail independently
system reliability
c knight
software failure
fi errors
ultrareliable systems
accelerated testing
ultrareliable software
independence model
fi error
reliability region
john c
critical applications
dick hamlet
fault tolerant
test duration
reliability models
kth execution
binomial process
physical failures
digital computers
low reliability
hour mission
versions fail
critical systems
testing process
real time
failure times
critical region
software bugs
engineering p
acm sigsoft
safety critical
reliability system
program a1
bugs removed
n version
exponential process
reliability software
design flaws
y intercept
slow system
next bug
ultrareliability quantification
test specimen
programming teams
non replacement
separate programming
multi version
failure process
subjective arguments
ultrareliable system
within feasible
known functions
replicates n
error rate
null hypothesis
formal methods
different versions
time per
years 1
critical software
terms must
low sample
failure per
notes v
sigsoft software
engineering notes
equation 10
failure rates
key assumption
mission time
reliability modeling
chi square
system fails
reliability model
software fault tolerance
probability of failure
time on test
reliability growth models
failure rate per
fault tolerant software
rate per input
reliability growth model
life critical applications
john c knight
tolerant software reliability
time per input
expected test time
theta 10 gamma15
coincident error rate
conference on software
expected test duration
amounts of testing
case is r
moderate reliability region
time to failure
low to moderate
software engineering p
r and n
amounts of time
number of test
software engineering v
ff and fi
order of 10
failure of 10
within feasible amounts
software reliability modeling
number of bugs
failure per input
remove the last
low reliability system
non replacement case
sys is small
matter of life
time execution time
terms are small
used in life
low sample rate
software engineering notes
engineering notes v
acm sigsoft software
sigsoft software engineering
real time execution
low or moderate
probability of system
must be shown
use of digital
system under test
sequence of inputs
annals of software
transactions on software
software engineering may
theta 10 gamma8
fails a new
failure rates per
probability of accepting
finished when r
intercept last bug
tester chooses values
smaller the statistical
program slope y
quantification of ultrareliability
hardware physical failures
programs in reference

corpus/krapavin2000-test/608041.txt
commerce
servers
sites
server
tailed
traffic
site
heavy
burstiness
front
web
utilization
arrival
response
business
load
bursty
secs
av
workload
requests
hurst
transfer
file
request
day
periods
ssl
logs
secure
collected
services
estimator
plot
arriving
disk
buying
weekday
corporations
self
disks
database
ldap
sec
attributed
security
processor
characterization
catalog
sustained
queue
consumer
speculation
firewall
morning
sizes
back
period
aggregated
night
llcd
balancer
businesses
busy
nature
scalability
configuration
nda
population
similarity
evening
customer
observed
series
users
till
burst
bucket
internet
fic
normal
service
traf
bytes
loader
powered
billion
microsoft
activity
clients
peak
studies
files
bursts
req
aggregating
inspection
image
customized
stationary
buckets
tests
serve
encryption
office
granularity
planning
estimating
environment
scales
queuing
estimated
rate
characteristics
perceived
wavelet
serving
refutes
arby
reqs
lrd
complying
accruing
https
diurnal
unmistakable
portal
httpd
throttle
titchkosky
delphi
balancers
propelled
arlitt
characetrization
extent
impact
popularity
simplified
workloads
industry
valuable
regularity
availability
db
visual
representative
sensitive
lance
revenues
veitch
selling
amazon
immense
smtp
seasonal
williamson
netscape
shopping
divulge
oltp
vironments
speculated
conducts
reluctant
figures
hours
cumulative
implications
proportion
socket
stationarity
e commerce
back end
end servers
heavy tailed
front end
commerce sites
response time
h parameter
response times
arrival process
tailed behavior
end server
transfer sizes
web servers
file sizes
end web
processor utilization
commerce environment
database servers
plot test
response file
commerce traffic
commerce servers
secs figure
load periods
response size
web environment
commerce site
web server
queue length
self similar
hurst parameter
main d
av estimator
arrival traffic
time series
self similarity
size distribution
web traffic
traffic arriving
transfer times
consumer b2c
general web
request size
catalog server
b server
workload characterization
database server
arrival rate
series obtained
tailed distribution
disk utilization
times observed
normal web
business b2b
ldap server
high burstiness
sites serve
entire day
simplified configuration
image servers
hard disks
observation period
sec time
access logs
commerce server
utilization time
different load
main database
user population
load conditions
hard disk
two sites
capacity planning
service time
heavy traffic
d b
visual inspection
high load
back end servers
e commerce sites
heavy tailed behavior
front end web
r s plot
front end server
e commerce environment
response file sizes
e commerce traffic
e commerce servers
e commerce site
front end servers
main d b
degree of self
request and response
data was collected
back end server
business to consumer
end web servers
d b server
business to business
tailed in nature
end web server
follow a heavy
heavy tailed distribution
time series obtained
used for estimating
e commerce server
response times observed
behavior of transfer
request size distribution
using the av
estimating the h
response time distribution
web response times
bursty in nature
site is shown
heavy tailed nature
normal web traffic

corpus/krapavin2000-test/614294.txt
gabor
pca
wavelets
wavelet
texture
kohonen
laser
visualization
neurons
fig
multidimensional
frequency
facial
sylvia
pyramid
color
fourier
training
colors
segmentation
neuron
landmarks
face
shape
multiresolution
principal
scanner
eq
valued
decomposition
feature
image
orientation
transform
figured
pipeline
nostrils
lvq
subspace
features
2d
mouth
eye
centroids
gaussian
evidently
orthonormality
trained
coding
regions
surface
pupils
sine
amplitude
nose
spatial
envelope
imaginary
visualizing
encode
green
cosine
curvature
faces
orthogonal
3d
images
eyes
topological
coefficients
visualize
tip
competitive
supervised
localization
coordinates
onto
map
gross
orthonormal
nonseparable
scanners
filters
frequencies
eigenvectors
shifting
scaling
vectors
encoded
eigenspace
orange
self
clusters
reconstruction
layer
red
graphics
human
resolution
eigen
areas
rotated
convolution
postprocessing
oscillation
markus
covariance
antisymmetric
normalization
volume
plane
brows
cheeks
moustache
diagonalizes
gatti
darmstadt
demarcated
similarities
modulation
dimensionality
signal
scientific
dc
fft
neural
localized
spectral
expansion
products
visual
coordinate
decorrelated
surgery
staadt
illumination
blue
selectivity
eigenvector
depicted
rendering
energy
cylinder
bases
heisenberg
luminance
pink
female
tensor
window
extraction
clustering
filter
radiosity
rgb
reacting
euclidian
morphing
photographs
dure
topology
interpreted
depicts
decompositions
directional
eigenvalues
transforms
proce
grain
rotation
organizing
rendered
rough
respective
cortical
roger
cylindrical
geometric
preservation
around
compact
network
elegantly
superimposing
vision
detection
picture
scaled
reconstruct
width
coherent
pyramids
decompose
reveal
corner
normalized
range data
gabor wavelets
kohonen map
complex valued
gabor function
laser range
data features
gabor functions
r g
training areas
g b
feature vector
texture data
fourier transform
image function
visualization pipeline
topological mapping
without pca
frequency plane
data sets
principal component
component analysis
based visualization
texture information
feature vectors
feature based
m h
x y
gabor decomposition
multidimensional feature
human faces
range images
u v
gabor pyramid
convolution products
competitive layer
g m
self similar
data set
color space
h gross
similar colors
computer graphics
non orthogonal
color information
scalar valued
right eye
multidimensional data
g l
real part
scientific visualization
spatial frequencies
competitive neurons
face features
face data
valued gabor
valued 2d
similar functions
oscillation term
gabor transform
expansion basis
compact coding
signal analysis
2d image
frequency domain
data analysis
volume rendering
inverse fourier
2d gabor
markus h
range information
similar features
feature space
b color
texture analysis
gabor filters
important data
spatial domain
surface point
feature extraction
principal components
local data
encoding scheme
dimensionality reduction
straightforward way
fine grain
c means
initial data
neural network
wavelet transform
data using
r g b
shape and texture
laser range data
sylvia s image
feature based visualization
principal component analysis
m i x
visualization of multidimensional
based visualization pipeline
2d image function
local data features
complex valued 2d
within the training
complex valued gabor
face data base
important data features
g b color
performance of detection
encode and analyze
set of self
multidimensional data sets
around the eyes
m i u
range data using
self similar functions
initial data set
b color space
g x y
markus h gross
inverse fourier transform
functions of different
amplitude and phase
width and length
left and right
depicted in fig
using complex valued
finite energy function
around right eye
function a set
vectors of sylvia
cylindrical coordinate system
convolution products g
using the gabor
diagonalizes the covariance
complex data sets
data using complex
onto the r
fourier transform g
multidimensional feature space
data from human
proposed in 23
topological mapping neural
multidimensional feature vector
affected by specific
valued 2d image
training areas demarcated
raw laser range
products g m
range data sets
methods in particular
according to appendix
scaled and shifted
multidimensional face features
complex valued decomposition
map was trained
way to perfectly
feature vectors g
computer graphics center
vectors g l

corpus/krapavin2000-test/628676.txt
segmentation
hypotheses
motion
image
scene
estimator
residual
dja
estimation
ekf
hypothesis
estimators
regions
robust
occlusion
motions
signal
dt
savings
eq
mdl
velocity
encoding
tracked
breakdown
vision
noise
segmentations
cooperative
outlier
estimates
maps
surface
maxima
occluding
estimate
frame
credit
object
djh
rigid
ds
homogeneous
map
norm
kalman
soccer
layers
discontinuity
dots
recovered
looming
contested
djy
husain
disconnected
estimated
surfaces
transparent
camera
squares
synthetic
contamination
regularization
images
windows
degenerate
region
estimating
populations
ball
chunks
shape
regression
priors
gaussian
transparency
covariance
bayesian
predicted
rotating
continuation
threshold
treue
kervrann
irls
frigui
flickering
trubuil
hichem
arch
llse
layer
representations
minima
measurement
optical
entropy
person
eqs
additive
plate
hypothesize
selection
occluded
feature
rotation
sfm
geman
garden
reweighting
gestalt
andersen
spurious
outliers
thresholding
piecewise
edge
grouped
shannon
field
pixel
body
predictability
plants
leclerc
stage
salient
track
heterogeneous
grouping
overlap
views
intelligence
covers
perceptually
jepson
alain
thin
majority
scenes
perception
error
human
corresponded
discount
deltat
coarsely
perceptual
despite
phenomena
recover
covariances
foreground
plant
complicated
gradient
perfect
features
observers
transparently
sitting
overlapping
fitting
ff
weighting
allan
rolling
feb
likelihood
squared
converge
coherent
sampling
undergoing
maximizes
house
spheres
filter
deviation
accounts
visual
planar
locked
tradition
constituent
deformable
euler
agreed
disjoint
polynomial
boundaries
reconstruction
orientation
fit
processes
cylinder
support maps
residual error
support map
robust estimation
image sequence
edge based
m estimator
hypothesis set
breakdown point
based segmentation
ds dja
description length
initial set
initial hypotheses
encoding savings
feature track
one hypothesis
rigid body
minimum description
initial support
dt dt
error norm
robust estimator
m estimators
selected hypotheses
dja dt
initial hypothesis
m estimation
model complexity
first frame
computer vision
point j
minimal encoding
motion estimate
complicated occlusion
predicted feature
selection stage
estimation framework
soccer ball
update rule
velocity field
motion parameters
multi layer
local maxima
continuation method
support based
estimation process
constant regions
range data
single object
least squares
real object
vision v
djy x
body motion
recovered 3
p djy
overhead term
region grouping
overlapping support
b initial
disconnected regions
image signal
cooperative update
known robust
single support
b final
estimated surface
motion model
two motions
estimation literature
single robust
segmentation model
global velocity
squares estimate
estimation methods
eq 19
basis functions
second order
machine intelligence
outlier points
robust estimators
line process
body motions
multiple estimators
final hypotheses
piecewise polynomial
parameters x
disjoint regions
field models
pattern analysis
image b
parameter space
linear basis
motion segmentation
thin plate
additive gaussian
d model
initial conditions
two hypotheses
feature locations
multiple objects
entire image
recursive structure
length principle
model parameters
intelligence v
relative orientation
order polynomial
set of hypotheses
structure from motion
edge based segmentation
segmentation of image
minimum description length
initial hypothesis set
ds dja dt
represent the segmentation
sequence and b
applied our method
velocity field models
single support map
recovered 3 d
b final hypotheses
p djy x
well known robust
least squares estimate
shows the support
images that contain
rigid body motion
sequence with two
cooperative update rule
using a support
linear basis functions
image b initial
global velocity field
objects or surfaces
computer vision v
analysis and machine
machine intelligence v
transactions on pattern
set of support
l s l
p y x
second order polynomial
rigid body motions
parameters are estimated
description length principle
journal of computer
approach to estimating
thresholding the residual
estimation of k
flickering random dot
majority of points
parameter and support
deciding how many
constant across models
multi layer representations
solutions are degenerate
dt and thus
use of support
least one hypothesis
rule eq 23
error norm given
order polynomial surfaces
using global velocity
segmentation using global
subset of hypotheses
construction of synthetic
segmentation of range
shows the construction
noise free case
maps to represent
estimators to describe
cooperative support update
frame from image
compute a support
robust estimation methods
image into homogeneous
regions of support
transparent flickering random
high order discontinuity

corpus/krapavin2000-test/629154.txt
packets
routing
packet
mesh
transposition
travel
route
destined
permutation
destination
vertically
destinations
odd
processors
processor
row
queues
sorting
east
column
inversion
movement
south
array
west
exchange
optimally
reach
routes
theta
north
distance
horizontally
vertical
rotation
contents
buffer
move
distances
completes
forced
moves
neighbors
neighboring
participates
arrays
bad
moving
uninterrupted
rotations
neighbor
participate
heuristic
delayed
horizontal
queue
instant
opposite
buffers
gap
routed
computers
position
connected
phases
chain
initially
normalized
synchonization
nxn
krizanc
builts
jonathon
antonios
rajasekaran
largeand
tollis
queuesize
brebner
tidswell
procced
symvonis
tsantilas
makedon
located
motion
adjacent
lemma
columns
switched
reaches
kunde
ofparallel
completion
cross
meshes
transmit
submeshes
itis
interconnection
communicate
sup
probabilistic
simulations
valiant
trough
lemmata
positions
wants
enter
leighton
happen
boundary
direction
forces
transpositions
downwards
gamma
directions
experiment
trapped
thetan
normalization
phase
remind
origins
multistage
experimental
generator
constitute
upwards
interrupted
away
got
want
torus
disjoint
art
mimd
area
communicates
pathological
rows
instances
bidirectional
talk
collisions
stays
deterministic
leftmost
comparisons
traced
originated
transfer
novel
hits
random
admit
occupy
generators
originally
queueing
tighter
created
buffering
normalize
decreased
grids
spite
go
chip
exchanged
hundreds
permutations
starts
observe
corner
said
portion
solved
diameter
discarded
summation
moderate
greedy
messages
secondly
nontrivial
ffl
algorithm route
routing steps
even transposition
odd even
routing problem
packet p
packet routing
n mesh
mesh connected
size queues
permutation routing
column destination
transposition method
total distance
routing problems
random routing
n theta
n steps
theta n
permutation problem
permutation packet
compared packets
two packets
n packets
buffer area
o n
one packet
theta 100
performs optimally
row k
constant size
route needs
type h
moves vertically
maximum distance
routing algorithm
opposite directions
time instances
type v
time disjoint
processors algorithm
correct column
bad situation
connected array
moving vertically
routing time
vertical movement
move vertically
n routing
packets want
delayed packets
disjoint phases
steps required
neighboring processors
optimal routing
needs exactly
next step
connected parallel
steps using
first row
exactly 2
second phase
linear array
non optimal
arrays extended
east neighbors
good experimental
experimental behavior
packets reach
moving horizontally
odd even transposition
theta n mesh
n theta n
even transposition method
packet routing problem
permutation routing problem
constant size queues
complete the routing
random routing problems
mesh of processors
permutation packet routing
reach their destinations
want to move
distance a packet
position i j
initially at position
algorithm route needs
completes the routing
n 2 steps
time disjoint phases
destined for position
want to travel
mesh connected array
theta 100 mesh
packet of type
processors algorithm route
exactly 2 packets
n routing steps
j is destined
mesh is called
cross the row
packets that want
forced to occur
chain of processors
o n 2
given an n
order to complete
steps in order
mesh connected parallel
number of routing
order to reach
p i 1
routing problem proof
packet that initially
r routing steps
two time disjoint
arrays extended abstract
type h also
array of 8
steps the row
algorithm that completes
n sup 2
reach their column
routes the packets
forced to move
processor at position
route the packets
problems where non
assume a row
used for sorting
route needs exactly

corpus/krapavin2000-test/626771.txt
reconfigurability
lr
embedding
reconfiguration
ea
reconfigurable
dr
lx
reliability
ft
mft
failed
arrays
redundant
graphs
subgraph
faulty
systolic
family
fault
fi
finitely
pe
dimensional
reliable
lattice
hole
hayes
fr
tolerant
vertical
nodes
ie
node
array
distance
architecture
working
vlsi
subsegments
web
dimension
locally
wsi
webs
orthogonal
wavefront
reconfigure
dynamic
es
adversary
cell
lattices
surrounded
switches
delta
changed
inner
lemma
failures
obstacle
euclidian
gas
isomorphic
tolerance
spare
ith
central
module
image
classes
pile
edges
semiring
subsegment
vertex
gammaj
claim
contracting
impossible
segment
adjacent
reconfigured
border
defects
labeling
dimensions
periodic
sacrificing
projected
loop
hyperplane
architectures
connections
interior
degree
constructions
informed
runtime
resp
maintain
inform
indices
zag
ineqality
triplicating
zig
processors
regarded
polygons
images
contiguous
edge
diagonal
contract
replacing
diogenes
avionics
ffln
connected
polygon
static
middle
replaced
theta
chordal
fabrication
wafer
consecutive
sup
infinite
redundancy
squares
failure
replications
contracted
embedded
regular
tmr
planarity
mapped
connect
generality
triangle
replaces
chooses
defective
stricter
gamma
passing
adaptability
reconfiguring
interprocessor
cells
quadruple
mk
fewest
digraph
pick
neighboring
paths
wires
logn
indexed
halves
struc
corollary
replace
ij
copy
eral
pipelines
replacements
rays
convex
cn
insist
doubly
neighbor
impossibility
repetitions
confined
nth
connection
contradiction
processor
satisfies
repair
horizontally
flight
vertically
column
empty
labelling
dynamic graphs
embedding architecture
application graph
dimensional dynamic
dynamic graph
g n
lr reliable
d dimensional
g r
locally reconfigurable
k nodes
reduced graph
initial embedding
reliability fi
redundant graph
graph g
finitely reconfigurable
local reconfigurability
ft g
dimensional orthogonal
distributed reconfiguration
inner central
n h
n r
working subgraph
constant fi
empty classes
linear arrays
total distance
k n
dr d
orthogonal lattice
working nodes
fi proof
g 0
dr k
fault tolerant
f k
m nodes
reconfiguration algorithm
central class
original working
es g
one dimensional
embedding function
fixed level
static graph
vertical lines
x r
single loop
two dimensional
two nodes
one dimension
k ft
redundant graphs
mft g
lx 0
h ft
node single
ea cannot
dimensional reduced
line lx
orthogonal lattices
ft n
dimensional web
ith application
line along
finite reconfigurability
n node
node x
one node
delta f
n nodes
linear array
vertical line
array processors
fault tolerance
vertex set
d c
lemma 4
distance dr
hayes h
reconfigurability dr
embedding strategy
spare node
vlsi wsi
lines lx
isomorphic subgraph
one greater
satisfies 5
replacing nodes
classes thus
lattice gas
cell dynamic
redundant nodes
dimensional webs
distance cost
infinite graphs
wavefront arrays
working node
obstacle o
dr nodes
empty class
lx 1
set v
given g
d dimensions
v x
fi 2
g n r
dimensional dynamic graphs
reliable with reliability
g 0 c
dimensional dynamic graph
d dimensional dynamic
nodes have failed
family of d
degree of reconfigurability
dr k n
number of nodes
cannot be lr
ft g n
level of reliability
nodes in g
exists a constant
graphs there exists
architecture is lr
reliability fi proof
one dimensional dynamic
family of linear
dimensional orthogonal lattice
distributed reconfiguration algorithm
d k n
hole of size
application graph g
node in c
two dimensional orthogonal
dynamic graph g
inner central class
graph g n
function of k
nodes of g
theorem 4 3
vertex set v
c a d
dimensional reduced graph
reconfigurability and reliability
d dimensional reduced
n h r
h ft n
delta f k
d dimensional web
node single loop
vertical line lx
k ft g
reliability fi 2
non empty classes
g n h
dimensional orthogonal lattices
ith application graph
two dimensional dynamic
dr d k
graph g 0
family of two
g i r
d dimensional orthogonal
set v x
g a g
nodes in one
lemma 3 2
get a new
g j r
reduced graph g
delta t d
static graph g
dynamic graph must
surrounded by non
arrays and g
called dynamic graphs
n m classes
distance between original
given an embedding
d dimensional webs
cell dynamic graph
hayes h ft
empty classes thus
least n m
total distance cost
least one greater
original working subgraph

corpus/krapavin2000-test/1008470.txt
hosts
election
reset
feedback
skip
rounds
round
host
multicast
reply
messages
implosion
elect
bolot
rnd
population
collision
receivers
history
send
transmissions
aggressive
idmaps
undershoot
replies
representatives
tracers
channel
overshoot
polled
entity
elected
electing
estimation
active
maxguess
rfijmg
packets
council
fig
polling
else
tsybakov
bits
message
penalty
dependency
users
init
leader
maxfn
multiplicity
colliding
elections
sends
packet
ma
resolution
protocols
unicast
ternary
conservative
transmitted
joining
robustness
initialization
transmitting
bit
representative
drawings
transmission
measurement
draws
optimum
convergence
converges
regardless
balanced
vi
improvement
video
anonymous
suggest
sent
collided
kazakos
collides
tatives
candi
dershot
astonishingly
pervious
likhanov
plicity
papantoni
pippenger
matias
candidacy
vanroose
ruszink
tire
fijng
rs
target
pseudo
inaccurate
congestion
leaving
received
receives
massey
jargon
georgiadis
lps
silence
tracer
therefor
sidi
reactivation
nificantly
lixia
enyi
responders
members
servers
group
feed
aware
estimating
sender
rom
jjj
popu
erd
rolls
distributively
steep
stayed
azar
elects
confidence
receiver
unknown
successful
spirit
simulations
flat
afek
underestimation
depicts
probability
suggested
drops
big
polls
ues
quarter
pay
net
gain
iv
achieves
payment
poll
overestimation
dates
occurred
synchronous
examined
advertised
formance
framing
decoded
suppression
allocations
coins
balls
central
represen
simulation
knows
skip reset
algorithm skip
n c
expected number
users n
u 8
send reply
send feedback
basic algorithm
n expected
feedback implosion
feedback n
active hosts
election process
one round
n n
feedback message
target range
bolot et
previous round
reset choice
multiple access
c l
collision resolution
c number
population size
c u
ma networks
multicast video
rnd c
multiplicity feedback
feedback 3
received feedback
video distribution
host algorithm
n hosts
implosion problem
estimating n
al btw94
initialization round
l 4
improved algorithm
transmitting entity
successful transmissions
c sends
c 8
init 2
two rounds
c n
n bits
leader election
feedback messages
reply 11
u 10
inaccurate estimation
colliding hosts
assumes hosts
election rounds
multicast feedback
central entity
n dependency
c 13
n 500
balanced allocation
conservative aggressive
avoid feedback
aggressive algorithm
replies fig
distributed leader
maxfn n
p rfijmg
reply 14
confidence simulations
full multiplicity
typical rs
choice algorithm
rounds skip
like multicast
n 5000
feedback bounds
else 12
messages skip
election message
r received
additional round
rounds required
choice history
small number
c 5
l u
messages algorithm
else 7
history 1
round c
hosts may
networks scalable
protocols performance
n maxfn
reset 1
else 15
algorithm skip reset
number of messages
number of rounds
users n expected
n expected number
u 8 c
send feedback n
n c l
number of users
reset with history
bolot et al
number of hosts
c n c
l 1 u
number of replies
algorithm t n
skip reset choice
n c u
n c number
n c 0
less than l
n and n
c 0 2
elect a small
et al btw94
regardless of n
feedback n c
feedback n 1
feedback implosion problem
hosts is known
l 4 u
rnd c n
multicast video distribution
received feedback 3
c 5 6
algorithm that requires
init 2 n
number of active
value of n
performance of algorithm
log n bits
examined a model
round and n
messages for typical
messages and rounds
c u 10
estimation is reduced
l 5 send
messages skip reset
send reply 14
feedback the hosts
host to maintain
send reply 11
skip reset 1
n l 1
number of colliding
reply 11 else
group of hosts
c r received
l 6 send
applications like multicast
around the optimum
distributed leader election
c l 6
model assumes hosts
host algorithm skip
control for multicast
else 7 send
reset with estimating
full multiplicity feedback
r received feedback
access protocols performance
multiple access protocols
c l 5
n c 8
estimation of n
else if 9
anonymous networks scalable
users n l
rounds to elect
n c r
avoid feedback implosion
u 10 send
c g fig
n 0 3
n c 13
rounds skip reset
n n 5000

corpus/krapavin2000-test/637321.txt
residually
morphic
ultimately
kn
periodic
mthhn
buchi
morphism
word
monadic
xp
semigroup
decidable
predicates
predicate
un
elgot
nite
integers
fibonacci
dn
acc
rational
hn
letter
factorized
rabin
innite
alphabet
decidability
siefkes
automaton
xed
automata
dened
sequences
thue
maes
accepted
morphisms
eectively
characteristic
dierence
contraction
dene
suces
ln
fn
dierences
factorial
integer
exponentiation
morse
undecidable
landweber
nal
ng
rst
lemma
innitely
coecients
congruence
eective
unary
lm
proposition
expansions
theories
equivalence
au
fthhn
undecidibility
berstel
wmthhn
blkbd
coecient
factorization
acceptance
corollary
powers
jean
una
grater
ang
binomials
unsettled
fen
letters
mod
recursive
closed
ehrenfeucht
qq
belongs
theoretic
thm
mth
bc
claim
games
fun
primes
nally
induction
product
fk
decision
generalizations
vn
sucient
prime
successful
infinite
jn
prominent
inline
nitely
sequel
concrete
matrix
xn
satises
wn
dimension
veried
proves
belong
embed
reducible
cellular
polynomial
periodicic
sturmian
boasson
bumyampersanduml
schinzel
phic
hosch
allouche
buechi
myampersandlt
utzenberger
desarmenien
petazzoni
lqq
automota
sentence
said
images
icates
schutzenberger
arith
endows
carton
mfcs
ordinals
semigroups
wilke
approachable
suce
grdel
closure
thomas
obviously
strictly
concatenation
matics
cidable
canonically
mathe
metic
presburger
gers
relations
imply
expansion
denitions
kk
dissertation
pictured
cial
complementing
contracted
twin
jacques
ffn
arithmetics
matrices
lim
sch
almeida
jorge
nonterminating
ultimately periodic
residually ultimately
l n
n n0
word x
mthhn p
n rational
k n
n greater
monadic theory
sequence un
two integers
sequence k
problem acc
innite word
characteristic word
morphic predicates
p kn
kn q
nite semigroup
un n0
integer n
predicates p
n q
kn 1
kn l
theory mthhn
buchi automaton
acc xp
integers r
q 00
contraction method
periodic sequences
kn n0
predicate p
sequence u
rational sequence
morphic predicate
class k
k l
integer l
decision problem
hn p
dierence kn
also residually
dn q
integers n
order theory
u n
let un
n l
p l
q l
xed point
acc x
alphabet b
nite word
morphic words
fibonacci predicate
nal state
r 0
lemma 26
sequences k
u k
monadic second
buchi acceptance
eectively computed
ln n0
thue morse
lemma 27
morphism 0
nite words
innite words
dn r
periodic predicates
morphic word
lemma 25
word xp
rabin 11
siefkes 18
xed integers
morse word
factorial predicate
sequence v
let k
matrix representation
n dn
residually ultimately periodic
sequence k n
k n n0
k l n
l n n0
two integers r
p kn q
n t p
elgot and rabin
l n q
greater than r
l n 1
kn t p
problem acc xp
sequence u n
innite word x
kn l n
p l n
theory mthhn p
sequence un n0
u n n0
ultimately periodic sequences
n 1 kn
q l n
kn 1 kn
n and p
also residually ultimately
sequence of dierences
x is accepted
decision problem acc
sequences of integers
k n l
r and q
n l n
dene the morphism
monadic theory mthhn
n rational sequence
periodic by lemma
class of residually
morphic predicate p
relation t p
integer n greater
k t p
two integers n
problem acc x
p to q
path from p
monadic second order
k n 1
sum and product
sequence of integers
class of morphic
thue morse word
sequences k n
dierence kn 1
periodic the following
r t p
q for n
theory of hn
belongs to k
xp and hence
l n dn
periodic the sequence
n is integer
product and exponentiation
ultimately periodic predicates

corpus/krapavin2000-test/606529.txt
letter
lettericity
sigma
quasi
vertices
graphs
subgraphs
subgraph
induced
adjg
obs
vertex
clique
alphabet
unbounded
letters
precedes
forbidden
subword
labelled
nonisomorphic
cochromatic
obstructions
superscripts
threshold
adjacent
word
halflines
halfplanes
toma
cobipartite
symbols
rise
ordered
interval
labels
bipartite
bojan
dm
reflexive
complements
tight
corollary
proposition
cyclically
ding
adjacencies
recognizable
intersection
cycle
minor
cycles
extremal
nonempty
ordering
neighbors
occurrences
label
permitting
finitely
distinguish
transitive
iii
polynomial
ababa
antichains
xly
abcabc
rlg
nonisolated
embeddabil
nonconstructive
matroidal
recognized
assertions
ag
paths
intervals
contiguous
fc
impossible
isomorphism
antichain
pendant
chv
atal
csg
robertson
higman
dichromatic
pisanski
labellings
mohar
arranged
nonnegative
damaschke
gers
kruskal
endpoints
infinite
monoid
bordering
thm
homeomorphic
ab
indices
coincides
isomorphic
seymour
jrj
census
matchings
divisibility
inte
hammer
family
rewrite
cardinality
forces
gammai
ideals
triangulated
resp
characterization
equivalence
iff
lemma
complement
ng
finiteness
ba
restate
neighborhoods
counting
topological
bijection
intervening
rr
homomorphism
reversing
proved
conversely
aa
famous
closure
ff
logarithms
listing
indebted
disjoint
ideal
mod
exceeds
recognition
minimal
algebras
perfect
labelling
helping
union
swapping
rg
fig
arrangement
discarding
reducible
jv
versus
leftmost
characterize
ity
rightmost
block
fg
decidable
relation
adjacency
stable
dn
enumerate
wishes
partition
closed
suffice
linearly
aggregation
undirected
classes
letter graphs
well quasi
k letter
g sigma
letter graph
quasi ordered
induced subgraphs
unbounded interval
induced subgraph
sigma p
n vertex
threshold graphs
independent set
p w
subgraph relation
g p
interval graphs
vertex graphs
n vertices
forbidden induced
quasi order
v g
c n
obs g
g k
quasi ordering
graph g
l g
size three
length 3k
minimal forbidden
g y
different letters
k gamma2
x g
c 3k
nonisomorphic n
vertex graph
three occurrences
n 4c
relation defined
sigma n
cycle k
c 4
h m
polynomial time
l y
l h
intersection graph
p n
l n
w l
n j
w hence
sigma 2
lemma 1
g assume
hence l
b n
finite alphabet
graphs g
p 4
graph minor
distinguish four
exceeds 0
least size
word consisting
lettericity exceeds
rewrite relation
toma z
ordering stable
minor relation
topological minor
th block
letters whose
contiguous subword
vertices 1
graphs unbounded
iii g
fewer vertices
following assertions
g ding
subgraph ideal
word obtained
cochromatic number
p sigma
arranged linearly
n labelled
easier reference
graphs closed
cases w
whose lettericity
alphabet permitting
superscripts distinguish
taking induced
sigma gives
whose letter
threshold graph
versus independent
equivalent ii
k letter graphs
g p w
g sigma p
well quasi ordered
unbounded interval graphs
k a 1
n vertex graphs
k a 2
induced subgraph relation
x g y
forbidden induced subgraphs
well quasi ordering
vertices of g
well quasi order
l h m
pairs of letters
subgraphs and well
minimal forbidden induced
either a clique
check that g
k a 3
graphs on n
obs g sigma
b n 4c
l g assume
graphs is well
n vertex graph
p as x
n 4c letters
k letter graph
recognized in polynomial
lettericity of cycles
nonisomorphic n vertex
w l g
hence l h
set of size
g is denoted
x l y
closed under taking
graph on n
vertices of c
class of k
set of ordered
classes of graphs
easy to check
n is large
graphs on four
however being adjacent
symbols from sigma
graphs from g
distinguish four cases
n the path
sigma n coincides
obs g k
determine the lettericity
superscripts are added
theorem 2 iii
graphs is 2
remains to see
conversely let g
g p z
whose lettericity exceeds
sets versus independent
k different letters
graph is c
precedes a 2
cases w r

corpus/krapavin2000-test/626974.txt
decoupled
ep
caches
cache
ap
uniprocessors
strcpy
latency
saxpy
locality
architectures
slip
instruction
queues
zs
uniprocessor
queue
instructions
deap
processor
eod
memories
memory
execute
astronautics
livermore
interleaved
bandwidth
pipe
sensitivity
benchmarks
convolution
fetch
architecture
insensitivity
unequal
unbalance
llls
noninterleaved
operands
benchmark
traces
lawrence
fetched
cycles
correlation
decoupling
speedup
loops
processors
mips
bottleneck
tokens
access
pipelined
wm
studies
bus
spatial
streams
token
parallelism
computers
temporal
effects
load
string
cray
block
ahead
unrolling
simulation
cycle
fom
uniproc
handcoded
slow
miss
trace
exhibit
significance
simulations
fig
dae
chip
sma
furnishes
contentions
slower
instr
deposited
hide
cached
register
vlsi
limitations
count
deposit
linpack
flushed
bytes
organizations
grain
alleviate
concluded
exhibits
module
calculation
speed
compiler
increments
interleaving
simulators
width
peak
bits
capturing
array
waiting
hides
organization
dec
architectural
delay
benefit
demand
past
bottlenecks
evident
stand
read
microprocessor
ibm
loaded
routine
attained
offs
assembly
strcmp
porpodas
interlocks
heel
unrealistically
tripling
parcerisa
nonpipelined
crago
milidonis
noncached
espasa
alachiotis
whereupon
wulf
furnishing
gaudiot
goutis
sdp
kakarountas
mask
baseline
rs
busy
conduct
accessing
consume
superior
ratio
strong
controller
computations
buffering
achilles
fifos
writeback
decoupled architectures
memory latency
decoupled architecture
execute processor
access processor
memory access
decoupled systems
decoupled system
access time
decoupled computers
latency effects
zs 1
temporal locality
execution time
cache based
spatial locality
data memory
data cache
address calculation
astronautics zs
access execute
without caches
read queue
lawrence livermore
main memory
data caches
memory speed
livermore loops
decoupled access
block size
memory bandwidth
architecture performance
saxpy unequal
cray 1
write queue
instruction streams
memory unit
strong temporal
cache memories
bandwidth requirement
memory module
total bandwidth
slow memory
performed simulations
two processors
performance advantage
larger block
memory cycle
simulation study
total execution
execute architectures
latency sensitivity
structured memory
certain latency
calculation instructions
cached uniprocessors
memory path
eod token
data operands
execute processors
pipelined memory
ep stand
wm architecture
ap instructions
cache organizations
cache decoupled
deap architecture
alone execution
data fetch
ap ep
memory system
data elements
bus width
mips r2000
interleaved memories
limitations associated
single processors
computer program
interleaved memory
single cycle
grain parallelism
instruction caches
simulation results
bandwidth requirements
processor would
access and execute
memory access time
astronautics zs 1
memory latency effects
effects in decoupled
decoupled access execute
lawrence livermore loops
benefit from caches
effects of memory
uniprocessor with cache
ap and ep
performance of decoupled
uniprocessors and decoupled
uniprocessors with caches
cache based systems
decoupled architecture performance
caches and decoupled
strong temporal locality
total execution time
effect of memory
structured memory access
stand alone execution
time the ep
study of decoupled
complete its section
ep stand alone
ahead of demand
fine grain parallelism
associated with caches
sensitivity to memory
memory latency sensitivity
address calculation instructions
access execute architectures
alone execution time
convolution and correlation
reported in 24
beyond a certain
memory cycle time
increase in execution
execute processor would
choice for cpu
instruction buffering techniques
correlation and strcpy
total memory access
also once memory
caches can reduce
data memory unit
uniprocessors without caches
buffering techniques memory
decoupled architectures exhibit
architecture a simulation
different instruction streams
access related instructions
register and cache
zs 1 central
computations the access
limitations of decoupled
offs for microprocessor

corpus/krapavin2000-test/628731.txt
acoustic
scores
speaker
classifiers
recognition
classifier
identification
face
score
speech
voice
eyes
interocular
eye
codebook
training
rejection
hyperbf
codebooks
mouth
person
rank
nose
integration
stranger
correlation
cues
utterance
eqn
visual
normalization
ranks
reject
database
biometric
interactions
image
normalized
utterances
signal
images
misrecog
strangers
tanh
rejected
speakers
subsystems
adaptation
familiar
estimators
integrated
measurement
session
regions
lip
deviation
features
confidence
utter
irst
cepstrum
templates
digitized
multimodal
people
candidates
sessions
quantization
recordings
mel
interacted
digit
oe
accepted
variations
static
outputs
persons
im
vectors
rejecting
illumination
ff
dispersion
vq
matching
accept
couples
interacting
verification
similarity
acquisition
frontal
anil
entries
letters
axis
vision
semispace
grabber
favouring
hampel
brunelli
intraspeaker
misrecognized
troids
hernndez
mfccs
kwat
spectrum
reported
facial
fusion
filter
geometric
acceptance
robust
mapping
threshold
reliable
rankings
spectra
jain
mad
eqns
biometrics
pupils
recognizer
dat
abidi
digits
intensity
hamming
geometrical
frame
symmetry
pixels
distance
waveforms
phonetic
negatives
scribed
independence
bank
scale
distances
interaction
authentication
text
psi
gaussian
finger
transitional
recog
unimodal
bivariate
cen
samples
thereby
audio
ij
sounds
noise
lying
plane
evaluated
ross
estimate
hybrid
fs
spectral
match
adapted
sigmoidal
acquired
energy
reference
distributions
weighted
normalize
median
ro
luis
arun
perceptron
lighting
fig
stochastic
security
delta
location
separation
channel
users
centroids
gang
template
face recognition
speaker recognition
measurement level
identification system
recognition systems
acoustic features
linear classifier
integrated score
normalized scores
hyperbf network
eyes nose
geometric average
multiple classifier
reference database
interocular distance
best candidates
total error
correlation values
familiar rejected
person identification
recognition system
accept reject
multiple classifiers
recognition letters
stranger accepted
speech signal
rank measurement
real interactions
background noise
familiar misrecog
adaptation vectors
weighted geometric
user face
multiple cues
reject rule
best candidate
system performance
pattern recognition
features used
interval 0
single feature
database entries
vector quantization
letters v
input signal
reported experiments
visual features
rank correlation
right eye
standard deviation
text independent
hybrid rank
second final
acquisition channel
test sessions
normalized ratio
dynamic codebooks
corresponding ranks
level integration
identification systems
digitized image
score list
score distributions
utterance length
corresponding regions
stochastic minimization
matching scores
verification system
speaker verification
first ten
final best
rank information
acoustic analysis
integration module
hamming window
eye templates
energy outputs
negative examples
training vectors
person recognition
different classifiers
error measure
non acceptable
symmetry axis
leave one
system based
processing v
power spectrum
correlation value
integrated system
second best
points lying
different features
learning task
acoustic and visual
nose and mouth
face recognition systems
speaker and face
pattern recognition letters
recognition letters v
weighted geometric average
rank measurement level
location and scale
using an hyperbf
accept reject rule
interval 0 1
reported in figure
level the output
hybrid rank measurement
list of scores
identification system based
y t n
face and voice
based on vector
second final best
final best candidates
set of classifiers
static and dynamic
training and test
reported in table
average and standard
static or dynamic
n 16 p
using a weighted
number of people
performance is evaluated
set of examples
use of multiple
signal processing v
recognition sub system
visual ones provide
recognition system based
integration of multiple
defined in eqn
robust statistical techniques
speaker recognition system
functions classifiers pattern
rejecting a user
template matching process
accepted or rejected
based on acoustic
turn for testing
user as unknown
best integrated score
two best scores
rank information derived
person identification using
lists of scores

corpus/krapavin2000-test/627005.txt
dbmin
buffers
mg
allocation
buffer
looping
marginal
adaptable
tp
references
mix
throughput
queries
disk
faults
ref
edu
reference
query
page
ud
policy
predictors
admission
yao
allocate
pages
utilization
allocations
waiting
gains
mini
mru
mixes
gain
policies
throughputs
queueing
predictor
allocated
pessimistic
load
noh
chou
queue
jobs
manager
flexible
yookun
jongmoo
dewitt
loads
cho
replacement
allocating
lyul
activate
accesses
sequential
td
loop
sharing
sang
optimistic
concurrent
management
database
choi
cpu
availability
tc
kim
clustered
simulation
runtime
admitted
pool
workload
avoidable
random
comparably
predictive
instantaneous
pass
sam
relational
min
flexibly
formulas
hot
accessed
pf
activated
lru
selectivity
idle
locality
resident
fluctuation
allocates
beneficial
harmonic
msec
switching
hits
effective
symbols
multiprogramming
cur
opt
inflexibility
fluctuate
weakness
predictions
extra
wasted
ef
degenerates
package
estimate
join
ingres
benefited
demand
effectiveness
patterns
workloads
recurrence
exceeds
activating
adopting
summarizes
cornell
adaptability
chong
referenced
head
exhibited
fewest
cf
activation
pp
jong
unified
cycle
job
gamma
cycles
decisions
sub
response
utility
usenix
sigmetrics
averages
situations
diversity
quantification
usable
simulations
portion
kept
scan
transaction
milliseconds
opearting
schkolnick
ecomonics
junho
hun
oblivion
ssequential
fcfs
asad
donghee
luxury
admissions
mg x
buffer allocation
marginal gain
mg 50
random reference
gain values
random references
marginal gains
looping reference
page faults
allocation algorithms
looping references
concurrent queries
mg 100
adaptable algorithms
tp o
disk utilization
load control
x y
data sharing
waiting queue
sequential reference
optimal allocation
yao estimate
available buffers
y algorithms
buffer management
o edu
flexible buffer
adaptable buffer
many buffers
allocation policy
admission policy
effective disk
queueing model
clustered index
edu o
dbmin mg
buffer manager
local replacement
waiting time
allocation policies
edu 2
allocated buffers
extra buffers
buffer utilization
simulation results
locality set
h noh
mini cycle
buffer pool
d e
relative throughput
sub optimal
relational database
expected number
two predictors
query mixes
yookun cho
mini cycles
reference l
noh sang
gain value
queries r
reference ref
total marginal
jongmoo choi
sam h
optimal allocations
k n
access patterns
disk load
sang lyul
f faults
r 30
lyul min
non clustered
hot set
length k
allocation algorithm
query type
c d
f k
predictors tp
b yao
mix 4
buffers assigned
e mg
may allocate
mix 1
page hits
utilization ud
sequential references
dynamic workload
min yookun
adaptable allocation
disk loads
resident pages
total buffers
state f
b c
query mix
class model
l k
mg x y
number of buffers
marginal gain values
buffer allocation algorithms
effective disk utilization
mix of queries
adaptable buffer allocation
flexible buffer allocation
number of page
e a b
x y algorithms
number of concurrent
availability of buffers
c d e
mg 100 1
buffers at runtime
based on marginal
notion of marginal
mg 50 12
tp and edu
tp o edu
r k n
b c d
patterns of queries
o edu o
sam h noh
concurrent queries r
throughputs of dbmin
non clustered index
noh sang lyul
buffer allocation algorithm
chou and dewitt
h noh sang
looping reference l
marginal gain value
reference l k
sub optimal allocation
mg 50 y
number of available
sang lyul min
formulas for computing
simulation results show
mg 50 18
lyul min yookun
allocation algorithms based
adaptable allocation algorithms
dbmin mg x
state f k
min yookun cho
allocations to looping
disk utilization ud
sub optimal allocations
types of references
queries of type
x and y
number of pages
performance of mg
allocating extra buffers
relation of size
reference of length
shown as path
algorithms mg x
come first serve
compared with dbmin
local replacement policies
buffers are available
faults in k
total marginal gain
o edu 2
portion of avoidable
x y scheme
edu o edu
relative throughput mix
choi sam h
adaptable algorithms running
y becomes 15

corpus/krapavin2000-test/627029.txt
arf
inspector
exchanger
array
processor
dereference
executor
parti
irregular
hashed
translation
fortran
compiler
yold
hash
mesh
processors
arrays
primitives
gather
scheduler
fluxroe
loop
irregularly
schedule
unstructured
references
meshes
ia
scatter
accumulations
indices
ipsc
runtime
exchangers
subscript
ib
template
strips
cache
nmsgs
flux
kernels
sparse
carry
preprocessing
align
fluxes
jagged
partitioned
loops
kernel
multiply
partition
optimizations
sd
synthetic
dino
partitioning
cols
block
exchange
striped
send
la
euler
blocked
irreg
ms
calls
decomposition
proc
compile
accesses
receive
sweep
costs
strip
efficiencies
nonlocal
vb
tables
map
procedures
codes
assignments
copies
dissection
dereferencing
compilers
baden
aerodynamic
hpff
nprocs
ncols
executors
iterations
pa
endif
solver
accessed
targeting
temp
statements
ffl
communications
index
gagan
lux
statement
descriptors
messages
carried
parallelized
initialization
coded
numbered
setup
carries
ranged
intel
accumulation
referenced
descriptor
va
multigrid
reference
accumulate
foreach
blocks
indirect
multiprocessors
interprocessor
supercomputing
id
extensions
ttable
iva
inspectors
ivb
gflops
iiia
gammapartition
stodghill
ivc
icase
gammaprocessor
ivd
stored
locations
fetches
nasa
contiguous
temporary
gathered
clause
mapping
matrix
dimension
dependencies
whitaker
kali
dereferences
iib
oak
indirections
pingali
cdrom
reg
count
primitive
williams
owner
communication
compiling
pointer
nest
subtract
accumulates
memory
agrawal
iia
idiom
riemann
translation table
distributed array
hashed cache
arf compiler
distributed translation
hash table
gather exchanger
array elements
local array
fortran d
array references
ipsc 860
point template
local indices
distributed arrays
table h
vector multiply
irregularly distributed
distributed memory
global indices
parti primitives
block matrix
data exchange
matrix vector
fluxroe kernel
sparse block
build translation
local index
using schedule
distributed irregular
processor data
non local
loop iterations
unstructured meshes
processor p
translation tables
executor time
language extensions
synthetic mesh
array element
time required
processor assignments
arrays x
scatter exchanger
template synthetic
irregular using
mesh partitioned
array y
table initialization
executor phase
irregular array
parti procedures
processor distributed
time ms
processor elements
n proc
k n1
array partition
inspector phase
d block
blocked translation
count p
exchanger using
cross processor
mapping array
setup hashed
runtime support
hash tables
receive calls
processor references
compile time
ms time
time primitives
processor map
k n2
unstructured euler
arrays ia
table hashed
find processor
yold k
array map
processor loop
multiply kernel
binary dissection
align x
call dereference
call gather
euler solver
exchange primitives
cache hashed
insert code
h n1
synthetic meshes
local data
figure 13
loop l
processors p
ffl generate
irregular patterns
single sweep
match match
edge partition
irregular problems
call setup
d blocks
statements s1
support irregular
array reference
mesh b
distributed array elements
distributed translation table
hash table h
matrix vector multiply
block matrix vector
build translation table
sparse block matrix
required to carry
processor and local
processor distributed array
send and receive
distributed translation tables
template synthetic mesh
point template synthetic
q 0 4
distributed irregular using
ia and ib
synthetic mesh partitioned
irregularly distributed arrays
setup hashed cache
exchanger using schedule
distributed array references
translation table initialization
distributed array element
inspector and executor
non local data
vector multiply kernel
call setup hashed
hashed cache hashed
table h n1
data exchange primitives
align x y
elements of yold
ms time ms
cross processor loop
run time primitives
processors p 3
time ms time
array a 0
blocked translation table
table hashed cache
irregular array references
hash table hashed
partitioned into strips
call gather exchanger
generated from arf
sparse matrix vector
fortran d language
initialization and dereference
p then else
k 1 4
loop carried dependencies
data from needs
hashed gamma cache
parti run time
call to dereference
finite difference template
intel ipsc 860
y k n1
data in hash
generate the inspector
distributed array y
p 3 figure
local index assignments
flux 1 4
call scheduler id
orthogonal binary dissection
exchanger is generated
dereference to find
local indices la
find processor assignments
gather exchanger places
map array using
gather exchanger using
patterns of distributed
processor assignments pa
using a mapping
id n hashed
scheduler id n
partitioned between processors
schedule s n1
partitioned into 2
values of map
support irregular patterns
translation table using
f lux k
block sparse matrix
loop to ffl
scheduler and data
data and computational
irregularly distributed array

corpus/krapavin2000-test/635468.txt
iho
wrapping
ivps
odes
lohner
stepsize
taylor
enclosure
eect
qr
eigenvalues
interval
coe
obreschko
pts
enclosures
hermite
validated
cients
truncation
factorization
arithmetic
intervals
stability
ivp
box
advancing
overestimations
rigorous
series
instability
ordinary
nonsingular
corrector
enclosing
moore
sti
ode
rotated
stable
enclose
overestimation
enclosed
matrices
di
nding
uniqueness
dened
eigenvalue
berz
makino
nonautonomous
lim
widths
diagonal
jr
bigger
cient
wrapped
tight
tend
error
jt
validating
triangular
parallelepiped
signicantly
jacobian
ty
unstable
nn
lth
tighter
eective
formula
perspective
midpoint
distributive
law
magnitudes
veri
reducing
bounds
advances
numerical
xed
newton
preprint
priori
asymptotically
nd
expansions
ith
formulas
exible
ax
matrix
predictor
propagates
expositional
hidde
stepsizes
eigenraam
zonotopes
eijgenraam
rihm
tadiff
mag
kruckeberg
fadbad
obreschkoff
pade
parallelepipeds
dierenti
nitudes
roundings
subdistributive
unshifted
ranges
width
conjugate
inclusion
propagating
picard
moduli
kw
diagonalized
lindelof
outwards
dissipative
jacobians
orthogonal
sides
culty
ample
principal
vectors
outline
round
ir
nota
unacceptably
dierentiating
pth
differential
validate
autonomous
propagated
ellipsoids
orbits
oscillates
veries
ab
interpreted
normally
phases
showed
jhj
banach
guaranteed
dierent
validates
scalars
quotients
existence
suer
outward
parabolic
tighten
serious
integration
reliability
block
nite
uv
contracts
rearrange
converge
cult
interpret
ation
abs
overestimate
ated
lr
readily
dierentiable
jong
francis
grid
automatic
meth
modulus
products
magnitude
jaj
chips
overview
solutions
wrapping eect
global error
taylor coe
taylor series
interval arithmetic
iho method
y iho
pts method
direct method
qr factorization
hermite obreschko
interval vector
interval methods
truncation error
w y
computing rigorous
interval hermite
factorization method
coe cients
y j
true solution
stable scheme
constant stepsize
interval taylor
interval vectors
validated methods
rigorous bounds
ordinary di
j 1
algorithm ii
initial value
interval method
p q
coe cient
lim j
value problems
much bigger
new perspective
standard numerical
local truncation
asymptotically unstable
computed bounds
iho methods
rotated box
formula 29
enclosure y
standard functions
validated solutions
wrapping effect
iho scheme
obreschko method
qr algorithm
series coe
priori enclosure
methods considered
tight enclosure
order taylor
arithmetic operations
r j
y 0
real intervals
point interval
r nn
q p
z j
high order
upper triangular
point methods
unique solution
recent advances
solution set
computing tight
lohner 17
describe lohner
series expansions
eigenvalues f
enclosure method
wrapping e
guaranteed bound
equal magnitude
moore 19
ax j
arithmetic evaluation
f ax
parallelepiped f
validating existence
iteration 48
principal diagonal
exible c
machine interval
obreschko iho
diagonal tend
iho y
method propagates
ivps for odes
methods for ivps
reducing the wrapping
taylor coe cients
lohner s qr
qr factorization method
taylor coe cient
advancing the solution
computing rigorous bounds
interval hermite obreschko
lohner s method
stepsize and order
high order taylor
interval arithmetic operations
scheme for advancing
existence and uniqueness
problem of reducing
lim j 1
initial value problems
order taylor series
vectors and matrices
reduce the wrapping
showed in 22
sense that lim
overview of interval
interval taylor series
local truncation error
w z j
series coe cients
taylor series coe
hermite obreschko method
w y iho
generation of taylor
intervals a b
y j 1
q p q
initial value problem
cients of y
d r n
odes but also
generating the taylor
taylor series expansions
computed by generating
methods for initial
interval vector y
f ax j
hermite obreschko formula
stepsize or increasing
parallelepiped f ax
discuss some recent
computing tight enclosures
ir and 2
standard numerical methods
orthogonal and r
machine interval arithmetic
ith taylor coe

corpus/krapavin2000-test/1007924.txt
hcc
adv
diam
blowup
placement
coff
poff
files
loop
caches
preserves
paging
parent
cache
deact
capacity
caching
child
incurs
ine
coloring
request
competitive
online
landlord
depth
cooperative
file
anc
swapp
harvest
white
children
guard
lru
colorable
react
ch
diameter
load
incurred
root
ultrametric
nuca
bartal
hierarchical
metrics
lemma
outer
requests
competitiveness
epoch
black
serverless
dist
inequality
descendants
moves
nonzero
missing
act
ton
arbitrarily
toff
evict
ultrametrics
swapc
sleator
game
confusion
adversarial
feasible
node
claim
placed
adversary
nonuniform
incur
fakcharoenphol
tarjan
squid
nonconstant
retrieval
predicate
preserve
od
internal
hierarchy
invariant
field
cooperate
branch
nonnegative
diameters
relocation
ancestor
copy
rooted
terminates
shell
colorings
placements
consistency
consistent
serves
initially
exchanging
penalty
polylog
departments
opt
deterministic
iteration
fields
cap
lemmas
everywhere
leaf
furthest
ect
incurring
descendant
subtree
guesses
metric
ancestors
removes
separated
tree
seminal
sibling
lines
offline
swap
sized
modify
migration
log
equals
executed
sd
requested
department
amortized
incorrectly
serving
updated
derivation
dren
walnut
empowers
chil
nonidle
xfs
algorith
competiveness
predicament
korupolu
unachievable
wisely
eviction
maintains
approximating
old
discovery
statement
brevity
ects
copies
adds
terestingly
maxu
deactivation
reactivation
gration
partment
erature
operative
evicted
fill
guess
erarchy
deci
ratio
replication
hierarchies
erent
desc
idle
count
awerbuch
lit
pulled
capacity blowup
parent diam
cooperative caching
o ine
line 12
hcc algorithm
request sequence
lemma 4
line 4
line 15
hcc problem
loop preserves
holds initially
hierarchical cooperative
distributed paging
preserves p
paging problem
x field
loop moves
internal node
main loop
x value
competitive ratio
b feasible
every iteration
every internal
line 14
online algorithm
constant competitive
placement p
loop proof
associated coloring
loop invariant
tree metrics
retrieval cost
file f
constant capacity
e child
online hcc
second branch
black child
old node
caching problem
preserves i2
ine algorithm
depth 4bk
placement poff
diam parent
constant competitiveness
preserves i1
statement takes
nonzero value
cost incurred
e parent
proof every
coloring c
hence line
always consistent
loop terminates
positive x
avoid confusion
lower bound
ine hcc
swapp p
g depth
holds everywhere
files placed
adv generates
bartal 3
load deact
coff proof
feasible placement
global invariant
penalty f
x values
first inequality
lines 4
line 8
line 5
every line
lines 14
dist u
claim holds
p holds
arbitrary metrics
approximating arbitrary
hierarchical cooperative caching
set of files
outer if statement
inequality is due
incurs a cost
node i e
every internal node
lines that modify
equal to 0
o ine algorithm
constant capacity blowup
diam parent diam
cooperative caching problem
takes the second
confusion we use
claim holds initially
consistency of coff
parent diam parent
initially because root
execution of line
proof every iteration
sequence of requests
proof the claim
lemma 4 3
preserves the consistency
online hcc algorithm
positive x value
depth 4bk 1
ine hcc algorithm
use to refer
set both x
set of caches
thus the change
execution of adv
moves to one
o ine hcc
loop preserves i1
p holds initially
dist u v
copy of f
total cost incurred
approximating arbitrary metrics
metrics by tree
line of code
lemma 4 7
lemma 4 6
follows from lemma
lemma 4 4
set of nodes
b feasible online
denote the old
loop terminates lemma
k k h

corpus/krapavin2000-test/1007454.txt
pivot
cycling
expand
simplex
cycle
steepest
tableau
degeneracy
row
degenerate
indefinitely
iterations
column
devex
iteration
tie
nonbasic
columns
behaviour
expanded
pivotal
gill
pivots
proposition
shall
perturbation
tolerance
objective
cyclically
dantzig
cycles
primal
eigenvalues
coefficients
unbounded
vertex
acceptable
lp
wolfe
fletcher
beale
bqpd
osl
shifted
resolving
ffi
odd
criterion
dual
indefinite
selection
arithmetic
deltag
minos
redundant
edge
breaks
analyse
inexact
constraint
leave
harris
coefficient
roundoff
unshaded
enter
largest
negative
stalling
feasibility
ratio
pattern
scaling
reset
guaranteed
simplest
resolves
nonnegative
preprocessing
gamma
terminate
ff
relied
preprint
repeat
perturbed
candidate
anti
stay
gammaaa
coap
reinversion
mckinnon
ifa
xpressmp
zrnig
likelyhood
unboundedness
balin
reversed
signs
conjugate
sufficient
repeats
entries
leaving
inequality
gomory
returns
characteristic
encountered
prevent
breaking
theta
breaker
detached
tableaux
direction
infeasible
rows
matrix
feasible
gammaffi
enlargement
normally
singular
extra
numerical
ski
summarises
recalculated
cplex
resetting
julian
perturbing
nonzero
min
entry
tance
tightest
itera
whilst
unaltered
impor
broken
bounds
destroying
relaxes
characterise
rule
break
simplify
stability
encountering
interchanged
solu
pass
finiteness
lexicographic
eventual
basis
met
escape
pivoting
visits
invert
formed
prohibitively
alternation
slack
epsrc
analysed
termination
danger
award
submatrix
sole
induction
zeroes
strict
established
introducing
elsevier
violations
sided
straightforwardly
cycle examples
cycle pattern
steepest edge
x 2k
simplex method
reduced cost
negative reduced
expand ratio
ratio test
largest pivot
row 2
column selection
column 2
row 1
degenerate vertex
basic variables
column 1
two iterations
cycle indefinitely
row selection
expand procedure
pivot row
objective function
using expand
edge column
sufficient conditions
x x
simplex algorithm
prevent cycling
expand row
odd iterations
pivotal column
objective row
full step
iteration 2k
shifted cyclically
gill et
iteration 2
table 4
min step
g k
theta 2
proposition 1
selection rule
cost criterion
cost row
also cycle
characteristic equation
unique pivot
cycling examples
unbounded direction
cycle order
step ff
resolving degeneracy
feasibility tolerance
chosen rather
inexact arithmetic
without scaling
even iteration
expand method
exact arithmetic
simplest possible
variable values
cost column
real eigenvalues
lp problem
linear programming
x r
test returns
k 0
m 1
m 2
even iterations
cycling still
gamma a11
cycling example
new expanded
nonbasic variables
problem cycles
nonbasic variable
x 2k 2
expand ratio test
negative reduced cost
x x x
leave the basis
necessary and sufficient
steepest edge column
edge column selection
pivot in row
expand row selection
tableau t 1
gill et al
enter the basis
start of iteration
values of variables
rather than column
reduced cost criterion
given in row
cost column selection
breaks the 2
column selection rule
columns are selected
tableau t 3
gamma s gamma
reduced cost column
ratio test returns
theta 2 matrix
conditions of proposition
g k 0
since a 11
step is taken
values in table
determines the maximum
variable columns shifted
feasibility tolerance ffi
direction is found
area in figure
holds which implies
column selection criterion
cycles when using
iteration 2k 1
x x pivot
degeneracy in linear
problem is unbounded
resolves the degeneracy

corpus/krapavin2000-test/1027352.txt
broadcast
uplink
periodic
ahb
requests
items
item
bandwidth
server
tc
deadlines
edf
demanded
channel
workload
deadline
periodically
demand
missed
adaptive
scheduled
overload
broadcasting
cycle
bod
workloads
hybrid
asymmetric
batching
batch
bw
request
saturation
clients
downlink
zipf
scheduling
users
dissemination
client
profiles
transmission
zipftian
capacity
frequency
mode
schedule
static
bidirectional
disks
priority
pull
cooling
environments
frequencies
adaptation
program
pages
pinwheel
population
critical
demands
percentage
receive
received
congested
heavily
period
pfair
threshold
sampling
unsatisfied
unlimited
push
fountain
scalability
fraction
coming
dynamically
bd
bad
requested
adapt
access
allocated
issued
ffl
frequently
uniform
integrates
satisfied
knapsack
broadcasts
cutoff
waste
slot
pseudodeadline
proportionate
aida
index
indexing
fairness
unit
channels
saving
crossover
prioritizes
contending
driver
interleaved
included
slots
policy
becoming
arriving
saturated
requirements
sample
timing
mobile
simulation
air
collisions
minimize
consequently
reserved
page
wasting
incorporating
bulk
popularity
priorities
estimated
effectively
trying
predetermined
calculate
accessed
overwhelmed
congestion
communication
listen
tolerant
dynamic
decreased
traffic
offered
suffers
logn
met
decreases
contention
layout
interval
functionality
strong
contents
queue
moderate
pure
potential
multiset
status
worse
grows
overhead
protocols
worst
modes
yes
units
occupies
expects
wasted
worth
situations
devoted
dy
precomputed
dummy
unable
equals
allocation
effective
transmitted
energy
routes
sent
fault
portray
lacuna
suffering
kee
periodic broadcast
broadcast program
uplink channel
tc ahb
non adaptive
demand broadcast
time unit
edf batch
broadcast periodically
deadlines missed
asymmetric communication
requests scheduled
access frequency
broadcast cycle
adaptive hybrid
demanded items
adaptive 1
user access
time critical
adaptive 2
bw threshold
items demanded
access distribution
per time
broadcast mode
critical asymmetric
requests received
communication environments
channel saturation
hybrid broadcast
actual user
deadline constraints
broadcast disks
overload conditions
broadcast model
broadcast models
frequency distribution
critical adaptive
demanded time
heavily demanded
client profiles
zipf distribution
bandwidth requirements
length cycle
data broadcast
level uniform
edf batching
bandwidth assigned
workload items
limited uplink
communication environment
strong overload
cycle length
hybrid model
missed deadlines
available bandwidth
broadcast length
workload increases
given item
data dissemination
cooling factor
unit edf
adaptive models
low workloads
dynamic uniform
unit workload
demanded per
frequently demanded
workload range
data items
deadline requirements
uniform distribution
bandwidth required
information server
fixed fraction
relative deadlines
hybrid models
static uniform
potential requests
scheduled figure
static zipf
scheduled time
deadlines b
access frequencies
sample size
b requests
first 20
bandwidth allocated
broadcast period
broadcast frequency
periodically broadcast
two level
adaptive model
low capacity
dynamic time
request per
items periodically
broadcasting periodically
deadline distribution
transmission mode
every item
broadcast frequencies
downlink channel
bandwidth effectively
distribution limited
dynamic zipf
low overload
worth broadcasting
whole workload
dynamic client
capacity uplink
single transmission
data item
sampling technique
total bandwidth
pull based
periodic broadcast program
number of requests
number of deadlines
amount of bandwidth
per time unit
non adaptive 1
non adaptive 2
critical asymmetric communication
time critical asymmetric
asymmetric communication environments
user access distribution
actual user access
critical adaptive hybrid
access frequency distribution
two level uniform
heavily demanded items
time critical adaptive
demanded time unit
items demanded time
broadcast cycle length
limited uplink channel
adaptive hybrid broadcast
uplink channel saturation
workload items demanded
non adaptive models
time unit workload
via the uplink
time unit edf
demanded per time
unit edf batching
level uniform distribution
asymmetric communication environment
static zipf distribution
unit workload items
deadlines b requests
b requests scheduled
broadcast on demand
scheduled time unit
batching a missed
requests scheduled figure
missed deadlines b
first 20 items
frequently demanded items
requests scheduled time
hybrid broadcast model
number of users
user access pattern
cycle the server
adaptive hybrid data
request per time
one request per
non adaptive model
dynamic client profiles
total bandwidth required
dynamic time critical
adaptive 2 model
strong overload conditions
satisfy as many
distribution limited uplink
via a single
tolerant broadcast disks
demand broadcast mode
dynamic zipf distribution
deadline constraints associated
whole workload range
broadcast length cycle
program is computed
fault tolerant broadcast
number of unsatisfied
number of items
minimize the number
change with time
needed to broadcast
use the available
program is static
capacity uplink channel
percentage of deadlines
consequently the server

corpus/krapavin2000-test/1035757.txt
checkpoint
checkpoints
clock
checkpointing
forced
causal
protocol
useless
lc
cl
lamport
ckpt
netzer
sent
mostefaoui
ck
raynal
rollback
irisa
elary
message
prevention
timestamp
domino
protocols
array
enddo
manivannan
mcj
induced
delivery
pk
timestamps
recovery
reception
consistent
iff
determination
clocks
orphan
receives
unstable
detection
sending
send
cycle
snapshots
deliver
messages
manages
event
singhal
breakpoints
predicates
communication
predicate
managed
quasi
processes
hlary
trackability
mck
docase
ik
contradicts
sends
computations
ffl
min
initialization
booleans
piggyback
piggybacks
oe
false
boolean
synchronous
path
events
received
paths
z
piggybacking
timestamped
timestamping
breakpoint
prevent
precedes
brought
depicted
tocol
russell
directs
coordination
remind
safe
pattern
mobile
family
xu
arrays
sender
save
michel
coordinated
endif
stable
arrives
max
belongs
delta
happened
synchronize
appended
inconsistent
delivering
conjunctions
enddocase
manitoba
emmanuelle
jichiang
leen
zcf
piggybacked
anceaume
vitenberg
coasting
netxer
agbaria
erlier
redrawn
rdt
gyung
winnipeg
cycles
interval
invariant
asynchronous
fc
indicated
previuosly
incrementation
russel
subcondition
attiya
intial
executes
formation
reset
updates
snapshot
tradeoff
statements
concatenation
propagation
arriving
meaning
pointing
classical
adnan
occurences
youn
tsai
withdrawn
appends
sharpening
hagit
characterizes
proves
simplications
genericity
hee
fourteenth
examine
logical
arrival
plications
directing
hypothesis
channels
roy
encompasses
consequently
past
passing
luo
z path
local checkpoint
local checkpoints
causal z
forced checkpoints
communication induced
global checkpoint
forced checkpoint
induced checkpointing
take checkpoint
checkpoint c
consistent global
k z
useless checkpoints
c k
z cycle
m clock
distributed computations
global checkpoints
checkpointing protocols
z pattern
process p
message m
based prevention
communication based
z paths
m raynal
clock j
r netzer
irisa communication
h elary
mostefaoui r
netzer m
ck z
m 1
local state
condition c
checkpointing protocol
array clock
basic checkpoints
p k
j m
proposed protocol
c j
j y
lamport clock
procedure take
last checkpoint
p j
m h
control information
send m
boolean array
quasi synchronous
x 1
receives m
rollback recovery
non causal
state oe
local clock
array sent
checkpoint taken
lamport clocks
path m
z cycles
checkpoint forced
checkpoints c
m sent
max ck
checkpoint sends
clock lc
c 1
m 2
unstable properties
clock k
m lc
current local
pattern m
distributed computation
m 0
checkpoints taken
checkpoint interval
domino free
case clock
lamport timestamp
false enddo
basic checkpoint
free communication
array greater
control variables
useless checkpoint
safe strategy
first checkpoint
hypothesis ffl
rollback propagation
prevent useless
get max
data structures
c i x
c k z
communication induced checkpointing
causal z path
consistent global checkpoint
cl i k
c j y
local checkpoint c
induced checkpointing protocols
checkpoints in distributed
prevention of useless
communication based prevention
take a forced
m h elary
m clock j
netzer m raynal
mostefaoui r netzer
irisa communication based
r netzer m
elary a mostefaoui
j m h
consistent global checkpoints
number of forced
induced checkpointing protocol
procedure take checkpoint
detection of stable
sent by p
path from c
checkpoint is useless
checkpoint is taken
set of local
taken by p
sends a message
x and c
message m sent
take a checkpoint
save the current
take checkpoint sends
checkpoint forced checkpoint
checkpoint of p
clock i k
message to pk
non causal z
z path m
m clock k
z pattern m
checkpoints to ensure
causal z paths
checkpoints are taken
j m clock
take checkpoint forced
local state oe
condition c 1
current local state
contradicts the hypothesis
described in figure
receives a message
c i 2
c k 2
checkpoint between c
oe i 0
determination of consistent
clock j m
taken a checkpoint
m 2 sent
condition c 0
z ck z
ffl case clock
known by p
prevent useless checkpoints
domino free communication
free communication induced
takes a basic
value of lc
brought to p
boolean array greater

corpus/krapavin2000-test/1032082.txt
cc
modmp
inf
zz
rank
mod
sigma
mzz
modm
acceptance
prime
nondeterministic
theta
protocol
submatrix
ort
semiring
seq
pp
circuits
counting
proposition
incomparable
accepting
sigmaj
modes
sup
mode
protocols
rejecting
acc
player
matrix
np
co
communication
ranks
rej
prob
sdt
rankr
ir
binomial
ib
subspace
fermat
semirings
vlsi
inclusion
kth
modular
players
var
lemma
nondeterministically
homomorphism
arguments
orthogonal
classes
depth
announces
ip
branching
nonnegative
matrices
determinism
entries
primes
deterministic
damm
homeister
multilective
focs
canonic
brosenne
coefficient
probabilistic
tradeoffs
inner
bip
blackboard
waack
turing
orthogonality
oblivious
delta
gates
babai
speak
rg
rows
integers
ae
regard
claim
pairwise
modularity
computations
variation
sequences
dn
factorization
vectors
spectral
bounds
henrik
stephan
infinitely
pseudorandom
vegas
dlog
reductions
diagonal
norm
monotone
matthias
las
communicated
rectangular
log
characteristic
modulo
nondeterminism
reals
root
integer
reducible
languages
cos
indices
corollary
reischuk
halstenberg
stacs
coprime
meanders
basel
idempotents
pzz
qjm
party
complement
ff
commutative
chooses
indexed
homogeneous
columns
bit
transposes
monoids
hing
history
string
gammaf
analogies
enumerations
relativized
discriminator
relations
product
versus
divides
comparability
obvi
announce
carsten
properly
stops
sequel
maximal
polynomial
analytic
notions
algebra
tree
logspace
obdds
fz
divisibility
rigidity
identity
connect
nonzero
obviously
communication complexity
p cc
sigma n
complexity classes
np cc
modmp cc
n theta
acceptance modes
counting communication
zz mzz
protocol p
theta sigma
mod m
mod p
pp cc
theta n
c prob
order equivalent
acceptance mode
prime number
communication protocol
rank zz
ort p
counting acceptance
sup cc
seq n
var rank
sigmaj n
cc sup
prob f
n matrix
x y
g n
j sigmaj
lower bounds
co n
binomial coefficient
mod inf
co np
input x
b v
n 0
acc p
branching programs
m 0
ii 6j
rejecting computations
variation ranks
rej p
kth binomial
modm equivalent
n p
let p
integer matrix
c co
mod q
probabilistic communication
theta y
vlsi circuits
p p
communication protocols
rank 1
rank arguments
r inf
orthogonality test
rank ib
nondeterministic communication
prime factorization
rejecting otherwise
cc 6
many n
chooses nondeterministically
inf r
dn re
n seq
semiring homomorphism
nondeterministic mode
m ort
real variation
co nondeterministic
little theorem
homogeneous submatrix
variation rank
nondeterministic protocols
player x
m acc
theta j
ir n
claim follows
zz m
communication history
modulo m
proposition 20
inclusion 2
accepting computations
x theta
p l
c mod
l 00
monotone circuits
inf 1
natural number
corollary 7
properly contained
inner nodes
y 2
maximal set
l k
linear subspace
v x
f log
lemma 14
nonnegative integer
communication complexity classes
theta sigma n
sigma n theta
counting communication complexity
n theta sigma
inf i p
input x y
theta n matrix
sup cc sup
co np cc
j sigmaj n
mod p p
cc are incomparable
c prob f
counting acceptance modes
n 0 theta
p p cc
rank zz mzz
incomparable with regard
theta n 0
regard to inclusion
n theta n
p i inf
p i sup
g n p
ii 6j 0
c co n
y 2 sigma
kth binomial coefficient
accepting and rejecting
b v x
cc is closed
computation of p
z 2 g
p l k
x theta y
x y 2
m acc p
n seq n
n 0 submatrix
infinitely many n
m i inf
var rank zz
mod p l
theta j sigmaj
cc and mod
inf r inf
fermat s little
sigmaj n theta
submatrix of m
sup and mod
cc and modmp
protocol on sigma
inf i m
p on input
f z 2
p on x
set of pairwise
probabilistic communication complexity
inf 1 inf
matrix with entries
l k k
sum and product
x and y
sufficient to show
let a 0
rows and columns
consider the ordered
binomial coefficient consider
homeister stephan waack
inner nodes v
circuits for matching
j gamma 2m
nondeterministic communication protocols
entries in f
yield better bounds
zz mzz rank
provide lower bounds
nondeterministic vlsi circuits
stops rejecting otherwise
q p cc
equivalent to j
lower bound arguments
computation stops rejecting
show that rank
x chooses nondeterministically
entries are equal
cc as well
sigma n holds
m ort p
acceptance modes except

corpus/krapavin2000-test/607032.txt
hypergraph
diagen
editing
diagram
conn
editors
editor
hyperedge
grammars
layout
syntax
flowchart
flowcharts
diagrams
flowout
hypergraphs
varrow
lhs
grammar
hyperedges
attachment
parser
directed
srg
productions
flowin
asg
fig
reducer
drawing
arrows
visual
derivation
modeler
layouter
blockseq
diamond
attribute
rhs
developer
box
schurr
subdiagrams
parsing
arrow
edges
statement
cf
uml
prototyping
transformation
attributes
erent
visited
syntactic
berthold
nonterminal
boxes
resp
languages
creating
terminal
hoffmann
java
eer
vispro
subdiagram
reker
arity
multiset
stmt
areas
specification
edge
hline
syntactically
di
generator
match
parsed
language
block
programmed
dag
er
semantic
modes
production
ers
rules
edited
embeddings
gathers
parsers
internal
automatic
labels
rekers
nassi
nonterminally
costagliola
chok
shneiderman
shapely
penguins
polese
harrow
genged
deufemia
operationsupport
gral
colimes
drewes
minas
grayed
rule
specifying
compiler
removes
vertical
tool
gray
modifies
please
diamonds
marriott
screenshot
tailored
lexical
rapid
mode
transformations
replacement
ladder
canvas
graphics
adjusted
text
arrangement
shaped
dags
gennaro
vincenzo
reduction
rectangular
graphical
spatial
seamlessly
omitted
connect
free
hyper
relationships
pascal
modify
nodes
transformer
crossed
specify
rectangles
shelf
interfaces
compilers
realization
indicated
force
ort
labeled
generic
constraint
macros
supplied
primarily
created
adds
meaning
morphisms
drawings
cond
informaticae
carries
outlined
thick
fundamenta
depicted
giuseppe
string
connected
occurrences
reads
ected
suited
abstract
realized
textual
hypergraph model
directed editing
syntax directed
conn conn
free hand
hand editing
reduced hypergraph
editing operations
diagram components
diagram language
diagram editors
attribute evaluation
attachment areas
hypergraph grammar
editing operation
graph grammars
diagram layout
diagen editors
diagram languages
hypergraph transformation
diagram component
diagram analysis
diagram editor
graph transformation
hypergraph models
editor developer
context free
automatic layout
derivation tree
specific diagram
drawing tool
condition conn
hypergraph grammars
editor framework
reduction rules
statement statement
application conditions
free hypergraph
syntactic structure
visited nodes
c statement
cf fig
diagen editor
constraint multiset
multiset grammars
new statement
hypergraph parser
statement box
editing mode
derivation structure
layout mechanism
conn condition
internal model
program generator
transformation rule
cf section
uml class
visual languages
di erent
o er
h c
conn edges
reduction step
vertical arrow
diagram model
conditional block
class diagrams
attachment area
starting hypergraph
hypergraph transformations
statement condition
berthold hoffmann
internal diagram
prototyping tool
diagram editing
editing modes
corresponding nodes
transformation rules
program code
reduced one
semantic representation
rapid prototyping
fig 10
quite similar
o ers
visual representation
algebraic approaches
diagen uses
drawing tools
creating diagram
flowout edge
edited diagrams
derivation dag
flowin flowout
diamond shaped
varrow edge
reduced model
shaped conditions
support syntax
visual language
correct subdiagrams
string grammars
sub hypergraphs
hyperedge replacement
correct diagram
specify box
component edges
evaluation cf
diagen o
cross model
transformation part
conn statement
syntax directed editing
conn conn conn
free hand editing
reduced hypergraph model
directed editing operations
specific diagram language
lines and arrows
context free hypergraph
constraint multiset grammars
reduced hypergraph models
condition conn condition
conn condition conn
free hypergraph grammars
cf fig 2
directed editing operation
h c statement
hypergraph transformation rules
uml class diagrams
set of diagram
grammars with embeddings
rapid prototyping tool
internal diagram model
shown in fig
lhs and rhs
used for creating
computing by graph
diagen a rapid
approaches to graph
specify box b
representations of diagrams
graph transformation part
creating diagram editors
based on hypergraph
model the hypergraph
relationships between attachment
conn conn statement
step of diagram
attribute evaluation cf
schurr s approach
flowchart of fig
implementation of visual
hand editing mode
automatic layout mechanism
shows the hypergraph
diagen o ers
editing or free
hypergraph model fig
diamond shaped conditions
support syntax directed
syntax directed translation
edges and nodes
cf section 5
applying the rule
fig 4 shows
operations are specified
areas are modeled
statement h c
rule in fig
support free hand

corpus/krapavin2000-test/627797.txt
dma
itemsets
site
polling
candidate
mining
association
cd
sites
pruning
counts
itemset
apriori
ch
db
heavy
skewness
database
sup
count
locally
dhp
ll
maxsup
partitions
globally
databases
broadcast
candidates
bed
gen
exchange
scan
rules
hl
discovery
hash
bc
pdm
partition
thresholds
message
messages
secondary
iteration
ratios
minsup
ab
clifton
threshold
requests
experiment
broadcasts
collect
reduction
prune
shichao
kubat
buckets
items
hashing
primary
zaki
lp
transaction
vaidya
fef
fefg
fbc
adaptation
request
mohammed
plotted
scanning
pruned
sequential
away
jaideep
fab
ranges
ling
centralized
horizontally
broadcasted
hongjun
xindong
pvm
synthesizing
sigkdd
sent
chris
zhang
feng
miroslav
chengqi
jiawei
synthetic
acts
partitioned
broadcasting
vipin
parthasarathy
deduced
picked
han
subsets
gg
transmitted
finds
lemma
privacy
chart
srinivasan
sizes
multidimensional
synchronization
scans
vertically
receive
evolutionary
ac
clustering
jeffrey
tutorial
ef
ninth
wei
popular
centers
reply
recorded
send
kantarcioglu
cdg
dbminer
hbc
gudes
jingkai
silvestre
pendharkar
como
literatures
wthrich
ycel
parag
fbcg
sap
bcg
jianning
acg
databasess
sanseverino
unfavourable
perrizo
rgc
netweaver
saygin
legler
bar
sends
rs
originating
kumar
gamma
effective
responsible
communication
lu
workstations
receives
murat
masaru
rozenberg
kargupta
morinaga
lekkala
candidate sets
support counts
locally large
association rules
large itemsets
local pruning
polling site
candidate set
globally large
x sup
local support
support count
count exchange
global pruning
apriori gen
every site
mining association
itemset x
dma cd
ch k
k itemsets
minimum support
heavy itemsets
sets generated
polling requests
message size
support threshold
data mining
global support
cd figure
distributed database
apriori algorithm
association rule
secondary range
primary range
polling sites
heavy k
maxsup x
itemsets found
distributed databases
distributed mining
total message
message communication
test bed
partition db
algorithm dma
data skewness
l k
parallel mining
gen function
prune away
large k
knowledge discovery
hash tree
k itemset
execution time
polling request
sets ch
secondary ranges
remaining candidate
parallel environment
size 2
first experiment
th iteration
rule mining
direct application
database db
set generation
sets per
set x
x must
database mining
generalized association
large 2
message sizes
pruned away
size reduction
average number
local support counts
number of candidate
set of candidate
mining of association
large at site
dma and cd
mining association rules
candidate sets generated
heavy at site
ch i k
site s 1
dma cd figure
globally large itemsets
support count exchange
candidate set x
rules in distributed
dma against cd
heavy k itemsets
number of sites
x is locally
x is heavy
applying the apriori
sets in ch
local support count
apriori gen function
large k itemsets
must be locally
minimum support threshold
size 2 candidate
k th iteration
problem of mining
x is globally
exists a site
ll i k
large itemsets found
remaining candidate sets
globally large k
candidate set generation
candidate sets per
global support counts
global support count
candidate sets ch
transactions in db
site s 3
performance of dma
message size reduction
k the set
site s 2
set of large
association rule mining
o n messages
data engineering v
knowledge and data
l k gamma1
generalized association rules
transactions on knowledge
k to denote
primary and secondary
cd t10 i4
sites s j
sets per site
sets at every
itemsets in db
x large sites

corpus/krapavin2000-test/637759.txt
register
devs
trap
instruction
message
npc
alfa
msg
dest
cpu
regglob
cmpa
students
registers
alu
sendoutput
window
bus
cmp
cwp
const
incdec
cmpb
psr
activated
pc
circuit
bits
internalmessage
unimp
dtack
device
port
byte
interrupt
stb
reset
serviced
ports
coupled
store
tick
masmin
masmax
inc
instructions
cu
signal
organization
simulator
traps
cd
bit
transition
eth
reg
processor
address
mask
courses
decremented
comparators
issued
int
inputs
inb
passivate
outputfunction
bgrant
oldb
externalmessage
internalfunction
portname
externalfunction
olda
priority
architecture
charge
clock
xor
gates
addr
dec
mem
outputs
strobe
modifiability
ina
finished
selector
sent
cycle
sparc
assembly
turned
top
multiplexers
routine
stores
circuits
delay
event
incremented
atomic
transmitted
lw
linker
cen
operands
external
assembler
uc
gnu
increment
enabled
scheduled
microprocessor
chip
attacked
teaching
simulation
toolkit
internal
bsel
iack
assemblers
mastering
bgrantin
fcod
talisman
clck
simulink
portnum
influencees
irqs
irq
asel
maisie
xnor
tbr
useing
pil
simplescalar
shifter
holdin
traplogic
wainer
cclogic
passivates
breset
cpu 05
top 01
message y
message d
message 00
d 00
y 00
coupled model
alfa 1
computer organization
message x
x 00
digital logic
root 00
control unit
inc dec
sendoutput msg
msg time
transition functions
input output
reg 1
memory image
dec model
cmpb link
mem 02
const internalmessage
clock tick
internal transition
internal event
register window
instruction register
output ports
experimental framework
transition function
following figure
logic level
instruction set
trap type
cu 43
register 1
high byte
using cd
register 4
stb r1
chip selector
model 50
msg port
assembly language
instruction cycle
boolean gates
log file
hardware description
base address
last operation
register stores
base register
priority trap
trap base
model uc
model incdec
enabled store
number received
internalmessage msg
c enable
eth line
atomic model
global registers
externalmessage msg
address strobe
internalfunction const
external event
simulated computer
outputfunction const
clock 45
y register
initial image
image addr
const externalmessage
organization courses
sparc processor
addr memory
event arrives
register number
externalfunction const
pc inc
basic behavior
model regglob
result obtained
model definition
simulated time
execution flow
register 2
one bit
d 00 00
y 00 00
message d 00
message y 00
message 00 00
message x 00
x 00 00
message i 00
top 01 top
sendoutput msg time
store the high
return this model
cpu 05 cpu
digital logic level
inc dec model
internal transition function
stb r1 dest
store the register
byte of reg
cpu 05 root
int i 0
input output ports
found in 49
const externalmessage msg
addr memory image
modifiability of alfa
register has changed
following figure shows
using digital logic
input was enabled
register number received
image addr memory
must be serviced
external event arrives
externalfunction const externalmessage
computer organization courses
const internalmessage msg
outputfunction const internalmessage
incremented or decremented
assembly language level
stored in memory
model is used
model definition transition
clck 1 000
see if cmp
definition transition functions
npc to cpu
value is sent
object oriented simulation
issued the memory
coupled model representing
computer systems design
times set 1
load the register
assembler and linker

corpus/krapavin2000-test/609230.txt
jvm
cl
loader
invokevirtual
loaders
srmethod
loading
desc
bytecode
srclass
def
java
getr
denition
findclass
soundness
saraswat
overrides
lvars
typing
objectref
subtyping
wf
vp
verication
dened
invv
resolved
bridge
formedness
parent
instruction
typedness
specication
predicate
spoong
areturn
widening
overriding
ok
stack
rr
applet
speakup
verier
resolution
bug
dispatch
superclass
denes
selects
invocation
invokeinterface
resolves
mt
environments
loadings
safe
inside
applets
name
lemma
subtype
safety
formalization
bytecodes
stata
ndclass
verifyrecord
classname
tvalue
satises
linking
rst
descriptor
env
trusted
conversion
augmented
string
symbolically
delegation
constraint
veried
denitions
remembers
veries
dene
classdef
iface
delegations
cc
instructions
pc
delegates
abbreviates
abadi
modication
referenced
lang
redene
judgement
satised
transitivity
premise
names
lazy
transition
loaded
vironment
invariant
dention
aws
classloader
exeception
coredumps
bracha
retval
loadclass
classes
security
heap
inconsistencies
exive
ects
preserves
nalization
invariantly
runtime
environment
transitive
selection
violation
induction
correctness
dierent
whereby
speci
interfaces
unrelated
resolve
member
aw
cial
supertype
appearing
descriptors
signature
delegate
sun
virtual
sub
invoked
ow
eld
semantics
dening
formalizations
override
symmetry
violates
lemmas
cf
rt
succeeded
tokyo
loc
straints
indirect
transitions
invariance
consistency
ns
exibility
proved
en
typed
diers
veri
closure
super
formalizes
judgment
predicates
threads
expresses
faithfully
jensen
subroutines
elds
violate
proving
remember
references
existence
def 2
loading constraint
constraint scheme
cl n
method resolution
class loaders
class loader
cl 0
class loading
bytecode verication
n cl
method selection
value typing
cl cl
findclass scheme
denition 2
class c
vp l
l 0
class name
c cl
loading constraints
method m
invv ok
widening conversion
method desc
method dispatch
ok e
well formedness
well typedness
objectref class
parent loader
type spoong
method cl
dispatch table
l 00
subtyping relation
lemma 1
class d
denes class
bytecode verier
bridge safety
symbolically referenced
predicate selects
jvm state
loader 0
selection process
string list
def 4
soundness theorem
method overriding
l vp
r speakup
loader 2
loader l
direct parent
wf parent
parent e
augmented typing
context cl
class loadings
cl pc
augmented value
loader 1
java virtual
method invocation
object value
soundness proof
r l1
rr getr
d getr
cl method
c selects
method overrides
safe e
found inside
method cc
theorem trusted
context l
ndclass scheme
trusted environments
wf method
applet loaders
parent loaders
predicate overrides
bridge safe
r getr
error state
selects srmethod
selects m
x loader
name desc
class names
l 2
n l
l 1
environment e
r l
objects classes
type safety
virtual machine
resolution process
also invariant
method e
type r
pc lvars
local stack
r l2
signature x
type env
c name
loading constraint scheme
cl n cl
invv ok e
method selection process
correctness of invokevirtual
method dispatch table
cl cl n
saraswat s bug
wf parent e
parent e p
saraswat s problem
augmented value typing
java virtual machine
def 2 7
n cl 0
l vp l
method resolution process
superclass of c
def 2 9
wf method e
n cl cl
stata and abadi
lemma 1 correctness
loader in e
proving the soundness
bridge safe e
denition 3 1
n l 0
l n l
section 2 4
e an element
assume the rst
def 2 6
vp l 00
class t loader
def 2 1
method overrides srmethod
vp l 0
class loader l
existence of method
def 2 13
cl 0 n
l 0 vp
srmethod and method
cl 0 cl
wf class e
lvars and stack
context l 2
symbolically referenced method
symbolically referenced class
cl vp l
lemma 3 existence
existence of constraints
select a method
rule of invokevirtual
resolved into c
cl n 0
direct parent loader
cl pc lvars
cl method desc
spoong in jdk1
theorem trusted environments
lemmas 1 1
dened in figure
inside the current
def 2 10
def 2 3
method cl method
section 2 5
satises the following
denition 2 7
r l 1
r l 2
dynamic class loading
cf section 2
p l 0

corpus/krapavin2000-test/629432.txt
bfea
spline
knot
nurbs
curve
surface
vcca
splines
rational
cell
curves
architecture
pumped
surfaces
controller
graphics
ac
megson
systolic
basis
parametric
virtual
clock
patch
calculate
cells
accumulating
array
normals
pts
isoparametric
pipeline
calculating
tangent
uniform
pacs
calculated
delay
bezier
vlsi
patches
weights
unified
rhs
hardware
cycles
conics
dag
pac
derivative
triangle
grid
cubic
indispensable
adder
inner
kth
knots
megsons
subtractors
speeded
denominator
blending
incremented
registers
gammak
workstations
subtractor
pumps
active
quantities
geometric
3d
dummy
units
coordinate
downstream
equivalents
engine
inputs
triangles
normal
architectures
lth
boils
weighted
4d
delta
orders
pins
vectors
extent
vertices
numerator
core
product
derivatives
wn
resultant
generation
host
discrete
throughput
functional
division
nonrational
sandwiched
versprille
proengineer
abstractb
meager
gourard
geomod
systolically
casteljau
ushered
nondependence
rationalized
deboor
lj
umin
iges
tessellated
equation
corrupted
row
timing
ffl
bi
calculation
vector
calculates
mathias
pumping
pump
era
umax
ctrl
elaborates
suitably
boxes
apart
rendering
fill
shaded
computes
aided
inset
unfolds
innovations
aliased
slowed
useless
communicate
sent
cycle
microcode
cagd
warranted
continues
shapes
difficulties
generations
raster
rose
explosive
pulled
modeling
calls
upstream
subtracted
semiconductor
routine
evolution
outputs
column
theta
fi
quadratically
utmost
controls
integration
primitives
dependency
decouples
widespread
cards
lighting
impressive
shape
basis function
b spline
control points
basis functions
knot vector
rational b
virtual control
spline curves
b splines
useful basis
order basis
nurbs surface
control point
function values
uniform rational
knot values
spline curve
uniform knot
active control
j l
parametric value
nurbs curve
non uniform
clock cycles
function computation
evaluation array
curve surface
function evaluation
unified architecture
weighted control
product computation
non rational
uniform b
time required
non zero
discrete values
first cell
graphics pipeline
k basis
curve computation
architecture proposed
value u
spline surface
k u
inner product
function curves
cell requires
last point
l v
c u
two clock
one triangle
kth order
systolic architecture
l active
function value
point p
x coordinate
normal vectors
vlsi architecture
geometric modeling
architecture presented
linear structure
first term
processing cell
parametric values
isoparametric curve
highly suitable
megson 19
nurbs surfaces
unit control
calculating array
accumulating cells
curve control
modeling applications
control pts
k useful
compute nurbs
linear architecture
function generation
high end
k theta
clock cycle
particular value
equation 8
second term
theta l
whole curve
end workstations
term gives
tangent vectors
valid range
standard graphics
nurbs curves
whole surface
every clock
delta delta
time taken
functional units
one useful
zero values
output line
computer graphics
b spline curves
basis function values
curves and surfaces
virtual control points
rational b spline
useful basis functions
active control points
uniform knot vector
non uniform rational
b spline curve
number of control
values of u
value of u
basis function computation
computation of basis
uniform rational b
basis function evaluation
n i k
rational b splines
order basis functions
function evaluation array
computation of nurbs
j l v
inner product computation
parametric value u
required to calculate
basis function value
non uniform knot
order basis function
uniform b spline
non rational b
weighted control points
useful basis function
b spline surface
values of v
l j l
k and l
j l j
rhs of equation
first order basis
basis function curves
l active control
theta l active
types of b
k theta l
control point p
two clock cycles
every two clock
u and v
computation of b
number of discrete
required to generate
set of basis
one useful basis
k basis functions
pipeline of high
basis function generation
basis function n
compute nurbs surfaces
direction of u
proposed by megson
control points n
kth order basis
standard graphics pipeline
non zero values
architecture to calculate
megson s architecture
calculate a nurbs
ffl the architecture
virtual control point
suitable for integration
n j l
curve control points
grid of k
computes the virtual
computation of uniform
n i 1
every clock cycle

corpus/krapavin2000-test/628780.txt
disparity
stereo
occluded
occlusions
tsukuba
match
inhibition
pixel
poggio
image
marr
disparities
occlusion
pixels
vision
ground
window
images
truth
intensity
camera
3d
uniqueness
cooperative
smooth
coal
map
dot
synthetic
baseline
scene
surface
continuity
matching
correlation
dense
gpm
stereogram
matches
neighboring
sight
intensities
mine
diffusing
binocular
squared
isometric
nakamura
detected
converged
areas
depth
discontinuities
mrf
maps
tower
directional
rxcxd
sloping
scharstein
delineated
diffused
zitnick
labeled
sigmoid
surfaces
iterations
rectified
oversmoothing
multiview
fronto
szeliski
repetitive
masking
area
averaging
incorrect
occluding
stereoscopic
correctly
converge
slanted
kanade
roof
bing
percentage
correspondence
scenes
black
normalized
errors
inhibiting
sing
fish
omni
filtered
foreground
correct
university
convergence
texture
adaptive
attempted
2d
textured
quantitative
array
inhibit
projective
supplied
april
regions
similarity
unwanted
diffusion
ordering
volumetric
distortion
continuous
iteratively
kang
resultant
plot
assumptions
detection
hirschmller
burkert
niese
degui
prez
szelski
fattening
subregioning
kanatsugu
jingli
ladendorf
cynthia
minglun
leupold
shengsheng
myron
passig
olague
burschka
smeaton
yasuaki
infection
lutton
darius
bobick
telepresence
noisiest
garibaldi
intille
evelyne
noel
jiwon
changming
stereograms
photogrammetric
someya
matting
hendriks
connor
qiuming
rooftop
periscope
consistency
update
phenomena
constraint
steven
segmentation
bi
visible
dr
ohta
ayoub
margrit
gelautz
lamp
photorealistic
match values
disparity map
local support
support area
ground truth
c r
r c
left image
disparity values
disparity space
stereo matching
right image
r d
stereo algorithm
non occluded
disparity maps
d c
truth data
match value
random dot
initial match
correct match
inhibition constant
adaptive window
based stereo
ordering constraint
c d
normalized correlation
april june
detected occlusions
pixel r
found correctly
update function
multi baseline
vision v
computer vision
stereo image
pixels labeled
uniqueness assumption
stereo algorithms
real stereo
stereo correspondence
stereo vision
y r
black areas
image pairs
values within
june 2002
stereo methods
true occlusions
3d local
occluded areas
coal mine
cooperative algorithm
poggio 15
tsukuba data
support among
v 47
international journal
depth maps
image pair
occluded pixels
values l
element v
element r
squared differences
isometric plot
occlusions detected
explicitly identified
occlusion detection
camera masking
resulting disparity
false match
area black
labeled non
diffusing support
neighboring elements
reference left
dot stereogram
processing constraints
stereo images
window method
detailed disparity
synthetic random
gpm mrf
maximum match
completely converge
stereo pair
mine scene
area sizes
occlusions found
neighboring match
log filtered
two assumptions
intensity values
b right
along similar
similar lines
global constraints
dense depth
baseline stereo
among neighboring
quantitative comparison
three images
image similarity
image c
input images
d denote
different local
sigmoid function
one pixel
data supplied
inhibition area
incorrect disparities
disparity discontinuities
disparity relative
cooperative stereo
building attached
multiview image
assumption states
unique match
labeled occluded
slanted roof
d c r
local support area
r c d
marr and poggio
c r d
r d c
university of tsukuba
ground truth data
initial match values
y r c
vision v 47
april june 2002
pixel r c
smooth and detailed
u of tsukuba
computer vision v
match values l
journal of computer
v 47 n
element r c
poggio 15 16
match values within
3d local support
using our algorithm
n 1 3
left image b
pixels labeled non
adaptive window method
lines of sight
neighboring match values
based stereo methods
values l 0
synthetic random dot
random dot stereogram
values have converged
maximum match value
labeled non occluded
uniqueness and continuity
area black areas
matching and occlusion
coal mine scene
b right image
areas are detected
support area sizes
real stereo image
image b right
reference left image
right image c
diffusing support among
different local support
support area black
true occlusions found
stereo image pair
along similar lines
stereo image pairs
c r r
r c r
synthetic and real
demonstrate the effectiveness
c r c
using multi baseline
window method 12
map using multi
fast stereo matching
high match values
real stereo images
three different local
disparity map obtained
match with p
right image image
support among neighboring
continuous almost everywhere
labeled as occluded
allowed to completely
area rxcxd correct
camera angles used
values l n
support among disparity
correctly as occluded
support 3x3x3 5x5x3
image as illustrated
truth disparity map
dense stereo correspondence
corresponding to occluded
detailed with occlusions
correct correct found
array of match
feature based stereo
3d disparity space
values along similar
disparity map found
nakamura et al
detailed disparity map

corpus/krapavin2000-test/627662.txt
neuron
automaton
recurrent
learning
latching
phoneme
speech
subnet
numa
neural
neurons
word
recognition
nk
nets
connectionist
inumano
lexicons
iwr
conceived
nl
weights
automata
fsa
net
discrimination
nasals
codification
vowels
transition
equilibrium
italian
phonetic
injected
rules
uncertain
duration
isolated
transient
dictionary
intelligent
nw
explicit
network
tabula
rasa
minima
mentioning
spherical
coding
lexicon
subnets
nondeterministic
activation
repetitions
priori
latched
acoustic
fed
networks
fig
boolean
integrating
perceptual
learned
weight
devoted
cooperating
connections
stability
feedforward
perceptron
speaker
backpropagation
mainly
switching
realization
composed
hyperplanes
paradigm
chain
layered
giles
unified
discovering
inspecting
cascade
status
symbolic
string
worth
discover
sphere
classifiers
quantization
remember
trajectory
gradient
supervised
inputs
nnuuummaaa
nnmnuumummaaa
foggia
telex
thatf
unfing
suchthatji
vento
bps
sistemi
codifications
pearlmutter
firenze
zation
genna
cleeremans
sandiway
degeneration
descent
symbol
trajectories
iv
initialized
basically
automatic
transitions
outputs
refinement
equations
tasks
integration
relieved
dipartimento
resurgence
berthold
immanent
deltav
gammaw
nervous
informatica
tacitly
ji
preliminary
relying
henceforth
considerations
lyapunov
quanti
inject
omlin
pasquale
arisen
coded
accomplished
hidden
adopted
fong
latches
tel
perceptrons
fax
emulating
resentation
grammatical
eq
permits
murst
kremer
tio
elman
skips
feeding
universit
conveyed
hammer
realized
stable
gammai
cnr
spatiotemporal
hypotheses
configurations
explicit knowledge
w ii
automaton rules
word numa
speech recognition
automatic speech
information latching
recurrent networks
proposed model
isolated word
word recognition
recurrent network
example paradigm
connectionist models
full connected
uncertain information
state transition
neural networks
equations 12
ii 2
explicit rules
weight space
recurrent neural
x b
large lexicons
chain like
latching occurs
high transition
transient duration
integrating explicit
automaton states
intelligent behavior
first subnet
boolean state
nondeterministic automaton
priori knowledge
equilibrium point
worth mentioning
linear programming
multi layered
local minima
k l
learning algorithm
example approach
neural realization
latching condition
generic neuron
switching rules
italian word
perceptual tasks
network 1
rule representation
learning scheme
neuron switching
speech pattern
connected recurrent
word inumano
cooperating subnets
like nets
ordinary gradient
duration l
curve f
neuron input
subnet nk
feedforward nets
continuous signal
speaker independent
word prediction
neuron receives
nets nw
tabula rasa
phoneme outputs
automaton 19
two cooperating
learning sequences
fig 5b
n p
unified approach
us consider
state transitions
mainly responsible
hypothesis w
transition occurs
local feedback
feedback multi
net n
equilibrium points
rule r
let us
second statement
input information
input line
layered networks
first factor
unlike many
network inputs
lee giles
network composed
learned rules
learning by example
knowledge and learning
automatic speech recognition
isolated word recognition
w ii 2
problems of automatic
example in recurrent
low to high
integrating explicit knowledge
approach for integrating
recurrent neural networks
number of steps
let us consider
increasing the lexicon
nl s neurons
well when increasing
feedback multi layered
b the network
explicit and learned
transient duration l
multi layered networks
least for feedforward
two cooperating subnets
nk and nl
neuron switching rules
full connected recurrent
vowels and nasals
ordinary gradient descent
models the word
neural networks ieee
nondeterministic automaton 19
framework of linear
learning by examples
hypothesis w ii
local feedback multi
net n p
composed of vowels
chain like nets
recurrent network 1
presentation of examples
practice we want
state of neuron
numa when fed
italian word numa
information latching occurs
devoted to detect
vector of weights
state transition occurs
likely to scale
network which models
integration of explicit
likely to fail
presence of local
rely on learning
used for modeling
c lee giles
b i r

corpus/krapavin2000-test/607698.txt
semicontinuous
lters
sat
monasse
lter
hole
caselles
morphological
grain
jsat
cc
ir
holes
connected
continua
morphology
selfdual
jhj
extrema
compact
nonincreasing
proposition
closed
continuum
proves
image
levelings
shapes
operators
open
ker
ltered
dual
topographic
denition
invariance
idempotent
dened
union
nondecreasing
jcc
meets
internal
family
lindelof
grains
operator
inclusion
self
neighborhood
serra
equality
filters
continuous
sup
maxima
nite
intersection
jcj
dene
thanks
commute
lemma
keshet
joj
attenings
heijmans
masnou
unicoherent
satc
zoretti
rst
insu
dierent
deduce
subsequence
filter
structuring
cient
shall
contradicting
resp
additively
inf
contradicts
nested
connectedness
removes
monotonicity
su
families
minima
mathematical
tu
renato
disjoint
jdj
commutes
scarce
complement
acting
fk
consequence
meyer
symmetrically
monotone
conversely
multiscale
ne
nonempty
map
denitions
driven
claim
contours
acts
invariant
decreasing
xg
satises
ju
fx
jg
corollary
pnpgc
curvu
watersheds
nnn
idempotency
nestedness
pics
semicontinuity
jsatcj
mathematicae
guichard
morphologicae
jsataj
mwhich
salembier
saturation
regional
segmentation
images
pruned
uniformly
observe
texture
morel
semilattice
homeomorphism
voluntarily
cosity
senses
saturations
semilattices
stressing
cardinal
ator
jo
indierently
fmrx
carpet
tree
conclude
preserving
implying
innite
contradiction
shape
criterion
pruning
additivity
underlines
bunch
ages
homeomorphic
lim
external
concerning
contrast
stretches
upper semicontinuous
level sets
connected components
v caselles
p monasse
internal hole
self dual
extrema lters
semicontinuous functions
hole h
connected component
internal holes
semicontinuous function
k n
open sets
mathematical morphology
connected operators
sat x
cc x
compact sets
x 2
sat k
grain lter
contrast change
k 0
c n
continuous functions
sat c
let u
h n
cc o
jsat c
connected operator
n n2in
lower level
h 0
m u
y 2
u 00
set operator
c j
morphological lter
nonincreasing sequence
side term
topographic map
structuring elements
closed set
k y
compact set
may write
connected neighborhood
ir n
o n
n 0
open set
closed sets
may assume
function u
c l
direct consequence
invariance properties
u n
m 0
m uniformly
grain operators
cient measure
change g
connected sets
external hole
sat b
contrast invariance
lower semicontinuous
image u
also open
grain criterion
level set
jcc u
g k
u y
u x
thus x
x 62
y n
given 0
n since
since g
caselles and p
lower level sets
upper semicontinuous function
upper semicontinuous functions
hole of c
hole of k
neighborhood of y
union of open
x 2 g
components of level
increasing and self
jsat c j
shapes of u
hand side term
sequence of continua
sat k n
components of upper
family of connected
components of k
u is continuous
implies that u
holes of x
y 2 h
u is upper
sequence of compact
nested or disjoint
contrast change g
family of internal
components of u
holes of c
x 2 sat
cc o x
g k n
lindelof s theorem
whose associated set
sat k 0
upper level sets
upper and lower
n n 2
open or closed
b we get
thanks to lemma
proof let u
h of c
x 2 d
x we denote
x 2 c
n n 0
l l 2
union of c
conclude that y
using corollary 1
holes of k
write we claim
semicontinuous on compact
d g b
connected and meets

corpus/krapavin2000-test/629185.txt
race
release
consistency
unset
vax
synchronization
acquire
processor
po
paired
weak
hardware
races
programmers
stall
buffer
releasing
sequentially
incomplete
pairable
acq
conflicting
completes
unifies
processors
coherence
syncread
ordering
sequential
cache
read
unpaired
reserve
shared
fetch
instructions
ownership
multiprocessors
programmer
syncwrite
free
proposal
rel
acquires
memory
obey
uniprocessor
issued
datawrite
acquiring
writes
serialization
preceding
barrier
inc
programs
empties
synchronized
sistency
buffers
implementations
flag
consistent
restrictive
designers
obeys
designer
multiprocessor
releases
caches
execute
distinguished
optimizations
reads
kontothanassis
dataread
directory
stalls
correctly
sees
delay
transferred
program
distinguishing
leonidas
uniprocessors
dwarkadas
happens
critical
distinguishes
executions
ensures
completion
conflict
remembers
ops
properly
adve
write
execution
location
semaphores
protocol
requirement
deadlock
atomically
semaphore
keleher
gharachorloo
galen
nsyncs
prefer
deleted
released
request
labeled
instruction
sigops
cox
sigplan
viewpoint
dependencies
overrelaxation
writable
stets
rajamony
bershad
sandhya
lockup
manson
causally
sarita
retaining
returned
transfers
formalizes
opera
notices
pram
interlock
sigarch
zwaenepoel
larus
livelock
violations
message
asynchronous
fong
wo
hunt
causal
retains
delays
jose
executes
stalling
pugh
dubois
california
robert
discusses
returns
logic
pong
parthasarathy
zucker
complementarity
remote
requests
detecting
post
permission
invalidated
rc
scott
intuition
coherent
concurrent
tagged
monterey
drafts
pro
disadvantages
scalable
restrictions
retain
delayed
count
rollback
interconnection
writing
race free
data race
free 1
release consistency
free 0
weak ordering
sequential consistency
synchronization operations
sequentially consistent
memory operations
ordering release
program order
memory model
po po
test set
shared memory
data operations
special buffer
data requirement
four models
vax model
releasing processor
data races
fetch inc
cache coherence
properly labeled
acquire condition
reserve buffer
data operation
synchronization operation
hardware designer
requirement conditions
correctly synchronized
hardware designers
acquiring processor
implementation proposal
memory models
obey data
incomplete buffer
memory consistency
p 0
programmers prefer
unpaired synchronization
labeled programs
incomplete operations
release acquire
critical section
conflicting operations
memory multiprocessors
distributed shared
p 1
free program
consistency models
free programs
coherence protocol
syncread flag
buffer empties
consistent hardware
read returns
consistent execution
empty special
pairable relation
inc count
write due
post acquire
formal interface
appear sequentially
special operations
memory location
less restrictive
p rel
pre release
operations preceding
processor sees
paired release
ensures sequential
read due
designers since
coherence logic
data write
serialization operations
serialization operation
release condition
consistent special
appears sequentially
con sistency
released line
model data
buffer message
release operation
consistency 11
incomplete data
value written
data race free
race free 1
race free 0
weak ordering release
ordering release consistency
po po po
happens before 1
consistency the vax
free 1 memory
data requirement conditions
model and data
consistency or data
obey data race
free 1 unifies
shared memory multiprocessors
prefer to reason
race free program
ordering and release
unifies the four
appear to execute
properly labeled programs
vax and data
race free programs
implementations of data
cache coherence protocol
distributed shared memory
read on x
release and acquire
model data race
appear sequentially consistent
sequentially consistent hardware
release acquire condition
sequentially consistent execution
operations are distinguished
reason with sequential
fetch inc count
empty special buffer
special buffer empties
returns the value
definition of data
memory consistency models
explicit and formal
group of programs
implementations of weak
consistency and data
free 1 provides
appears sequentially consistent
ensures sequential consistency
allowed by weak
hardware designers since
post acquire condition
consistent special operations
implementation of data
consistency with sequentially
pre release condition
cache coherence logic
execution is possible
process as usual
allows an implementation
free 0 1
unpaired synchronization operations
special buffer message
conflicting data operations
write on x
models for shared
programmers can expect
release consistency 11
detecting data races
free 1 system

corpus/krapavin2000-test/1024923.txt
normed
renement
backward
automaton
renements
simulations
nite
forward
reachable
branching
simulation
automata
prophecy
trace
norm
history
fragment
bisimulation
ib
forest
stuttering
decidable
traces
specication
transition
unfold
innite
denition
preorder
invariants
soundness
action
inclusion
proposition
predicate
preorders
index
nat
completeness
dene
bisimulations
prex
specications
transitions
totality
adapted
subautomata
tautology
provers
rst
denitions
nitely
executions
clause
nal
invisible
dened
tau
proving
relations
bisimilarity
nonnal
conjunct
dashed
lemma
specied
correspondence
matched
nondeterminism
ext
ends
actions
founded
ioa
deterministic
decidability
pvs
relates
trivially
denes
reuse
image
convergent
satises
asserts
primed
execution
formula
safety
reachability
execs
weijland
klop
namjoshi
onig
technically
suces
constitute
seq
vg
simulated
glabbeek
counterexample
election
veri
turing
routine
formalized
unfolding
superposition
niteness
untimed
verication
leader
reasoning
hol
injective
acts
relation
isabelle
transfer
fifo
ip
mappings
constitutes
sound
dierence
past
characterization
proofs
abadi
fragments
isomorphism
establishing
nondeterministic
halt
exive
carry
inductively
cumbersome
sucient
corollary
strengthen
lamport
assertion
dicult
checking
induction
specifications
equivalence
move
logic
indicated
receive
verification
name
liveness
timed
speci
implication
declare
labeled
technical
equational
incoming
compositional
specification
restricted
correctness
undecidable
send
abstraction
owicki
normed forward
forward simulation
normed backward
step renement
backward simulation
forward simulations
backward simulations
step renements
normed history
execution fragment
index relation
branching forward
norm function
history relation
history relations
states b
start states
b proof
trace inclusion
nite execution
automaton c
execution correspondence
image nite
action name
start b
partial completeness
reachable states
prophecy relations
adapted normed
ib b
normed prophecy
level specication
normed simulations
automaton b
condition 2
norm functions
related via
reachable b
relation indicated
b 2
b 0
state variables
arbitrary norm
r related
proof method
higher level
r b
tautology checking
branching bisimulation
clause reachable
invisible nondeterminism
transfer condition
branching backward
lower level
dashed lines
start state
proposition 5
b u
completeness result
branching bisimilarity
reachable subautomata
prophecy relation
f related
v predicate
receive v
founded set
global reasoning
regular normed
v nat
level transition
send v
nite invisible
decidable whether
u 2
complete proof
b b
theorem provers
initial condition
last state
suppose b
normed forward simulation
normed backward simulation
normed forward simulations
normed backward simulations
branching forward simulation
normed history relation
normed history relations
states a states
states of b
renement from b
complete proof method
b is deterministic
branching forward simulations
exists a normed
lemma 5 4
state of b
b 2 r
j b u
checking is decidable
ends in u
index of 0
arbitrary norm function
b has n
proposition 5 6
constitutes a normed
simulations and normed
higher level specication
start b 6
execution that ends
nite invisible nondeterminism
adapted normed backward
completeness of normed
starts in u
r related via
simulation from b
branching backward simulation
exists no normed
trace s 0
partial completeness result
b is image
well founded set
c to e
soundness of normed
simulation from c
function from states
follows by lemma
method for establishing

corpus/krapavin2000-test/629430.txt
retiming
dfg
unfolding
unfolded
period
retimed
mcp
legal
cycle
sha
tpds
schedule
inprod
dfgs
dsp
delay
iteration
doc
scheduling
sh
prologue
edwin
dot
shortest
chao
edge
flow
count
preprocessing
loop
fig
lp
trans
ab
epilogue
retimings
qingfeng
production
static
mip
counts
zili
cr
vlsi
lemma
synthesis
zhuge
vliw
paths
shao
library
loops
edges
path
turely
saem
immaterial
schedules
vol
notre
jihong
dame
sched
xiao
graphs
gers
pipelining
factor
rate
codesign
delays
integers
node
nonrecursive
inte
pushed
signal
critical
precedence
unfold
pipelined
circuitry
neil
ceiling
bin
equals
periods
struc
yun
designer
mail
nonnegative
dataflow
risc
dependencies
beach
resource
copies
fractional
inequality
timothy
multiprocessor
host
resp
iff
hardware
jacome
interiteration
iowa
chantana
regroups
iastate
dongming
fice
messerschmitt
akturan
parhi
transformative
meikang
zhiping
saxe
nonintegral
thies
durham
warshall
abstractloop
asips
ranga
chatha
multiproceesor
reprints
precedences
lfc
chantrapornchai
mook
nice
iterations
oct
inequalities
han
kim
pipeline
huntington
vemuri
ieeecs
hms
ule
kyoto
finer
negative
unit
iterative
december
feedbacks
amarasinghe
ules
leiserson
matroids
soo
reorganizes
teger
veciana
composes
contradic
fore
subsection
longest
instant
scheduler
factors
copy
dung
rome
saman
army
multirate
xue
circularly
nique
unfolding factor
cycle period
retiming r
r f
g r
legal retiming
g f
iteration period
unfolded graph
factor f
dfg g
minimum iteration
delay count
u v
mcp f
v f
time dfg
f c
r v
static schedule
p f
graph g
unit time
data flow
o v
period c
original dfg
rate optimal
d p
doc regularpaper97
library trans
ab 19
retiming algorithm
inprod 100505
trans production
dot ab
production tpds
f library
tpds 2
delay counts
time o
minimum cycle
v e
given unfolding
m sha
negative delay
r u
flow graphs
f f
every path
dfg c
via retiming
lp form
path u
path p
d e
f v
edwin h
scheduling data
graphs via
edge e
node v
time dfgs
unfolding factors
f copies
sh v
iteration bound
computation time
o f
d f
bound g
shortest path
h m
loop l
c f
node u
v v
original graph
flow graph
retiming technique
sha scheduling
retimed dfg
l cr
retimed graph
vol 8
f g
path algorithms
f r
d l
node set
critical paths
preprocessing algorithm
iteration j
d r
v j
e f
v 0
systems vol
december 1997
retiming algorithms
graph dfg
unfolding technique
corresponding minimum
period mip
bin xiao
dfg first
qingfeng zhuge
dfg obtained
mip f
g r f
retiming and unfolding
unfolding factor f
legal retiming r
minimum iteration period
d p f
r f c
time o v
cycle period c
unit time dfg
minimum cycle period
g f c
f an unfolding
ab 19 968
library trans production
production tpds 2
inprod 100505 100505_1
f library trans
dot ab 19
doc regularpaper97 dot
tpds 2 inprod
trans production tpds
given unfolding factor
data flow graphs
p in g
h m sha
period of g
flow graphs via
c a cycle
o v e
graphs via retiming
path u v
unfolded graph g
edwin h m
f for every
time o f
scheduling data flow
dfg g r
f in g
e in g
u to v
u v e
every path p
order of retiming
period and f
retiming r f
u v f
o f v
o v 3
data flow graph
graph g f
u and v
original graph g
v in v
negative delay counts
graph g r
sha scheduling data
exists a legal
retiming from v
computation of node
find a retiming
chao and sha
december 1997 f
function from v
systems vol 8
unit time dfgs
edge from u
v in g
find the minimum
shortest path algorithms
g f r
distributed systems vol
r u r
e d e
runs in time
c f g
f and c
u v v
u i r
mcp f f
j r v
dfg and f
v j r
dfg in fig
delay count d

corpus/krapavin2000-test/1036463.txt
crossing
pcr
drawing
vertices
ow
crossings
nonplanar
bisection
arching
cr
subgraph
ssqd
vertex
leighton
ows
multicommodity
pach
arc
deg
tangled
edge
log
edges
bhatt
terminal
toth
shahrokhi
planar
paths
rounding
expansion
charged
width
cut
hb
vg
commodity
subgraphs
dilation
sup
recursive
circle
cross
ja
fu
witnessing
expander
embedding
unsplittable
valtr
sixtuple
rao
graphs
vlsi
congestion
draw
rst
bounding
induced
degree
ciently
partitioning
arcs
su
partition
plane
uv
randomized
split
nish
drawings
disjoint
degrees
unordered
pairs
lemma
ancestor
subdivision
partitions
embeddings
connecting
drawn
proved
kratochvl
chvatal
commodities
vrt
sykora
babilon
bisections
hereditary
theoremwe
helena
sixtuples
kolman
nyklova
scheideler
fahrad
miserably
crosses
feasible
mn
children
raised
cuts
integral
straight
provably
spencer
cle
matousek
newborn
tth
subarcs
szegedy
schieber
rescale
szemeredi
mohar
maxfd
prague
demand
detour
girth
layout
proofs
weaker
ajtai
seminar
forthcoming
republic
guha
pavel
analogy
maximal
induction
raghavan
czech
nf
transfered
integrality
remark
nished
balancing
path
balanced
passing
ministry
constituting
rescaling
absolute
mesh
separator
segments
algorithmic
improvement
odd
simplies
thompson
nm
layouts
uninteresting
tree
overlooked
nondecreasing
recursively
insist
recalling
bipartite
internal
contradiction
estimating
denition
culties
places
capacity
weight
quadratic
bounds
education
simplied
bounded
nd
leaf
approximations
concurrent
prescribed
injective
improved
removing
charge
participants
ces
theorems
crossing number
pair crossing
pcr g
log n
cr g
edge expansion
bisection width
ssqd g
graph g
nonplanar subgraph
arching pairs
crossing pairs
n vertices
maximum degree
tree vertex
every graph
g 0
multicommodity ow
deg v
k v
circle arc
even et
o 1
ow problem
hb g
recursive drawing
terminal vertex
fu vg
k 3
terminal vertices
randomized rounding
lemma 6
o log
nonplanar subgraphs
common terminal
leighton 2
small nonplanar
drawn along
maximal ow
ow number
tangled pairs
edge fu
optimal drawing
g 2
size o
theorem 4
let g
expected number
log 2
b g
given graph
bounded degree
size log
ja 1
al 3
feasible solution
degree bounded
vertex disjoint
subgraph g
subgraph induced
lower bound
absolute constant
g induced
uniform multicommodity
su ciently
degree graphs
theorem 8
min cut
n log
theorem 1
new graph
planar graph
edge e
possible number
log 3
sup 2
unit capacity
shahrokhi et
rao 8
recursive partitioning
concurrent multicommodity
witnessing pcr
c deg
multicommodity max
pair crossing number
drawing of g
number of crossing
o 1 log
induced by v
drawing of k
bhatt and leighton
k 3 3
number of crossings
even et al
number of edges
pair of vertices
partition of g
cr i g
multicommodity ow problem
terms of pcr
pairs in f
pairs of edges
number of vertices
log 2 n
vertices of g
o 1 n
every graph g
edges in g
pach and toth
minimum possible number
uniform multicommodity ow
edge fu vg
small nonplanar subgraphs
new graph g
pcr i g
vertices with edge
common terminal vertex
edges that cross
paths from p
vertices in g
g of size
maximum degree bounded
ja 1 j
graph into two
leighton and rao
et al 3
proof of theorem
n log n
g in terms
degree of g
p and q
bounded degree graphs
sup 2 sup
n 2 log
graph g 0
subgraph of g
number of paths
technique for provably
paths of p
vertex disjoint edges
approximations of crossings
bounding the crossing
constant degree expander
unit capacity ows
v is drawn
path p uv
crossings of pairs
hb g log
drawing d 0
algorithms and algorithmic
crossing number cr
probability o n

corpus/krapavin2000-test/611399.txt
multipattern
text
automaton
superimposed
string
automata
character
verifications
matching
characters
nfa
patterns
pieces
partitioning
piece
verification
pattern
errors
searching
oe
filter
manber
approximate
matches
word
subpatterns
bit
match
window
ff
muth
subautomata
parallelism
hierarchical
ffoe
gammam
bits
english
plain
search
filtering
sunday
searches
counting
verif
boyer
superimposing
matched
bk
superimpose
rts
shift
arrows
mn
sublinear
moore
diagonals
usefulness
occurrence
patt
gonzalo
jc
counters
searched
exact
ma
plots
substring
rn
mask
superimposition
aloha
filters
experimentally
moderate
truncate
letters
subtract
fastest
diagonal
navarro
dm
classical
count
kuri
josu
pait
cleverly
mcount
active
gammak
optimality
areas
fredriksson
kimmo
ludovic
informaticae
fundamenta
grows
occurrences
verified
masks
kmp
tour
trie
rm
advance
overflow
packing
mismatch
partition
log
asymptotically
bitwise
shifts
intrusion
deterministic
error
alphabet
nondeterministic
separator
decrement
sequential
sequentially
concatenation
bm
horizontal
ffl
halves
position
inspect
grouping
formula
retrieval
verify
faster
limit
fit
worst
grow
speedup
counter
pay
pack
mr
split
megabytes
simulation
bold
gram
deletions
dictionary
pessimistic
keyword
complexities
degrades
inside
kdm
superimposes
yevrus
superimp
apartitioning
aaabbbcccddd
aaabbb
retraverse
tiberio
udi
federica
aho
unrelevant
atsuhiro
aaaaaaaa
progamming
takasu
martoglia
techiques
corasick
surger
lengthly
mandreoli
smarter
ddd
cccddd
rmn
jea
cells
virginia
adapt
verifying
italic
row
triggered
guided
grams
tolerate
parallelization
string matching
approximate string
exact partitioning
computer word
hierarchical verification
single pattern
superimposed automata
multipattern search
r patterns
error level
log oe
bit parallelism
text window
pattern partitioning
bit parallel
english text
text position
text searching
exact searching
many patterns
text character
one error
machine word
muth manber
automaton partitioning
error levels
hierarchical piece
plots show
exact search
gammam 1
multiple approximate
search r
ffoe 1
plain verification
jc errors
piece matched
bk jc
k errors
piece verification
j gammam
complete pattern
multiple patterns
new text
dynamic programming
r 0
approximate pattern
increasing r
r oe
oe m
significant bit
short patterns
superimposed automaton
allowing errors
approximate searching
computer words
matching probability
pattern algorithm
candidate area
zero errors
superimposing automata
matching algorithms
filtering algorithms
boyer moore
length m
pattern length
k characters
pattern matches
complete match
increasing k
o m
log m
o mn
arrows represent
ff r
single search
filter based
search algorithms
text depending
sub patterns
active states
search superimposed
subtract 1
ffl transitions
efficient string
per character
matching fast
diagonal arrows
text areas
mn w
new character
oe log
matching approximate
multipattern exact
k pieces
o 1
pattern matching
search time
classical algorithm
longer patterns
bit mask
character c
gonzalo navarro
approximate string matching
number of patterns
log oe m
number of verifications
algorithm for approximate
new text character
j gammam 1
multipattern search algorithms
bk jc errors
ffoe 1 ff
multiple approximate string
hierarchical piece verification
partitioning into exact
search r patterns
string matching algorithms
approximate pattern matching
ff r oe
character t j
pattern in k
single pattern algorithm
number of errors
characters of p
string matching approximate
optimality and usefulness
bit parallel simulation
english text depending
shift or algorithm
oe log oe
use bit parallelism
partitioning is better
m gamma k
o mn w
bit parallel algorithms
cost of verifications
know which piece
efficient string matching
algorithms for multipattern
string matching fast
theta log oe
error level ff
based on exact
classes of characters
determine which piece
patterns to search
log oe log
algorithm is optimal
text we use
belonging to p
less than 50
algorithm is o
number of bits
based on dynamic
case of multiple
josu kuri gonzalo
based on counting
log oe rm
lower case english
single pattern version
bit of b
pattern p 1
locations in approximate

corpus/krapavin2000-test/633565.txt
cafeobj
institution
behavioural
grothendieck
hosrwl
institutions
rwl
category
cube
morphism
rewriting
specification
morphisms
signature
msa
ntriv
imports
functor
inclusion
module
denotation
triv
nnat
mon
obj
arrows
sentences
equational
exactness
specifications
behaviourally
signatures
sp
indexed
carriers
reduct
homomorphism
mod
liberality
theories
hidden
colimits
protecting
logic
coherent
foundations
elt
fibred
sentence
loose
liberal
sorts
paradigms
sorted
algebra
algebraic
semantics
satisfaction
diaconescu
homomorphisms
ins
logics
methodologies
vars
jij
osa
rzvan
surjections
inclusions
sen
iff
nat
sign
structuring
coinduction
maude
cocomplete
import
parameterised
pow
ole
denotations
categories
ordinary
monoid
embeddings
op
composition
osrwl
jsign
mathematical
arrow
logical
transitions
instantiation
hi
parameterisation
pushout
coherence
rewrite
visible
observational
flattening
abbreviated
pullback
inherited
constructs
regarded
generalises
embeds
preserves
imported
naturals
valuations
embedding
importing
importation
ultraproducts
cha
determinstic
llanos
rincn
strict
lattice
transition
concept
hu
associativity
carrier
weak
expansion
concurrent
equivalence
paradigm
concepts
colimit
mel
initiality
ayala
hsa
surjection
monoids
jargon
hartenstein
shared
operational
ji
verification
language
prototyping
commutativity
conservative
simplification
diagrammatic
formul
meseguer
lax
methodological
injective
trans
sort
conceptual
semantic
notice
idempotence
classical
membership
notably
concrete
concurrency
index
objects
ei
minded
construc
interpretations
familiarity
giving
declarative
morgan
firm
object
crucial
executable
translated
adjoint
interplay
scripts
extra
calculus
modelled
completeness
modules
reconfigurable
informaticae
famous
cafeobj cube
cafeobj institution
behavioural specification
theory morphisms
rewriting logic
inclusion system
grothendieck institutions
indexed institution
theory morphism
algebraic specification
h v
grothendieck institution
module imports
extra theory
basic specification
signature morphism
hidden algebra
weak inclusion
shared approach
indexed category
inclusion systems
z z
order sorted
signature h
hidden sorts
non behavioural
institution independent
grothendieck construction
module system
logical foundations
model m
important r
behaviourally coherent
module import
model homomorphism
cafeobj module
mon pow
theory colimits
hosrwl signature
hosrwl institution
cube institutions
functor mod
initial model
non shared
rzvan diaconescu
module composition
institution embeddings
op ins
behavioural coherence
system hi
proof calculus
signature morphisms
model functor
institution homomorphism
institution homomorphisms
coherent hidden
cafeobj specification
reduct functor
index category
behavioural operations
trans m
behavioural rewriting
basic specifications
structured specification
index morphism
m satisfies
r ole
equational logic
multiple parameters
underlying logic
behavioural equivalence
logical semantics
r r
mathematical foundations
see 12
m 0
behavioural specifications
easily translated
following cafeobj
denotation sp
elt n
parameter instantiation
ordinary theory
hu ji
observational logic
grothendieck category
specification paradigm
proving behavioural
model 0
multiple imports
behavioural equation
institutions definition
model reduct
z z z
foundations of cafeobj
category of signatures
signature h v
extra theory morphisms
r r r
important r ole
weak inclusion system
cafeobj cube institutions
index i 2
category of theories
semantics of cafeobj
coherent hidden algebra
inclusion system hi
specification in cafeobj
specification and programming
specification and verification
behavioural specification paradigm
iff the expansion
part of hosrwl
user defined transitions
module composition system
existence of theory
cafeobj is based
specification of non
result from 11
cafeobj module system
morphism u 2
non shared approach
interpretation of j
index morphism u
context c z
h a 0
play an important
results for equational
functor mod sign
use of behavioural
sorted rewriting logic
actions and observations
cube i e
semantics of behavioural
satisfaction condition holds

corpus/krapavin2000-test/1018452.txt
processors
log
adversary
oracle
crashes
coordinators
failures
alg
balancing
processor
synchronous
failure
prone
tasks
attended
adv
coordinator
pram
crash
message
iterative
passing
load
simulations
unattended
specic
shared
phases
solves
round
omniscient
perfect
denition
alive
stop
bounds
seti
subcases
wn
ciency
shvartsman
rst
dene
teach
fault
rounds
lemma
tolerant
georgiou
chryssis
block
undone
solved
stops
progress
phase
chlebus
tids
jf
extant
doall
bcc
fail
views
restatement
utility
dened
consensus
pid
derivative
stand
adequately
kill
expended
analyses
certified
messages
quantity
leaves
surviving
byzantine
lemmas
matching
memory
pattern
tentative
existed
idempotent
moderate
simulate
pr
faults
tolerating
assess
induction
impossibility
cient
iteration
iteratively
stage
exceed
gathering
abstracts
establishes
task
performing
sent
fragmentable
flp
needlessly
worker
venerable
denitive
refute
pids
tings
homemyampersandmdash
fiterations
scratchpad
delphian
timeprocessor
ces
iterated
alexander
asynchronous
delays
multicast
faulty
dr
sensitive
whp
kills
crcw
unknowingly
dariusz
specics
kanellakis
minates
newest
asynchrony
rescheduling
tight
loads
patterns
deterministic
cooperative
loop
caused
mergeable
rolls
survives
strengthens
martingale
elucidated
supercial
denitions
ideally
idling
kowalski
landscape
ticks
colleague
traversal
eect
crashed
identier
uc
omni
totally
tells
cause
sketch
partitionable
russell
gossip
ine
fernndez
rened
assists
simulating
proceeds
stale
identiers
dissimilar
multiplicities
dependability
log p
p log
p f
log log
work complexity
f log
prone processors
failure pattern
shared memory
f p
n f
o n
algorithm w
load balancing
message passing
perfect load
crash prone
work w
message complexity
log n
algorithm simulations
r log
failures f
n tasks
n log
lower bounds
complete analysis
failure prone
synchronous shared
attended phases
r iterative
block step
block steps
progress tree
balancing assumption
log f
n p
p processors
stop failures
lemma 3
log b
r p
pattern f
local views
adversary adv
wn p
algorithm alg
p n
c p
memory model
passing model
failure free
best known
c log
unattended phases
processor algorithm
phase w3
failure patterns
steps b
memory models
f c
p lemma
b p
u p
one coordinator
n problem
processors perform
upper bounds
work o
memory algorithm
failure model
new bounds
two subcases
log c
r r
n processor
q p
f denote
c 0
cases case
fail stop
matching upper
fail stops
processor steps
undone tasks
n stand
f sensitive
f stop
synchronous processors
passing algorithm
processor crashes
p crash
p failure
f problem
local view
using work
r instances
complexity w
crashes f
theorem 3
r n
n note
p r
e ciency
complexity arguments
processors assigned
p log p
log log p
log p log
log p f
p f log
p log log
r p f
r r p
perfect load balancing
o n f
c p log
f log p
f c p
failure prone processors
p and f
log n log
log b p
f p r
p r log
f p log
b p f
load balancing assumption
crash prone processors
q p f
synchronous shared memory
number of failures
number of processors
shared memory model
execution of algorithm
p lemma 5
f log log
n p log
log p lemma
message passing model
n log p
f the number
shared memory models
log log f
round of r
number of crashes
failure pattern f
log c 0
bounds on work
shared memory algorithm
analysis of work
f p n
c log p
passing and shared
alg that solves
therefore the work
case as o
number of block
two cases case
cases case 1
n r r
analysis of algorithm
unit of work
range of f
number of processor
log log log
r n r
adversary that causes
jf j f
algorithms on failure
p failure prone
message passing algorithm
stop failures f
pattern with f
work complexity w
solved by running
algorithms on crash
u log p
least one coordinator
n f problem
case is b
log n p
failure model f
p log c
p crash prone
f when f
block steps b
o n note
log p therefore
depends on f
failure free processors
wn p f
synchronous message passing
f stop failures
log pr f
n log log

corpus/krapavin2000-test/609461.txt
ber
qam
fading
channel
nakagami
nmf
cnr
adr
capacity
constellation
fl
spectral
rayleigh
channels
adaptive
acr
outage
rate
carrier
modulation
awgn
inversion
db
delay
transmitter
adaptation
multipath
regions
target
wireless
efficiency
bpsk
transmission
received
bits
ora
psk
bandwidth
figs
hz
noise
receiver
power
demodulator
fade
pdf
fb
symbol
mobile
nonadaptive
achievable
transmitted
exp
suffers
alouini
arq
truncated
link
ff
shannon
policies
cutoff
degradation
radio
average
fig
diminishes
penalty
qm
gammafl
policy
feedback
coding
sec
adaption
cnrs
fluctuation
columbia
normalized
degardation
tifr
cifr
opra
dalei
slim
continuous
schemes
perfect
vancouver
omega
agc
modulator
inverts
marcum
british
nth
approx
transmit
bessel
tolerated
diversity
impact
gammam
indoor
communications
bit
plotted
closed
dash
satisfactorily
pilot
thresholds
instantaneous
substituting
iv
rates
urban
budget
ratio
hr
discrete
band
bers
ae
quadrature
wu
proceeding
gaussian
km
reconfiguration
suffer
wired
mohamed
song
slowly
gain
estimation
flat
negligible
compensation
canada
operate
amplitude
complementary
march
solid
varying
ci
qos
expressions
conditioned
exact
responds
gamma
goldsmith
qingwen
geir
configurated
speidel
spectrally
mfl
vegard
sheikh
nyquist
belhaj
rician
sanqi
tives
tdd
hassel
nesrine
ien
gesbert
giannakis
chengzhi
pedestrians
switching
duration
estimator
confirmed
numerical
integral
sounding
mimo
configures
unattainable
fades
shengli
poisson
ms
probability
cross
m qam
spectral efficiency
target ber
average ber
adr m
nakagami fading
time delay
rate m
channel inversion
channel capacity
rate adaptation
constant power
constellation size
average received
fading channel
nmf channels
rayleigh fading
received cnr
variable rate
adaptive m
continuous rate
regions regions
unit bandwidth
link spectral
capacity per
acr m
nmf channel
discrete rate
g db
awgn channel
rate adaptive
fading channels
march 13
received carrier
power variable
adaptive modulation
ber 0
per unit
noise ratio
optimal rate
fixed rate
outage probability
ratio g
per symbol
normalized time
bits sec
optimal power
capacity optimal
ber average
fading m
qam fig
adaptive transmission
truncated channel
average bit
perfect channel
closed form
adaptive 2
channel estimation
fading parameter
qam b
nakagami m
adaptive continuous
achievable spectral
shannon capacity
channel fading
db average
adaptive discrete
bits per
substituting 2
total channel
ber degradation
fl o
b psk
transmit power
c ora
sec hz
qam schemes
feedback path
ber n
exact ber
m distribution
qam scheme
non adaptive
assuming perfect
bit rate
rate optimal
channel conditions
multipath fading
communication system
mobile radio
obtain closed
average link
m n
m 4
power continuous
ratio cnr
power constraint
ber requirement
nonadaptive bpsk
figs 14
qam exact
bandwidth awgn
qam discrete
inversion total
exact average
delay f
switching thresholds
qam adr
qam non
approximation 28
fading regions
db capacity
different adaptive
ber ber
regions capacity
rate transmission
approx adr
regions acr
adaptive policies
capacity penalty
cnr fl
cross layer
different adaption
qam comes
efficiency regions
channel fade
fading decreases
power truncated
qam approx
adaption policies
rate regions
cnr db
inversion fig
adr m qam
rate m qam
power and rate
adaptive m qam
capacity per unit
march 13 1998
carrier to noise
per unit bandwidth
link spectral efficiency
ber of 10
acr m qam
power variable rate
variable rate m
average received carrier
rate adaptive m
normalized time delay
bits per symbol
constant power variable
ratio g db
noise ratio g
continuous rate m
average received cnr
target ber average
truncated channel inversion
regions regions regions
ber average received
adaptive 2 qam
rate and constant
rayleigh fading channel
impact of time
non adaptive 2
adaptive discrete rate
constellation size m
capacity of nmf
nmf channel capacity
bounds the exact
achievable spectral efficiency
g db average
adaptive continuous rate
average bit rate
average link spectral
continuous rate adaptive
ber for m
optimal rate adaptation
m qam schemes
increase in capacity
obtain closed form
discrete rate adaptive
m qam scheme
total channel inversion
inversion with fixed
nakagami fading channel
bits sec hz
probability of outage
assuming perfect channel
discrete rate m
nakagami fading m
number of bits
size m n
performance of adaptive
w bits sec
average ber degradation
qam adr m
channel at time
db capacity per
estimation and negligible
channel inversion fig
spectral efficiency regions
approx adr m
qam approx adr
ber degradation due
m qam adr
received cnr db
qam non adaptive
regions regions capacity
qam over nmf
qam discrete rate
cnr db capacity
capacity optimal rate
power truncated channel
bandwidth awgn channel
db average bit
regions regions acr
constant power continuous
m qam comes
nakagami fading channels
channel inversion total
target ber 0
different adaption policies
channel capacity optimal
n a positive
b psk fig
m qam fig
flat fading channel
inversion total channel
regions capacity optimal
channel capacity c
exact non adaptive
rate optimal rate
qam exact non
negligible time delay
nakagami fading parameter
nakagami m distribution
time delay f
regions acr m
power continuous rate
capacity optimal power
bit rate regions
qam b psk
m qam discrete
constant power truncated
perfect channel estimation

corpus/krapavin2000-test/607200.txt
penl
enl
nl
outliers
dataset
disk
array
block
blocks
internode
outlier
buffer
processors
reciprocal
mining
bsp
count
arrays
minptsub
cheung
hung
counts
calculations
pages
objects
superstep
unmarked
reads
synchronization
dimensionality
percents
fill
reading
swap
barrier
distance
lof
pnp
ready
quadratic
object
node
exports
money
page
database
np
counter
neighborhoods
bulk
processor
mark
staying
card
repeat
besides
temp
evenly
passes
comp
nications
nearest
communication
neighbor
supercomputer
outperforms
workstations
communications
read
nearly
va
fraud
names
accessing
interconnected
parallelize
filling
commonalities
kn
detection
comparisons
density
dimensions
year
items
loaded
calculation
neighbour
waves
please
temporary
synchronous
electromagnetic
mine
marked
improvement
pp
cluster
datasets
spatial
satellite
commodity
send
reverse
minor
transferred
quantum
costs
association
execution
threads
neighbourhood
kong
databases
resident
credit
ibm
neighborhood
clustering
arrangement
targets
nested
memory
commerce
dist
theroretical
orginal
comparions
hksar
domestic
lied
supersteps
excep
hifh
breunig
athletes
architetures
knorr
commuication
amost
loadleveler
cpenl
fraction
transferring
sequential
discovery
studies
identification
cell
message
proximity
disks
ratio
categories
served
enhanced
passing
buffering
criminal
cx
first array
second array
blocks reads
o time
block reading
based outliers
internode communication
local disk
computation cost
execution time
non outlier
reading order
large database
nl algorithm
parallel mining
dataset size
set counter
second arrays
minptsub nearest
computation time
neighbor node
distance d
two arrays
m mark
bsp model
increase count
read required
dataset passes
local memory
density based
o communication
buffer size
distance based
performance studies
penl algorithm
third array
report unmarked
np p
unmarked objects
algorithm penl
computation operations
ready blocks
blocks loaded
three arrays
distance calculations
nearest neighborhoods
original nl
major cost
communication time
total number
communication network
synchronization time
count m
counter c
processor number
processors ffl
parallel algorithm
data mining
theoretical analysis
node 0
local block
otherwise mark
algorithm nl
nothing system
temp buffer
parallel bsp
passes is4
order swap
kn 2
local blocks
blocks staying
percentage change
bsp computer
change percentage
va file
nearly evenly
calculations actually
count j
penl using
disk i o
number of objects
number of processors
outliers in large
number of calculations
mining of outliers
block reading order
hung and cheung
nl and enl
number of pages
number of blocks
swap the names
distance based outliers
amount of memory
marked as done
total of 2
minptsub nearest neighborhoods
fill the second
objects in first
report unmarked objects
fill the first
arrays and repeat
number of dataset
density based outliers
array is marked
names of first
table of comparisons
count m mark
array as outliers
block of objects
compared to first
cost is quadratic
send the data
blocks the total
first and second
spatial data mining
o kn 2
object t j
n ae pnp
change percentage change
done state 2
j is unmarked
array if object
local block number
temporary minptsub nearest
state 2 fill
dataset passes is4

corpus/krapavin2000-test/633577.txt
geolev
adaboost
leveraging
margin
learner
arcing
master
weak
geoarc
boosting
descent
margins
hypotheses
hypothesis
jjh
jjdjj
sample
steepest
sin
gradient
breiman
angle
jjhjj
schapire
bagging
jj
learning
potential
orthant
learners
gammarf
confident
predictions
cone
template
iterations
recurrence
ff
direction
singer
rated
confidence
training
freund
normalized
leverager
learnability
wrapper
flipping
mlc
predictors
feasible
iteration
datasets
rim
classifiers
coefficient
arc
incomparable
amortized
delta
sign
normed
sine
generalization
bounds
leibler
boost
uci
conversion
kullback
wrapped
flip
continuing
classification
outlined
geometric
pac
minimized
derivatives
voting
dependence
tangent
negative
cos
repository
labels
logitboost
olev
drifting
atsch
undifferentiable
gentile
ffh
aboost
eurocolt
geoboost
error
divergence
gradients
games
vectors
sees
normalizing
edge
lie
majority
weighting
normalizations
tapers
trains
abstain
gression
divergences
zoutendijk
exponentiated
fooled
unsatisfying
inscribed
fits
lemma
quinlan
hinted
unnormalized
strengthens
jagota
penalizing
convergence
viewed
transformation
empirical
intuition
yoav
warmuth
warranted
manfred
ameliorate
resampling
monotonic
additive
vector
mildly
comparably
leverages
learnable
differentiates
confidences
mason
multiplying
creates
convert
seek
abe
navigating
halving
preliminary
modified
ip
equally
decrease
wrapping
normalization
decision
insight
intriguing
bers
committee
diminishing
arun
label
constrained
likelihood
potentials
claudio
guessing
wise
noting
decreases
contributing
flips
discriminant
tracked
cancel
instructive
friedman
minimizing
corollary
logistic
prediction
ran
effectiveness
proportional
bounding
complication
weak learner
master hypothesis
leveraging algorithm
potential function
margin vector
leveraging algorithms
hypothesis h
weak hypothesis
arcing algorithms
sample error
margin space
weak learning
distribution d
steepest descent
feasible direction
gradient descent
potential functions
margin vectors
master hypotheses
sin 2
jj 2
jjdjj 1
geolev algorithm
arcing algorithm
goal vector
weak hypotheses
negative components
geolev geoarc
arc x4
h 0
low confidence
coefficient ff
positive orthant
delta h
direction d
equally confident
amortized analysis
confidence rated
new master
hypotheses produced
boosting algorithms
confidence predictions
second transformation
jjhjj 2
error rate
generalization error
components therefore
polynomial learnability
modified sample
vector g
iterations required
training error
vector h
d delta
learning algorithms
negative gradient
zero sample
approximate gradient
class classification
hypotheses produce
natural potential
direction gradient
node decision
recurrence 22
breiman 5
geoarc may
geoarc algorithms
template outlined
produces hypotheses
bounds indicate
plane p
algorithm geolev
gammarf delta
learner produces
new weak
adaboost algorithm
theoretic generalization
leveraging process
singer 15
rated predictions
yields sin
valued hypotheses
large margins
decision taken
weak learners
boosting property
improved boosting
weighting d
hypotheses contain
d 0
jjh t jj
master hypothesis h
direction of steepest
geolev and geoarc
learner s hypotheses
sample error rate
angle between g
sample s 0
low confidence predictions
new master hypothesis
angle between h
goal vector g
weak hypothesis h
jj 2 1
weak learning algorithm
distribution d 0
schapire and singer
learner s hypothesis
leveraging algorithms include
direction gradient descent
improved boosting algorithms
master hypotheses produced
situation in margin
boosting algorithms using
decrease the angle
generated by weak
h delta h
weak hypotheses contain
algorithms using confidence
boosting a weak
new weak hypothesis
feasible direction gradient
angle to g
application to boosting
r and jjhjj
pac learning algorithms
better than adaboost
fits the template
d delta h
r 2 terms
breiman 5 4
y i h
geolev s bound
natural potential function
confidence rated predictions
decision theoretic generalization
approximate gradient descent
correct and equally
weak learning method
zero sample error
gammarf delta d
bounds are incomparable
first t iterations
geolev to achieve
negative components therefore
margin vectors lie
cos 2 0
weak learner produces
many low confidence
incomparable to adaboost
algorithm by majority
using confidence rated
h to h
leveraging algorithm based
component of h
used by geolev
margin vector h

corpus/krapavin2000-test/614386.txt
tetrahedra
multiresolution
mesh
rendering
sigma
dataset
warping
curvilinear
datasets
tetrahedral
tetrahedron
visualization
tetrahedrization
isosurface
volume
convex
decimation
simplification
meshes
lod
vertex
refinement
delaunay
vertices
omega
buckyball
tetra
irregular
approximated
multires
tan
lifting
accuracy
bluntfin
resolution
progressive
birth
dvr
gui
sites
tot
oe
accuracies
pt
deltar
subsampling
graphics
isosurfaces
historical
boundary
patches
2d
death
collapse
extractor
gamma
client
3d
polyhedron
module
opacity
terrain
interactive
incident
triangulations
hexahedron
surface
surfaces
hexahedra
sgi
wavelet
windowing
piped
submodule
regular
bucketing
extraction
covering
field
representations
visualized
warped
hybrid
triangulation
extracted
apriori
marching
coincident
hexahedral
geometries
che
hamann
lying
manage
triangles
polyhedra
triangular
cells
resolutions
facets
modality
cell
irregularly
heuristics
iv
face
bernd
ffl
interactively
depth
interpolation
openinventor
tetrahedrize
cracks
floriani
translucent
lods
baricentric
xforms
tetrahedrizations
hull
performances
block
transfer
simplified
physical
theta
image
blocks
unstructured
adopting
collapsing
datum
error
iteratively
adopted
occupancy
wavelets
terrains
splatting
leila
subcomponent
graphic
piecewise
scalar
lifted
levels
geometry
discontinuities
inserted
post
topographic
joy
hoppe
isovalues
adjacent
window
contrary
visualizing
ram
projected
decomposition
indigo
electron
parallelepiped
warranted
warrant
simplicial
warrants
subsampled
maximises
orientation
public
inside
inserting
spatial
approximation
scopigno
ws
complexes
file
cubes
spanned
editing
prepared
hardly
fig
supports
cignoni
triangulated
rectilinear
mt
simplices
estimate
inconsistent
multiresolution model
non convex
data simplification
curvilinear datasets
mesh sigma
tetrahedral mesh
volume data
historical sequence
hybrid rendering
irregular datasets
convex curvilinear
sigma c
volume rendering
tetrahedral meshes
tetrahedron oe
convex irregular
convex datasets
multires model
direct volume
omega c
isosurface patches
tot tetra
delaunay tetrahedrization
model tot
computational domain
volume dataset
approximated model
mesh gamma
refinement algorithm
refinement procedure
omega gamma
transfer function
approximated hybrid
block decomposition
curvilinear case
pt algorithm
domain omega
multiresolution extractor
deltar v
volume visualization
theta 32
point v
vertex v
regular datasets
multiresolution models
full resolution
modeling module
tan system
warping increase
convex case
depth order
approximated mesh
tetrahedra incident
edge collapse
lod representation
decimation algorithm
progressive rendering
rendering modality
inside oe
multiresolution visualization
physical space
oe c
reference model
hexahedral mesh
multiresolution data
bucketing structure
multiresolution representation
curvilinear dataset
gamma c
visualization system
dimensional case
data points
see figure
sigma 1
boundary vertex
different resolutions
construction algorithm
initial mesh
computational space
physical domain
isosurface rendering
data structure
sample points
maximum among
isosurface extraction
maximum warping
datasets sample
space omega
datum v
multiresolution rendering
interactive phases
e sigma
low lod
current mesh
images refer
non convex curvilinear
direct volume rendering
points of v
non convex irregular
model tot tetra
multires model tot
boundary of sigma
vertices of gamma
error and warping
levels of detail
deltar v w
convex irregular datasets
approximated hybrid rendering
birth and death
color and opacity
volume visualization system
representations at different
convex curvilinear datasets
mesh sigma c
tetrahedral mesh sigma
model is built
number of tetrahedra
blocks of size
sites of sites
warping and error
point of v
adjacent to v
tan v 2
standard surface graphics
mesh at full
example in 2d
block decomposition refinement
lies inside oe
dataset which represents
set of tetrahedra
domain omega gamma
based on refinement
select min vertex
tetra no sites
mesh at accuracy
sigma see figure
multiresolution data structure
accuracy 1 0
dataset at different
tetrahedra and isosurface
datasets sample points
based on data
hull of v
case of curvilinear
currently under implementation
smaller than ffi
three dimensional case
theta 32 theta
visualization of volume
based on tetrahedral
conference on visualization
case the point
number of sites
two dimensional case
v is called

corpus/krapavin2000-test/627724.txt
authorizations
authorization
tab
tabext
administrative
inst
derivation
ext
temporal
privilege
administer
instant
revoke
sam
csd
instants
ha
tmax
rules
endfor
hobjecti
hsubjecti
sdel
granted
aslongas
dred
friends
hopi
revokee
ptab
insertion
parametric
materialization
grantor
samarati
discretionary
whenevernot
pn
mode
privileges
endcase
hl
bertino
materialized
pierangela
haccess
modei
ins
appearing
deletion
endif
object
denials
matt
interval
jim
hx
lev
intervals
gig
atluri
auth
levels
negation
access
critical
rule
ferrari
request
dependency
elisa
deny
elena
chris
te
tissec
inserted
bob
sins
vijayalakshmi
sandhu
bettini
arity
negative
semantics
ground
ap
operator
logic
ticket
requests
authorized
catalogs
security
deleted
modes
maintenance
recomputing
permissions
revocation
exercise
ti
valid
priority
gammag
sushil
granting
jajodia
xml
delete
grant
dbms
endwhile
symbol
validity
symbols
users
uniqueness
max
ffl
mesiti
mizuho
revokeref
hpastopi
parisi
refi
revoking
hgrant
presicce
autho
xinwen
admi
iwaihara
jaehong
hrevoke
revoker
somchai
silvana
grantadm
revokeadm
chatvichienchai
hopian
chutiporn
anutariya
absence
administration
john
gi
castano
wuwongse
versioned
revoked
vilas
expires
read
ann
interpretation
inferences
subject
relevancy
subrahmanian
securing
avigdor
yorktown
explicit
fn
spans
gal
disjoint
technologies
returned
dependencies
specifying
deductive
updated
capabilities
update
repeat
op
affecting
adam
francesco
returns
claudio
stating
false
else
predicate
denial
policies
initialized
stratification
specification
derivation rules
inst tab
access control
temporal authorization
temporal authorizations
tab u
access mode
derivation rule
derived authorizations
authorization model
critical set
valid authorizations
u ext
csd algorithm
negative authorizations
time interval
positive authorization
negative authorization
parametric derivation
administrative operations
administer privilege
interval associated
positive authorizations
explicit authorizations
read sam
dred ext
authorization base
authorizations appearing
sam friends
ground derivation
check levels
function dred
administrative privileges
set detection
administrative authorizations
materialized authorizations
unique model
discretionary access
pairs ha
max level
refer privilege
top level
time instants
access modes
o m
materialization approach
haccess modei
pierangela samarati
authorization rule
administrative authorization
among authorizations
temporal capabilities
new authorizations
rules r
unique set
rule r
level l
b te
time intervals
evaluation order
access request
access authorizations
john o
temporal dependency
pn g
sequence hx
m pn
function update
inserted authorization
authorizations upon
strict dependency
authorization pattern
intervals representing
definition 2
logic program
o 1
r 3
case op
b t e
authorizations and derivation
tab u ext
authorizations and rules
time interval associated
set of valid
appearing in inst
parametric derivation rules
instant t 0
function dred ext
derive a 1
critical set detection
discretionary access control
rule t b
authorization t b
ground derivation rules
authorization is granted
set of time
rules r 1
e a k
follows definition 2
o m pn
function check levels
states that user
execution of administrative
access control model
tuple s o
o 1 read
modei on hobjecti
authorizations in tab
models and technologies
hobjecti from hsubjecti
temporal authorization base
m pn g
set of authorizations
algorithm for critical
hobjecti to hsubjecti
parametric derivation rule
given a tab
symposium on access
valid at time
algorithm 6 1
x t b
access control models
access control policies
based access control
transactions on information
information and system
security tissec v
system security tissec
set of derived
m on object
pairs ha ti

corpus/krapavin2000-test/627934.txt
te
temporal
oid
instant
chimera
dom
salary
nontemporal
instants
attribute
employee
expressions
expression
manager
lifespan
inst
dole
navigational
legal
path
division
terminal
object
ar
attributes
intervals
query
relational
oriented
mary
correctness
denoting
static
assignment
immutable
dependents
proposition
fh
equality
ins
valued
slice
ig
status
weak
languages
formalized
database
accesses
interpretation
qualifier
official
printers
joins
boolean
implicitly
semantics
undefined
shorthand
name
join
identifiers
history
gadia
daplex
statically
lesser
referring
subclass
string
symbolically
declared
oi
quel
belongs
interval
ensuring
historical
notions
sql
formalism
correct
car
superclasses
typing
consistency
strong
identifier
employees
instantaneously
databases
existed
objects
instances
modality
querying
signature
language
frontiers
restriction
composing
evaluated
multimedia
corollary
belonged
hsql
lif
appendixes
tquel
defintion
ootempsql
croker
valuedness
espan
hrdm
ttype
reviseted
temporality
weakly
equalities
item
member
inheritance
names
deduced
interpretations
investigate
navigations
oids
lifespans
snodgrass
nair
sapino
adali
members
imposed
record
specification
verified
vals
postulated
earned
postfix
clifford
ascribed
dering
subrahmanian
notion
checked
instantiated
satisfied
recursively
dangling
explicitly
disjoint
predefined
syntax
stated
sublanguage
headed
gove
inductive
devoted
navigates
bnf
migrated
abstracta
referential
presentations
pointer
recorded
characterizing
classes
aiming
flavors
rules
implicit
specified
assignments
evaluates
qualify
salvatore
peculiar
distinction
classical
collapsed
appearing
managers
premises
path expression
path expressions
temporal expression
te te
oid assignment
dom e
time instants
object oriented
instant valued
temporal expressions
temporal object
two path
te e
simple path
e e
time intervals
terminal path
mary dole
temporal path
first instant
static attribute
temporal value
temporal attributes
temporal context
query languages
time instant
instant te
e dom
last interval
te dom
attribute name
correctness conditions
type e
type correct
salary mary
valued temporal
fh ig
salary 40k
temporal interpretation
ar e
expression equality
current time
specific class
oriented query
data model
expressions denoting
boolean expressions
correct path
oriented data
navigational approach
class history
static attributes
manager employee
attribute whose
temporal values
inst slice
navigational accesses
last instant
temporal types
manager 50
slice te
e te
te first
object belongs
employee temporal
legal oid
attribute access
inst inst
te last
te n
attribute accesses
dole salary
either explicitly
value equal
data models
expression denotes
dom dom
x last
temporal query
conditions ensuring
temporal data
query language
relational data
o v
value denoted
e ar
implicit joins
history lifespan
structured types
ig fh
te type
last te
valued r
legal values
object denoting
interval first
official car
value equality
division salary
status full
temporal type
temporal relational
first te
te inst
legal assignment
weak value
strong interpretation
symbolically denote
full time
ar ar
assignment two
oriented model
lifespan class
division 20
oriented database
boolean expression
recursively defined
oriented databases
thus denoting
set of time
simple path expression
e a e
two path expressions
temporal object oriented
e a te
te te te
e e e
terminal path expression
e dom e
temporal path expression
salary mary dole
path expression equality
e a dom
instant valued temporal
object oriented query
object oriented data
set of chimera
correct path expression
valued temporal expression
temporal path expressions
attribute whose value
simply a shorthand
notion of temporal
path expression denotes
path expressions denoting
mary dole salary
dom e dom
e e te
x last interval
oriented query languages
e te te
classes of example
expression is evaluated
following are examples
object oriented database
defined as follows
expression is correct
status full time
expressions of example
lifespan class history
fh ig fh
history lifespan class
interval first instant
assignment two path
class history lifespan
legal oid assignment
object oriented model
first instant te
te dom e
terminal path expressions
te type e
class the object
last instant te
inst slice te
oid assignment two
last interval first
dom e e
te inst slice
type correct path
ig fh ig
instant te inst
instant valued r
dom dom dom
te first instant
analysis of path
assignment is correct
slice te n
manager 50 division
assignment is legal
notions of equality
te e v
object oriented databases

corpus/krapavin2000-test/629425.txt
keys
pg
sorting
snake
multiway
sorted
merge
subsequences
zeroes
batcher
bruijn
petersen
shuffle
subgraphs
subgraph
odd
hamming
columnsort
dirty
bitonic
sequences
sort
product
networks
hypercube
subsequence
dimension
hamiltonian
exchange
transposition
merging
dimensions
dimensional
asymptotic
mesh
torus
homogeneous
routing
mct
gray
grid
dilation
asymptotically
permutation
network
products
ary
sorters
slowdown
exchanged
prefixing
diameter
bisection
congestion
erasing
vertex
concatenation
emulation
leftmost
parberry
uth
symbol
trees
rows
cleans
running
merges
interconnection
consecutive
cube
sorts
filled
position
de
subnetworks
parker
node
column
positions
labels
rightmost
ux
row
transpositions
adjacent
interleave
versatile
connected
predecessor
symbols
grids
differ
graphs
area
concatenated
reading
recursively
hung
columns
hypercubes
recursive
merged
weight
referring
array
rm
embedding
cycle
emulations
pgr
fundemental
shuffles
drysdale
schnorr
sortings
lisza
logarithmic
brackets
vertices
organization
tuple
tuples
biing
crcw
tsung
kunde
spokes
dimensionally
aks
hypercubic
routings
shyan
reintroducing
chyun
reconciling
situation
completion
log
generalized
partly
shaded
unreasonably
prams
flies
adaptative
yuh
bounded
tori
bz
pictured
inserting
simplifies
aggarwal
cleaning
curly
butter
leighton
folded
clarification
papers
dividing
white
divide
yung
shamir
resp
developing
shan
cleared
ku
puters
tighten
tolerant
nodes
instances
randomized
delta
window
width
identifies
euromicro
alternates
ting
bo
kai
product networks
pg r
snake order
dimensional product
multiway merge
sorting algorithm
n r
r dimensional
r keys
odd even
pg k
sorted sequence
dirty area
r gamma1
product network
sorted sequences
homogeneous product
de bruijn
shuffle exchange
p g
merge sorting
merge algorithm
o r
r node
running time
sorting n
dimension 1
pg 2
n sorted
dimension 3
mesh connected
u p
merge process
v pg
asymptotic complexity
dimension 2
sort n
even transposition
q r
sequence d
hamming weight
r gamma2
connected trees
batcher algorithm
permutation routing
gray code
two dimensional
sorting network
sorting networks
subsequences b
even merge
factor graph
ary gray
n subsequences
n time
node r
r 2
u v
g subgraph
bruijn networks
initial situation
petersen graphs
petersen graph
single sorted
sequence j
dimensional torus
sorted order
log 2
o n
product graph
node shuffle
length n
sorting algorithms
g r
code sequences
exchange networks
merge operation
time complexity
vertex labels
k gamma2
r tuple
n node
hamming distance
n ary
n rows
c j
graph g
n 2
n sequences
node de
exchange network
subsequence b
congestion 2
one principle
bruijn network
code sequence
dimensions f1
compare exchange
group sequence
leftmost position
subgraphs u
unit hamming
step 3
use u
recursive call
asymptotically optimal
n r keys
o r 2
n r node
u p g
multiway merge algorithm
complexity of sorting
b i j
dimension 3 dimension
r dimensional product
sort n r
r node r
node r dimensional
merge sorting algorithm
u v pg
p g r
pg r gamma1
n sorted sequences
sorting n r
n 2 node
odd even transposition
number of dimensions
mesh connected trees
number of zeroes
sorted in snake
homogeneous product networks
zeroes and ones
dimension 1 dimension
log 2 n
length n 2
odd even merge
v pg k
single sorted sequence
steps of odd
n 2 keys
sequence of keys
pg k 1
ary gray code
de bruijn networks
sequences of length
factor graph g
two dimensional product
n ary gray
multiway merge sorting
pg 2 subgraphs
exchange or de
product of petersen
g r gamma1
r dimensional torus
gray code sequences
keys on pg
node shuffle exchange
even merge sorting
algorithms for product
v p g
r 2 n
shuffle exchange networks
b u v
see figure 7
q 2 1
products of de
de bruijn network
sorted sequence j
product of de
sequences c j
j can differ
node 2 dimensional
bruijn networks 9
sorting on pg
r 2 log
node de bruijn
dimensional product network
possible to sort
sequence c j
shuffle exchange network
dimensions f1 2g
merge sorting network
p g 3
dimensional product graph
properties of product
sequence d obtained
dimension 2 dimension
unit hamming distance
bruijn or shuffle
zero one principle
m n figure
gray code sequence
homogeneous product network
n subsequences b
r is bounded

corpus/krapavin2000-test/627922.txt
inverted
documents
document
hhnl
hvnl
vvm
file
collections
similarities
vvs
hhs
os
textual
collection
join
simulation
wsj
hvs
entries
increment
theta
multidatabase
job
backward
pages
hvr
resumes
read
scan
held
resume
similarity
applicants
attributes
doe
bhhs
joins
query
outer
descr
scanned
fr
entry
intermediate
files
memory
estimated
retrieval
incurs
bhvs
fcompute
title
formula
performer
accommodate
simulations
integrity
fif
binghamton
hhr
subcollection
ds
ir
queries
unprocessed
storing
scans
processed
minfg
ssn
batch
participate
ascending
cell
ff
dsm
save
reading
engineer
lets
sequentially
schema
selectivities
obligations
text
inner
observations
festimate
obiav
vvr
cells
sequential
verifying
email
group
relational
outperform
accumulating
descriptions
bytes
selections
smart
impact
zsoyolu
forward
collected
buffer
integrated
packed
accumulated
frequency
accessed
page
occupies
statistics
database
vocabularies
consecutive
motivating
tightly
storage
definitely
reviewers
ucla
formulas
sql
cpu
unlikely
entirely
likely
brought
outperforms
lowest
originally
comparator
scanning
fraction
edu
former
occurrences
track
reaches
largest
np
random
positions
counterpart
accommodated
reserve
records
none
disadvantage
policy
pq
noticeable
submitted
iri
sm
accumulate
fewer
automating
chicago
selection
norms
department
avg
comparing
tread
selma
aye
sengr
inverted file
file entries
algorithm hhnl
theta theta
algorithm hvnl
algorithm vvm
file entry
document collections
backward order
document collection
memory space
intermediate similarities
o cost
two collections
outer collection
textual attributes
real collections
collection c2
inverted files
two document
forward order
one collection
term numbers
b tree
using formula
simulation results
real collection
corresponding inverted
simulation 13
distinct terms
m documents
theta vvs
cost hhs
largest similarities
job descriptions
inner collection
hhs 3
two inverted
intermediate similarity
simulation 8
optimal order
one scan
similarity values
processing joins
x documents
collection use
simulation 7
job descr
job description
vvs 4
ir systems
collection c1
integrated algorithm
multidatabase system
available memory
three algorithms
much memory
also appears
large enough
consecutive retrieval
storing intermediate
simulation 19
entirely held
global schema
p title
textual type
compute hvs
hvr theta
hhs using
zero similarities
compute bhhs
similar observations
memory buffer
one document
mapping structure
new collection
whose corresponding
three real
term matrix
document d
non zero
new inverted
ascending term
inverted file entries
theta theta theta
documents in c2
inverted file entry
result of simulation
number of documents
documents in c1
document in c2
random i os
process the join
two document collections
entries on c1
changes from 10000
increment of 5000
corresponding inverted file
total i o
theta theta vvs
o cost hhs
intermediate similarity values
cost hhs 3
number of terms
space as possible
changes from 5
theta vvs 4
vvs 4 figure
random i o
three real collections
much memory space
sequential i os
increment of 5
use as much
enough to hold
compute the similarities
hhs using formula
attributes of textual
results in group
non zero similarities
using the inverted
hhs 3 hvr
hvr theta theta
likely to perform
needed to process
document term matrix
algorithms for processing
enough to accommodate
performance of algorithm
bhhs compute hvs
appears in c1
whose corresponding inverted
p job descr
documents in one
input document collections
two inverted file
ascending term numbers
documents from one

corpus/krapavin2000-test/631169.txt
timing
cache
wcet
instruction
wcta
reservation
pipelined
block
misses
caches
pipeline
miss
risc
wcets
schema
tail
references
reference
hits
struct
interference
worst
rd
instructions
md
wctas
processors
hit
alu
overestimation
analyzer
phi
head
execution
loop
pruned
pruning
live
program
blocks
preempted
seongsoo
preemptive
scenario
accurately
succeeding
retargetable
sp
fig
exp
friedhelm
ferdinand
engblom
jakob
ermedahl
stappert
preceding
processor
policy
calculating
compile
constructs
overlapped
lyul
wmin
fidge
lee
preemption
assembly
tasks
benchmark
board
mapped
surrounding
mips
cycle
contents
scheduling
intra
prediction
max
tight
concatenate
sang
revised
timer
wp
inherits
pipelining
notices
fetched
addresses
cached
sheayun
roychoudhury
procedurally
abhik
whalley
xianfeng
harmon
jungkeun
wilhelm
dongkun
theiling
acsr
ffi
nov
memory
calculated
arc
overlap
sigplan
kim
path
nop
jihong
concatenates
opcode
fpu
minsoo
tulika
rectify
paths
ranges
mm
programs
associative
statement
predicted
prune
limitation
calculation
schneider
tables
safe
loose
andreas
christian
formula
accurate
estimation
effects
burst
lw
hazards
colin
ryu
gmez
accesses
ij
predicting
analyzing
ansi
variation
cycles
loaded
hayes
reinhard
displaced
timers
superscalar
compiler
static
enumerates
henrik
tighter
accounted
tool
ignoring
resumes
div
dirty
mitra
concatenation
predictions
chip
suffers
voltage
stage
write
automation
analytical
weight
refine
associativity
null
task
stack
bounds
liu
shin
bb
ian
longest
infeasible
delay
penalties
program construct
first reference
case execution
timing information
timing schema
timing analysis
execution path
pipelined execution
reservation table
cache block
last reference
instruction block
execution time
worst case
timing formula
wcet bounds
real time
data caches
cache memory
risc processors
time systems
struct pipeline
cache timing
w 2
basic block
memory block
cache miss
pipeline cache
phi operation
original timing
execution scenario
case timing
timing tool
w 1
timing analyzer
program constructs
reservation tables
loop statement
write back
cycle mean
maximum cycle
timing effects
preceding program
extended timing
proposed technique
wcet analysis
execution times
write access
live ranges
task interference
succeeding program
intra task
information w
alu rd
references whose
case scenario
instruction cache
pipelined processors
basic blocks
cache contents
memory blocks
cache misses
time bound
data cache
timing variation
revised timing
history sensitive
ffi tail
loop timing
block address
call graph
w 3
simple time
execution paths
preemptive scheduling
benchmark programs
analysis technique
compile time
b 4
instruction references
path p
p j
instruction caches
set associative
direct mapped
weighted directed
cache hits
b 2
timing behavior
cache partitioning
ffi head
write run
pipelining effects
whose hits
schema approach
timing abstraction
wp n
accurately accounted
program syntax
mean weight
pipelined processor
timing variations
md fig
jakob engblom
write accesses
two reservation
one cache
block addresses
back policy
friedhelm stappert
andreas ermedahl
wcet estimation
christian ferdinand
wcta wp
block fetched
differ depending
measured execution
worst case execution
case execution path
real time systems
case execution scenario
cache timing information
execution and cache
reference to b
pipeline cache timing
original timing schema
struct pipeline cache
d i j
worst case timing
hits or misses
maximum cycle mean
extended timing schema
time systems v
analysis of data
timing information w
effects of pipelined
succeeding program construct
reference and last
case execution time
sequence of instructions
loop timing analysis
simple time bound
bit is set
analysis of pipelined
timing information associated
preceding program construct
revised timing schema
wcets of tasks
rd if md
mean of g
weighted directed graph
case timing analysis
systems v 17
references whose hits
instruction block references
best case scenario
schema the timing
within a maximum
history sensitive nature
timing schema approach
burst of cache
instruction block addresses
write back policy
path not necessarily
wcta wp n
write through policy
reference i else
accessed in w
case timing abstraction
timing analysis technique
measured execution times
exp s 1
scenario for w
inter task interference
two reservation tables
due to write
reference i w
cache simulation approach
path that might
worst case scenario

corpus/krapavin2000-test/1040306.txt
mapkey
haskell
arrayelem
declarations
declaration
translation
judgement
dictionary
arrayrep
constructor
arr
cmapkey
int
array
lookup
indexed
mk
functional
dependencies
generic
siek
typing
garcia
traits
overloading
inst
ml
mapint
mappair
lumsdaine
target
hinze
optimising
akin
superclasses
jones
library
libraries
indexint
erent
peyton
parametric
sigplan
map
td
jeremy
overloaded
classes
jaakko
cls
intensional
dictionaries
notices
datatype
judgements
chakravarty
simon
evidence
witness
pairarray
duck
newtype
sulzmann
lookupdict
refm
jeremiah
jrvi
unboxed
adata
willcock
formedness
forall
parameterised
arrays
di
typed
signatures
translated
keller
pgm
brr
gabriele
qualified
translating
polymorphism
patricia
declara
rules
vanilla
harper
erasure
optimisation
instantiation
andrew
ref
manuel
vertex
val
container
synonyms
template
mb
constructors
modules
maps
fresh
reis
duggan
prj
stroustrup
cheney
dmappair
defaultarray
bjarne
curried
vertexes
uintarr
newref
syntax
dependency
mp
instances
indexing
io
self
mentions
signature
generalisation
neubauer
scrap
overbar
decl
stuckey
polymorphic
instantiations
mi
ma
gregor
specialised
generics
parametrised
bool
interfaces
environment
arguments
comparative
source
subtlety
dos
translates
extra
translate
monad
templates
runtime
index
keys
notational
construc
language
constraint
soundness
ar
nice
selector
oh
gabriel
boost
formalise
dependence
default
java
checking
douglas
abstraction
clutter
roman
omitted
style
martin
abstract
elaborated
generalised
proposal
kind
hm
mu
tiny
tricky
er
guarded
compiler
programmer
motivating
saturated
validity
tor
associated type
associated types
type classes
data type
type indexed
associated data
functional dependencies
instance declarations
data types
generic programming
evidence translation
indexed types
type environment
type translation
instance declaration
type class
class parameters
array e
system f
garcia et
map k
type system
type parameters
class declaration
data map
class mapkey
arrayelem e
type variable
type declarations
top level
type parameter
data array
dictionary environment
type map
type array
element type
instance mapkey
value declarations
self optimising
finite maps
type variables
type constructor
type analysis
generic haskell
target language
type must
indexed data
data constructor
class arrayelem
ml modules
andrew lumsdaine
e arr
target term
jeremy siek
source types
optimising libraries
key type
map int
typing rules
di erent
class d
int e
simon peyton
graph library
acm sigplan
level data
intensional type
peyton jones
notices v
translation judgement
type indexing
associated top
template library
mapkey b
language akin
generic finite
explicitly typed
b lookup
abstract interfaces
mapkey int
sigplan notices
type declaration
functional dependency
target types
array example
parametric type
type checking
new type
manuel m
standard type
haskell type
value type
et al
well formedness
type directed
k v
instance environment
type synonyms
mi d
data vertex
typed target
multi parameter
arr int
type cmapkey
v lookup
data edge
jeremiah willcock
jaakko jrvi
array type
dictionary function
k mi
d patricia
e array
extra type
hoc overloading
martin sulzmann
new datatype
default definition
lookupdict k
b mapkey
representation type
b mp
lookup k
ma mb
type erasure
target declarations
checking rules
arrayelem class
target terms
formedness judgement
refinement kinds
patricia lookupdict
gabriele keller
associated data types
type indexed types
associated data type
garcia et al
associated type environment
type indexed data
data type declarations
indexed data types
support for generic
b where data
top level data
self optimising libraries
map k v
intensional type analysis
data type declaration
simon peyton jones
sigplan notices v
acm sigplan notices
generic finite maps
haskell s type
data type must
parametric type classes
associated top level
type translation judgement
target language akin
haskell type classes
m t chakravarty
explicitly typed target
well formedness judgement
d patricia lookupdict
lookup k mi
e array e
patricia lookupdict k
type of d
akin to system
lookupdict k d
mapkey b mapkey
type map k
k mi d
lookup a b
element type e
type checking rules
associated type array
mi d patricia
type indexed type
associated type synonyms
applications of associated
array e int
k where data
int where data
mapkey a b
e int e
mapkey a mapkey
typed target language
ad hoc overloading
must be parameterised
notices v 40
given in figure
translation of type
programming in c
notices v 41
v 40 n
v 41 n
mappair ma mb
key type k
used in rules
introduce type indexed
class mapkey k
source term e

corpus/krapavin2000-test/606717.txt
spai
multigrid
smoothers
coarsening
smoother
smoothing
seidel
gauss
amg
sparsity
grid
sparse
inverses
diusion
interpolation
convergence
preconditioners
inverse
coarse
approximate
preconditioner
damped
jacobi
pq
frobenius
algebraic
uences
anisotropic
ilu
coarser
dierential
eective
rotating
stuben
grids
mg
ow
preconditioning
priority
dependencies
mak
convection
robustness
geometric
diagonal
norm
ruge
equispaced
gridsize
huckle
anisotropy
galerkin
convergent
prolongation
dependency
discretization
pp
shall
locally
inherently
weakly
qq
di
rates
denite
operators
ki
mesh
cult
entries
stencil
iteration
grote
preconditionings
uh
residual
squares
priori
adaptivity
symmetric
unstructured
interplay
strong
hackbusch
prolongations
benzi
cheap
interpolated
ve
nest
boundary
stencils
agglomeration
adjusted
matrix
triangular
green
correction
promising
coarsest
satises
ll
tang
denser
xed
neighbors
aligned
factorized
diverges
weak
culty
heuristic
dened
tolerance
solver
smooth
laplacian
expert
pattern
inherent
comparative
levels
usefulness
greedy
proceeds
row
interpolating
mpi
numerical
splitting
scalability
cient
smoothed
siam
elliptic
approximates
nonzero
culties
conguration
frequency
dominated
sorted
parallelize
multilevel
classical
prescribed
dierences
wan
controls
cycle
agonal
benson
undecided
smoo
decient
mccormick
lently
thers
computersmyampersandmdash
stben
riority
beowulf
wesseling
frederickson
upwinding
tuma
meurant
candidates
nite
parallelism
densities
hierarchy
strongly
conjugate
dier
ciently
circles
strategy
tends
greatly
powers
ciency
lu
eth
nev
couplings
cosity
ertheless
spai 0
spai 1
approximate inverse
sparse approximate
gauss seidel
approximate inverses
algebraic multigrid
coarse grid
sparsity pattern
spai algorithm
multigrid iteration
q m
c points
coarsening strategy
f points
damped jacobi
spai smoothers
convergence rates
inverse preconditioners
geometric multigrid
seidel smoothing
rotating ow
frobenius norm
m q
smoothing property
inverse m
algebraic coarsening
locally anisotropic
multigrid methods
sparsity patterns
m h
inherently parallel
coarsening algorithm
anisotropic diusion
grid selection
h k
x k
grid levels
c point
ow problem
ki mak
smoothers spai
table amg
improved robustness
amg convergence
coarsening goal
smoothing steps
f point
y h
multigrid method
grid correction
point p
unstructured grids
classical smoothers
geometric mg
weak dependencies
spai smoothing
semi coarsening
interpolation operators
xed sparsity
local adaptivity
inverse smoothers
seidel 0
frequency behavior
multigrid v
v cycle
m gauss
eective sparsity
multigrid solver
non expert
convergent multigrid
f splitting
smoother q
ilu smoothing
two grid
smoothers based
symmetric gauss
seidel spai
c dependency
rates q
via sparse
strong dependency
di cult
partial dierential
positive denite
parameter free
grid method
smoothing step
smooth error
priori sparsity
inverse preconditioner
approximation property
convergence rate
least squares
k th
inherent parallelism
o diagonal
remain bounded
row m
rates obtained
high frequency
coarser level
squares problems
overall complexity
linear systems
d q
greedy heuristic
dierential equations
algorithm proceeds
q 2
linear system
diagonal smoothers
denser m
problem 12
property 15
inverse smoother
sparse approximate inverse
pattern of m
m q m
q m q
sparse approximate inverses
approximate inverse preconditioners
gauss seidel smoothing
approximate inverse m
spai 0 2
rotating ow problem
coarse grid selection
spai 1 smoother
y h k
locally anisotropic diusion
x x k
smoothers spai 0
spai 0 spai
table amg convergence
algebraic coarsening strategy
number of multigrid
g x x
coarse grid correction
smoothers for multigrid
green s function
m h k
convergence rates q
multigrid v cycle
gauss seidel spai
eective sparsity pattern
symmetric gauss seidel
convergence rates obtained
high frequency behavior
smoother q m
approximate inverse smoothers
gauss seidel 0
spai 0 smoother
q m gauss
convergent multigrid iteration
c f splitting
m gauss seidel
seidel spai 0
two grid method
approximate inverse preconditioner
o diagonal entries
m of m
unknown a priori
k th row
partial dierential equations
least squares problems
o n log
n log n
cost of computing
pq 6 0
xed sparsity patterns
ilu smoothing matrix
jacobi or gauss
spai algorithm 13
performance of spai
dierent dependencies possible
spai the sparsity
ruge and stuben
weight a pq
strong dependency dependency
points are represented
matrix and preconditioning
squares problem 12
via sparse sparse
exceed o n
determines the coarse
minimize ki mak
parallel algebraic multigrid
dependency c point
spai 0 3
frobenius norm naturally
point f point
tang and wan
inverse preconditioners robustness
amg convergence results
inverse preconditioners via
approximate sparsity patterns
original spai algorithm
spai 1 smoothers
smoother gauss seidel
via the spai
coarsening goals 1

corpus/krapavin2000-test/1018405.txt
adv
counterexample
discrepancy
res
comm
airdepth
disc
inputs
suc
assertions
assertion
rectangle
circuit
product
circuits
resource
depth
units
xor
strong
fair
kr
weather
kd
protocols
decision
trees
lemma
fairness
forests
guessing
amplification
bits
protocol
hardness
forest
tensor
communication
rectangles
nisan
hard
repetition
yao
norm
erent
wigderson
spectral
imbalanced
kc
disjointness
xk
direct
orest
spending
computable
boolean
attempting
intuition
matrix
coordinates
core
proving
sided
item
ciently
bit
beneficial
raz
stronger
randomness
leaf
supposed
matrices
pseudorandom
players
unbiased
av
black
fraction
remark
unavoidable
contradict
gcd
di
vectors
inequality
plugging
su
intuitively
cd
queried
glance
eigenvalue
parnafes
multiplicativity
leafs
repetitionmyampersand
cbit
smartly
impagliazzo
kthis
strengthenings
supposes
eigenvalues
coin
lot
heads
generators
tree
outputs
correctly
products
expectedly
rudich
qk
trapdoor
evan
unfairly
concatenation
restrictions
formulation
exclusive
correlating
contra
schwartz
conversations
probability
corollary
variant
imposing
setup
probabilistic
theoretic
proofs
cherno
unnatural
ruled
avi
countless
box
induction
restriction
roughly
distributional
airs
activates
induces
draw
resources
attempts
unpleasant
tempted
insures
unaware
advisor
correlate
unpublished
padding
flaw
existence
seems
preparing
textbook
unbalanced
unfair
coins
absolute
simplify
nice
quantity
impose
defects
ks
lemmas
impressive
weaken
fk
direct product
strong direct
product assertion
product assertions
decision trees
adv comm
communication protocols
r units
compute f
f k
product theorem
depth d
bit communication
low discrepancy
f airdepth
res r
communication complexity
decision tree
c bit
product question
communication protocol
hard core
xor lemma
suc res
comm c
fair decision
parallel repetition
boolean circuits
spectral norm
product results
adv res
repetition theorem
k decision
hardness amplification
tensor product
computes f
given r
probabilistic communication
rectangle r
computational models
sided discrepancy
suc size
fairness restriction
strong product
adv size
hard given
product problem
airdepth kd
negative coordinates
given slightly
function f
di erent
function 0
h y
fact 1
functions computed
proving strong
advantage greater
general counterexample
random guessing
computed correctly
d 1
u v
k times
lemma 4
one sided
fact 2
ask weather
assertion holds
depth kd
forest model
adv depth
stronger computational
easy given
decision forest
made formal
item note
optimal direct
adv f
weak randomness
k adv
amplification techniques
algorithm attempting
decision forests
r kr
discrepancy using
erent inputs
r su
help bits
comm kc
previous calculation
kr units
unbiased bits
average given
strong direct product
direct product assertions
direct product assertion
hard on average
denote the class
direct product theorem
c bit communication
direct product question
f is hard
given r units
fair decision trees
yao s xor
parallel repetition theorem
attempting to compute
prove a strong
direct product results
bit communication protocol
function 0 1
proof of lemma
probabilistic communication complexity
c a d
bit communication protocols
slightly more units
theorem for fair
resource and easy
attempts to compute
adv comm c
item of fact
f airdepth kd
proving strong direct
greater than p
compute f k
direct product problem
one sided discrepancy
hard given r
larger than r
matrix with entries
trees of depth
x 1 x
number of inputs
compute the function
d 1 d
family of functions
computes f k
entries in 1
result of prw97
words the circuit
bound the discrepancy
weather a strong
size s f
strong product assertion
weather an input
k decision trees
di erent inputs
computations on di
adv f airdepth
assertion for f
spending a lot
f airdepth d
generally what kind
easy given slightly
conclude that adv
assertions are true
average to algorithms
nisan and wigderson
r su ciently
product assertion hold
kind of restrictions
let f airdepth
communication protocols 1
d k decision
dependence on c
supposed to compute
technique of raz
conclusions for specific
f has low
probability of heads
uses its resource
measures how imbalanced

corpus/krapavin2000-test/635794.txt
discretisations
nonconforming
nite
multigrid
stokes
discretisation
smoothing
mesh
grid
spaces
nodal
functionals
solvers
gmres
cell
crouzeix
raviart
fk
convergence
cells
piecewise
dened
prolongation
braess
sarazin
nest
bilinear
smoother
conforming
averaged
disc
navier
transfer
elliptic
simplicial
regularity
multi
smoothers
korn
mixed
coarser
satises
lr
dierent
eciency
quadrilaterals
residue
nc
grids
pressure
quadrilateral
solver
coarse
lowest
rened
nonsymmetric
triangulation
norm
element
barycentric
prolongations
neighbouring
saddle
triangulations
rates
exible
discontinuous
satised
freedom
renement
residual
dene
renements
mappings
operator
symmetric
analysed
triangles
correction
preconditioned
projector
ane
numerical
rot
levels
nested
ka
equations
mod
brezzi
magdeburg
babuska
cku
zulehner
divergence
degrees
rst
coecient
triangular
boundary
pd
nk
suciently
discrete
reduction
bb
mortar
midpoints
riesz
uzawa
ckd
ecient
variational
geometrical
kh
wj
subscrpt
cycle
child
contraction
mapping
preceding
solvability
hierarchy
behaviour
velocity
spectral
schur
euclidean
inequality
cf
2d
modied
ak
fullled
reference
coecients
isomorphisms
approximation
sup
denite
vanishing
jn
jk
analysing
onto
md
iteration
dierential
ch
mg
inf
validity
outer
benchmark
arising
coupled
inner
von
discretization
multilevel
fe
regular
transforming
prescribed
duality
norms
matrix
usual
gulations
possion
conditioners
rannacher
msm
guericke
motive
discretely
ellipticity
decribed
conditioner
nite element
v l
multi grid
u l
l 1
multi level
q l
order discretisations
level method
mesh level
l k
order nonconforming
element spaces
transfer operator
element discretisations
error reduction
l l
l u
nodal functionals
averaged error
cell k
level solvers
p l
smoothing steps
stokes equations
nonconforming nite
lowest order
two level
higher order
new l
reduction rates
spaces v
stokes problem
smoothing property
u new
p mod
general transfer
k u
finite element
example 4
b k
element space
multigrid methods
crouzeix raviart
mixed problems
reduction rate
grid methods
local nodal
level solver
multigrid method
basis functions
space v
l p
grid method
p nc
k 2
level independent
raviart element
standard multi
nonconforming discretisations
disc mesh
reference cell
basic iteration
l 2
coarse level
pre smoothing
nite elements
lr b
w cycle
approximation property
low order
navier stokes
non nested
space l
discrete problem
nonconforming finite
regularity property
nonconforming piecewise
braess sarazin
gmres method
fk 2
point problems
exible gmres
grid solvers
level correction
dierent discretisations
level l
piecewise linear
nite number
independent constant
child cells
levels l
piecewise constant
level 0
present numerical
constant functions
u j
preceding section
f l
k h
space q
b l
bilinear form
u p
linear element
velocity spaces
system 13
grid level
coupled multigrid
sarazin type
discretisations based
additional projection
projection step
operator u
q rot
valued basis
korn inequality
pd 1
mesh cells
cells k
nonconforming low
type smoother
saddle point
nite dimensional
space b
level approach
e k
problem 6
nite element spaces
higher order discretisations
multi level solvers
averaged error reduction
v l 1
spaces v l
two level method
l k u
k u l
error reduction rates
l p l
q l 1
l u l
space v l
multi level method
lowest order nonconforming
cell k 2
l u new
u new l
u l l
nite element space
local nodal functionals
multi grid methods
nite element discretisations
error reduction rate
multi level solver
finite element discretisations
general transfer operator
l l p
multi grid method
element spaces v
p l 1
l 1 l
d 1 2
new l k
crouzeix raviart element
methods for nonconforming
order nonconforming discretisations
nonconforming nite element
lr b k
disc mesh level
navier stokes equations
pre smoothing steps
u l 1
l k h
p l k
example 4 1
degrees of freedom
nonconforming finite element
space q l
solution of 13
b k k
l q l
p l p
l is obtained
nonconforming piecewise linear
piecewise constant functions
method for nonconforming
level independent constant
multi grid solvers
coarse level correction
saddle point problems
l 1 q
low order nonconforming
problem 6 7
theorem 2 1
u j 1
prolongation and restriction
present numerical results
l l k
l 1 v
multi level approach
example 4 4
nonconforming nite elements
reference cell b
independent constant c
sarazin type smoother
pd 1 2
l 2 stability
piecewise linear element
eciency of multi
standard multi grid
piecewise linear functions
low order discretisations
discretisations of mixed
order nonconforming low
vector valued basis
q l respectively
additional projection step
multi grid hierarchy
fk 2 lr
nonconforming low order
dierent nite element
valued basis functions
shows the averaged
braess sarazin type
l and l
l l u
obtained by transforming
l and q
u f l
conforming and nonconforming
nite dimensional space

corpus/krapavin2000-test/626842.txt
ring
hot
request
processor
latency
utilization
contention
outstanding
spot
transaction
topologies
banks
station
traffic
hector
cache
rings
locality
saturation
cluster
packet
theta
cycle
branching
efficiency
cycles
memory
workload
blocking
packets
topology
utilizations
reads
prefetching
block
slotted
module
processors
rate
spots
localities
multiprocessors
simulator
word
exposed
ml
queue
tradeoff
misses
levels
speeds
remote
hierarchy
retries
stall
doubtful
target
transfers
memories
rates
favorite
hit
plots
unidirectional
miss
page
sci
synchronization
mode
batch
probabilities
coherence
modules
dram
multiprocessor
clusters
hierarchical
saturate
bank
strobe
tango
multicomputer
versus
interfaces
questionable
inter
shared
communication
simulating
interconnection
prototype
degradation
multithreaded
crossbar
multithreading
network
interface
stations
root
response
validated
fetched
hiding
accesses
sibai
halfwidths
cyberplus
fadi
teraflop
ultracomputers
favoritism
rxmy
ratio
consistency
synthetic
factors
compensate
batches
significance
prohibitively
agarwal
writes
controller
limiting
migrations
drop
offered
ranges
coherent
loads
mem
cause
connections
bottleneck
ksr
alpha
hardware
addressing
hierarchies
near
disadvantage
subtransaction
replications
realism
hide
increased
traverse
saturates
distributing
workloads
load
simulation
contexts
varied
transactions
advantageous
standards
requesting
realistic
causes
tend
traversed
bandwidth
concurrency
caches
access
examine
sensitive
patterns
committee
improvement
congested
percentage
scalable
ends
chose
completes
extent
transfer
percent
read
varying
substantially
queues
dec
retry
sharply
imposes
request rate
ring utilization
theta theta
transaction latency
maximum ring
outstanding transactions
hot spot
communication locality
processor efficiency
memory banks
cycle time
ring cycle
target memory
processor cycles
memory cycle
blocking reads
request rates
multiple outstanding
inter ring
branching factors
page mode
cluster 1
non blocking
ring based
memory utilization
mean remote
memory saturation
spot memory
multiple memory
block size
branching factor
ring interface
mode access
root ring
spot traffic
memory queue
base system
cluster 2
first word
contention free
theta figure
workload model
ring levels
hierarchical ring
ring hierarchy
ring utilizations
l request
versus request
traffic patterns
rate b
hot spots
u l
shared memory
ring topology
ring cycles
source processor
favorite memory
processor module
e request
response packet
cache miss
processor cycle
hit ratio
cache misses
memory contention
workload parameters
remote transaction
processing module
memory latency
cache hit
traffic pattern
memory probabilities
request packet
plots efficiency
larger branching
ring saturation
ring contention
communication localities
locality model
r u
cache coherence
memory access
one memory
maximum number
processor stall
memory bank
hot memory
hardware contexts
best topologies
reads block
scalable coherent
target station
stall ends
ring interfaces
large branching
b 33
multiple hardware
coherent interface
level workload
three traffic
per processing
l e
system performance
x r
limiting factor
memory module
overall system
block transfers
ring connections
local ring
processor modules
station controller
efficiency versus
banks per
increasing efficiency
maximum transaction
synthetic workload
cycle times
memory multiprocessors
per processor
software cache
rate 0
memory consistency
level 1
experiments indicate
c l
maximum ring utilization
theta theta theta
number of outstanding
non blocking reads
multiple outstanding transactions
multiple memory banks
memory cycle time
hot spot memory
hot spot traffic
ring cycle time
x r u
page mode access
request rate b
theta theta figure
r u l
versus request rate
u l request
l request rate
cache hit ratio
mean remote transaction
m a x
remote transaction latency
e request rate
c l e
number of levels
cluster 1 probabilities
cluster 2 size
inter ring interface
maximum ring utilizations
one memory bank
overall system performance
scalable coherent interface
hierarchical ring based
cycles between cache
per processing module
three traffic patterns
processor stall ends
multiple hardware contexts
ring and memory
favorite memory probabilities
b 33 theta
inter ring connections
rate b 33
memory and maximum
memory banks per
request rate 0
maximum transaction latency
larger branching factors
system and workload
level 1 ring
rate for different
memory and ring
number of processor
shared memory multiprocessors
number of memory
rate of 0
processor cycle time
reaches the processor
software cache coherence
f c e
somewhat larger branching
higher request rates
u l topologies
level workload model
l e request
one outstanding transaction
different t values
utilization and maximum
outstanding transactions per
per memory module
increasing the block
synthetic workload model
concurrency and contention
page mode dram
adaptive maximum number
efficiency versus request
l a y
y c l
number of ring
plots efficiency versus
f f c
communication locality model
effect on efficiency
source processor module
access strobe line
transactions and non
mode dram access
take prohibitively long
increase in ring
communication locality changes
memory bank per
use of page
large branching factors
would take prohibitively
low level workload
transactions per processor
degree of communication
near the hot
ring based systems
simple node interfaces
exposed transaction latency
increase in order
c e request
tradeoff between concurrency
shared memory multiprocessor

corpus/krapavin2000-test/627095.txt
polynomials
irreducible
jhj
primitive
aliasing
degree
misr
jhjn
lfsr
jhju
polynomial
faults
feedback
lcm
log
factors
gcd
gf
compacting
register
division
circuit
jhjd
bist
ra
pg
prime
primitivity
lfsrs
exhaustive
ras
pgs
factoring
factor
response
ep
signature
divisors
delta
procedures
erroneous
deg
irreducibility
fault
jhjm
ljj
worst
sift
tried
candidate
bounds
lemma
product
cut
circuits
degrees
drawing
modeled
flops
iff
complexities
ttm
jhjl
candidates
conducted
fields
dominant
finding
reconfigurable
flip
responses
ranged
jm
divisor
compacted
chakrabarty
smallest
outputs
variance
es
divides
rj
gammaj
took
draw
distinct
da
divide
hayes
sequences
registers
fh
multiplication
roots
compaction
cell
phases
shift
collapsing
dlog
mapped
selections
stuck
experiments
ran
looking
mm
md
operands
try
millions
selecting
aforementioned
tens
ascending
bits
configured
novk
hlawiczka
jhjt
sifts
nosek
uber
onhage
charakteristik
tlog
compactor
zassenhaus
gcds
dalog
minfbd
multiplikation
adleman
remaindering
ierardi
lcms
schnelle
ljm
plva
jhje
pomeranz
polynomen
garbolino
gucwa
orpern
jmd
logarithmic
seconds
referred
tm
pre
logarithm
logic
factorization
ob
stage
abstractwhen
misrs
2dlog
breuer
lengthen
dividend
cantor
alently
premium
sifting
redundant
oe
saved
mod
error
thousands
expected
non factor
zero aliasing
o jhj
primitive polynomials
irreducible primitive
feedback polynomial
least degree
degree j
log log
polynomials g
primitive case
degree non
jhj log
degree less
expected bounds
jhj 2
expected complexity
primitive polynomial
irreducible factors
primitive non
irreducible polynomials
good response
error polynomials
procedure distinct
irreducible case
d h
distinct factors
o jhju
jhju 2
distinct irreducible
gf 2
m d
work required
specified degree
smallest degree
aliasing misr
log jhj
aliasing polynomial
modeled faults
random polynomials
worst case
log q
expected bound
m n
exhaustive search
degree 11
log jhjn
non factors
error sequences
degree d
log d
delta log
test sequence
log jhjd
feedback polynomials
lcm method
primitive feedback
aliasing lfsr
primitive candidate
primitive zero
expected work
primitive factors
log n
o u
expected degree
p d
u 2
relatively prime
case complexity
pre specified
expected number
degree 9
effective polynomial
es h
jhj polynomials
degree irreducible
log 2te
m jhjn
degree m
gcd method
ep h
compacting function
experiments found
jhj delta
case bounds
minimum degree
finite fields
shift register
polynomial division
u log
least integer
polynomials h
dominant term
practical test
degree l
corollary 11
polynomials of degree
g i j
degree non factor
least degree non
o jhj log
finding a non
o jhj 2
primitive non factor
factors of degree
factor of degree
irreducible primitive polynomials
factors of h
find a non
log log q
factor of h
jhju 2 m
set of polynomials
zero aliasing polynomial
jhj 2 n
o jhju 2
zero aliasing misr
irreducible primitive polynomial
pre specified degree
number of faults
polynomial of degree
number of irreducible
case and o
u 2 m
irreducible and primitive
jhj log jhjd
complexity of procedure
u 3 m
log log d
distinct irreducible factors
procedure distinct factors
find a zero
primitive zero aliasing
zero aliasing lfsr
find an irreducible
q 2 08
d i j
worst case complexity
complexity of finding
number of primitive
worst case bounds
h is bounded
j is less
expected work required
n 2 u
primitive feedback polynomial
o u 2
log log 2te
factors of g
phase is o
bounded by o
p d h
number of polynomials

corpus/krapavin2000-test/628814.txt
cherno
silvey
nuisance
asymptotic
snr
distances
sensor
lrt
leibler
kullback
ali
target
sec
tank
coe
recognition
targets
likelihood
detection
quantizers
gaussian
compressed
truck
cients
sensors
noise
miss
compression
image
hypothesis
coder
coders
transform
quantization
hypotheses
orientation
concave
lindeberg
mixture
imagery
quantized
lossy
favorable
detector
convex
imaging
theoretic
wavelet
thermodynamic
bounds
distributions
priors
tractable
radar
statistical
noisy
probability
distance
prior
ji
composite
scene
dissimilarity
inequality
multisensor
unquantized
ratios
intractable
pdf
variability
ln
tightness
attractive
unknown
ary
testing
remote
fig
di
modeled
figs
additivity
monte
ch
ratio
expressions
involving
additive
orthonormal
corrupted
infrared
variate
tight
entropy
carlo
images
spikes
tance
degradations
measures
classification
bit
db
analytically
equality
cient
central
integrals
minimax
rigid
clean
exp
template
angles
zone
clutter
strengthened
pixel
bayesian
realizations
identically
multiplicative
signal
error
erent
rates
alarm
proposition
convexity
invertible
worst
simplifies
jensen
deformations
asymptotically
expectation
optimality
nonlinear
simulations
qualified
orientations
formulated
evaluated
approximations
conditioned
covariance
energy
probabilities
flir
vasudevan
cher
deadzone
advantageously
imagers
analytics
lavanya
calumet
kassam
dwelled
lanterman
shaikin
quantizer
urbashi
decompressed
unbeatable
noncoherent
civilian
tanks
category
estimation
dead
ds
quantities
exponent
approximation
templates
mass
conditional
ects
decreasing
dr
statistically
marginals
hyperspectral
thermo
marcum
curran
trucks
bhattacharyya
reemphasize
usion
neyman
systematic
poisson
scalar
coherent
p e
target recognition
ali silvey
cherno distances
kullback leibler
nuisance parameters
likelihood ratio
p miss
detection problem
leibler distances
hypothesis testing
sec 2
sensor noise
coe cients
target detection
sensor data
cherno distance
error p
asymptotic approximation
d p
information theoretic
sec 5
log likelihood
sec 6
c d
d gaussian
recognition performance
compressed data
upper bound
transform coe
hypotheses h
likelihood ratios
composite hypothesis
l ji
silvey distances
theoretic distances
recognition problems
asymptotic expressions
image data
h 0
truck imagery
least favorable
noisy sensor
nuisance parameter
cherno bound
average approximation
silvey class
testing problem
p f
detection performance
bit rates
known target
detection problems
l c
problems involving
h 1
cients c
m ary
independent components
hypothesis test
hypothesis h
bit rate
scalar quantizers
ary hypothesis
binary detection
involving nuisance
error rule
approximation 35
lossy compression
expression 21
optimal lrt
bound 14
gaussian sensor
silvey distance
binary hypothesis
asymptotic expression
snr 8
distances provide
miss p
performance measures
distance d
performance bounds
limit theorem
central limit
average distance
theoretic bounds
automatic target
ratios l
mixture distribution
minimum probability
statistical models
system parameters
proposition 7
detection algorithm
cherno bounds
carlo simulations
see sec
gaussian noise
p 0
coe cient
possible targets
gaussian data
provide upper
upper bounds
lower bounds
d d
d h
sec 3
compression algorithm
prior distribution
convex function
d i d
probability of error
data i d
kullback leibler distances
l c d
cherno and kullback
error p e
ali silvey distances
information theoretic distances
leibler and cherno
ji i d
composite hypothesis testing
hypothesis testing problem
bounds on p
transform coe cients
ali silvey class
d s p
decreasing and c
sec 2 4
cients c d
log likelihood ratio
bound on p
d p 0
coe cients c
proposition 7 1
c d d
ali silvey distance
tank and truck
probability of miss
involving nuisance parameters
target recognition performance
d gaussian sensor
log likelihood ratios
bounds on target
target recognition problems
approximation to p
noisy sensor data
likelihood ratios l
distances in 11
gaussian sensor noise
binary detection problem
c is concave
m ary hypothesis
asymptotic expression 21
asymptotic approximation 35
miss p miss
central limit theorem
modeled as random
see sec 2
distance d p
discussed in sec
sec 5 1
automatic target recognition
information theoretic bounds
d are independent
probability of false
dissimilarity between two
sec 2 2
provide upper bounds
monte carlo simulations
optimal lrt detector
miss and p
simple hypothesis testing
illustrate the theory
p i d
along with noisy
expectation under hypothesis
bounds on ali
lrt in 4
d gaussian noise
erent noise realizations
j i d
upper bound 42
presence of nuisance
bounds on detection
exp snr 8
whether a known
classification of multiple
sec 6 3
worst where worst

corpus/krapavin2000-test/628087.txt
trigger
triggers
sting
sub
region
cells
spatial
cell
attribute
mining
leaf
insertion
updates
deletion
nmin
expand
density
shrink
tq
attr
query
composite
dist
miles
cellular
monitor
shr
phones
squared
update
regions
tqmax
mile
boundary
event
clause
phone
insertions
subtriggers
events
database
suspended
hierarchy
neighbors
conf
ffi
accumulated
exp
geominer
reallocation
statistical
incremental
recalculated
area
triggered
children
obsolete
nu
active
deletions
location
shade
posted
period
evolved
suspend
bandwidth
distance
neighborhood
pyramid
qualified
bold
cpu
forwarded
warehousing
clusters
qmax
objects
calculated
handling
adjacent
ts
proximity
consumed
del
grid
market
employs
databases
interior
cluster
action
ffin
outside
satisfied
predicates
attributes
shaded
satisfaction
cause
theta
smin
recalculate
erage
confidence
joins
evolves
outstanding
placed
removed
deadline
root
enters
granularity
hierarchical
threshold
deleting
primitive
contour
dimension
aggregate
cycles
incrementally
mined
gammat
intermediate
normal
efficiently
fired
upgrade
prototype
queries
decreased
emergency
awareness
clustering
ahead
continues
overhead
users
focused
variance
notified
scenario
shape
func
actions
predicate
phase
select
av
ins
pk
calculate
nb
status
levels
evolving
bottom
accommodate
facilitate
specified
dark
track
movement
complicated
fourth
adjust
iff
consumes
deemed
updated
expensive
fulfillment
whenselect
usting
dedale
eighteen
sub triggers
sub trigger
leaf level
trigger condition
insertion sub
expand sub
deletion sub
spatial data
level sub
data mining
level cell
level cells
shrink sub
density sub
composite event
trigger evaluation
ffi trigger
statistical information
composite events
attribute ffi
attribute sub
attribute condition
original region
attribute trigger
cellular phones
squared miles
become true
intermediate level
result r
select clause
per squared
boundary distance
conf l
squared mile
accumulated amount
use per
distribution type
least 10
within r
total area
non spatial
insertion deletion
triggers set
sting employs
active spatial
level insertion
size region
interior boundary
c 44
density condition
attribute values
cellular phone
hierarchical structure
cpu cycles
query processing
mining triggers
fixed region
trigger trigger
level deletion
children cells
u attr2
defined triggers
active period
calls distance
fourth phase
attribute conditions
defined trigger
updates occur
r ts
region trigger
range 100
user defined
example 3
cells within
distance calls
update occurs
query result
spatial databases
average number
distance larger
region query
higher levels
might cause
bottom level
active data
spatial data mining
insertion sub trigger
level sub triggers
expand sub triggers
deletion sub trigger
leaf level sub
density sub triggers
leaf level cell
leaf level cells
number of leaf
area at least
deletion sub triggers
expand sub trigger
triggers are set
insertion sub triggers
attribute sub triggers
shrink sub triggers
amount of updates
number of objects
trigger is set
attribute ffi trigger
per squared mile
use per squared
intermediate level sub
shrink sub trigger
number of sub
sub triggers set
area in range
active spatial data
make the trigger
condition to become
least 10 cellular
used to monitor
condition is satisfied
event in e
user defined trigger
leaf level deletion
e s occurs
calls distance larger
user defined triggers
level sub trigger
distance calls distance
leaf level insertion
leaves the region
categories of triggers
level insertion sub
triggers are used
larger than 100
density and attribute
active data mining
cause the trigger
range 100 1
set of composite
level deletion sub
data mining triggers
condition on certain
miles with total
number of updates
types of sub
long distance calls
time t 1
statistical information associated
statistical information grid
trigger is defined
clause example 3
children at level
evaluate the trigger
sub triggers expand
sub triggers associated
triggers are placed
range 50 1
handling a sub
m s min
set on cells
triggers and expand
triggers and deletion
joins the region
cells within r
least 10 squared
non spatial attributes
updates on attr

corpus/krapavin2000-test/609228.txt
powerdomain
security
pers
secure
st
jck
binding
semantics
noninterference
powerdo
flow
equivalence
command
leino
hh
probabilistic
powerdomains
slam
termination
commands
joshi
jhh
denotational
strictness
nondeterminism
snd
equational
volpano
interpretation
denotations
semantic
soundness
denotation
extensional
confidentiality
confidential
nondeterministic
theta
sabelfeld
leak
analyses
relations
zdancewic
sigplan
notices
flows
lapadula
programs
jp
convex
projection
anindya
polymorphic
strict
andrei
imperative
mains
calculus
static
specification
behaviours
correctness
iff
deemed
sensitive
ipo
conditio
mastroeni
lubs
egli
declassification
isabella
giacobazzi
quotienting
interpreta
denning
benton
milner
isomorphic
idempotent
financial
hoare
ker
dependencies
leakage
launchbury
kleisli
mads
axiomatic
lift
evaluations
program
dependency
nontermination
downgrading
chalmers
clarifies
possibilistic
banerjee
projections
treatment
dam
hunt
forgetting
myers
compositional
lattice
language
composition
lattices
operational
nonterminating
threaded
smyth
steve
id
instrumented
pow
equiv
relational
subtyping
powerset
secrecy
plotkin
integrity
jb
untrusted
concurrent
den
polymorphism
smith
inclusion
roberto
style
nick
abstract
arguments
deterministic
unwanted
unifies
ning
interference
sequential
degrees
fi
encryption
bell
reflecting
observer
trust
subsets
inspired
finitely
partial
jc
functional
vary
sound
reflexive
cunningly
hankin
etayer
mantel
giambiagi
indiction
publicdomain
oteborg
leonor
goo
formali
trusting
fandrei
rbaek
cheol
preoreder
justifica
jbks
security condition
information flow
equivalence relations
secure information
high theta
binding time
theta low
security properties
probabilistic powerdomain
time analysis
per d
command c
partial equivalence
powerdomain semantics
p st
equational security
jck c
convex powerdomain
termination sensitive
security type
slam calculus
low high
low security
information flows
per model
program c
based security
upper powerdomain
type high
calculus hr98
jhh k
projection analysis
probabilistic security
equivalence relation
security levels
high part
type system
higher order
high low
log file
sequential programs
partial evaluation
order functions
acm sigplan
notices v
g ffi
per based
powerdo main
partially confidential
concurrent language
per p
powerdomain interpretation
lower powerdomain
anindya banerjee
correctness arguments
probabilistic semantics
security types
powerdomain p
powerdo mains
relational semantics
ker c
flow properties
theta id
andrei sabelfeld
sigplan notices
jp j
semantics based
static analysis
abstract interpretation
ffi f
strictness analysis
imperative language
steve zdancewic
non interference
theta st
high security
one must
denotational semantics
constant function
computer security
flow analysis
program analysis
e d
let us
security analysis
nondeterministic choice
joshi lj98
alternative semantic
variables h
power domain
termination insensitive
g subsets
command b
bottom reflecting
den ning
jc 1
high variable
security half
security conditions
thus able
powerdomain 1
static arguments
discrete powerdomains
mads dam
c myers
sensitive security
discrete powerdomain
representing degrees
roberto giacobazzi
analysis hs91
l st
domain st
secure iff
secure information flow
binding time analysis
high theta low
partial equivalence relations
high and low
low high theta
theta low high
leino and joshi
equational security condition
c is secure
value of h
higher order functions
sigplan notices v
acm sigplan notices
properties of higher
r 2 per
choices of powerdomain
degrees of security
information flow properties
use of pers
slam calculus hr98
model of secure
information flow analysis
based security condition
function in st
type high low
g ffi f
denote the relation
h and l
value of l
notices v 39
partially confidential data
jck c b
based formal specification
sequential programs based
choice of powerdomain
induced discrete powerdomain
roberto giacobazzi isabella
discrete powerdomains p
volpano and smith
output of program
specification of secure
powerdomain of evaluations
semantics based formal
known at partial
powerdomain is isomorphic
f g subsets
probabilistic information flows
security type high
pers to model
specifying binding time
powerdomain p l
style of semantic
unifies a number
f g sets
bell and lapadula
security by partial
pair where h
powerdomains p st
intuitively the equation
symmetric and transitive
define the extension
high theta st
andrew c myers
run on data
probabilistic powerdomain semantics
time analysis hs91
giacobazzi isabella mastroeni
per d e
clarifies and unifies
et al vsi96
pers in static
p all theta
variables or processes
specify security properties
time analysis must
expresses that g
st is isomorphic
subsets of st
partial evaluation time
function g ffi
proposes an extensional
functions and partially
specific correctness arguments
extensional semantics based
projections for strictness
probabilistic security properties
sets of values
time analysis lau89

corpus/krapavin2000-test/1005453.txt
coloring
superedge
outgrowth
vertex
width
supergraph
clique
perimeter
height
face
colors
vertices
ring
subcubic
bag
minors
balanced
incident
minor
edge
superedges
colorings
edges
surface
graphs
outgrowths
crosscap
bags
degenerate
pointset
surfaces
planar
subgraphs
tree
tw
faces
layers
decontractions
color
subgraph
joins
partition
robertson
corollary
partitions
rings
layer
colored
endpoint
counterexample
witnessed
excluding
heights
seymour
disk
join
integers
ossona
pointsets
jaroslav
neetil
mendez
df
round
boundary
embedded
cyclic
xvi
patrice
rotate
euler
fill
endpoints
reductions
filling
arbitrarily
injective
closed
integer
canonical
proofs
cb
cyclically
embedding
lemma
uv
ke
declared
conjectured
delete
mod
incidence
extensions
deleting
replacing
finitely
constructions
decomposition
deletions
generality
fomin
mohammadtaghi
slovene
leqsf
demaine
encyclings
spannings
hajiaghayi
widlh
thilikos
fillings
punctured
fedor
apex
decontraction
capping
cappings
theorems
incidences
endvertices
thomas
preserving
ers
span
drawing
string
dms
reversals
subexponential
dimitrios
deletion
structural
author
triple
disjoint
conjecture
di
sounds
contracting
circuit
hypergraph
genus
continuous
grant
ranging
xx
combinatorics
rd
qualities
louisiana
fund
naval
cap
lemmas
strings
algorithmic
witnesses
forbidden
connected
induced
loss
jacm
deg
wish
parts
homomorphism
noted
corollaries
preserve
bounding
phrases
boundaries
leaves
ce
fractional
characteristic
uniquely
attaching
agency
assigns
solvable
tree width
every graph
r ring
g h
r outgrowth
face f
vertex coloring
supergraph h
graph minors
h layer
vertex partition
g w
ring r
edge partition
k b
h f
clique join
clique joins
colors form
k tree
full coloring
balanced k
f 0
balanced full
k minor
planar graph
j parts
parts form
suppose g
l coloring
minor closed
edge coloring
r rings
e b
g e
graph g
g 1
g 2
height h
v q
v g
vertex l
endpoint rule
closed disk
vertex extensions
closed class
edge partitions
edge e
g v
coloring c
every face
graphs g
bounded tree
w k
every edge
v b
height preserving
outgrowth g
full r
corollary let
l colors
low tree
h layers
partial k
joins starting
superedge f
tw g
minor may
handle reductions
balanced edge
bag x
width r
h 1
theorem let
graph k
j 1
r h
non degenerate
let k
e h
form a graph
g h f
graph with tree
set of surfaces
balanced k b
join of g
r ring r
g 2 w
set of colors
j parts form
g e b
perimeter t 1
set of graphs
ring with perimeter
balanced full coloring
h is full
face of h
vertices and edges
h f 0
g a b
minor closed class
j j parts
full and subcubic
lemma 1 4
vertex l coloring
edges in e
bounded tree width
coloring of g
vertex and edge
class of graphs
corollary 2 2
edges of g
j colors form
l colors form
vertex coloring c
low tree width
extensions of graphs
clique joins starting
partial k tree
h by replacing
j l colors
k minor may
every graph k
author s research
excluding a planar
outgrowth g h
r h layer
theorem for every
leaves the vertices
r s h
face f 0
crosscap and handle
v q w
k b coloring
constructed by clique
width r 1
e with endpoints
pointset of f
robertson and seymour
vertices in w
g and h
theorem 2 1
obtained from h

corpus/krapavin2000-test/628215.txt
nnf
mvds
mvd
fds
aset
hobby
nested
attributes
fd
matriculation
conflict
prof
descendent
bcnf
skiing
ancestor
acyclic
hiking
student
database
chair
dependency
schemes
join
redundant
steve
seed
dept
violates
unmarked
redundancy
ru
equipment
tree
unnesting
tdc
lhs
pat
carter
normal
rm
xy
dance
ph
implied
pnf
kong
relational
ada
polya
dep
gamman
child
ordb
ordbs
aef
nontrivial
fk
tableau
publication
forms
hong
toy
embedded
root
imply
jane
cde
rap
dependencies
keys
envelope
rn
transitive
relation
interestg
equipmentg
notationly
tabc
scheme
math
splits
dc
title
trees
turing
attribute
lemma
rb
generalizing
chase
node
flexibility
subtree
ag
flat
nonempty
ts
barker
hat
preserving
travel
wb
bottle
databases
ae
nesting
sm
multivalued
young
reducible
cs
notice
numerous
tru
wordy
txz
costume
mmin
closed
decomposition
satisfies
subsection
pairwise
path
relations
fig
dp
article
shoe
dancing
squeeze
subcondition
ra
water
stating
contradiction
neighbors
intersection
caused
transferable
soccer
converses
xv
violations
free
zhuge
entered
sp
disjoint
edge
designers
atomic
adams
xz
neighbor
guides
vacuously
wg
counterparts
induction
chess
gamma
lemmas
remove
marked
superior
generates
usa
jsj
hai
tuples
shall
abbreviate
lee
tuple
scheme tree
nested relation
nnf oy87a
nnf mne96
nnf oy89
nnf rk87
conflict free
relation scheme
relation schemes
database scheme
attributes let
acyclic database
database schemes
normal forms
free sets
scheme trees
u let
redundant data
mvd x
data values
ancestor v
join dependency
prof hobby
given set
join tree
student interest
attributes u
nested relations
normal form
hobby hobby
given fd
hobby equipment
dept chair
algorithm 1
matriculation student
descendent w
let u
node n
free set
m 0
nested normal
total unnesting
reducing redundant
redundancy caused
scheme r
step 2
j 0
dependency preserving
extended conflict
nested database
chair prof
gamman k
node scheme
intersection property
e d
condition 1
path scheme
let m
ancestor n
violates condition
dep x
satisfy nnf
generalizing 4nf
steve programming
tr seed
cs turing
implies mvd
connected subtree
condition 2
hong kong
u gamma
d implies
design flexibility
satisfies condition
closed set
given database
gamma xy
satisfies nnf
left reduced
math polya
polya steve
v descendent
fundamental keys
r seed
jane skiing
article title
lhs m
publication location
turing jane
single path
set of mvds
set of attributes
nnf oy87a nnf
mvds and fds
respect to m
nested relation scheme
nested relation schemes
aset t u
sets of mvds
redundant data values
respect to d
conflict free sets
fds over u
step 2 2
conflict free set
acyclic database schemes
set of fds
attributes let m
mvds over u
attributes let d
relation in figure
acyclic database scheme
programming in ada
reducing redundant data
mvd x y
matriculation student interest
hobby hobby equipment
dept chair prof
extended conflict free
node scheme tree
given database scheme
gamman k 1
single path scheme
single node scheme
set of relation
d is equivalent
node in j
r i 2s
also in 4nf
nnf mne96 nnf
z on u
nested normal forms
implies an mvd
d of mvds
w on aset
key of m
mvds is conflict
satisfy nnf mne96
x u gamma
cs turing jane
ancestor v descendent
algorithm 1 generates
fds that hold
v descendent w
math polya steve
nested database schemes
u gamma xy
path scheme tree
r 1 rn
nodes in j
r is acyclic

corpus/krapavin2000-test/627222.txt
subtask
rba
oba
dasa
deadline
mndw
subtasks
ramp
replicas
ke
overload
benefit
arrival
replica
deadlines
aggregate
workload
missed
heap
scheduling
processor
allocation
timeliness
lbesa
response
anticipated
adaptation
resource
ravindran
workloads
proactive
rhd
accrued
tasks
period
invoking
hegazy
processors
task
amortized
red
eqf
kelog
asynchronous
aperiodic
message
window
slack
underloaded
invokes
fig
arrivals
scheduler
triggering
edf
eex
resources
deallocate
pseudocode
vol
ratio
predecessor
schedulers
periodic
const
stk
replicasprocessors
binoy
arrivaltime
mdndw
dl
messages
nd
load
allocations
computationally
mines
qos
arrive
analyzes
deallocates
delays
baseline
queue
log
benefits
sti
overloads
maximize
deter
determines
allocates
analyzeresponse
overloadcheck
responsetime
determinereplicasprocessors
mk
decisions
subsections
constructs
feasibility
event
effort
xm
allocate
constructing
assignment
peng
allocated
detected
miss
switch
rj
overloaded
arrives
kth
incurs
worst
ready
executing
considers
triggered
benchmark
repeats
earliest
rationale
computers
invoked
packet
events
determining
uncertainties
naval
cj
parent
decreasing
heuristically
periods
instants
extract
sender
extracted
ti
nents
counterpart
replication
packets
replicating
numerator
compo
ethernet
incrementing
replicated
examines
ordered
er
affect
subproblems
jensen
xn
extracting
middleware
highest
situations
list
plots
executions
execution
experiment
percentage
processes
expensive
abstraction
mndw ke
deadline ratio
resource allocation
missed deadline
benefit tasks
aggregate benefit
subtask response
arrival list
subtask deadline
subtask arrival
higher benefit
asynchronous real
adaptation functions
response time
amortized complexity
real time
log mndw
aggregate task
overload test
ramp ramp
application benefit
arrival time
response times
rba _determinereplicasprocessors
dasa nd
underlying scheduling
proactive resource
ramp workloads
time distributed
scheduling algorithm
using application
subtask replicas
increasing ramp
subtask execution
procedure rba_analyzeresponse
task benefit
scheduling algorithms
arrival times
time window
accrued benefit
computers vol
vol 51
ravindran using
higher aggregate
aggregate accrued
future time
processor assignment
n tasks
rba _algorithm
lower benefit
task deadline
task period
task benefits
processor q
periodic task
const ramp
rba performs
o mndw
scheduling events
procedure rba
anticipated workload
kelog mndw
second replica
thus rba
lower missed
task missed
anticipated workloads
single replica
benefit task
load error
triggering periodic
best effort
time analysis
execution times
august 2002
effort real
log n
relative load
rba dasa
b missed
adaptation period
current processor
task adaptation
maximize aggregate
rba algorithm
available slack
invoking dasa
baseline ramp
subtask deadlines
parent task
subtask arrivals
n subtask
produces higher
ke log
minimize aggregate
missed deadline ratio
performance of rba
rba and oba
number of replicas
asynchronous real time
higher benefit tasks
log mndw ke
real time distributed
proactive resource allocation
subtask response time
allocation in asynchronous
time distributed systems
satisfy the subtask
benefit for proactive
using application benefit
ravindran using application
number of subtask
hegazy and ravindran
higher aggregate benefit
timeliness of higher
subtasks and messages
computers vol 51
aggregate accrued benefit
underlying scheduling algorithm
subtask response times
response time analysis
benefit and minimize
aggregate task benefit
overload is detected
complexity of rba_analyzeresponse
future time window
rba under dasa
const ramp workloads
benefit and lower
cost of invoking
task missed deadline
aggregate task missed
kelog mndw ke
lower benefit tasks
lower missed deadline
complexity of rba
increasing ramp ramp
determines the number
best effort real
effort real time
log n k
total available slack
accrued benefit b
ramp ramp workloads
subtask execution times
ke log mndw
determine the subtask
subsections that follow
aggregate missed deadline
workloads a aggregate
order of task
triggering periodic task
benefit b missed
relative load error
produces higher aggregate
time scheduling algorithms
observe that rba
baseline ramp ramp
b missed deadline
mndw kelog mndw
minimize aggregate missed
affect the timeliness
constructing the subtask
mndw ke log
dasa and red
shown in fig
transactions on computers
real time scheduling
change in aggregate
cost of constructing

corpus/krapavin2000-test/608786.txt
skewing
locality
tomcatv
nest
loop
balance
tile
loops
ow
stencil
calculations
calculation
scalable
cache
live
tiling
stripe
int
nests
iteration
break
array
temporaries
stripes
arrays
dependences
rxm
rym
benchmark
tiles
wolf
oating
cur
ry
interference
rst
lam
skew
residuals
iterations
ne
statements
tridiagonal
temporary
inhibit
outer
reindexing
sixth
optimizations
multiplication
bandwidth
stencils
dimension
spaces
improving
unimodular
fth
traverse
seven
nn
grows
raises
library
memory
transformation
ding
latency
produced
sustained
layout
virtual
code
aa
compile
transformations
limits
hope
carries
xed
grow
scans
statement
omega
codes
dependence
inner
aect
occurred
extremely
rastislav
kristof
regrouping
seshia
outpace
strout
armando
liviu
recompress
maksim
lezama
jeanne
orlovich
semicoarsening
taxes
kreaseck
shallower
hypre
gilad
sanjit
beyls
mccalpin
tancau
bodik
block
completing
skewed
reused
linearly
sublinearly
hollander
guohua
permutable
intermediately
ferrante
michelle
aberrant
complier
saraswat
refactorings
hoisting
producing
expanding
symbolic
ignore
subscript
contend
yonghong
carter
mills
ischia
crummey
bump
mellor
denition
expand
supercomputing
initialize
seconds
derives
matrix
nd
empirical
fourth
experiences
proportional
scsi
unoptimized
tiled
kmp
lexicographical
rosser
sketching
indices
blocks
nal
solar
erik
widening
coerce
corrupting
mckinley
multigrid
borders
scalable locality
time skewing
time loop
time step
achieve scalable
data ow
produce scalable
compute balance
machine balance
loop nest
step calculation
improving locality
int figure
iteration spaces
o b
main memory
step calculations
skewing transformation
time block
tomcatv benchmark
seven arrays
problem size
cache interference
three point
matrix multiplication
code generation
tile size
virtual memory
value produced
break occurred
break statements
e loops
stencil calculations
solve tridiagonal
extremely high
iteration space
oating point
value based
omega library
memory locality
generation system
point stencil
outer loop
values produced
current techniques
loop carried
loop nests
n values
data locality
b g
loop bounds
ow dependences
next tile
initialize c
step completing
two nests
rst nest
fourth nest
exhibits scalable
place stencil
time skewed
high balance
cache requirements
temporary values
determine maximum
locality proceedings
inhibit scalable
cache requirement
cur array
break statement
live simultaneously
j dimension
grows less
high machine
ignore issues
exhibit scalable
skewed code
sixth nest
previous iteration
operations performed
g e
transformation systems
achieving scalable
chen ding
int for int
achieve scalable locality
produce scalable locality
time step calculation
time skewing transformation
wolf and lam
ow of values
iteration t j
time step calculations
code generation system
class of calculations
three point stencil
o b g
used in iteration
produced in iteration
skewing and tiling
measures our ability
discussed in mw98
time loop must
raises the hope
values are reused
inhibit scalable locality
achieving scalable locality
nest of tomcatv
c to zero
iteration data ow
operations on o
time skewed code
extremely high machine
locality we must
locality for figure
calculation in figure
zero for int
given in mw98
ry i j
values are live
exhibits scalable locality
extremely high balance
follow the data
time step completing
live on entry
achieve the appropriate
within the stripe
entirely in cache
exhibit scalable locality
compile time optimizations
b g e
high machine balance
ability to apply
degree of locality
arrays of size
ow of information
techniques for improving
value of time
less than linearly
algorithm for time
o n b
per time step

corpus/krapavin2000-test/611411.txt
url
disk
proxy
foxy
file
proxies
squid
urls
web
requests
buddy
stream
packetizer
locality
lazy
webcosm
cache
buffers
server
read
kbytes
reads
request
movements
head
throughput
latency
caching
delete
utilization
storage
files
loc
polygraph
client
conscious
plots
internet
lru
clients
management
unix
documents
overhead
serve
solaris
contiguously
contiguous
hit
hbench
unnoticeable
directory
tcp
secondary
meta
gbyte
servers
simulator
caches
crash
traffic
trace
fragmentation
buffer
mbytes
requested
improves
load
completion
magnetic
traces
directories
accesses
serving
contents
soloviev
taztool
dirs
bottlenecked
ufs
creation
deletion
requesting
noticeable
contrary
store
bandwidth
prefetching
operating
miss
http
structured
traditional
interleaved
news
page
writes
slot
response
policies
object
layout
hits
blocks
busy
threshold
disks
sustain
slots
matters
replacement
write
connection
interleaving
ffl
snapshot
fed
white
pong
clustering
dots
os
minutes
milliseconds
surges
rousskov
inktomi
maltzahn
lmbench
bake
cacheflow
metadata
storing
writing
workloads
nearby
stores
subsystem
serviced
fills
stored
improvements
benchmarking
seek
sent
origin
benchmark
zebra
serverless
watermark
mogul
evicted
custom
plotting
driven
ftp
policy
accessed
rotational
bottleneck
fsm
filesystem
seagate
millisecond
deletes
scattered
articles
arrive
grouping
firewall
cao
ping
percentage
workload
ultra
mismatch
configured
cached
plotted
block
wake
mbyte
locations
outperforms
network
achieves
suggest
improvement
html
striped
gbytes
advocate
dns
lazy reads
locality buffers
web proxies
web proxy
read requests
file system
stream packetizer
read operations
per second
url read
file systems
url write
disk head
requests per
log structured
head movements
url get
disk utilization
structured file
proxy server
write operations
storage management
web server
input load
figure plots
url requests
reads loc
per file
conscious storage
web conscious
url delete
meta data
disk space
free space
secondary storage
file creation
disk cache
get operations
file space
completion time
main memory
get requests
locality buffer
write requests
unix like
disk read
one url
file management
o overhead
operations per
level cache
busy web
write throughput
caching proxies
web polygraph
traditional proxies
space management
url per
second level
cache simulator
new url
single file
web objects
operating system
read operation
performance improvements
end user
url request
proxy performance
hbench os
make matters
url operations
serve around
webcosm techniques
appropriate file
origin web
gbyte disk
http request
buddy improves
mbytes per
disk locations
solaris 5
management overhead
like file
serving 1
matters worse
traditional web
delete requests
data overhead
delete operations
network file
read request
user level
improves performance
creation deletion
level web
separate file
reduce disk
trace driven
web documents
wide web
world wide
experimental evaluation
head position
requests second
system crash
significant performance
local copy
memory cache
disk seek
network bandwidth
single disk
disk block
level disk
requests per second
log structured file
structured file systems
lazy reads loc
disk i o
web conscious storage
disk head movements
conscious storage management
url get operations
get operations per
operations per second
function of disk
squid and foxy
url get requests
performance of stream
plots the completion
file i o
url write operations
performance of buddy
one url per
url per file
url read operations
create and delete
able to serve
file to store
second level cache
serving 1 000
file creation deletion
stores all urls
unix like file
mbytes per second
meta data overhead
absence of locality
source of overhead
origin web server
get requests per
make matters worse
time for serving
file management overhead
traditional web proxies
file space management
world wide web
simulation and experimental
main memory cache
secondary storage management
performance of read
long head movements
previous read request
urls per file
busy web proxy
disk utilization lazy
taken with taztool
input load requests
like file systems
stream of write
study the overheads
webcosm a set
throughput of squid
file system operations
like log structured
url read requests
nearby disk locations
url delete requests
lazy reads figure
url write request
utilization lazy reads
ping pong effect
stream and stream
load requests second
sequential write operations
url read url
delete a file
tcp ip connection
performance of lazy
storage management techniques
reduce this overhead
store all urls
much like log
disk is plotted
set of techniques
disk space utilization
structured file system

corpus/krapavin2000-test/606915.txt
taut
propositional
clocked
turing
np
nondeterministic
tautology
transducer
enumerable
polynomial
sound
machines
reckhow
co
promise
jwj
cook
simulates
comp
opt
languages
pudl
kraj
cek
jxj
deterministic
ak
accepts
ff
accepting
tautologies
presentation
computable
provably
polynomially
sigma
presentability
hartmanis
kowalczyk
hemachandra
recursively
ae
fm
recursive
string
possesses
existence
categorical
uniformity
formulas
classes
acceptors
messner
fsound
relativizations
subsets
recognizable
acceptor
machine
theorems
maybe
enumerations
counterpart
covering
accepted
possess
proofs
fulfilling
soundness
satisfiable
cap
bm
language
enumeration
gamma
guesses
unambiguous
formula
yes
fn
sat
iii
jcomp
sengupta
revelation
presentable
nondeterministicg
obler
unsuccesfully
glaer
fhm
algoritms
samik
representability
quantified
independence
tupling
jffj
posed
guess
chief
selman
mutations
theoretic
structural
analogously
shut
manners
strength
strong
connection
conp
pay
intensively
transducers
attacking
padding
names
fl
characterization
restated
familiarity
lectures
boolean
strings
reducibility
rice
promises
symmetrically
recursion
corollaries
halts
producing
structurally
hm
sight
attaching
deeper
connections
christian
reflecting
encodings
provable
tor
proven
proves
simulation
obey
cryptography
versus
undecidable
working
connectives
complements
clocks
word
symbol
distant
alan
similarity
systematically
springer
verlag
recognizing
outputs
fi
equivalence
alphabet
produces
efficiency
classifying
zeros
question
notion
verify
statements
procedures
searched
translating
proving
aimed
formalized
displays
reductions
claimed
contrary
seem
classification
reasoning
translates
public
devices
complementary
translate
propositional proof
time clocked
proof system
optimal propositional
clocked turing
polynomial time
np co
proof systems
turing machines
complete languages
co np
nondeterministic polynomial
turing machine
propositional tautology
easy subset
easy subsets
nondeterministic turing
recursively enumerable
promise classes
np presentation
p optimal
machine m
optimal proof
complete language
comp gamma
ae taut
clocked transducer
enumerable list
recursive np
np easy
gamma sound
transducer m
sound jwj
g comp
p simulates
deterministic turing
time computable
every tautology
sound jxj
accepts taut
tautology ff
good form
input w
turing transducer
pudl ak
classes np
provably np
machines covering
every theory
p presentation
complexity classes
polynomial p
polynomially bounded
uniformity property
nondeterministic algorithm
length n
string x
deterministic polynomial
computable function
p pudl
covering languages
provably easy
bounded propositional
fm n
j accepting
r reckhow
optimal nondeterministic
strong nondeterministic
propositional tautologies
j kraj
cook reckhow
taut possesses
transducer n
time bound
exists j
jxj k
certain fixed
accepts w
relative efficiency
machine n
main results
complete problems
optimal deterministic
almost optimal
theorem 5
m w
m 0
string w
boolean formulas
computations end
versus co
fulfilling 1
tautology let
propositional proof system
polynomial time clocked
optimal propositional proof
time clocked turing
np co np
clocked turing machines
nondeterministic polynomial time
subsets of taut
subset of taut
optimal proof systems
turing machine m
propositional proof systems
exists a polynomial
recursively enumerable list
algorithm for taut
time clocked transducer
recursive np presentation
comp gamma sound
nondeterministic turing machine
taut there exists
g comp gamma
p optimal propositional
existence of complete
polynomial time computable
exists a recursively
language for np
clocked turing machine
clocked transducer m
every tautology ff
machine m 0
m on input
nondeterministic turing machines
deterministic turing machine
gamma sound jwj
classes np co
exist an optimal
provably np easy
kraj i cek
languages for promise
n i j
input of length
time computable function
deterministic polynomial time
exists an optimal
cook and r
list of nondeterministic
prove that opt
proof of length
gamma sound jxj
optimal nondeterministic algorithm
machines covering languages
bounded propositional proof
p pudl ak
polynomially bounded propositional
working in polynomial
optimal deterministic algorithm
produced by m
exists an easy
cek and p
simulates any propositional
proof of ff
systems for taut
sound jxj k
almost optimal deterministic
d i j
possesses a recursive
existence of optimal

corpus/krapavin2000-test/1011176.txt
cpo
pcf
nat
lift
dyn
static
adequacy
sund
denotational
snf
operational
denable
semantics
compile
compilation
undenedness
dened
dapp
dund
cpos
pred
dynamic
interpretation
denition
hf
junk
residual
lemma
binding
arrow
compiled
induction
lambda
distinction
equational
sd
interpreted
ifz
typed
commutes
undened
substitution
name
interpret
evaluator
languages
uence
gi
handbook
purely
language
functor
termination
calculus
closed
factorisations
morphisms
formation
terminate
dene
embeds
counterpart
categorical
pragmatics
hypothesis
pow
lazy
partial
interpretations
pd
denotation
reductions
statically
relate
conversely
untyped
morphism
ut
usual
polymorphic
cartesian
intended
valid
rst
reduction
machinery
bool
rules
lifting
translation
interpreting
correctness
phases
semantic
nthen
parametrisation
postponent
compil
ftrue
plift
cuted
enrichment
hid
leeuwen
category
subtraction
specialized
continuous
terminating
wise
invalid
propagating
logical
soundness
interpretative
eugenio
unde
hearn
culus
lcf
falseg
id
diagrams
evaluations
chains
underlines
parametrised
intuitionistic
moggi
directed
isolation
rule
monotone
failure
respected
pv
fragment
abstraction
program
behaves
nal
murst
specialisation
formedness
evaluators
hh
essentially
contexts
preserves
deserve
seman
borrowing
px
exe
postponed
canonical
behaviour
categories
immediate
naturals
ned
xx
constructs
lemmas
cult
projection
postpone
asserting
novelty
judgement
conrms
versions
logic
crucial
macros
succ
cal
recursion
adequate
interplay
exibility
booleans
reconsider
equivalences
understand
syntactic
diagram
modications
behave
exponential
tics
comparatively
ness
relations
incorporate
calculi
dynamic terms
partial evaluation
level pcf
dynamic types
operational semantics
type nat
term m
dyn f
denotational model
m 0
r d1
compile time
adequacy theorem
level languages
static reduction
lift n
name pcf
binding time
logical relation
directed partial
non termination
b r
run time
closed term
dynamic type
induction hypothesis
r d2
denable functions
sub term
d lift
static adequacy
dynamic adequacy
pred m
x lift
type directed
type formation
level language
case m
purely dynamic
residual program
nat nat
x m
denotational semantics
type d
two level
dynamic arrow
term sund
partial evaluator
dynamic ones
cpo x
pairs hf
lift 0
environment x
static components
hf gi
point wise
terms like
interpret dynamic
functor categories
type assignment
m 00
static undenedness
lift sund
lazy calculus
category cpo
dynamic evaluation
immediate otherwise
equational theory
x x
c 7
d 0
f 6
type unit
formation rules
substitution lemma
execution phases
f b
r d
typed term
static types
cartesian closed
unit unit
cases case
time analysis
base types
m d
least element
f r
dynamic counterpart
terms pred
static term
reduced dynamically
m pred
dapp dyn
usual interpretation
sd m
like call
standard pcf
m sd
dynamic numbers
component dened
call by name
dened by x
type directed partial
two level languages
give an operational
directed partial evaluation
interpretation of dynamic
r d2 g
d lift n
x a p
f b r
static and dynamic
binding time analysis
semantics of dynamic
dyn f r
purely dynamic terms
compilation and execution
x m 0
terminate at compile
r d1 d2
b r d2
b r d
pairs hf gi
type formation rules
f r d1
dynamic type d
call by value
term of type
closed term m
interpretation of terms
denition of dyn
dened as follows
obtained from pcf
m m sd
m pred m
type unit unit
dynamic adequacy theorem
identity on x
interpret terms like
model of 2
must have dynamic
pred m pred
dynamic sub term
time information inside
r d1 c
sd m 0
polymorphic binding time
static normal form
handbook of logic
dynamic value d
dapp dyn f
dyn f b
given to relate
dene a translation
logical relation r
snf and m
kinds of undenedness
b r d1
term m 00
dyn f 6
f be x
m let f
lemma 16 hence
m sd m
taken in isolation
bounds of chains
relation is essentially
semantics an equational
cpo is dened
f be c
d m 0

corpus/krapavin2000-test/607623.txt
hmm
documents
training
page
missionary
pages
classifier
emission
text
hmms
xt
categorization
american
scribners
monthly
bayesian
markov
category
bayes
em
dataset
document
dt
learning
isolated
naive
hidden
articles
ocr
frasconi
ck
emissions
classifiers
year
unlabeled
eq
transition
classification
realizations
categories
rabiner
moa
labeled
xi
nigam
ergodic
bag
ct
trained
contextual
heckerman
datasets
grammar
jensen
magazine
mccallum
sequences
accuracy
sequential
baum
journals
crawling
word
nb
merging
stochastic
welch
editorial
overfitting
contents
topology
america
indians
charniak
ten
cj
independence
belief
eqs
books
extracted
probabilistic
transductive
xix
diligenti
selection
pertains
portals
cultural
extraction
feature
percentages
inference
labels
retrieval
networks
outperforms
surveys
article
evidence
home
conditional
pearl
saturate
cornell
temporally
collapses
classifying
michigan
likelihood
labeling
transitions
maximization
libraries
century
unseen
boundaries
induction
recognition
xn
generative
occurrences
hierarchically
society
ci
automating
graphically
dictionary
counts
probabilities
moaxmlfilessuppliedwiththedocumentscollections
estimationofemissionparametersinthiscasewouldbeaccomplished
althoughissuesofscribnersmonthly
enriches
trash
kalt
undoubt
americans
typeset
scrib
founders
preface
asociated
typesetting
hyphenated
bengio
afurtherdirectionofinvestigationisthereforerelatedtothedevelopment
inhypertextsbyextendingthearchitecturedescribedinthispaperisstillanopenproblem
edly
byreplacingcounts
stepisperformedinthestandardwayfortransitionparameters
hypertexts
magazines
theassignedcategorieswerethen
bicknese
afro
poems
dedication
misspelledwords
dor
childhood
thegeneralcaseofdirectedgraphsisdifficultbecauseofthepresenceofcycles
deservesattention
blumson
tales
toc
passerini
metae
nonexistent
lucke
trainingset
estimation
performances
speech
parsing
convenient
gain
plausible
focused
biased
variability
internet
american missionary
naive bayes
hidden markov
text categorization
feature selection
multi page
markov models
scribners monthly
bayesian networks
isolated page
labeled documents
page classification
bayes classifier
hmm topology
page documents
frasconi et
training set
text classification
p dt
unlabeled documents
sequential classifier
emission parameters
missionary dataset
em algorithm
al 2000
jensen 1996
contextual information
page classifier
rabiner 1989
induced hmm
state realizations
page categories
journal issues
hmm states
heckerman 1997
nigam et
bayesian network
training sequences
documents using
classification using
page category
page labels
text pages
emission model
average accuracy
page boundaries
w ck
xi x
model induction
ocr text
transition structure
labeled pages
year 1884
et al
vector machines
training documents
baum welch
transition graph
focused crawling
remaining issues
machine learning
information gain
structure learning
two datasets
belief networks
classification accuracy
markov model
eq 6
support vector
isolated pages
mccallum et
account contextual
internet portals
training text
ergodic hmm
hmm outperforms
models feature
merging collapses
selection text
p ck
hmm architecture
hmm transition
eqs 11
occurring less
ten categories
transductive inference
observed sequence
p xt
transition distribution
traditional isolated
pearl 1988
whose emissions
monthly dataset
reached note
hierarchically classifying
extracted grammar
conditional word
isolated vs
hmm classifier
process pertains
ten states
state xi
ck w
class ck
charniak 1993
article 2
grammar extraction
page sequences
using em
partially labeled
transition parameters
collapses two
model merging
name description
data induced
emission distribution
sequential classification
given xt
state evidence
multiple states
sequential organization
word w
digital libraries
hidden markov models
naive bayes classifier
frasconi et al
multi page documents
american missionary dataset
et al 2000
bag of words
induced hmm topology
nigam et al
xi x j
making of america
labeled and unlabeled
isolated page classification
classification and retrieval
isolated page classifier
sequence of pages
may be convenient
support vector machines
sequential page classification
eqs 11 15
w in pages
account contextual information
bayesian model merging
models feature selection
markov model induction
classification from labeled
domain name description
data induced hmm
p xi x
vs sequential page
structure learning algorithm
merging collapses two
feature selection text
hierarchically classifying documents
information gain criterion
training text classifiers
ocr text pages
methods for focused
hmm with ten
within the sequence
percentages of labeled
unlabeled documents using
prediction is biased
collapses two states
conditional word independence
inference and learning
scribners monthly dataset
pages the hmm
model of text
induction by bayesian
two states x
documents using em
traditional isolated page
outperforms the isolated
automating the construction
algorithm for training
new probabilistic model
example of induced
partially labeled documents
error rate reduction
construction of internet
percentage of labeled
words occurring less
mccallum et al
portals with machine
within a document
occurrences of word
learning algorithm presented
isolated vs sequential
inference for text
text classification using
p ck w
classifying documents using
n w ck
pages of class
probabilistic independence networks
hidden markov probability
page of class
classification using support
obtained from eq
category is known
markov probability models
based mapping method
using support vector

corpus/krapavin2000-test/613982.txt
latency
mpi
throughput
subsystem
mpps
adapters
switch
ibm
mpl
aix
message
mb
kb
upgrade
messages
interchange
swm
thmax
benchmarks
collective
bt
pvm
npb
mflop
broadcast
native
communication
adapter
old
sp
spooling
meiko
gregorio
passing
processors
mpich
mpp
paragon
processor
directional
nas
interconnection
grain
medium
bus
lu
bandwidth
barrier
achievable
mg
benchmark
configurations
beivide
parkbench
upgraded
simulator
bi
intel
bytes
irvine
destination
programmed
torus
peak
micro
numeric
reductions
channel
rendezvous
communications
regions
asymptotic
region
short
offers
hardware
fortran
software
researcher
factored
navier
stokes
noticeably
plus
thousands
fitted
basically
supercomputing
nowadays
shallow
ethernet
bisection
triangular
network
tests
water
specially
designers
cache
library
reduction
community
ports
cray
assessing
subsystems
offering
fluid
header
kernels
discretization
frequent
tens
routers
ps
massively
jobs
latencies
characterize
myricom
tirado
euphoria
cnica
vallejo
fica
argonne
dgicyt
comunicacions
investigaci
aprox
labarta
bechmarks
pentadiagonal
hockney
sangman
dongman
pstswm
johasz
direcci
llorente
zoltan
nonmember
fittings
comisi
gflop
dongsoo
unfactored
worley
tecnolog
massive
running
communication subsystem
parallel applications
message length
o v4
performance switch
n v4
new switch
th o
o v3
long messages
point communication
message passing
length kb
throughput mb
short messages
high performance
point communications
native version
execution times
ibm sp2
average values
collective operations
new version
bi directional
frequent interchange
spooling time
plus mpi
lu sp
parallel simulator
message th
micro channel
nas parallel
adapters aix
kb region
parallel benchmarks
parallel computer
message size
point case
applications requiring
asymptotic throughput
minimum latency
obtained running
length figure
grain parallel
interconnection network
message latency
processor 0
running parallel
th n
maximum throughput
intel paragon
fortran 77
execution time
built around
fine grain
software layer
difference discretization
mpi collective
message interface
numeric applications
communication tests
latency reduction
enough messages
mpps including
passing networks
software elements
noticeably reduced
channel controller
r beivide
region 3
sp bt
passing software
simulated computational
case minimum
offers several
acknowledgements section
equations resulting
parallel application
several mpi
communication software
approximately factored
passing paradigm
old switch
region 1
ibm offers
directional ports
bt swm
implicit finite
current mpps
aix v4
mg lu
random traffic
rendezvous protocol
one half
point to point
latency and throughput
high performance switch
latency s message
version of mpi
start up time
message length kb
mb s message
o v4 n
grain parallel applications
th n v4
o v4 th
n v4 throughput
length kb region
switch and adapters
message length figure
messages are short
results obtained running
o v3 o
th o v3
message th o
o v3 th
nas parallel benchmarks
th o v4
j a gregorio
hardware and software
l 1 2
performance of parallel
finite difference discretization
several mpi collective
reduction of latency
mpi collective operations
e a message
message passing networks
message size required
lu sp bt
characterization of latency
experiment a significant
aix v4 native
implicit finite difference
mb s peak
mg lu sp
header to reach
running parallel applications
adapters aix v4
micro channel controller
regions that correspond
message passing software
offers several alternatives
bi directional ports
simulated computational fluid
latency is noticeably
random 2 sets
times of parallel
message passing paradigm
sp and bt
components of latency
throughput for point
new communication subsystem
interchange of short
latency for short
regarding the hardware
fortran 77 plus
mpi and mpl
large data structures
communication a first
sp bt swm
fitted to equation
reductions in execution
increase the throughput
required to transmit
run parallel applications

corpus/krapavin2000-test/609180.txt
dlet
binding
deps
continuations
resumable
handler
lisp
calculus
exceptions
dynamic
axioms
lookup
eval
lexical
expressiveness
fmark
equational
deep
abstractions
exception
felleisen
passing
ltc
queinnec
xd
speculative
sabry
ml
translation
syntactic
semantics
delimiters
operand
lk
extent
observational
lexically
signalled
raised
scope
hostname
emacs
intro
latest
style
continuation
stuck
elim
eulisp
abstraction
functional
adds
placeholder
maclisp
environment
assignments
equationally
purely
shallow
gnu
accessible
mandatory
language
bind
sequential
notices
associative
fluid
bindings
propagate
feeley
apparition
ffix
southampton
expressive
binds
conciseness
sigplan
programmer
print
lambda
funarg
syntax
inverse
programs
enclosing
calculi
refine
xg
monitor
alue
scoping
organisation
popping
essence
sensible
innermost
operator
dialects
popped
combinator
duplicated
axiom
scoped
mccarthy
perl
amr
favour
xr
behaviour
languages
name
fork
mutable
reasoning
creation
growth
parallelism
duplicating
fig
xs
transform
haskell
explanatory
pop
indefinite
theories
translated
vn
equivalences
signal
transition
strengthen
inside
primitive
ffi
dynamically
denotational
register
xed
constructs
displayed
bug
cons
christian
hole
translations
annotation
sound
active
correspondence
fivefold
stoyle
penalise
magorzata
observationnally
mitscheme
stolen
denigrate
cartwright
barendregt
penalises
alued
chieh
hicks
bierman
ribbens
abortive
multilisp
biernacka
wansbrough
dynamicness
sperber
destruct
gavin
soton
manual
duration
pushed
declarations
occurrence
evaluation
site
relies
derivations
body
macro
lazy
resource
fi
db
simulate
soundness
revised
expression
dynamic binding
dynamic environment
dlet dlet
evaluation function
deps d
parallel evaluation
deep binding
dynamic extent
environment passing
dynamic variables
dynamic variable
evaluation context
sequential evaluation
dlet construct
latest active
syntactic theory
adds expressiveness
dynamic abstraction
dlet propagate
binding adds
passing style
purely functional
d calculus
passing translation
propagate 0
associative list
binding list
expressive programming
passing transform
common lisp
inverse translation
program m
equational reasoning
functional language
shallow binding
dynamic abstractions
ml 26
expressiveness 8
dlet intro
fluid let
resumable exceptions
eval c
lisp 43
control delimiters
exceptions like
first class
class continuations
transition rules
value calculus
m 7
programs using
continuation passing
programming technique
axioms dlet
context e
active handler
dlet elim
emacs lisp
lookup 2
primary axioms
current dynamic
lk 2
binding technique
style exceptions
partial continuations
eval l
dynamic scope
lookup 1
dlet error
e xed
observational equivalence
gnu emacs
active binding
rule dlet
rule ltc
equationally corresponds
ml style
print number
binding strategy
syntactic theories
target language
equational correspondence
m 2
lookup operation
transform d
control state
notices v
sigplan notices
state space
d gamma1
using dynamic
acm sigplan
environment e
standard ml
value v
special form
let body
rules dlet
allows equational
structure organisation
programming patterns
appears inside
future construct
variable hostname
implementation strategies
dlet ffix
remains accessible
feeley 7
dynamically bind
derived axioms
lexical binding
intro 0
resumable ones
e evaluation
dynamically bound
dlet dlet dlet
dynamic environment passing
sequential evaluation function
binding adds expressiveness
dynamic binding adds
dlet propagate 0
prove that dynamic
purely functional language
environment passing style
m 2 0
expressive programming technique
theory of dynamic
common lisp 43
environment passing transform
program m 2
parallel evaluation function
first class continuations
call by value
show that dynamic
set of axioms
adds expressiveness 8
passing transform d
environment passing translation
ml style exceptions
present a syntactic
current dynamic environment
semantics of exceptions
latest active handler
programs in dynamic
semantics of future
rule dlet propagate
deep binding strategy
reasoning on programs
latest active binding
continuations and assignments
using dynamic binding
abstraction is applied
programs using dynamic
exception was raised
inside the scope
sigplan notices v
acm sigplan notices
sabry and felleisen
ae dlet dlet
exceptions like resumable
parallelism and distribution
associated with lisp
gnu emacs lisp
order to strengthen
variable is translated
dlet ffix x
dlet ae dlet
perform equational reasoning
define a parallel
v alue d
deep binding technique
expression a dynamic
fluid let 18
theory that allows
xd extend e
define a calculus
defined and equal
space binding list
exception is signalled
refine the evaluation
inverse dynamic environment
x d v
dlet dlet ffix
d any value
mutable dynamic variables
error if dlet
eval l m
kinds of exceptions
notion in semantics
claim that dynamic
binding with value
e evaluation context
duplicating the dynamic
transition rules dlet
dlet merge dlet

corpus/krapavin2000-test/628048.txt
recurrent
elman
training
neural
weight
grammatical
grammar
fgs
learning
zipser
automata
dfa
epoch
ungrammatical
sentence
networks
english
nmse
backpropagation
grammars
japanese
eager
annealing
verb
williams
surface
stochastic
network
descent
batch
hidden
gradient
dfas
innate
window
connectionist
narendra
gori
soda
frasconi
extraction
stubborn
linguists
bptt
speakers
train
minima
native
john
verbs
parthasarathy
noun
logistic
chomsky
plot
gb
discriminatory
sectioning
activation
sentences
extracted
trained
sigmoid
tagging
architectures
representational
learned
plots
dev
talk
judgments
convergence
adjectives
prepositions
std
word
simulated
investigated
contradictory
adv
language
sentential
government
speaker
rate
learn
speech
entropy
inference
update
tanh
weights
inputs
nouns
turing
investigates
quadratic
linguistic
binding
phonology
sincerely
innateness
grammaticality
obligatorily
equalized
complementizer
resulted
classifications
feedforward
classification
giles
sharply
neurons
updates
schedule
languages
dataset
layer
categorization
dimensions
activations
competence
adjective
parsimoniously
feedback
schedules
overt
destruction
error
deviation
center
syntactic
parsing
sleep
epochs
alter
mary
dynamical
phenomena
difficulty
consisted
symbolic
quicker
acceptability
encoding
connections
outputs
crossed
decreased
lectures
digraph
simulations
converge
strings
principles
neuron
escape
serial
symbol
million
terminal
compactly
recognizes
faculty
phrase
spots
encoded
flat
randomly
updating
capability
locally
categories
temporal
learning rate
recurrent neural
neural networks
error surface
w z
recurrent network
recurrent networks
elman network
williams zipser
input window
finite state
neural network
natural language
gradient descent
simulated annealing
stochastic update
batch update
z network
weight weight
epoch epoch
gori soda
state automata
cost function
grammatical inference
frasconi gori
training set
weight 0
chosen dimensions
fgs network
locally recurrent
extracted automata
rate schedule
narendra parthasarathy
word inputs
surface plots
plot corresponds
hidden nodes
network architectures
two randomly
elman networks
native speakers
test set
training data
deterministic finite
local minima
partition state
entropy cost
z networks
shown fully
two word
grammatical ungrammatical
turing equivalent
discriminatory power
rate schedules
zipser network
quadratic cost
n p
activation function
std dev
training algorithm
hidden layer
order recurrent
correct classification
simple recurrent
elman narendra
vs innate
descent based
non contradictory
stochastic updates
weight 81
innate components
extracted dfas
gb theory
sub categorization
japanese data
million stochastic
eager john
learned vs
grammar g
components assumed
fully figure
appropriate grammar
sharply grammatical
gb linguists
automata extraction
weight initialization
noun class
negative examples
second order
native speaker
initial learning
formal grammars
relative entropy
recurrent neural networks
backpropagation through time
w z network
elman and w
finite state automata
frasconi gori soda
recurrent neural network
neural network architectures
case the center
randomly chosen dimensions
error surface plots
quadratic cost function
weight 0 3
parameters after training
learning rate schedule
deterministic finite state
two randomly chosen
connections are shown
network each plot
two word inputs
williams zipser network
epoch epoch epoch
learning rate schedules
w z networks
government and binding
respect to two
described by context
extraction of rules
use of simulated
able to learn
million stochastic updates
gradient descent based
judgments as native
learn an appropriate
introduction to formal
vs innate components
shown fully figure
elman narendra parthasarathy
sentences as grammatical
innate components assumed
relative entropy cost
kind of discriminatory
eager for john
grammatical or ungrammatical
framework or government
talk to john
learned vs innate
principles and parameters
assumed by chomsky
entropy cost function
sharply grammatical ungrammatical
used by elman
shown in table
comparison of recurrent
order recurrent networks
initial learning rate
performance as shown
form of deterministic
simple recurrent networks
part of speech
natural language sentences
second order recurrent
neural network models
number of hidden
values of q
training and test
set of strings
neural computation v

corpus/krapavin2000-test/627784.txt
slg
win
stable
ground
founded
ai
literals
atoms
clause
literal
truth
tabled
atom
irene
residual
prolog
semantics
query
color
gm
psm
sean
diff
logic
body
answers
teach
valued
chaining
anss
fixpoint
chris
program
undefined
delayed
interpretation
sldnf
clauses
negation
programs
propagation
herbrand
branch
negative
alternating
false
predicates
xoldtnf
loops
abductive
backward
xsb
forest
stall
und
di
os
backtracking
predicate
ilkka
niemel
simplification
definite
delaying
coincides
conditional
resolution
forward
pfeifer
faber
mary
disjunctive
nonmonotonic
head
move
subgoal
decstation
credulous
delete
db
cse
leone
lifschitz
skeptical
disjunction
simplified
autoepistemic
gelfond
teaches
mgtp
stselect
gma
derives
gerald
francesco
nicola
timing
guessing
neg
deductive
beliefs
loop
answer
evaluated
pgm
diffchoice
modularly
calimeri
reasoning
fp
declarative
john
stratified
wolfgang
falsity
dlv
subrahmanian
links
quantification
calling
eiter
edge
complements
occurring
kripke
calls
deleting
universe
inconsistent
processed
warren
gelder
versatile
kleene
prototype
queries
pa
reduction
proposals
normal
oriented
derivation
vg
clark
stratification
annals
covered
instances
universal
intelligent
facts
pl
integrate
integration
bodies
enumerating
artificial
contexts
intelligence
portion
safety
renaming
interface
returned
selects
tabling
patrik
compacts
seas
furbach
gml
smu
giannella
pgml
timo
builtin
hyperresolution
eshghi
elkhatib
yahya
simons
atms
bry
balduccini
noby
pontelli
bonatti
stnot
resolving
student
stable models
stable model
founded semantics
well founded
win b
valued stable
residual program
ground atoms
logic programs
ground program
query evaluation
two valued
reduce algorithm
ground atom
finite ground
p gm
sean ai
truth values
assumed truth
model computation
negative literals
program p
irene ai
chris ai
ai diff
ai choose
b win
delayed literals
ai di
truth value
backward propagation
win c
alternating fixpoint
negative loops
three valued
forward chaining
normal logic
ground programs
choose sean
general logic
goal oriented
negative loop
fixpoint logic
chaining links
founded partial
color b
x win
tabled predicates
negative context
total interpretation
anss psm
undefined instances
choose irene
call win
conditional answers
bound method
move b
p os
partial model
m p
logic program
partial interpretation
p und
john cse5381
ai take
diff chris
diff irene
conditional answer
color d
teach john
computing stable
let p
oriented query
following program
ground negative
color c
negative literal
body literal
every clause
model semantics
search space
diff sean
teach mary
mary cse5381
prolog execution
query win
tabled predicate
atoms whose
y color
c win
choose chris
ground literals
choose x
false according
win x
di p
definite program
data complexity
original program
logic programming
positive literal
literal l
well founded semantics
two valued stable
model of p
valued stable models
assume and reduce
stable model computation
win b win
win a win
values of ground
finite ground program
assumed truth values
computation of stable
choose sean ai
general logic programs
branch and bound
three valued stable
valued stable model
well founded partial
forward chaining links
alternating fixpoint logic
founded partial model
b win b
sean ai diff
oriented query evaluation
goal oriented query
normal logic programs
set of ground
teach john cse5381
edge a y
computing stable models
chris ai choose
diff chris ai
occurs in p
diff irene ai
definition of stable
occurring in p
stable model semantics
ai di p
teach mary cse5381
color a color
number of stable
choose irene ai
win c win
logic of general
finite ground programs
time data complexity
assumed truth value
move a x
x win x
ai diff chris
propagation of assumed
used to delete
ai choose sean
ai choose irene
ai diff irene
choose x y
polynomial time data
produces a residual
diff sean ai
choose chris ai
true or false
clause in p
normal logic program
models of p

corpus/krapavin2000-test/624870.txt
demeter
law
supplier
acquaintance
rulename
defmethod
archive
grammar
parsedetails
preferred
referencesec
lieberherr
oriented
microfichefiles
lookup
programmer
flavors
parse
rulelist
bookssec
book
object
style
hiding
void
lookupparse
bookidentifier
karl
send
programmers
software
complexnumber
searchgoodstyle
searchbadstyle
classes
strict
attached
symbol
dictionary
declaration
adherence
client
library
suppliers
self
lifting
coupling
message
utilities
fragment
getbody
microfiche
friend
pushing
sigplan
isbn
hierarchy
sept
loan
documents
public
documentation
member
xiao
smalltalk
violations
guideline
responsibility
interface
frege
helm
brock
eiffel
listofbooks
riel
casais
mitch
wilde
fruleg
archmicrofiche
newobject
wirfs
messenger
ebnf
warwick
churcher
upwardly
aldrich
huitt
libraryofcongress
gar
cdromfile
compile
reusability
oct
minimization
parts
restricts
development
arguments
clos
cun
neville
aspectj
subpart
oops
lepe
penalties
notices
subparts
irwin
ignacio
browser
declare
statically
immediate
behavioral
thesis
modular
wand
obeying
maintainability
promotes
compositionality
benefits
rule
ffl
bad
informally
inheritance
body
ross
encapsulated
carl
localizing
redesign
document
compiler
languages
implements
comprehensible
assuring
pacific
norman
repeat
violates
growth
doug
programming
maintenance
declaring
communications
abstraction
program
visualisation
subclasses
encapsulation
aspect
vancouver
alternation
sent
richard
dependencies
phrase
members
return
asia
objects
jonathan
silva
toplas
expresses
adaptive
helps
readable
organize
boolean
versions
restriction
duplication
transform
evolution
repetition
localization
thousand
object oriented
acquaintance class
acquaintance classes
preferred supplier
parts class
instance variable
lookup rulename
demeter system
class c
class form
instance variables
class archive
strict version
defmethod grammar
good style
symbol rulename
type symbol
c void
part class
flavors defmethod
rulename type
send self
method m
class b
grammar parse
send send
class dictionary
book f
grammar lookup
class referencesec
preferred acquaintance
archive class
oriented software
oriented program
oriented programming
class definition
object form
supplier classes
supplier class
bad style
void grammar
implements interface
book book
list repeat
object version
symbol send
information hiding
class rule
oriented systems
f return
oriented design
class definitions
class class
preferred client
class used
created directly
class version
information restriction
none implements
karl lieberherr
self lookup
minimization version
class bookssec
class bookidentifier
parse rulename
lookupparse rulename
j lieberherr
classes used
library class
parts none
rulename parsedetails
rulename defmethod
software engineering
class hierarchy
f public
class library
acm v
objects created
acm sigplan
rule parsedetails
parsedetails defmethod
extended notation
rulename f
style rules
class book
class grammar
client methods
class microfichefiles
lookup symbol
archive archive
argument class
preferred suppliers
reference section
sept 1990
supplier objects
immediate parts
parsedetails c
parse symbol
fragment uses
g class
supplier object
interface class
rulename send
c case
oriented programs
message f
ffl b
class documents
rule lookup
programmer might
variable class
return type
compile time
software development
aspect oriented
given method
program fragment
law of demeter
rulename type symbol
object oriented program
object oriented programming
book book f
class of c
send send self
type symbol send
attached to class
c has parts
object oriented systems
object oriented design
object oriented software
send self lookup
objects created directly
grammar parse rulename
parts none implements
preferred acquaintance class
using the law
defmethod grammar parse
flavors defmethod grammar
c void grammar
symbol send send
lookup rulename parsedetails
class c case
self lookup rulename
lookup rulename type
preferred supplier classes
supplier to m
none implements interface
following the law
number of arguments
rulename parsedetails defmethod
interface class c
acm v 33
defmethod grammar lookup
parse rulename type
lookup symbol rulename
parts class archive
grammar parse symbol
grammar lookup rulename
method is attached
preferred client methods
parsedetails c void
parse symbol rulename
class archive class
f g class
parsedetails defmethod grammar
book f g
instance variable class
dependencies between classes
void grammar parse
implements interface class
archive has parts
rule lookup rulename
grammar lookup symbol
program fragment uses
law s class
book f return
symbol rulename f
object oriented programs
structure of complex
conference on aspect
aspect oriented software
member of class
oriented software development
number of methods
software engineering v
sigplan notices v
transactions on software
acm sigplan notices
v 33 n
called the law
referencesec has parts
paper are written
sends function calls
part of hierarchy
construction class definition
number of acquaintance
rule flavors defmethod
defmethod rule parsedetails
encodes the ideas
program which appears
lookupparse rulename defmethod
c void c
rules that constrain

corpus/krapavin2000-test/608352.txt
certifying
keerthi
qp
wd
int
wolfe
gilbert
convergence
svm
samples
chunking
working
indices
lanl
joachims
jv
dual
gsmo
cristianini
anysubset
smo
optimality
chang
lp
ur
shawe
svms
rate
bl
platt
nite
dened
cient
stepwise
sv
training
dene
properly
machines
decomposition
optimum
lin
modication
su
nished
vapnik
la
qpsolve
pairg
fdetermine
kkt
feasible
drive
criterion
taylor
dr
cortes
karush
dunn
zoutendijk
normalization
epsi
qw
regimes
denition
iterations
learning
nontrivial
convex
classier
kuhn
satises
rates
tucker
polynomial
routine
ong
concave
motivates
rst
margin
cancel
diers
classi
light
sample
barrier
constrained
edition
ordered
technical
slight
placing
equations
avriel
hush
serafini
zanghirati
parenthetic
jochamin
finitially
etadoty
osuna
scovel
extremals
igel
glasmachers
steinwart
innitesimal
performq
fsample
hsuen
zanni
betadoty
nikolas
qiao
algorithmic
excessive
specically
integral
jr
decomposing
concavity
gaetano
shevade
clint
bhattacharyya
soft
decompose
guarantee
unspecied
pai
covariates
jumped
unattractive
nonseparable
pass
improvement
aw
hulls
fif
tobias
singular
terminates
optimiza
mercer
yg
skips
neglecting
iteration
asymptotic
converges
restricting
chooses
violate
hao
ingo
log
index
establish
dierence
gramming
kelly
ulrich
thorsten
leveraging
rong
sqrt
syan
nishes
subscripted
improper
sorting
sort
preliminaries
ru
certifying pair
rate certifying
v low
working set
v high
low v
wolfe dual
d high
qp problem
support vector
vector machines
properly ordered
working sets
jv int
gilbert 2000
keerthi gilbert
high v
chang et
qp problems
certifying pairs
keerthi et
o m
smaller qp
ur 00
la ur
lanl technical
report la
high low
log m
m log
al 2000
cristianini shawe
one certifying
stepwise improvement
certifying algorithm
taylor 2000
existing svm
certifying condition
svm algorithms
step convergence
lin 2000
joachims 1998
model algorithm
su cient
al 2001
m light
sv m
low 0
shawe taylor
low low
m time
learning research
two indices
decomposition algorithms
technical report
smo algorithm
constrained wolfe
chunking algorithm
optimality using
nite step
anysubset routine
v int
nontrivial components
gsmo algorithm
d low
original qp
m operations
et al
polynomial time
decomposition algorithm
slight modication
using certifying
int w
v k
convergence rate
w c
v l
research 7
run time
index set
low high
w contains
optimality condition
k denote
current solution
machine learning
th iteration
q 2
many existing
qw c
three regimes
linear classier
leaves open
al chang
cortes vapnik
sequential minimal
margin formulation
z i2i
prove necessary
al keerthi
low g
feasible directions
overall run
guarantee progress
methods 1st
training errors
algorithm a 1
rate certifying pair
support vector machines
keerthi gilbert 2000
chang et al
keerthi et al
m log m
lanl technical report
high v high
d high v
report la ur
low v low
la ur 00
ur 00 3800
smaller qp problems
high low v
technical report la
o m log
et al 2000
cristianini shawe taylor
v high low
v low v
rate certifying algorithm
rate certifying condition
existing svm algorithms
shawe taylor 2000
least one certifying
one certifying pair
contains a certifying
et al 2001
sv m light
journal of machine
machine learning research
nite step convergence
using certifying pairs
algorithms for support
criterion to within
working set contains
jv int w
working set w
constrained wolfe dual
original qp problem
optimality using certifying
drive the criterion
low i high
class of algorithms
v l l
polynomial time bound
let k denote
learning research 7
solve a sequence
research 7 p
case of algorithm
log m time
number of samples
k th iteration
components of d
number of iterations
necessary and su
increases by c
open the question
al 2001 keerthi
v k v
remainder is used
algorithm a 2
m light algorithm
combinations of v
original problem solution
methods 1st edition
high 0 d
v int v
pair in o
et al keerthi
int low v
determine a certifying
normalization for r
negative at least
wolfe dual problem
cortes vapnik 1995
decomposing the original
classier in h
current solution plus
feasible _ w
subset of samples
d low 0
certifying pair dened
guarantee progress toward
high v low
conditions for stepwise
proof is nished
low v int
low and v
al keerthi gilbert

corpus/krapavin2000-test/629409.txt
crown
multilevel
crowns
events
consistently
chordal
security
bipartite
site
transaction
unclassified
leakage
ordering
event
orders
timestamp
secret
lattices
databases
planar
hasse
greatest
replicated
lattice
bouchitt
ordered
orderings
serialization
concurrency
secure
iff
exhibited
globally
classifications
decisions
sites
database
covert
partial
synchronization
timestamping
hierarchical
histories
inconsistent
message
directional
au
chordless
serializable
signaling
consulting
serializability
diagram
antichain
lamport
contradiction
nonplanar
serializes
locks
receipt
timestamps
consistent
visible
classes
incomparable
communication
relabel
prohibited
encapsulates
planarity
leaks
totally
dominated
lock
acyclic
vertex
antisymmetric
edges
raw
elimination
clock
enjoy
subgraph
cycle
detection
mod
directed
max
read
resort
split
graphs
remote
discarding
transitive
inconsistency
injective
vqg
unwound
nato
tisymmetric
unshown
trotter
semitrees
proscribed
pleasure
setups
unserializable
obliged
salowe
imagination
locking
channel
precedes
choices
subsequence
edge
inconsistently
kernelized
partite
leaking
diction
receipts
fuller
unwind
outgrowth
prominently
precluding
moh
vd
undirected
observations
items
neighbor
free
incident
restrictions
receiving
indirect
contra
envisioned
arisen
lapadula
rework
confinement
multics
communicate
comparability
conjectures
demarcation
rival
chord
confidential
unsurprisingly
vq
ivan
mcdermott
overt
erty
nization
concurrent
maximal
eliminated
cyclic
troublesome
ings
redo
mally
collect
derivative
channels
perhaps
scheduling
sketch
informally
mandate
suits
dominance
unable
dilemma
larly
unfamiliar
global p
consistently ordered
crown free
partial order
communication structure
partial orders
ordering decisions
multilevel security
hierarchical databases
communication structures
p max
crown detection
greatest element
e 1
ordered property
p j
least upper
event ordering
e 2
class p
split graph
globally consistent
concurrency control
secure databases
consistent ordering
free partial
bound classes
one directional
multilevel replicated
unclassified level
hasse diagram
bipartite graph
l e
free property
b high
local events
transaction processing
control algorithms
event e
security classifications
replicated secure
b low
global synchronization
n least
dominated classes
timestamping algorithm
secret level
bouchitt e
mod n
additional synchronization
global consistent
site b
directional communication
main database
planar lattice
induced subgraph
distributed environment
replicated databases
length greater
e p
must respect
multilevel secure
upon receipt
upper bound
maximal element
directed graphs
consistent event
one crown
without resort
synchronization information
planar lattices
totally order
unique greatest
transaction histories
consistent orderings
e bou85
timestamp generation
ordering assignments
replicated architecture
acyclic communication
sites communicate
receiving site
local order
planar partial
ordered consider
describe communication
globally inconsistent
inconsistent event
crown since
signaling channel
arbitrary directed
undirected version
execution histories
corresponding timestamps
partitioned synchronization
serializes e
given events
paper indicate
chordless cycle
synchronization rule
ordered iff
databases hc86
time o
global p j
consistently ordered property
least upper bound
crown free property
crown free partial
upper bound classes
concurrency control algorithms
mod n 1
security and hierarchical
replicated secure databases
n least upper
one directional communication
greater than 4
p must respect
nodes in q
exhibited in table
visible at p
free partial orders
multilevel replicated secure
covert or signaling
local to p
cycle of length
time o n
make some observations
set an element
j where class
prior to e
q is bipartite
order in figure
consistent ordering decisions
part by consulting
bouchitt e bou85
whether a communication
additional synchronization information
e i mod
structure is crown
consistently ordered iff
hierarchical databases hc86
directional communication structure
indicates that p
consistently ordered consider
global consistent order
property to describe
local ordering decisions
partitioned synchronization rule
unique least upper
crowns of size
algorithms for multilevel
class p j
g is chordal
ordering decisions without
decisions are possible
arbitrary directed graphs
condition on global
global p states
describe communication structures
globally consistent event
crowns in partial
states that global
least one crown
detection in arbitrary
see why suppose
unique greatest lower
ordered at p
event and ordering
encapsulates a database

corpus/krapavin2000-test/606913.txt
guarded
cgf
clique
gf
logics
lgf
modal
monadic
xed
formulae
width
bisimulation
quantication
sentence
bisimulations
satisable
loosely
fragment
countable
logic
tuple
decidability
satisability
bisimilar
sentences
rst
formula
benthem
lfp
innitary
quantier
kripke
quantiers
tree
guard
denition
calculus
gaifman
automata
decidable
propositional
atom
guards
ordinals
tuples
ml
unraveling
denable
nemeti
gradel
andreka
guardedness
arity
elementary
ht
substructure
exptime
backwards
induces
nite
maarten
marx
modalities
axioms
dened
ry
induction
coexist
isomorphism
rx
translation
sect
walukiewicz
gfp
vardi
theoretic
greatest
universe
fragments
saturated
ary
forth
ordinal
satised
cardinality
atoms
van
vocabulary
atomic
link
substructures
modality
denes
trees
saying
fa
axiom
quantied
erich
rabin
unguarded
determinacy
nestings
beth
gso
subformula
expressive
dene
decomposition
existential
isomorphisms
liberal
rwth
grdel
cardinal
invariant
alternating
tableaux
aachen
operators
denitions
informatik
notions
relations
games
simultaneous
predicates
variants
sx
ternary
ctl
forgetful
satisfiability
algorithmic
innite
pf
branching
inductively
constants
hai
ables
remark
conjunct
famous
agree
universal
stages
proposition
conjunction
packed
mu
contained
superposition
preprint
hypothesis
occurrences
relational
extensions
satises
machinery
really
fb
vari
ha
fv
permit
resp
talk
retains
overlapping
operator
structures
semantic
tyszkiewicz
graedel
rxyz
satisies
benthems
eyz
wheras
walulkiewicz
janin
tcgf
hodkinson
relativised
dismissing
mgi
clique guarded
xed point
guarded xed
loosely guarded
guarded fragment
guarded set
tree width
point logics
model property
guarded logics
rst order
width k
order logic
tree model
monadic second
modal logic
point logic
f v
guarded quantication
guarded bisimulations
cgf 1
xed points
least xed
clique k
satisability problem
tree decomposition
second order
guarded tuples
every satisable
modal logics
greatest xed
tuple b
guarded bisimulation
tuple d
van benthem
countable trees
point formulae
propositional modal
k bisimilar
guarded tuple
partial isomorphism
gf lgf
monadic relations
node v
f w
tree e
kripke structure
modal calculus
nite model
satisable sentence
guarded fixed
clique x
gaifman graph
every clique
set x
structure b
model theoretic
x 0
structure d
two structures
g w
cgf sentences
backwards modalities
relations o
maarten marx
guarded fragments
every formula
tuples c
structure k
andreka van
countable model
guard formulae
cgf sentence
associated tree
k unraveling
denition 2
formula x
node w
order formula
tree structure
tree representations
ary relation
free variables
order sentence
automata theoretic
g b
modal operators
order theory
g v
induction hypothesis
v b
v v2t
guarded xed point
tree model property
xed point logics
monadic second order
xed point logic
rst order logic
least xed point
guarded set x
second order logic
clique guarded set
loosely guarded set
induces a clique
lgf and cgf
every satisable sentence
least and greatest
xed point formulae
clique guarded tuple
clique guarded bisimulations
theory of countable
clique k bisimilar
propositional modal logic
guarded fixed point
every clique guarded
greatest xed points
kripke structure k
nite model property
fragment of rst
variants of guarded
invariant under clique
andreka van benthem
notions of guarded
structure t d
associated tree structure
b are clique
benthem and nemeti
clique guarded fragment
calculus with backwards
tree width k
set x 0
exists a node
back and forth
clique in g
x x 0
lfp rx r
rx r x
tuple d 0
xed point sentences
clique guarded quantication
loosely guarded quantication
gf and lgf
structure with tree
fixed point logics
guarded in b
structure has tree
exists a partial
tree decomposition ht
b is clique
tuple of monadic
m ary relation
model theoretic properties
sentence in cgf
k in cgf
sentences of width
xed point formula
d is contained
constant a 2
results for guarded
sentences of bounded
sentence of width
loosely guarded fragment
width k 1
monadic relations o
theorem 4 2
second order theory
decomposition of width
greatest xed point
rst order formula

corpus/krapavin2000-test/631204.txt
views
pipe
reuse
deltay
glisp
circle
correspondences
eqn
deltax
oop
generic
abstract
specialized
radius
procedures
mkv
translation
segment
xmas
lisp
diameter
cone
wrapper
var
atan
buttons
compiler
compilation
deleting
gldefun
compiled
interface
vars
equations
xfers
setf
leftof
menu
encapsulation
languages
graphical
diagram
reused
phi
solved
unsolved
idl
specialization
float
mouse
transfer
slope
polar
cos
tuple
software
conversion
expt
lileanna
formats
basis
transformational
storing
functional
gries
sqrt
translate
representations
fig
deleted
transformations
mathematica
algebraic
documenting
superclass
emulates
ml
correspondence
units
dep
modula
code
diagrams
tan
stored
references
reusable
runtime
theta
inside
lil
unchangeable
christmas
sinapse
glambda
miranda
create
object
compile
independence
measurement
interfaces
scientific
message
fields
manipulations
storage
polya
implementer
biggerstaff
kids
specify
polygon
algebra
symbolic
parameterized
store
inherited
exit
creation
generics
accomplishes
read
typed
language
oriented
calling
angle
clicking
program
field
viewing
cartesian
record
selects
modules
enter
versions
encapsulates
rigidity
broker
mathematical
sin
standards
inhibits
functors
produced
isomorphism
created
inefficient
dependency
button
programming
saved
clean
2d
compiling
checking
reusability
ontology
conformance
interoperability
equation
pi
everyone
warning
ordinary
solver
human
sharing
tree
subexpression
ls
standardization
someone
repeating
understand
ada
specialize
items
module
operate
packages
denotational
reusing
target
draws
basis variables
abstract type
application data
basis variable
application type
generic procedures
line segment
generic algorithms
deleting eqn
software reuse
inside diameter
var defined
transfer variables
abstract data
view type
glisp compiler
generic procedure
abstract variable
equation set
xmas tree
solved eqn
data type
desired variable
p pipe
circle p
symbolic algebra
solved variables
specialized versions
data types
graphical interface
data translation
independence properties
deltax deltay
oriented functional
2d deleting
leftof distance
enter var
exit vars
transfer variable
deltay p2y
deltay deltax
length cos
wrapper objects
using views
setf get
deltay length
object oriented
graphical user
specialized version
data structure
user interface
data representations
generic algorithm
expression tree
new equation
deleted tuple
abstract types
software engineering
tuple variable
type pipe
application types
eqn slope
transformational programming
theta 2a
produces efficient
deltax length
eqn deltay
eqn deltax
parameterized programming
atan deltay
line compilation
user obtains
repeating step
achieve reuse
length sin
goal type
basis equations
pipe divided
ordinary programming
correspondences using
deltax p2x
oriented programming
program development
units of measurement
pipe as circle
translation of data
divided by 2
storage and independence
abstract data type
specialization of generic
set of basis
deltay p2y p1y
application data structure
equation is deleted
views from correspondences
2d deleting eqn
enter var defined
object oriented functional
basis variable v
graphical user interface
object oriented programming
repeating step 2
application data type
type the user
interface is self
atan deltay deltax
type the view
versions of generic
deltax p2x p1x
equations for computing
theta 2a solved
variable is added
variables and equations
abstract data types
type of object
adapted to fit
makes the application
types t 1
cos l angle
might be inefficient
deltay 2b deleting
describe how application
ordinary programming language
line segment fig

corpus/krapavin2000-test/1024162.txt
frobenius
lattice
lenstra
polytope
aardal
instances
branch
lc
coefficients
infeasible
hurkens
hyperplanes
reformulation
sublattice
infeasibility
decompose
homomorphism
cornu
ejols
integer
wolsey
dawande
cplex
jr
asz
lov
width
determinant
rk
ry
hyperplane
diophantine
px
scarf
selmer
louveaux
decomposable
isomorphism
vectors
sylvester
gcd
simplex
branching
million
harder
intersect
quit
coordinate
search
interval
hermite
wi
dimension
feasibility
direction
delta
formulation
dual
integral
relaxation
rank
ker
print
projected
coefficient
reformulated
short
thin
euclidean
verweij
nmakes
knapsacks
fukuda
py
vectorx
cassels
beyer
zgiven
presolver
hungerford
zturns
thetaq
brauer
grbner
zsuch
bram
presolve
odseth
khinchine
whicha
weismantel
baniak
donet
nhave
dinate
hnf
orsa
feasible
spanned
column
solved
solve
claim
fy
vector
pure
schrijver
decompo
curran
stern
hendrik
financed
thetam
fmrx
coor
negativity
intersecting
tree
decomposition
axes
directions
nonnegative
matics
erd
lauritzen
tl
basis
contradicts
gammam
erb
russian
kannan
greenberg
gammaz
exceptionally
sition
integers
hard
frobenius number
lattice l
l 0
z n
integer vector
infeasible instances
instances prob11
instances cuww1
lattice lc
vectors p
aardal hurkens
lattice hyperplanes
vector x
b 0
full dimensional
polytope q
aardal et
search nodes
integer programming
cornu ejols
direction e
search tree
d l
computing time
delta 1
r z
tree search
node limit
lattice hyperplane
large frobenius
n simplex
projected polytope
frobenius numbers
lattice basis
million nodes
nodes created
pure sublattice
lattice z
unit direction
short vectors
basis reduction
search algorithm
lower bound
first group
lov asz
search direction
integer point
computational study
computational results
integer multiple
x f
r n
n gamma1
constant depending
large compared
l c
good search
column b
ry 2
first isomorphism
feasibility search
integer branching
solved within
solve using
dual lattice
dual l
decomposable structure
comparable sizes
branching algorithm
x a0
jr 1983
verify infeasibility
ker f
wolsey 2000
2d j
w lenstra
coefficients decompose
search node
lenstra 2000b
lenstra jr
unit directions
short p
integer direction
px mod
second computing
integer width
linear diophantine
al 2000a
dawande 1999
hermite normal
lattice reformulation
e n
basis vectors
l y
branch and bound
p and r
instances prob11 prob20
contain an integer
hurkens and lenstra
instances cuww1 cuww5
lattice l 0
lenstra s algorithm
solve by branch
aardal et al
e n gamma1
basis for l
tree search algorithm
class of instances
jr i j
d l 0
vector x f
r are linearly
short vectors p
large frobenius numbers
group of instances
l 0 c
b 1 gamma2d
lattice z n
direction e n
number of lattice
unit direction e
easy to solve
compared to p
due to assumption
vector x 2
hard to solve
x 2 z
number of nodes
see that instances
h w lenstra
instances were generated
instances we consider
first isomorphism theorem
integer branching algorithm
formulation in x
computing the frobenius
lenstra jr 1983
lattice basis reduction
louveaux and wolsey
b b nodes
second computing time
basis b 0
w lenstra jr
p k g
r k p
integer vector 2
lc is equal
w s d
b b time
et al 2000a
kernel of f
ejols and dawande
coefficient a 0
coefficients that decompose
image of z
width of q
decompose with short
decompose as follows

corpus/krapavin2000-test/1035806.txt
adversary
setonce
processes
writer
winner
wait
naming
lucky
registers
row
segment
randomized
register
shared
ff
tasonce
atomic
coin
protocol
keys
bits
game
owned
flip
log
writes
read
probability
crash
crashes
invoking
bit
corrupt
claiming
invoked
competing
reader
faulty
renaming
consensus
asynchronous
param
object
executions
adversaries
succeeds
resilient
rows
flips
intercommunication
mobd
freeness
executing
enabled
composite
wins
adaptive
invocation
coins
fnumber
ffln
primitives
adversarial
dirty
interprocess
expectation
selects
name
ns
running
pr
schedules
numbering
safe
segments
snapshot
randomization
strongest
win
var
outcomes
claimant
multivalue
unfrozen
processesg
fphase
spoiling
int
objects
contents
concurrent
anonymous
crashing
forward
key
od
oblivious
doesn
private
reads
captured
claimed
fair
free
je
infinite
snapshots
ends
freezes
gammac
success
gets
memory
idle
symmetric
indivisible
backed
array
asymmetric
elusive
names
scanning
events
tails
balls
deterministic
arbitrarily
competition
chernoff
sooner
stepping
immaterial
clean
executed
infinitely
lived
appendix
rounds
fluctuations
shot
tentative
succeed
invoke
rank
summation
event
executes
communicating
failures
failure
recalling
outcome
protocols
impossibility
sc
goto
atomicity
eventually
reaches
bins
computability
round
try
repeatedly
mg
broadcast
legal
agreement
write
synchronous
fspecifies
reinitialize
fshared
processg
fined
standardize
fffflkn
invokation
multiwriter
competitition
rowg
gameg
fspecify
searchg
segmentg
contenders
simp
ncg
claimants
worthless
adaversary
rangeg
prisingly
bstart
aloneg
wait free
test setonce
ff test
setonce object
n reader
writer n
shared memory
read writes
log q
row r
one process
process p
n log
running time
key range
n processes
adaptive adversary
free atomic
log n
naming protocol
log log
o n
shared bits
ff tasonce
n bit
read write
coin flip
composite register
naming problem
every process
system execution
name space
high probability
state c
probability ff
atomic read
competing processes
system executions
crashes occur
reader shared
write registers
randomized wait
bit operations
o log
q read
row row
single writer
non faulty
key space
bits proof
random key
reader 1
reaches row
setonce objects
adversary schedules
shared variables
expected running
row p
r rows
ns r
wait freeness
game ends
symmetric shared
corrupt objects
whole key
naming algorithm
free naming
invoking processes
process wins
steps forward
row k
faulty process
line 9
randomized consensus
free solution
crash failures
write b
bit registers
memory model
multi reader
writer multi
k p
coin flips
average running
b k
using shared
key k
key within
protocol segment
writer per
bit components
anonymous communication
reach row
shared atomic
lucky processes
enabled steps
reader wait
per component
least ff
process steps
using ff
private register
reader o
intercommunication primitives
b key
atomic bits
int fnumber
free test
shared registers
winner within
component composite
range size
initial execution
execution segment
n writer
processes back
first random
probability 1
p 0
possibly different
ff test setonce
test setonce object
writer n reader
o n log
wait free atomic
log n bit
lucky at row
log log n
atomic read write
free atomic read
n log q
q read writes
n bit operations
randomized wait free
read write registers
log q read
n log log
test and set
n reader 1
test setonce objects
o log q
owned by process
b k p
expected running time
o log log
time is o
n log n
probability at least
symmetric shared memory
wait free naming
write a row
object is invoked
reader shared bits
wait free solution
writes to 1
c i gamma1
n reader shared
gets a key
non faulty process
get a key
number of processes
n log 2
single writer multi
space of size
log n log
writer multi reader
average running time
succeeds with probability
using shared memory
n bit components
wait free test
reaches row r
multi reader wait
reach row r
n reader o
n writer n
process steps forward
hard to analyze
writer per component
find a key
whole key space
shared bits proof
log q bit
reader o log
way not known
n i log
uses a name
per component n
invoked by q
row p 1
initial execution segment
writes to shared
exactly one process
n component composite
selects a winner
non faulty processes
using ff test
doesn t work
every non faulty
l s gamma
p is owned
reader 1 writer
key range size
proof a process
reader wait free
component n component
processes it uses
bit b k
log 2 n
log log q

corpus/krapavin2000-test/1010995.txt
erlang
locker
client
crl
starvation
pending
clients
resources
specication
resource
locks
demanded
exclusion
verication
ok
mutual
server
release
eects
request
checker
huch
identier
callback
rst
requests
supervision
loop
ericsson
reply
evtfollow
checking
processes
toolset
self
yn
releases
starve
notied
promela
pathfinder
eect
java
tag
supervisor
alternation
viz
transition
requesting
eld
stamp
served
module
translate
gen
scenario
roy
modules
generic
translation
deadlock
actions
fredlund
erlangterm
obtainables
axd
ebaran
newlocks
chanchal
csar
xs
message
atm
calculus
critical
action
noll
ald
access
tool
hours
prover
dierent
tallinn
ication
bandera
estonia
liveness
elds
conguration
scheduler
development
translated
sigplan
lars
lock
repeatedly
uml
requested
priority
wonder
gets
appending
hd
spin
removing
crashes
exclusive
million
congurations
instantiated
started
scheduling
specic
transformation
eq
monitors
spec
statements
abstracts
veried
return
nd
portland
init
safety
verify
oregon
formulating
append
fault
resourcesg
ingenuity
svensson
itrue
benac
hubert
conrmation
cordy
therewith
noreply
wcallresult
pendings
boil
izak
dilian
earle
claessen
garavel
congu
rcallresult
jaco
sics
alpes
aldbaran
promissing
banani
advises
clientserver
ake
langevelde
gurov
fty
rhone
nite
programs
list
workshop
lists
calls
kumar
loops
clara
unsettled
koen
frequest
fokkink
pol
mateescu
caesar
noties
innite
excluded
crl specication
model checking
client 3
access pending
mutual exclusion
client 1
generic server
erlang programs
pending list
demanded resources
transition system
side eects
server call
client 2
handle call
model checker
side eect
pending 3
critical section
pending processes
locker algorithm
gen server
supervision tree
erlang code
two resources
erlang modules
call function
pending access
callback module
repeatedly request
erlang september
erlang program
alternation free
one crl
locker self
locker resources
clients repeatedly
end locks
exclusion property
eect free
three clients
get access
loop locker
free functions
starvation problem
gets access
demanded resource
requests resource
ok self
pending lists
erlang processes
rst come
locker process
come rst
sigplan workshop
case study
return value
specication language
source transformation
case statements
time stamp
one resource
checking tool
formal verication
data types
design patterns
access eld
deadlock mutual
resource b
requests b
give access
specic conguration
within ericsson
process identier
implementation language
rst serve
release client
self locker
huch 15
translate erlang
axd 301
ok message
obtainables locks
erlang transformation
list access
free calculus
client ok
csar ald
access 2
hd mcrlarg1
reply ok
erlang function
causes client
x y1
classical properties
xs y1
call stack
starvation since
contain side
access 1
locks false
ald ebaran
self locks2
formally veried
kumar roy
atm switch
pending 3 3
resources are available
gen server call
side eect free
workshop on erlang
clients repeatedly request
mutual exclusion property
acm sigplan workshop
rst come rst
eect free functions
access pending access
clients and locker
pending access pending
absence of deadlock
clients and resources
access pending 3
handle call function
one crl specication
loop locker resources
functions with side
number of clients
number of resources
model checking tool
source to source
list of pending
access 2 pending
implementation in erlang
ok self locker
list of resources
specication the erlang
pending list access
want to access
clients and two
deadlock mutual exclusion
xs y1 yn
causes client 3
erlang september 26
clients that want
come rst serve
chanchal kumar roy
resource a client
client 3 requests
approach of huch
client is notied
resource the client
list of clients
x y1 yn
csar ald ebaran
generic server design
specication is used
locker is implemented
access 1 pending
f x y1
alternation free calculus
request an arbitrary
contain side eects
server call function
requests both resources
client 2 releases
client 1 releases
erlang to crl
erlang september 16
use of model
client ok self
axd 301 atm
erlang to erlang
client 1 requests
implemented in erlang
releases and requests
self locker self
end locks false
september 26 28
using the generic
non deterministic choices
around this problem
functions that contain
september 16 16
using model checking

corpus/krapavin2000-test/611453.txt
chebyshev
residuals
ellipse
residual
foci
recursions
rutishauser
richardson
ultimate
recurrences
ult
roundo
krylov
iteration
res
coecients
rec
bicg
eigenvalues
polynomials
accuracy
axis
spectrum
conjugate
cg
acc
recurrence
ax
convergence
gradient
gap
poles
jt
recursion
expl
rut
joukowski
factors
segment
quotients
coupled
elliptic
stationary
pole
oating
matrices
quotient
iterates
asymptotic
exterior
spd
conformal
origin
roundoff
recursively
imaginary
nonsymmetric
norm
conditioned
absolute
updated
strakos
semiiterative
cosh
stagnate
solvers
uence
lie
straight
sucient
products
amplication
ultimately
nth
versions
iterative
elliptical
amplied
ellipses
interval
ill
norms
arithmetic
mildly
updating
denominator
attainable
aected
zeros
achievable
errors
ridge
epsilon
corrections
slowly
seriously
six
euler
inexact
matrix
determination
symmetric
nonlinear
come
peaks
reformulation
serious
overton
manteuel
residu
arcosh
summability
shev
iterationsverfahren
nonsymmetrizable
biconjugate
cheby
misprints
biomin
ansatz
kublanovskaya
confocal
verfahren
omin
iterations
explicitly
converge
summarizing
bi
semi
onto
zdenek
needless
orthogonalization
greenbaum
gutknecht
overrelaxation
diagonalizable
sinh
unitarily
stagnates
stiefel
inexactly
hestenes
allgemeine
rst
realization
slow
classical
rate
eigensystem
amplify
als
lanczos
nonzeros
denition
multiplicative
disk
monotone
inner
fig
iter
forecast
jbj
damped
golub
kf
bicgstab
dened
plotted
inserting
normalized
gmres
asymptotically
converges
dierent
oblique
chebyshev iteration
three term
two term
computed residuals
ultimate accuracy
explicitly computed
foci c
recursively computed
term recurrences
r n
chebyshev polynomials
coupled two
recurrence coecients
order richardson
true residuals
real axis
krylov space
b ax
line segment
term chebyshev
residual chebyshev
richardson iteration
acc n
rec res
res true
ult acc
w rec
true residual
term recursions
term recursion
absolute value
conjugate gradient
iterative methods
elliptic domain
term version
factors 48
updated residuals
local errors
rutishauser versions
x n
second order
computed residual
residual gap
n 1
straight line
segment c
algorithm 1
n 12
local error
point arithmetic
w expl
factors 12a
residual norms
semi axis
sucient accuracy
ellipse must
expl res
normal matrices
ax n
chebyshev 2x2
gap f
space methods
joukowski transformation
res rec
norms chebyshev
rut w
chebyshev rut
rec residual
number normalized
chebyshev 3
oating point
linear systems
achievable accuracy
recursions 6
term two
computing r
normalized residual
space solvers
iteration using
iteration see
residual fig
residual norm
asymptotic convergence
value smaller
iteration number
ill conditioned
iterations needed
domain e
methods based
inner products
around 0
side equations
term rutishauser
recursions iteration
whose foci
stationary second
step iterative
elliptical domain
standard three
ellipses chebyshev
consistency condition
jt 2n
assume iterates
approximation problem
residuals algorithm
roundoff effects
whose eigenvalues
ultimately achievable
solving choose
explicitly computed residuals
coupled two term
second order richardson
straight line segment
ult acc n
recursively computed residuals
res true residual
acc n 12
order richardson iteration
w rec res
r n 1
ellipse with foci
two term recurrences
three term recurrences
oating point arithmetic
term chebyshev iteration
line segment c
three term version
n 12 ult
chebyshev iteration using
three term recursions
chebyshev 2x2 w
krylov space methods
term and rutishauser
absolute value smaller
three term recursion
factors in 10
expl res true
factors 12a 12c
three term chebyshev
iterates and residuals
rec res rec
three term two
term two term
chebyshev 3 w
computing r n
true residual chebyshev
chebyshev rut w
w expl res
res rec residual
rec res true
b ax n
normalized residual norms
onto the exterior
version with updated
residual norms chebyshev
true residual fig
two term chebyshev
iteration number normalized
rec residual chebyshev
positive real axis
algorithm 1 except
number normalized residual
computed with sucient
n and r
recursively computed residual
krylov space solvers
methods for solving
interval 1 1
smaller than 1
matrices with eigenvalues
chebyshev iteration see
equations from 4
space methods based
r 0 b
residual chebyshev 3
stationary 2 step
axis a matrix
n 12 100
iteration for solving
term recursions iteration
coecients are computed
term rutishauser c
norm in conjugate
residuals by explicitly
updated and true
jt 2n 1
residual r n
step iterative methods
local error whose
avoid the residual
contrast to cg
elliptical domain e
whose components come
conjugate gradient type
ultimately achievable accuracy

corpus/krapavin2000-test/1039333.txt
distortion
bartal
metric
metrics
ws
steiner
metrical
log
cut
hsts
embeddings
approximating
embedding
laminar
approximation
cuts
competitive
trees
separates
center
spaces
stretch
outerplanar
settles
mendel
charikar
hk
vertices
spanning
labeling
wuv
tree
cluster
planar
polylog
probabilistically
edge
hst
polylogarithmic
settle
permutation
graphs
buy
rabinovich
minors
expectation
vertex
shall
hierarchically
gave
unassigned
decomposition
centers
konjevod
bourgain
talwar
ckr
separator
rao
probabilistic
italic
bulk
online
placement
chekuri
earthmover
radius
conquer
separated
alon
erent
clustering
pr
server
yair
linial
tardos
packing
seymour
rabani
ccr
min
family
karp
unfair
multicommodity
dia
euclidean
deterministic
aggregation
improves
dominating
lectures
algorithmic
hierarchical
flow
dual
adversaries
routing
diameter
vn
matthias
ratios
oblivious
ravi
arrange
volume
clusters
arc
london
rounding
covering
vehicle
inf
came
concurrent
fee
decompositions
doublings
englert
derandomized
derandomization
myampersandell
manor
ramsey
expec
aumann
derandomize
mour
burch
heirarchically
fractionally
sey
bollobs
manthey
harrelson
rcke
karlo
mimimum
multiembedding
dpst
metrices
thicknesses
logarithmic
showed
pick
rectangle
dominate
children
feedback
mobile
conditional
nsf
queueing
di
gupta
permission
tomkins
fakcharoenphol
pute
matousek
harald
roughgarden
archer
newman
salman
bla
telescope
distance
gap
singleton
excluded
geometry
shaded
cooperative
azar
diameters
wk
stoc
mat
calinescu
conducive
metic
anupam
scholarship
probability
distances
assigned
game
prefix
u v
log n
o log
tree metrics
d u
v d
approximation algorithms
metrical task
separates u
log log
approximation algorithm
metric spaces
cut decomposition
n log
metric labeling
k u
n approximation
k server
edge u
hk u
laminar family
distortion o
group steiner
steiner tree
spanning trees
d v
finite metric
log k
metric v
w cuts
center w
tree metric
hierarchical cut
cuts u
server problem
expected stretch
min sum
task system
bulk network
result improves
charikar et
n competitive
network design
k log
expected cost
outerplanar graphs
approximating arbitrary
well separated
log 2
pr u
task systems
competitive ratio
dual problem
ccr 0105533
settle u
cut u
topology aggregation
v ws
covering steiner
ws d
u ws
center v
planar metrics
communication spanning
center l
max flow
factor approximation
deterministic algorithms
algorithmic applications
probabilistic approximation
particular level
steiner points
arbitrary metrics
hierarchically well
conditional expectation
labeling problem
extension problem
arc set
v u
time approximation
improved approximation
flow min
min cut
al 17
random permutation
expected value
constant factor
approximating min
cuts trees
competitive concurrent
online tracking
approximating packing
rabinovich 37
v closer
chekuri et
wuv d
steiner problem
settles e
bartal 7
hsts bartal
via trees
factor came
distortion embedding
distributed queueing
probabilistic embedding
n distortion
probabilistically approximates
k outerplanar
cost spanning
linial london
k clustering
excluded minors
k hsts
v gets
polylogarithmic competitive
dominating tree
theoretic game
o log n
d u v
log n log
d t u
separates u v
n log log
log log n
v at level
d i 1
edge u v
log n approximation
u and v
o log 2
log 2 n
metrical task system
buy at bulk
d i separates
metrical task systems
group steiner tree
bulk network design
metric v d
assigned to w
hierarchical cut decomposition
k server problem
charikar et al
pr u v
metrics by tree
u v d
value of d
let k u
distortion o k
ws d v
decomposition of v
communication spanning trees
settle u v
distortion of embedding
graphs into 1
say that center
log n d
w cuts u
d v ws
gave an o
log n competitive
n d u
d u ws
k log n
u v 2
metric labeling problem
n approximation algorithm
v we shall
u is assigned
n log k
log k log
v d u
distribution over tree
hierarchically well separated
polynomial time approximation
max flow min
one of u
set of vertices
constant factor approximation
et al 17
u v v
o k log
n point metric
vehicle routing 16
k outerplanar graphs
log n distortion
distribution over dominating
approximating a finite
routing cost spanning
approximating the bandwidth
al 17 showed
n approximation algorithms
algorithms for unfair
labeling problem via
method of conditional
task system 10
distributed k server
deterministic polylog approximation
grant ccr 0105533
metrics into euclidean
via a new
chekuri et al
minimum communication spanning
result of bartal
approximating packing integer
center w cuts
level i let
aggregation for directed
embedding planar metrics
steiner tree problem
distortion and volume
cluster in d
since the radius
new linear programming
algorithms approximating packing

corpus/krapavin2000-test/1013843.txt
exposure
sensors
sensor
deployment
target
exposed
deployed
unauthorized
deploying
obstacles
region
fusion
energy
detection
east
alarm
grid
west
targets
emitted
periphery
detecting
lep
monitored
erent
activities
dijkstra
traversing
chapter
fictitious
speed
path
travels
speeds
obstacle
noise
deployments
segment
sensing
di
traveling
false
coverage
probability
field
density
traversal
alarms
surveillance
deploy
activity
weight
paths
signal
intensity
coe
decision
placement
south
measured
idling
collaborate
north
detect
threshold
collaborative
probabilistic
exposures
likelihood
distance
tradeo
cient
detections
detectability
mum
decay
collaboration
cumulative
segments
cd
decays
fault
energies
emits
weights
chi
network
varying
minimizes
confidence
networks
mini
profile
detected
grids
probabilities
shape
ciently
gaussian
shortest
position
monitoring
maximize
wireless
ut
fine
attempts
ective
hour
er
simulator
log
reached
reaching
highlighted
horizontally
finding
presence
investigates
freedom
desired
simulations
formulation
square
simulation
cs
formulated
peer
connecting
tolerant
fx
crossing
goodness
randomly
mlogn
posure
breach
agriculture
obstruct
peripheries
seconds
corrupted
crosses
develops
vertices
analytical
hoc
traverses
tolerance
travel
closest
website
civil
crease
tar
pollution
divider
covered
finer
cients
intersecting
cross
achievable
su
ect
measurement
location
ery
servations
minimum exposure
least exposed
exposed path
sensors deployed
detection probability
sensor field
decision fusion
false alarm
detecting unauthorized
unauthorized activities
activities using
sensor network
sensor deployment
alarm probability
target detection
constant speed
sensor networks
energy measured
value fusion
di erent
variable speed
desired exposure
energy emitted
path exposure
west east
point u
d u
n sensors
e d
region monitored
deploying sensors
target activities
exposure e
probabilistic exposure
expected cost
grid point
speed targets
unauthorized traversal
target travels
one sensor
deployment strategy
path p
detection algorithms
g p
deployment region
line segment
possible paths
log g
least exposure
unauthorized traversing
sensing range
monitored region
exposed paths
travels along
deploying one
exposure level
target traveling
lep west
monitored deployment
region nodes
detection attempt
detection attempts
target activity
signal emitted
false alarms
detection performance
speed problem
weight path
sensor placement
grid points
varying number
sensor nodes
distributed detection
three di
grid size
exposure density
sensors randomly
fictitious point
detection level
multiple speed
m sensors
east west
signal intensity
namely value
detecting sensors
least exposed path
number of sensors
using a sensor
detecting unauthorized activities
unauthorized activities using
false alarm probability
presence of obstacles
detecting a target
dijkstra s algorithm
cost of deployment
value and decision
point of interest
find the least
alarm and detection
log g p
target is assumed
figure 1 4
finding the least
cost of deploying
least exposed paths
weight of 0
distribution of minimum
deploying one sensor
deployment region nodes
region monitored deployment
exposure e d
west to east
lep west east
log m l
networks for target
sensors are deployed
monitored deployment region
d v u
d d u
three di erent
region of interest
position of target
collaborative target detection
probability of detecting
find the path
figure 1 6
detecting the target
minimum exposure e
detection probability d
point u p
east figure 1
variable speed targets
west east figure
deploying sensors randomly
sensors minimum exposure
tolerance in collaborative
west east unauthorized
traversing the region
figure 1 9
figure 1 7
cover the region
minimum exposure density
sensors at every
distributed sensor networks
minimizes log g
erent target activities

corpus/krapavin2000-test/608666.txt
stalker
skipto
wien
wrapper
extraction
landmark
knoblock
landmarks
wildcards
semistructured
muslea
minton
sources
tokens
disjunct
craig
ec
training
disjuncts
wrappers
matches
web
ion
items
token
zagat
skipt
restaurant
documents
steven
rules
learndisjunct
softmealy
refining
uncovered
wrap
item
la
document
kushmerick
learning
tex
induction
phone
candidates
weekly
wrapped
content
match
whisk
skipuntil
exs
wildcard
perfect
parent
seed
prefixes
pages
disjunctive
extract
imperfect
perfectly
zip
slot
prefix
consume
src
hierarchical
fewer
learned
unconsumed
restaurants
altigran
las
rule
extracting
refinements
extracted
consumes
adisjunct
htmltag
listiter
rapier
candidate
wraps
agents
learns
html
lists
laender
imperfectly
missing
accuracies
late
labeling
terminals
extracts
automaton
iteration
tuple
prefer
punctuation
orders
addresses
silva
wai
everything
early
learn
accuracy
format
wic
generates
tuples
covered
automata
variations
soderland
skipu
quafafou
srv
accur
alphabetic
turmo
cuisine
mecca
retv
seafood
ntil
listextr
desai
colfax
habegger
orderdisjuncts
page
transition
failed
da
consumed
prefers
anything
unsupervised
inductive
codes
visa
sourav
capitalized
atzeni
postprocess
bhowmick
street
alberto
median
intelligent
rejects
refine
ignore
tie
readable
name
chawathe
expressive
terminal
tries
linguistic
lam
suffix
ends
fails
ribeiro
neto
berthier
embedded
refinement
ashish
docs
extraction rules
wrapper induction
information sources
steven minton
semistructured information
ion muslea
hierarchical wrapper
training examples
muslea steven
minton craig
information extraction
skipto b
iteration rules
ec tree
list extraction
paper tex
tex 19
skipt o
missing items
various orders
seed example
list iteration
extraction rule
initial candidates
perfect disjunct
la weekly
uncovered examples
correct matches
early matches
area code
wien stalker
data extraction
landmark l
information agents
restaurant name
area codes
examples stalker
matches within
refining process
fewer wildcards
extraction language
stalker generates
linear la
extraction tasks
late matches
perfect rules
failed matches
end rule
wien fails
inductive algorithm
refining candidate
ec description
prefer candidates
stalker uses
data knowledge
positive examples
web pages
fewer tokens
test domains
knowledge engineering
rules based
da silva
training example
engineering v
src wien
correct rule
imperfect wrappers
stalker requires
zip code
stalker wraps
skipto rules
last token
landmark automata
stalker creates
rule skipto
extracting data
embedded lists
ignore everything
extraction systems
covered examples
token landmark
disjunct d
wrapper generation
linguistic constraints
three initial
initial candidate
prefix x
o skipto
zagat document
stalker may
craig a knoblock
semistructured information sources
hierarchical wrapper induction
steven minton craig
ion muslea steven
induction for semistructured
muslea steven minton
tex 19 11
paper tex 19
appear in various
sequence of tokens
number of training
data knowledge engineering
knowledge engineering v
stalker and wien
extraction and iteration
altigran s da
number of examples
start and end
src wien stalker
problem into several
active learning techniques
uncovered examples stalker
skipt o skipto
extraction rules based
learning extraction rules
information extraction systems
weekly and zagat
o skipto b
prefix x p
skipt o b
list iteration rules
rule that consumes
three initial candidates
web information extraction
adding more terminals
items and items
alberto h f
rule that extracts
h f laender
list of addresses
web based information
web intelligence p
september 20 24
many as possible
algorithm that generates
conference on web
wic acm international
allow the use
ieee wic acm
n 2 p
l i j
already covered examples
ignore all tokens
domain specific wildcards
items that appear
list iteration rule
document in figure
extraction rules presented
items that may
token that represents
best refining candidate
unconsumed prefixes longer

corpus/krapavin2000-test/629058.txt
arrays
array
partitions
loop
partitioning
loops
interprocessor
offset
ff
communication
processor
cc
diagonals
supercomputing
kandemir
alignment
partition
locality
offsets
choudhary
compilers
compiling
compiler
interchange
accesses
banerjee
ramanujam
mahmut
allocation
anti
superb
partitioned
multicomputers
transformations
operands
machines
columns
pingali
simd
programmer
decompositions
optimizing
parallelograms
equations
references
executes
automatic
parallelogram
fortran
restructuring
processors
alok
parallelizing
multiprocessors
ping
dependences
annotations
esin
jih
woei
mongenet
gannon
aids
formulation
incurred
rows
fi
outer
taylan
decomposition
hyperplane
memory
compatible
wrap
huang
vectors
deriving
parallelism
sheu
family
interchanging
peizong
keshav
kth
paid
shared
prithviraj
mar
supercompilers
catherine
iterated
distribute
volume
parallelization
accessed
numa
nests
shenoy
iterations
transformation
interchanged
nested
notices
matrix
tokyo
computers
diagonal
dataflow
writer
chu
compilation
programs
owner
mod
workload
supercomputers
shapes
mutually
sigplan
referred
consuming
chih
procedural
wei
defines
minimizing
rowwise
ender
ponnusamy
marchdec
zdamar
orchestrating
suprenum
prith
acknowlegdment
kastner
wenrui
zima
knobe
rnger
zcan
enormity
memetic
rauber
loechner
minyi
equationsb
musicus
raja
lebarta
systemb
linet
onbaioglu
todate
onbasioglu
gudula
stripmined
gallivan
assignment
li
sequentially
february
japan
memories
worthwhile
row
organization
admit
free
scientific
rewritten
macro
inter
gupta
affine
minimize
architectures
passing
day
incur
improving
trapezoidal
relieved
akimasa
koshizuka
yoshida
nagaraj
nonshared
cedar
ayguad
honoring
chua
cierniak
blaze
communication free
free partitioning
ff cc
c 0c
offset vectors
array b
processor k
b ff
distributed memory
interprocessor communication
constant offsets
zero communication
parallel loops
ff 0
free partitions
executes 1
memory machines
k executes
local memory
linear references
parallel lines
dimensional arrays
loop interchange
following system
data distribution
r mod
anti diagonals
following loop
data partition
fully parallel
j ramanujam
k p
complex memory
shared memory
compiling programs
loop l
outer loop
compatible partitions
communication minimization
alignment functions
mutually compatible
process partitioning
solution 1
loop transformations
automatic data
array accesses
parallelizing compilers
supercomputing p
following set
data partitioning
data decomposition
supercomputing v
storage patterns
sequentially iterated
matrix notation
iterated parallel
index domain
alok choudhary
inter processor
computers acm
minimizing communication
distributed systems
wei li
fortran programs
allocation problem
memory systems
array elements
data allocation
systems v
example example
example 10
array element
array access
fi 0
li keshav
complicated example
discuss techniques
also assigned
normalization loop
lines given
access normalization
loop example
communication see
data usage
vectors q
current day
describe array
diagonals figure
huang chih
accesses result
get ff
therefore worthwhile
determine allocation
jih woei
given partition
automatic process
loop interchanging
incur zero
deriving heuristics
catherine mongenet
optimizing data
therefore ff
set array
communication free partitioning
b ff cc
partitions of arrays
communication free partitions
executes 1 k
k executes 1
processor k executes
one of ff
b for example
b c 0c
family of lines
set of equations
partitioned into columns
fully parallel loops
lines in array
partitioning is possible
family of parallel
system of equations
partitioning of arrays
conference on supercomputing
distributed systems v
transactions on parallel
parallel and distributed
distributed memory machines
formulation that aids
b are partitioned
p to n
communication is incurred
ff 0 means
partitioned into rows
loop after transformation
present a formulation
partitioned into anti
shows the partitions
allocation of arrays
locality of reference
journal of supercomputing
sequentially iterated parallel
attention is paid
iterated parallel loops
n by p
assigned to processor
defines a family
order to minimize
consider the following
elements of array
techniques for data
shared memory machines
parallel programming v
journal of parallel
values of c
huang chih ping
pingali access normalization
line in array
describe array accesses
data access graph
communication see figure
partition of b
technique for linear
non trivial solution
distribution in superb
addition to managing
communication when communication
offset vectors q
loop l 1
processors is p
therefore for communication
compiler to analyze

corpus/krapavin2000-test/1005397.txt
animal
anml
ccalc
car
lmw
nextsegment
zoo
mounted
pos
cars
segment
gate
nonexecutable
mount
animals
homer
tra
jumbo
human
varsigma
rider
road
positiveorientation
sg
formalization
species
riding
sp
causal
cage
action
choosesegment
cages
position
giunchiglia
getoff
willleave
throwoff
world
opened
ds
caused
actions
speed
positions
uent
loc
gates
laws
none
vacated
maxstep
adult
calculator
landscape
modifiedorientation
travelled
cagea
thrown
specication
neighbor
moves
deliberative
inertialfluent
rides
distance
move
sides
snoopy
quoted
seg
speeds
humans
segments
velocity
constants
node
grounding
sdfluent
mounts
humanspecies
thielscher
modifieddistance
maxint
gateao
lifschitz
commonsense
closing
occupancy
scenario
leave
silver
mounting
vehicles
accessible
locations
ahead
posi
constraint
roads
spacecraft
traffic
movement
waiting
defeasible
utexas
henschel
joohyung
startnode
throwo
largespecies
modifiedsegment
maxspeed
doneby
enter
specic
named
uents
default
front
neighbors
mentions
declared
unspecied
travelling
modelling
surrounding
restriction
safety
nd
elephant
preconditions
integers
query
formalize
motion
outside
drivers
domains
opening
nondeterminism
throw
moving
dened
tag
stay
topography
exogenousaction
ridden
mccain
hudson
geto
dismount
topspeed
horse
law
circumstances
sort
abbreviation
failed
disjunctions
clause
exceptions
entering
crossings
getting
killing
exogenous
throws
eating
ascii
denite
driving
nondeterministic
rst
language
transitive
supposed
le
dierent
restrictions
agents
c world
zoo world
pos anml
h anml
nextsegment c
c sg
anml p
tra c
large animal
p p1
distance car1
human cannot
c none
mounted h
road segment
new segment
segment car1
nextsegment car1
speed car1
node car1
distance car2
lmw constraint
large animals
giunchiglia et
speed limit
node c
mount h
pos h
animal moves
c sp
al 2003
neighbor p
anml p1
cannot attempt
causal calculator
pos anml1
sides p
top speed
another large
safety distance
anml human
neighbor relation
speed limits
none speed
modelling workshop
segment car2
animal cannot
waiting area
nonexecutable mount
causal laws
action language
speed c
nextsegment car2
logic modelling
speed car2
loc pos
occupancy restriction
opened g
pos homer
action domains
maximum speed
query maxstep
willleave c
pos jumbo
positiveorientation c
continuous motion
getoff h
choosesegment c
caused speed
road segments
lmw nonexecutable
none nextsegment
deliberative cars
position adjacent
constraint pos
top speeds
anml h
distance travelled
input language
c nd
two positions
h g
language c
end node
two large
p pos
surrounding tra
dynamic laws
none node
throwoff anml
modifiedorientation c
distance car3
users tag
h h1
tra c world
pos anml p
nextsegment c none
mounted h anml
giunchiglia et al
p p1 g
nextsegment c sg
attempt to mount
et al 2003
language of ccalc
nextsegment car1 none
sides p p1
pos anml p1
another large animal
neighbor p p1
mount h anml
human cannot attempt
nonexecutable mount h
logic modelling workshop
none speed car1
position just vacated
node car1 none
quoted in section
getoff h anml
speed car1 2
al 2003 section
two large animals
node c nd
anml human cannot
car in front
choosesegment c sg
close a gate
caused speed c
h anml p
constraint pos anml
expressed by integers
segment car2 seg_bc
speed car1 1
none nextsegment car2
f after g
choosing a new
p 0 pos
caused node c
edu users tag
p pos anml1
distance car1 2
animal s present
h anml human
absence of actions
close h g
loc pos homer
mount an animal
pos anml1 p
action language c
g human cannot
anml p pos
none node car2
riding an animal
surrounding tra c
species are large
pos h p
point in time
enter a new
number of positions
section 2 1
utexas edu users
cs utexas edu
www cs utexas
c a d
query query maxstep

corpus/krapavin2000-test/628247.txt
clindex
cluster
ios
clusters
tsvq
cell
dataset
nn
cf
clustering
io
ep
nearest
query
golden
pac
cells
sr
outlier
similarity
indexing
disk
image
tree
centroid
id
elapsed
images
retrieved
neighboring
subregions
precision
spaces
objects
neighbor
neighbors
approximate
retrieval
wall
edward
outliers
search
stripes
adjacent
dimension
object
em
chang
blocks
ffl
directory
heap
schemes
index
sequential
ms
vase
resides
datasets
retrieving
retrieve
recalls
recall
multimedia
goh
cliff
crawled
queries
block
curse
dimensional
five
centroids
clock
cheng
indexes
theta
motwani
file
suffer
searches
cc
databases
dimensionality
versus
indyk
horizon
sequentially
height
ids
distances
pyramid
divide
communities
amsaleg
luminescence
gros
eamonn
kingshy
tentacles
berrani
keogh
beitao
reclustering
heapfind
lonardi
pbir
ten
bulk
nearby
efficiency
populated
read
phi
baltimore
seek
objectives
feature
hashing
shy
hadjieleftheriou
tallies
marios
keke
ciaccia
athitsos
fective
patella
lai
quality
grids
axis
ffi
regions
rotational
achieves
dimensions
accuracy
traditional
forming
finely
kollios
jessica
ottawa
vassilis
content
fi
near
clustered
divides
top
periments
kwang
subregion
lately
sclaroff
sid
bits
cutting
perception
shapes
database
closest
selectively
believe
king
clus
dram
trades
tenth
belongs
mining
returning
metric
contiguously
alfredo
contiguous
fraction
conducted
grouped
structures
stored
learning
stan
ineffective
ahmed
laurent
requested
vision
loading
exponentially
lookup
mbps
tois
boost
query object
r tree
pac nn
similarity search
sr tree
high dimensional
cf algorithm
outlier cluster
cluster size
golden results
m tree
cell id
image dataset
approximate similarity
nearest neighbors
dimensional spaces
nearest neighbor
clustering algorithm
mapping table
r precision
nn scheme
elapsed time
one cluster
index structure
k nn
one io
relative distance
five ios
cf r
cluster directory
d theta
tree structures
io time
recall versus
neighboring blocks
tsvq ep
nn queries
nn query
top k
approximate nearest
wall clock
image retrieval
entire dataset
neighbor search
top 20
tree like
io efficiency
edward chang
cell belongs
distance errors
cf tsvq
centroid information
index structures
feature vector
pre processing
like structures
based image
high recall
sequential file
clustering algorithms
control parameters
block size
query time
higher recall
x ios
ep scheme
whose centroid
sequential ios
objects retrieved
cluster id
traditional index
target recall
five schemes
feature vectors
similarity query
cluster whose
new cluster
clock time
indexing structure
query point
given vector
good clustering
large clusters
tree structure
search space
dimensional space
disk blocks
image set
o d
number of ios
clindex with cf
high dimensional spaces
approximate similarity search
pac nn scheme
tree and sr
number of objects
nearest neighbor search
number of clusters
tree like structures
approximate nearest neighbor
tsvq and ep
relative distance errors
cluster the cell
cell is adjacent
ep and r
search in high
based image retrieval
cluster whose centroid
top 20 golden
cf r tree
high dimensional space
wall clock time
achieve a target
number of points
clustering and indexing
conference on multimedia
content based image
high dimensional data
acm international conference
good clustering algorithm
dimension into 2
wei cheng lai
different cluster sizes
o d theta
recall than tsvq
perception based image
cluster is stored
exact similarity search
cf clustering algorithm
show that clindex
n theta d
theta d theta
time versus recall
traditional index structures
clusters the recall
takes o d
r tree sr
r sr tree
tree sr tree
cf r sr
top k golden
ios are performed
o n theta
sr tree figure
recall of cf
meets databases june
workshop on computer
vision meets databases

corpus/krapavin2000-test/609238.txt
xpoint
cbv
uniformity
iterator
filinski
axioms
calculus
continuations
hasegawa
kakutani
rigid
recursion
axiom
category
iterators
operators
monad
operator
uniform
functionals
axiomatization
bijective
simpson
kleisli
categorical
rst
plotkin
switch
stable
selinger
cps
continuation
cpo
morphism
typed
pets
centre
lambda
correspondence
algebra
monads
bot
fixpoint
semantic
xpoints
sml
stability
algebras
theories
eects
duality
centrality
eta
morphisms
central
coproducts
denition
justied
sound
proposition
loop
recursors
bekic
conway
premonoidal
dinaturality
fuhrmann
rigidness
style
products
syntactic
bijectivity
axiomatized
eect
equational
strict
functional
dene
canonically
typing
parameterized
adt
nite
tx
ty
iteration
reasoning
characterisation
fun
lemma
spelling
hy
principles
dened
counterpart
axiomatics
fossacs
thunkability
filin
dinatural
jerey
discardable
strictness
arose
summarised
focal
monadic
arrow
languages
categories
diagonal
adjoint
equivalently
predomains
thielecke
inspecting
constructions
converse
axiomatic
ki
response
principle
name
hofmann
judgements
moggi
nj
hx
veried
theoretic
thesis
contravariant
capital
carsten
cartesian
bottom
completeness
sabry
totality
axiomatizations
ski
exponentials
dierent
remark
combinators
uniquely
amounts
dening
maps
passing
ole
soundness
commutes
parametrically
judgement
subterm
congruence
enjoys
semantics
sucient
strong
graphical
conversely
shall
strengthen
characterised
recalling
objects
notion
calculi
negative
presence
family
parameterization
appendix
consideration
lifting
syntactically
expansion
sums
interpreting
notions
distilling
tinuations
specialise
blain
alpgebra
trivialising
thunkable
schweimeier
ciple
chasings
ohori
partical
isao
copyable
tensorial
distill
axiomatisations
xpoint operator
xpoint operators
stable uniform
c calculus
cbv xpoint
rst class
class continuations
uniform cbv
uniformity axiom
value xpoint
rigid functionals
bijective correspondence
cbv calculus
switch 1
uniformity principle
value calculus
uniform call
uniform iterator
r c
category c
computational lambda
x v
uniform xpoint
algebra morphism
lambda calculus
algebra structure
uniformity principles
c theory
uniform iterators
cbv theory
negative types
uniformity condition
function types
stability axiom
cps transformation
negative objects
strong monad
rigid functional
passing style
continuation passing
base category
object r
nite products
fixpoint operators
let x
categorical semantics
values f
response category
least xpoint
plotkin 27
xpoint equation
diagonal property
kleisli category
f holds
domain theory
internal language
value programming
eta expansion
response object
term m
computational model
main result
total functions
second main
side eects
h f
n x
rst main
value recursion
algebra morphisms
value setting
value strictness
continuation monad
strict maps
types terms
step pets
style reasoning
xpoint axiom
hy ki
bekic property
loop g
iterator loop
operator restricted
complete class
iteration theories
uniquely extends
call by value
uniform t xpoint
recursion in call
axioms for recursion
rst class continuations
hasegawa and kakutani
uniform cbv xpoint
stable uniform cbv
cbv xpoint operators
x be m
stable uniform call
call by name
presence of rst
category of continuations
simpson and plotkin
computational lambda calculus
value xpoint operator
sound and complete
cbv xpoint operator
filinski s uniformity
iterator on r
uniform xpoint operator
m in n
recursion from iteration
base category c
notion of uniform
continuation passing style
v be m
m in let
operator on negative
value programming languages
uniform t fixpoint
value xpoint operators
centre and focus
category with nite
filinski s construction
u n x
second main result
recursion and iteration
lambda calculus 18
cbv xpoint axiom
h is rigid
n be m
switch and switch
operators of simpson
stable uniform xpoint
restricted on negative
response object r
stability and uniformity
recursors and iterators
notion of centre
rst main result
operator on c
category of algebras
m in u
xpoint operator restricted
h is total
least xpoint operator
f 2 c
family of functions
c t x
free in f

corpus/krapavin2000-test/631150.txt
standby
warm
temperature
seniority
jacket
reactor
copy
hot
batch
reliability
copies
profile
cold
sensor
valve
junior
steam
reaction
cb
master
processor
reactions
mse
primary
processes
concentration
fault
processors
failure
oe
recovery
allocated
profiles
water
tolerant
hierarchically
alive
vulnerable
chemical
hardware
failures
slots
parent
sampling
nrc
unmaintainable
kinetics
valves
tolerate
unreliable
load
simulated
unattended
deprived
harsh
senior
period
survives
supervisor
filled
replication
restart
fail
child
instr
actuator
serving
frequency
charge
houston
cooling
hierarchy
consume
spare
link
favorable
backup
controller
stop
hierarchical
lived
acquiring
tolerance
simulates
triple
simulation
replicated
proportional
double
controlling
repair
capacity
yield
self
burst
rate
allocation
prescribed
peer
active
controls
formulating
partial
reactant
helicopter
chical
exothermic
chemicals
mississippi
seniorities
weir
vessel
magnitude
fraction
fails
minute
broadcasting
channel
subsystem
temporary
continuity
faulty
logical
loading
nel
xw
reac
bastani
regulating
effecting
reacted
proportionately
howev
sumed
date
capability
structured
receiving
reliabilities
datagram
regulatory
nuclear
quirements
backups
damages
eter
tmax
ess
puter
consecutive
redundancy
envision
unexpectedly
gammac
er
failed
simulator
advances
ceases
sync
disruption
stand
critical
broadcast
inventory
responsibilities
die
governs
links
protocols
commission
possessing
disrupt
decline
ent
iff
exponentially
prac
repairing
surviving
formulates
param
sequently
heat
advancing
instantaneously
tice
logged
catastrophic
favored
warm standby
hot standby
control process
temperature profile
standby system
standby copy
standby copies
batch reactor
standby scheme
primary copy
jacket temperature
cold standby
partial copy
control processes
sensor input
master control
batch reaction
logical communication
junior copy
process control
processing power
level processes
full copy
reactor system
partial copies
oe m
control programs
steam valve
standby schemes
sensor sampling
optimal temperature
temperature control
chemical batch
using warm
control hierarchy
temperature profiles
fail stop
hierarchically structured
hierarchical control
stop processors
level 2
fault tolerant
p 3
control program
level 1
full copies
seniority function
input temperature
water valve
simulation evaluation
vulnerable period
consecutive reactions
solution concentration
sampling frequency
control information
underlying hardware
processor failures
hardware failures
hardware cost
communication link
level 3
recovery time
system failure
mean square
square error
communication links
upper level
p 4
takes charge
triple processor
copy provides
recovery rate
double failure
three copies
standby redundancy
cb desired
iff 9a
new seniority
seniority equal
standby using
standby warm
active copies
structured system
global factors
unmaintainable systems
order consecutive
temperature changes
channel process
final yield
copies e
jacket processes
g instr
using hot
parallel structure
batch reactions
warm standby system
warm standby copies
warm standby scheme
master control process
warm standby copy
hot standby copies
process control programs
hot standby system
yield of cb
jacket temperature control
using warm standby
chemical batch reactor
batch reactor system
copy of m
fail stop processors
logical communication links
sensor input temperature
oe m p
level 3 process
hot standby scheme
level 1 process
upper level processes
logical communication link
copy s seniority
frequency of receiving
input temperature profile
hot standby copy
copy with oe
temperature control process
lead to system
oe a p
lower level processes
process which simulates
mean square error
order of magnitude
processes are embedded
control process needs
standby copies e
receiving the sensor
failures are possible
level 2 process
standby and hot
use of warm
order consecutive reactions
copies of j
environments where burst
processes i e
cold standby schemes
g instr sec
closed when p
reliability of partial
replicated on three
oe a y
operating in harsh
hierarchically structured system
yield of b
processes e g
jacket temperature profiles
triple processor failures
detailed one corresponding
embedded is simulated
proportional to oe
seniority for example
hardware is unreliable
provides direct control
software failure rate
parent to child
containing a full
first order consecutive
desired temperature profile
hence the frequency
exponentially distributed time
temperature sensor input
long lived unmaintainable

corpus/krapavin2000-test/609316.txt
qos
seamless
wireless
mobility
portable
mobile
prayer
home
caching
backbone
file
consistency
disconnected
cached
handoff
tcp
network
negotiation
transport
adaptation
migration
cdpd
disconnection
networks
adapt
owned
outdoor
connection
ip
challenges
indoor
mode
policies
adaptive
management
notification
stations
files
hoard
autonomously
networking
cellular
reintegration
service
mosquitonet
hoarded
reaction
bayou
connections
environment
hoarding
modems
invalidation
server
interoperable
csma
collaboratively
fields
gracefully
contemporary
commercially
notifications
reconnection
bandwidth
medium
afs
getqos
template
pricing
goals
manager
diverse
aware
consistent
cells
records
graceful
os
react
offs
conflicts
agent
notifies
rollback
organizations
station
trade
wired
ram
switches
standards
accompanied
operating
commercial
operated
policy
across
coda
record
connectivity
authentication
proprietary
inter
kept
transparent
semantic
mailbox
barwan
reintegrate
wlan
onus
dane
reintegrated
seer
appointments
mdm
pconsistency
ficus
private
scarce
imposes
traffic
grain
descending
notified
technologies
handling
bursts
granularity
mechanisms
invalidate
writes
man
supports
secretary
pda
voluntary
witnessed
provider
servers
read
clients
services
emergence
induce
layer
exception
virtual
environments
filesystem
tdma
dwyer
snoop
stubs
security
explores
interfaces
heterogeneous
dynamics
granted
session
dynamically
partially
copy
disconnects
connectedness
mth
disconnections
sprite
abort
connected
viable
drivers
calendar
mh
predictive
email
directed
broad
targeting
negotiated
parametrized
nfs
interact
client
cache
reads
puters
priority
block
migrate
awareness
ghz
intermittent
managed
seamless mobility
mobile computing
computing environment
portable computer
wireless networks
adaptive computing
consistency management
file system
wireless network
multiple wireless
mobility across
disconnected operation
qos class
consistency policies
home computer
qos changes
partially connected
dynamic qos
application directed
mobile user
network qos
different wireless
inter network
connected operation
different networks
data transport
connection manager
connected mode
backbone support
caching consistency
qos negotiation
whole file
commercial networks
computer may
application servers
kept consistent
dynamic operating
outdoor wireless
re negotiation
network mobility
adaptation support
providing seamless
file systems
across different
base stations
cached data
network level
available network
distributed file
tcp ip
application level
ip address
exception handling
computing environments
collaboratively adapt
provide seamless
consistent read
variable qos
non interoperable
invalidation mode
cellular modems
reintegration mode
prayer mobile
support disconnected
provides seamless
semantic record
autonomously owned
record caching
acceptable qos
network migration
qos re
user mobility
operating conditions
wireless networking
commercially available
semantic structure
three broad
upon reconnection
network connections
base station
application structure
uniform framework
networking technologies
computing model
virtual point
local copy
update conflicts
backbone network
may induce
prayer supports
low qos
level adaptation
qos change
point connection
measured qos
predictive caching
logical ip
user switches
g switches
interoperable wireless
level solution
medium transparent
qos network
qos bounds
multiple connections
ffl seamless
several viable
desired qos
service goals
explicit consistent
area wireless
contemporary research
pricing structure
mobile computing environment
caching and consistency
multiple wireless networks
mobility and adaptive
seamless mobility across
different wireless networks
partially connected operation
mobility across different
across different wireless
network for data
portable computer may
environment which provides
dynamic operating conditions
providing seamless mobility
mobile computing environments
provide seamless mobility
qos re negotiation
negotiation and reaction
support disconnected operation
change in qos
owned and operated
provides seamless mobility
semantic record caching
inter network mobility
prayer mobile computing
mobile computing model
wireless networking technologies
quality of service
mobility on top
e g switches
outdoor wireless networks
indoor and outdoor
commercially available wireless
non interoperable wireless
class is granted
indoor to outdoor
network level solution
procedure to execute
networks is typically
network is unable
application directed caching
dynamic qos re
inter network migration
support for applications
systems which support
logical ip address
available network qos
computing and seamless
choice of wireless
desired qos class
networks and provides
heterogeneous wireless networks
mobility over multiple
sequence of acceptable
mobile user switches
application level adaptation
wide area wireless
file system clients
mobile service stations
distributed file systems
order to provide
point to point

corpus/krapavin2000-test/635239.txt
greedy
admissible
matroids
gale
matroid
coxeter
symplectic
orderings
weight
orbit
acting
rank
polytope
compatible
root
attains
roots
edmonds
rado
unstarred
solves
cyclic
starred
supporting
ba
injective
nite
bipartite
hyperplane
gelfand
spanning
ordering
polytopes
denition
orthogonal
orders
poset
endpoints
correctly
steiglitz
hyperoctahedral
greedoids
borovik
optimization
combinatorial
chooses
edge
collection
group
subsets
representatives
lawler
continuation
action
answered
joining
transitively
papadimitriou
permutations
ordinary
bijection
conversely
intention
texts
proposition
acts
dene
nd
induced
dened
bouchet
sitive
korte
xag
involutions
maximumwith
lovasz
cryptomorphic
sympletic
serganova
precede
permutation
symmetric
geometric
lie
dening
edges
evasive
negating
objective
classical
consisting
rmative
furnishes
vertex
characterized
nonempty
denitions
icting
avenues
concerning
algebra
cosets
strata
vertices
remark
cardinality
white
transpositions
automorphism
acyclic
transitive
characterization
parabolic
hr
combinatorics
antisymmetric
vector
concerns
cient
interchanged
subsume
inverse
arrangements
fag
exive
contained
weights
geometries
symmetrically
element
situations
lg
lexicographically
manifolds
reversing
corollary
tran
signicance
convex
fails
question
generality
partial
intentionally
torus
light
irreducible
eectively
put
bases
subgroup
attain
perturbed
hall
sought
naturally
notions
compatibility
hull
orthonormal
comprising
readability
violating
brackets
philip
theorems
meant
preferable
achieves
partially
perturbation
comprise
tree
nds
objectives
closed
motivates
rst
converse
realization
maximizes
satised
ordered
elementary
greedy set
greedy algorithm
weight function
k greedy
greedy sets
rank k
admissible vector
gale order
admissible weight
correctly solves
symplectic matroids
optimization problem
linear orderings
algorithm correctly
function f
k element
admissible functions
group case
coxeter matroids
cyclic group
admissible function
o k
total weight
f v
element subsets
linear orders
linear order
f b
example 3
single orbit
every linear
polytope l
algorithm chooses
unique maximum
weight functions
optimization problems
nite set
tree problem
linear ordering
p contains
p consisting
linear extension
spanning tree
partial orderings
conversely assume
set l
p g
linear objective
group acting
edge e
combinatorial optimization
vector v
algebra root
every weight
simple framework
gale maximum
supporting hyperplane
orbit o
matroid case
collection l
set system
f compatible
theorem 5
case let
root systems
matroid theory
g acting
lie algebra
x attains
b f
subset l
every admissible
group z
rank 2
every edge
l o
theorem 4
ordered set
z 5
vector 1
condition 3
independent sets
rank k greedy
weight function f
k greedy set
algorithm correctly solves
pair s p
l s k
greedy algorithm correctly
admissible weight function
solves the optimization
contains only linear
f is admissible
k element subsets
acting on n
admissible vector v
spanning tree problem
problem for every
greedy algorithm chooses
f is compatible
f b f
l o k
set in l
edge of l
maximum on l
l is parallel
attains a maximum
ordering in p
assume that l
linear function f
function f v
theorem 5 7
element of l
example 3 4
order in p
k greedy sets
every admissible weight
denition of root
k is supporting
v x attains
lemma 5 6
continuation of example
set s together
cyclic group z
example 2 5
rado and edmonds
every weight function
admissible the greedy
greedy set l
n the roots
lie algebra root
rank 2 greedy
orbit o k
matroids the greedy
e of l
set and admissible
f v x
p of partial
theorem 5 5
example 3 3

corpus/krapavin2000-test/628028.txt
categorization
document
category
retrieval
hersh
corpus
documents
text
categories
avgp
ohsumed
query
scores
mesh
score
medline
training
vocabulary
automatic
learning
perspective
metric
manually
baseline
manual
advanced
na
docs
micro
exemplars
upsilon
vocabularies
collection
selection
psi
yang
extraction
frequency
categorized
conducted
statistically
exemplar
rtt
feedback
precision
perspectives
lewis
te
disease
stems
collections
phrases
ranked
weight
classifiers
wilcoxon
cat
diff
representations
wrt
tuning
queries
trec
strategies
experiment
heart
smart
medical
word
pool
learned
runs
combinations
rarity
masand
atn
gammatext
metrics
retrieved
tested
rank
tf
vectors
assigned
headings
hoff
hsin
widrow
strategy
stories
relevance
signed
quality
worse
row
expert
baselines
stemmed
controlled
classifier
decision
descending
conduct
asterisk
weighting
summary
classifying
focal
options
operates
judged
stemming
automatically
decisions
differences
experts
phrase
tables
vector
assessed
ki
significantly
adopt
title
articles
inverse
investigate
chung
yielded
normalized
rocchio
catego
lame
guiraude
selamat
goren
newswire
omatu
tayfun
tically
okapi
comprehended
evren
tsvi
llsf
karaca
kucukyilmaz
kuflik
sigeru
padmini
saphire
innovating
matched
statistical
classification
similarity
assignments
indexing
theta
web
free
organizing
extracted
barla
thematic
rization
automatic categorization
parameter selection
hersh corpus
free text
query design
perspective metric
retrieval performance
text retrieval
category vector
selection process
categorization approach
advanced query
category perspective
text vector
training collection
text categorization
category learning
mesh category
category extraction
learning model
test collection
retrieval feedback
document perspective
parameter combinations
mean f
ohsumed corpus
categorization process
f 1
manually assigned
extraction process
selection mean
mesh categories
vocabulary differences
simple query
document collection
decision perspective
quality metric
docs table
manual categorization
baseline 1
parameter values
instance based
micro f
tuning set
word stems
training document
runs based
baseline 2
category vectors
categorization evaluation
query analysis
document frequency
assigned categories
categorization performance
technique known
based learning
categories associated
automatic strategy
categories assigned
run docs
mean micro
quality metrics
heart disease
retrieval experiment
na na
categorization strategies
categories f
retrieval strategies
automatic text
inverse document
term frequency
performance using
selection based
retrieval experiments
document representations
automatic method
performance achieved
significantly better
new document
evaluation based
avgp score
set psi
test query
medline test
document instances
category pool
tr collection
rtt collection
combinations tested
corpus 4
categories may
appropriate categories
assigned mesh
test collections
precision scores
rank test
avgp 11
run parameter
m categories
query representations
medline database
point average
text portion
differences controlled
trec 3
advanced queries
documents assigned
wilcoxon signed
process table
best strategies
using manual
different automatic
signed rank
learned categories
based categorization
mesh phrases
perspective results
perspective hersh
parameter selection process
free text vector
advanced query design
category learning model
f 1 scores
f 1 score
category extraction process
mean f 1
category perspective metric
query by query
parameter selection mean
simple query design
number of documents
instance based learning
mesh category vector
vector is derived
document perspective metric
automatic categorization approach
automatic text categorization
investigate the application
micro f 1
mean micro f
parameter selection based
selection mean f
automatic categorization strategies
categories f 1
run docs table
manually assigned categories
set of exemplars
decision perspective metric
summary of runs
mesh category vectors
inverse document frequency
method is significantly
described in part
metric as described
automatically the number
known as instance
vocabulary differences controlled
retrieval performance compared
selection based categorization
different parameter combinations
signed rank test
perspective hersh corpus
documents in psi
known as retrieval
performance achieved using
evaluate the categorization
metric this evaluation
free text portion
run parameter selection
training document collection
documents from 1987
automatic categorization based
manually assigned mesh
derived by automatic
categorization evaluation based
using manual categorization
previous work 16
retrieval performance achieved
using a quality
point average precision
categorization to text
measure the categorization
different automatic categorization
wilcoxon signed rank
retrieval technique known
selection mean micro
individual test query
based categorization evaluation
parameter combinations tested
set of categories
values for n
n and m

corpus/krapavin2000-test/1029351.txt
eal
lamping
elementary
mairson
typed
asperti
bookkeeping
fan
duplication
statman
fans
dk
levy
boxes
memberk
lambda
beta
logic
encoding
lc
ell
reduction
sharing
quantiers
reductions
contraction
redexes
decoration
powerset
calculus
io
croissants
box
redex
ill
la
intuitionistic
ne
translation
derivation
xed
oracle
nesting
le
normalization
abstract
annihilate
universes
lal
decorating
decorations
rst
typing
formulas
rening
reducer
shared
normalize
turing
light
jxj
dene
unfeasible
contractions
bracket
typeable
prime
inference
depth
bold
skeleton
cut
quanties
kmax
mula
connectives
formula
encoded
girard
rewriting
families
brackets
optimality
paradox
affine
quantied
nets
quantier
dynamics
subterm
elimination
abstraction
rules
wire
coded
en
untyped
proofs
inside
weakening
double
fragment
coding
wrong
labelling
machinery
bool
greatest
dened
oj
vindicates
reducers
intuitionist
croissant
contr
piling
perfomed
culprit
devolved
gonthier
cofin
curry
contractible
mality
implicational
breakthrough
boxing
syntax
dierent
false
grammar
discipline
rithm
sketched
nally
creasing
rewritings
kalmar
kathail
eta
discriminated
duplications
eraser
ference
propositional
rule
grows
principal
variants
crucial
technical
functional
hinted
lawall
inductively
normal
understand
labelled
reach
admitted
culminated
erb
lacked
pretty
contracted
nique
lvy
jacques
prescribes
algo
labels
l l
abstract algorithm
eal type
sharing graph
d d
optimal reduction
linear logic
simply typed
shared reductions
typed term
term encoding
term m
l c
fan fan
beta reduction
ne logic
typed terms
c l
eal typed
optimal sharing
restricted system
graph reduction
fan rules
c lc
le c
two fan
lc c
l la
type inference
elementary function
n le
elementary time
normal form
non elementary
elementary recursive
two fans
false c
prime formulas
inside eal
optimal lambda
bookkeeping part
c false
greatest k
parallel beta
nesting depth
memberk appears
affine logic
lc true
higher order
z z
elementary functions
arbitrary formula
true c
sharing graphs
x x
proof nets
lambda term
lambda calculus
c x
graph rewriting
syntax tree
z y
turing machine
order logic
e l
untyped terms
normalize en
ill proof
shared beta
bookkeeping work
elimination procedure
box nesting
global dynamics
using lamping
corresponding ill
redex families
free terms
bookkeeping technique
optimal reducer
light affine
optimal duplication
type free
optimal implementation
reduction optimality
box stands
normalization procedure
preliminary redexes
rules annihilate
beta steps
dierent encoding
quantier elimination
new preliminary
en using
eal proofs
d d d
l l c
l l l
c l l
asperti and mairson
b a b
lamping s algorithm
elementary a ne
number of shared
encoding an arbitrary
c e l
lc c x
fan fan rules
l c n
simply typed term
c lc c
reach the normal
c n le
n le c
type in eal
two fan fan
x c e
lamping s abstract
optimal sharing graph
le c l
eal typed terms
l l la
inference in eal
z y y
z z y
e l l
c x c
higher order logic
l c l
n the type
parallel beta reduction
lamping s graph
theorem of statman
figure 8 d
true c false
la a lc
lc true c
c false c
y y x
y x x
l c c
x x x
functional programming languages
xed integer 0
derivation of m
elementary linear logic
box nesting depth
notation for proofs
need to open
brackets and croissants
required to normalize
representing a variable
fan rules annihilate
higher order formula
shared beta steps
size of m
arbitrary for mula
type free terms
typeable in eal
oracle of lamping
bold box stands
implementation of functional
dynamics of optimal
quantier elimination procedure
dynamics of sharing
maintain the families
normalize en using
number of quantiers
light affine logic
new preliminary redexes
type of powerset
type i io
n shared reductions
complexity of beta
lambda calculus reduction
levy s theory
optimal lambda calculus
optimal graph reduction

corpus/krapavin2000-test/631036.txt
subdomain
subdomains
covers
narrows
criteria
properly
universally
sel
testing
partitions
criterion
specification
sdc
detecting
suite
subsumes
dua
fault
weyuker
faults
edges
maldonado
associations
program
adequacy
inputs
software
flow
expose
nfa
suites
adequate
subsumption
executable
cover
analogs
sigsoft
subsume
mutation
ability
sd
causing
gammauses
hamlet
applicable
frankl
strategies
partition
engineering
jos
reflexive
covering
selection
strengthens
tester
coverage
measures
repetitive
mathur
relations
transitive
singh
aditya
max
jino
nsup
vergilio
delamaro
robby
nfup
manufacture
stuart
notes
failure
branch
gamman
tosem
stubblebine
gammap
devanbu
silvia
carlos
regina
zhu
assessing
analytical
du
guarantee
unexecutable
phyllis
jeng
kn
disjoint
wong
edge
pairwise
eric
elaine
inspire
assoc
fd
dick
weiss
arising
duplicates
dependability
undefined
belonging
loop
statement
multi
concentration
selecting
bearing
corollary
relationships
sub
exiting
duplicate
conditional
programs
assessed
mario
hong
association
goto
cryptographic
induces
na
simulations
superset
intersection
anomalies
overlapping
undecidable
thetaspecifications
thetaprograms
inali
marcio
schatz
unexercised
wisniewski
bai
lingzi
ganghong
trustability
mrcio
diaper
hatcliff
pasquini
sugeta
pravin
voas
howden
probbetter
yudong
probabilistic
feasible
theorems
relation
analog
paths
york
distinction
pascal
def
satisfies
podgurski
yuen
zweben
mccleese
premkumar
pasareanu
hierons
harshinder
gourlay
ftjt
cukic
yueh
capizzano
redefines
c 1
c 2
properly covers
partitions c
program p
covers c
properly partitions
p uses
criteria c
fault detecting
detecting ability
subdomain based
p specification
software engineering
multi set
input domain
test suite
p use
universally applicable
test cases
criterion c
data flow
test case
sel 2
uses criterion
causing inputs
failure causing
covers relation
testing criteria
one test
c sub
flow testing
narrows relation
partition testing
subdomain consists
use associations
detecting faults
test data
based criteria
edges criterion
narrows c
m 2
variable v
every program
testing strategies
sdc p
properly cover
universally narrows
subdomain d
sel 1
engineering v
c adequate
partitions relation
y max
test suites
subsumes c
applicable analogs
using sel
requires selection
c use
random testing
branch testing
testing ieee
better according
partitions relations
start node
sub 1
acm sigsoft
program testing
testing techniques
based testing
universally covers
repetitive statement
definition p
specification pair
uses criteria
definition c
subdomains arising
subsumes relation
sub 2
least one
d 3
m 1
software testing
flow graph
clear path
definition clear
adequate test
multi sets
adequacy criteria
probabilistic measures
test set
sigsoft software
notes v
engineering notes
g frankl
testing criterion
j weyuker
data selection
selection strategies
program shown
d max
ieee transactions
partitions c 2
covers c 2
c 1 properly
p and specification
criteria c 1
fault detecting ability
properly partitions c
properly covers c
program p specification
guarantee that c
exists a program
one test case
c 1 covers
transactions on software
c 2 according
failure causing inputs
software engineering v
data flow testing
least one test
c 1 partitions
narrows c 2
c 1 narrows
subdomain based criteria
faults than c
fact that c
according to m
better at detecting
relation is reflexive
p s c
c 1 universally
c 1 subsumes
c sub 1
p uses criterion
criterion c 1
universally applicable analogs
testing ieee transactions
flow testing criteria
reflexive and transitive
better than c
definition c use
definition p use
p s observation
relations between criteria
specification pair p
transitive if c
c sub 2
subdomain based testing
belonging to sdc1
conditional or repetitive
program specification pair
universally narrows c
covers and properly
every program specification
measures of fault
definition clear path
software engineering notes
engineering notes v
acm sigsoft software
sigsoft software engineering
test data selection
path with respect
proof let p
n test cases
illustrates the distinction
assume c 1

corpus/krapavin2000-test/627754.txt
join
bushy
gmc
query
gmr
joins
processors
sgd
allocation
se
sopt
processor
parallelism
heuristics
cardinalities
gopt
multiprocessor
te
heuristic
fragmentation
operational
st
mt
rrr
dependency
synchronous
sequences
scheduling
pipelining
execution
rr
allocated
profile
efficiency
relations
intra
queries
database
curve
termed
sequential
proc
deallocation
inter
hash
operands
cumulative
execute
operator
tree
fs
child
skew
schemes
simulation
xprs
cardinality
merge
bottom
jv
attributes
exploiting
outperformed
costs
jr
relational
joining
internal
allotted
interoperator
resulted
efficiencies
syan
sort
trees
ongoing
attribute
composite
eased
bubba
exploit
prob
light
minimize
exploitable
grace
scheduler
shall
minimal
alleviate
despite
outperform
excessive
employed
evaluated
exe
disks
pipelined
selection
concept
opportunity
opt
trend
dominating
prevalent
dealt
emerges
categorized
suffer
nowadays
ming
tuples
mc
effectiveness
completion
greedy
workload
pn
incurred
absent
resort
poor
node
multi
parallelizing
efficiently
objective
reasonably
top
deemed
allocates
constraintssuch
decomposer
rrrrr
reallocating
rrrrrrrrrrrrrr
nonequal
rrrr
intraoperator
multiquery
inners
mediocre
gammah
jjej
fragmentationthan
uopn
ullmann
idleness
rrrrrrrrrrrrrrr
rrrrrrrrrrr
allocating
mentioning
mobile
factors
avoided
evaluate
explore
rdbms
softwares
alleviating
nonstop
lengthen
informix
shrunken
tially
join sequence
processor allocation
bushy tree
join sequences
operator parallelism
execution time
general join
execution dependency
sequential join
multi join
synchronous execution
operational point
st se
inter operator
system fragmentation
sequence scheduling
join query
sequence efficiency
operational curve
r 5
minimal cost
intra operator
efficiency point
query graph
execution costs
r 4
sequence heuristics
resulting relation
cumulative execution
query execution
multiprocessor system
processors allocated
join queries
point selection
bushy trees
next join
cost join
join operation
internal node
r r
merge join
r 6
child nodes
optimal sequential
sort merge
r j
average execution
different join
time point
sequence heuristic
best efficiency
heuristic se
heuristics proposed
resulting join
execution cost
parallel execution
figure 7a
r 2
join r
data skew
sequences obtained
minimum time
r y
simulation results
allocation heuristics
fs mt
se fs
exploiting inter
schemes evaluated
built bottom
resulting r
sequence proc
two child
figure 7b
figure 2a
h p
r 3
processor system
allocation efficiency
join methods
hash joins
r 8
join method
time end
execution tree
single processor
scheduling schemes
execution sequence
o jv
starting time
p b
time resulting
query complexity
join operations
several heuristics
number of processors
synchronous execution time
inter operator parallelism
concept of synchronous
join sequence scheduling
general join sequences
multi join query
join sequence efficiency
query execution time
number of relations
sequential join sequence
general join sequence
intra operator parallelism
query in figure
operational point selection
r 5 r
r 4 r
dependency and system
join sequence heuristics
scheduling and processor
sequential join sequences
r 6 r
minimal cost join
minimum time point
r 2 r
sort merge join
r i r
optimal sequential join
multi join queries
tree in figure
r r r
single processor system
join sequences obtained
r 3 r
join sequence heuristic
gmc and gmr
minimize the query
cardinalities of relations
execution of multi
best efficiency point
sequence of joins
two child nodes
despite their simplicity
processor allocation efficiency
processor allocation heuristics
sgd and sopt
proc no starting
within a query
cumulative execution cost
time end time
minimize the execution
se fs mt
cumulative execution costs
h p j
execute the join
join sequence proc
time efficiency point
processors to execute
starting time end
cardinalities of attributes
time resulting r
end time resulting
exploiting inter operator
determine the next
propose and evaluate
top down approaches
bottom up approach
evaluated by simulation
used to execute
section 3 3
determine the number
r 1 r
top down approach
se and st
form of parallelism
processor allocation heuristic
execute each join

corpus/krapavin2000-test/608176.txt
tfi
automata
tla
hytech
acr
rm
abr
newrm
automaton
efi
ost
ela
aux
conformance
cell
coq
reception
snapshot
timed
cells
klay
emx
locations
monin
asap
transition
calife
atm
parametric
urgent
init
pi
modelling
invariants
verification
transitions
guard
action
rate
reachability
location
itu
upde
updal
dgcra
checking
stable
idle
auxiliary
inductive
ait
resp
ab
ideal
prover
reaching
invariance
zone
env
correctness
reachable
updag
connexions
rabadan
fertilizing
atcs
updatable
synchronized
assistant
proving
clock
moves
evolve
inv
proofs
algorithmic
protocol
arrival
hybrid
henceforth
subcases
incremental
checker
updated
discrete
gcra
aenv
alur
rnrt
endb
negociated
telecom
delay
update
guards
forbidden
mechanical
invariant
admissible
events
henzinger
kronos
standardized
conjunct
move
assertional
atc
loca
updates
audio
human
subcase
floyd
vardi
transitivity
universal
flaws
dates
tactics
encoding
automated
specification
emitted
datalog
reacts
enriched
arithmetic
appendix
actions
modeled
constraint
rn
schedulers
unified
dataflow
scripts
hoare
viz
mechanically
checked
tool
months
discrepancy
convex
conjunction
reasoning
merits
life
france
tools
arrives
symbolic
reformulated
simultaneous
reaches
arrivals
proved
receiving
explain
qos
fruitful
generic
executions
gained
isdn
antoine
reformulating
updat
subsidiarily
recasted
latters
uppaalmyampersandmdash
negociation
sttc
recapitulation
conformit
rouillard
davy
additionnaly
examplified
olufsen
confrontation
accurateness
paves
sertions
automa
bouyer
ambivalent
mentionned
endi
dufourd
p automata
rm cell
tfi tla
p ost
p automaton
rm cells
b 0
abr conformance
timed automata
model checking
property u
rate acr
ab 0
stable locations
p constraint
current time
reaching tfi
ideal rate
ost q
proof methods
algorithm b
auxiliary properties
efi ela
q init
update relation
operation 9
conformance control
action move
discrete variables
variable r
project calife
synchronized product
action moves
cell rate
universal clock
new rm
discrete variable
real time
reachability analysis
value e
automated proof
parametric timed
two proof
transition newrm
inductive invariance
inductive invariants
w ait
p zone
expected rate
delay moves
reaches tfi
hybrid systems
reachable states
algorithm f
value r
theorem proving
theorem prover
complete sequence
ideal algorithm
initial location
upon reception
data cell
time systems
form evaluation
location less
correctness property
last rm
cell rates
product automaton
admissible state
rate value
delay move
received rm
proof assistant
cross fertilizing
standardized algorithm
newrm followed
france telecom
parametric real
automaton ab
performing 9
convex constraint
cell reception
transition snapshot
snapshot action
hybrid automata
ela emx
conformance algorithm
monin klay
symbolic states
aux 0
hytech 14
emx r
modelling framework
model checker
unified framework
initial p
target location
becomes equal
rate e
p re
r k
algorithm called
data cells
order functional
bit rate
time increases
automata model
algorithm b 0
p ost q
tfi and tla
ideal rate acr
ost q init
framework of p
new rm cell
two proof methods
parametric timed automata
analysis of hybrid
real time systems
sequence of transitions
computation of acr
p automata model
efi and ela
initial p constraint
closed form evaluation
algorithm for abr
model of monin
rm cell reception
efi ela emx
time s becomes
time s reaches
two stable locations
receiving an rm
monin and klay
parametric real time
last rm cell
framework of project
automaton ab 0
verification of real
h a 0
higher order functional
correctness of algorithm
section 7 1
order to implement
model of p
computation of p
p automata 8
constraint s tfi
conformance control algorithm
list is complete
newrm r snapshot
reasoning for concurrent
automata in coq
auxiliary variables efi
algorithm called due
called p automata
received rm cell
implement the higher
algorithm of abr
automated proof checking
automata for modeling
like i algorithm
pairs t e
conformance of cells
incremental abr conformance

corpus/krapavin2000-test/1014532.txt
ioa
automaton
ballot
daikon
invariants
paxos
chooseval
cons
interpreter
consensus
assignval
internaldecide
specication
lp
automata
verication
actions
abstain
init
makeballot
ndr
ballots
prover
toolkit
thenodes
simulation
internal
executions
paired
larch
action
detector
val
vote
nondeterminism
eort
voted
suite
purported
od
methodology
quorums
invariant
lemmas
verifying
human
lockstep
witness
scripts
block
forward
failed
unsound
proofs
veried
provers
correctness
behaviors
simulated
dilsun
abstained
lsl
aballot
mocha
tlc
kcd
fail
nite
imple
mentation
corrected
specications
succeeded
signature
decide
guidance
veri
proving
ignore
execution
smv
prelude
supply
assist
traces
tomata
correspondence
formulating
dead
discover
toolset
denition
dynamically
se
auxiliary
unexpected
tools
trace
checking
departures
reveal
external
pre
checked
transition
specializing
resume
bookkeeping
initiated
fragment
checks
speci
reported
validity
provable
nil
nd
legal
eects
automating
au
formal
peppered
explicating
lengthier
rintanen
falsied
prompting
solidify
ghg
abstaining
ahm
multisorted
reies
veriers
cutions
buttress
ecutions
imaginative
parliament
inductiveness
reporting
attempting
node
organizing
deductive
assistance
existential
transitions
style
program
soundness
denes
detected
freeing
asml
transcription
eters
investing
approval
hindrance
automates
rst
examining
imperative
reachable
candidate
innite
cope
detection
implements
programmers
succeed
simulates
theories
obscuring
axiomatize
fate
postulate
simulation relation
b ballot
v value
proof block
ioa interpreter
o automaton
forward simulation
level automaton
simulated execution
output decide
input fail
ioa toolkit
step correspondence
dynamic invariant
invariant detector
internal chooseval
automaton global1
automaton cons
specication automaton
start state
ioa language
reported properties
internal actions
test suite
paxos algorithm
consensus value
set ballot
paired execution
assignval b
ballot ignore
machine checked
internaldecide b
input init
b pre
chooseval v
v pre
two automata
theorem prover
case study
invariant detection
node v
node b
internal internaldecide
re internal
internal start
implementation automaton
l se
checked proof
makeballot b
ballot v
ndr program
internal assignval
denition 1
program properties
simulation relations
verifying distributed
execution fragment
v representing
value v
o automata
daikon invariant
external actions
formal verication
automaton model
distributed algorithms
imple mentation
b set
theorem provers
state systems
model checking
potential problems
theorem proving
nite state
execution based
signature input
invariants inv1
predicate relating
b val
failed failed
human guidance
candidate simulation
chooseval global1
value internal
ndr programs
decide action
via simulated
start thenodes
daikon reported
human eort
machine veried
satises property
imperative style
node init
value output
detected invariants
simulates execution
lp proof
daikon provide
purported simulation
block contains
larch prover
re chooseval
interpreter simulates
re output
re input
automaton paxos
execution provides
v od
internal makeballot
internal vote
using lp
makeballot abstain
fully characterizes
veried proof
auxiliary invariants
val b
internal abstain
node v value
f i re
forward simulation relation
ignore for internal
decide i v
init i v
dynamic invariant detection
internal chooseval v
decide i node
ballot v value
internal assignval b
machine checked proof
internaldecide b ballot
b set ballot
init i node
e l se
internal internaldecide b
node b set
fail i node
b ballot v
re internal chooseval
o automaton model
assignval b ballot
verifying distributed algorithms
daikon invariant detector
proof of correctness
chooseval global1 val
invariants and simulation
b ballot ignore
prelude to formal
high level automaton
consensus in ioa
automata in ioa
abstain i node
vote i node
low level automaton
pre output decide
daikon s output
implementation of consensus
machine veried proof
v value internal
invariants and lemmas
b pre internal
signature input fail
fail i failed
makeballot b ballot
re output decide
purported simulation relation
dynamically detected invariants
ballot in global1
interpreter simulates execution
value output decide
paired execution provides
formulating and checking
cons figure 1
v value output
val b val
internal makeballot b
internal chooseval global1
assignval and internaldecide
set ballot ignore
reported properties may
suite fully characterizes
preserve the simulation
via simulated execution
se else f
l se else
resume by specializing
relation satises property
internal start thenodes
value do f
test suite fully
step in verifying
execution based techniques
abstain and vote
candidate simulation relation
node b ballot
simulation relation satises
f a b

corpus/krapavin2000-test/629351.txt
simd
queen
grainsize
atomic
gromos
mimd
processor
kernel
synchronous
processors
thread
instruction
auction
fullness
asynchronous
messages
loosely
mp
dest
subqueen
message
efficiencies
runtime
responsequeen
parallelqueen
irregular
utilization
machines
chare
threads
molecular
rescheduling
instructions
load
destination
collision
placement
parallelism
grainsizes
sequentialqueen
suspension
emanated
graphinators
superoxide
board
mpl
priority
maspar
tailing
computations
granularity
speedup
ghc
balancing
transfer
execute
act
buffered
efficiency
overhead
iteration
active
scheduling
architectures
massively
processes
seqqueen
solutioncount
graphinator
queeninit
lgdf
auc
dismutase
oscreateproc
residual
emergency
synchronization
linda
cyclic
variation
corp
sod
mandelbrot
cyc
queens
scheduled
supercomputers
cm
array
barrier
indirect
prevention
millisecond
entry
balance
send
addressing
dynamics
prolog
sec
speedups
transferred
program
phase
declarations
unprocessed
imbalanced
cycle
balanced
portable
growing
sys
diagonals
unsolved
deliver
transfers
reactive
oriented
src
computers
maximize
nonuniform
ix
executes
flat
execution
wait
deferred
viii
int
selection
machine
pn
repeatedly
methodologies
thinking
simulation
architecture
keyword
milliseconds
mismatch
loop
simlad
dietz
rescue
bookkeep
npac
stalled
hut
mized
gummaraju
nael
xianzhi
rips
dally
jayanth
mattan
bernut
qcd
ahn
responsecount
abu
procname
hanxleden
syracuse
wilsey
groningen
ghazaleh
babb
bovine
jerry
unsent
hensgen
iterations
priorities
communication
ffl
body
newly
fortran
vii
atomic computation
p kernel
atomic computations
n queen
asynchronous problems
data messages
loosely synchronous
simd machines
simd machine
mp 1
queen problem
auction algorithm
thread based
computation selection
grainsize variation
dest p
data area
common data
system overhead
synchronous problems
runtime support
support system
destination processor
memory space
processor p
application problems
user program
process messages
sec speedup
message transfer
instruction level
level approach
process message
queen 13
program phase
queen 14
full state
gromos program
kernel system
system efficiency
computation types
oriented approach
molecular dynamics
cyclic algorithm
indirect addressing
gromos 12
chare kernel
queen 8
handle asynchronous
queen gromos
speedup time
system phase
machines handle
fullness efficiency
time sec
theta k
execution time
thread level
kernel language
simd architectures
load balancing
every processor
application oriented
simd computers
random placement
data message
region growing
array based
connection machine
instruction multiple
emergency state
residual data
system oriented
execute different
synchronous loosely
flat ghc
mimd like
message msg2
maspar mp
processor suspension
process placement
process definitions
tailing effect
mimd machines
reactive kernel
processor mp
efficiencies sys
generated process
simd hardware
priority auction
based programming
processor utilization
efficiency depends
nearly full
utilization efficiency
main process
active processors
sys n
computation type
programming methodology
available parallelism
different processors
processor q
central control
system program
j p
data parallel
newly generated
int k
control unit
d k
one instruction
massively parallel
adaptive algorithm
processor executes
computation model
f int
computation phase
different problem
common data area
problems on simd
instruction level approach
runtime support system
n queen problem
time sec speedup
loosely synchronous problems
queen 13 queen
queen 14 queen
p kernel system
atomic computation types
sec speedup time
p kernel language
simd machines handle
speedup time sec
n queen gromos
user program phase
queen gromos 12
gromos 12 queen
number of processors
maspar mp 1
f int k
newly generated process
thread based programming
processor mp 1
active t active
nearly full state
synchronous loosely synchronous
sys n queen
system oriented approach
based programming methodology
application oriented approach
atomic computation type
space at processor
efficiencies sys n
machines handle asynchronous
residual data messages
thread based model
central control unit
handle asynchronous problems
kinds of messages
times and speedups
transfer of data
efficiency is defined
synchronous and asynchronous
utilization efficiency depends
loosely synchronous asynchronous
process atomic computation
entire instruction set
transparent to users
one atomic computation
kernel is able
ffl the gap
destination processor id
processors at iteration
handle general asynchronous
thinking machines corp
n body simulation
thread based approach
dest p 1
parallelqueen and responsequeen
chare kernel 30
computation selection algorithms
efficiencies for different
maximize the processor
software on simd
processors can execute
one common data

corpus/krapavin2000-test/633574.txt
sup
fgng
regression
ns
lim
convergence
minimax
kd
nonparametric
antos
lip
birge
fg
classication
yang
brick
2d
rate
rates
tending
fp
devroye
gyor
el
bayes
denition
fb
stone
estimation
distributions
plug
gn
lugosi
bricks
polinomial
lq
efy
er
pf
tsybakov
inmum
recognition
classes
pfc
kohler
exponent
entropy
individual
rst
decision
km
fa
bounds
classi
disjoint
xed
xg
pack
fn
universally
jg
ibragimov
xunif
fatou
massart
extention
fgn
mammen
kx
khasmiskii
efj
pedent
bxc
eln
fng
korostelev
imply
dierent
fy
fc
unif
kfk
funtions
efg
estimates
generalizations
mat
identically
log
assertion
recog
reconstruction
probability
derivatives
wants
chervonenkis
borders
qa
barron
theorems
uniformly
asymptotic
remark
metric
lebesgue
vapnik
error
learning
counterexamples
kp
inequality
rules
sample
strange
conditioning
nish
inde
decreases
discrimination
modulus
lipschitz
corollary
diers
subclass
vanishing
cn
measurable
nition
segment
specially
kg
assure
tend
slow
jensen
fastest
mr
cubic
posteriori
strongest
converging
references
pattern
contraction
inferior
dened
estimators
smoothness
concerning
therein
density
jx
subsequence
ts
continuity
anything
indicator
fi
strong
wishes
border
arbitrarily
cation
achievable
intersections
exclude
easier
doesn
modied
dropping
innite
tell
fr
rich
distribution
rational
slowly
statistical
spirit
derives
proofs
denitions
exponential
nontrivial
j k
lim sup
individual lower
y 2d
regression function
n g
c j
ns c
sup x
lower rate
function estimation
kd c
fgng sup
fg n
class d
lip d
upper rate
k d
lower rates
yang 16
el n
fp j
b n
k r
sup sup
x y
lower bounds
sup b
er ns
minimax lower
positive sequence
sup lim
bayes decision
c c
assumption 1
r d
j g
r ns
2d lim
birge 7
c er
individual upper
classes lip
nonparametric pattern
rules fg
sup r
d kd
class f
classes d
fb n
c n
n l
d c
sequence tending
xed distribution
see antos
kd moreover
corresponding distribution
satisfying 6
gn sup
exist rules
metric entropy
distribution class
regression functions
let fb
n j
fa n
pattern recognition
r r
log 1
c x
taking values
function class
m j
classes see
rst term
every sequence
every c
d y
x 00
j log
denition 5
see also
q 1
see devroye
every distribution
2d el
d assumption
antos gyor
devroye et
b ns
estimates see
strong minimax
stone 15
kohler 4
sup gn
distribution classes
satisfy lim
d f0
function estimates
exist regression
gives kd
n lim
fgng lim
choose fp
exist individual
k lq
convergence results
g n
k 3
theorem 2
sequence fg
rule see
uniformly bounded
image reconstruction
sequence fa
distribution x
decision rule
rate results
minimax theory
near 1
v d
sample size
c j k
rate of convergence
sup x y
j k d
x y 2d
j k r
regression function estimation
fg n g
fp j g
individual lower rate
k d c
d c j
lim sup sup
el n l
probability of error
distributions of x
n j k
c n j
r a j
individual lower rates
fgng sup lim
sup sup x
sup b n
sup lim sup
lim sup b
er ns c
r ns c
y 2d lim
log 1 q
rules fg n
kd c c
c er ns
sup a n
lim sup r
2d lim sup
ns c er
sup r ns
classes lip d
minimax lower bounds
individual upper rate
n a n
distribution of x
tending to zero
r r r
f n g
class of distributions
rates of convergence
c c x
n 2 d
convergence of nonparametric
j k g
k d kd
moreover for every
corresponding distribution class
fa n g
c x k
plug in rule
d of distributions
convergence for d
k 3 fgng
fgng sup x
distribution class d
fb n g
nonparametric pattern recognition
g which satisfy
c 2 c
m j k
function class f
r i c
j k 2
class of functions
strong minimax lower
devroye et al
c k 3
ns a ns
sequence fg n
assertion 2 proof
sup gn sup
second term c
d and v
2d a n
d kd moreover
bounds for learning
d assumption 1
lim sup gn
function with support
easier than regression
distribution x y
positive sequence fa
near 1 2
2d el n
x is uniformly
sequence fa n
support of d
exist individual lower
g g d
r d f0
rate for d
y 2d el
sequence b n
arbitrary positive sequence
decision for c

corpus/krapavin2000-test/1016179.txt
cedf
wfq
session
packet
sessions
hop
delay
deadlines
rate
percentile
deadline
server
ae
lights
hops
packets
edf
traffic
gm
rpps
additive
token
earliest
queueing
service
multiplicative
delays
coordination
randomness
servers
link
burst
coordinated
scheduling
injection
tokens
protocol
inj
disciplines
ki
analytical
parekh
backlogged
liebeherr
gps
fig
green
fair
fifo
discipline
network
rand
conserving
leighton
sharing
qos
ferrari
bits
tenet
lmax
gallager
erin
andez
fern
switching
rates
congestion
serviced
networks
plots
georgiadis
prev
preemptive
oe
services
admission
ring
light
curves
obtains
vin
maggs
leaky
manhattan
shaping
goyal
verma
accumulate
links
weighted
car
processor
rabani
paths
double
cbr
jitter
mk
figures
integrated
simulation
bounds
coexist
passes
cut
gu
quickly
suffer
injected
interfering
subsequent
randomization
robin
bucket
emphasize
configuration
success
plot
sivarajan
wrege
harchol
richa
simistic
hluchyj
pgps
maxft
essentiallyae
ostrovsky
golestani
cipline
balter
priority
dead
utilization
scenarios
probabilistic
italic
interfere
neighboring
comparable
outperform
antonio
incremented
routing
waiting
entering
red
switched
reshaping
unconsumed
strained
reshaped
wrr
peris
grossglauser
ofae
buffer
achievable
generalized
suffers
suite
delayed
contention
theta
contend
tention
kurose
jorg
passed
successful
buffers
emulates
pes
shenker
keshav
tardos
mth
stamping
spread
networking
showed
traversing
behaves
avenue
cruz
ther
towsley
slopes
rate 0
delay bound
long session
end delay
mean delay
session length
length rate
hop sessions
delay due
delay bounds
long sessions
processor sharing
percentile delay
fair queueing
hop delay
additive bound
earliest deadline
percentile session
delay session
generalized processor
weighted fair
wfq 1030507090110130150
multiple long
server m
integrated services
session rate
hop paths
theta k
first server
deadline first
burst size
r m
session due
analytical bound
services networks
servers quickly
multiplicative bound
subsequent servers
delay guarantees
packet service
sharing approach
per session
packet switching
hop path
multiple hop
double link
link network
network rate
scheduling discipline
single hop
form 1
analytical bounds
coordinated earliest
delay guarantee
packet passes
simple coordination
uniform packet
small burst
gives priority
cedf 1030507090110130150
additive delay
non cut
session processing
simple cedf
work conserving
packet size
speed networks
actual delays
packet p
rate ae
size oe
service time
flow control
packet sizes
simulation results
bound 1
success probability
real time
rate 0 1
rate 0 15
rate 0 03
rate 0 2
end to end
session length rate
length rate 0
rate 0 7
rate 0 3
rate 0 6
rate 0 4
session i packet
due to wfq
mean delay due
delay session length
weighted fair queueing
generalized processor sharing
percentile delay due
multiple long sessions
percentile session length
earliest deadline first
end delay bound
long session due
mean delay session
control in integrated
subsequent servers quickly
packet service time
double link network
deadlines are defined
processor sharing approach
length of network
network rate 0
integrated services networks
approach to flow
protocol is successful
cedf 1030507090110130150 98th
end delay bounds
additive delay bound
single hop delay
burst size oe
wfq 1030507090110130150 98th
wfq 1030507090110130150 mean
coordinated earliest deadline
multiple hop delay
per session processing
high speed networks
number of servers
network mean delay
small burst sizes
guarantees of o
fair queueing wfq
wfq scheduling discipline
session is likely
scheduling in packet
form 1 ae
processor sharing rpps
hop delay bound
distributed packet switching
routing with per
link network mean
r mk log
time protocol suite
illustrate the end
server utilization factor
integrated services packet
must suffer delay
path of session
georgiadis gu erin
session rate ae
bound for cedf
packet delay guarantees
accumulate a delay

corpus/krapavin2000-test/628552.txt
deltaoe
amplitude
gabor
filters
contours
behaviour
phase
disparity
neighbourhoods
stability
filter
kernels
linearity
singularity
scale
modulated
noise
band
wave
spectra
signal
binocular
instantaneous
octaves
imaginary
octave
predictor
spatial
gaussian
deformations
disparities
velocity
perturbations
views
harmonics
neighbourhood
uncorrelated
frequency
quadrature
kernel
response
regions
white
deformation
wavelength
bandwidths
bandwidth
extent
image
scales
variation
fleet
deltak
vertical
oe
stable
signals
correlation
matching
frequencies
derivative
fourier
tuned
images
poorer
measurement
arg
optical
pass
vision
singularities
dilation
drift
variations
instability
bars
dilations
horizontal
detected
subsampled
sigma
windowed
residual
square
measurements
hilbert
deltax
jz
predicted
sensitivity
nonlinearities
instabilities
sinusoidally
transforms
survive
stereo
convergence
crossings
wavelets
differences
dc
shear
jepson
steerable
approximations
amounts
specular
sinusoidal
ae
superimposed
spatiotemporal
bernd
extents
constraint
tuning
scene
expansions
geometric
position
figures
valued
magnitude
centre
estimates
spectrum
filtered
contour
textured
motion
quantitative
shift
decreases
correlated
deviation
affine
expansion
gabors
scanlines
stereopsis
intensity
exhibited
responses
gradient
axes
windows
concerns
aliasing
passband
elliptical
innermost
dependence
translations
occlusion
encloses
elongated
translation
crossing
wavelet
delta
surface
derivatives
appendix
weng
evident
reliably
scalar
flow
reflects
justification
unstable
plane
dominated
shadows
tightest
predominantly
mean
modulation
centres
edges
exp
envelope
coincidence
pixel
nearly
extracted
expect
log
gamma
maxima
predictors
differentiation
phase behaviour
scale space
z 1
level contours
phase stability
band pass
square wave
phase based
b z
amplitude spectra
singularity neighbourhoods
spatial position
instantaneous frequency
phase difference
modulated square
gabor filters
phase contours
scale perturbations
stability constraint
filter output
phase information
imaginary parts
mean phase
e deltaoe
expected phase
image velocity
white noise
gabor kernels
filter response
phase differences
phase linearity
space expansion
binocular disparity
space position
ae x
natural images
gaussian noise
scale changes
gabor scale
quadrature pair
pass signal
phase singularities
complex valued
input signal
pass filters
based matching
optical flow
gabor filter
different views
r 1
p 0
small scale
two views
dc sensitivity
geometric deformations
arg r
phase correlation
space framework
deltaoe gamma
wave kernel
k x
oe x
local phase
low frequencies
white gaussian
spatial extent
uncorrelated noise
space phase
regions detected
gabor kernel
geometric deformation
one octave
phase matching
input scale
phase drift
phase structure
amplitude spectrum
filters tuned
amplitude derivative
correlation techniques
flow techniques
disparity measurement
approximate mean
jz 1
phase values
log scale
complex plane
fourier transforms
space time
image matching
cross correlation
different scales
scalar z
scale variation
quantitative approximations
pass filtered
b z 1
modulated square wave
stability of phase
real and imaginary
domain of convergence
scale space expansion
scale space position
phase based matching
band pass filters
function of scale
function of spatial
band pass signal
gabor scale space
amplitude and phase
detected by 28
expected phase behaviour
scale space framework
small scale perturbations
behaviour of phase
white gaussian noise
contours that survive
contours of b
phase correlation techniques
square wave kernel
neighbourhood of p
mean phase behaviour
ae x x
arg r 1
filters with respect
scale space phase
linearity through space
vertical and horizontal
phase with respect
optical flow techniques
left and right
stable with respect
variation in octaves
bound b z
mean phase difference
oe x x
function of deltax
deltaoe gamma z
quadrature pair filters
phase based disparity
e j deltaoe
phase based techniques
measurement of image
windowed fourier transforms
mean b z
band pass filtered
shown to depend
sample of white
behaviour of deltaoe
jepson and fleet
local phase information
k 0 x
gamma z 1
valued band pass
translations and dilations
square wave filters
linearity of phase
residual term r
space phase behaviour
stability and phase

corpus/krapavin2000-test/628213.txt
production
powder
negation
stratied
argumentation
gps
grounded
naf
failure
semantics
attacks
classical
pps
literal
atoms
atom
wash
washing
preferred
cond
denition
ps
tenure
sem
cl
actions
ict
stable
priorities
stratication
hyp
shops
hire
rules
priority
computations
rule
clothes
patient
achievable
assistant
mp
neighbor
nal
assert
sound
dierent
incomplete
defended
washed
hfnot
literals
arguments
coincide
defeasible
defend
hp
life
specication
logic
house
retract
borrow
borrowing
attacked
rst
founded
nd
prioritized
ann
satised
ground
cult
cardinality
eect
dened
nonmonotonic
declarative
strata
acceptable
acceptability
action
dene
shop
reasoning
doctor
hired
attack
logics
compiling
defeats
subcomputation
mary
acquire
resp
robot
defeated
applicable
imagine
away
nondeterminism
active
risky
cleang
bgi
prex
treatments
intuitive
fag
buying
acquiring
di
con
save
premises
agi
nondeterministic
ni
formalized
stratified
lives
fnot
terminologies
goals
compile
leader
intuition
foot
fbg
eorts
sequel
monotonic
leading
bottom
database
occurring
naive
disjunctive
ag
plausible
referring
advisor
hw
hypotheses
professors
revised
saving
head
course
nite
machine
propositional
operator
io
cut
enjoy
treatment
understanding
minimality
meaning
team
nonempty
undesirable
artifact
world
person
polynomial
viewing
buy
prof
pg
deeper
worth
label
ancestor
professor
satisfying
empty
expressiveness
adopted
pm
renaming
opinion
faculties
ghter
fateful
peoples
frostbite
argumen
oering
attacksi
fneighbor
computationg
minimalg
bop
doctors
arar
production systems
production system
computation c
machine powder
classical production
general production
stratied gps
complete computation
stratied production
production rule
p 0
cond r
cl cond
production rules
argumentation systems
r l
rule r
possible computations
gps p
ict free
hyp r
incomplete state
naf literal
possible computation
stable semantics
con ict
complete computations
grounded preferred
nal c
stratied ps
classical ps
logic programming
l 0
c 0
stable set
hand wash
away negation
sound implementation
attacks c
compiling away
classical negation
complete implementation
grounded semantics
partial computation
semantics coincide
real life
argumentation system
classical literal
empty computation
assert p
empty computations
incomplete states
using negation
output semantics
l r
denition 5
c 2
underlying assumptions
life problems
active database
declarative semantics
system p
least solution
computation starting
set r
rule based
di cult
common sense
well founded
r 1
argumentation based
borrow powder
possible course
assumptions hfnot
acquire machine
grounded well
hand washing
example 3
current state
c 3
r 4
us rst
denition 3
example 1
c 1
literal l
referring back
r r
let us
active databases
negation as failure
course of actions
cl cond r
stratied production systems
nd a course
l 0 r
r l 0
con ict free
computation c 0
failure to nd
number of atoms
cardinality of r
classical production systems
set r l
base for l
set of arguments
r l r
preferred and stable
production system p
way to acquire
general production systems
classical production system
complete computation c
input output semantics
systems with negation
example 1 1
set of computations
real life problems
cult to see
c of p
programming with negation
rule in p
general production rules
class of stratied
grounded well founded
assumption not machine
c in c
general production rule
powder in house
underlying assumptions hfnot
classical production rule
compiling away negation
example 3 3
c 0 2
let us rst
back to example
computation c 2
c p 0
implementation of p
semantics of p
exists a computation
priorities between rules
introduce the class
l with respect
atoms of p
sound and complete
rule based systems
active database systems
respect to p
grounded preferred stable
shops are open
powder then hand

corpus/krapavin2000-test/636361.txt
filter
filtering
oe
dt
ffi
sigma
wiener
noise
deduce
signal
diffusions
filters
differentiation
phi
asymptotic
nonlinear
injective
valued
fh
matrix
riccati
dx
ds
stability
kalman
derivatives
estimation
filtration
girsanov
kz
differentiable
fx
restored
dy
expansions
jacobian
processes
channel
pi
differential
diffusion
stationary
noisy
estimations
integration
converges
loose
devoted
suboptimal
approximate
vanishes
filtrage
fragile
bruit
avec
hasffi
unnoisy
morceaux
eaire
ffp
semimartingales
vaste
coefficients
estimate
ff
dimensional
taylor
gammap
neglects
detectability
formula
observation
ae
kv
law
log
nonlinearity
gammac
puted
matrices
equation
petit
expectation
derivative
uniformly
summing
conditional
stable
lebesgue
injectivity
proposition
ith
boundedness
ku
multiplication
inequality
schwarz
stochastic
notations
cauchy
probability
differentiated
rp
assump
dp
differentiate
differentiating
iis
magnitude
transposition
moments
invertible
convergence
articles
scale
quadratic
tracks
bounded
psi
par
fm
spaces
adopted
force
contraction
gamma
verifies
linearity
jth
dynamical
gain
body
fy
entering
fi
multiply
satisfies
efficiency
approximation
smoothing
piecewise
going
aim
enable
inverse
dealt
notices
rigorous
proceeding
rate
nonnegative
th
variation
viewed
observed
claimed
monotone
modelled
restrictive
sequel
multidimensional
submitted
asymptotically
multiplying
evident
lin
theoretically
article
behaviour
error
observations
transforming
parts
assumptions
equations
obtains
exponentially
looks
switching
converge
variance
surprising
involving
tends
replace
contents
calculus
universal
driven
negligible
log l
sigma m
observation noise
x 1
z th
optimal filter
d dt
approximate filter
filtering error
nonlinear filtering
wiener processes
oe f
filter 3
r 0
initial condition
parts formula
noise channel
order gamma1
o gamma1
standard independent
low noise
dt d
probability measure
linear case
fh x
independent wiener
small observation
dimensional diffusions
valued process
order gamma3
time scale
matrix valued
extended kalman
uniformly bounded
filtering problem
f 12
condition x
l 2
finite dimensional
ffi 1
p gamma1
x 0
one dimensional
kalman filter
theorem 2
j 2
almost linear
dimensional process
th 0
bounded partial
processes x
ffi holds
assumption h6
girsanov theorem
ds oe
assume h1
quadratic variation
signal see
filter m
dx 1
force described
filtration generated
bounded derivatives
diffusions measured
approximate filters
observation function
optimal filtering
high signal
efficient suboptimal
channel nonlinear
inequality one
estimate j
noise vanishes
gamma sigma
valued processes
riccati equation
oe oe
h x
oe h
u yields
computation shows
taylor expansions
obtain d
th 2
signal x
dx 2
two filters
conditional expectation
th x
asymptotic analysis
l p
process f
u gamma
function h
d d
j 5
fx t g
integration by parts
theorem 2 1
low noise channel
differentiation with respect
term of 30
almost linear case
independent wiener processes
ffi is close
x t g
matrix valued process
standard independent wiener
small observation noise
d d j
change of probability
condition x 0
extended kalman filter
initial condition x
d j 2
f and h
theorem 3 1
loose the signal
obtain d dt
viewed as functions
signal see 8
l t z
z th 0
replace the processes
two dimensional process
order gamma1 2
z t sigma
o s formula
enough to 1
obtained from fh
differentiable with respect
dt d d
j 2 dt
th x 1
d dt d
m t given
channel nonlinear filtering
order gamma3 4
o gamma1 4
gamma sigma m
converges to 0
z th x
z th 2
filter is studied
th 2 x
observation noise vanishes
bounded partial derivatives
dimensional diffusions measured
small and one
assumption h6 ffi
th 0 x
optimal filtering problem
one dimensional diffusions
r 0 log
error is small
f t g
yields a process
noise channel nonlinear
one can write
h x 1
replaced by oe
theta 2 matrix

corpus/krapavin2000-test/614335.txt
streak
particle
tetrahedron
unsteady
velocity
particles
tetrahedral
cell
tracing
visualization
interpolation
flows
grid
interactive
tapered
injectors
flow
rake
grids
curvilinear
tetrahedra
coordinates
windtunnel
advection
physical
cylinder
cfd
fig
runge
vortex
kutta
fluid
interpolations
dt
hexahedral
processors
zone
wing
cells
location
odd
lines
raphson
gigabytes
integration
visualize
shedding
interactively
decompositions
frames
numerical
frame
stream
traces
trilinear
interpolated
numbering
newton
megabytes
face
steady
injecting
crossed
field
levit
darmofal
buning
adjoining
bulirsch
lucy
novoselov
violator
pao
virtual
rates
rendered
falko
bryson
stoer
onyx
advections
haptic
kuester
bruckschen
velocities
injection
doubling
christopher
joy
advected
hamann
graphics
decomposition
haimes
airfoil
sgi
jacobian
determinant
dale
oscillating
nasa
bernd
temporal
halved
ralph
fields
sec
simulations
simulation
batch
kenneth
motion
spatial
roman
angle
tolerance
tables
visualized
interpolating
lawrence
locate
configuration
dependent
sought
inverted
abstractstreak
smoke
terrill
peskin
creon
sungho
judith
recirculation
jespersen
subsetting
scrutiny
albertelli
clump
polina
tunnels
rudiger
sadarjoen
bashforth
kruger
karman
hultquist
aeronautical
understeer
synergistic
kipfer
renderframes
hagedorn
kelso
kondratieva
satterfield
displacement
solvers
accuracy
released
probe
adaptation
nearby
conventions
tests
render
conditional
moving
continuity
advance
transformed
commensurate
remapped
streaklines
sikorski
barycentric
surrounds
crawfis
filament
tracers
bends
weaving
chaderjian
malaterre
core
delta
hundreds
streak lines
particle tracing
point location
natural coordinates
unsteady flows
velocity interpolation
physical space
time steps
step size
tapered cylinder
unsteady flow
computational space
tetrahedral method
frame rates
three processors
stream lines
h z
time dependent
x h
particle traces
unsteady particle
streak line
particle path
tetrahedron 5
path lines
tetrahedron 4
tetrahedron 2
virtual windtunnel
tetrahedron 3
tetrahedron 1
x z
tetrahedral decomposition
velocity field
curvilinear grids
tracing algorithm
simulation time
important flow
physical coordinates
lines could
even tetrahedral
tracing algorithms
kutta scheme
tetrahedral decompositions
time lines
cell search
time step
z x
runge kutta
data set
hexahedral cell
steady flows
data sets
delta wing
multi zone
z 0
numerical integration
interactive streak
spatial interpolation
path line
location technique
temporal interpolation
line generated
flow simulations
particle would
zone data
step doubling
space tracing
line injectors
test tetrahedron
lines path
particles sec
lines streak
advection rate
newton raphson
frames per
y z
vortex shedding
curvilinear grid
interactive frame
interactive performance
velocity vector
non dimensional
large unsteady
particle advection
per second
interpolation function
b even
linear basis
one two
dependent particle
flow features
raphson method
finite element
jacobian matrices
conditional test
error tolerance
vector field
equation 4
current position
bounding tetrahedron
interactive computation
roman y
studying unsteady
space particle
fraction d
current tetrahedron
visual haptic
size adaptation
y pao
numbering convention
buning 15
actual motion
numbering conventions
tetrahedral elements
lucy y
batch computations
space schemes
size dt
bulirsch stoer
cell same cell
x h z
x z x
z x z
tetrahedron 3 tetrahedron
tetrahedron 4 tetrahedron
tetrahedron 1 tetrahedron
number of streak
tetrahedron 2 tetrahedron
look up tables
particle tracing algorithms
streak lines could
runge kutta scheme
simulation time steps
particle tracing algorithm
computed and rendered
even tetrahedral decompositions
number of particles
odd and even
could be computed
location and velocity
tetrahedron 5 z
odd and b
test tetrahedron 1
multi zone data
would have crossed
conditional test tetrahedron
natural coordinates x
zone data sets
lines and time
coordinates x h
lines streak lines
unsteady particle tracing
point location technique
interactive streak lines
streak line injectors
frames per second
dependent particle tracing
h z 0
interactive frame rates
linear basis function
taken to compute
newton raphson method
time dependent particle
x y z
visualization of large
two and three
lucy y pao
flows numerical simulation
simulation of flow
expensive for interactive
computation and visualization
important flow features
generated by tracing
darmofal and haimes
space to make
particle advection rate
space particle tracing
interpolation is performed
physical space tracing
flows the velocity
physical space particle
dale a lawrence
location at time
capture these features
b tetrahedral decomposition
changes in time
christopher d lee
linear interpolation function
unsteady particle traces
continuity between cells
roman y novoselov
steps of data
needed to identify
x z tetrahedron
time fraction d
time t d
grid and velocity
grid and solution
stream lines path
tapered cylinder data
tracing in computational

corpus/krapavin2000-test/608920.txt
tam
wrapper
tams
soc
cores
scan
ppaw
core
chains
ilp
width
testing
pnpaw
socs
chain
paw
widths
wrappers
marinissen
chakrabarty
bypass
krishnendu
kmax
pw
enumerative
chip
enumerate
sehgal
automation
europe
erik
longest
anuja
sc
co
internal
partition
goel
bus
sandeep
wmax
functional
balanced
maxfs
extest
jan
minimized
assignment
pb
bfd
ijk
clock
optimization
os
bits
ozev
sule
intest
chips
jk
cycles
exec
np
flops
kumar
nicolici
sog
interconnect
lengths
halted
philips
flip
vikram
designs
bin
iyengar
multiplexed
partitioning
scheduling
minimize
industrial
partitions
embedded
terminals
qiang
unbalanced
linearized
integration
lpsolve
maxrfl
daisy
psc
multiplexing
nicola
objective
conjecture
vlsi
optimizing
architectures
inputs
tester
yoneda
stones
tomokazu
reconfigurable
scalable
xu
smin
fujiwara
iscas
hideo
adaptation
electronic
outputs
infrastructure
sizing
assigned
munich
mathematical
analog
cells
priority
utilization
stepping
formulated
assignments
progression
combinational
modular
ics
solver
solved
minimizing
circuits
address
standardized
pseudocode
enumerated
wrapped
exceeding
ff
addressed
iii
fit
serialization
mode
modes
bins
methodology
patterns
heuristic
bit
formulation
created
mixed
determining
rings
ultra
flexible
zahra
zhanglei
minmax
saleh
minftg
wenhua
jianhua
minimiz
arbitrating
oostdijk
peripheral
optimizaion
burleson
wrapper scan
testing time
tam width
scan chain
scan chains
internal scan
wrapper design
wrapper tam
co optimization
tam optimization
tam design
tam co
ilp model
testing times
test access
total tam
ppaw enumerate
test wrapper
design wrapper
jan marinissen
longest wrapper
design automation
krishnendu chakrabarty
tam widths
functional inputs
core assignment
b tams
core based
erik jan
core 6
system testing
clock cycles
test bus
tam lines
test wrappers
ieee p1500
balanced wrapper
soc d695
test scheduling
general problem
soc test
mathematical programming
test width
two tams
bit tam
width among
problem pw
functional outputs
kumar goel
width partition
anuja sehgal
chain 8
core test
n cores
access mechanism
sandeep kumar
execution time
europe p
design problem
times obtained
programming model
chain elements
width required
pb w
goel erik
pnpaw 1
industrial soc
system chips
soc p93791
tam j
scan elements
ilp formulation
width adaptation
chains created
ilp models
test patterns
w among
optimal partition
chip test
embedded core
core testing
np hard
optimal testing
infrastructure design
wrapper chains
interconnect test
bin design
soc testing
longest internal
access architectures
test architecture
new wrapper
bus model
minimize testing
optimal tam
test infrastructure
test time
width w
obtained using
w j
based system
design algorithm
chakrabarty test
wrapper scan chains
wrapper scan chain
internal scan chains
wrapper tam co
number of tams
tam co optimization
total tam width
internal scan chain
cores to tams
longest wrapper scan
assignment of cores
system on chip
conference on design
system testing time
erik jan marinissen
test in europe
automation and test
balanced wrapper scan
time is minimized
values of w
chain 8 ff
sandeep kumar goel
mathematical programming model
testing times obtained
test access mechanism
scan chain 8
number of wrapper
problem of wrapper
core based system
tam width partition
time for d695
scan chain elements
goel erik jan
tam width required
chains of lengths
kumar goel erik
number of tam
among the tams
scan out chain
scan in scan
longest internal scan
wrapper design algorithm
cores and b
core testing time
test infrastructure design
created in part
test access architectures
test width adaptation
test bus model
model for ppaw
minimize testing time
based system chips
tam width among
values of b
partition of w
partitions of w
large scale integration
vlsi systems v
integration vlsi systems
scale integration vlsi
stated as follows
problem of determining
ieee p1500 standard
models for tam
assignment to tams
scan chain 1
tams of given
soc testing time
february 16 20
sule ozev krishnendu
wrapper chains created
time 1000 clock
total testing time
assignments of cores
using ppaw enumerate
tam optimization models
assigned to tam
soc as well
partitioning wrapper scan

corpus/krapavin2000-test/631135.txt
firing
spns
spn
petri
marking
regenerative
stochastic
sr
nets
smp
emc
transition
subordinated
ctmc
transitions
regeneration
timed
steady
transient
rft
enabled
dtmc
srp
markov
dspns
ciardo
firings
markovian
markings
expolynomial
fire
fires
tangible
dspn
gspns
distributions
reachability
transmission
net
nk
exponentially
matrix
conversion
reward
inhibitor
timeout
exponential
supplementary
const
semi
gsmp
technische
espns
tpns
tokens
german
jensen
immediate
discrete
restart
ctmcs
ioe
memoryless
berlin
holding
instants
transi
geom
numerical
truncation
entries
oe
sm
mr
evolution
deterministic
probabilities
multiplicity
probability
molloy
gtpns
marsan
tpn
mial
ajmone
expolyno
bobbio
stieltjes
timenet
tg
delay
vol
arc
equations
places
underlying
laplace
sans
trivedi
srns
chain
piecewise
pi
geometric
instant
scaling
analytical
psi
discretization
policies
arcs
universit
cesses
polynomials
hierarchy
row
factors
mass
reinhard
quotients
normalizing
fl
enabling
event
fired
und
se
excessively
activity
generalized
matrices
formulas
generator
processes
constitute
normalized
enjoys
mail
differential
kernel
unity
characterization
embedded
weighted
multiplications
recurrent
theta
concurrently
randomization
delta
exchange
germany
throughput
fur
rows
appendix
simulation
disabled
increasingly
drawn
sufficiently
stochas
shedler
fioe
rechnersysteme
bechta
williamsburg
horvth
gmd
asymptotical
natkin
geist
stochastiques
mikls
bmft
gesellschaft
thors
gtpn
expolynomials
rfts
daten
armin
sanda
chiola
erhan
symons
rge
kelling
multiplic
tekel
stochastic petri
firing time
petri nets
sr spn
steady state
distributed firing
regeneration points
sr spns
state solution
firing times
stochastic process
petri net
probability vector
marking process
semi markov
underlying stochastic
transient analysis
conversion factors
timed transitions
immediate transitions
timed transition
exponentially distributed
probability matrix
subordinated ctmc
process underlying
regenerative spns
firing delay
markov regenerative
discrete time
timed petri
state analysis
state probability
transition probability
numerical solution
step transition
matrix exponential
regenerative stochastic
regenerative transition
extended dspns
time distributions
state probabilities
marking dependent
reachability set
non exponentially
regeneration point
vol 20
execution policies
regenerative transitions
markov spns
firing distributions
ciardo et
expected holding
average firing
minimum rft
semi regenerative
subordinated processes
activity networks
ctmc spns
transmission line
holding times
step oe
spns underlying
unit step
matrix p
continuous time
generalized timed
time distribution
engineering vol
analytical solution
generalized stochastic
transition firing
markov chain
july 1994
equations 11
software engineering
stochastic activity
transitions enabled
extended stochastic
two transitions
piecewise defined
spn whose
time spns
exponential transitions
spn classes
generally distributed
markovian spn
become enabled
embedded process
constant firing
firing process
srp spns
transient state
equations 16
dtmc spns
immediate transition
places contain
embedded markov
supplementary variables
vector matrix
phase type
generalized semi
modeling power
tangible marking
increasingly efficient
markov process
one step
discrete event
geometric distribution
distribution function
scaling factor
stochastic petri nets
steady state solution
stochastic petri net
exponentially distributed firing
transition probability matrix
distributed firing times
stochastic process underlying
state probability vector
step transition probability
steady state analysis
underlying stochastic process
steady state probability
one step transition
underlying a stochastic
regenerative stochastic petri
jensen s method
firing time distribution
firing time distributions
deterministic and stochastic
probability matrix p
timed petri nets
non exponentially distributed
al a characterization
ciardo et al
engineering vol 20
distributed firing time
transition t 1
transactions on software
generalized stochastic petri
transition is enabled
analysis of stochastic
generalized timed petri
software engineering vol
semi markov spns
embedded markov chain
extended stochastic petri
f t delta
method of supplementary
generalized semi markov
markov regenerative stochastic
increasingly efficient solution
matrix of conversion
expected holding times
reduced in exchange
classes of spns
analysis of deterministic
generally distributed firing
power is reduced
classes where modeling
must be studied
constant firing times
transient state probabilities
regeneration points must
c of conversion
average firing time
semi markov process
hierarchy of spn
stochastic activity networks
solving the linear
enabled in marking
transient and steady
transition t 2
class of extended

corpus/krapavin2000-test/628030.txt
weak
transaction
strict
copies
ias
quasi
cluster
reconciliation
schedule
consistency
writes
mobile
core
intracluster
wt
iasg
item
read
copy
serializability
ww
clusters
sw
disconnections
intercluster
sr
updates
reads
ies
replication
iesg
disconnected
hot
st
cold
items
op
coherency
schema
inconsistency
disconnection
wr
connectivity
bandwidth
quorum
transactions
serial
lock
conflicts
integrity
cl
serialization
committed
sites
database
conflict
divergence
weakly
commit
permanent
networking
messages
correctness
abort
rowa
locality
divergent
throughput
bayou
acyclic
allowable
vacation
replicated
clients
nl
response
currency
aborted
sg
eventual
client
concurrency
ignorant
initiated
commitment
iots
consistent
contention
translation
wireless
reconciling
intermittent
projection
adaptivity
locally
criterion
host
tentative
granule
esr
inconsistent
availability
roll
server
update
rolled
reconciled
replica
trans
hosts
latency
operate
ranges
arrival
coda
file
middleware
locks
strongly
sec
immediate
adaptability
acyclicity
conservative
compatibility
cached
tuned
semantics
bellavista
stefanelli
hotspots
corradi
dependency
conditionally
undone
serializable
rate
duration
queries
edge
modes
environments
managers
wired
protocols
optimistic
plugged
cesare
roncancio
alvarado
montanari
date
management
wrote
propagate
service
aware
probability
synchronizing
iff
located
intervals
globally
laptops
claudia
intermittently
users
attain
projections
session
write
network
belong
prevailing
serrano
extremes
percentage
frequently
effort
depicts
accesses
interface
barriers
rebecca
transmission
imposed
databases
accepted
precedence
portable
requirements
ignorance
connected
weak transactions
strict transactions
core copies
quasi copies
data item
strict transaction
weak transaction
consistency factor
intracluster schedule
one copy
strict read
data items
weak read
core copy
weak connectivity
weak operations
copy serializability
serial schedule
quasi copy
strict write
networking conditions
weak writes
among copies
st j
hot data
reads x
serialization graph
response time
strict operations
weak write
sw x
ias schedule
data copies
bounded inconsistency
database state
consistency requirements
disconnected operation
translation function
data copy
read operation
since weak
connected sites
intercluster schedule
replication schema
cold data
wr ww
ww sr
input rate
transaction wt
sr sw
cluster cl
mobile computing
different clusters
integrity constraints
available bandwidth
correctness criterion
allowable input
divergent copies
disconnection intervals
coherency control
copy serial
strongly correct
d consistency
write operations
item x
conflict equivalent
system throughput
best effort
read operations
maximum allowable
j reads
transactions read
value read
copies located
currency requirements
data contention
locally available
abort times
transaction st
access hot
x reads
weakly correct
dependency edge
since strict
local quasi
q r
write operation
factor c
processing time
arrival rate
read quorum
strict consistency
database interface
per cluster
mobile file
per data
weak and strict
one copy serializability
number of messages
core and quasi
read only transactions
copies of x
number of weak
operations on data
weak transaction wt
wr ww sr
probability of abort
ww sr sw
one copy serial
st j reads
j reads x
copy serial schedule
consistency factor c
allowable input rate
since weak transactions
data item x
order of transactions
reads from relationship
strict transaction st
sw x x
transactions at different
copy of x
conflicts between weak
rate for updates
transaction of type
strongly connected sites
sr sw x
maximum allowable input
per data item
strict and weak
schedule s ias
percentage of weak
consistency factor figure
ranges from 0
read and write
degree of divergence
number of read
types of translation
weak write ww
duration of disconnections
local quasi copies
among copies located
data items per
connected sites belong
copies and weak
items per cluster
divergence among copies
strict write operation
strict write sw
strict read sr
database state x
values of bandwidth

corpus/krapavin2000-test/610819.txt
gray
digit
tape
tapes
computability
signed
sdr
stog
indeterministic
computable
embedding
pl
lled
heads
xs
cell
rst
character
innite
multihead
haskell
head
dyadic
expansion
denition
dene
machine
topological
conv
xor
nite
valued
alphabet
invert
sd
eternally
gtos
ds
moved
characters
code
undenedness
sequences
turing
conversion
innitely
realizes
blank
machines
outputs
bits
decimal
representations
injectivity
bit
im
topology
inverted
dened
indeterminism
unlled
redundancy
tail
calculate
interval
induced
applicable
name
overwritten
symmetricity
cantor
modied
tent
names
subspace
composing
homeomorphic
fbg
injective
nh
golden
conversions
recursive
ll
proposition
output
cells
nondeterministic
binary
prex
shrinking
coming
skipping
arithmetic
rational
dierent
located
deterministic
fractions
usual
numbering
int
rules
integers
movements
losing
coding
realized
nondeterminism
rule
functional
addoneoftwo
coroutine
prexes
hideki
izumi
machiens
mariko
knobel
embbeding
omnibus
distin
kamo
tsuiki
explaind
guish
yasugi
bottomed
hiroyasu
complement
shifting
dom
dier
repeats
converts
intervals
lazy
dening
eective
uncountably
naturality
takagi
richards
expan
itinerary
grzegorczyk
indenitely
acted
lose
putting
waits
continued
encoding
reads
lling
followings
discus
ghc
zip
takeuchi
sicstus
multi
inputs
paths
gray code
signed digit
digit representation
type 2
output tape
multi valued
work tapes
real numbers
input output
code expansion
input tapes
next cell
indeterministic multihead
innite sequences
code embedding
multihead type
valued function
h 2
input tape
sdr name
rst digit
real number
h 1
exact real
computability notion
usual binary
computational paths
unit open
binary expansion
embedding g
dyadic number
topological embedding
binary code
two heads
code computable
pl 0
modied gray
valid results
applicable rule
remaining bits
open interval
pl 1
nite time
output sequences
xs 0
im g
partial function
one head
output tapes
real functions
number x
stog 0
decimal point
code computability
second digit
whole real
blank character
approximation information
calculate f
restricted signed
computability induced
innitely many
machine m
computes f
innite sequence
haskell program
rational interval
many names
one induced
rst bit
produce valid
real line
language haskell
basic algorithms
x 7
bit 1
functional language
real function
computable function
function f
turing machine
real arithmetic
topological properties
signed digit representation
type 2 machine
gray code expansion
multi valued function
h 2 o
multihead type 2
gray code embedding
indeterministic multihead type
name of x
h 1 o
type 2 machines
unit open interval
pl a 1
input output sequences
gray code computable
position of h
modied gray code
representation and type
o and h
input output tapes
produce valid results
gray code computability
machine of type
usual binary code
o is moved
functional language haskell
restricted signed digit
stog 0 0
based on gray
set of innite
function to calculate
whole real line
input output tape
multi valued functions
innitely many names
output is made
topology on f0
reduction of figure
calculate f x
tape is lled
notion of computability
computability of real
f i k
real number x
thus we dene
h n 1
exact real arithmetic
computable function f
half of figure
rule is applicable
form a 1
invert the output
expansion of real
good approximation information
computability and domain
may be overwritten
machine we consider
second cell respectively
consider the inverse

corpus/krapavin2000-test/614468.txt
radiosity
illumination
scene
patch
texture
light
unoccluded
shadows
textures
shadow
virtual
relighting
reflectance
radiance
patches
lighting
visibility
photographs
lights
irradiance
subdivision
occluded
interactive
correction
refinement
color
frontier
rendering
reconstruction
bi
scenes
images
display
mesh
links
modulated
intensity
sources
blocked
fis
preprocess
intensities
hierarchy
reflectances
debevec
interactively
photograph
emittance
ei
visible
diffuse
modulation
reprojection
insertion
calibration
modification
reality
mosaics
reprojected
imag
regions
rgb
3d
darker
eq
camera
vision
tex
image
switched
outdoors
modulating
corr
casting
objects
augmented
subdivided
pixel
graphics
subdivide
viewpoint
ray
floor
modulate
orange
virtually
inserted
totalcalib
loscos
quicktime
frs
reproject
exchanges
source
boundaries
polygons
preprocessing
geometric
inter
reconstructed
indoors
imagis
occlusion
polygon
hierarchical
pull
attenuation
geometry
indirect
leaves
registration
projected
video
manually
final
environments
specular
modifications
switch
extracted
wall
sec
photo
modify
onto
di
publications
inaccuracies
colors
lumination
rekon
photos
flectance
finement
bfv
fournier
mincolor
mindistance
distancecolor
effects
viewpoints
invisible
ev
red
push
secondary
poulin
shaft
occluders
quadtrees
polyhedra
insert
progressive
passive
refine
creation
object
estimated
coarser
reference
fr
modifica
soler
cyril
mosaic
illuminate
ture
correspondences
leaf
epipolar
convincing
sillion
updates
appropriately
ratio
removal
cast
bf
lit
opengl
bright
notably
world
clusters
turned
inria
recovering
removed
adapted
limitation
exposure
solu
accurate
tracing
gather
heuristic
real scene
virtual objects
virtual light
common illumination
virtual object
light source
light sources
unoccluded illumination
hierarchical radiosity
correction factor
real light
reference patch
shadow boundaries
radiosity solution
augmented reality
blocked light
texture based
real shadows
radiosity system
real objects
based refinement
radiance images
patch hierarchy
illumination effects
real scenes
global illumination
illumination textures
virtual lights
original texture
form factor
bi di
display correction
two patches
lighting conditions
dynamic range
left light
reflectance values
form factors
real lights
new reflectance
visibility information
hand light
heuristic correction
using radiance
right light
vision based
multi pass
interactive relighting
additional irradiance
new texture
light intensities
current radiosity
radiosity step
high dynamic
passive links
debevec et
occluded patch
radiosity value
virtual source
unoccluded patches
illumination tex
radiosity bi
mesh subdivision
virtual sources
visibility type
shadow regions
video sequences
real world
figure 20
b c
sec 0
resulting texture
interactive modification
scene using
geometric model
computer graphics
push pull
different lighting
c d
ray casting
3d model
b figure
www imagis
illumination texture
shadow calculations
loscos tvcg00
texture modification
light exchanges
insert virtual
imagis imag
similar color
original photographs
publications loscos
dynamic object
patch r
source intensities
pass display
original illumination
real and virtual
texture based refinement
virtual light source
unoccluded illumination textures
shown in figure
display correction factor
common illumination effects
real light sources
left hand light
virtual light sources
method of 8
b c d
real scene using
modification of real
debevec et al
unoccluded illumination tex
high dynamic range
virtual and real
insertion of virtual
real world textures
workshop on rendering
light source visibility
lights and objects
http www imagis
adding in blocked
fr publications loscos
modulating the texture
algorithm of debevec
regions of shadow
using radiance images
imagis imag fr
hierarchical radiosity system
real scene viewed
new reflectance values
quicktime video sequences
dynamic virtual object
unoccluded illumination texture
refinement for shadow
loscos tvcg00 index
imag fr publications
www imagis imag
publications loscos tvcg00
multi pass display
original real scene
different lighting conditions
b the resulting
web http www
c d figure
presented in detail
graphics and interactive

corpus/krapavin2000-test/629452.txt
routing
destination
gedir
wireless
hop
hcb
energy
swr
power
localized
ad
consumption
hoc
mfr
dir
neighbors
delivery
lifetime
packet
sensor
sp
transmission
neighbor
message
rm
bd
route
networks
mobile
stojmenovic
shortest
node
sl
radio
metrics
nfp
ivan
sd
nc
gps
neighboring
compass
loop
battery
nearest
progress
aware
networking
success
dies
metric
mobility
transmissions
location
protocols
elec
counts
routes
boca
raton
minpower
bcsw
transmit
closer
sb
flooding
sa
bmsu
nodes
rounded
bs
forwarding
sender
kv
multihop
ietf
crc
consumed
ts
reception
geographic
savings
toward
holding
rates
forward
count
guaranty
sppower
maxpow
rodoplu
minpow
eghk
clusterhead
bmjhj
batteries
minimize
proactive
retransmissions
traffic
greedy
network
tv
hops
source
hosts
dijkstra
send
greatest
closest
saving
sending
ksu
expends
prasant
reluctance
healing
tassiulas
mohapatra
finn
mc
demand
distance
decisions
hoping
plenty
memorizing
minimizes
adjusted
packets
pc
trial
weighted
amp
forwarded
ax
selects
path
sensors
bellman
sleep
conserving
radii
ford
quorum
ticket
radius
shall
handbook
press
chao
rate
ar
hl
awareness
gui
reached
graphs
formulas
rt
nk
aimed
retransmission
delivered
transmitting
sends
monitoring
superiority
obstacles
signal
variant
experimentally
occasional
meng
positioning
sides
failure
communicated
cn
jie
variations
failed
drops
spaced
update
lin
yu
alpha
inc
solely
ac
hopefully
power cost
routing algorithm
routing algorithms
ad hoc
power consumption
wireless networks
efficient routing
loop free
power efficient
power needed
u r
sp power
hoc networks
sensor networks
hop counts
cost methods
localized routing
hcb model
power aware
shortest weighted
cost efficient
success rate
hoc wireless
energy consumption
path algorithm
d ad
currently holding
ivan stojmenovic
routing task
non localized
cost routing
direct transmission
destination d
weighted path
u d
mobile ad
neighboring nodes
routing protocols
hop count
power method
routing decisions
transmission power
random progress
power savings
delivery rates
localized power
aware routing
remaining power
ts r
compass routing
rm model
gps based
wireless ad
node b
wireless sensor
neighboring node
hoc networking
location update
networks proceedings
routing tasks
sp cost
cost method
per routing
nfp method
total power
e elec
aware metrics
bd c
unit graphs
power saving
cost b
best choice
update scheme
based routing
pc b
networks mobile
localized algorithms
control messages
intermediate node
nearest integer
energy per
destination node
total energy
shortest path
routing techniques
minimal power
networks crc
radio model
cost algorithms
proposed localized
energy consumed
consumption metric
method dies
raton fl
power formula
ad bd
low success
r tv
consumption may
boca raton
increased energy
delivery rate
adjusted transmissions
past traffic
inc boca
bcsw kv
previous node
progress method
localized cost
power adjusted
minimize p
crc press
dir routing
demand based
cost iii
efficient routing algorithm
cost and power
ad hoc networks
power efficient routing
neighbor of b
sp power cost
shortest weighted path
power cost methods
ad hoc wireless
hoc wireless networks
u d ad
mobile ad hoc
routing in wireless
wireless sensor networks
wireless ad hoc
weighted path algorithm
forward the message
c a 1
ad hoc networking
b a f
location update scheme
power cost routing
power cost efficient
f a ts
algorithms are loop
cost routing algorithms
power cost b
algorithm is loop
power aware metrics
cost efficient routing
rounded to nearest
properties of power
sizes of m
localized power efficient
closer to destination
c a f
f a u
acm international symposium
routing in ad
d a c
follows repeat let
wireless networks crc
techniques for mobile
per routing task
localized routing algorithm
b that minimizes
networks the handbook
localized routing algorithms
choice of neighbors
u r tv
destination is reached
handbook of ad
networks crc press
power aware routing
delivery in wireless
power adjusted transmissions
hcb and rm
boca raton fl
reached if possible
minimizes pc b
neighbors and destination
networks and applications
power cost method
energy consumption may
crc press inc
d is u
power consumption metric
low success rate
power and cost
increased energy consumption
press inc boca
random progress method
power cost algorithms
total power needed
aware routing algorithm
needed for direct
routing algorithm may
inc boca raton
networks mobile networks
source and destination
symposium on mobile
applications v 10
holding the message
b a u
minimize the total
values of m
hoc and sensor

corpus/krapavin2000-test/627258.txt
token
visit
visits
ttrt
timed
synchronous
sevcik
elapse
protocol
trt
transmission
arrival
johnson
rotation
deadlines
inclusive
mac
tighter
node
fddi
successive
ring
asynchronous
message
arrivals
downstream
han
messages
bandwidth
elapsed
chen
burns
early
late
rotations
overheads
arrives
timing
delta
lc
deadline
destination
unavailable
transmit
generalized
guaranteeing
cycle
tht
neighbor
timer
derivations
exclusive
judged
generalised
ending
transmitting
sba
allocated
pm
zhang
expires
th
fiber
allocation
findings
frames
departure
transmitted
unbroken
traffic
incurred
totally
exceed
stream
bandwidths
timely
imaginary
chance
delivery
till
forwarded
tight
theorems
dc
reset
spent
guaranteed
arrive
neighboring
network
calculated
media
generalizes
communications
externally
expression
relaxed
delay
failing
adaptable
report
medium
convenience
realizing
grow
nodes
subsequent
enabled
holding
constraint
internally
ps
sent
reinitialized
hsrb
enbedded
safenet
nonperiodic
misjudged
sijing
otain
hsdb
transmits
misses
notations
ffl
et
interval
concise
consumed
accounted
gamma
bus
receives
leftover
circulates
deltan
ulm
survivable
glossary
contending
inherent
buffer
worst
subscripts
grows
supposed
arrived
bounded
lemma
counter
departs
fibre
unallocated
visited
instant
wrongly
integers
published
removal
possibly
responsiveness
minf
supposing
optic
quoted
conversions
negotiate
deferring
period
calculate
calculation
upstream
summations
negotiated
tightest
timers
expired
analyzed
schemes
lth
counts
group
immediately
units
simplify
happens
fall
duration
studies
jing
stewart
upper
voice
periodic
initialized
waiting
timed token
token protocol
token rotation
visit l
upper bound
synchronous bandwidth
successive token
c th
han et
th arrival
elapse time
th visit
chen et
bound expression
generalized upper
remaining visits
n successive
early visit
time properties
cycle time
protocol constraint
generalized result
token mac
visit c
synchronous messages
theorem 5
successive visits
visit x
rotation time
synchronous message
mac protocol
node k
downstream neighbor
complete token
message deadlines
token arrivals
n visits
constraint 1
delta n
asynchronous messages
token arrives
possibly elapsed
token rotations
real time
message transmission
time possibly
l th
immediately subsequent
various overheads
et al
tighter upper
destination node
x y
one complete
e node
token ring
timing properties
group 1
time communication
theorem 4
guaranteeing synchronous
asynchronous transmission
pm q
token visits
y pm
generalised johnson
particular node
hard real
synchronous transmission
time communications
al 17
new generalized
source node
delta ttrt
derived upper
early visits
r remaining
late visit
visit p
subsequent arrival
overheads possibly
token makes
l exclusive
previous findings
whole message
bandwidth allocation
ffl based
q m
delta b
sum total
bound derived
bound given
previous results
timed token protocol
johnson and sevcik
arrival at node
generalized upper bound
han et al
chen et al
upper bound expression
cycle time properties
visit to node
timed token mac
token mac protocol
token rotation time
protocol constraint 1
visit x y
token s c
c th visit
complete token rotation
n successive visits
token s l
node i 1
number of successive
unavailable for message
derived by chen
zhang and burns
c th arrival
time possibly elapsed
l i inclusive
successive token arrivals
one complete token
destination node k
derived by han
sevcik s theorem
tighter upper bound
real time communication
means that visit
visits i e
synchronous message deadlines
y pm q
time t l
since the token
x y pm
l th arrival
pm q m
judged with theorem
hard real time
real time communications
q m 1
derived upper bound
results by johnson
timed token ring
b i l
al 1 6
visits in group
various overheads possibly
produce a tighter
r remaining visits
bounded by ttrt
definition of shown
synchronous bandwidth allocation
token s arrivals
immediately subsequent arrival
receives the token
shown in theorem
et al 17
neighbor i e
upper bound derived
given in theorem
upper bound given
et al 1

corpus/krapavin2000-test/627861.txt
microcode
libraries
faults
ibm
bookkeeping
library
word
confidence
functional
fuzzy
records
comment
cfev
development
database
team
historical
tool
definite
manual
errors
extrapolated
teams
relevant
hardware
databases
testing
pertinent
puts
entries
answering
comments
failure
relevancy
percentages
fev
accuracy
fault
separability
dilemma
ffl
attributed
bug
error
regarding
responses
representative
manufacturing
established
processes
severity
avizienis
wfev
category
establishing
defects
put
command
confuse
liable
laprie
attributing
routine
constitutes
irrelevant
disposition
manifestation
validations
intervention
expert
generator
logic
commands
proceeded
promoted
attribution
deviation
percentage
opinion
phi
human
changes
file
failures
responsibilities
assessments
tracking
closeness
examination
record
service
evaluator
validation
entry
composition
responsible
prediction
researchers
resolution
anticipated
investigation
bugs
reflect
breakdown
attribute
developers
days
individuals
report
accesses
patches
answer
experimentations
inapplicability
trackable
readiness
reporting
aspects
absence
discovered
participants
assessment
questions
diverse
concluded
files
maintaining
suggesting
extracted
faulty
findings
erroneous
extrapolations
phenomenological
disagreement
expedient
misunderstanding
misinterpret
reluctance
population
history
methodology
entire
exclude
words
clusters
specifications
plurality
spoken
radiation
pertains
contributor
alphabetically
memberships
today
frequencies
track
row
cycle
question
resolve
validate
clustering
supply
correction
promotes
extrapolation
grades
cluster
outcome
indicating
processor
commonly
confidences
packaging
logging
cooling
categorize
arena
occasions
membership
retrieve
synonyms
relevant words
ibm 4381
functional testing
bookkeeping libraries
relevant word
confidence value
error data
ibm 9370
functional changes
manual evaluation
answering system
question answering
experimental databases
development processes
historical data
word table
words relevant
zero relevant
logic design
possible changes
fuzzy expected
library entries
two relevant
definite changes
microcode development
tracking libraries
change category
routine accesses
entire record
error tracking
tool accuracy
bookkeeping library
modified database
databases db1
possible change
definite change
replace table
changes changes
system test
computer systems
unique word
different development
expected value
development process
development cycle
tool changes
component test
word generator
cfev value
put records
microcode possible
entire development
confidence associated
errors faults
development bookkeeping
database question
words changes
category include
data file
error fault
design faults
test phase
confidence values
error prediction
computer implementations
one relevant
three databases
unique words
issues related
computer system
high degree
system state
put command
changes tool
diverse aspects
word relevant
particular team
defined specifications
possible words
expected service
confidence vector
population sizes
fev processor
faults ffl
entire ibm
laprie 3
reasoning database
ibm 4381 hardware
ibm 4381 microcode
question answering system
relevant words relevant
ibm 9370 microcode
microcode and hardware
fuzzy expected value
relevant word table
zero relevant words
words relevant words
possible and definite
different development processes
error tracking libraries
databases db1 db2
libraries are usually
degree of confidence
two relevant words
ffl we considered
answering system 2
database question answering
development bookkeeping library
system test phase
hardware and microcode
possible change category
comment is assumed
unique word generator
design and microcode
testing of computer
percentage of records
subject of interest
number of changes
error prediction models
contains the words
w r l
three experimental databases
defects and track
establishing the relevancy
relevant two relevant
entire ibm 4381
system to report
set ffl step
frequencies of relevant
avizienis and j
resulting in multiple
definition of faults
days or less
separability of errors
correction of faults
development processes ffl
comments containing zero
processes the dilemma
one relevant word
relevant word relevant
containing zero relevant
phase in three
threshold value ae
identified as patches

corpus/krapavin2000-test/627803.txt
itemsets
mining
association
itemset
frequent
apriori
count
processors
processor
candidate
candidates
sizeup
pass
hash
counts
serial
redistribution
scaleup
datasets
zaki
rules
transaction
response
mohammed
database
filter
apriorihybrid
jiawei
prune
pruning
han
discovery
parthasarathy
abcd
partitioning
multiprocessor
disks
asynchronously
gregory
communication
items
offs
srinivasan
buehrer
riedel
powerparallel
subproblem
databases
ck
aggregate
sigkdd
kitsuregawa
repartitioning
laks
lakshmanan
schuster
masaru
assaf
keng
synchronize
speedup
dataset
sigmod
carson
pdm
wei
disk
discovering
kubat
chiu
choudhary
yen
wolff
leung
ab
passes
agrawal
raymond
liao
newsletter
counting
broadcast
karypis
vipin
alok
faloutsos
mb
christos
shaowei
ghoting
xiaohua
repartitioned
daehyun
shiby
cheung
explorations
workloads
parallelization
hu
kai
chen
generation
trade
ogihara
kan
ruoming
gagan
eui
amol
abcde
ganger
vanneschi
nagle
mitsunori
balancing
sang
ling
jm
mpi
synchronization
bases
sarawagi
hongjun
kurc
coppola
sunita
tahsin
shichao
confidence
counted
associations
prefix
feng
intensive
massimo
mahmut
rakesh
miroslav
scalable
record
xia
kandemir
kuang
saltz
gmbh
physica
li
develops
jin
yu
steve
ibm
rule
lk
kim
exploits
configurations
node
engineering
heidelberg
kumar
dr
smart
david
conscious
shih
nothing
george
ng
winner
heuristically
exchanged
zhang
anthony
southeast
nguyen
join
song
partition
tuples
ning
association rules
frequent itemsets
distribution algorithm
candidate distribution
data mining
mining association
hash filter
processor p
count distribution
data distribution
l k
candidate generation
k gamma1
local data
response time
serial algorithm
aggregate memory
distribution algorithms
prune step
association rule
rule mining
parallel algorithms
candidate set
c k
apriori algorithm
response times
three parallel
apriori candidate
minimum support
parallel mining
support counts
problem specific
engineering v
data engineering
per node
knowledge discovery
count algorithm
frequent itemset
every pass
candidate algorithm
redistribution pass
srinivasan parthasarathy
jiawei han
j zaki
mohammed j
pattern mining
parallel data
generating rules
rules data
support count
rules acm
trade offs
next pass
rule generation
distributed mining
distributed association
record v
sigmod record
mining algorithms
large databases
candidate sets
generation procedure
shared nothing
data bases
steve c
time normalized
kai sang
candidate itemset
alok n
c chiu
larger datasets
six datasets
mb per
k counts
distributed smart
usage synchronization
carson kai
n choudhary
complete l
local candidate
sang leung
smart disks
global c
ran wolff
chiu wei
gregory buehrer
schuster ran
acm sigmod
acm sigkdd
first pass
discovery v
large data
association mining
database size
data tuples
communication memory
assaf schuster
o intensive
pass 1
entire dataset
liao alok
christos faloutsos
wei keng
w cheung
intensive workloads
generating c
keng liao
join step
masaru kitsuregawa
laks v
ling feng
single pass
ieee transactions
candidate itemsets
k itemsets
whose support
hash tree
l j
v 15
k using
mining association rules
l k gamma1
count distribution algorithm
data distribution algorithm
candidate distribution algorithm
association rule mining
c i k
count and data
apriori candidate generation
three parallel algorithms
data engineering v
knowledge and data
transactions on knowledge
n 2 p
number of processors
l i k
parallel data mining
algorithm for mining
mining of association
problem of mining
candidates in c
data distribution algorithms
mohammed j zaki
association rules data
candidate generation procedure
mining and knowledge
sigmod record v
acm sigmod record
n 3 p
engineering v 15
large data bases
amount of data
knowledge discovery v
c k counts
steve c chiu
kai sang leung
k from c
schuster ran wolff
chiu wei keng
use of aggregate
david w cheung
offs between computation
memory usage synchronization
use of problem
computation communication memory
communication memory usage
carson kai sang
step of candidate
response time normalized
o intensive workloads
complete l k
subproblem the problem
every other processor
liao alok n
alok n choudhary
c chiu wei
rules acm sigmod
raymond t ng
assaf schuster ran
spectrum of trade
distributed smart disks
problem specific information
number of candidates
association rules acm
processors to synchronize
wei keng liao
keng liao alok
rules data mining
record v 27
v s lakshmanan
v 15 n
mining of frequent
processors is increased
p i generates
mining for association
distributed association rule
rules in parallel
data bases p
sigkdd explorations newsletter
normalized with respect
explorations newsletter v
acm sigkdd explorations
intelligent data analysis
data analysis v
n 4 p
parallel databases v
n 1 p
parallel and distributed

corpus/krapavin2000-test/1032163.txt
ra
registration
cell
mss
mh
vlr
intra
gammanoncore
lr
ras
cells
gammacore
handoffs
hlr
inter
signaling
bs
mobile
mhs
gammacall
gammamove
mobility
lrs
moves
core
registered
deliveries
handoff
overlapping
calls
cv
delivery
location
reconfiguration
mt
load
registrar
msss
gammaoutgoing
notif
offs
gammaincoming
exclusion
pcs
vv
inclusion
station
req
ex
updates
configuration
gsm
areas
management
bss
noncore
hlrs
messaging
exclude
users
servicing
searches
terminal
costs
highway
candidate
yes
home
id
rates
cmr
visitor
traffic
neighboring
area
boundary
calling
db
sends
period
overlapped
css
subscription
mobiles
update
terminals
cellular
adapting
excluded
move
attraction
ffi
dynamically
geographical
external
contacted
old
stations
movement
contraction
pole
kryukova
akyildiz
callee
das
decrease
expansion
excludes
aggregate
bejerano
prakash
exclusions
asks
hierarchy
decides
rajagopalan
aggressiveness
personal
performing
default
message
notifications
register
service
database
reconfigure
profitable
decide
locality
communication
standards
hexagonal
urban
ip
sandeep
patterns
adapt
shrinking
simulation
expanding
contacts
serviced
notifies
hops
holes
belong
replication
gamma
pattern
wireless
informs
caller
reg
servers
caching
ff
services
initiating
overhead
subtract
expanded
requests
handles
periodically
networks
stabilize
additions
happens
network
tries
ffl
radius
balancing
tracking
simulations
equilibrium
fl
incoming
multiplicity
sent
direcytedhand
outgo
mssk
varsamopoulos
vmr
badrinath
registrars
lizes
perfoms
massingill
mscs
overlaping
inter ra
intra ra
ra k
moves k
registration area
ra calls
call delivery
registration areas
location management
c intra
ra handoffs
cost ex
ra moves
call deliveries
calls k
hand offs
c inter
k moves
cv c
core cell
core cells
gammamove gammanoncore
non core
ra call
gamma cost
reconfiguration period
gammacall gammanoncore
intra gammacall
ra hand
ra handoff
intra gammamove
ex k
n calls
candidate cell
gammacall gammacore
inter gammaoutgoing
location registrar
mss k
mobile terminal
cost inter
inter gammaincoming
cost intra
mobility pattern
pcs networks
candidate cells
gammanoncore gammanoncore
lr db
gammacore c
gammamove gammacore
k cost
load k
signaling load
gammanoncore gammacore
increase inter
base station
increase intra
signaling cost
call patterns
another cell
gammacore 2ffi
boundary k
home location
decrease inter
new vlr
external cell
k signaling
ffi vv
n moves
cell c
mobile users
mobile service
performing inter
ff v
cell d
proposed scheme
gammaoutgoing gammacall
cost updates
dynamically adapting
gammanoncore 2ffi
users registered
gammaincoming gammacall
location register
called mt
old vlr
management strategy
updates searches
mhs registered
two msss
exclusion notif
call pattern
inclusion notif
gammaoutgoing gammamove
ra m
part shows
current load
cell cost
cell j
new ra
mobility patterns
management schemes
new cell
inter ra calls
ra moves k
inter ra handoffs
registered with ra
intra ra calls
ra calls k
moves k moves
k moves k
inter ra moves
c intra gammamove
gamma cost ex
cost ex k
c intra gammacall
inter ra call
cost in k
cost in gamma
mobility and call
c inter gammaoutgoing
c inter gammaincoming
intra ra moves
k a increase
cv c intra
cost intra ra
intra gammamove gammanoncore
cost inter ra
increase inter ra
ra hand offs
updates and searches
increase intra ra
gammacore 2ffi cv
degree of overlapping
intra ra handoffs
performing inter ra
inter ra handoff
non core cell
intra gammacall gammanoncore
k i c
cv c inter
ra call deliveries
decrease inter ra
inter ra hand
ra call delivery
k in cell
cost for performing
deliveries and hand
intra ra handoff
update and search
load for performing
inter gammaoutgoing gammamove
intra ra hand
gammanoncore 2ffi cv
cost updates searches
cell to another
cells of ra
inter gammaoutgoing gammacall
intra gammacall gammacore
home location registrar
gammamove gammanoncore gammacore
cost of intra
inter gammaincoming gammacall
values of call
k a gamma
cost of inter
k signaling load
location management schemes
inclusion and exclusion
number of inter
k a k
different cost depending
gammacall gammanoncore gammanoncore
exclude a candidate
m and call
cost in cost
search lr db
handoff takes place
gammacore c inter
users of k
dynamically adapting registration
gammaincoming gammamove gammacore
inter gammaincoming gammamove
call delivery inter
mobility pattern m
period the lr
gammamove gammanoncore gammanoncore
call and move

corpus/krapavin2000-test/1040296.txt
typecase
coercions
int
labels
label
polymorphism
coercion
eq
polymorphic
polytypic
bool
branches
ls
constructor
haskell
setcase
tostring
branch
hoc
polykinded
generativity
coerce
coercing
directed
head
generative
ad
subcomponents
nominal
constructors
fst
extensible
core
calculus
map
language
judgment
lindex
datatypes
jones
maps
intensional
names
kind
programmer
marshalling
statically
structural
isomorphisms
semantics
harper
reflexivity
rossberg
unanalyzable
generic
equality
programmers
kinds
di
ml
boilerplate
abstractions
primitive
annotated
hinze
operationally
equivalences
forms
syntactic
arguments
distinctions
peyton
coerced
snd
abstracts
expressiveness
operational
erently
argument
abstraction
newtypes
trifonov
functorial
typed
erased
compile
record
integers
expressions
universe
judgments
booleans
sugar
weirich
analyzable
charity
scrap
distinguished
singleton
fix
inr
instantiated
erent
weak
treat
annotation
wished
morrisett
destroys
reflexive
isomorphic
closed
quantified
syntax
records
tos
fish
folds
vars
analyzed
constants
dynamically
pressions
poly
loading
matched
annotate
parametrically
checks
operator
lists
ect
phone
formed
list
traversals
stuck
languages
conservatively
compilation
universal
rule
normal
overloading
xml
er
scope
parametric
calculi
determines
extensions
expressible
ex
instantiate
portland
open
sound
fee
hide
oregon
interpretation
definer
extensionality
idioms
destructs
cata
deconstructing
rializer
tycon
polyp
sider
hindering
eqint
gleton
existen
tensible
billings
elides
glew
saha
tials
settostring
dered
rok
washburn
uncoercions
leifer
rebuilds
strnia
shinwell
polytypism
stylized
mapcase
type directed
type analysis
label set
order coercions
directed operations
new types
higher order
hoc polymorphism
order coercion
new label
defined types
generative types
l language
label sets
new labels
ad hoc
core l
type constructor
directed operation
directed programming
new names
weak head
class maps
user defined
labels l
type argument
type level
run time
first class
l e
head normal
int bool
polykinded types
int int
type information
order analysis
generic haskell
list int
normal form
type variables
intensional type
finite maps
type isomorphisms
type names
fst x
l label
matching branch
y list
instance eq
polymorphic equality
primitive coercions
polymorphic operations
type constants
full reflexivity
l l1
typecase int
map e
time type
polytypic operations
core language
e l
new type
structural analysis
type constructors
dynamic type
type classes
type variable
fully reflexive
analysis operator
type generativity
x list
set polymorphism
poly terms
label therefore
kind polymorphic
analyzed type
order type
type functions
bool int
nominal analysis
distinguished labels
matched label
finite map
l includes
variant types
l l
e e
type check
source language
first order
quantified type
type arguments
full language
polymorphic function
type directed operations
higher order coercions
ad hoc polymorphism
user defined types
set of labels
type directed programming
type directed operation
first class maps
higher order coercion
labels that may
weak head normal
forms of ad
head normal form
time type analysis
intensional type analysis
run time type
operations are defined
appear in types
higher order analysis
new in e
run time analysis
first order coercion
define a language
label set polymorphism
types of expressions
closed to extension
type level analysis
record and variant
e e l
higher order type
core l language
structure of types
l e e
finite type maps
types are equivalent
type directed function
fst x fst
e l label
eq a eq
x int bool
ad hoc operation
analyzed by typecase
types are designed
label set analysis
y list all2
typecase int bool
dynamic type analysis
label and label
first class map
bool s l0
l l1 l2
ad hoc polymorphic
language the generic
type of typecase
version of eq
matter what type
extensible generic functions
list all2 eq
types we use
int bool int
rightmost matching branch
appropriate source language
semantics of typecase
matched label therefore
typecase the full
new types without
kinds for label
first order coercions
labels of higher

corpus/krapavin2000-test/636260.txt
snf
coecients
nonlinear
unfolding
kth
cnf
cnfs
normal
perturbation
maple
singularity
dy
rescaling
dt
simplied
equations
transformation
coecient
takens
nd
algebraic
dierential
simplest
dx
ecient
frechet
bracket
nding
nt
singularities
recursive
forms
near
nth
identity
rst
homogeneous
snfs
hypernormal
retained
generic
polynomials
bogdanov
undetermined
dierentiation
equation
transformations
dierentiating
hopf
unnecessary
equilibrium
eliminated
complementary
jth
saves
bifurcation
lie
greatly
ij
aid
yuan
symbolic
preprint
derivative
eort
formula
jacobian
repeatly
efcient
rescal
dxf
paid
algebra
eld
taylor
remove
simplify
bifurcations
pursuit
lx
reduction
poincare
lined
resonance
transfor
duced
codimension
dropped
belonging
row
differential
degeneracies
dh
equilibria
grading
diagonally
analytic
nal
pei
eliminate
operator
aects
downwards
complicated
lows
vector
stability
equa
nserc
jordan
hamiltonian
plus
tations
ago
compu
eral
arranging
substituting
instability
matrix
listed
vicinity
putation
fol
dene
elsevier
credit
mation
imaginary
particularly
author
expansions
expansion
conventional
box
qualitatively
ascending
eigenvalue
eigenvalues
traced
council
reversed
illustrative
tm
dynamical
spanned
summarizing
nn
explicit
tables
normalizing
attention
hundred
vii
substitute
ing
yields
follow
tem
researchers
gen
leading
subscripts
implying
formulations
split
unlike
continued
transform
consistent
expand
extremely
identically
coded
planar
triple
pc
continuing
multiplied
involve
secondly
employing
expanded
submitted
continue
involved
employs
solving
yu
nonlinear transformation
normal form
kth order
form theory
near identity
perturbation parameters
normal forms
order equations
zero singularity
order terms
simplest normal
reduced system
algebraic equations
single zero
dy d
order equation
system 20
generic case
dx dt
coecients h
order nonlinear
nonlinear transformations
order normal
k y
unnecessary coecients
dy dt
identity nonlinear
non generic
cnf theory
order algebraic
vector homogeneous
identity transformation
original system
computer memory
higher order
system 1
recursive formula
maple program
nonlinear terms
complementary space
snf without
g k
homogeneous polynomials
without unfolding
nth order
lower order
equation 29
r k
computer algebra
frechet derivative
linear part
kth degree
greatly saves
lie bracket
unique normal
perturbation parameter
nonlinear vector
h 2j
three coecients
dt dy
nt coecients
form terms
computational time
state variable
two coecients
degree vector
simplied way
h k
algebra system
h l
g see
rst equation
g 2
equation 20
dierential equations
equation 17
space r
k k
takens normal
using maple
saves computational
leading non
vector unique
second algebraic
empty box
h 11
computation eort
lie transform
jth order
consistent nonlinear
apply normal
explicit expressions
parameters unfolding
particular advantage
part belonging
coecients zero
conventional normal
contain perturbation
undetermined coecients
simplied however
nal snf
snf however
normal form theory
computing the snf
single zero singularity
snf of system
kth order equation
simplest normal forms
coecients of h
near identity transformation
order normal form
near identity nonlinear
order algebraic equations
compute the snf
kth order terms
snf with unfolding
equation of 18
vector homogeneous polynomials
order nonlinear terms
simplest normal form
time and computer
non generic case
g k y
higher order terms
kth order equations
normal form terms
kth order normal
given by dy
snf of systems
h k y
coecients h 2j
computation of normal
rescaling on time
f k x
assume a 11
snf without unfolding
coecients t 1j
higher order normal
systems with perturbation
degree vector homogeneous
nd the form
kth order algebraic
higher order equations
kth order nonlinear
idea of normal
space r k
must be retained
computer algebra system
e g see
dy dt dy
reduced system 23
vector eld f
contain the kth
dt dy dt
fact the coecients
recursive formula 11
dierentiating equation 8
thus the snf
resulting normal form
uses a consistent
many higher order
identity nonlinear transformations
leading non zero

corpus/krapavin2000-test/636409.txt
elementary
grzegorczyk
analog
reals
gn
dierential
computable
gpac
dened
hierarchy
exp
dene
elementarily
proposition
integration
recursive
dynamical
en
denition
composition
primitive
xed
flix
shannon
computability
continuous
subclasses
discretization
costa
growth
functionals
equations
jy
recursion
bournez
nli
mycka
subtraction
iterated
nth
projections
sums
extensions
functional
jerzy
closed
dierentiable
bss
rational
products
arithmetical
turing
rst
successor
jos
ka
belongs
subrecursive
lacombe
tortoise
campagnolo
heaviside
hainry
nite
integers
oracles
bounded
valued
achilles
kalmar
shafts
integra
euler
numerical
xn
tj
kh
differential
cut
homogeneous
inequalities
pour
analyser
idealization
gh
norm
arity
neural
recognizers
classical
satises
sin
emmanuel
factorial
constants
denable
climbing
technological
integer
oracle
bk
partly
innite
exponentiation
iteration
subclass
olivier
closure
exponential
operator
compositions
moore
jxj
manuel
digital
extension
su
product
nd
levels
inversely
multiplication
molly
rill
straties
integrators
mathemat
dierentially
funtion
rubel
metamathematical
kerry
transnite
lord
discreteness
jsin
trautteur
fcul
unphysical
danner
labmac
kathleen
skepticism
sylvestre
tary
gakwaya
acumulated
fct
modelos
vannevar
completness
praxis
gear
ojakian
shub
jcos
spootie
arquitecturas
lipshitz
netwoks
guglielmo
flad
grzegorczyk hierarchy
elementary functions
dierential equations
linear dierential
recursive functions
linear integration
analog computation
e n
bounded product
y 1
l k
primitive recursive
en 1
bounded sums
elementarily computable
elementary functional
proposition 4
continuous time
xed k
analog class
analog computer
bounded sum
dynamical systems
non linear
elementary function
exp n
real functions
contains extensions
nth level
purpose analog
o subtraction
iterated exponential
h x
f x
jy 1
y 2
e c
function f
initial condition
basic functions
recursion theory
exp m
flix costa
analog computers
gn contains
discretization error
jos flix
cut o
computable functions
equation 15
initial functions
dierential equation
proposition 5
valued functions
functions computable
constants 0
real function
continuous real
gn k
basic function
classical recursion
zero successor
jerzy mycka
dierentiable way
using composition
class l
continuous dynamical
bounded products
mycka jos
integer closest
dene h
forming bounded
computation theory
n computable
y h
recursive function
time computation
unique solutions
function theory
elementary time
theoretical computer
step function
hierarchy e
certain kind
linear differential
xn 1
x z
n 3
proposition 2
xed m
exp d
given f
primitive recursion
linear dierential equations
primitive recursive functions
non linear dierential
n 3 non
general purpose analog
purpose analog computer
cut o subtraction
xed k 2
f and g
proposition 4 3
belongs to l
jos flix costa
y h x
continuous time computation
constants 0 1
set of functions
proposition 4 4
sums and products
closed under composition
belongs to gn
reals of en
closed under bounded
jerzy mycka jos
therefore we claim
allowed to solve
ka t k
continuous real function
closed under iteration
jy 1 n
grzegorczyk hierarchy e
continuous dynamical systems
forming bounded sums
gn contains extensions
mycka jos flix
computable in e
composition and linear
e n computable
shannon s general
growth of functions
classical recursion theory
euler s method
version of shannon
set of oracles
exp n 1
hierarchy e n
functions in gn
sums and bounded
f is elementary
show that gn
theoretical computer science
proposition 2 1
functions of several
f 2 e
highly non linear
recursive function theory
k is closed
x t k
proposition 3 1
model of computation
linear differential equations
journal of complexity
functions in l
computer science v
dene a function
function f 2
proposition 5 3
y f x
x z y
class of functions
computation dynamical recognizers

corpus/krapavin2000-test/627813.txt
propagation
schema
print
document
dictionary
wrapper
trip
refinement
behavioral
reprogramming
itinerary
directive
void
daytrip
ff
alternation
reuse
pattern
patterns
adaptiveness
pd
demeter
doc
prefix
annotation
fi
polymorphic
date
annotations
departure
oriented
printing
fragments
page
hooks
suffix
operational
reachable
specifications
wrappers
database
object
vertex
annotate
evolution
ffi
fg
arrival
specification
modifications
binding
directives
legal
scope
body
bypassing
seamless
modification
fl
reused
itineraries
ident
daytrips
structural
ma
sig
mechanisms
pp
pages
clause
vertices
ps
queries
polymorphism
manually
ea
promotes
compatible
compatibility
nextloc
eachloc
locationlist
article
query
title
classes
locations
encourage
signature
reusability
refined
abstraction
avoided
oql
incremental
traversed
adaptation
schemas
cooperating
gamma
text
syntactically
programs
navigational
checker
semantics
nextday
daytriplist
seamlessness
lpa
eachday
writers
ec
prints
contracts
activity
string
consistency
hk
character
inheritance
designers
proposition
avoiding
invalid
edges
objects
injected
travel
affiliate
scopes
propagations
location
city
iff
differently
specialized
anticipation
suf
rip
hook
content
code
salient
identifies
modified
robustness
triple
compile
reusable
repetition
effort
adaptive
attached
seamlessly
specifying
old
tm
persistent
transitivity
enhancing
languages
verified
reorganization
contract
mechanism
day
interface
executed
paths
conformance
formal
concept
raising
semantically
writing
emphasizes
visited
argue
nonempty
ling
traversal
minimized
restructuring
redefine
target
dbms
agency
path
motivating
alberta
requirement
frontiers
propagation pattern
propagation patterns
class dictionary
dictionary graph
pattern refinement
print document
behavioral refinement
pattern print
propagation directive
pattern ff
object oriented
schema modifications
schema modification
doc body
reuse mechanisms
propagation scope
print itinerary
schema evolution
polymorphic reuse
g print
class vertex
oriented database
pattern fi
method annotations
alternation reachable
pattern defined
application programs
propagation time
gamma w
requirement changes
operational requirement
trip schema
propagation constraints
operation void
refinement mechanism
directive refinement
class structure
given propagation
sig m
wrapper order
pd ff
schema changes
dictionary graphs
refined propagation
using propagation
code fragments
construction reachable
void print
ps ff
ma ff
class schema
signature refinement
document schema
propagation directives
m fi
m ff
u gamma
ffi 1
demeter system
incremental design
behavioral abstraction
pp refinement
existing propagation
pages page
oriented schema
activity model
operational specifications
manually reprogramming
trip object
database specifications
propagation constraint
date g
modified schema
ma fi
ffi 2
u 0
definition 3
queries due
departure arrival
method interface
definition 11
vertex u
trip location
prefix date
towards schema
suffix wrapper
printing trip
propagation paths
pattern given
target vertices
legal path
construction edges
method print
operation propagation
print article
database programs
trip itineraries
component pages
detailed itinerary
location departure
alternation edges
body components
print figure
document doc
prefix wrapper
pd fi
body doc
time trip
print detailed
v gamma
code generated
u v
path expressions
program adaptation
query specifications
consistency checker
class dictionary graph
propagation pattern refinement
propagation pattern print
refinement of propagation
propagation pattern ff
pattern print document
object oriented database
polymorphic reuse mechanisms
methods and queries
due to schema
propagation pattern defined
propagation directive refinement
propagation pattern fi
defined in figure
concept of propagation
using propagation patterns
schema of figure
class dictionary graphs
refined propagation pattern
schema in figure
pattern print itinerary
operation void print
avoiding or minimizing
reprogramming of methods
operational requirement changes
definition 3 ii
object oriented schema
existing propagation patterns
methods to classes
patterns and propagation
print detailed itinerary
set of propagation
doc body components
document doc body
v gamma w
prefix date g
u is executed
u gamma w
printing trip itineraries
g print figure
date g print
wrapper of v
oriented database specifications
mechanism for propagation
defined over g
classes at propagation
propagation pattern given
component pages page
body doc body
time trip location
wrapper of u
path from document
location departure arrival
given propagation pattern
doc body doc
according to definition
oriented database system
existing object oriented
set of class
object oriented systems
void this g_print
d doc body
void city print_itinerary
behavioral refinement mechanism
refinement ff fi
daytrip prefix date
void locationlist_iterator nextloc
trip print_itinerary departure
reference object model
number location departure
ff sig m
u is alternation
specification of propagation
graph of schema
given class dictionary
m ff sig
schema and thus

corpus/krapavin2000-test/1032502.txt
stc
cache
htc
fetch
instructions
instruction
trace
branch
cfa
miss
branches
xblast
codes
traces
blocks
postgres
fipa
misprediction
btb
subroutine
apsi
reordering
sequentiality
ijpeg
layout
core
fetched
josep
torrellas
vortex
workloads
exec
reordered
fipc
postgresql
mgrid
breaks
block
profile
popular
gcc
seed
predictor
reorder
bb
pettis
branchrep
execrep
unconditional
locality
indirect
misses
code
benchmark
caches
threshold
loops
rate
sequences
hardware
conditional
alone
arcade
cpa
benchmarks
seeds
cycle
buffer
contiguous
executed
inlining
percentage
consecutive
ras
perl
transitions
prediction
optimizations
aggressive
loop
fpppp
applu
pey
larriba
superscalars
irez
gag
compile
pc
thresholds
target
hansen
base
training
secondary
compress
fp
pq
predicted
break
fill
unused
fetching
proportion
breaking
mispredictions
bench
spec
unit
width
replication
discarded
references
coloring
targets
replicated
workload
crossing
reserved
processor
wasting
pen
len
calls
jumps
cycles
unrolling
floating
penalty
bp
barely
jump
interleaved
fall
transfers
offered
meanwhile
chains
conflicts
outgoing
layouts
seq
raising
speculative
collapsing
hit
reductions
optimize
penalties
decode
offer
behave
trying
stops
temporal
double
mapping
address
software
frequently
weight
throughput
optimizes
simulation
frequent
determinism
outcomes
stream
passes
alex
mispr
ecuted
aptind
xavi
basic blocks
fetch unit
trace cache
basic block
cache miss
instruction cache
miss rate
core fetch
base 7
base 6
sequence breaks
branch misprediction
software trace
instruction fetch
conditional branches
instructions per
per access
branch threshold
code reordering
subroutine calls
branch prediction
code layout
integer codes
branch predictor
htc alone
popular traces
useful instructions
hardware trace
pc relative
cfa size
per cycle
better results
cache lines
taken branches
code sequences
execution path
large codes
misprediction rate
exec threshold
codes like
code sequentiality
fill buffer
fetch mechanism
double size
fetched instructions
performance limit
loop basic
prediction accuracy
cache line
code replication
unconditional branches
consecutive instructions
profile information
execution sequences
instructions executed
memory positions
reordering technique
pettis hansen
fetched ffl
loop branches
sequential fetch
subroutine call
cache htc
size alone
predictor throughput
reordered code
unused basic
fixed way
small htc
popular sequences
trace building
indirect jumps
dynamic references
base 11
block transitions
address cache
execution core
fixed behavior
base 13
branch address
consecutive basic
blocks executed
cache stc
execution paths
fetch address
high instruction
rate reduction
josep torrellas
fetch performance
cache misses
sequentially executed
cache miss rate
core fetch unit
software trace cache
instruction cache miss
hardware trace cache
similar or better
branch prediction accuracy
fetched instructions per
cache t cache
instructions per access
loop basic blocks
branch misprediction rate
number of fetched
instructions per cycle
number of instructions
consecutive basic blocks
branch address cache
cache i cache
double size alone
miss rate reduction
percentage of sequence
break the execution
basic blocks executed
branch predictor throughput
running the training
unused basic blocks
htc of double
basic block transitions
code reordering technique
percentage of basic
trace cache htc
consecutive instructions executed
sequential fetch unit
trace cache stc
sequences of basic
basic block size
instruction cache misses
number of useful
number of consecutive
basic block reordering
breaks seq len
start a secondary
sequence breaking bb
per cycle obtained
pc relative unconditional
base 11 7
sequentially executed basic
instruction cache hit
cache line coloring
torrellas et al
floating point codes
main execution path
number of sequence
reorder the basic
access we also

corpus/krapavin2000-test/628217.txt
ttl
adns
heterogeneity
web
hit
requests
server
client
overloaded
prr
load
request
rr
policies
utilization
dns
hits
sensitivity
servers
dispatching
heterogeneous
capacities
varttl
drr
capacity
scheduling
alarm
cgi
site
zipf
domains
node
adaptive
ip
dispatcher
mrl
dierent
clients
hostname
probabilistic
policy
hot
dal
address
schemes
overloading
tier
cumulative
unevenly
alarms
coming
name
rates
skew
robin
strategies
collector
http
routing
resolution
gateways
seconds
uneven
url
session
aected
rate
period
cooperative
reaching
monitor
assignment
specically
scheduler
page
req
homogeneous
prob
deterministic
workload
www
hetero
geneity
frequency
residual
gure
feedback
hidden
bin
mapping
rst
threshold
round
estimation
perturbation
nodes
tra
arrivals
authoritative
internet
conguration
modication
weight
aects
domain
mechanisms
rewalls
logle
alteon
tilization
heaviest
systemmaxu
instant
selector
xed
caching
service
risks
overload
proximity
switch
arrival
default
levels
sites
cluster
popular
pure
percentage
busiest
disciplines
axis
sharing
accumulated
geographical
eectively
uniform
partition
skews
tracks
metrics
aect
visible
oered
eect
cached
originated
xes
loaded
condence
daemon
inadequate
dierence
dynamically
kwok
watson
rob
controls
distributions
assign
besides
scenarios
xing
geographically
jdj
imbalance
adopted
centralized
ve
utilized
robustness
normal
browsers
utilizations
org
addresses
versions
arriving
max
selects
bursts
schedulers
percentile
interval
excludes
fraction
probability
modications
proportional
ttl value
web server
server system
adaptive ttl
constant ttl
heterogeneity level
hit rate
domain hit
name servers
ttl k
ttl schemes
distributed web
ttl values
ttl algorithms
node heterogeneity
address mapping
hit rates
web site
system heterogeneity
web node
web nodes
load weight
ttl 2
maximum utilization
system maximum
ip address
hidden load
variable ttl
address resolution
client requests
node capacities
address request
cumulative frequency
probabilistic routing
overloaded nodes
th domain
adns control
hits per
heterogeneity levels
adns scheduling
domain partition
hot domains
server systems
requests coming
minimum ttl
frequency system
relative capacity
mean ttl
ttl policies
tier domain
client distribution
system max
heterogeneous nodes
two tier
page requests
global scheduling
node capacity
max utilization
k schemes
domain load
ttl period
web switch
dns based
non cooperative
node selection
client request
name server
heterogeneous web
pure zipf
round robin
cooperative name
feedback alarm
address caching
dierent ttl
resolution request
cgi req
address requests
adns algorithm
page request
ttl interval
adns scheduler
algorithms heterogeneity
requests reaching
average ttl
estimation error
service time
scheduling algorithms
web page
load sharing
non uniform
unevenly distributed
limited control
homogeneous web
system capacity
avoid overloading
client domain
request counter
exponential mean
mapping requests
hit service
dispatching algorithms
www http
ttl base
load monitor
connected domain
conguration information
normal domains
dynamic ttl
restricted rr2
web cluster
class threshold
probabilistic versions
client domains
overloaded level
cgi type
request assignment
load collector
scheduling policies
perform better
two classes
web server system
ttl s k
distributed web server
domain hit rate
adaptive ttl schemes
system maximum utilization
hidden load weight
adaptive ttl algorithms
ttl s 2
prob not overloaded
web server systems
domain hit rates
j th domain
tier domain partition
cumulative frequency system
system max utilization
two tier domain
constant ttl algorithms
frequency system max
number of hits
heterogeneous web server
minimum ttl value
reaching the web
cooperative name servers
non cooperative name
algorithms heterogeneity level
homogeneous web server
address resolution request
level of 20
sensitivity to system
web page requests
number of overloaded
hit service time
domain load collector
www http www
popular web sites
hits per second
zipf s distribution
among the domains
domain name server
constant ttl schemes
sensitivity to ttl
adns scheduling algorithms
adaptive ttl policies
k and ttl
levels of node
node is overloaded
dierent ttl value
http www http
ttl k schemes
inadequate to address
state and conguration
ttl 2 algorithms
ttl k algorithms
address both node
mean ttl value
least loaded server
address mapping requests
hits per page
ttl node capacities
dynamic ttl schemes
overloaded level figure
ttl variable ttl

corpus/krapavin2000-test/627189.txt
primitive
garbage
symbolic
milliseconds
calculated
reversal
conditionals
cache
ecient
optimizations
recursions
nontermination
inputs
eciently
sort
heap
eects
cbleast
transformations
accurate
bounds
unknown
chez
alpa
insertion
underestimation
ca
programs
measured
loops
yanhong
accurately
symbolically
worst
allocated
merge
automatic
append
rosendahl
cleast
car
else
transformation
program
partially
summations
analyses
constructor
cons
paths
lifting
constructors
disabled
timing
enabled
loop
compiler
inx
synthesizer
language
sums
conditional
inlining
languages
branches
arguments
dierent
measurements
pipelining
bindings
incremental
terminate
counts
recursive
xxxxxx
ibonacci
vcbleast
incrementalization
varref
rst
depths
simplifying
analyzing
instruction
functional
inability
calls
bytes
liu
transformed
stony
sunysb
brook
recurses
conservatively
live
dicult
source
merging
subcomputation
ssl
lub
stoller
binding
union
lisp
measuring
optimizing
inecient
structs
ultra
annotations
collection
terminates
cdr
app
nonrecursive
meant
inaccurate
branch
conservative
optimized
sorting
evaluator
microseconds
syntax
automatically
tried
calculate
caching
accuracy
constructs
accommodate
schema
nil
cost bound
primitive cost
bound function
cost parameters
symbolic evaluation
bound functions
cost bounds
input size
bound analysis
known input
calculated time
partially known
garbage collection
calculated measured
time milliseconds
milliseconds input
size parameters
input structures
heap space
insertion sort
accurate cost
ca calculated
measured worst
original program
loop bounds
execution paths
worst case
collection times
cache enabled
list reversal
selection sort
cost function
language based
direct evaluation
set union
reversal w
collection time
sort calculated
space bounds
direct symbolic
time bound
merge sort
partial evaluation
cost parameter
case times
union list
measuring primitive
sort selection
merging paths
symbolic direct
cache disabled
evaluation takes
source program
cost analysis
variable reference
incremental computation
time analysis
closed forms
function calls
resulting function
ca 50
size calculated
constructing cost
simplifying conditionals
lifting conditions
chez scheme
approximate time
reversal reversal
w append
include garbage
cost functions
measured time
primitive operation
sort merge
actual running
example programs
given values
input structure
program analysis
function terminates
dierent operations
small inputs
sort set
synthesizer generator
system alpa
size insertion
paths automatically
value unknown
recursion depths
bytes allocated
accurate conservative
optimized symbolic
input sizes
else e
bounds automatically
cache eects
measured conservatively
level languages
source level
language level
language implementation
complexity analysis
source programs
source language
case execution
recursive function
resulting cost
symbol c
algorithm analysis
car x
space allocated
sizes 10
e 1
analysis results
cost bound function
primitive cost parameters
cost bound functions
partially known input
input size parameters
milliseconds input size
measured me ca
time milliseconds input
known input structures
calculated time milliseconds
cost bound analysis
ca calculated measured
measured worst case
else if v
garbage collection times
primitive cost parameter
time bound analysis
accurate cost bound
sort calculated time
garbage collection time
worst case times
methods and techniques
analysis and transformation
direct symbolic direct
insertion sort selection
v then e
symbolic direct symbolic
language based approach
sort merge sort
analysis with cache
inputs of sizes
measuring primitive cost
set union list
selection sort merge
sort selection sort
allocated for constructors
union list reversal
reversal w append
inputs of size
calculated and measured
source language level
bounds or execution
values of input
list reversal reversal
size calculated measured
include garbage collection
reversal reversal w
yanhong a liu
input of size
time or space
high level languages
dierent operations performed
execution paths automatically
conservative or approximate
prototype system alpa
optimized symbolic evaluation
subset of scheme
accurate cost bounds
e 2 end
automatic and accurate
heap space allocated
sort set union
merge sort set
conservatively or approximately
consists of transformations
e 1 else
machine with cache
programs on inputs
known input structure
might not terminate
symbolic evaluation takes
values of primitive
automatically and accurately
else e 2
evaluation and optimizations
size insertion sort
eciently and accurately
worst case execution
terms of primitive
analyses and transformations
evaluation of cost
time and space
takes as arguments
number of experiments
number of bytes

corpus/krapavin2000-test/608323.txt
lopt
centres
cls
mwp
pmp
alt
centre
dec
entities
ssc
subproblems
subproblem
mladenovic
weber
entity
median
rvns
malt
dissimilarity
mwpm
optimum
quality
switzerland
allocated
hansen
cent
brimberg
allocation
cities
clustering
instances
diminishes
vehicle
rosing
depot
beasley
vns
location
cooper
taillard
centroid
solutions
decomposition
dissimilarities
optimally
haca
vnss
glover
heuristic
greedy
solving
allocate
succeeded
proportion
solved
sg
unused
neighbourhood
routing
sparc
euclidean
facility
airports
brim
bongartz
weiszfeld
jura
revelle
mwps
cantons
lakes
candidate
perturbation
irregular
multisource
swiss
taboo
hartigan
procedures
clusters
repetitions
quick
nearest
bubble
berg
tabu
originate
opening
perturbed
weighted
performances
gravity
empirically
article
locating
sort
lake
serviced
seconds
deterministic
meta
policy
grows
averaged
improving
heuristics
distances
repeat
consuming
optimizes
multivariate
behaviour
weights
lem
workstation
improvements
estimated
position
prob
positions
fleischmann
dokmeci
ordez
improvedand
lequel
peeters
bhaskaran
murtagh
reinelt
mladenovi
niwattisyawong
schilling
wesolowsky
mirchandani
alt procedure
p median
dec 20
solution quality
computing time
entities allocated
location allocation
initial solution
computing times
candidate list
p centres
best solutions
dec lopt
mwp instances
o n
clustering problems
cls procedure
malt 100
dissimilarity measure
lopt 10
cls 1000
greedy procedure
centroid clustering
list search
solution values
good solutions
p increases
vehicle routing
best solution
median problem
routing problems
cooper 1963
per cent
weber problem
subproblems solved
nearest centre
r centres
solution known
problem instances
o p
step 2b
allocation procedure
multi depot
cls 100
pmp instances
brimberg et
source weber
search cls
p grows
solutions known
times seconds
lopt procedure
heuristic methods
dynamic programming
sub problems
multi source
local optimization
better solutions
step 2a
initial problem
sparc 10
decomposition methods
n p
quick sort
optimum number
deterministic procedure
facility location
solution value
relatively uniform
dec procedure
respective computing
step 3c
lopt diminishes
cls algorithm
p entities
taillard 1996
optimum location
perturbed solution
lopt method
hansen mladenovic
depot vehicle
cls dec
re location
quality time
beasley 1985
quality obtained
mwp solution
ssc mwp
number of centres
dec and lopt
dec 20 50
set of entities
p median problem
candidate list search
vehicle routing problems
values of p
centroid clustering problems
dec 20 200
diminishes as p
o n p
p a n
p of centres
complexity of dec
list search cls
best solutions known
obtained by dec
ssc and mwp
computing times seconds
brimberg et al
multi source weber
lopt 10 50
hansen and mladenovic
number of entities
best solution known
non deterministic procedure
number of subproblems
location allocation problem
multi depot vehicle
respective computing times
best solution values
depot vehicle routing
re location policy
succeeded in improving
decomposition of switzerland
complexity of lopt
originate from hansen
location allocation problems
alt and cls
p grows linearly
mladenovic and taillard
pmp and mwp
time s sparc
solution quality obtained
n p entities
o n 2
et al 1997
see e g
able to find
linearly with n
methods for large
o p 2
complexity of o
let us mention
lopt 7 50
instances with 50
time of dec
solutions of similar
mwp instances brd14051
solution quality provided

corpus/krapavin2000-test/620236.txt
scheduling
deadlines
precedence
tasks
deadline
lateness
multiprocessing
edf
preemption
schedule
preemptive
jobs
np
multiprocessor
priority
uni
overload
monotonic
resources
job
release
mok
anomalies
heuristics
static
resource
earliest
overloads
periodic
blocking
lawler
processor
processors
miodrag
potkonjak
nonpreemption
outtrees
baruah
intrees
bins
jackson
miss
scheduled
interchange
minimizing
schedulability
task
arrival
garey
scheduler
metrics
classical
packing
layland
llf
designer
bin
series
clairvoyant
laxity
preemptable
shared
completion
designers
optimality
baker
implications
preemptions
kuan
polynomial
inversion
schedules
wayne
forest
pcp
critical
implication
metric
dates
aperiodic
cessors
periods
exclusive
synthesis
ceiling
comp
richard
chang
ffl
blazewicz
edd
ddsched
mcnaughton
ruei
nonpreemptable
mall
anup
hamidzadeh
yacine
atif
ravindranath
hardness
meet
wolf
shih
successors
timing
johnson
babak
kernelized
intree
outtree
tardiness
bfd
late
policy
exclusion
smith
automation
hard
cumulative
multiprocessors
utilization
transformable
ffd
sha
srp
constraints
bhattacharjee
chuan
multitasking
preempt
rise
dynamic
worst
bf
pal
schedulable
alarms
priorities
admits
station
theorems
period
rate
sequencing
oct
commack
nova
string
minimize
multimedia
fit
capacity
blocked
publishers
graphs
permitted
forbidden
loads
anomaly
ting
sigops
avoided
shortest
aided
stack
graham
chemical
switches
locked
ada
lee
feasible
deadlocks
predecessors
protocol
mutually
robotics
arrivals
priori
lin
iri
situations
successor
proven
guaranteeing
chung
concurrency
wei
prevent
pessimistic
spring
pro
real time
time systems
precedence constraints
maximum lateness
multiprocessing scheduling
shared resources
rate monotonic
scheduling algorithm
uni processor
series parallel
scheduling problem
scheduling theory
static scheduling
release times
multiprocessor scheduling
line scheduling
time scheduling
dynamic scheduling
classical scheduling
non preemptive
general precedence
time tasks
np hard
z graph
deadline scheduling
earliest deadline
scheduling results
computation time
scheduling problems
np complete
preemptive model
parallel graph
schedule length
periodic tasks
precedence relation
monotonic algorithm
mok 24
priority inversion
scheduling algorithms
optimal schedule
parallel graphs
critical section
task set
precedence graph
partial order
overload conditions
precedence relations
deadline monotonic
miodrag potkonjak
single deadline
future release
string interchange
cumulative value
interchange relation
theory results
scheduling list
start times
computation times
hard real
theorem 4
resource constraints
unit computation
johnson 10
multiprocessor real
run time
completion times
decomposition tree
complete 2
edf scheduling
bin packing
classical results
among tasks
multiprocessing anomalies
kuan shih
arbitrary partial
baruah et
independent periodic
resources arbitrary
z graphs
preemptive multiprocessing
constraints shared
tasks miss
np comp
uni processors
wei kuan
systems designer
worst case
execution time
np hardness
optimal algorithms
arrival times
theorem 3
job j
problems ffl
static schedule
periodic processes
due date
monotonic scheduling
highest priority
pro cessors
first fit
without preemption
precedence constrained
real time systems
real time scheduling
classical scheduling theory
multiprocessor scheduling problem
set of tasks
earliest deadline scheduling
series parallel graph
real time tasks
series parallel graphs
sum of completion
hard real time
future release times
string interchange relation
richard s anomalies
jackson s rule
scheduling theory results
advantage to preemption
np complete 2
minimizing the maximum
time systems v
line scheduling algorithm
multiprocessor real time
problem with 2
unit computation time
scheduling of real
garey and johnson
number of bins
constraints shared resources
polynomial and np
tasks with precedence
baruah et al
static scheduling algorithm
scheduling problems ffl
general precedence constraints
time systems designer
wei kuan shih
boundary between polynomial
liu and layland
general precedence relation
precedence constraints shared
rate monotonic algorithm
arbitrary partial order
rate monotonic scheduling
evaluate the worst
resources arbitrary partial
smith s rule
complete 2 theorem
non preemptive model
miss its deadline
minimize the maximum
problem of scheduling
problems are np
minimizing the number
real time system
many real time
miss their deadlines
number of processors
real time computing
real time control
set of independent
ieee acm international
et al 3
optimal in many
lawler s algorithm
ffl to prevent
versus dynamic scheduling
rise to z
resources currently available
cumulative value achieved
used on line
time is np
minimizing maximum lateness
shortest processing time
tasks have deadlines
arbitrary release times
deterministic static scheduling
np are polynomial
important classical scheduling
ddsched a distributed
graph the algorithm
proven theorem 3
forest partial order
strings of jobs
transformable to r
interest to real
run time scheduler
system level synthesis
list is built
times precedence constraints
intrees or outtrees

corpus/krapavin2000-test/629124.txt
dunx
policy
page
numa
ss
migration
synth
coherency
workload
placement
replication
pages
uma
sp
migrations
freeze
policies
ro
migrate
ideal
remote
fault
analytic
predictions
defrost
references
static
bouncing
msort
replicate
bbn
rm
rc
window
cache
replications
reference
faults
multiprocessors
mig
mod
psolu
hough
mor
gauss
scanner
copy
shared
theta
multiprocessor
memory
daemons
freezing
completion
predicted
wrm
mandel
mva
interprocess
processor
race
management
microseconds
trigger
operating
settings
migrated
replicated
frozen
migrating
workloads
errors
decisions
rep
predicts
pr
experimental
virtual
coherence
assortment
read
kernel
fish
contention
frame
invalidation
architectural
confidence
factors
reevaluation
remotely
history
instances
os
architectures
varied
request
upsilon
effects
triggered
parameterized
controls
synthetic
activity
module
granularity
barriers
comprised
dynamic
wave
tuning
wait
degrades
tuned
platinum
bolosky
snooping
incorrect
consistency
servicing
costs
justify
hardware
recent
referenced
aging
fpr
fortunate
secs
replicating
ms
prob
plot
nine
encountered
barrier
spg
scanners
interconnection
measurements
seconds
validation
subtle
lw
invalidations
transitions
measured
differences
queue
plotted
versions
sharing
programmer
accurate
excessive
pursuing
bt
movement
modification
worse
opportunities
poor
ten
invalidated
implementable
bx
experimentation
five
lr
bm
count
program
contributing
simulates
nearly
transfer
interval
varying
questions
pivot
handler
invalidate
nonuniform
addressing
experimentally
adjusts
page placement
ideal policy
recent mod
freeze window
workload model
static policy
theta theta
dynamic page
r ss
coherency fault
copy page
numa memory
multiple copy
memory management
cache policy
sp pages
replication coherency
analytic model
numa static
page bouncing
error policy
page migration
input parameters
memory reference
bbn gp1000
rm pages
dynamic multiple
static page
operating system
page fault
dynamic policy
analytic predictions
dynamic placement
synth instances
page classes
shared memory
completion time
e sp
local remote
ss pages
workload 4
coherency faults
numa problem
k mig
w ss
placement activity
fault pairs
model predictions
experimental data
virtual memory
mean time
system kernel
synthetic program
w c
confidence interval
memory references
memory module
model experiments
uma dynamic
migration costs
dunx implementation
uma version
interprocess reference
rc migrations
policy decisions
numa version
k rep
phase transitions
remote architectures
uma static
reference history
placement policy
page replication
r ro
remote memory
local memory
r c
shared data
measured performance
experiments r
remote reference
instance 5
system model
mean number
q m
memory multiprocessors
measured completion
memory request
page errors
predicted data
workload 3
r sp
window parameter
policy errors
page scanner
numa versions
reference granularity
numa multiprocessor
write reference
mod parameter
dunx operating
ss values
copy policies
e ss
incorrect policy
dunx kernel
sp page
local frame
value analysis
single copy
data obtained
mean value
page faults
theta figure
parameter settings
static combination
placement policies
sp values
theta theta theta
dynamic page placement
copy page placement
multiple copy page
numa memory management
static page placement
replication coherency fault
ss and sp
dynamic multiple copy
migration and replication
coherency fault pairs
ss and w
number of references
operating system kernel
ro and rm
page placement policy
local remote architectures
model experiments r
mean value analysis
shared memory multiprocessors
r c w
comparison of experimental
freeze window parameter
migrate or replicate
experimental and predicted
dunx operating system
shared data pages
recent mod parameter
read only fashion
uma and numa
theta theta figure
experimental data obtained
window is set
c r c
effectiveness of dynamic
c w c
triggered the fault
page placement policies
page placement activity
ss and wrm
uma dynamic combination
w ss values
policy design space
mean measured completion
dynamic policy points
software input parameters
class c r
ro rm ss
comparison of 8
results completion time
bound a 99
approximate mean value
sp and w
model input parameters
remote memory module
interprocess reference granularity
dynamic placement activity
fault that results
replication over migration
necessary to justify
approximate ideal policy
numa static combination
performance dynamic policy
hand tuned numa
numa shared memory
workload 4 model
result in performance
w sp values
migration or replication
single copy policies
number of migrations
time to actually
local and remote
memory and network

corpus/krapavin2000-test/609176.txt
retraction
cps
sps
lambda
transform
oe
joek
pi
app
typing
axioms
transforms
omega
monads
moggi
jmkae
typed
definable
continuation
ae
embedding
calculus
tg
provable
soundness
codomain
sequents
interpretation
denotational
style
interpretations
monadic
constants
equational
axiom
divergence
inference
untyped
wand
logic
pcf
recursive
equivalence
encap
caluclus
divergent
lemma
abs
gamma
joe
meyer
definitions
passing
pure
fij
fixpoint
closed
inductively
substitution
reasoning
inverse
language
sabry
retract
functional
implication
felleisen
semantics
ml
fs
sound
mutable
continuations
diverges
understood
says
equality
induction
modified
asserting
theorems
interfering
assertion
difficulty
membership
sketch
asserts
isolate
parameterized
notions
hyperdoctrines
diver
numerals
axions
aefv
overline
continutions
oef
metalanguage
crole
unrea
strachey
operators
equalities
interpret
discipline
recursion
equipped
hypothesis
mapping
extensions
programs
recovered
impure
discoveries
sonable
retractions
deltak
comprehending
viswanathan
queen
effortlessly
filinski
riecke
letrec
closure
imperative
letters
languages
effects
elementary
fill
var
motivate
typable
definability
singled
unjustified
andrzej
haven
fore
abstract
satisfies
affirmative
pitts
disambiguate
tuitively
gence
isolating
correspondence
contin
fj
monad
banach
axiomatization
typ
analogous
operator
truth
validity
preserves
stronger
mantics
xk
hypotheses
ku
reynolds
abbreviates
uation
seemed
act
computations
extend
constructs
picture
naval
retraction theorem
cps transform
lambda terms
computational transform
type oe
sps transform
r oe
modified computational
retraction embedding
type sets
terms r
sps transforms
term m
terms e
m pi
computational lambda
lambda calculus
r e
passing style
e oe
type system
type inference
lambda term
embedding pairs
define terms
constants e
soundness lemma
terms m
recursive type
r k
simple type
fixed point
equivalence classes
abstract transform
embedding pair
r app
computational effects
computational effect
conditions y
m oe
oe r
recursive types
continuation passing
c r
value v
definition 3
gamma x
closed term
oe n
denotational semantics
lemma 3
closed terms
c extended
point operator
oe 0
value evaluation
types oe
satisfies gamma
simple types
joe k
typing hypothesis
closed lambda
particular transform
joek fs
closure conditions
n pi
typing assertion
terms extended
retraction approach
joek r
e k
defined using
simply typed
oe m
term r
e r
x n
r exist
axiom r
every type
fs tg
equational correspondence
value pcf
r r
larger class
gamma m
k oe
compute r
let ae
omega gamma
x oe
e x
k instead
terms p
x m
oe x
modified computational transform
call by value
e and r
prove the retraction
transform t pi
logic of c
simple type oe
type oe r
retraction embedding pairs
c r e
r oe n
r r oe
e r app
retraction embedding pair
class of terms
classes of terms
computational lambda calculus
terms and types
fixed point operator
interpretation of types
continuation passing style
let x m
gamma m oe
terms to lambda
terms r oe
oe r oe
oe and e
ae x n
function s joek
define terms r
axioms of c
joek r r
joek fs tg
extend the retraction
transform we define
sound for call
lambda term r
lemma 3 10
x n pi
recursive type system
define the interpretation
interpretations of terms
r k oe
lambda terms m
extend the type
m of simple
type t oe
transform is defined
closed term m
interpretation of terms
terms of type
lemma 3 9
finally we define
call by name
m and n
y and z
transform we study
e x e
models of c
define the extended
transform of m
gamma x 1
pcf with assignment
two constants e
class of extensions
transforms as well
term m r
show s 1
r m pi
define the retraction
relation between direct

corpus/krapavin2000-test/608635.txt
commitment
commitments
agents
auctioneer
compliance
fish
multiagent
bidder
creditor
agent
debtor
metacommitments
discharge
protocols
bid
aamas
autonomous
protocol
causality
price
delegate
singh
munindar
bidders
mq
venkatraman
tex
messages
market
message
metacommitment
quasimodel
noncompliant
observer
money
coordination
yolum
release
cancel
parties
participating
ctl
commerce
violation
committed
yes
interactions
joint
party
announces
irrevocable
discharged
messaging
timestamp
temporal
reasoning
interaction
authority
social
web
sell
timestamps
skeleton
causal
netherlands
meanings
act
behaviors
mallya
takers
wronged
ashok
pathsae
pnar
pinar
supply
commit
electronic
ag
heterogeneity
abbreviation
phi
proposition
propositions
autonomy
events
event
ordinarily
guerin
sigecom
spoiled
entail
testing
actions
logics
gamma
assign
specifications
skeletons
commits
guilty
auctions
meaningfully
bologna
rationality
synthesizing
heterogeneous
received
pending
resolved
clock
bucket
feng
open
eventually
obeying
wan
meaning
pitt
blowup
specifi
tokens
behave
tells
checking
logic
proto
bnf
lowers
multiparty
tems
specification
intentions
comply
abbreviates
pool
customary
functioning
anyone
ultimately
fourth
create
monolithic
beliefs
resolves
specifying
jeremy
authenticated
iis
rational
observations
action
subtle
meta
designs
concrete
designers
manipulated
totally
community
reflecting
says
quantification
authentication
created
sys
executions
deals
inform
flexible
hagent
adver
pagespace
ordination
jure
fmessageg
systemic
pliance
justifiable
naur
afdom
conceptsae
interoperation
gq
rethinking
contractual
legitimizes
trueuq
sential
pathae
commitment protocols
multiagent systems
autonomous agents
commitment c
fish market
multiagent system
market protocol
aamas tex
tex 20
potential causality
p singh
munindar p
participating agents
venkatraman singh
local models
international joint
joint conference
v compliance
commitment protocol
agents may
base level
agent systems
model checking
says yes
compliance testing
systems july
agent communication
z c
fourth international
temporal logic
multi agent
action c
x c
open systems
global model
single message
electronic commerce
member agents
proposition meaning
message patterns
technical framework
discharge x
level commitments
feng wan
delegate x
testing compliance
bidder says
create x
protocol example
agents another
assign y
communication languages
message pattern
july 25
l gamma
g p
agents must
y z
distributed computing
message m
much attention
multi party
u mallya
patterns constructed
commitments proceedings
new creditor
level commitment
ordered communication
heterogeneous autonomous
via commitments
agents commitments
compliance checking
commitments among
using commitments
bidder b1
compliance with commitment
fish market protocol
aamas tex 20
tex 20 02
munindar p singh
conference on autonomous
operations on commitments
international joint conference
agents and multiagent
multi agent systems
multiagent systems july
systems july 25
fourth international joint
july 25 29
create x c
autonomy and heterogeneity
delegate x z
approach for testing
x z c
yes the auctioneer
bucket of fish
assign y z
delegate or assign
commitment to z
discharge the commitment
discharge x c
base level commitments
bidder says yes
y z c
agents and multi
agent systems v
agent communication languages
proof from theorem
hold and p
m i creates
c to z
c and message
meanings of formulas
feng wan munindar
q and abbreviates
debtor creditor context
given multiagent system
given state q
action c usually
c debtor creditor
causality and temporal
ashok u mallya
discharged if ag
wan munindar p
created or manipulated
q will eventually
one bidder says
open multiagent systems
compliance in open
observer s model
c discharge x
meaning the fish
yolum munindar p
c usually holds
whether the auctioneer
performed on c
reflecting the independence
auctioneer is noncompliant
compliance checking procedure
protocol our approach
j for price
creates commitment c
logics of program
heterogeneous autonomous agents
functioning of open
base level commitment
application of causality
market protocol example
bid is received
lowers the price

corpus/krapavin2000-test/606859.txt
differentiable
ncp
differentiability
differential
psi
phi
lipschitzian
complementarity
semismooth
burmeister
fischer
merit
matrices
differentials
nonsmooth
nonlinear
fx
stationary
gowda
bouligand
phijj
subdifferential
ravindran
thetan
nonnegative
subsequence
locally
matrix
frf
row
echet
co
optimality
jacobian
theorems
dg
variational
omega
diagonal
quadruples
componentwise
univalence
monotone
solves
regularity
frchet
convex
piecewise
newton
unconstrained
continuously
corollary
claim
penalized
clarification
rf
minimizer
nonzero
jz
contradiction
clarke
regular
ad
rn
fa
fr
remark
contradicting
proposition
valued
equivalence
lagrangian
strictly
converging
remarks
proves
superset
ft
min
formulating
calmness
defeng
solodov
semiconvex
eodory
carath
tawhid
lorentz
homeomorphisms
facchinei
index
ng
calculation
satisfying
inequalities
continuity
smooth
conversely
semicontinuous
versely
mangasarian
zeros
constrained
quasi
strict
soares
compact
minimizing
nonempty
recalled
relaxations
minimizers
semidefinite
gammaz
timization
lim
subcase
implication
injectivity
multivalued
hypotheses
ith
hadamard
referee
bx
separation
weaken
unify
jy
nonsingular
jong
bd
enjoy
mathematics
completes
applicable
baltimore
lg
subsequences
representative
pang
specializing
stated
ff
sun
contradict
jie
weakening
shi
md
abuse
fix
vectors
neighbourhood
convergent
characterizations
peng
methodologies
minimization
hx
fv
optimization
respec
regularization
algebraic
reformulation
prop
lems
tively
simplicity
hull
maryland
reversed
cg
carried
semi
fc
fy
affine
researchers
motivates
inequality
smoothing
implicit
oe
generalized
statements
dealt
func
consequences
h differential
h differentiable
h differentiability
ncp f
ncp function
r n
locally lipschitzian
fischer burmeister
p 0
row p
psi x
nonlinear complementarity
merit function
burmeister function
differentiable function
phi x
p matrix
fx k
f x
p matrices
differential given
x consists
p function
complementarity problems
h differentials
p property
solves ncp
differentiable functions
function phi
x solves
regular point
complementarity problem
stationary point
phi f
necessary optimality
diagonal matrices
j x
function f
theorems 6
sequence fx
stationary points
strictly regular
subsequence fx
phijj 2
c differentiable
bouligand subdifferential
ncp functions
psi 1jj
continuously differentiable
optimality condition
k j
two applications
x k
f r
k g
generalized jacobian
suppose 0
ad 0
echet differentiable
c differential
matrices satisfying
frf x
local global
nonsmooth functions
problem min
co e
fr echet
piecewise smooth
nonnegative diagonal
local optimal
j g
b f
local minimum
n thetan
x 2
fixed parameter
min f
every x
convex combination
second application
nonzero vector
x 6
suppose f
first application
contradiction since
w d
x g
stated equivalence
corresponding merit
fx dg
min function
lipschitzian function
ft k
differentiable at x
applications of h
differential of f
fischer burmeister function
p 0 property
f at x
consists of p
h differential given
h differentiable function
solves ncp f
p 0 p
row p 0
x solves ncp
differentiable function f
differentiability of f
f is h
nonlinear complementarity problem
row p property
f x consists
differential t x
ncp function phi
k j g
x 2 r
f r n
x and d
exist a subsequence
theorem is h
co t psi
h differentiable functions
necessary optimality condition
strictly regular point
x when arbitrary
gowda and ravindran
psi is h
fx k j
psi 1jj phijj
p 0 matrix
nonlinear complementarity problems
b f x
sequence fx k
fx k g
every x 2
v a w
exists an index
p 0 matrices
diagonal matrices satisfying
suppose f r
differential of phi
point of psi
quadruples a v
local optimal solution
ncp f proof
fr echet differentiable
suppose if possible
min f x
x are diagonal
nonnegative diagonal matrices
minimizing the merit
frf x g
show that phi
v w d
v and w
suppose that 0
x 6 0
x i 6
function f r
f x k
r n r

corpus/krapavin2000-test/628111.txt
lsh
hash
mh
negatives
positives
columns
hashing
similarity
sig
column
false
rows
min
association
mining
sun
jsig
bucket
cutoff
signature
estimator
fraction
pruning
candidates
sec
confidence
km
signatures
threshold
row
hamming
candidate
priori
basket
agree
ksm
counter
cohen
market
haim
pairs
rules
running
motwani
densities
biased
indyk
kaplan
edith
increments
sparse
histogram
news
articles
counters
amongst
peer
matrix
subtable
hashed
synthetic
scanning
varied
tuples
screened
jm
items
nearest
extremely
associations
jc
fiat
amos
recommender
url
extracted
directional
count
cheng
quality
permute
phase
density
locality
collision
attributes
identifying
curve
fc
dissimilar
sliding
filtering
increment
chess
devising
mk
ks
pass
discovery
collaborative
permutation
matrices
unbiased
indexes
sparsity
exceeding
disadvantage
phrases
buckets
documents
neighbor
jian
schemes
correlated
sensitive
brute
agrawal
highly
really
client
ip
clustering
decreases
causal
plot
reachability
cystic
masao
thetajc
darth
wingyan
fibrosis
satanic
bertolt
nakada
kjc
gras
hors
personalities
nostra
hirohito
stymied
diapers
soviet
kirpal
yishan
avant
beluga
brecht
meryl
ketel
oceania
ivanchuk
meseo
vader
feigenbaum
bucked
venkatasubramanian
misc
efjsig
subodh
dalai
cosa
caviar
krishnan
mardi
polger
presse
jatin
vodka
papier
yuko
agence
karpov
chhugani
lama
carinii
pneumocystis
streep
palshikar
oeuvres
ahad
hossain
timman
emperor
zahid
garde
cacm
objections
showcase
osana
discovered
min hash
hash values
false negatives
false positives
sun data
h lsh
k mh
m lsh
min hashing
column c
hash value
column pairs
c j
running time
k min
pairs found
columns c
data set
total running
found performance
column pair
association rules
negative threshold
similar columns
lsh algorithm
time sec
lsh m
mh h
priori algorithm
mh k
hash count
sec running
o km
two columns
low support
hashing scheme
high confidence
c m
total time
false negative
highly similar
similar pairs
mh algorithm
similarity cutoff
high support
support requirement
matrix m
vs false
similar column
biased estimator
k 500
sec sec
negatives mh
b fraction
f 80
single pass
matrix c
candidate generation
locality sensitive
sensitive hashing
high similarity
market basket
hash table
data mining
news articles
hashing schemes
synthetic data
counter increments
o ksm
ksm 2
client ip
lsh algorithms
lsh scheme
mh algorithms
o k
main memory
first row
h c
values extracted
sig j
edith cohen
k smallest
candidate pairs
support pruning
small hamming
haim kaplan
hamming distance
d figure
second phase
k rows
set k
association rule
j c
real data
collaborative filtering
l times
pruning phase
k sets
min hash values
number of false
sun data set
k min hash
pairs of columns
total running time
mh on sun
min hash value
pairs found performance
lsh on sun
fraction of pairs
sec running time
mh h lsh
mh k mh
min hashing scheme
k mh h
false negative threshold
time sec running
lsh m lsh
sig i j
total time sec
r and l
positives and false
number of rows
h lsh m
c j c
data set k
data set f
k min hashing
output and total
false negatives mh
pair of columns
set k 500
vs false negatives
quality of output
negatives mh k
set f 80
similar column pairs
locality sensitive hashing
c j 0
c d figure
c i c
k mh algorithms
similarity of column
o ksm 2
k mh algorithm
rules of interest
number of counter
hash values extracted
m lsh algorithm
small hamming distance
sec sec sec
probability that columns
h lsh algorithm
family of schemes
c i implies
mh and k
without any support
value of parameter
column c j
values in c
number of 1s
j c j
indyk and motwani
set of rows
m i 1
sets of attributes
k the number
number of columns
number of pairs
values of r
time sec false
amos fiat haim
o km 2
cohen amos fiat
j are identical
two columns c

corpus/krapavin2000-test/1015499.txt
bu
flows
tcp
router
er
ers
packets
lived
congestion
rtt
window
routers
tra
queue
link
ering
backbone
pkts
flow
packet
bursts
utilization
thumb
sawtooth
afct
wmax
burst
sizing
sender
bottleneck
synchronized
gsr
outstanding
bandwidth
linecard
overbu
dram
ect
sigcomm
ered
short
internet
sawtooths
pauses
trip
cisco
mb
avoidance
slow
buffer
erent
throughput
queueing
di
desynchronized
delay
simulations
buffers
fifo
doesn
today
links
synchronization
occupancy
aggregate
persuade
dynamics
busy
sram
underutilized
networking
nick
simulation
mckeown
windows
acks
mix
dropped
bw
drop
arrivals
evolution
tail
predicts
leith
mtu
util
sommers
barford
poisson
completion
erence
attacks
latency
congested
round
reno
goodput
job
measurements
ll
fairness
chips
pareto
trough
modem
dos
senders
network
sending
red
arrive
drops
lengths
mixes
manufacturers
lose
bytes
sure
ected
capacity
speeds
chip
ack
underflow
steadily
provisioning
pause
halved
ansnet
yashar
villamizar
drains
underflows
linecards
ganjali
propagation
shorten
rate
goes
net
cult
pins
timeouts
devices
halves
load
duffield
aimd
rtts
drams
joel
commercial
exp
carrying
fill
review
cascades
rfc
lockstep
outdated
card
networks
ram
gateways
amos
asics
gsm
mbit
topology
aggregated
complicates
loss
ton
telecommunications
idle
argue
board
oscillating
multiplexed
tailed
bu er
bu ers
er size
window size
long flows
tcp flows
short flows
router bu
long lived
bottleneck link
lived flows
rtt c
queue length
bu ering
tra c
tcp flow
access links
short lived
slow start
congestion control
lived tcp
er requirements
flow completion
goes empty
congestion window
many flows
congestion avoidance
m g
e ect
wmax 2
cisco gsr
required bu
bu ered
gsr 12410
smaller bu
pkts figure
minimum required
computer communication
acm sigcomm
communication review
sigcomm computer
round trip
backbone routers
outstanding packets
di erent
queueing delay
thumb comes
short flow
internet routers
backbone router
flow lengths
congestion windows
queue pkts
aggregate window
link utilization
review v
average queue
packet loss
control algorithm
single flow
single tcp
trip time
go empty
large bu
delay bandwidth
rtt bw
flow length
queue occupancy
using ns2
overbu ering
lose throughput
phase synchronization
concurrent flows
small bu
packets outstanding
g 1
window sizes
model predicts
never goes
bandwidth product
graph shows
network tra
sending rate
length distribution
avoidance mode
average flow
access link
backbone networks
net work
rate c
completion time
n shorten
sender pauses
required buffer
backbone links
lived flow
infinite bu
non tcp
bottleneck router
ering needed
er never
core router
nick mckeown
packet bu
router design
physical router
router linecard
internet backbone
bu er size
number of flows
rule of thumb
router bu er
long lived flows
amount of bu
router bu ers
number of long
m g 1
lived tcp flows
bu er requirements
long lived tcp
short lived flows
computer communication review
sigcomm computer communication
communication review v
acm sigcomm computer
required bu er
congestion control algorithm
average queue length
smaller bu ers
queue pkts figure
g 1 model
dynamics of tcp
simulations and experiments
round trip time
sizing the bu
delay bandwidth product
flow completion time
large bu ers
aggregate window size
cisco gsr 12410
single tcp flow
small bu ers
never goes empty
minimum required bu
rtt c n
point of congestion
average flow completion
gsr 12410 router
g 1 queue
congestion avoidance mode
review v 36
flow completion times
congestion control algorithms
network of real
flows in practice
bu er never
wmax 2 packets
single long lived
bu ering needed
infinite bu ers
minimum required buffer
short and long
review v 35
average congestion window
tcp s congestion
bandwidth delay product
network tra c
topology in figure
random early detection
number of outstanding
v 36 n
networking v 51
v 35 n

corpus/krapavin2000-test/608456.txt
survival
regression
cv
risk
dippon
robustified
univariate
bandwidth
therapy
kernel
cancer
estimate
breast
observable
nonparametric
covariate
componentof
hn
pn
patient
validation
predictor
reasoning
pm
pt
bandwidths
neighborhoods
cross
ps
distance
ht
multivariate
age
estimated
jx
censored
patients
dh
stuttgart
ardle
es
dn
statistical
influence
averaging
estimates
tumor
fz
ms
gr
tick
robustification
resubstitution
nadaraya
menopause
lymph
quart
scree
supremum
realizations
unknown
sample
bosch
ost
valley
diagnosis
splitted
covariates
physician
categorical
status
ratios
validated
simulated
akaike
prediction
mn
loader
estimation
watson
plot
minimization
curse
simulations
marks
empirical
alive
stone
simplification
nominal
observed
minimal
norm
dg
missing
dotted
date
valued
determination
big
wants
component
plug
naive
article
fx
cutted
regresion
histological
simonoff
estrogene
tnm
quartile
missingg
robustify
distibution
therapies
progesterone
reponse
efjm
categorial
shibata
yng
sensitively
mariuzzi
menopausal
jmn
smooths
metastases
uncensored
menachem
interquartile
krankenhaus
thatk
ey
quartiles
wishing
carbonez
kolodner
closely
estimator
seeks
variance
suggested
samples
fy
censoring
ellipsoidal
pursuit
refering
median
smoothing
fold
squared
axis
doesn
ffi
estimating
solid
column
withdrawal
penalizing
minimizes
distances
identically
splits
coded
selection
scaling
dimensionality
fig
match
equals
underestimation
occurence
bandwith
grading
accidental
dispense
coined
survival time
case based
based reasoning
kernel estimate
e h
distance function
estimated l
observed survival
j dippon
dippon et
statistical approach
observable variables
new case
cv h
bandwidth h
l 2
cross validation
regression estimate
breast cancer
optimal bandwidth
component 1
regression function
robustified bandwidth
r d
distance functions
pt pn
x componentof
regression estimates
univariate kernel
pn pm
bandwidth e
y jx
h 2
bandwidths e
function m
h j
nonparametric regression
pm es
cv function
local averaging
componentof component
es ps
new problem
e y
cancer data
given new
m x
h 1
predictor variables
ms ht
regression estimation
y component
ht pt
z j
final result
n h
ps 0
cv 1
closely match
component 2
time observed
data dn
axis right
run left
column cross
new patient
univariate bandwidths
univariate regression
survival times
new predictor
d valued
h ardle
validation estimated
cancer patients
validated l2
norm distance
function dh
function cv
min oe
cross validated
tick marks
similar cases
multivariate kernel
bandwidth selection
column univariate
censored survival
via cross
age ms
component j
r v
ae min
supremum norm
et al
h 3
testing data
y fig
component x
left column
unknown distribution
right column
kernel function
valued random
simulation run
n l
fx 1
one wants
k cases
gr es
suggested method
pm gr
scree plot
averaging estimate
appropriate therapy
l 2 risk
case based reasoning
approach to case
dippon et al
j dippon et
estimated l 2
observed survival time
optimal bandwidth h
bandwidth e h
robustified bandwidth e
e y jx
e h 1
bandwidths e h
e h j
estimate of e
h 2 r
x componentof component
pt pn pm
componentof component 1
h 1 e
breast cancer data
e h 2
univariate kernel estimate
survival time observed
ht pt pn
es ps 0
pn pm es
d n l
m n h
time observed survival
distribution of x
h 2 e
column univariate kernel
marks if within
run left column
left column cross
cv function cv
j are indicated
given new case
estimate the l
simulation run left
cross validated l2
jx i using
ae min oe
column cross validated
times of breast
r d valued
y component 2
jx i depending
pm es ps
ms ht pt
solid i 2
validation estimated l
univariate bandwidths e
breast cancer patients
regression function m
h i solid
via cross validation
censored survival time
component 2 y
distance function dh
cv h l
determination of univariate
right column univariate
realizations of x
axis right column
age ms ht
supremum norm distance
indicated by tick
choose that distance
bandwidth h j
x axis right
cross validation estimated
h i dotted
validated l2 risk
e h 3
r p q
family of distance
using the optimal
r d r
close to zero
within the range
respect to h
distance function d
d j z
functions as parameters
cv h 0
plug in methods
n x ffi
risk of m

corpus/krapavin2000-test/628789.txt
tsbn
mlp
pixelwise
cpts
cml
gmm
training
ikl
likelihood
ml
marginals
road
segmentation
posterior
image
images
pixel
trained
classication
vegetation
predictions
compensated
jy
marginal
tsbns
furniture
pixels
neural
segmentations
entropies
belief
pearl
bouman
xje
conditional
colour
scaled
label
sky
em
street
entropy
labels
maximise
coding
prior
jpeg
cpt
scenes
rural
probabilities
raw
multiscale
causal
mrfs
bayesian
compensation
normalising
inference
propagation
generative
surface
labelling
scene
root
dierent
mpm
classications
lossless
scaling
mixture
lm
message
trees
evidence
gaussian
hidden
downward
initialised
markings
ls
smap
laferte
clamped
sowerby
gmms
softmax
marking
predictors
train
tree
optimisation
jx
children
mobile
correlations
quadtree
labelled
passing
dr
hmms
rees
codec
bae
perez
maximising
ej
yjx
parent
spatially
region
ik
initialisation
gareth
rise
regions
gradient
ow
bpp
uninstantiated
upward
pa
columns
estimated
classiers
diag
mrf
node
probability
calculation
appendix
urban
lter
shapiro
modelling
pmlp
helmholtz
nechyba
blocky
glm
downsampling
gldv
levelled
todorovic
loco
loopy
bristol
accuracies
normalised
recognition
networks
learned
unsupervised
seven
graphical
estimation
network
texture
misclassied
independences
downsampled
mlps
prediction
bits
six
siblings
dataset
calculated
features
markov
prof
database
baum
aerospace
unlabelled
condent
positional
trainable
nding
conguration
uk
posteriori
feature
truncated
speech
panel
wright
classier
ground
conjugate
truth
label images
x l
ml tsbn
road surface
scaled likelihood
pixelwise predictions
p x
posterior marginal
ikl ikl
street furniture
l jy
mobile object
marginal entropies
trained tsbn
maximum likelihood
neural networks
surface building
ml trained
prior marginals
compensated mlp
vegetation road
cml training
level 1
root node
p y
road marking
p xje
tsbn model
mlp pixelwise
building street
marginal likelihood
training set
log p
conditional probability
belief network
bits pixel
conditional maximum
likelihood model
node x
likelihood method
marking road
cml trained
cml tsbn
tsbn training
gmm pixelwise
furniture mobile
colour images
probability propagation
jpeg ls
likelihood training
message passing
em algorithm
test images
gaussian mixture
non causal
prior model
image segmentation
class labels
y m
mlp local
posterior marginals
z ikl
compensated gmm
label image
causal mrfs
passing schemes
local predictions
road markings
ml training
data y
belief networks
image coding
neural network
level 7
prior probabilities
classication accuracy
likelihood p
training data
generative model
hidden nodes
graphical models
image analysis
l given
laferte et
passing scheme
sky vegetation
smaller trees
object vegetation
range correlations
bayesian image
likelihood cml
mlp predictors
tsbn using
spatially uniform
seven classes
hand labelled
n ikl
perez et
pixelwise classication
learned cpts
p ej
raw mlp
gmm model
dynamic trees
normalising factor
map segmentation
uniform compensation
image modelling
coding cost
tsbn methods
structured belief
ground truth
model parameters
x lm
al 36
jx l
p yjx
p x l
gmm and mlp
x l jy
road surface building
posterior marginal entropies
scaled likelihood method
surface building street
ml trained tsbn
building street furniture
conditional maximum likelihood
ikl ikl ikl
maximum likelihood training
vegetation road marking
road marking road
gmm pixelwise predictions
furniture mobile object
y i jx
marking road surface
mlp pixelwise predictions
p c k
ml and cml
training the tsbn
street furniture mobile
message passing schemes
compensated mlp pixelwise
non causal mrfs
sent to node
avoid under ow
hidden variables x
classify each region
bouman and shapiro
tree structured belief
object vegetation road
spatially uniform compensation
gaussian mixture models
laferte et al
message passing scheme
perez et al
x l given
compensated gmm pixelwise
mobile object vegetation
pearl s probability
marginal likelihood p
maximum likelihood cml
maximum likelihood ml
et al 36
scaled conjugate gradient
y i x
using the em
conditional probability p
maximum a posteriori
computation of p
hidden markov models
training and test
see section 6
section 4 5
tsbn the network
tsbn with mlp
likelihood model p
structured belief network
compare the tsbn
sky vegetation road
posterior marginals p
log p x
probability tables cpts
corresponding label images
pixelwise predictions spatially
likelihood against iteration
ground truth labelling
cml tsbn method
siblings of x
classes see 4
model p yjx
tsbn to model
features were extracted
likelihood cml training
z 0 2s
longer range correlations
likelihood p x

corpus/krapavin2000-test/1036164.txt
cover
covering
vertex
strip
opt
lp
outerplanar
ld
strips
coverage
dual
width
disks
covered
shifting
vertices
uncovered
approximation
covers
primal
graphs
planar
ptas
hochbaum
pr
rounding
relaxation
edges
greedy
expanders
delta
expander
chebyshev
sa
cantelli
optimally
packing
outliers
dfs
geometric
partial
multicuts
massaging
slav
maass
duh
bodlaender
rer
approximating
round
baker
asz
lov
segev
feasible
sc
rounds
partition
asaf
randomized
pick
diameter
semidefinite
decompositions
degree
cov
danny
ffi
jh
polynomial
obstacle
inequality
decomposable
chernoff
4d
levin
guessing
ver
np
letting
facility
squares
tail
semi
forest
fractional
pos
gamma
expectation
highest
tree
criteria
sion
formulation
square
decomposition
ratio
coloring
strategy
wish
fx
jopt
costliest
equaled
individu
gavril
qilian
golovin
setcover
pactly
qingchun
cjx
nagarajan
mohit
lovmyampersand
thetald
ik
hardness
italic
jx
variance
costs
raise
collection
integral
matching
star
bounded
equality
weighted
ponent
chv
mulation
maxfk
atal
viswanath
suitably
facilities
ffl
implying
appendix
incident
guess
relax
serial
erage
als
sz
asc
multicut
homogenous
isoperimetric
disk
sup
exhaustive
partitions
approximate
collec
judiciously
yehuda
permissible
timization
pairwise
complementary
vlsi
unweighted
ering
fz
integrality
sible
recourse
itively
families
belongs
union
cardinality
recipe
coverings
afford
generalization
modified
ip
edge
fl
vertex cover
k vertex
set cover
cover problem
partial covering
full coverage
covering problem
l outerplanar
approximation algorithms
optimal solution
tree width
shifting strategy
geometric covering
covering case
k set
partial vertex
width ld
planar graphs
covering problems
average degree
outerplanar graph
least k
primal dual
partial set
coverage version
lp relaxation
ffl k
uncovered elements
property p
semi local
dual feasible
highest cost
approximation scheme
approximation algorithm
partial coverage
partial cover
chosen sets
full covering
cover full
performance ratio
approximate solution
h delta
time approximation
feasible solution
k elements
constant average
multi criteria
points covered
f sets
set covering
n opt
randomized rounding
bounded tree
polynomial time
given points
packing problems
cost set
maximum degree
degree graphs
linear time
cover problems
maximum matching
delta gamma
l partitions
strip j
tail bounds
modified instance
cantelli inequality
bounded average
problems approximation
chebyshev cantelli
bounded degree
graphs approximation
approximation technique
expander graphs
e c
sets chosen
outerplanar graphs
location problems
end point
cost function
minimum cost
tree decomposition
pr u
diameter d
improved approximation
k points
dual variables
facility location
solved optimally
k edges
let opt
greedy algorithm
x j
lower bound
graph g
dynamic programming
local optimization
greedy heuristic
k vertex cover
vertex cover problem
cover at least
k set cover
partial vertex cover
u i j
partial set cover
strips of width
k i partial
l outerplanar graph
covers at least
least k elements
solution to cover
cover for planar
partial covering case
partial covering problem
covering and packing
constant average degree
dual feasible solution
algorithms for np
set cover problem
number of 1
find a minimum
bounded tree width
graphs of bounded
polynomial time approximation
z i j
bounded degree graphs
number of elements
cover the points
bounded average degree
disks of diameter
vertex cover problems
chebyshev cantelli inequality
semi local optimization
least k edges
ffl k vertex
partial coverage version
vertex cover full
partial cover problem
graphs of constant
strip of width
r a l
highest cost set
h delta gamma
l outerplanar graphs
full coverage version
u i 0
points in strip
geometric covering problem
full covering case
number of points
facility location problems
graphs approximation algorithms
set covering problem
better than 2
number of edges
set of disks
improved approximation algorithms
time approximation scheme
number of disks
number of sets
given a graph
needed to cover
semi local 2
multicuts in trees
linear time algorithms
f approximate solution
approximating the partial
decomposable graphs approximation
optimally using 2
modified greedy heuristic
side length ld
hard problems approximation
parallel algorithm runs
cover we wish
minimum cost solution

corpus/krapavin2000-test/609232.txt
ml
termination
nat
dml
reducible
withtype
terminating
cs
int
recursion
reducibility
acc
metrics
fun
typing
redex
programmer
hi
xs
metric
typed
derivable
par
funs
ackerman
datatypes
cmp
mutual
orderings
bool
ack
proving
program
char
polymorphism
structural
recursive
dependent
decorated
verification
trss
natg
qs
matches
expressions
proven
dom
liveness
checking
establishing
hongwei
nuprl
founded
judgments
pvs
quicksort
erasure
judgment
index
practicality
syntax
rewriting
xi
substitutions
realistic
ordering
checker
continuation
nating
feel
datatype
lexicographic
attach
body
currying
donnelly
mercury
satisfaction
renewed
explode
typable
coq
labelling
annotation
readily
verifica
height
labels
closed
verifies
nonterminating
termi
isabelle
len
primitive
contexts
programs
difficulty
formed
omit
characters
verified
safety
induction
interactive
ji
forming
jej
rules
verifying
errors
verify
novelty
accept
derivation
treatment
semantics
abstracting
synthesize
sorts
calculus
kevin
substitution
programming
loop
usual
automated
handled
toplas
hn
clause
string
unclear
calls
detecting
effort
informally
fn
expression
pattern
guaranteeing
constructors
smoothly
lam
language
prototype
corollary
semantic
hesitant
minating
glenstrup
easing
untrue
undeniably
belling
endless
carthy
hap
mechanized
unobtrusiveness
obtrusive
amram
ilam
thunk
arne
chiyan
ats
cast
contribution
else
suffices
spend
normalizing
star
demonstrating
interpretations
integer
minor
tuples
lambda
unwilling
deem
technicality
subscripting
redexes
pens
dependently
decorate
trs
godel
checks
label
program termination
dependent types
termination verification
ml 0
mutual recursion
termination checking
index expressions
type system
program errors
structural ordering
recursive function
cs matches
well typed
cmp x
programming features
proven terminating
establishing program
ackerman function
metric typing
general recursion
interactive theorem
typed program
every well
n nat
typing rules
par cmp
structural orderings
hi j
nat j
metric hi
length cs
detecting program
loop j
assume derivable
primitive recursion
higher order
rewriting systems
theorem proving
term rewriting
types int
cs 0
e 0
type checking
natural numbers
language ml
nat n
subject reduction
dynamic semantics
order functions
nat int
usual lexicographic
program error
hongwei xi
f reducible
automated termination
b int
recursion higher
decorated type
hi ji
closed recursive
informally explain
fun f
significant programming
reducibility let
j nat
else acc
termination proofs
xs withtype
rule type
termination checker
systems trss
closed expression
well founded
satisfaction relation
simply typed
practical programming
typed closed
type annotation
int j
types developed
char c
including mutual
founded orderings
f 7
facilitate program
termination analysis
safety property
e 2
function call
programming language
x xs
liveness property
development cycle
lexicographic ordering
index variable
corollary 3
program termination verification
approach to program
types in dml
notion of reducibility
redex which reduces
derivable in ml
establishing program termination
well typed program
reduces to e
every well typed
interactive theorem proving
implementation of ackerman
reducible if e
par cmp x
detecting program errors
e is reducible
term rewriting systems
corollary 3 10
allows the programmer
prove that every
need to verify
cannot be proven
rewriting systems trss
recursive function call
program in ml
form of dependent
e are reducible
reducibility let e
attach the metric
significant programming features
mutual recursion higher
language ml 0
rules for ml
dependent types developed
closed recursive function
programmer to provide
nat j nat
including mutual recursion
well typed closed
usual lexicographic ordering
recursion higher order
errors that cause
higher order functions
well founded orderings
types in practical
program development cycle
e e 0
lemma 3 9
program in figure
kevin donnelly hongwei
theorem proving systems
design a type
e is 0
dependent sum type
j funs f
k nat int
terminating in ml
metrics for verifying
xs of x
type for integer
prefix of cs
withtype n nat
nested recursive function
closed metric e
donnelly hongwei xi
n u r
nat int k
sequence of index
nuprl 2 coq
subject reduction theorem
approach to realistic
realistic programming language
termination verifica tion
datatypes and polymorphism
often have difficulty
acc p1 cs
f 7 e

corpus/krapavin2000-test/628189.txt
instantiations
instarray
curset
optimized
uninstantiated
minsup
association
confidence
optset
curloc
attributes
instantiation
numeric
confidences
conf
pruning
categorical
sup
intlist
optconfrange
dst
rectangle
mins
maxconf
france
minconf
maxs
instantiated
mining
intermediate
rules
disjunctions
ny
attribute
maximized
supports
overlapping
naive
src
optconfpruneopt
finstarray
optsuprange
country
rectangles
telecom
prune
depth
rule
overlap
extending
calls
provider
alg
constraint
permitted
weights
instar
starray
newlist
search
opt
city
periods
front
quantitative
promotion
cities
sensitivity
tuples
upto
corresponded
date
correlations
satisfying
marketing
dates
admissible
enumerate
invokes
pruned
enumerates
prior
sorted
discovery
decreasing
weight
regions
exhaustively
hui
atomic
intervals
arranging
items
exploring
sigkdd
permitting
track
exceed
stop
offering
customers
np
hye
pruneopt
discounts
yesook
optconfnaive
optcon
instanti
tribute
ingful
confnaive
optsup
optconfcanprune
phil
enriching
frange
abstractmining
optconfpruneint
bari
narain
minweight
meric
sameep
kwei
kaya
candidates
deleted
intractable
eliminate
period
trends
incur
ray
korth
tiations
maxsup
gibbons
reda
instan
seasonal
gehani
minimumsupport
hank
wilfred
doo
andn
lack
extend
dealt
formulations
service
tribution
innovations
alhajj
promotions
unraveling
vitter
disproportionately
xiong
poorly
interval
subsection
discovering
park
effi
miroslav
shashi
stants
hwan
kubat
yen
mehta
ya
silberschatz
rozsypal
nutshell
avi
yiping
taxonomies
antonin
unsatisfiable
mehmet
ffl
stored
ranges
toward
correlated
pearson
sizable
retail
lap
shekhar
optimized set
optimized confidence
association rules
intermediate sets
optimized association
uninstantiated attributes
computing optimized
numeric attributes
confidence set
optimized support
current optimized
confidence sets
graph search
least minsup
association rule
constraint 8
overlapping instantiations
extending curset
depth first
search space
following constraint
curloc 1
high confidences
numeric attribute
mins maxs
optimized sets
extend curset
conf optset
w instarray
search algorithms
w 2
satisfying constraint
either categorical
rules problem
c satisfying
naive algorithm
minimum support
categorical attributes
search algorithm
non overlapping
rule u
pruning instantiations
uninstantiated conditions
contain uninstantiated
high supports
stop extending
instantiated rules
contain disjunctions
rule problem
confidence problem
telecom service
dst country
procedure optconfrange
instantiations u
prior pruning
decreasing order
sup r
given k
support set
first algorithm
minimum confidence
support sets
m dimensional
user specified
optimal instantiations
gamma w2
confidence rule
src city
uninstantiated attribute
every instantiation
atomic conditions
uninstantiated numeric
dst france
admissible regions
conf r
instantiated conditions
rule date
rules contain
minsup values
intermediate set
single optimal
sup optset
m uninstantiated
opt w2
next instantiation
instantiations however
uses intermediate
mining optimized
low supports
service provider
optimized confidence set
optimized association rules
number of instantiations
current optimized set
optimized confidence sets
optimized association rule
minsup and conf
used to extend
set of instantiations
number of uninstantiated
graph search algorithm
computing optimized sets
calls from ny
support at least
categorical and numeric
instantiations in instarray
permitted to contain
association rules problem
minconf and sup
non overlapping instantiations
computing optimized confidence
c satisfying constraint
satisfying constraint 8
depth first algorithm
supports and confidences
found in 9
support and confidence
instarray i l
sup s minsup
stop extending curset
optimized confidence problem
categorical or numeric
optimized support set
association rule problem
extend s 2
graph search algorithms
telecom service provider
rules are permitted
instantiations with higher
m dimensional space
confidence and support
problem given k
number of tuples
values of c
problem of computing
values of w
range of values
support and minimum
mining optimized association
ways 1 association
sorted by confidence
instantiation of u
instantiations with high
alg for optimized
optimized confidence rule
instantiations are sorted
confidence of curset
range of supports
attributes 2 association
uninstantiated attributes 2
l gamma w2
list of intermediate
allowed to contain
rules to contain
rules are allowed
optimized support sets
ny to france
two intermediate sets
disjunctions over uninstantiated
r is maximized
front of instarray
attributes and uninstantiated
algorithms for computing
lack of space
number of calls
algorithm that uses
contain an arbitrary

corpus/krapavin2000-test/614304.txt
quaternion
frenet
4d
frame
quaternions
curve
frames
transport
curves
3d
sphere
curvature
streamlines
streamline
torsion
rotations
orientation
knot
fields
vanishing
projected
rotation
ball
smoothly
lighting
field
visualizing
tangent
differential
scalar
eq
visualization
geometry
display
smooth
hanson
color
moving
hyperhemisphere
displayed
torus
euclidean
diametrically
tangents
binormal
eps
rolling
perpendicular
light
surfaces
solid
gammaq
similarities
fig
dt
coordinate
assigning
pathological
interactive
orientations
vanishes
plane
alpern
mensions
thickening
viewer
viewing
numerical
gray
straight
ffl
manifolds
undefined
jump
sign
surface
triad
tubes
ambiguous
illumination
rotate
stream
differentiable
multiplication
interpolation
expose
tandem
bishop
discontinuous
projection
orthogonal
southern
families
lying
volume
sudden
scales
highlighting
plot
piecewise
everywhere
rigid
intrinsic
populated
rendering
displays
polar
densely
angle
manifold
opposite
reciprocal
intrinsically
locally
geometric
volumetric
arc
degrees
segment
integrate
dense
derivatives
derivative
ambiguity
tensor
unit
plots
freedom
vector
inner
interactively
coordinates
angular
equations
slerping
mathematicians
reexpressing
posite
meshview
alterna
bled
singles
discontinuously
pseudocol
allax
indeterminable
tubing
kauffman
antisym
codi
pseudocolored
abstractcurves
pseudocolor
entations
framings
treatise
shoemake
altmann
hart
perhemisphere
displaces
solomon
crack
evolve
quantities
displaying
similarity
analog
rendered
normal
continuity
north
flow
andrew
meeting
distinguishing
serret
ponent
invent
ored
7d
ori
heng
hemispheres
6d
gents
lationship
parallel transport
frenet frame
quaternion frame
transport frame
three sphere
quaternion frames
frame components
four vector
space curves
space curve
quaternion field
moving frame
quaternion space
frame field
3d space
4d light
frenet frames
torus knot
vanishing curvature
frame fields
differential geometry
quaternion frenet
transport frames
unit quaternions
four space
euclidean space
scalar fields
vector field
frame upper
4d lighting
color scales
streamline data
two quaternions
quaternion fields
components showing
smooth quaternion
3d rotations
vector quaternion
4d rotations
vector frame
4d quaternion
scales indicate
b selected
rolling ball
projected image
four dimensional
left graph
plane perpendicular
curve x
quaternion representation
3d rotation
curvature vanishes
eps figure
initial frame
solid ball
moving coordinate
4d normal
sphere plot
quaternion parallel
given curve
quaternion multiplication
upper left
coordinate frame
stream surfaces
frame see
ffl compute
unit quaternion
see e
arc length
coordinate frames
non vanishing
th component
q 0
dimensional euclidean
three space
scalar product
inner product
theta 3
eq 6
normal vector
independent degrees
initial reference
curve shapes
space color
selected parallel
southern hyperhemisphere
identical curves
frame coordinates
defined everywhere
4d unit
visualization methods
transport method
ball interface
single curves
orientation frames
lighting formula
knot b
diametrically opposite
reference orientation
4d projection
viewing strategy
pathological curve
space picture
quaternions using
assigning quaternions
orientation control
sphere embedded
assigning smooth
quaternions remain
parallel transport frame
quaternion frame components
curvature and torsion
parallel transport frames
vector frame upper
graph in c
upper left graph
indicate the 0
3d space curve
color scales indicate
frame components showing
four vector frame
curve s four
frame upper left
quaternion frenet frames
three sphere plot
four dimensional euclidean
projected from four
4d normal vector
four vector field
frame see e
four vector quaternion
quaternion parallel transport
see e g
dimensional euclidean space
curves and surfaces
four space color
triad of orthogonal
unit three sphere
using the 4d
frames the frenet
properties of space
transport frame components
geometry of curves
parallel transport method
quaternion frame coordinates
curve is locally
torsion scalar fields
b selected frenet
frenet frame field
b selected parallel
alpern et al
quaternion frenet frame
smooth quaternion frame
selected frenet frame
knot b selected
theta 3 orthogonal
curves in three
columns of eq
3d 3 5
non vanishing curvature
ball has points
moving coordinate frame
select a numerical
dt d x
three sphere projected
euclidean space picture
frame field plotted
rolling ball interface
pathological curve segment
frenet frame components
frame components d
space color scales
d the path
three sphere color
c the quaternion
compute a candidate
streamline data set
4d quaternion space
4d to 3d
parallel transport analog
families of space
rotate the frame
set of streamlines
x t dt
curve segment b
frame at x
sphere color scales

corpus/krapavin2000-test/628132.txt
images
image
xi
query
display
coecients
database
visual
distance
voronoi
nin
metric
sa
color
emergent
feature
xj
similarity
polygons
interface
interaction
va
endowed
operators
el
gd
tensor
yi
meaning
exploration
operator
concept
car
quantization
wavelet
medieval
modigliani
crucifixion
weyl
spaces
multimedia
labels
databases
sb
transform
exploratory
coecient
screen
heisenberg
cultural
asa
retrieval
ane
icon
placed
displayed
fig
subjects
dierent
distances
subgroup
keywords
colors
gosselin
irn
giang
painting
matthieu
cbir
semiotics
paintings
creation
metadata
sk
centroids
jd
homomorphism
manifold
dieomorphic
pentagonal
latin
eco
worring
portrait
oer
ecient
projection
grayscale
mediated
cord
hexagon
rahul
vb
schematically
anchored
riemann
invariance
browsing
interfaces
concepts
textual
regularization
tensors
manipulation
indices
angular
algebra
stars
marcel
art
gabor
endow
hessian
histograms
semantics
ramesh
closeness
dissimilarity
circle
cars
configuration
media
raw
front
semantic
paris
nguyen
mother
position
manipulate
viz
jain
origin
attached
philippe
transforms
dimensionality
triangular
sake
multidimensional
queries
social
determination
production
interacts
unitary
group
linguistic
box
terminals
singh
spring
filtering
enforce
vision
deemed
interpretation
knickmeyer
evocative
takama
rodrguez
celmar
altman
tihonov
aristotelean
isq
havementioned
torres
lookig
derik
steji
similerity
saussurean
bosque
cuv
archtecure
matism
vademecum
yasufumi
wihch
artistic
kanagasabai
purport
signifie
gij
octagonal
tversky
rajaraman
verbocentric
pilho
restrepo
fotouhi
contributer
lina
sreenath
portait
feature space
display space
query space
visual concept
voronoi polygons
el nin
natural distance
nin o
xi yi
image databases
distance function
image representation
query operator
visual concepts
emergent semantics
xi xj
similarity measure
space f
image data
metric tensor
two coecients
e xi
similarity criteria
vector quantization
user interaction
optimization problem
whole database
ane group
weyl heisenberg
car image
heisenberg group
images around
sa sa
dimensional display
f xi
image space
distance functions
image database
three spaces
function f
two images
current database
space q
traditional databases
color image
feature sets
f f
fig 3
dimensional feature
multimedia october
projection operator
wavelet transform
low dimensional
x y
visual queries
tensors g
operator q
discrete transform
place operator
france giang
exploration interface
features xi
raw feature
images closest
interaction involving
graphical front
o 18
guided exploration
apply vector
el nin o
set of labels
feature space f
set of images
g and c
e xi xj
number of coecients
sa and sb
weyl heisenberg group
image is represented
representation of g
x y 0
class of distances
distribution of images
xi and yi
distance between two
set of keywords
dimensional feature space
conference on multimedia
possible to define
annual acm international
space of distance
two dimensional display
nin o 18
display the whole
philippe h gosselin
france giang p
features xi yi
space is dieomorphic
context that suggests
j c e
model of interface
polygons of image
given feature space
interface of el
interfaces for emergent
query space q
space is endowed
c e xi
quantization an image
moving images around
case of color
yi are angular
h gosselin matthieu
hexagon in fig
dieomorphic to ir6
apply vector quantization
paris france giang
database the query
raw feature space
class of images

corpus/krapavin2000-test/618430.txt
skin
muscle
muscles
ellipsoid
ellipsoids
bones
stuffing
animal
anchor
joints
body
cat
animals
longitudinal
coordinate
isosurface
segment
axis
origin
adjustment
tendons
animation
tissue
joint
anatomy
segments
polygonal
insertion
vertebrates
thalmann
deformations
realism
interactively
mesh
motion
volume
anchored
surface
attached
frame
lengths
positions
henne
ears
skull
zuni
reshape
vertebrae
anchors
geometry
spring
attachment
frames
comfortable
voxelization
proximal
position
texture
realtime
grid
virtual
displaced
skeleton
individuals
gelder
outward
world
moves
magnenat
jurassic
hues
biomechanical
distal
physiological
jld
abdomen
toad
stuffings
nearest
adjusted
species
animations
underlying
filtered
vertices
collision
humans
interactive
extracted
animated
anchoring
purple
rhythm
soft
axes
filtering
hierarchy
realistic
anatomical
bears
graphics
3d
deformation
foot
attachments
created
simulate
feel
allen
wilhelms
rescaled
bone
cubes
modeled
move
springs
grasping
leg
dt
parameterized
creation
marching
default
parent
polygon
neighboring
drawing
modeling
layered
filter
human
dp
visual
displacements
images
scalar
geometrical
decay
connections
implicit
loose
motions
tightly
center
converted
movement
shape
loosely
field
influence
flexible
dinosaurs
karan
markush
inverte
abductor
nudged
lucasfilm
biomechanically
variably
scapula
larboulette
arnaldi
fatty
figuratively
endoskeleton
cola
merril
caroline
contaction
adhoc
gourret
chadwick
jointed
vertebrate
bulbous
fingers
baggy
extensor
flexor
invested
haumann
aexture
anatomically
brates
pauline
worldspace
skin points
skin point
world space
bones muscles
underlying components
coordinate frame
skin mesh
rest position
polygonal skin
body parts
z axis
muscle ellipsoids
state geometry
underlying parts
rest length
insertion points
virtual anchor
axis lengths
coordinate system
neighboring skin
rest geometry
soft tissue
animal models
segment coordinate
individual muscles
ellipsoid equation
local coordinate
rest state
body moves
collision detection
nearest point
anchor ellipsoid
muscle body
three ellipsoids
local segment
muscles stuffing
origin point
underlying anatomy
skin model
ellipsoid coordinate
across joints
zuni cat
allen van
longitudinal axis
local position
parent segment
virtual anchors
joints move
local ellipsoid
axis vector
body segment
anchor points
coordinate systems
implicit surface
finite element
present state
texture mapping
second using
adjacent points
van gelder
frames per
greater realism
segments bones
muscle axis
new muscle
origin segment
physiological principles
different individuals
x lengths
ellipsoid axis
skin positions
simulated muscles
adjustment iteration
muscle changes
skin automatically
body muscle
geometry bones
muscle behavior
parameterized local
joint motion
muscle origin
body segments
skin vertex
research provides
remarkable similarity
real animal
body deformations
many animal
element theory
whole animal
animal model
interactive speeds
flexible skin
individual bones
jurassic park
filtered value
spring constant
mark henne
loosely attached
comfortable interactive
achieves greater
magnenat thalmann
origin and insertion
muscles and stuffing
bones muscles stuffing
segment coordinate frame
allen van gelder
neighboring skin points
attached to underlying
influence of neighboring
images and animations
per second using
frames per second
produce a polygonal
muscles and soft
change in position
muscles and 13
ellipsoid section 3
local segment frames
position in world
thalmann and thalmann
parameterized local position
figures 5 9
field is usually
local ellipsoid coordinate
polygonal skin model
many animal models
change during joint
individuals and species
anatomical and physiological
adjacent points e
achieves greater realism
stuffing and skin
anchor ellipsoid section
positions of skin
skin is generated
bones and stuffing
ellipsoid coordinate frame
tend to use
origin segment coordinate
comfortable interactive speeds
along the longitudinal
animal coordinate system
finite element theory
using 1 adjustment
structure of individual
henne also used
second using 1
muscle or stuffing
ellipsoids that form
changes in position
skin points two
muscles are created
skin is automatically
ellipsoid axis lengths
state geometry bones
user can interactively
local coordinate systems
user defined parameters

corpus/krapavin2000-test/628075.txt
diseases
lcpt
disease
findings
specificity
lcpts
leak
diagnostic
diagnosis
bayesian
jpd
overconfident
specificities
unmodeled
reversal
gate
probabilities
cardiac
conditional
sensitivity
sensitivities
posterior
arrhythmias
link
causal
conditionally
inversion
net
medical
netica
mi
noisy
marginally
inverted
independence
dag
parents
tamponade
breathing
pathophysiological
std
network
confidence
diagnostics
ill
finding
joint
statistics
probabilistic
posed
qualitative
myocardial
diagnosing
subnetwork
entries
belief
probability
truth
fig
designer
expert
arrythmias
physicians
sinus
arrhythmia
diagnoses
yhl
djf
breathlessness
dyspnea
depression
atrial
jpt
dependency
likelihoods
corrected
reasoning
intermediate
dependence
links
blanket
cpts
bns
infarction
dja
extremal
propositional
gates
constructing
leaky
symptoms
prevalence
tables
bn
antecedents
subnetworks
patient
jh
networks
odds
st
rarely
estimates
node
api
medicine
corrections
employed
filled
logical
numerator
instantiating
pl
combinations
priors
influences
inverting
imprecise
incidence
generative
boolean
nodes
marginal
behaved
anti
yavuz
etin
breath
iliad
epidemiological
ajd
ferat
breathless
adolescence
ajc
inhalations
jpts
bradycardia
cozman
unwarranted
junctional
coronary
gagliardi
electrocardiogram
polpo
arnavut
cassio
diffidence
afb
bjd
sahin
internist
swarm
fibrillation
ziya
uluyol
shinsuke
tachycardia
flutter
nder
overconfidence
supplemental
dealing
parent
predictive
denominator
factorization
introducing
entry
jr
artery
influencing
afl
tuberculosis
impairs
jaime
inconclusive
qmr
bronchitis
makers
rhythm
experiential
djh
ca
two findings
leak probability
link reversal
link probabilities
bayesian networks
finding nodes
disease node
conditional dependence
disease d
reversal algorithm
probability tables
conditionally independent
conditional independence
bayesian net
unmodeled conditional
marginally independent
partial statistics
conditional probability
ill posed
probabilistic networks
joint probability
intermediate nodes
intermediate node
posed problem
problem domain
medical diagnostics
overconfident diagnosis
original network
cardiac tamponade
two diseases
qualitative probabilistic
node ca
unmodeled diseases
leak term
number ffl
diagnostic systems
finding node
link probability
type shown
fig 4
bayesian network
posterior probability
finding f
local conditional
expert systems
posterior probabilities
f 2
node d
f 1
probabilities p
probability distribution
knowledge engineering
specificity data
marginally dependent
finding indicates
numeric information
anti causal
conditional dependency
leak probabilities
partially correct
diseases d
posterior odds
causal independence
odds o
disease regardless
tamponade d
generative direction
second finding
bayesian subnetworks
usually available
diagnostic direction
several diseases
dja b
indirect statistics
marginal probabilities
pathophysiological states
infarction mi
n diseases
myocardial infarction
o dja
several cardiac
lcpt however
boolean clusters
constructing bayesian
propositional rules
re inverted
cardiac arrhythmias
independent finding
particular disease
following lcpt
reliable methods
p djf
f jh
extremal values
yhl 88
reversal algorithms
found link
inverted net
belief updating
one leak
lcpt entries
markov blanket
overconfident network
sensitivity and specificity
sensitivities and specificities
p i l
present the posterior
noisy or model
link reversal algorithm
ill posed problem
conditional probability tables
shown in fig
networks for medical
diseases to findings
times the prior
estimate the leak
unmodeled conditional dependence
noisy or gate
local conditional probability
conditional probability distribution
fig 4 c
distribution p djf
causal and anti
cardiac tamponade d
intermediate node ca
parents of f
leak term p
found link probabilities
combinations of diseases
proposed bayesian subnetworks
already found link
cause the finding
following numerical example
dealing with conditional
link probabilities p
assumptions of conditional
specificity and sensitivity
net in fig
marginally independent finding
odds o dja
qualitative probabilistic networks
myocardial infarction mi
posterior odds o
number of probabilities
findings in addition
links between findings
o dja b
resulting network represents
network with marginally
independent finding nodes
constructing bayesian networks
finding is present
avoid over confidence

corpus/krapavin2000-test/1024149.txt
cut
simplex
terminal
calinescu
sparcs
terminals
integrality
cuts
cutting
corner
segment
aligned
ball
sparc
multiway
relaxation
density
embedding
slices
rounding
gap
icut
slice
segments
rays
lp
slicing
cell
geometric
paths
hexagon
endpoints
edge
planar
dual
gn
infinitesimal
mesh
volume
triangle
embedded
edges
planarity
probability
embeddings
concave
coordinates
uniformly
dahlhous
discretized
vertex
optimum
karloff
maximizer
symmetrized
hex
fix
symmetry
suffices
analytic
endpoint
discrete
rabani
alignment
disconnected
induces
approximation
ratio
multicommodity
fork
connecting
distances
analytically
lemma
permutation
hyperplanes
schemes
gave
goes
vertices
norm
chooses
contribution
hyperplane
bounds
enumerating
provable
bold
duality
gaps
seffi
tationally
undertook
worsened
hanneke
hinting
followingconditions
symmetrize
langberg
bidirected
obliviously
ofk
approximationalgorithm
plification
allk
avidor
generalk
calledterminals
bedding
cells
captured
distance
technically
guided
symmetric
faced
face
flow
capture
closed
closest
diagram
tractable
central
ork
matures
geodesics
infinitesimally
chekuri
snp
adi
multiterminal
transductive
sides
random
boundaries
maximizes
finish
contradiction
devised
restrict
lengths
neu
alignments
ogous
prompted
qf
multicut
cunningham
anupam
straightfor
contributes
understand
derives
infinite
ratios
semidefinite
disconnects
await
thirds
tices
coordinate
removal
simplifies
ward
trian
cplex
mann
gle
mally
seymour
tabular
discretizations
mapped
ordering
boundary
min
omega
guarantee
located
union
metric
amit
naor
way cut
cutting scheme
calinescu et
corner cut
k way
integrality gap
ball cut
segment e
maximum density
multiway cut
aligned segment
d k
geometric relaxation
j aligned
cut problem
linear program
x k
way cuts
planar dual
x 1
rounding scheme
embedded graph
approximation algorithm
connected cut
corner scheme
cutting schemes
ball corner
performance ratio
x 2
lemma 6
performance guarantee
terminal 1
two terminals
et al
x 3
terminal case
probability distribution
k p
upper bound
fact 4
point r
j d
cut twice
rounding schemes
corner closest
corner cuts
discrete sparc
disconnected cut
density contribution
three paths
terminals 3
scheme chooses
expected cost
expected number
approximation ratio
geometric embedding
cut corresponds
k simplex
optimal 3
terminal j
central node
cut thus
x j
edge e
form expression
theorem 6
diagram shows
one zero
improved approximation
general k
c k
proof fix
path p
approximation algorithms
closed form
calinescu et al
k way cut
p i j
x 3 x
e is cut
multiway cut problem
x 1 x
j aligned segment
ball corner scheme
cut is made
x i r
d a 0
lemma 6 4
cut is chosen
aligned segment e
half the l
closest to terminal
e is e
x 2 6
less than 12n
k p e
thus the expected
optimal 3 terminal
number of times
chosen with probability
closed form expression
theorem 6 2
show that c
probability of choosing
probability 1 2
fix x 1
cut from p
k maximizes d
cost multiway cut
edge is cut
q k 1
maximizes d k
like our upper
provable upper bounds
terminals in random
work of calinescu
density of p
distribution over sparcs
graph calinescu et

corpus/krapavin2000-test/628688.txt
da
fl
discontinuities
smoothness
regularizer
lp
smoothing
regularization
mrf
euler
discontinuity
energy
regularizers
aifs
ff
jjj
membrane
aif
adaptive
interaction
derivative
vision
oversmoothing
convex
priors
continuity
apf
wn
convexity
anisotropic
quadratic
apfs
defects
ill
pami
diffusion
posed
regularizing
noise
band
strength
ihi
dx
minimization
derivatives
slopes
analog
jf
continuous
gnc
deltaff
continuities
synaptic
lim
neighboring
2d
image
irregularities
roof
restoration
fig
blake
piecewise
posterior
temperature
clique
jg
pavlidis
inadequacy
shah
ffid
thicker
stability
regularized
gibbs
string
continuously
vol
triangles
fi
approximated
yy
thinner
geman
conductance
hopfield
ffif
girosi
flip
gradient
li
pp
markov
potential
whereby
differentiability
steep
mrfs
zisserman
leclerc
weak
annealing
bands
reconstruction
analytic
xy
descent
mumford
penalized
abrupt
circuit
nonzero
monotonically
neighborhood
stable
images
jh
priori
penalty
closeness
field
weighting
simulated
instantiates
geiger
spacing
stochastic
un
everywhere
intelligence
delta
potentials
adaptivity
pixels
realizes
dis
diagonal
signal
boundary
directions
neurons
missing
encoded
updating
xm
isotropic
preserving
eq
differentiable
variational
piece
spaced
robust
solid
convergence
constrained
discrete
white
pyramid
equilibrium
manufacturing
spatially
prescribed
parameterized
continuation
solutions
wile
ntu
monotony
gories
disturbances
szli
infi
deltafl
shulman
bedini
moothness
herve
soh
usingthe
rod
graduation
besl
carmine
evenness
asymptote
marroquin
ntuix
oversmoothed
fiore
da model
euler equation
lp model
g fl
line process
h fl
da solution
solution f
smoothness priors
discontinuity adaptive
fl j
wn x
potential function
anisotropic diffusion
smoothing strength
adaptive smoothness
quadratic regularizer
data d
smoothness constraint
h ff
process variables
neighboring points
ill posed
regularization models
interaction function
energy function
u f
un f
g 1fl
pami 17
vol pami
adaptive interaction
regularization model
component defects
intelligence vol
network circuit
pp 576
f 0
computer vision
f ff
jg 0
mean field
c 1
posed problems
band b
ihi fl
adaptive string
mrf model
functions aifs
corresponding energy
string model
jjj increases
equation constrained
interaction functions
jf n
bounded slopes
roof edges
solutions obtained
june 1995
f n
ff j
necessary condition
machine intelligence
potential functions
d dx
continuous nature
continuous domain
smoothness term
dis continuities
analog network
b fl
neighborhood system
mrf models
pattern analysis
markov random
h f
piece wise
term u
field theory
equation 25
g ff
j d
n x
solid lines
lp solution
delta function
variables l
robust statistics
fl 2
e f
energy minimization
ff x
fl 0
global minimum
ideal signal
g 2fl
finite fi
wise constant
gnc like
process potential
associated euler
solution depends
binary line
empirically chosen
priori smoothness
constraint encoded
adaptive smoothness priors
discontinuity adaptive smoothness
line process variables
priors in computer
interaction between neighboring
li on discontinuity
g fl j
without such noise
machine intelligence vol
vol pami 17
pp 576 586
intelligence vol pami
model is defined
c 1 continuous
ill posed problems
f n x
interaction functions aifs
adaptive interaction functions
stable to changes
euler equation 25
convexity of e
large but bounded
h fl 2
euler equation constrained
potential function g
model the interaction
changes in parameters
u f j
adaptive to discontinuities
smoothing at discontinuities
transactions on pattern
analysis and machine
fl is defined
f j d
g f n
mean field theory
class of adaptive
aifs the corresponding
adding sigma25 evenly
random fields mrfs
jf 0 ff
d is shown
class of aifs
priori smoothness constraint
uniformly spaced points
process potential function
interaction is piecewise
lines the ideal
introduce a parameter
simulated by adding
distributed random noise
energy function e
fl is chosen
anisotropic diffusion 16
euler equation associated
ff f 0
h ff j
mumford and shah
line process variable
oversmoothing at discontinuities
difference between different
using the hopfield
controlling the interaction
minimizing the corresponding
smoothness constraint encoded
shown in dashed
quality changes etc
evenly distributed random
line process potential
term u f
simulated component defects
however the da
spaced points x
exponential g 1fl
obtained with simulated
h ff f
noise this demonstrates
solution f ff
error tolerance property
indicated by triangles
gaussian with standard
shown in thinner
different models lies
gnc like algorithm
triangles with 50
smoothness term u
signal is shown

corpus/krapavin2000-test/611451.txt
psdm
pseudospectrum
sweep
pseudospectra
pf
kahan
triplet
curve
contours
gre
descent
newton
contour
speedups
cobra
curves
grid
disconnected
steepest
cyclic
min
arpack
processor
zi
singular
static
nished
processors
stepsize
correction
evaluations
partitioning
dn
mpi
lengths
signicant
boundary
toolbox
approximated
load
matrix
dospectrum
sparskit
imbalance
sweeps
gure
boldface
block
bekas
gallopoulos
inwards
embarrassingly
kokiopoulou
pseu
grcar
secs
depict
gradient
policy
allocate
approximate
approximating
mesh
uncontrollability
consecutive
inner
cf
partitionings
rst
polygonal
eigenvalues
prediction
wi
lying
reduction
tasks
dening
suer
rows
triplets
regarding
culty
neighboring
adaptation
balance
modied
matrices
experimented
readily
noting
matlab
jw
dropped
philippe
weakness
plane
outermost
proceed
master
vis
seeking
proc
inferior
sgi
half
continuation
directional
upatras
secretariat
koutis
geo
zh
scgroup
blocksize
cuves
ameliorated
bruhl
visibly
tured
sunstantial
mipspro
krg
mezher
springboard
underdetermined
spdm
mpt
astute
ceid
ene
allgower
hpclab
satisfactory
manages
adapt
parallelism
parentheses
grain
corrected
allocated
sparse
trajectories
di
eective
nally
savings
path
owes
inscribed
encircled
shue
harwell
kostin
steplength
jmin
embarassingly
circle
dropping
iterative
reveal
capturing
ect
inside
dene
renements
underline
matics
openmp
wj
mathe
boeing
hermitian
underscore
irix
gauge
versatility
worth
target
moderate
distance
oered
unsymmetric
eorts
renumbered
arnoldi
z k
path following
points computed
gre 1107
point reduction
static block
static cyclic
disconnected components
consecutive points
kahan 100
steepest descent
newton step
points z
initial curve
cyclic partitioning
one sweep
single sweep
min zi
w k
relative error
point z
pseudospectrum descent
order 100
dn p
initial contour
n points
singular vectors
block partitioning
reduction policy
single newton
level curve
points dening
minimum singular
nished rst
boundary curve
matrix kahan
capture disconnected
method psdm
parallel nature
single boundary
contours computed
triplet evaluations
matrix gre
descent method
p e
complex plane
load balance
mean relative
matrix toolbox
e points
newton iteration
compute points
level curves
min u
table 8
table 10
k 1
test matrix
computed via
singular value
time secs
load imbalance
u min
w 0
cf 5
processor 1
real analytic
target points
grcar 50
original curve
directions used
pseudospectrum contours
introduction cobra
y psdm
sweep psdm
points approximating
corrected towards
boundary curves
original path
points 46
pseu dospectrum
secs 6000
pf scheme
e consecutive
embarrassingly parallel
use static
cyclic partitionings
rows 3
rows 7
contour m
via psdm
applied psdm
using descent
correction direction
contour lengths
curve 0
corresponding speedups
time processor
adaptive point
partitioning time
polygonal path
triplet evaluation
parallel psdm
contours corresponding
capturing disconnected
move inwards
pseudospectrum level
block static
via pf
prediction direction
sweep of psdm
number of points
points z k
computed by psdm
computation of pseudospectra
kahan of order
application of psdm
implementation of psdm
dn p e
static cyclic partitioning
static block partitioning
points on m
pseudospectrum descent method
z k 1
matrix gre 1107
version of pf
point z k
points of m
triplet at z
single newton step
contours computed using
distance between consecutive
capture disconnected components
n points z
maximum and mean
computing the triplet
single boundary curve
based at z
min u min
test matrix toolbox
times and speedups
speedups in parentheses
experimented with static
block static cyclic
min q min
e consecutive points
corresponding to min
rows 7 9
directional newton methods
r min x
outlined in table
min z k
indicate that psdm
methods in n
u min v
methods an introduction
cost for computing
partitioning time secs
p e consecutive
path following method
using static block
psdm on matrix
p e points
initial curve 0
correction direction c
maximum relative error
static block static
evaluation at z
direction c k
point reduction policy
inside the initial
processor that nished
cf 5 2
original path following
time secs 6000
point w k
time processor 1
adaptive point reduction
number of triplet
min v min
candidates for dropping
curve 0 1
descent method psdm
w k using
capturing disconnected components
reduction policy described
min x k
block and cyclic

corpus/krapavin2000-test/627083.txt
transaction
lock
slowdowns
vf
locking
vv
blocking
occ
thomasian
ryu
concurrency
slowdown
permanent
commit
conflict
concurrent
transient
silent
snapshot
queue
commits
optimistic
aborted
herlihy
locks
analytical
conflicts
committing
calculate
aborts
numa
predictions
gammafl
processors
nonblocking
synchronization
processor
object
shared
residence
utilization
contention
executes
ana
throughput
slow
granule
abort
broadcast
enqueue
spin
response
cns
executing
priority
multiprocessors
utilizations
execute
faults
executions
stage
pointer
phi
enqueues
lazowska
architectures
items
ticket
fl
approx
conflicting
uma
prakash
atomic
instruction
protocol
static
validation
dequeue
goodman
multitasking
unsuccessful
rate
processes
formulae
bus
simulation
swap
multiprocessor
spends
proportion
atomically
accesses
jobs
queues
dequeues
valois
plj
backoff
zahoran
cache
anderson
discrimination
probability
calculates
execution
blocked
kills
avl
turek
spinning
unconditional
read
ff
old
calculated
ss
exponentially
exclusive
shasha
mellor
crummey
experience
heterogeneous
restart
seconds
protocols
instructions
queuing
free
switch
cleanup
mf
temporarily
closed
analyzing
stages
composite
compete
access
dt
agreement
plot
database
johnson
formula
poisson
calculations
spite
accurate
service
restarts
stone
workspace
eager
occupancy
validate
kernel
trees
interfering
reserve
ran
considerable
thread
distributions
resource
objects
failed
accessed
permits
idle
enters
researchers
simultaneous
bias
mimd
agrawal
update
permitting
record
poor
frontiers
page
analyses
variety
executed
pessimistic
mechanisms
phenomenon
randomly
regains
lock free
c transaction
non blocking
free algorithms
concurrency control
class c
locking algorithms
non locking
conflict rate
vv model
execution time
per class
structure algorithms
k transaction
vf model
permanent slowdowns
concurrent data
blocking algorithm
permanent slowdown
blocking algorithms
optimistic concurrency
closed system
slowdown model
fl c
silent static
p c
class k
response times
transaction class
transient slowdowns
transient slowdown
lock based
system utilization
transaction model
transaction commits
transaction aborts
gammafl c
slow processors
variable time
shared memory
object instance
data items
concurrent objects
shared object
calculate p
transaction conflicts
fixed fixed
dynamic broadcast
blocking queue
f model
committing transactions
locking algorithm
class utilizations
fixed class
time fixed
vf approx
data structure
uniformly randomly
residence time
object protocol
numa architectures
execution times
f c
processor models
aborted transaction
phi k
processor slowdowns
small slowdowns
object pointer
line faults
code 4
ff model
vf models
composite snapshot
data granule
dynamic concurrency
vv transaction
numa architecture
slow operations
slowdown processor
broadcast occ
old object
operation execution
open system
occur due
response time
cache line
b f
v f
b c
validation study
atomic snapshot
e gammafl
data conflicts
memory multiprocessors
analytical models
shared data
locking protocols
code 2
model makes
transaction processing
r c
resource contention
time distributions
expected execution
context switch
exponentially distributed
contention page
use formula
variable fixed
point old
operation executes
makes poor
transaction executes
poor predictions
lock free algorithms
class c transaction
ryu and thomasian
class k transaction
optimistic concurrency control
non blocking algorithm
non locking algorithms
data structure algorithms
non blocking algorithms
executing a class
performance of lock
calculate p c
test and set
b f c
concurrent data structure
per class utilizations
time fixed class
non blocking queue
dynamic concurrency control
calculate the per
cache line faults
slowdowns can occur
closed system model
class 1 class
phi k c
performance of concurrent
permanent slowdown model
calculate the conflict
transient slowdown model
shared memory multiprocessors
compare and swap
transient and permanent
b s c
calculate the probability
expected execution time
time to execute
memory and bus
committing transaction conflicts
page faults context
architectures heterogeneous architectures
large object protocol
variable time fixed
support lock free
transaction in stage
e gammafl c
slowdown processor model
architectures or differences
concurrent data structures
contention page faults
b k seconds
class 2 class
aborts at stage
non blocking data
bus contention page
faults context switching
v f model
static concurrency control
makes poor predictions
lock based concurrent
differences in operation
operation execution time
vv transaction model
due to cache
line faults memory
two transaction classes
numa architectures heterogeneous
transaction is aborted
calculated by taking

corpus/krapavin2000-test/608017.txt
squashing
logistic
regression
roc
dumouchel
mart
likelihood
classication
squashed
empirical
boosted
weights
unweighted
moments
regressions
diminishing
coe
training
bayes
curves
predictor
weighted
owen
cients
score
missing
credit
sampling
reweighting
predictors
weighting
imputed
classiers
benet
sample
stratication
friedman
scoring
variance
proprietary
dierences
gains
hellinger
liebler
equationsn
stumps
variates
condentiality
misclassication
classied
won
ij
bad
accelerates
custom
expect
population
curve
madigan
zm
dms
trees
plotted
correlated
prediction
records
strata
dollar
estimator
predict
dierence
match
boosting
ambitious
kullback
benets
proportion
samples
adjusts
customized
convex
conditional
returns
additive
rst
averages
variances
monte
region
mining
categorical
scaling
euclidean
predicted
probabilities
estimators
withn
lawless
posse
condential
baggerly
overtting
hoadley
wol
semma
prot
volinsky
hesterberg
tibshirani
cochran
unweighed
ridgeway
hastie
unrealized
obfuscating
lohr
nason
underpinnings
splus
mineset
rabinowitz
jerome
nonmissing
staple
pregibon
reweight
bratley
obfuscated
cast
accuracy
regions
settings
column
nn
children
carlo
numerical
maximize
eective
reweights
empirical likelihood
logistic regression
data squashing
dumouchel et
likelihood weights
roc curves
al 1999
diminishing returns
bayes error
squashed data
logistic regressions
roc curve
missing values
likelihood weighted
good cases
likelihood squashing
coe cients
data set
credit scoring
weighted logistic
unweighted logistic
global features
g m
simple random
original data
x ij
likelihood weighting
boosted trees
regression estimator
regression weights
using empirical
sample sizes
classication trees
random sample
training algorithms
predictor variables
weights w
data sets
min v
local features
full data
et al
expect squashing
curves tend
nn h
kullback liebler
variance reduction
equationsn log
share values
conditional moments
speed gains
conditional means
categorical variables
dimensional family
approximate form
m functions
signicant places
non categorical
cases classied
regression coe
predictor values
boosted decision
boosted classication
power p
scoring problem
control variates
increased accuracy
mart models
squashing method
predicted probabilities
zero bayes
proprietary score
regression weighting
n increases
numerical integration
coe cient
order moments
lines correspond
bad cases
likelihood based
max v
smaller sample
error rate
carlo simulation
log f
training data
pairs x
dumouchel et al
empirical likelihood weights
et al 1999
empirical likelihood squashing
empirical likelihood weighted
reasonable to expect
empirical likelihood weighting
simple random sample
weighted and unweighted
using empirical likelihood
likelihood weighted logistic
unweighted logistic regression
zero bayes error
method of dumouchel
accelerates the rate
regression on 8000
credit scoring problem
classied as good
like x 1
expect an error
form of squashing
regression coe cients
ij with y
roc curves tend
m 1 dimensional
used in monte
described in dumouchel
scaling up algorithms
bayes error rate
boosted decision trees
g m x
instead of scaling
logistic regression coe
squashing with global
log f x
al 1999 might
weighted logistic regression
functions g m
boosted classication trees
squashing is used
non categorical variables
approximate form b
point at 0
weighted logistic regressions
data to match
algorithms to large
curves from top
v min v
family of solutions
monte carlo simulation
n m 1
top to bottom
large data sets

corpus/krapavin2000-test/1006425.txt
hypergraph
transversal
branching
mintr
ffn
psi
rossmanith
transversals
niedermeier
branchings
hypergraphs
vertex
mintrnonr
mintrexp
subcase
hitting
vertices
edges
fxg
jhj
yg
kullmann
hyperedges
fx
gammaff
robson
tur
branches
cardinality
dominated
continous
reductions
rank
parameterized
edge
poly
zg
jt
loops
maximally
jv
dualization
stavropoulos
vales
kavvadias
hyperedge
tree
ff
worst
polynomial
branch
pick
running
recursion
exponential
qn
removed
spent
delta
return
uniform
ordinary
runs
care
covered
loop
cover
ae
mining
sat
remember
coloring
filling
formulas
correctness
overestimated
cugs
hypergraps
fzg
caen
meier
transver
berge
solveff
intractabil
dinality
nieder
disjunctive
tuple
intractability
phylogeny
domination
phylogenies
monotonously
deltan
sal
minimal
stirling
confronting
moser
sweden
damaschke
fyg
gammaq
filled
monotone
similarities
proven
labelled
caching
eiter
fvg
obeying
helper
mishra
reduc
formula
tricks
pitt
asymptotics
holland
gottlob
min
article
turned
moon
subcases
deals
lengthy
hg
listen
ceiling
smallest
approximating
biggest
settle
occuring
assignment
balance
calculated
divisions
calculating
biology
fills
catches
mathematics
finding
modification
halting
graphs
reach
maximal
concrete
reached
catch
overly
school
eg
beforehand
imperfect
spends
evolutionary
regardless
trick
tries
degree
consideration
lem
fe
leaf
temporarily
graduate
polynomially
thorough
motivation
np
labels
subgraphs
car
ity
linking
afterwards
seeks
branching number
psi k
minimum transversal
hypergraph h
o 1
branching numbers
running time
hitting set
transversal hypergraph
mintr h
psi 0
f h
case 4
number branching
uniform hypergraph
subcase d
number cases
edge fx
o 2
branching tree
independent sets
exponential space
transversal problem
smallest transversal
hypergraph problem
uniform hypergraphs
fx yg
mintr 0
h 0
r h
rank 3
polynomial space
poly n
d 2
vertex x
minimal transversals
mintrnonr h
gammaff n
ordinary graphs
k formula
case analysis
final case
v 0
worst case
vertex cover
cases 1
jt r
use exponential
fxg 2
algorithm mintr
case branching
maximally reduced
loop fxg
rossmanith 13
maximum d
cases 0
using psi
needs polynomial
search tree
ae v
time o
k 0
min h
r uniform
one 2
maximum independent
n h
related problems
n time
n delta
independent set
every v
f k
return 1
called hyperedges
third branches
empty return
ffn ffn
return fxg
branching tuple
cardinality 3
fx zg
hypergraph transversals
associated hypergraph
monotone disjunctive
since case
approximating coloring
branching b
actual branching
mintrexp h
h return
degree hypergraphs
mintrnonr algorithm
input hypergraph
output smallest
niedermeier and rossmanith
o 1 6737
subcase d 2
number branching number
case 4 subcase
cases for case
psi 0 k
branching number branching
branching number cases
rossmanith s algorithm
transversal hypergraph problem
minimum transversal problem
o 1 6316
number of 2
d 2 x
o 2 270
formula for branching
x is dominated
o 1 6538
cases 1 3
transversal of h
values for psi
o 2 n
time o 1
v 0 ae
runs in o
mintr 0 h
space and runs
jt r h
values of psi
worst case branching
needs polynomial space
hypergraph with n
o 1 6484
edge fx yg
r h j
edges of cardinality
time of mintr
use exponential space
algorithm mintr h
hypergraph h 0
using psi 0
poly n delta
maximum independent sets
one 2 edge
runs in time
time of o
algorithms for related
d k x
give the branching
rank 3 hypergraph
monotone disjunctive normal
fxg 2 h
empty return 1
maximum d x
actual branching numbers
loop fxg 2
r uniform hypergraph
pick a vertex
cases 0 3
occur in h
o poly n
h input hypergraph
efficient fixed parameter
q 2 edges
x with maximum
one worst case
present two algorithms
input hypergraph h
x is continous
every v 0
dualization of monotone
time o 2
sets of bounded
hypergraph h output
h output smallest
polynomial local work
fixed parameter algorithm
problem where one

corpus/krapavin2000-test/610812.txt
computable
solids
computability
rational
solid
prp
countable
dcpo
lebesgue
lub
disks
recursive
continuous
ftt
boolean
tolerances
dyadic
geometry
requicha
membership
theoretic
scott
predicate
pdvs
polyhedra
voxel
deltag
predicates
operators
interval
realistic
uncertain
ux
domains
compact
boundary
converging
modelling
fkjr
lebesgues
polyhedron
effectively
fxg
epsilon
robust
subsets
topology
rectangles
directed
cad
rigid
modeling
fractals
infimum
mathematical
proposition
regular
regularization
domain
tt
partial
hausdorff
truth
observable
unreliable
semi
enumerable
poset
euclidean
ff
maximal
disk
turing
uncertainties
boxes
complement
robustness
neg
inclusion
notions
union
ir
intersection
curved
calculi
functionals
polyhedral
xg
sequences
ae
interior
appendix
defining
tangent
manufacturing
spaces
effective
embedding
beware
lieutier
repr
fnjb
tehran
revis
edalat
esentation
pvds
compactification
bjy
physics
intervals
equipped
closed
equivalently
lambda
recursiveness
ershov
discriminated
ziegler
closure
open
image
segment
outline
classical
uncountable
finitary
ited
abbas
manufactured
enumeration
differential
element
ram
similarities
thinks
dangling
cagd
idealization
rudimentary
coordinates
isomorphic
classically
banach
polynomials
surfaces
consistent
reverse
capture
theoretically
greatest
basis
stronger
metric
endow
behaviour
adjacent
geometric
sound
captured
shrinking
jb
hospitality
regularized
tangential
andr
classifications
methodology
notion
program
algorithmic
wrt
catastrophic
oo
cauchy
idealized
partially
requirement
horizontal
measuring
unsatisfactory
downward
mathematics
situations
topological
epsrc
sign
entail
unavoidable
endowed
digits
stands
solid domain
partial solids
domain theory
boolean operators
partial solid
solid modeling
domain theoretic
interval disks
semi computable
recursive analysis
r e
rational numbers
membership predicate
interval domain
lebesgue computable
rational polyhedra
effectively given
countable basis
increasing sequence
regular sets
continuous domain
computable partial
boundary representation
real numbers
theoretic approach
ftt ff
continuous membership
non computable
recursive partial
compact subsets
basis elements
maximal elements
real number
computational geometry
rational interval
rigid solids
open set
ff g
gamma g
computable real
computable sequence
proposition 3
robust algorithms
machine model
continuous domains
f gamma
computable function
v b
rational polyhedron
dyadic voxel
computable computable
lebesgue measures
robust interval
best continuous
upper space
directed subset
cad situations
every open
every directed
voxel set
reverse inclusion
sub rectangles
r n
computable non
scott open
scott topology
observable properties
least upper
two partial
exact real
solid modelling
domain d
every element
consistent set
non regular
partial order
real functions
ae r
set theoretic
truth table
mathematical model
least element
b 2
recursive function
mathematical theory
fkjr k
finite part
subset o
ram machine
real solids
correct algorithms
computable elements
unreliable programs
membership predicates
domain introduced
basic scott
modeling operators
representation modelling
increasing chain
finite program
purpose computer
bound lub
valid polyhedral
interval solid
empty compact
real ram
computable however
actual robust
effective limit
exists a program
program to compute
sequence of rational
domain theoretic approach
notion of computability
element a b
b a b
compute an increasing
f gamma g
ftt ff g
see the appendix
two partial solids
non regular sets
solid a b
consistent with requirement
computable non computable
scott open set
rational interval disks
recursive partial solids
predicates and operations
every directed subset
computable partial solid
least upper bound
ae r n
set of output
set theoretic aspects
computable partial solids
given for every
data 8 19
dyadic voxel set
continuous membership predicates
r domain theory
best continuous approximation
lower semi computable
dcpo we say
sequence of prp
lebesgue computable partial
computability on subsets
upper bound lub
effectively given continuous
analysis and domain
uncertainties of input
actual robust algorithms
ordered by reverse
domain theory used
theory of computability
methodology for actual
capture the uncertainties
every open subset
partial or uncertain
represent regular sets
semantics in data
r is computable
framework for solid
two increasing sequences
real ram machine
towards robust interval
non empty compact
continuous membership predicate
general purpose computer

corpus/krapavin2000-test/635238.txt
irup
cutting
stock
csp
trim
zz
instances
km
divisible
dz
piece
pieces
pattern
feasible
relaxation
dominant
gap
mirup
ea
gaps
maximal
patterns
investigations
proper
lp
csps
fulfilled
assertion
iq
families
cut
nica
family
integer
material
belong
eg
relaxations
packing
residual
knapsack
dominance
possesses
round
pe
fulfilling
possessing
equivalence
fulfills
cf
delta
abbreviation
demands
prime
pairwise
ed
lengths
reels
wooden
roundup
supplementing
unpacked
fmg
gau
ng
dimensional
inequalities
tends
belongs
loss
units
gilmore
deltae
gomory
structur
continuous
contradiction
ql
dominates
rational
impression
lim
initiated
fulfil
asymptotically
mj
concluding
ld
implemen
tations
integral
lexicographically
counterexample
conjectured
demand
possibilities
fulfill
plane
rounding
arise
tend
said
counter
unlimited
branch
heuristics
z
interval
omitting
decade
nd
equals
duality
cone
gamma
sufficiently
remarkable
shortly
violating
summarizing
possess
intractability
increased
arises
tighter
matrix
rarely
bin
inequality
generality
ae
infinity
supposed
remarks
especially
separating
pi
ir
succeed
smallest
characterized
modelled
fifth
index
infinite
substitution
ratios
analogously
ff
published
tests
conjecture
decreasing
difficulties
constructive
identified
constructions
remember
comprehensive
fl
ith
negative
observations
numerous
coefficients
relatively
identification
odd
notations
importance
mostly
named
modified
completeness
sizes
largest
inherent
covered
occurring
versa
verify
sake
non irup
irup instances
cutting stock
instance e
stock problem
z c
cutting pattern
cutting patterns
divisible case
zz m
dimensional cutting
dz c
instances e
proper pattern
trim loss
non equivalent
k instances
delta e
integer round
continuous relaxation
c e
one dimensional
maximal cutting
irup instance
stock material
trim less
e dz
feasible pattern
non dominant
equivalent non
e p
lp relaxation
e 0
piece lengths
less pattern
ed defined
pattern matrix
maximal pattern
equivalent instances
show z
irup 1
total trim
order demands
stock problems
modified integer
pairwise relatively
negative integer
k 2
e hence
relatively prime
p 1
z e
integer solution
m proof
j d
gaps tend
exist non
instances belong
theoretical investigations
dominant cutting
cutting plane
km km
relaxation bound
gap equal
proper patterns
k instance
stock length
feasible patterns
asymptotically bounded
dominant patterns
pattern ea
irup k
gap delta
order demand
ng denote
lim p
smallest piece
instance presented
dimensional csp
small gap
dominance let
p units
knapsack problems
property irup
j nd
e k
exact solution
m 1
k e
index set
z z
e pattern
solution approach
maximal patterns
problem csp
non irup instances
cutting stock problem
respect to e
belong to m
dimensional cutting stock
one dimensional cutting
feasible with respect
z c e
pieces of length
pattern a j
round up property
zz m 1
families of non
e dz c
non irup instance
non equivalent non
l 2 zz
equivalent non irup
dz c e
maximal with respect
feasible for proof
instance e p
trim less pattern
exist any proper
piece of length
irup 1 k
defined in 3
family of instances
total trim loss
maximal cutting pattern
times the pattern
since the gaps
cutting stock problems
modified integer round
instance e 0
patterns a j
non irup 1
non negative integer
pairwise relatively prime
consider the instance
cannot be cut
equivalent to e
family of non
c e e
e is also
algorithms and computer
tend to 1
exact solution approaches
pattern a dominates
relaxation of e
cutting and packing
c if z
exists a column
belongs to d
stock problem csp
lim p 1
instances can also
least one piece
gap delta e
p of instances
delta e 1
exist non irup
non dominant patterns
column a k
dominant cutting patterns
non irup k
instances with k

corpus/krapavin2000-test/633709.txt
nns
performances
nn
stepdisc
regression
bonnlander
ruck
selection
relevance
saliency
neural
leray
moody
czernichow
cibas
criterion
ecd
backward
ocd
obd
dorizzi
classification
derivatives
yacoub
refenes
hessian
feature
retraining
damage
pruning
validation
training
mutual
sv
weight
stopping
monotonous
mse
derivative
stepwise
perf
prediction
parametric
measures
wilks
kittler
frontier
criteria
wave
stop
fisher
correlated
multilayer
recognition
brain
forward
ard
statistical
coefficient
noisy
rossi
obs
learning
stopped
pathological
frontiers
discriminating
hypothesis
mclachlan
epanechnikov
souli
fogelman
ebd
saliencies
priddy
hajlmarsson
ssr
intensive
heuristic
entropy
prohibitive
sensitivity
weights
ingredients
computationally
eliminated
percentage
fukunaga
surgeon
fraser
regressor
aberrant
gustafson
axis
ranking
battiti
retrained
networks
outputs
cell
variance
risk
absolute
gaussian
narendra
perceptrons
mlp
bootstrapping
estimates
representative
rely
density
threshold
estimated
correlations
nonparametric
generalization
floating
estimation
correlation
fs
trained
heuristics
network
search
feedforward
perceptron
uncorrelated
cross
squared
hidden
wrt
selects
classical
meaningless
fitted
discriminant
attractive
modelling
bayesian
deletion
subsets
diagonal
dependencies
neurons
exhaustive
statistics
restrictive
statistic
difficulty
error
layer
differentiable
averaged
branch
confidence
salient
deletes
artificial
selecting
discarding
regularization
kernels
gradient
variation
marginal
covariance
costly
selected
determinant
gasca
swinney
wertz
pertinence
hermans
kullbak
econometrics
representativeness
rdle
infraction
committees
stahlberger
multinormal
baxt
utans
feature selection
variable selection
selection methods
selected variables
mutual information
neural networks
choice criterion
validation set
weight pruning
relevance measures
stop criterion
l l
generalization error
sv p
order methods
wave problem
p selected
backward search
different variable
non linear
performance comparison
variables perf
selected variable
correlated variables
stepdisc 4
feature evaluation
good performances
non pathological
axis percentage
cell damage
method p
bonnlander 4
variable set
x l
pattern recognition
selection method
variable subset
evaluation criterion
parametric methods
c r
cross validation
neural network
evaluation criteria
f x
r p
fisher test
model independent
pure noise
moody 5
gaussian problem
stepwise methods
fs p
relevance measure
variable relevance
two gaussian
refenes 5
dorizzi 5
czernichow 5
architecture selection
original wave
floating search
x f
linear models
input variables
al 1996
several authors
noise variables
based feature
remaining variables
final prediction
prediction error
training set
non parametric
l x
methods use
best subset
best performances
input variable
class j
two weight
p 1
et al
correct classification
f c
several methods
absolute values
authors use
optimal search
computed using
computationally intensive
density estimation
linear regression
al 1994
p b
model selection
search methods
diagonal approximation
cibas leray
since variables
backward methods
noisy wave
regressor f
p variables
variables bonnlander
refenes et
fogelman souli
representative methods
branch bound
dependence measure
stop criteria
discriminating power
relevance criterion
fixed threshold
data refenes
early brain
set sv
early cell
derivative absolute
wilks lambda
nn variable
variable selection methods
different variable selection
feature selection methods
l l l
p selected variables
f c r
comparison of different
method p selected
feature selection method
selected variable set
selected variables perf
r p 2
stepdisc 4 2
bonnlander 4 3
l l x
x l l
may be used
either for regression
selection is stopped
original wave problem
l x x
moody 5 2
dorizzi 5 2
pure noise variables
czernichow 5 2
refenes 5 2
selection for neural
using a validation
methods which use
two gaussian problem
f x l
percentage of selected
compute the mutual
sv p 1
et al 1996
take into account
f x f
x f x
non linear models
classification and regression
proposed to use
p a b
sets of variables
et al 1994
set sv p
using mutual information
methods in feature
perf stepdisc 4
optimal cell damage
o the importance
c r non
l sv p
percentage of variables
fs p forward
variable is found
variables selected y
cibas 5 3
table 1 selection
p th variable
variable is usually
early cell damage
priddy et al
noisy wave problem
bonnlander s method
validation set since
correlations between variables
methods vs percentage
nn is trained
stopping the selection
families of methods
refenes et al
gustafson and hajlmarsson
bottom of table
several methods propose
time series modelling
proposed a series
simple backward search
allows to take
validation or algebraic
fitted for nns
pathological data refenes
feature selection pattern
data refenes 5
variables the second
ruck 5 2
sub optimal search
order methods several
leray 5 3
ingredients of feature
partial correlation coefficient
zero order methods
regression or classification
propose two weight

corpus/krapavin2000-test/1007547.txt
xpath
xml
stockid
promela
msl
requestlist
macro
register
translation
wsat
web
exp
conversation
int
document
intvalue
gfsa
outtree
services
gk
schema
intree
spin
mtype
blank
ltl
gencode
sas
payment
message
fig
boolean
guard
service
verification
investorid
accountnum
investor
insertandreplace
attribute
request
sb
inv
qualified
tag
node
macros
expressions
parent
location
declaration
stock
wsci
markchild
tree
transition
checker
bill
ret
hashtable
string
cancel
jwig
markall
embedment
bresult
typedef
xsd
matchinsert
creditcard
expression
handling
owner
standards
peers
mode
manipulation
predicate
rd
documents
init
var
intermediate
specification
code
split
semantics
synthesized
paths
tags
index
reject
latest
operator
composite
ack
array
peer
indices
predicates
stockids
unranked
owl
insertall
bpel
position
prefix
fragment
marked
leaf
iis
sent
root
blanks
subexpressions
interacting
composition
syntax
segment
protocol
op
appearance
declared
automata
markup
bandera
wildcard
names
motivating
inherit
children
evaluates
child
nsf
trees
pre
name
embedded
records
facto
realizability
broker
occ
ccr
efforts
path
business
delicate
attributes
generates
protocols
exchange
skip
quadruple
msg
career
java
translating
guards
arithmetic
flows
manipulating
initialization
basically
manipulate
terminal
translated
registration
msl type
location path
xml document
web services
xpath expression
xml data
type tree
promela code
xpath expressions
location paths
type node
translation algorithm
web service
xml schema
tree sequence
register message
msl types
equation 2
xml variable
promela translation
macro tree
boolean xpath
int 5
data manipulation
node test
composite web
requestlist stockid
xpath location
step stockid
last call
node indices
model checker
xml tree
conversation protocols
variable register
qualified names
c d
xml documents
software systems
basic type
code segment
absolute location
integer variable
node 5
last stockid
statement macro
type trees
register requestlist
analysis service
tree sequences
index i1
marked node
empty macro
position last
lines 51
qualified name
message classes
tool wsat
latest request
conversation protocol
pre calculation
ltl property
document tree
stock analysis
test n
register stockid
relative location
input c
model checking
hand side
request message
web based
syntax rules
service analysis
intermediate type
boolean expression
root node
right hand
normal mode
techniques presented
fig 5
output node
input node
type declaration
transition condition
ltl properties
processed mode
step int
corresponding promela
stockid i1
payment accountnum
int intvalue
k split
end model
bounded xml
xml manipulating
attribute definition
stockid position
parent reference
attribute var
xsd int
function gencode
else skip
side corresponds
exchange xml
conversation specification
transition t8
macro trees
copy mode
xpath 22
node value
manipulating software
parent type
schema 23
single xml
xml data manipulation
example 2 3
input c d
boolean xpath expression
tree in fig
xml variable register
n c d
composite web services
node test n
verification of web
msl to promela
stock analysis service
xpath location paths
based software systems
value of last
web service analysis
service analysis tool
relative location path
message being sent
web based software
analysis tool wsat
xpath to promela
right hand side
shown in fig
set of macro
translation of xpath
bounded xml data
xml tree sequence
corresponding type tree
verification of xml
promela code segment
xml schema 23
xml manipulating software
stockid i1 intvalue
input type node
hand side corresponds
register requestlist stockid
g t g0
translation of equation
latest request message
semantics of xpath
xml document tree
macro is generated
given an xml
absolute location path
constitute the basis
leaf node value
document in fig
composition of web
back end model
set of node
path for example
evaluates to true
model checking techniques
presented in fig
side of equation
given in example
g if g
set of values
left to right
requestlist stockid 0001
analysis of interacting
generated promela code

corpus/krapavin2000-test/1016857.txt
macros
mrflow
regexp
macro
format
schemeql
syntax
formatting
string
embedded
interpreters
tmp
stx
plt
match
matcher
runtime
languages
printf
cursor
continuation
invariants
interpreter
analyses
arguments
subs
drscheme
library
combinators
primitive
specifier
datum
dispatch
expression
lisp
positives
char
regular
lambda
statically
false
host
errors
combinator
language
clock
expressions
args
compiler
strings
lexical
identifier
transformer
cons
programmers
flow
cayenne
hygienic
ghost
submatch
submatches
quoted
expansion
hoc
unfolding
swap
tags
literal
guard
hex
aaa
subpatterns
exp
static
pseudo
template
append
contexts
programs
functional
substring
anal
ad
matched
specialize
primitives
program
partially
bbb
suc
parenthesized
query
id
hindley
componential
hygiene
hexadecimal
augustsson
unparsing
formatter
car
ysis
arrow
precision
guage
consume
matches
partial
programmer
subexpression
alternation
succeeds
prefixed
zzz
subpattern
subexpressions
spurious
lookup
abstract
rules
pattern
conservative
imprecise
analyzing
identifiers
simulates
specialized
ocaml
implementor
renames
compositionally
expand
expansions
laying
flagged
analyzer
disappear
tag
http
excerpt
flowing
argument
operator
raise
undetected
precise
accepts
invokes
debugger
kleene
referential
failure
milner
underlined
references
java
row
binds
arrows
flows
haskell
phone
lan
list
inspect
binding
contents
forms
syntactic
cond
specializing
conservatively
inside
overloading
gcd
checking
character
expanded
constructs
matching
displayed
expects
cess
branch
discover
wrong
branches
rewrite
transparency
invoked
text
edu
server
evaluated
success
object
exposed
url
regexp match
embedded languages
partial evaluation
regular expression
syntax object
plt scheme
syntax rules
host language
macro expansion
embedded interpreters
embedded programs
abstract value
syntax id
id rules
scheme macros
formatting string
partially evaluating
syntax case
format char
static analysis
embedded language
format specifier
failure continuation
format primitive
string append
stx syntax
compiler macros
lambda stx
let tmp
set based
dependent types
three elements
false positives
library functions
partially evaluated
macro system
type system
object datum
define syntax
lookup subs
cons lookup
pseudo type
value flow
case stx
known statically
embedded program
transformer procedure
clock e
pseudo types
precise analysis
result list
specific embedded
ad hoc
regular expressions
original function
additional arguments
based analysis
first argument
flow analysis
program analysis
case dispatch
format function
analysis cannot
schemeql query
tag corresponds
pattern guard
success continuation
z line
partially evaluate
runtime errors
macro template
append format
dispatch second
closure analysis
format hex
tmp tmp
aaa bbb
spurious errors
second pattern
three embedded
formatting language
third r
set clock
string given
compute precise
bbb edu
match http
type checking
domain specific
based program
might evaluate
second r
imprecise analysis
hoc manner
abstract values
scheme program
rules form
expression language
term 3
present case
syntax id rules
cons lookup subs
lambda stx syntax
stx syntax case
syntax object datum
syntax case stx
set based analysis
evaluation of embedded
either a list
number of arguments
second and third
specific embedded languages
based program analysis
string append format
http a z
value flow analysis
regexp match http
append format char
aaa bbb edu
regular expression language
three embedded languages
rules and syntax
using partial evaluation
ad hoc manner
flow of values
list of three
domain specific embedded
z a z
http aaa bbb
raise syntax error
implemented as macros
derived expression forms
format s exp
macros to partially
ad hoc solution
swap a b
whether partial evaluation
embedded languages contain
flow sensitive analysis
graph that simulates
regexp match returns
formatting a class
set clock e
syntax object representing
case stx swap
clock e clock
subs cons lookup
tmp tmp e2
let tmp b
value from flowing
specialize dependent types
embedded in scheme
tmp b set
web with high
returned by regexp
r process url
analysis of regexp
dispatch second r
chain of cons
bbb edu zzz
regexp match figure
r dispatch second
match a b
syntax rules form

corpus/krapavin2000-test/614387.txt
octant
streamline
streamlines
octants
visualization
cells
core
octree
disk
tetrahedral
unstructured
cell
megabytes
coordiates
workstation
mbytes
block
queue
fetching
preprocessing
graphics
memory
interactive
rendering
meshes
kurc
tahsin
tests
cludio
millions
saltz
million
paging
pool
waiting
silva
virtual
particle
resident
ready
overhead
streamtubes
chialin
joel
calculations
scientists
interpolation
initialization
airplane
workstations
grids
tracing
seed
ueng
shyh
file
blocks
eight
sussman
scientist
farias
neighboring
streaming
mid
vm
kuang
finished
partitioning
node
created
sparc
fetch
coordinate
sun
policy
id
integration
catalyurek
nickolas
streamribbons
atalyrek
ribarsky
coefficients
stored
mesh
released
scheduling
timing
files
chunk
jen
claudio
kenneth
child
calculating
constructing
ricardo
seconds
ibm
william
october
indices
kuester
falko
faust
connectivities
bruckschen
moran
chunks
operating
management
record
program
resolution
storing
ellsworth
joy
umit
hamann
allocated
queues
chang
visualizing
precomputed
wall
buffers
redundancy
grid
cancels
irregularity
face
positions
read
initiate
octrees
schroeder
unsteady
alan
searching
concurrently
connectivity
volume
fly
tunnel
bernd
san
velocity
store
interactivity
celebrating
ralph
stores
costs
transformation
chiang
searched
cfd
isosurface
overload
preemption
flow
raw
dedicated
reveal
spatial
davis
jiang
sharing
minutes
california
moderate
field
intersect
bounding
united
resolutions
wind
diego
enter
conducted
carolina
bytes
eurographics
fields
center
attain
swapping
multiresolution
fluid
octant size
maximum octant
memory space
size level
streamline construction
node node
block size
core program
main memory
streamline visualization
streamline object
local disk
tetrahedral cells
data node
octant table
test results
virtual memory
data set
solution data
core method
space pool
million cells
streamline objects
cell record
z coordiates
data sets
average cost
waiting queue
data size
ready queue
non local
large unstructured
coordinate transformation
memory management
coordiates node
interactive streamline
constructing streamlines
level maximum
core algorithm
finished queue
free space
management policy
data partitioning
times figure
disk files
memory blocks
preprocessing step
tahsin kurc
data visualization
y z
mbytes 4
streamline calculations
one octant
octant fetching
transformation functions
constructing 100
core approach
program maximum
child octants
joel saltz
disk space
interactive visualization
unstructured grids
data preprocessing
cell indices
neighboring cell
core rendering
space size
initialization cost
core streamline
total cost
computer graphics
memory block
tetrahedral meshes
operating system
large data
unstructured grid
interpolation functions
data redundancy
single step
ieee computer
preprocessing stage
memory based
july 2001
size 40
eight child
one streamline
octant containing
mid range
longer involved
mbytes 8
data fetching
four million
size initiate
vm based
octree structure
sparc 20
streamlines concurrently
streamline scheduling
initiate construct
step computation
construct total
visualization calculations
chialin chang
grid data
three parameters
vector field
many smaller
remaining memory
visualization software
alan sussman
size 10
maximum octant size
block size level
node node node
non local disk
solution data node
y z coordiates
memory management policy
size level maximum
z coordiates node
free space pool
level maximum octant
time the block
conference on visualization
cost of constructing
millions of tetrahedral
cludio t silva
tests are conducted
memory space size
constructing 100 streamlines
mbytes 4 times
virtual memory based
data from disk
neighboring cell indices
timing of program
set of tests
program maximum octant
applications v 21
visualization of large
size is set
graphics and applications
ieee computer graphics
unstructured grid data
size 10 000
number of streamlines
size initiate construct
eight child octants
achieve interactive visualization
octant size 40
single step computation
data size initiate
number of octants
streamlines are constructed
fly during streamline
megabytes of main
mbytes 8 times
cost and overhead
main memory space
four neighboring cell
program performs better
size 40 000
sun sparc 20
interactive streamline visualization
initiate construct total
coordinate transformation functions
streamlines by using
octant size 10
coordinate transformation function
visualization and graphics
unstructured tetrahedral meshes
core streamline visualization
remaining memory space
number of time
number of cells
shyh kuang ueng
v 21 n

corpus/krapavin2000-test/1013859.txt
beta
lattices
pv
lattice
quasicrystals
tiling
delaunay
tiles
meyer
crystallographic
integers
symmetry
tilings
rotations
plane
cyclotomic
crystals
rotational
pisot
tile
rotation
law
algebraic
quasiperiodic
laws
distributive
asymptotic
quadratic
ring
additive
expansion
multiplication
asymptotically
multiplicative
translations
counting
bravais
crystallography
quasicrystallographic
vijayaraghavan
parry
galois
quadrilateral
rotationally
group
crystal
conjugate
decorated
periodic
abelian
elementary
cos
artin
recurrence
invariant
freely
decoration
pentagonal
penrose
schreier
fold
behaviour
actions
invertible
associative
conjugates
isometries
internal
shall
substitution
arithmetics
groups
appendix
self
denser
proposition
action
semi
translational
alphabet
units
eventually
regime
sl
joining
generically
ordinary
vertices
similarity
ls
symmetries
leaving
equivalently
endowed
operators
distortion
ss
isomorphic
integer
assert
thinking
canonical
contraction
rings
composition
quasimultiplicative
distorts
nombres
imitating
quasiadditive
quasicrystalline
bieberbach
conjugation
quasicrystal
arithmetically
myampersandbgr
dodecagonal
reexpressed
decagonal
harmonique
motives
consequence
ll
ball
horizontal
deduced
inversion
mathematical
cited
sgn
moduli
aperiodicity
superpositions
perron
packings
imitation
decorate
potentiality
historically
noncommutative
zeros
letters
axis
acting
infinitely
said
hopeless
game
z
infinite
bertrand
idealization
indi
dense
behaves
displayed
duals
equip
golden
easiest
recover
article
aperiodic
endow
hexagonal
plication
salem
delicate
eligible
richness
radius
kind
adapted
orbit
erently
realm
compatible
digit
tempting
ergodic
trivially
bm
inclusions
deformed
classical
spheres
merit
symmetrical
striking
countable
origin
rotates
ered
digits
beta integers
beta lattices
lattice 1
beta lattice
quadratic pv
delaunay set
beta expansion
b n
pv number
point sets
symmetry group
case 2
pv unit
plane group
meyer sets
case 1
pv units
rotational properties
meyer set
plane groups
z z
r d
eventually periodic
internal laws
point group
beta integer
algebraic integer
asymptotic behaviour
freely generated
r q
semi direct
u q
rotationally invariant
counting function
self similarity
r n
direct product
mathematical quasicrystals
canonical alphabet
counting system
delaunay sets
like lattices
multiplicative properties
quasicrystallographic numbers
rotation actions
quadrilateral tile
adapted rotations
bravais lattices
elementary quadrilateral
trivial tiling
invertible operators
pisot vijayaraghavan
set z
joining points
n fold
lattices 1
direction defined
symmetry plane
abelian group
real numbers
q l
q b
points left
group structure
new internal
cos 2
point set
n z
sets based
proof case
holds true
points along
result proposition
set r
appendix b
r 1
asymptotically like
tiles l
ordinary multiplication
counting systems
cyclotomic pv
ordered ring
crystallographic groups
translational properties
artin schreier
lattice case
additive group
elementary tiles
observed quasicrystals
group structures
extended rotations
tiling obtained
crystallographic group
given beta
two tiles
ls sl
fold bravais
quasiperiodic point
positive beta
crystallographic cases
set of beta
distributive with respect
quadratic pv unit
group of 1
beta lattice 1
quadratic pv units
additive and multiplicative
z z z
q b n
symmetry of order
semi direct product
together with q
b n z
point sets based
joining points along
new internal laws
expansion of 1
based on beta
rotations and beta
conjugate is 1
defined on 1
n 2 1
axis and along
r n 2
number of letters
along the horizontal
proof case 1
along the direction
addition and multiplication
tilings and lattices
definition of multiplication
positive beta integers
build the point
radius r contains
exists k z
elementary quadrilateral tile
algebraic integer 1
rotation operator r
lattices in r
recover the definition
group for beta
operators are defined
class of beta
groups for beta
quasiperiodic point sets
say that every
operator r 1
q are defined

corpus/krapavin2000-test/635905.txt
bdy
frontwidth
fem
boundary
stiness
cholesky
jv
numbering
meshes
dissection
partitioning
mesh
concentrated
shape
subdomains
dist
factorization
jvj
steklov
balanced
geometric
bem
nnz
poincare
frontwidths
chol
vn
dirichlet
regularity
hp
cone
denition
neumann
ops
fk
nested
sparsity
triangle
psfrag
rened
recursion
tn
dene
yn
remark
fig
proposition
neighbor
matrix
bsp
subdomain
denite
replacements
sparse
vectors
triangulation
elliptic
conrm
freedom
edge
log
assembling
schur
polylogarithmically
dims
dimvn
degrees
triangulations
degree
hk
interior
supp
clover
cients
coe
satised
figs
vertex
2d
storage
unknowns
fe
spaces
analytic
lemma
verbatim
exposition
jx
nn
operator
submatrices
delaunay
preconditioner
slope
cient
rst
estimates
nite
tangential
oating
un
center
dened
estimate
solver
toward
square
smooth
vertices
eectiveness
sup
cn
thick
vanish
polynomial
nodes
variational
numerical
symmetric
neighbors
multiplications
uniformly
expect
guidelines
arising
cf
mixed
internal
multiplicity
node
cjvj
shewchuck
analyticity
bdya
holdsjv
columnwise
trefethen
fhx
cea
profs
barycenter
withanitedimensionalsubspace
dumbbell
njg
cuthill
diamk
picture
logarithmic
trace
complement
ll
violated
vector
triangles
ciently
enumerate
visible
element
refinement
motivates
hanging
poole
ruppert
kuk
inmum
mckee
hackbusch
approximation
median
collected
constants
mention
quasi
realization
rigorous
numerically
justies
legendre
coercivity
lef
equilateral
sobolev
associate
suited
splits
shape functions
boundary concentrated
concentrated fem
algorithm 3
stiness matrix
nested dissection
linear degree
geometric meshes
geometric mesh
cholesky factorization
partitioning vector
partitioning vectors
degree vector
cone condition
jv bdy
polynomial degree
v bdy
v left
internal shape
example 4
element k
shape function
v right
poincare steklov
denition 2
size h
hp fem
sparsity pattern
boundary mesh
partitioning strategy
dist x
q balanced
degree vectors
remark 3
mesh size
boundary conditions
node numbering
binary space
examples 4
lemma 3
proposition 3
jv j
steklov operator
right j
bdy j
rened toward
edge shape
dist dist
side shape
element method
space partitioning
nodes v
log 2
functions associated
psfrag replacements
factorization scheme
dissection algorithm
condition 3
symmetric positive
cholesky factor
nite element
dirichlet problem
logarithmic complexity
reference element
left v
bdy starting
dissection v
vertex shape
n frontwidth
chol sec
k bdy
direct solver
solution u
function associated
storage requirement
positive denite
example 3
standard basis
boundary shape
mixed boundary
r nn
j jv
numbering scheme
slope 0
linear logarithmic
edge e
see fig
degree p
figs 5
schur complement
node v
number n
problem size
boundary point
sets v
n 0
log 4
half spaces
point b
theorem 2
n log
log n
coe cients
boundary concentrated fem
algorithm 3 10
algorithm 3 9
linear degree vector
algorithm 3 2
lemma 3 4
boundary mesh size
neighbor in h
mesh size h
denition 2 7
condition 3 9
linear degree vectors
shape functions associated
cone condition 3
mesh with boundary
binary space partitioning
internal shape functions
theorem 2 4
meshes and linear
shape function associated
nested dissection algorithm
ops t chol
side shape functions
poincare steklov operator
jv bdy j
number n 0
log 2 n
degrees of freedom
example 4 3
sense of denition
examples 4 1
symmetric positive denite
linear logarithmic complexity
results are collected
triangle s output
reference element k
v left v
describing the geometric
expect the frontwidth
jv j h
collected in table
associated with edge
left v right
nested dissection v
edge shape functions
cholesky factorization scheme
v bdy starting
picture of fig
log n frontwidth
j h 1
figs 5 6
example 4 5
mixed boundary conditions
example 3 11
proposition 3 1
set of nodes
problem 2 1
points in space
o log 2
example 3 3
near the boundary
example 4 1
denote by v
proposition 3 6
o n log
system of linear
finite element method
denition 2 1
bdy the partitioning
psfrag replacements x
shape functions v
choice of partitioning
clover leaf log
replace the square
cholesky factor l

corpus/krapavin2000-test/606722.txt
preconditioner
schur
ainv
nonsingular
inverse
markov
irreducible
complement
singular
matrix
ilu
sep
tot
sparse
preconditioning
separator
ldu
preconditioners
inverses
diagonal
approximate
cgstab
factorization
matrices
krylov
preconditioned
biorthogonalization
chains
penrose
ncd
nonsymmetric
mutex
leaky
incomplete
nonnegative
avg
dom
triangular
bi
processors
nonzeros
factorized
telecom
minors
density
subspace
stationary
chain
frobenius
partitioning
nonzero
subdomain
sparsity
nonsingularity
aq
qn
spai
dropping
generator
factorizations
iterative
block
pseudoinverse
conjugate
aa
gamma
structurally
moore
principal
entries
gn
ups
precondi
dayar
cimmino
subgraphs
schmidt
ergodic
subdomains
stochastic
2d
factors
parallelization
dense
numerical
queueing
null
scalability
pivot
entry
iterations
perron
thetam
tioning
jacobi
generalized
processor
ir
nnz
convergence
parallelize
reducible
irreducibility
projector
gram
norm
blocks
solvers
gmres
cardinality
oblique
drop
tables
inversion
lu
reliability
neumann
symmetric
inner
leading
seidel
pivoting
ods
meth
gauss
products
coefficient
inexact
grows
row
accumulation
timings
invertible
converging
breakdown
page
arising
multilevel
smoothly
gradient
wavelet
multiplicity
axjj
entrywise
symmetrizable
tril
grul
ffii
platis
splittings
aliakbar
vectorize
onauer
triu
maglogiannis
relativeley
montazer
agapios
arator
straightfoward
ilias
metis
mishev
schur complement
m matrix
approximate schur
approximate inverse
sparse approximate
nonsingular m
separator set
tot time
p density
singular m
p time
markov chains
avg dom
sep size
singular irreducible
ainv algorithm
irreducible m
inverse factors
markov chain
graph partitioning
krylov subspace
generalized inverse
bi cgstab
chain problems
ldu factorization
table matrix
m matrices
inverse preconditioners
diagonal blocks
null space
generator matrix
generalized inverses
biorthogonalization process
group inverse
leading principal
exact schur
principal minors
u gamma1
subspace methods
time 1
z 11
approximate inverses
inverse preconditioner
incomplete process
linear systems
moore penrose
parallel preconditioner
matrix hard
upper triangular
distribution vector
nonsymmetric linear
preconditioned krylov
z matrix
test problems
hard p
unit basis
approximate 1
diagonal block
diagonal entry
subspace method
schmidt process
aa gamma
ilu methods
ergodic markov
incomplete factorization
unit upper
drop tolerance
preconditioner construction
structurally symmetric
unit lower
row stochastic
average subdomain
ilu factorization
gn r
dimensional null
singular case
iterative solvers
approximate inversion
irreducible singular
generalized gram
markov process
l gamma1
inverse techniques
finite markov
factorized sparse
large markov
ainv preconditioner
two level
u 11
gram schmidt
factorized form
parallel implementation
markov models
numerical experiments
last one
m gamma1
nonzero entry
queueing network
coefficient matrix
diagonal matrix
large state
speed ups
see 26
approximate schur complement
nonsingular m matrix
sparse approximate inverse
singular m matrix
singular irreducible m
irreducible m matrix
markov chain problems
approximate inverse preconditioners
krylov subspace methods
leading principal minors
exact schur complement
approximate inverse preconditioner
q t aq
preconditioned krylov subspace
approximate inverse factors
z and w
nonsymmetric linear systems
sparse approximate inverses
large markov models
p time 1
matrix hard p
finite markov chains
hard p time
incomplete a biorthogonalization
singular m matrices
krylov subspace method
pseudoinverse a y
gram schmidt process
dimensional null space
compute the preconditioner
unit upper triangular
irreducible singular m
one dimensional null
nonsingular m matrices
generalized gram schmidt
p time 0
approximate 1 2
factorized sparse approximate
approximate inverse techniques
solution of markov
number of nonzeros
number of processors
number of iterations
comparison of partitioning
set is small
table matrix p
nonsingular approximate schur
telecom p time
ir m thetam
theory of nearly
m matrix proof
level iterative solvers
systems a fast
solution of nonsymmetric
formed and stored
matrix p time

corpus/krapavin2000-test/606904.txt
smoothing
burke
complementarity
newton
predictor
corrector
pcx
fw
optimality
convergence
subsequence
xu
pilot
nonlinear
continuation
noninterior
interior
centering
ncp
superlinear
cholesky
primal
iterates
chks
converges
accumulation
font
netlib
mangasarian
dierentiable
boundedness
nesm
maros
harker
perold
kanzow
monotone
reformulate
iterate
monotonically
ng
inequalities
inequality
armijo
smale
inexactly
dened
rst
behaviour
updating
variational
numerical
sparse
perturbed
central
exible
jacobian
nal
statement
satises
recipe
stepsize
quadratically
concave
equations
chen
cf
lemma
uence
nonsingular
uniprocessor
aa
proposition
simplex
strictly
converging
stopping
signicantly
objective
fx
linearcomplementarity
truss
standgub
greenbea
standata
ganges
brandy
standmps
nonsmoothness
forplan
scorpion
greenbeb
adlittle
algorithm 2
smoothing type
optimality conditions
fw k
conditions 2
xu 3
type methods
complementarity problems
interior point
sequence fw
k g
predictor step
smoothing parameter
smoothing method
property p
nonlinear system
linear programs
global convergence
k generated
central path
smoothing functions
accumulation point
point methods
k 2
predictor corrector
convergence properties
sparse cholesky
f k
lemma 2
strictly feasible
noninterior continuation
sub font
centering parameter
problem objective
w k
path conditions
feasible point
continuation method
type method
nonlinear complementarity
x k
linear complementarity
line search
chks functions
constrained variational
properties p
smoothing newton
quite popular
using chks
nal iterate
superlinear convergence
corrector smoothing
non interior
chen mangasarian
mangasarian smoothing
global linear
well dened
updating rules
minimum function
newton type
box constrained
corrector step
numerical results
smoothing methods
newton method
rst note
fx k
variational inequalities
r n
theorem 3
proposition 3
monotonically decreasing
become quite
continuously dierentiable
linear systems
p 3
sequence f
linear system
font size
sequences fx
pilot 1368
nesm 654
regarding statement
subsequence since
automatically satisfy
called smoothing
exible choice
local superlinear
g converges
nally state
inequality x
chen harker
monotone ncp
component ng
lot 133
n su
cholesky code
superlinear continuation
quadratic noninterior
local convergence
subsequence converging
primal objective
perold 593
index ng
algorithm 2 1
optimality conditions 2
smoothing type methods
burke and xu
k 2 n
sequence fw k
f k g
step s 2
generated by algorithm
fw k generated
lemma 2 3
interior point methods
solution of linear
central path conditions
strictly feasible point
denotes a suitable
theorem 3 3
class of smoothing
nonlinear complementarity problems
system of equations
newton s method
smoothing type method
method using chks
property p 3
functions for nonlinear
become quite popular
chen mangasarian smoothing
linear complementarity problems
predictor corrector smoothing
constrained variational inequalities
box constrained variational
functions for monotone
w k k
smoothing method using
mangasarian smoothing functions
using chks functions
corrector smoothing method
based on chen
proposition 3 2
global and local
sequence f k
results for algorithm
fx k g
satisfy the inequality
rate of convergence
number of iterations
theorem 3 5
properties p 1
smoothing newton method
non interior point
satises the linear
perold 593 1374
subsequence since otherwise
quadratic noninterior continuation
lot 133 346
better numerical results
netlib test suite
inexactly a sequence
due to burke
path conditions 3
limit k 1
monotone linear complementarity
sparse cholesky code
property p 2
mixed complementarity problems
predictor step namely
global and superlinear
sequences fx k
harker kanzow smale
advanced uniprocessor computers
nonlinear and mixed
converging to w
proposed by burke
global convergence properties
local superlinear continuation
aa t using
method for nonlinear
sub font size
equation in 16

corpus/krapavin2000-test/608350.txt
posterior
pac
bayesian
srm
stochastic
averaging
countable
gibbs
qjjp
concept
prior
density
uncountable
learning
trigram
dp
selection
theta
fi
stochastically
continuous
training
guarantees
concepts
mdl
sample
bigram
nonzero
cq
vacuous
fit
barron
kuhn
tradeoff
hx
tucker
guarantee
smoothes
gjjh
langford
catoni
divergence
nearly
loss
feasible
suffices
lemma
mixture
distributions
probability
empirical
minimizing
inequality
yjx
unigram
delta
fits
smoothed
jensen
avrim
maximizing
warmuth
schapire
yi
goodness
kearns
expectation
densities
theorems
ffi
bonn
normalizing
compact
quantity
chernoff
leibler
mild
satisfying
kullback
selecting
blum
nondecreasing
estimation
trees
prediction
measurable
yang
differentiable
mixtures
weighted
induces
robert
classifiers
truth
du
formula
objective
tyerms
ffjp
lafferty
inequali
mugizi
matti
rajashekar
rwebangira
mincuts
renormalization
gjjf
laviolette
kriinen
classifier
bounds
quantities
minima
ffl
constraint
rates
distribution
subtrees
picks
ln
superior
majority
named
weighting
inspiring
marchand
arindam
regulariza
smoothing
classes
generalization
justified
pruning
enlarging
yishay
seeger
newspaper
letting
expert
risk
yoav
reddy
mansour
yamanishi
manfred
iid
xd
lection
sampling
parametric
probabilities
error
bias
singer
chervonenkis
tong
emphasizing
banff
analogous
generality
john
theoretically
germany
yoram
signifies
freund
vapnik
ith
fl
gradient
valued
infinitesimal
abbreviates
interval
decision
simplify
coefficients
exponentially
pittsburgh
ia
meir
classifications
divergent
instances
likelihood
settings
interpret
justifying
learnability
rb
model selection
stochastic model
pac bayesian
model averaging
posterior distribution
ffl f
b q
l theta
theta x
loss function
concept classes
theorem 1
probability measure
q fi
concept class
prior probability
prior distribution
l c
d qjjp
continuous concept
posterior distributions
feasible set
distribution q
vector theta
performance guarantee
performance guarantees
delta c
possibly uncountable
line guarantees
arbitrary prior
optimal posterior
countable concept
trigram model
simpler posterior
posterior q
concept c
formula 1
training data
p l
following 8
gibbs distribution
concept f
density estimation
function l
empirical error
density p
machine learning
m instances
compact feasible
continuous density
srm tradeoff
pairs hx
bigram model
countable class
fit well
arbitrary posterior
e cq
continuous model
decision trees
generalization error
lemma 1
probability distribution
hx yi
description length
bayesian approach
objective function
distribution p
learning p
distribution d
error rates
fi 0
constraint 10
first main
concept space
l q
nearly optimal
main result
posterior density
kuhn tucker
second main
r n
c x
error rate
continuous function
normalizing constant
learning algorithm
error bounds
define l
parameter vector
selection algorithms
f 3
minimizing b
quantity d
give special
small divergence
following dp
delta satisfying
density h
drawn independently
continuous probability
maximizing subject
distribution g
gibbs posterior
dp dp
concept distribution
proving lemma
unigram model
loss l
bayesian mixture
constraint 12
uncountable continuous
constraint 13
cq l
stochastic model selection
l theta x
loss function l
l c x
density p l
simpler posterior distributions
sample of m
compact feasible set
guarantees for model
function of theta
model selection algorithms
first main result
pairs hx yi
prior probability measure
distribution on delta
parameter vector theta
measure on concepts
prior on theta
theta 2 r
follows where z
vector theta 2
continuous concept classes
vacuous for continuous
pac bayesian approach
conference on machine
machine learning p
implies the following
second main result
closed and compact
f 1 f
f 2 f
f i x
jensen s inequality
goodness of fit
suffices to prove
concept that fits
exponentially many different
cq l c
nearly optimal performance
guarantees for deterministic
posterior distribution q
like to give
consider a countable
noted in 15
model selection algorithm
possibly uncountable set
averaging for density
concept distribution u
concepts f 1
measurable loss function
continuous probability density
provides a guarantee
b q fi
define l c
superior to analogous
class of concepts
quantity d qjjp
bayesian stochastic model
fits the training
smoothed trigram model
divergence from g
pac bayesian stochastic
drawn independently according
algorithms that select
multiple local minima
guarantee for stochastic
fi 0 k
minimizing b q
countable concept classes

corpus/krapavin2000-test/608634.txt
agent
host
agents
specication
customized
connectors
functional
client
issarny
saridakis
dfs
architectural
web
connector
originator
declared
interaction
typeformat
server
specications
rpc
hosting
acceptance
adls
remote
policies
coordination
pcc
mobile
requested
prototype
middleware
conguration
declaration
typedsc
hostfileserver
ambients
architecture
rejection
port
hosts
software
notication
customization
resources
bindings
le
execution
matching
fs
resource
accept
ports
trust
format
authentication
requirements
specied
binding
typeint
matchinter
svce
leserver
intranet
nonfunctional
open
safely
accepting
denes
environment
csp
reception
ambient
assure
interactions
adl
characterizes
evaluates
verication
unavailability
dened
repository
compatibility
piece
servers
abstractly
promote
checkpoint
fd
mobility
dierent
informal
eld
dene
architectures
formal
customizing
instantiation
cient
assistant
verifying
java
execute
standpoint
benets
modular
characterize
gross
com
correctness
exposing
prominent
conforms
entity
retrieved
subdivided
benet
practicality
prover
threads
regarding
component
instantiate
exible
safety
instigate
agentsecuritymanager
sacricing
failureatomicity
conicts
ticated
securitymanager
matchfunc
inscape
nement
agentsecurity
matchports
aster
matchnonfunc
primitives
security
match
declarations
interfaces
dier
raise
supporting
signatures
possess
keys
availability
relieving
employment
somebody
approval
noties
closet
conne
rections
signify
notied
omg
specica
hosted
dispose
approved
systematic
interacting
rst
checks
signicant
accepted
services
service
su
aims
describing
capabilities
requests
carrying
interface
environments
fdr
agrams
hostile
poli
cgi
damages
authen
denition
interconnection
read
subsection
behaviors
heavy
substitution
proposal
execution properties
functional properties
non functional
host environment
web agents
architectural elements
execution environment
remote execution
interaction properties
customized remote
software architecture
v issarny
typeformat format
open software
formal specication
web agent
formal specications
agent based
software architectures
pattern matching
le server
open components
agent component
host agent
using pattern
architectural description
open architecture
format functional
customized execution
functional property
specication matching
mobile ambients
server typeformat
client typeformat
software repository
typedsc fd
environment customized
client component
resource management
given agent
matching techniques
web servers
mobile agents
components agent
host hence
component providing
server non
close typedsc
agent specication
open component
connectors declared
available architectural
conguration made
requirements regarding
fd interaction
explicit declaration
middleware customization
elements available
o agent
connectors svce
agent x
bindings among
host according
logic e
agents 11
client com
interaction open
typeint close
agent characteristics
close read
functional interaction
gross organization
software agent
c client
format server
server interaction
port client
trust issues
service binding
modular constructions
dfs architecture
dfs binding
mobile assistant
server checks
interaction points
instantiation process
coordination processes
associated execution
agent denote
declared operations
coordination process
associated key
formally specifying
properties requirements
functional typeint
operation signatures
safely accept
svce service
agents 15
functional non
non functional properties
agent s requirements
execution of web
customized remote execution
agent s execution
agent s specication
host s policies
agent s originator
using pattern matching
components and connectors
accepting an agent
execute the agent
specied in terms
functional and interaction
client typeformat format
agent s code
open software architectures
open software architecture
sends the agent
typeformat format functional
customized execution environment
reason of rejection
server typeformat format
implemented using pattern
set of ports
evaluates to true
piece of code
c this function
specication the host
functional typeint close
correctness of component
open close read
environment to meet
close typedsc fd
functional properties like
characterize a unit
description of agent
correctness of bindings
elements and resources
declared by agent
binding in figure
host is able
required and provided
accept the agent
e g authentication
close read write
connectors svce service
typeint close typedsc
architecture description languages
interaction and non
description of open
execute to completion
typedsc fd interaction
pattern matching however
based on trust
agent denote respectively
server non functional
upon the reception
declared by c
host agent denote
functional non functional
client server interaction
properties which characterize
possess a component
memory and disk
port client typeformat
svce service binding
format server typeformat

corpus/krapavin2000-test/626961.txt
wave
reset
appl
stabilizing
diffusing
module
sn
atomicity
gd
layer
modules
spanning
resets
self
subsystem
father
st
root
processes
stabilization
nonmasking
arora
adjacency
fault
initiate
repairs
coordination
adj
actions
action
anish
tree
resetting
channels
request
masking
tolerant
steady
reach
tolerance
gouda
villain
karaata
nesterenko
election
completion
tolerate
session
franck
leader
enabled
guaranteed
mehmet
rooted
eventually
petit
hakan
adjacent
failures
propagates
hmodulei
hactioni
declarationsi
ajoy
propagated
fairness
communicate
predefined
vincent
ht
mohamed
reaches
mittal
hongwei
healing
read
increment
stabilize
regained
schneider
mikhail
progress
initiates
guard
faults
afek
yehuda
kulkarni
datta
initiated
consensus
lost
annual
periodically
appendix
token
resuming
cycle
requests
interleaving
erroneous
updates
channel
reachable
rounds
layered
reconfiguration
var
maintains
snap
fail
wireless
terminate
resume
forest
networking
passing
protocols
impossibility
travels
putation
restored
convergence
irrespective
layers
stop
snapshots
inconsistent
propagate
rings
transient
telecommunications
updated
predicate
spanningtree
hassignment
redress
bapat
thetadg
hparameter
ravikant
colette
anat
cournier
upsets
alternator
paulitsch
conjoined
johnen
bumped
prajwal
attie
hguardi
naik
azzedine
seiya
precaution
bremler
strarvation
boulinier
fujii
boukerche
biconnected
maximizable
gradinariu
tta
kopetz
abrougui
cobb
liming
miyashita
wilfried
arumugam
statementi
kaouther
fatima
vora
kulathumani
belkouch
bui
joffroy
hmodule
marco
collective
mask
lastly
executing
comprises
maintenance
exhibit
zhang
ensuring
symposium
self stabilizing
distributed reset
reset subsystem
diffusing computation
global state
reset wave
process p
wave layer
spanning tree
root process
tree layer
write atomicity
completion wave
module wave
distributed system
request wave
adjacency relation
application layer
arbitrary state
distributed computing
appl j
wave reaches
local appl
distributed resets
read write
masking fault
given global
session number
module maintains
predefined global
fault tolerance
anish arora
nonmasking fault
fault tolerant
state satisfying
root j
low atomicity
updates st
local wave
rooted spanning
increment operation
initial graph
stop failures
arbitrary distributed
n st
h l
leader election
steady state
p j
self stabilization
v 62
fail stop
system execution
eventually reach
vincent villain
upon starting
petit vincent
module tree
variable st
process action
wave wave
father process
self stabilize
hakan karaata
layer discussed
global reset
mehmet hakan
diffusing computations
adjacent processes
stabilizing global
module appl
value denotes
j module
adjacent process
franck petit
mohamed g
g gouda
state detection
state predicate
output relation
computing v
systems self
adjacency graph
proof presented
distributed systems
may 2002
given distributed
reach a state
read write atomicity
guaranteed to reach
appl i module
state in gd
appl i modules
wave i module
system is guaranteed
processes and channels
tree i module
given global state
layer is guaranteed
guaranteed to eventually
distributed computing v
computing v 62
maintains a variable
state in g
fail stop failures
reaches the root
repairs of processes
resets the state
closed under system
st i 6
wave i modules
rooted spanning tree
state of appl
tree i modules
sn i n
masking fault tolerance
journal of parallel
input output relation
show in appendix
parallel and distributed
v 62 n
principles of distributed
process p j
normal to initiate
mehmet hakan karaata
state the wave
initiates a reset
mohamed g gouda
global state detection
franck petit vincent
stabilizing global state
whose value denotes
predefined global state
given distributed system
reset wave reaches
root process p
sn i j
petit vincent villain
failures and repairs
root i j
sn i sn
self stabilizing global
nonmasking fault tolerant
symposium on principles
process p k

corpus/krapavin2000-test/628848.txt
parallax
epipoles
epipole
motion
frames
scene
plane
3d
frame
brightness
camera
fl
homography
planar
image
images
epipolar
recovered
pixel
residual
displacements
singularity
estimation
shape
pixels
recovery
correspondences
eq
squares
brighter
pw
aperture
dense
pyramid
surface
carpet
alignment
reference
pi
ambiguity
2d
calibration
bars
fig
unknowns
homographies
sfm
views
displacement
unknown
uncalibrated
horizontal
vertical
motions
warped
estimated
minimization
house
fluctuations
geometries
recovering
ffiu
garden
stairs
taller
correspondence
centered
estimating
vicinity
flower
elevated
constancy
ego
estimate
reconstruction
grey
phi
resolving
gradients
folded
denominators
weights
ground
flow
geometry
aligned
depth
across
quantities
gradual
darker
projective
err
disappears
resolved
opposed
pure
radial
recover
mixed
gradient
coordinate
coordinates
field
scenes
facade
prazdny
takeo
toys
misalignment
rulers
jth
window
denominator
visible
texture
lamp
weaving
trifocal
attendant
fine
noise
scalar
square
front
uniquely
resolution
finest
gauge
transforma
occluding
suffer
distances
phase
measurements
shifted
encode
kanade
tensors
indoor
looming
benefits
constraint
eliminated
parametric
spatial
simultaneous
coarsest
okamoto
rename
multiplying
expression
region
weight
rotation
notoriously
aligning
itera
meaningful
ambiguities
stabilization
stripes
linearized
enlarge
pole
translational
video
normalization
vision
estimates
decouples
folding
parametrically
defense
constrained
sample
relates
focused
warping
recovers
precomputing
textured
equating
unify
pyramids
eqs
gracefully
ence
cameras
holes
unified
iteration
purely
plane parallax
multiple frames
reference plane
planar parallax
shape recovery
3d structure
planar surface
multiple epipoles
scene structure
reference frame
3d scene
two frames
parallax displacements
image motion
multi frame
values correspond
local phase
estimation process
residual parallax
one epipole
aperture problem
parallax motion
horizontal motion
epipole singularity
vertical motion
image brightness
two frame
reference image
scene points
camera epipoles
parallax displacement
residual image
global phase
plane pi
correspondence estimation
fl x
recovered structure
squares minimization
parallax flow
dense 3d
shape relative
structure fl
brighter values
motion parameters
sequence fig
per frame
camera motion
brightness constraint
frame estimation
d search
scalar weight
parallax estimation
uncalibrated views
frame case
mixed motions
pyramid level
ground surface
typical depth
b gamma1
dense planar
spatial gradients
plane alignment
estimation algorithm
one frame
x y
across multiple
image displacements
pixels across
flow vector
recovered shape
structure parameter
calibration parameters
previous iteration
pixel x
eq 3
direct estimation
g l
depth map
j g
least squares
flow field
sequence b
eq 5
pixel per
pure vertical
pyramid construction
variations across
plane homography
brightness constancy
frames however
unknown calibration
recovering dense
line constraint
estimated well
brightness measurements
jth frame
g estimating
homography estimation
grey corresponds
darker values
carpet fig
taller points
camera geometries
shape fluctuations
simultaneous estimation
local correspondence
3d parallax
parallax decomposition
motion ambiguity
estimated directly
brightness variations
direct recovery
parallax representation
images fi
multiple uncalibrated
points relative
parallax e
residual planar
ambiguity along
least squares minimization
residual image motion
j g l
brighter values correspond
planar parallax displacements
across multiple frames
images with multiple
fl x y
applying the algorithm
structure and motion
map that results
3d scene structure
d search problem
directly from image
recovered shape relative
shows the recovered
results from applying
typical depth map
pixel x y
sequence a one
two frame case
dense planar parallax
dense 3d structure
b the recovered
example of shape
across all frames
direct estimation algorithm
correspond to points
x t j
structure parameter fl
fi j g
correspond to scene
epipole t j
plane parallax representation
unknown calibration parameters
plane parallax estimation
plane parallax framework
algorithm to real
multiple uncalibrated views
done by 11
motion ambiguity along
note the fine
directly from brightness
image brightness variations
recovering dense 3d
epipoles t j
parallax flow vector
scene structure fl
reference plane pi
denote the image
plane parallax decomposition
algorithms which handle
brightness variations across
pure horizontal motion
e g estimating
pixel per frame
flower garden sequence
local correspondence estimation
sequences with purely
j x y
residual planar parallax

corpus/krapavin2000-test/609226.txt
reflective
reification
interpreter
reified
datalist
dispatch
argse
reifiable
reflection
locale
mops
instancelink
reify
eval
java
expmethod
methodlist
mop
tower
arg
metaj
referent
lookupdata
isreified
deification
expid
baseinstance
msg
interpreters
exp
lookup
fn
lookupmethod
expassign
methodid
fst
object
superclass
extendslink
expnew
args
field
runtime
snd
basename
name
receiver
string
parser
specially
metaobject
tostring
smith
fields
classid
aclass
towers
explist
baseclass
reifiedrep
instancewithtrace
println
tailored
constructor
transformation
lisp
clos
private
sender
generic
exemplified
exps
expdata
getextendslink
metapair
booleanvalue
metacircular
printablepair
return
body
extends
meta
introspection
lhs
languages
semantics
oriented
prototype
technicalities
smalltalk
accessible
operator
tracing
dispatching
interpretation
jjt
iguana
unreified
countinstances
instanceof
stringlist
intercession
krs
entities
classes
color
security
environment
interprets
parsed
debugging
agora
asai
imperative
senders
layer
creates
seminal
implements
stack
trace
modify
ast
expression
representations
syntax
coda
verbatim
distinguishes
active
sake
inheritance
accessed
transformational
remember
arguments
selective
objects
operators
protocols
adaptability
prog
gaining
delegated
prints
suppressed
base
levels
expressive
interfaces
identifier
calls
nr
message
functional
ba
tackled
null
rhs
modified
typed
correctness
profiling
instantiating
programming
programs
traces
super
intentionally
id
dynamically
redefine
designers
else
rewriting
program
branches
middleware
lightweight
reflective interpreter
non reflective
dispatch object
reified representation
generic reification
class instance
method call
argse add
reflective programming
reification technique
base representation
class pair
environment locale
eval environment
m 1k
reification scheme
data eval
arg m11
reflective systems
original class
extends exp
reification operator
interpreter definition
specially tailored
original interpreter
see figure
class name
method m1
datalist datalist
arg m
instancelink datalist
class class
object oriented
program transformation
string name
environment argse
dispatch objects
type fn
reified object
lookup name
reflective interpreters
field referent
class instancelink
class expmethod
non reifiable
active representation
tailored mops
object pair
type f1
base class
local environment
arg fn
method lookupdata
accessible representation
reflective tower
datalist field
reflective programs
oriented interpreters
instance class
explist args
exp private
private exp
interpretation layer
using reflection
data lookupdata
method reify
arg f1
class expid
reflective towers
reflective languages
smith like
prototype based
dispatch class
reflective system
instance see
pair pair
lookupdata string
runtime system
level n
interpreter program
method return
return new
security properties
user programs
provides access
syntax tree
language designers
class baseinstance
reflective one
metacircular interpreter
field f1
fn name
pair string
metaobject protocols
send msg
method eval
meta object
reified one
datalist lookup
type m11
msg msg
extra interpretation
field instancelink
expmethod extends
non reified
expmethod eval
name return
fn arg
type m1
representation instance
field fn
deification operators
interpreter memory
method lookupmethod
reification process
field list
reification operation
side expression
global environment
reflective capabilities
type m
current representation
private string
non reflective interpreter
data eval environment
eval environment locale
arg m 1k
fst and snd
specially tailored mops
interpreter at level
generic reification technique
exemplified in section
object oriented interpreters
class instancelink datalist
system out println
instancelink datalist datalist
instance see figure
extends exp private
representation is active
environment argse add
interpreter in order
generic reification scheme
data lookupdata string
interpreter s memory
lookupdata string name
method m1 type
work on reflective
arg m11 type
use of reflection
datalist datalist field
type m1 method
type m 1k
class expmethod extends
method m1 arg
original class name
dispatch object instance
arg f1 type
return this datalist
type fn arg
type f1 arg
examples of reflective
m 1k arg
arg m11 arg
hand side expression
fn arg fn
string name return
original interpreter definition
name type f1
datalist lookup name
pair pair pair
efficiency and security
expmethod extends exp
type m11 arg
smith s seminal
see figure 12
list of methods
object oriented languages
dispatch class instance
smith like reflection
incoming method calls
baseinstance say b
field f1 type
denoted by 4pair
type fn field
object protocols mops
parser java jjt
generated dispatch class
level n interprets
args data eval
method lookupmethod string
constraints are different
extra interpretation layer
interest in practical
others expressive power
method call tracing
datalist datalist instance
called meta object
fn name referent
called metaj metaj
new tower level
java java2expvisitor java

corpus/krapavin2000-test/628007.txt
leases
lease
volume
clients
server
client
callback
invalidation
stale
renew
poll
consistency
unreachable
timeout
invalidations
servers
writes
messages
cached
expire
delayed
object
cache
files
renewal
web
polling
alidate
reads
workload
expired
timeouts
delay
teapot
coda
inactive
contact
epoch
gwertzman
renews
invalidates
load
read
day
seltzer
expires
expirei
renewlist
renewing
seconds
bursts
trace
workloads
inv
caching
notify
simulator
dahlin
driven
volumes
protocols
murphi
periods
contacting
file
invalidate
alvisi
prashant
amortize
effort
id
send
bytes
caches
protocol
wait
cao
wan
objects
volid
leaseset
renewrecvd
hclient
renewals
invallist
objid
recieve
deltat
iyengar
disconnected
shenoy
sending
mutable
traces
strong
ack
rees
callbacks
amortizing
currenttime
bursty
arun
traffic
browsers
randal
darrell
valid
failures
reconnection
accesses
expects
news
delays
peak
pending
expiration
longest
vnum
renewall
renu
invalidating
purushottam
awards
inval
tewari
validlease
renewlease
spawar
hobjid
recoverunreachableclient
volepoch
receive
short
krithi
indefinitely
ramamritham
network
accessing
maintaining
message
mike
crashes
burns
tolerance
sent
article
http
loaded
gifts
cheriton
unknowingly
farm
cise
fault
axis
novell
renewed
tot
minutes
browser
dissemination
modified
copies
reboot
bayou
bestavros
kulkarni
popular
examine
amortized
abort
old
sends
ccr
modifying
heavily
requests
write
request
microsystems
rises
discard
track
career
synthetically
lorenzo
weak
coherence
frequency
overhead
tolerable
volume leases
volume lease
object leases
delay volume
stale data
invalidation messages
object lease
cache consistency
strong consistency
best effort
server driven
delayed invalidations
unreachable set
client poll
per day
lease algorithms
inv alidate
lease expires
server load
valid object
server state
hold valid
long object
lease algorithm
lease renewal
v id
cached objects
driven protocols
consistency algorithms
distributed file
volume v
client polling
writes per
volume algorithms
client reads
object invalidation
short leases
leases reduce
notify clients
see stale
valid leases
leases algorithm
stale time
effort volume
callback algorithm
effort algorithms
clients whose
network failure
whose volume
cached object
day change
r deltat
arun iyengar
o version
o volume
clients read
inactive clients
disconnected clients
o id
write frequency
wait delay
epoch number
ack inv
vs timeout
server writes
short volume
long leases
teapot version
cached data
weak consistency
cached copies
driven consistency
fewer messages
prashant shenoy
wide web
let o
world wide
loaded server
object o
file systems
consistency protocols
must contact
leases provide
write workload
default workload
poll algorithm
change probability
inactive set
consistency state
read cost
v unreachable
darrell d
delayed invalidation
randal c
renew lease
sending invalidations
recieve times
invalidations algorithm
receive renew
front page
volume t 100
poll each read
clients that hold
leases with delayed
volume t 10
number of clients
gwertzman and seltzer
best effort volume
writes per day
see stale data
timeout in seconds
best effort algorithms
number of messages
number of writes
object is modified
server driven consistency
whose volume leases
callback and volume
long object leases
ack inv alidate
modifying an object
volume lease algorithms
object a server
volume leases algorithm
clients whose volume
per day change
objects are modified
object invalidation messages
hold valid object
effort volume leases
day of 0
world wide web
heavily loaded server
distributed file systems
cache consistency protocols
burns robert m
liu and cao
day change probability
indicates how long
leases have expired
abort the read
volume lease timeouts
contact to contact
delay volume 1x10
inv alidate o
dahlin arun iyengar
c burns robert
randal c burns
darrell d e
alidate o id
client driven protocols
robert m rees
holds a valid
volume 1x10 7
server driven protocols
leases volume leases
valid object lease
poll and object
server to renew
mike dahlin arun
files a per
delayed invalidations algorithm
cost of renewing
volume lease expires
times out abort
d e long
expires a client
renew a volume
valid object leases
short volume leases
conference on world
cache consistency algorithms
amount of state
amortize the cost
large scale systems
wide web may
clients with lease
clients never see

corpus/krapavin2000-test/607620.txt
kernel
gsk
lsk
documents
svm
document
reuters
lsi
corpus
semantic
training
baseline
text
generalised
vsm
feature
latent
classifier
learning
matrix
gram
generalisation
retrieval
kernels
dimensionality
categorization
alch
margin
eigenvalue
conducting
buc
acq
inner
bvsm
wheat
gvsm
siolas
category
money
schmidt
regression
dimension
ionosphere
joachims
micro
datasets
products
bag
dimensions
crude
singular
modeapte
earn
eigenvalues
pca
indexed
gaussian
classification
similarity
medline
svd
averaged
co
decomposition
bias
indexing
ridge
grain
eigenvectors
norm
vectors
spaces
polynomial
informative
ship
soft
rank
fx
splits
orthogonalisation
yaoyong
kermit
hypernym
newfeat
tfidf
feat
corn
ff
experiments
categories
rise
diagonal
vector
multilingual
wordnet
husband
spouse
kms
equalization
machines
word
principal
projection
entries
ir
synonymous
wife
shawe
statistical
punctuation
features
learnt
mapped
incorporating
occurrence
mapping
correlations
metric
proximity
conducted
onto
reminiscent
corpora
improvements
extraction
sparse
split
frequency
recipes
nr
sv
lewis
approaching
preprocessed
impressive
ordinal
dual
extract
trade
relevant
tuned
subspace
orthogonal
approximation
substantial
extracting
fed
classifiers
weight
demonstrate
sought
dictionary
conjunctions
extracts
avg
external
krieging
grauman
hff
maillet
eigensubspaces
gvsms
satarupa
zilan
haixian
smola
generalistion
solias
spi
kevyn
isometrically
kristen
pun
recode
remultiplying
dulong
feature space
gsk algorithm
kernel matrix
latent semantic
svm classifier
linear kernel
semantic kernel
baseline method
support vector
relevant documents
generalisation performance
document matrix
vector space
space model
inner products
information retrieval
gsk lsk
eigenvalue decomposition
text categorization
vector machines
generalised version
kernel k
baseline figure
money fx
co occurrence
gram matrix
gram schmidt
text data
semantic indexing
alch e
term term
non text
vsm matrix
d alch
kernel defined
e buc
generalised gsk
basic vector
defined feature
reduced feature
kernel methods
training set
matrix p
statistical learning
kernel function
semantic information
first k
lsk step
term similarity
new kernel
reuters categories
polynomial mapping
semantic network
low rank
two documents
feature spaces
text classification
averaged f1
rank approximation
th feature
kernel based
micro averaged
feature vector
ridge regression
matrix d
test set
inner product
optimal value
semantic proximity
ionosphere data
buc 23
k training
cross language
conducting preliminary
gaussian construction
joachims 10
conducting experiments
polynomial kernel
indexing lsi
lsk method
similarity matrix
occurrence information
results demonstrate
e ff
training data
vector d
j th
semantic kernels
soft margin
different terms
enough positive
feature map
co occur
machine learning
term matrix
component analysis
approximation strategy
new space
original feature
gaussian kernel
preliminary experiments
singular value
vector machine
vector space model
svm with gsk
performance of svm
lsk and linear
term by document
support vector machines
latent semantic indexing
reduced feature space
d alch e
alch e buc
defined feature space
basic vector space
kernel defined feature
siolas and d
generalised gsk algorithm
non text data
micro averaged f1
number of dimensions
low rank approximation
onto the first
j th feature
bag of words
value of c
semantic indexing lsi
experiments on one
e buc 23
vsm matrix p
version of gsk
conducting preliminary experiments
original feature space
co occurrence information
term similarity matrix
set of experiments
number of documents
term by term
statistical learning theory
results are averaged
document is represented
space in order
support vector machine
averaged over 100
svm with linear
view the lsk
set and test
acq money fx
yaoyong li john
feature extraction process
set we selected
indexing lsi 4
polynomial or gaussian
term term correlations
ff which satisfies
husband and wife
feat i j
data matrix d
text and non
k training set
towards relevant documents
documents that share
approximate dimension equalization
latent semantic kernel

corpus/krapavin2000-test/1007763.txt
median
configuration
nk
bins
weight
guha
sampling
weights
clustering
indyk
balls
dbe
randomized
nonnegative
thorup
bin
interpoint
krw
nmaxfk
kr
approximate
black
assignment
reals
successive
thrown
box
distances
plaxton
jb
polylogarithmic
ng
probability
lemma
ball
online
uniform
claim
sufficiently
nonzero
failure
postprocessing
facility
weighted
sohler
mettu
coupon
coresets
log
chernoff
extraction
brevity
metric
opt
sample
frac
maxfk
recurse
sub
distance
rw
samples
remark
collector
fix
succeeds
bk
bernoulli
running
demands
incomplete
appearing
diameter
gaussians
variant
partition
preceding
closest
nonempty
covers
sublinear
approximation
learning
mixtures
triangle
christian
ju
union
establish
configurations
success
develop
gereon
kobbi
raskhodnikova
monemizadeh
npg
morteza
gyeongju
frahling
sofya
aside
italic
trials
invocation
incur
landed
straighforward
redistributing
commensurately
expends
nonnegligible
medoid
ask
asks
deterministic
rapidly
quick
streams
succeed
prams
nissim
prioritize
sedona
charikar
ratio
runs
fraction
remainder
ptas
tk
feldman
mishra
twenty
viewing
annual
simplifies
unweighted
feeding
toss
shai
throughout
generality
belongs
location
vacuously
ug
throw
mistake
lie
penalty
bounds
objective
trouble
medians
stream
fx
iff
produces
inequality
nearest
logarithmic
tosses
omits
adam
lemmas
combinatorial
center
ally
neg
foundations
korea
crude
tations
arizona
appropriately
substantially
corpus
favorably
unsupervised
hides
greg
statistical
iterations
probabilistic
widely
paragraphs
remarked
constituent
doubles
covered
k median
median algorithm
median problem
o 1
k o
uniform weights
approximate k
sub bins
successive sampling
o nk
k configuration
configuration x
guha et
sampling algorithm
step follows
input points
cost x
lemma 2
weights k
complete sub
arbitrary weights
log ng
m o
total weight
high probability
r w
positive real
m configuration
nk time
online median
clustering variant
al 5
black box
k 0
small space
o k
r d
w f
nonzero weight
median algorithms
running time
n k
k log
sufficiently large
k means
constant factor
weights algorithm
weight r
interpoint distances
nmaxfk log
box k
kr w
incomplete sub
o nmaxfk
problem instance
facility location
f m
w u
failure probability
point y
nonnegative reals
box algorithm
point weights
log n
m 0
approximation ratio
randomized o
extraction technique
u j
e b
approximate algorithm
desired approximation
o n
points x
j u
sampling technique
balls x
uniform demands
demands k
dbe balls
o krw
standard chernoff
algorithm small
ng time
nk 0
sub bin
weight function
w x
success probability
w g
large choice
m bins
good points
approximate clustering
metric space
location problems
minimum cost
d x
x denote
constant fraction
second step
et al
small range
first step
distance function
k median algorithm
k median problem
o 1 configuration
k o 1
o 1 approximate
approximate k median
guha et al
m o 1
complete sub bins
uniform weights k
weights k median
log n k
et al 5
k configuration x
point in u
o nk time
case of arbitrary
case of uniform
o 1 assignment
k median algorithms
indyk s algorithm
successive sampling algorithm
set of points
j u j
black box k
n k o
o nmaxfk log
second step follows
uniform weights algorithm
online median algorithm
nmaxfk log ng
probability of failure
first step follows
black box algorithm
desired approximation ratio
obtain a k
lemma 2 7
e k 0
k log n
m a b
o k o
o k log
follows from lemma
claim then follows
standard chernoff bound
incomplete sub bins
produces an o
bound of nk
demands k median
sufficiently large choice
uniform demands k
exists a sufficiently
configuration with high
box k median
algorithm small space
log ng time
r w k
randomized o 1
successive sampling technique
d x y
denote the set
compute a k
real there exists
lemma 2 3
factor approximation algorithm
exists a positive
sufficiently large constant
x in x
j and m
constant factor approximation
algorithm of section
runs in o
particular sub bin

corpus/krapavin2000-test/629283.txt
response
throughput
processors
tasks
processor
elemental
series
bdt
pipeline
pipelined
ipsc
assignment
subhlok
asgn
task
assignments
convex
allocating
compositions
jaspal
scheduling
np
multitasked
parallelism
motion
fl
hallaron
partitioning
grids
proc
pipelines
nonconvex
allocated
composition
hypercubes
hypercube
multiprocessor
diagonal
psi
constraint
dinda
nonconvexity
vondran
precedence
gross
intel
dilation
parallelizable
webb
meet
maximizes
vision
embedding
priority
jon
supercomputing
architectures
monotone
choudhary
transputer
allocation
image
rectangular
stereo
alok
arises
allocations
diagonals
computations
sec
gary
multistage
systolic
pipe
notices
chains
contention
mapping
nonuniform
nondecreasing
maximizing
statically
constituent
dag
convexity
sigplan
signature
characterizations
comprised
composite
benchmark
pipelining
convolution
schedule
dummy
marked
subject
embeddings
stream
monotonicity
pasm
threatens
aknown
krishnamurti
computationsextending
varshney
weiner
goubran
jinquan
jaspar
areapplied
endeavors
childrens
bepipelined
timerequirement
ofprocessors
bokhari
mimimal
followingprocessor
rnp
kohr
andrecomposition
intertask
lvoie
whichis
pureza
downton
krishnaiyer
assignmentoptimizing
rafik
luddy
ofassignments
vitoria
estimation
assigned
heap
maximized
vol
understanding
minimal
minimize
onto
achieving
subchain
fleury
chitectures
prasanna
lion
typeface
forma
chinneck
koranne
retiming
makespan
pramod
procs
keng
david
completion
thomas
optimally
meshes
utilizing
tradeoff
scene
nine
loop
assigning
multiprocessors
communication
straint
digest
nonincreasing
checksum
extrapolated
amdahl
minimizes
initialize
job
experimentally
sup
treat
communicating
supply
feasible
rakesh
throughputs
krishnamurthy
srinivasa
dsp
ncube
donald
costs
maximal
response time
time function
series parallel
o np
time functions
throughput constraint
parallel task
np 2
optimal response
response times
throughput problem
task structures
processor assignment
time problem
parallel tasks
task structure
minimal response
log p
individual tasks
data sets
ipsc 2
time constraint
embedding rectangular
proc time
assignment diagonal
elemental tasks
asgn sec
series composition
throughput requirement
f p
data set
data parallel
optimal assignment
task system
parallel precedence
rectangular grids
motion estimation
p time
david r
jaspal subhlok
f 1
gamma psi
time proc
motion understanding
multitasked parallel
sec asgn
execution signature
constraint fl
throughput constraints
pipeline computations
feasible assignments
maximizes throughput
given response
dilation two
pipeline computation
throughput subject
series task
nonconvex response
thomas gross
assigning processors
understanding benchmark
processor system
parallel architectures
p processors
dynamic programming
parallel composition
parallel components
o hallaron
task response
optimal processor
stereo image
individual task
parallel algorithms
intel ipsc
task systems
processor allocation
problem arises
mapping systolic
priority heap
utilizing multidimensional
jon webb
states jaspal
multidimensional loop
pipelined data
processor count
composite task
task compositions
assignment diagonals
hallaron thomas
count q
function completely
dinda jon
containing branches
binary decomposition
gary vondran
minimal mesh
hypercubes characterizations
minimize schedule
constraint using
pipe pipelined
vondran optimal
parallel pipeline
series tasks
assign processors
subhlok gary
integrated vision
binary hypercubes
monotone nondecreasing
maximal throughput
x processors
np sup
processing engine
q processors
estimation system
signature 10
statically assigned
scheduling multiprocessor
transputer environment
possible throughput
multiprocessor tasks
given throughput
good throughput
minimizing response
potentially parallelizable
array assignment
minimum response
subhlok david
multistage linear
every response
mapping task
bdt node
pipelined image
r fl
gross peter
webb communication
allocating programs
minimize response
mesh embeddings
r o
response time function
response time functions
o np 2
optimal response time
number of processors
response time problem
response time constraint
log p time
series parallel task
np 2 log
minimal response time
embedding rectangular grids
meet the throughput
series parallel precedence
time function f
time proc time
np 2 time
given response time
nonconvex response time
time constraint fl
proc time proc
image understanding benchmark
series and parallel
algorithms for mapping
asgn sec asgn
sec asgn sec
tasks are considered
sequence of data
r o hallaron
david r o
must be processed
intel ipsc 2
branches and loops
considered to form
minimum response time
scheduling parallel task
parallelism on large
minimizing response time
function c j
achieving a given
np sup 2
multitasked parallel architectures
processors to individual
architectures and parallel
dinda jon webb
united states jaspal
parallel task systems
grids in hypercubes
allocating programs containing
systolic algorithms onto
array assignment problem
algorithms for integrated
parallel task system
subhlok david r
optimal processor assignment
maximizing throughput subject
pipelined data parallel
minimal mesh embeddings
utilizing multidimensional loop
grids with dilation
parallel precedence relation
every data set
multiple processor system
response time subject
system in computer
states jaspal subhlok
partitioning of cache
functions are convex
jon webb communication
f p fl
tasks we may
every response time
pipelined image processing
minimize schedule length
parallelism in applications
peter a dinda
embeddings in binary
use in scheduling
mapping systolic algorithms
hallaron thomas gross
subhlok gary vondran
scale parallel processor
o hallaron thomas
minimize response time
processor count q
multistage linear array
times for individual
throughput constraint using
image processing engine
motion estimation system
task is potentially
complexity of scheduling
tasks has already

corpus/krapavin2000-test/631185.txt
tla
diagram
diagrams
hin
outi
predicate
hx
action
sem
init
infinitely
phi
pi
psi
wf
unchanged
fairness
yi
formula
enabled
specification
hai
increments
asserts
iff
hn
delta
leaves
hm
pictures
inv
formulas
pc
labeling
upsilon
stuttering
equals
sf
muller
disjunction
omega
draw
transition
semaphore
au
actions
khdri
desharnais
ridha
frappier
assigns
originating
implication
mili
predicates
picture
forever
semantically
temporal
ng
fig
flowchart
formalisms
jules
labeled
inputs
logic
incremented
specifications
primed
events
oe
asserting
arrows
transitions
invariance
ti
nat
leave
operators
proofs
hs
ali
pn
complementary
marc
node
circuit
ae
edge
safety
iii
lusini
specificationand
dillon
priming
gedanken
plicitly
innumerable
thimbleby
leisurely
aquila
nondisjoint
correcteven
nonboolean
kutty
actiondiagram
complements
aspects
expressive
satisfying
views
invariant
conjunction
purely
spaghetti
mealy
bulleted
melliar
ramakrishna
tochi
vicario
increment
label
rigid
proving
describing
interpretation
eter
unprimed
moser
agrams
conjoining
harold
understand
false
infinite
aid
assertion
infix
ous
drawn
labels
rigor
formu
quotes
conveyed
indicated
iv
larly
specifica
simi
dia
meaning
ffl
interface
traditional
scenarios
param
sequential
boolean
suffices
dition
asserted
homomorphism
equivalences
tosem
quantifier
visual
graphical
tuples
friendly
ditions
las
conjunct
confusing
imply
differs
usability
element
moore
illustrate
synchronization
else
precise
string
repeatedly
predicate action
action diagram
tla formula
c element
action diagrams
hx yi
y unchanged
pi c
phi phi
infinitely many
increments x
hai v
corresponding tla
leaves y
wf hx
hm 1
tla formulas
steps occur
hin outi
state function
fairness condition
input c
m hx
transition diagrams
behavior iff
state satisfying
node n
else leaves
specification psi
init pi
many hai
w steps
v steps
many hn
specification pi
initial nodes
n input
state predicate
hn 1
complete specification
ii every
m 1
state transition
omega omega
m inv
upsilon r
init phi
fairness conditions
yi step
enabled iff
tla specifications
hin 1
sem sem
yi steps
purely state
incremented infinitely
predicates labeling
init c
complementary views
phi upsilon
yi m
v sem
provide complementary
hn 2
describe aspects
muller c
oe ae
pi 2
every step
many steps
temporal logic
p sem
implies 2
another predicate
n step
ae oe
next state
possible state
infinitely often
state based
delta au
khdri ali
taking infinitely
correct description
constant operators
specification figure
one plus
unchanged since
tla differs
delta represented
element together
formula asserts
output step
jules desharnais
formula fig
ridha khdri
psi phi
predicate action diagram
predicate action diagrams
diagram of hin
phi phi phi
corresponding tla formula
hin i outi
input c element
leaves y unchanged
wf hx yi
one and leaves
x by one
m 1 step
diagram of figure
state transition diagrams
m hx yi
outi for pi
many hai v
unchanged and iii
hai v steps
one that increments
infinitely many hai
init pi 2
ii every step
infinitely many hn
x and y
infinitely many steps
n input c
hx yi m
purely state based
x and leaves
hx yi steps
phi upsilon r
provide complementary views
leaves both x
hx yi step
phi phi upsilon
implies that infinitely
step is either
y by one
muller c element
specification pi c
unchanged or else
step is one
logic of actions
originating at node
pi 2 m
ae oe ae
oe ae oe
function with domain
state for example
true or false
b the corresponding
c 1 1
pair of states
described in 3
x or y
state s iff
many hn 2
khdri ali mili
jules desharnais marc
value that state
many steps occur
plus the value
formula of figure
yi m 1
state action n
invariant under stuttering
diagrams are used
v a asserts
c element together
action is true
explain the specification
step that starts
ffl to illustrate
tla formula fig
many hn 1
integration of sequential

corpus/krapavin2000-test/634941.txt
majda
pego
capillary
bt
drs
hyperbolicity
ow
leverett
instability
hyperbolic
porous
elliptic
eq
saturations
corner
riemann
deg
stone
conservation
saturation
umbilic
region
diusion
pressures
eqs
stability
interior
eigenvalues
det
permeabilities
eld
pressure
mp
bifurcation
permeability
eigenvectors
oil
strict
ref
laws
neighborhood
buckley
waves
capillarity
eigendirection
boundary
convective
petroleum
triangle
eigenvector
vh
corners
prop
gas
og
nonuniqueness
family
immiscible
marchesin
eigendirections
sh
near
eects
jacobian
nondegeneracy
posedness
strictly
quadratic
cnpq
uid
locus
plohr
mobilities
water
edge
generically
matrix
shock
reservoir
phase
azevedo
reservoirs
diffusive
regions
continuous
unstable
viscosity
elds
br
suciently
sec
hypotheses
wo
curves
sucient
diusive
sotomayor
parabolicity
dge
zumbrun
viscosities
roussarie
admissibility
media
diffusion
vanish
nd
stable
slow
parabolic
wave
takens
kw
bogdanov
medium
flow
determinant
eigenvalue
coincide
dms
refs
associate
mixed
remark
secs
rotates
proposition
rotate
assumptions
fractional
characteristic
curve
ux
evidently
satises
angle
speeds
wg
ill
open
grant
vanishes
linearized
phases
dened
porosity
compressibility
pore
nonclassical
props
dumortier
calculations
dene
contour
arc
equations
traversing
viz
nonzero
inequality
nilpotent
oscillatory
nonexistence
instabilities
seepage
coinciding
loci
satisfying
lemma
boundaries
satised
numerical
nonnegative
denition
traveling
interpolation
odd
experimentally
tangent
linearly
ection
diagonally
rst
purely
smooth
concerning
mobility
statement
traverses
thermal
qp
oscillation
nonpositive
majda pego
three phase
phase ow
strict hyperbolicity
line eld
assumption 4
u 2
saturation triangle
assumptions 4
fast family
conservation laws
f 0
b u
capillary pressure
phase flow
elliptic region
instability region
g bt
strictly hyperbolic
r f
pego stability
deg r
capillary pressures
hyperbolic region
det r
drs point
open edge
pego condition
satisfying assumptions
quadratic stone
u 1
prop 2
associate u
family line
drs points
g e
point u
open neighborhood
component system
buckley leverett
slow family
ow models
e bt
linear stability
porous medium
drs bifurcation
linear instability
bt u
porous media
stability condition
model satisfying
continuous line
ref 3
umbilic points
leverett capillary
riemann problems
u r
two component
f 1
positive multiple
mixed type
system 4
eq 2
eqs 6
pego instability
riemann solutions
pressure jacobian
purely convective
characteristic speeds
conditions d1
unstable region
convective form
permeability k
diusion matrix
pego unstable
pego stable
eq 6
r j
u 0
eq 4
right eigenvectors
elliptic regions
j u
eq 1
deg e
constant solution
k ow
two saturations
marchesin plohr
balance matrix
azevedo marchesin
immiscible three
umbilic point
k og
fractional ow
neighborhood v
linearly stable
ow functions
stable region
continuous oriented
suciently small
elliptic boundary
e u
strict inequality
system 1
f 0 u
three phase ow
three phase flow
stone s model
assumptions 4 18
majda pego stability
assumption 4 18
associate u 1
majda pego condition
satisfying assumptions 4
model satisfying assumptions
family line eld
fast family line
phase ow models
point u 2
eq 1 1
u 2 e
b u r
strictly hyperbolic region
bt u 0
g bt u
system 1 1
pego stability condition
continuous line eld
two component system
w and u
near the boundary
pego instability region
capillary pressure jacobian
g e u
purely convective form
majda pego stable
majda pego unstable
majda pego instability
region of strict
pego unstable region
det r f
system 4 8
laws of mixed
assumption 4 19
lemma 2 6
u 2 u
two phase ow
ow s w
eq 2 18
fractional ow functions
azevedo marchesin plohr
eigenvalues of f
leverett capillary pressures
pego stable region
condition 2 6
ow in porous
cnpq under grant
given by eqs
r j u
immiscible three phase
open neighborhood v
existence of drs
e and bt
linearly stable near
prop 2 3
g and u
f 2 2
system 4 9
f 1 1
hypotheses of theorem
matrix f 0
hyperbolic conservation laws
satises assumptions 4
eigendirection of b
assumptions 4 24
point of strict
line eld rotates
solution u x

corpus/krapavin2000-test/627706.txt
risk
sel
fragment
overspending
query
selectivity
ptu
tuples
ovsp
pts
db
selp
fragments
itr
quota
ff
furnaces
dbms
operator
op
ra
parse
complement
estimatedtime
fragmentation
selectivities
fi
qs
queries
costq
availabletime
fsp
operationg
relations
join
subquery
temperatures
monotone
union
selection
risks
overspent
relational
iteration
nonmonotone
aggregate
knapsack
chains
frag
heuristicchoose
basetime
qm
transformations
operators
iterations
algebra
attribute
unions
selectfragments
lesstimelowrisk
choosefragment
fop
operand
iterative
variance
constrained
please
np
status
transaction
disjoint
ozsoyoglu
evaluated
percentage
evaluating
comp
transformation
modification
fif
strata
indexed
projection
preferred
intersection
monotonicity
estimators
selectedrelation
eram
fname
minuend
timeleft
qsg
subq
seconds
succeeding
revise
disk
lists
guidance
revised
relation
subqueries
gultekin
fnumber
interrupt
formulations
heuristic
module
son
scenario
priority
database
stankovic
jjf
iri
modified
linearly
kyoung
sampling
lattice
costs
thereby
controlling
selected
formula
endwhile
dangerous
file
specifies
estimated
chooses
guides
dictionaries
evaluate
listed
endfor
insufficient
evaluations
evaluates
prefers
begin
choosing
expensive
involved
sang
response
estimations
jf
deadlines
management
revision
timer
priori
databases
completed
kang
variances
critical
tree
rel
page
constants
commands
temperature
formulas
keyword
aggressive
commerce
answers
prototype
chain
deadline
abstractcase
projectcost
fstandard
nonaggregate
fsolves
cleveland
responseg
fchooses
relationg
qiven
lesstimehighrisk
case db
complement fragment
itr ptu
pts ovsp
tuples selected
ptu pts
fragment size
selp itr
fragment selection
query evaluation
time quota
available time
input tuples
fragment list
time cost
difference operator
ovsp selp
tuples used
risk factor
parse tree
selection problem
query modification
fragment lists
relation fragmentation
time constrained
q f
operator queries
modification technique
evaluation step
modified query
figure effect
natural join
iterative query
list f
relational algebra
risk fi
ovsp 3
non aggregate
fragmentation chains
constrained query
algebra queries
real time
critical status
operationg estimatedtime
join operator
single operator
table effect
risk 100
multi operator
second attribute
fragment risk
fi op
ff gamma
query q
operator op
set difference
input relations
expected time
f j
disjoint union
ff 2
selection operator
ra query
sel 1
cost formula
required fragment
relation involved
risk taken
output tuples
complement fragments
used time
risk ff
fragment sizes
fragment f
monotone queries
time 10sec
gamma ff
relation r
union operation
please note
time costs
evaluation time
o p
time constraint
np complete
aggregate relational
aggregate queries
status furnaces
ff risk
relation based
risk 5
q previous
time 20sec
user dbms
risk given
risk value
time left
risk control
operator query
case basetime
given risk
knapsack problem
ff ff
first iteration
u 0
q 0
modified versions
output size
th step
single user
heuristic approach
second iteration
ptu pts ovsp
itr ptu pts
risk of overspending
selp itr ptu
number of tuples
fragment selection problem
effect of risk
ovsp selp itr
pts ovsp selp
percentage of tuples
complement fragment size
selected for processing
query modification technique
query evaluation step
increase the fragment
effect of time
iterative query evaluation
input tuples used
pts ovsp 3
relational algebra queries
sel i op
fragment list f
time constrained query
ff gamma ff
tuples in complement
risk 100 150
relation fragmentation chains
fragment risk 100
time cost formula
complement fragment risk
tuples used time
ovsp 3 sel
set difference operator
risk of 7
time figure effect
used time figure
priority and critical
evaluate the query
risk on single
choosing a relation
multi operator queries
critical status furnaces
basetime and fi
single operator queries
time 20sec table
performance of case
f j r
available time increases
within the available
e i 1
query is evaluated
amount of time
number of output
ff and ff
real time databases
number of iterations
natural join operator
single user dbms
operationg estimatedtime case
lists in x
iteration where overspending
queries in case
fi 1 case

corpus/krapavin2000-test/626911.txt
ctt
routing
faulty
dfs
assignments
traffic
hypercube
hypercubes
modules
links
cebn
switching
communication
link
message
hamiltonian
ctts
assignment
failures
circuit
cebm
turnaround
subcube
fault
greedy
task
cebns
cebms
multicomputers
module
packets
switched
injured
tasks
margin
shortest
cycle
outstanding
abdelzaher
bipartitioning
performances
msg
busy
objective
fig
minimizing
ij
mincut
tarek
routed
cube
timing
status
messages
heuristic
volume
wr
packet
destination
tolerant
multicomputer
congested
hops
optimizing
interconnection
shin
simulation
comparatively
pronounced
bottom
node
gets
kang
annealing
embedding
tested
goodness
ella
ulations
signments
opting
ultrix
atkins
dar
topologies
executing
volumes
onto
processed
queue
weight
blocked
units
tzen
asymmet
ric
subcubes
oe
changing
predict
becoming
span
exchanged
path
assigning
preset
honored
mapping
send
sent
relaxed
paths
event
communicating
improvements
abundance
absorbed
hunt
kept
spread
np
plotted
arrival
traversing
degrading
occupation
narrower
differentiates
scheduling
resources
effects
plots
steadily
perturb
intermediate
inter
broken
utmost
inaccuracies
matrix
randomly
simulated
needing
uncertainties
naval
diminish
combinatorial
negotiation
opinions
whichever
diminishes
mission
absolutely
recommendations
infor
optimize
simulate
halting
inaccuracy
onr
efficiency
stated
measured
edge
driven
axis
apart
negligible
merits
deliberately
unsuccessful
adaptable
thoroughly
hamming
judge
somewhere
grows
nodes
timings
office
adaptive
requests
communication traffic
faulty links
dfs routing
task modules
link failures
assignments found
message switching
communication performance
random assignments
task assignment
communication bound
hamiltonian cycle
routing algorithm
switched hypercubes
fault free
routing scheme
input tasks
bound tasks
u ij
circuit switching
hypercube multicomputers
simple objective
communication efficiency
turnaround time
path chosen
communication turnaround
minimizing communication
communication volume
circuit switched
task execution
tolerant routing
objective function
communication matrix
greedy approach
shortest path
cube size
assignments obtained
free hypercube
outstanding cebn
link status
links increases
called communication
injured hypercube
l msg
heuristic algorithms
tasks used
assignment algorithms
kept busy
one module
overall communication
path routing
simulation results
different algorithms
message length
time units
time behavior
intermediate node
minimizing ctt
task communication
communication oriented
assigning task
inter node
allocation onto
broken links
links grows
communication events
wr hamiltonian
time span
volume matrix
processed immediately
recursive mincut
mincut bipartitioning
optimize communication
message switched
assignments s1
switching however
alternative routing
find assignments
switching methods
communication event
assignment criterion
virtual edge
different switching
tarek f
global link
free shortest
f abdelzaher
communication volumes
routing algorithms
hypercube multicomputer
smaller communication
optimal mapping
hypercube embedding
units links
actually executed
actual communication
destination via
different assignments
fault tolerant
greedy algorithm
improve communication
task graph
node communication
task allocation
approach e
g shin
number of faulty
communication bound tasks
minimizing communication traffic
number of packets
number of link
circuit switched hypercubes
simple objective function
communication turnaround time
fault tolerant routing
faulty links increases
input tasks used
knowledge of faulty
pair of modules
found with different
overall communication traffic
fault free hypercube
links are kept
shortest path routing
run time behavior
global link status
node an outstanding
hypercubes with faulty
inter node communication
alternative routing algorithm
additional link failures
cebn is said
module is assigned
improvements over random
message is routed
performance of assignments
message switching however
function called communication
assignment of task
fault free shortest
time units links
approach for fault
actual communication performance
recursive mincut bipartitioning
timing of communication
algorithms are tested
called communication traffic
first search approach
free shortest path
like the dfs
sum of time
assignments s1 still
hypercube by recursive
onto a hypercube
algorithms the assignments
difficult to predict
modules in hypercube
task allocation onto
routing is used
optimizing this function
effects of changing
traffic is proposed
link status information
unless the task
switching is shown
routing in hypercube
message switched hypercubes
communication performance especially
faulty links grows
assigning task modules
communication performance measure
tarek f abdelzaher
communication volume matrix
smaller communication traffic
percentage of faulty
bottom up algorithms
link failures occur
optimize communication performance
wr hamiltonian cycle

corpus/krapavin2000-test/1031806.txt
mhd
magnetic
curl
dir
sing
incompressible
regularization
div
stokes
hood
inf
hydrodynamic
singularities
convergence
continuity
sup
weight
weighted
norm
dofs
magneto
solenoidal
coercivity
hydrodynamics
field
boundary
smooth
fem
velocity
discretization
mixed
navier
nodal
taylor
domains
spaces
rates
posedness
maxwell
convex
stationary
exponents
proposition
singular
corner
polyhedral
corners
opening
regularity
assertion
remark
inhomogeneous
subregion
embedding
pressure
quasi
oseen
smallness
insulating
therein
stability
mesh
qs
dirichlet
shaped
singularity
formulation
sobolev
uniqueness
exponent
ker
laplacian
weak
bilinear
numerical
corollary
discretizations
unknowns
strongest
indispensable
endow
convection
galerkin
denoting
norms
cb
linearized
polygonal
rellich
poincar
divergence
conducting
fields
angle
equipped
lipschitz
solely
inequality
picard
interpolant
reg
endowed
approximation
meshes
equations
analogue
convergent
elliptic
linearizations
integrable
hopf
subspace
dimensional
references
fluid
forms
liftings
chapter
lemma
di
errors
element
confirmed
iv
stabilization
reynolds
cited
error
coupling
governing
neumann
analogues
operator
polyhedron
restrictions
posed
dimensions
conforming
loc
polar
laplace
spherical
older
cycle
finite
erent
polyhedra
thereof
satisfying
radial
vector
freedom
skew
cone
decompositions
canbedecomposedas
cous
electrolysis
magnetostatic
forwardly
magnetomyampersand
beltrami
approximition
ellipitc
magnetohydrodynamics
dauge
gous
givenby
magnetohydrodynamic
electrostatic
costabel
dimensionalize
electromagnetics
eomorphic
hp
ball
stable
demonstrating
isomorphism
cient
nely
numer
permeability
conductivity
slip
metals
pumps
hereby
analo
fluids
aluminum
regulariza
ca
finite element
weighted regularization
weight vector
v c
magnetic field
mhd problems
c w
mhd problem
inf sup
constant c
convergence rates
incompressible mhd
convex domains
element approximation
u b
smooth solution
non convex
mixed finite
q l
c c
hood taylor
v h
h 1
vector satisfying
mesh size
two dimensional
sup condition
satisfying 2
remark 2
polyhedral domains
stationary incompressible
curl b
sing sing
boundary conditions
field b
l 2
w h
lemma 2
corollary 3
u h
c 0
b h
l h
weak formulation
solely depending
regularization technique
incompressible magneto
magneto hydrodynamics
taylor elements
continuous embedding
opening angle
shaped domain
b sing
boundary data
proposition 2
r c
c 1
continuity properties
size h
l shaped
quasi optimal
corner c
solution components
regularization term
v 0
element methods
r e
navier stokes
b p
u p
b x
optimal error
c 2
b v
singular solution
regularization approach
dir 1
proposed finite
linear mhd
magnetic fields
discrete inf
cycle dofs
magnetic singularities
element method
theorem 2
velocity field
solution u
error bounds
solution errors
forms c
well posedness
ker b
see 7
w d
e e
formulation 2
element spaces
p h
spaces v
non smooth
small data
h v
bilinear form
curl curl
oseen type
smallness assumption
qs c
magnetic bilinear
ca cb
dir given
cited therein
sup stable
dimensional analogue
inhomogeneous boundary
weighted spaces
standard inf
x error
mhd equations
curl operator
nodal elements
derive quasi
dimensional mhd
references cited
type mhd
unknowns u
error equation
stability bounds
c v
two dimensions
q v
v c w
constant c 0
finite element approximation
non convex domains
weight vector satisfying
vector satisfying 2
theorem 2 17
satisfying 2 19
h s d
u b p
c w h
mixed finite element
inf sup condition
magnetic field b
proposition 2 16
incompressible mhd problems
l 2 error
l shaped domain
quasi optimal error
hood taylor elements
incompressible magneto hydrodynamics
error in u
error in b
q l h
weighted regularization technique
finite element methods
mesh size h
existence and uniqueness
finite element method
h v c
c 0 solely
weighted regularization approach
optimal error bounds
discrete inf sup
w v c
formulation 2 28
solution u b
forms c 1
smooth solution errors
w h v
errors and convergence
finite element spaces
proposed finite element
c and e
h 1 0
lemma 2 10
using the weighted
l 2 0
theorem 3 3
technique recently developed
bound c 1
non smooth solution
two dimensional mhd
references cited therein
derive quasi optimal
w d u
lemma 2 12
stationary incompressible magneto
linear mhd problems
oseen type mhd
corner c c
h into l
o w d
inf sup stable
v c v
remark 2 11
lemma 2 15
incompressible mhd equations
find the velocity
series of numerical
standard inf sup
q l 2
problem 4 1
c w v
solutions in non
ker b h
regularity below h
curl b 2
embedding of h
u h b
h 1 error
regularization technique recently
magnetic bilinear form
b q v
type mhd problem
spaces v h
two dimensional analogue

corpus/krapavin2000-test/1014992.txt
mtbdd
mtbdds
prism
pctl
csl
ctmc
probabilistic
sparse
kanban
ctmcs
bdds
mdp
gethin
kwiatkowska
dtmcs
hybrid
symbolic
matrices
checking
osets
kronecker
parker
marta
vertex
mdps
coin
terminal
norman
matrix
traverserec
vertices
traversal
jor
unreachable
markov
leader
reachability
diagrams
oset
numerical
cient
reachable
cudd
baier
christel
ine
specication
dtmc
transition
logics
row
iterative
protocol
minimise
analyse
sigmetrics
col
modied
bdd
chains
steady
engines
transient
ciesinski
probverus
marca
katoen
david
specications
seidel
compact
quantitative
gauss
smart
ciardo
elseif
behaviour
tool
signicant
optimisation
jacobi
multiplication
entries
var
ir
marcus
smv
gspns
columns
labelled
analyser
indices
checker
elected
iteration
engine
attach
summarise
presently
parameterised
store
ctl
miner
decision
colorado
parser
randomized
conversion
boolean
logic
column
compactly
vn
checkers
analysed
web
diagram
veri
encode
temporal
valued
traversing
storing
encoding
simplex
fig
fm
dierence
fx
probabilities
chain
consensus
storage
itai
ciencies
represention
studentship
boulder
pdgs
carroll
buchholz
probmela
pallets
mathfit
younes
typied
groesser
stevens
deds
satisifes
stocastic
mtbbd
mciver
manip
hermanns
annabelle
unites
mtbbds
sproston
boudewijn
ingenious
joost
tacas
uniformisation
grer
negligle
inception
magnitude
species
stochastic
sub
children
fairness
frank
unpredictable
queueing
asynchronous
savings
opt
queue
modules
supports
proba
birmingham
bilities
model checking
hybrid approach
symbolic model
sparse matrices
probabilistic symbolic
david parker
marta kwiatkowska
kwiatkowska gethin
gethin norman
probabilistic model
probabilistic systems
iteration vector
sparse matrix
coin protocol
numerical computation
time markov
sub matrices
reachability based
prism web
mtbdd representation
terminal vertex
iterative methods
e cient
row col
modied mtbdd
equation system
mtbdd data
v row
reachable states
case studies
probabilistic models
using mtbdds
unreachable states
else v
decision diagrams
boolean variables
data structure
performance problems
based computation
using sparse
markov chains
continuous time
transition matrix
system description
temporal logics
vector multiplication
zero terminal
full array
page 31
christel baier
matrix entry
mtbdd representing
matrix entries
decision processes
matrix diagrams
mtbdd m
non terminal
steady state
linear equation
binary decision
var v
multi terminal
matrix vector
novel hybrid
matrix based
real valued
evaluation review
web page
acm sigmetrics
sigmetrics performance
checking algorithms
gauss seidel
performance evaluation
variable ordering
description language
model checker
markov chain
march 2005
v 32
bdds binary
concurrent probabilistic
cient mtbdd
key dierence
mtbdd based
matrix diagram
reactive modules
iteration vectors
explicit approaches
sparse hybrid
prism system
use mtbdds
identical sub
opt coin
symbolic probabilistic
overall matrix
coin 4
ctmc model
pure mtbdds
baier frank
recursive traversal
ciesinski marcus
elseif v
non probabilistic
hybrid opt
rst constructs
identical children
kronecker approach
mtbdd size
linear optimisation
kanban examples
rate matrix
matrix techniques
mtbdd implementation
shared vertices
mtbdds multi
mdp models
analyse probabilistic
kanban 4
use bdds
symbolic model checking
probabilistic symbolic model
marta kwiatkowska gethin
kwiatkowska gethin norman
norman and david
prism a hybrid
checking with prism
probabilistic model checking
time markov chains
continuous time markov
v row col
mtbdd data structure
using sparse matrices
reachability based computation
linear equation system
prism web page
pctl and csl
review v 32
matrix vector multiplication
binary decision diagrams
mtbdd and sparse
zero terminal vertex
web page 31
protocol and kanban
jacobi and jor
system description language
sparse matrix based
analysis of probabilistic
row and column
model checking algorithms
acm sigmetrics performance
performance evaluation review
sigmetrics performance evaluation
evaluation review v
v 32 n
checking of concurrent
slow or infeasible
system 5 2
use bdds binary
explicit sub matrices
subset of pctl
heuristics to minimise
e cient mtbdd
prism a tool
mtbdds and bdds
model checking times
symbolic and explicit
coin 4 43
sparse hybrid hybrid
frank ciesinski marcus
non terminal vertex
like data structure
ctmc in figure
hybrid hybrid opt
represent and analyse
baier frank ciesinski
checking for probabilistic
march 2005 christel
representing the ctmc
overcome these performance
identical sub matrices
markov decision processes
linear optimisation problem
traverserec else v
mtbdds multi terminal
opt coin 4
hybrid opt coin
array to store
sparse matrix techniques
christel baier frank
modied mtbdd representing
solution we adopt
model n states
symbolic probabilistic model
bdds binary decision
probabilistic temporal logics
speed of sparse
x 2 vertex
vertex then traverserec
model checking engines
mtbdd sparse hybrid
veri symbolic model
kanban 4 454
else v row
making a transition
store the iteration
parameterised by n
page 31 probabilistic

corpus/krapavin2000-test/606523.txt
covering
equivariant
cayley
automorphism
automorphisms
action
aut
act
lifts
voltage
coverings
stabilizer
dart
bre
cay
actions
faithful
transitive
walks
schreier
conjugacy
homomorphism
projection
generators
darts
coset
regular
beg
lift
autm
subgroup
group
cov
lifting
ker
eq
isomorphism
digraphs
graphs
vertex
ct
morphisms
morphism
involution
isomorphic
projects
projections
stabilizers
voltages
subgroups
acts
homomorphisms
mnp
arising
orbits
maps
map
epimorphism
loc
walk
orbit
presentations
hjg
sch
cosets
quotient
gz
adm
inv
lifted
id
acting
vertices
digraph
surfaces
reconstructed
preserving
isomorphisms
dened
bijective
invariant
singerman
monopole
cotree
onto
di
groups
proposition
hr
closed
nite
projecting
z
bijectively
bijection
conjugate
respective
regularly
incidence
transversal
conversely
oriented
generating
multiplication
epimorphisms
equivariantly
semiedges
macbeath
hypermaps
reidemeister
permutation
combinatorial
ng
denes
vega
homotopic
relators
pointwise
spanning
word
extends
permutations
fr
cw
disguise
orientable
denition
nonempty
branched
topological
arc
ser
induced
connected
combinatorially
lar
nu
mappings
admissible
intersects
fold
centres
switching
saying
transitively
jones
mapping
rise
lg
projected
multiset
inline
transformations
covers
rooted
cient
faithfully
trivial
induces
associate
su
fw
restrictions
correspondence
jg
znanost
aleksander
subgoups
variuos
siran
admz
slovenije
rewr
burnside
semiregularly
tomaz
spit
monopoles
semiedge
uniformes
graphes
hurwitz
sommet
valency
antly
addtional
cyclicaly
bq
homological
cellularly
automomorphisms
malni
znfb
ministrstvo
koviera
lins
kjg
z g
covering projection
act z
equivariant group
action graph
action graphs
g g
g b
voltage space
cay g
action automorphism
action automorphisms
aut z
cayley graph
act g
covering projections
regular covering
cayley multi
example 8
closed walks
oriented maps
eq z
regular map
group eq
di graph
graph act
eq g
structure preserving
along g
ct p
trivial voltage
generating cayley
g projects
ker q
schreier coset
multi set
automorphism group
set z
g lifts
ng g
covering graph
graph cay
base graph
dart set
lifting condition
conjugacy class
z 2
map d
group actions
b b
generating set
action digraphs
covering transformations
group presentations
right multiplication
group aut
lifts along
sch g
projection g
action z
equivariant covering
transitive actions
transitive graphs
vertex bre
projects along
action digraph
g z
group g
cayley graphs
b g
vertex set
g acts
multi sets
q 1
theorem 9
autm lifts
lifted group
graph x
regular homomorphism
split extension
general topological
closed walk
invariant covering
loc b
conjugacy classes
coset di
dart x
natural projection
cov f
switching involution
action di
normal stabilizer
hr li
cayley voltage
derived covering
q n
g q
example 5
theorem 8
h 0
act z g
aut z g
covering of actions
eq z g
automorphism of act
homomorphism of oriented
action graph act
cayley multi set
z 2 z
equivariant group eq
graph cay g
g is faithful
generating cayley multi
ng g b
transitive and faithful
along g g
cayley graph cay
theorem 5 6
action z g
g g r
map d r
coverings of actions
group eq g
arising from actions
z g lifts
projects along g
q 1 g
g is transitive
action of g
d r l
c b b
group of automorphisms
cayley voltage space
maps where m
projection of action
group eq z
covering is regular
eq g projects
along a regular
sch g h
g projects along
automorphism of g
schreier coset di
cayley multi sets
action graph structure
theory of maps
action di graph
group of covering
class of stabilizers
automorphisms of act
regular covering projection
h h 0
b g b
theorem 9 1
q n g
proposition 7 1
theorem 8 3
covering of transitive
let s g
exists an action
group hr li
x the covering
action digraph act
let h h
lifting and projecting
maps on surfaces
extension of ct
aut s g
m is also
covering projection p
left regular representation
group of cay

corpus/krapavin2000-test/1013562.txt
pebble
mso
pas
ras
pebbles
automata
ra
fo
string
automaton
hypersets
strings
1d
nlogspace
alphabets
hyperset
register
configurations
xml
erent
pa
francez
kaminski
configuration
2d
alphabet
pcp
registers
lmow
transitions
symbols
weak
accepts
delimiter
di
definable
alternating
undecidable
ga
emptiness
transition
lmo
accepting
symbol
head
parties
positions
universality
dialogue
membership
tape
alternation
expressiveness
infinite
languages
protocol
ptime
agap
accessible
monadic
strong
logics
reverse
accepted
logspace
position
gtm
reachability
lift
dom
placed
containment
deterministic
quantifier
logic
exp
expressive
party
successors
agent
closed
proposition
val
encodings
simulate
iw
dialogues
regular
syntactically
decidable
subsumed
labeled
variants
formula
vertex
quantification
encodes
erence
universal
kleene
dtd
segoufin
metafinite
etl
schwentick
adel
milo
equiped
globerman
formalisms
sym
walking
encode
sentence
messages
discipline
existential
trees
equality
harel
pebbled
vianu
suciu
transformers
xslt
subcomputations
yardstick
guesses
decidability
conjunct
closure
split
ph
tuple
inductively
stack
collapse
language
inclusion
theoretic
computable
lifting
gurevich
determinism
claim
incomparable
leftmost
stay
encoded
equip
assignment
recognize
finite
heads
occurrence
message
contradiction
dc
applies
encoding
star
depth
luc
lifts
unary
simulated
leaves
turing
nondeterministic
sweeps
checks
equals
ers
concatenation
formulas
express
undecidability
inclusions
rounds
accept
accessibility
completes
sends
liberal
numbered
web
quantifying
abbreviate
occurring
replies
sink
lifted
formalism
acts
enters
query
pebble automata
2d ra
reverse closed
infinite alphabets
di erent
q q
input string
1d pa
register automata
data values
1d pas
weak 1d
strong 1d
string w
u v
weak 1n
ga w
pcp instance
two way
second pebble
dom w
strong pas
state q
communication complexity
non emptiness
multi head
position l
d strings
automata models
decision problems
new pebble
theoretic assumptions
regular languages
p v
current symbol
head automata
ordered reachability
current pebble
2d ras
val w
weak pas
finite alphabet
v q
finite set
q u
transition relation
complexity theoretic
string u
pairs q
initial configuration
form u
place new
pebble assignment
stack discipline
u equals
n di
pebble model
k pebble
pa proof
mso formula
strong pebble
consider strings
split strings
lmo u
third pebble
register assignment
final configurations
finite alphabets
right delimiter
infinite alphabet
d symbols
standard decision
syntactically correct
x x
exp 2
communication protocol
non deterministic
one way
q 0
one pebble
initial register
x vertex
w l
current position
vertex x
monadic second
first position
finite memory
assume w
kaminski and francez
strong 1d pa
pebble is placed
u and v
complexity theoretic assumptions
form u v
weak 1d pas
weak 1n pa
p v q
hypersets over d
multi head automata
sets of configurations
input string w
set of states
q q q
hard for nlogspace
standard decision problems
x vertex x
ra is complete
n di erent
initial register assignment
string u v
based on communication
pairs q q
assume w l
set of symbols
monadic second order
l o g
w l o
b i 1
x x x
set of transitions
second order logic
v where u
d 1 2
represent a solution
pebble i 1
q q d
accepts an input
erent data values
lift current pebble
show that pas
notion of regular
b on w
show that universality
weak 1d pa
fo and mso
place new pebble
strong pebble automata
q 0 0
ras and pas
w a configuration
accepted by b
d that applies
finite memory automata
strings over infinite
register and pebble
concatenation and kleene
definable in mso
set of pebbles
x x vertex
k pebble automaton
defined in mso
q 0 q

corpus/krapavin2000-test/608626.txt
impedance
arm
torque
controller
controllers
macarena
matari
servo
jerk
joints
pd
joint
dof
motion
adonis
movements
elbow
ivaldi
mussa
postures
human
animation
primitives
posture
robotics
movement
hodgins
torques
shoulder
force
behaviors
cartesian
kinematics
articulated
manipulator
humanoid
angles
biological
pulse
tasks
agents
sub
motor
dance
arms
velocity
giszter
orientation
naturalness
velocities
stiffness
torso
field
qualitative
palm
hogan
williamson
maja
touch
unnatural
robot
damping
straight
hip
manipulators
jacobian
positions
collision
kluwer
wrist
bed
head
trajectory
collisions
body
rigid
actuated
waist
schaal
frog
raibert
ribs
atkeson
neck
position
trajectories
simulation
task
effector
spacetime
imitation
damper
panne
locomotion
equilibrium
desired
spring
specification
dynamics
quantitative
pai
fields
constrain
moving
gravity
physically
inverse
calculated
inspired
style
leg
subtask
craig
salisbury
lamouret
mataric
lapse
bizzi
imitate
pomplun
swinging
gaits
servos
hollerbach
ik
avoidance
sequencing
profiles
tradeoffs
mechanical
interpolate
angle
smooth
frames
revolute
dancing
totaling
wampler
legged
anthropomorphic
primitive
file
appearance
virtual
superposition
solver
whitney
jessica
legs
tuned
interpolation
orientations
finger
brien
encapsulating
watching
brady
aesthetic
flexibility
smoothness
activated
reaching
pulses
mason
specifying
move
forces
freedom
inspiration
touching
trends
robotic
people
recorded
profile
simulated
walking
peak
timing
3d
workspace
metrics
tuning
baker
hands
chose
coordinated
joint space
sub tasks
pd servo
sub task
matari c
torque field
impedance controller
mussa ivaldi
impedance control
force field
m matari
via points
c et
different controllers
human data
kluwer style
style file
field controller
desired angles
hand position
three controllers
inverse kinematics
end point
task specification
servo controller
space controllers
force fields
hogan 1985
articulated agents
human movement
space torque
jerk values
hand positions
arm motion
dynamic simulation
maja j
whole arm
ivaldi giszter
rigid body
human like
joint limits
hand movements
x desired
cartesian space
non linear
computer animation
test bed
upper arm
different types
ivaldi 1997
mechanical impedance
velocity profiles
hand tuning
space force
virtual spring
pai 1990
servo torque
complex articulated
torso simulation
space controller
hodgins et
controller use
humanoid torso
e sub
torque angle
dynamic simulations
actual gamma
touch left
giszter 1992
position control
desired position
motor primitives
williamson 1996
pulse functions
combination approach
hand palm
cartesian impedance
c 1997
get posture
arm path
touch right
different control
de panne
end effector
task 10
hand tuned
field approach
human motion
avoid collisions
motor control
collision avoidance
force f
robot arm
set points
reference frames
et al
low level
physically based
al 1995
m matari c
matari c et
c et al
kluwer style file
torque field controller
pd servo controller
joint space controllers
qualitative and quantitative
position and orientation
mussa ivaldi giszter
naturalness of movement
joint space torque
moving the hand
pd servo torque
touch left hand
use and flexibility
complex articulated agents
matari c 1997
performing the macarena
touch right hand
ivaldi giszter 1992
spring and damper
space force field
joint space force
hodgins et al
sub task 10
go to point
task to task
mussa ivaldi 1997
e sub tasks
van de panne
approach to control
degrees of freedom
et al 1995
could be used
used to generate
hand to top
three different controllers
cartesian impedance control
torque angle relationship
also been explored
sections 20 degrees
information is input
force field approach
values per arm
time lapse image
waist y z
straight out palm
baker wampler ii
consisting of eight
y z 3
left torque field
matari c pomplun
types of controllers
primitives for movement
control in computer
dancing the macarena
controllers we implemented
joint space control
work the primitives
control the elbow
simulation test bed
sub task 8
eight rigid links
maja j matari
controllers the torque
wrist waist y
space pd servo
elbow and hand
humanoid torso simulation
velocity and jerk
controllers pd servo
servo joint space
shoulder sub task
panne lamouret 1995
rigid body simulation
servo torque field
force field based
gamma desired actual
raibert hodgins 1991
joints of one
natural for example
requires hand tuning
joint space controller
robotics and animation
non linear controllers

corpus/krapavin2000-test/628000.txt
extracted
iris
cancer
trained
neurorule
bio
extraction
rules
neural
breast
rule
extracts
premises
kt
certainty
extract
binarized
discretization
alarm
hidden
versicolor
training
mlp
dedec
mofn
malignant
virginica
extracting
connectionist
network
completeness
anns
lre
cont
fuzzy
soundness
default
kbnn
setosa
consequent
networks
comprehensibility
ann
inputs
activation
binarizing
feedforward
mlps
fired
rulex
recurrent
links
re
cf
fire
hybrid
pruning
dfa
engine
pruned
format
lp
fireable
flnn
rulenet
conjuncted
discretized
artificial
combinations
symbolic
node
bin
bre
inference
binary
false
espresso
comprehensive
features
decisions
capability
architectures
yes
fidelity
measures
classification
benign
learning
comprehensible
boundaries
normalized
petal
binarization
linus
howes
promoter
neurofuzzy
kbann
misfired
crook
cebp
backpropagation
attributes
architecture
predetermined
testing
cover
measure
sigmoid
degrade
norm
attached
alleviating
link
incoming
acquisition
continuous
numeric
category
diagnosis
qualitative
body
med
retrained
partial
active
paradigms
decision
factors
logic
notable
six
adjustable
discretizing
supervised
delta
boolean
feature
gamma
refinement
refining
intelligent
layer
firing
dt
intermediate
localized
output
diagnostic
medical
weighted
ji
mitra
ordering
mimic
suitability
dna
weight
ranking
refine
explanatory
activate
automata
samples
expert
black
experts
feasible
examining
unseen
outputs
module
water
embedded
mapping
rewriting
correctly
explanation
patterns
regardless
truth
criteria
transparency
nodes
clustering
extracted rules
full re
rule extraction
rules extracted
partial re
bio re
breast cancer
input features
extract rules
trained network
extracted rule
default rule
node j
neural networks
extraction techniques
neural network
measure measure
false alarm
extracts rules
extracting rules
trained neural
output nodes
input feature
rule evaluation
certainty factors
soundness completeness
trained networks
corresponding trained
gamma o
per rule
completeness false
discretization boundaries
iris problem
output decisions
inference engine
input nodes
evaluation procedure
original rules
completeness measure
certainty factor
network architectures
output node
training network
re technique
re algorithm
network testing
embedded knowledge
cf gamma
technique rule
body class
data sets
rule based
networks trained
output mapping
cancer data
three rule
l h
rule 3
extraction approaches
iris versicolor
rule iris
cancer cont
consequent j
incoming links
conditions per
extraction approach
intermediate rule
binary rules
iris virginica
iris cont
cancer problem
final rules
rule rule
rules based
original input
three performance
hybrid systems
three techniques
hidden nodes
domain knowledge
performance measures
knowledge based
available data
input patterns
input x
connectionist architecture
rule ordering
lp problem
ordering algorithm
rule 4
rule 2
data set
weighted links
ratio match
premises per
soundness measure
class factor
gamma consequent
hidden output
fuzzy rules
box rule
network iris
certainty soundness
corresponding networks
iris setosa
hidden node
activation values
binary inputs
input output
extraction algorithm
yes yes
rule 1
based system
simple boolean
output decision
corresponding rules
rule base
extraction technique
default rules
artificial neural
finite state
rule extraction techniques
number of premises
iris and breast
rules from trained
completeness false alarm
extracted by full
extracted from network
rule evaluation procedure
trained neural network
re technique rule
three performance measures
alarm no body
measure measure measure
three rule extraction
training network testing
technique rule rule
soundness completeness false
used to extract
input output mapping
breast cancer data
set of rules
rule based system
rules from networks
rule extraction approaches
breast cancer problem
rule ordering algorithm
re and partial
trained neural networks
training and testing
simple boolean expression
premises per rule
rules in l
available data set
body class factor
black box rule
rule extraction technique
original input features
rule extraction algorithm
box rule extraction
computed by equation
gamma consequent j
set of extracted
extracted by bio
rules from feedforward
conditions per rule
certainty soundness completeness
rule extraction approach
corresponding rules extracted
hidden and output
yes yes yes
rule extraction process
rule rule b
cont by full
initial domain knowledge
rule b cancer
breast cancer databases
final rules extracted
certainty factor attached
rule with zero
corresponding trained networks
versicolor rule 3
iris setosa rule
extracted rules based
d 0 7
re and full
partial re algorithm
gamma node j
bio re algorithm
hidden nodes activation
rule extraction module
hidden or output

corpus/krapavin2000-test/627752.txt
sensor
monitoring
sensors
monitor
event
buffer
monitored
query
delay
inference
deductive
switch
network
attributes
driven
installation
route
object
obj
primitive
qos
throughput
subclass
collected
activation
status
measurement
magnet
outof
statistical
objectives
activate
broadband
database
perf
traffic
dataspace
activated
configuration
objective
installed
operators
queries
packet
attribute
aggr
vckt
creation
jn
activates
station
sample
var
frame
processor
buffers
identified
submitted
abstraction
generic
declared
management
instances
interface
id
association
specification
monitors
aggregation
activating
configured
senor
selectively
objects
aggregating
events
collect
aggregate
establishes
specifies
metropolitan
duration
networks
subsystems
deactivated
sampling
delays
created
arrival
relationship
operator
engine
message
relational
links
lans
recorded
switching
architecture
count
measures
samples
occupancy
sent
manage
resources
servers
deduction
entity
processed
managing
integrated
inherits
associate
service
interconnected
stopping
requested
transport
instrument
senosr
nemos
automatcally
nbs
arpanet
fabrics
create
reporting
specifying
transmits
questions
sees
identification
met
answered
debugging
responsible
tasks
gatani
codasyl
abstractan
gaglio
urso
dataspaces
hou
deactivates
history
experimentation
procedures
operate
decompose
indication
emphasis
lan
name
multiplexers
stamped
specialists
characterizes
terminal
hardware
send
measurements
switches
calling
disabling
observation
conceptual
abstractions
maintains
identify
quality
achievement
cdr
alfonso
persistently
configure
ownership
established
period
average
selected
negotiated
nu
sensory
st
ment
answers
entities
manual
initiator
geographically
methodology
identifies
center
users
derived sensor
time delay
event variables
switch buffer
objective driven
driven monitoring
performance parameter
performance parameters
state variables
inference processor
object class
primitive sensors
deductive inference
event variable
observation frame
statistical inference
state variable
obj view
buffer 0
status sensor
sensor database
average time
sensor configuration
broadband networks
knowledge database
component object
derived sensors
event sensor
delay call
configuration database
selected objects
activate sensors
sample path
new object
simple queries
measurement points
packet outof
driven measurement
collected information
perf parameter
measurement strategy
primitive sensor
outof buffer
magnet ii
evaluation operators
statistical operators
sensor installation
network station
integrated networks
maximum time
real time
monitoring system
qos parameters
time delays
based monitoring
sample count
data space
object specific
relationship type
monitoring scheme
attribute sample
throughput time
state var
analysis specification
sensor switch
sensors installed
selected performance
query analysis
knowledge based
class name
dynamic database
variables associated
data query
generic object
user id
collect information
inference engine
specific instance
time data
status monitoring
various performance
vckt route
variable specific
specific generic
traffic class
operator submitted
access points
buffer switch
generic sensors
derived object
creation indicates
data transformation
delay condition
variable packet
appropriate sensors
sensor operations
buffer jn
aggr perf
network monitoring
monitoring generic
statistical abstraction
performance measures
state and event
objective driven monitoring
average time delay
buffer 0 1
along the route
deductive inference processor
switch buffer 0
maximum time delay
time delay call
call a b
statistical inference processor
driven measurement strategy
packet outof buffer
knowledge based monitoring
objective driven measurement
performance evaluation operators
order to monitor
throughput time delay
state or event
query analysis specification
identify the instances
time of creation
sensor switch buffer
time data query
monitoring of distributed
selected performance parameters
monitor the state
real time data
set of state
shown in figure
variable packet outof
questions of interest
path and performance
describes the attributes
operator submitted queries
variable specific generic
driven monitoring scheme
activation of sensors
control and management
specific generic sensors
approach to monitoring
time delay condition
sensor is created
switch buffer jn
monitoring of integrated
aggr perf parameter
establishes the association
various performance measures
event variables associated
event driven monitoring
outof buffer switch
quality of service
real time traffic
measure the time
total average time

corpus/krapavin2000-test/1029352.txt
dnf
monotone
learning
fourier
learnmonotone
circuits
learns
mansour
linial
boolean
proc
coefficients
jaj
ann
findvariables
log
poly
polynomial
learnable
oe
depth
ffi
pac
comp
fdae
ac
valiant
ffl
gave
spectrum
chernoff
membership
supscrpt
parseval
corollary
uniform
bshouty
verbeurgt
fanin
tamon
symp
distributions
formulae
sharpened
product
lemma
coefficient
learner
gates
analogue
orthonormality
ff
norm
furst
orthonormalization
pr
italic
negations
learn
js
formulas
subsets
conf
hx
sat
sup
valued
hancock
tour
orthonormal
literals
circuit
transform
hf
fi
ex
analogues
schmidt
query
ae
learnability
drawn
subclasses
blum
sci
basis
hypothesis
probability
labeled
sampling
gram
kn
conjunctions
sakai
factorable
kucera
fik
khardon
kahn
okol
bitstrings
dichotomous
nishnikova
enouragement
maruoka
spanned
suffices
unbounded
guided
queries
workshop
identity
outputs
distribution
sign
hoe
rudich
jff
barred
lambdag
bahadur
fix
estimating
succeed
fifteen
armed
astad
read
jackson
capital
ajtai
celebrated
primer
sharpen
gurevich
nontrivial
disjoint
jrj
kearns
pitt
approximates
flipped
influential
sharper
hypotheses
identifying
boosting
ku
restricted
estimates
approximating
lowercase
polylogarithmic
bellare
implicit
switching
identifies
bounded
estimated
les
gamman
strengthened
inequalities
distribu
minor
arguments
subsequently
random
letters
differs
bounding
negated
recalling
seminal
estimate
uniquely
seventh
advice
ingredient
product distribution
term dnf
oe basis
fourier coefficients
uniform distribution
learning monotone
product distributions
monotone dnf
monotone functions
constant bounded
log n
ac 0
linial et
polynomial time
o log
boolean function
bounded product
n term
low fourier
size dnf
compute monotone
polynomial size
depth circuits
distribution d
constant depth
learning theory
comp learning
ffi time
algorithm learnmonotone
poly n
depth d
log 1
membership query
k term
d size
learning algorithm
monotone o
learnmonotone learns
dnf formulae
k dnf
time algorithm
corollary 11
query algorithm
ffl ffi
ex f
random examples
ffi 0
power spectrum
fourier transform
algorithm learnmonotone2
time membership
ann workshop
fourier spectrum
basis fourier
important variables
monotone boolean
dnf learning
fourier coefficient
term monotone
boolean functions
ae p
chernoff bounds
term size
monotone 2
learning dnf
learns class
real valued
size bound
constant ffl
valued functions
labeled examples
let c
d 1
small subsets
u f
m circuits
jaj c
mansour 23
unbounded fanin
ann symp
js f
log 32kn
d norm
dnf formulas
monotone k
class c
learning model
al 22
ff 0
f 1
let f
log log
fact 9
arbitrary polynomial
fix d
read k
learning boolean
set ff
least outputs
size m
lemma 10
n log
time polynomial
f 2
pac learnable
membership queries
small constant
p d
et al
log 1 ffi
algorithm for learning
linial et al
gave a polynomial
constant bounded product
o log n
log n term
product distribution d
compute monotone functions
circuits which compute
n term dnf
polynomial size dnf
low fourier coefficients
set s f
comp learning theory
ffl ffi 0
membership query algorithm
depth d size
class of depth
coefficients which correspond
polynomial time algorithm
n 1 d
mansour s lemma
monotone o log
bounded product distribution
ae p d
algorithm learnmonotone learns
log n 1
constant depth circuits
functions on f0
workshop on comp
n log 1
spectrum of f
poly n log
correspond to small
k term dnf
term monotone dnf
learns class c
ac 0 circuits
small constant depth
time membership query
ffi 0 algorithm
real valued functions
using the fourier
probability at least
log log n
et al 22
size 2 o
d size 2
arbitrary polynomial size
ex f u
d size m
read k dnf
learning monotone 2
monotone k term
function on f0
monotone boolean function
bounded product distributions
f of important
bshouty and tamon
obtained from f
dnf under constant
e u f
monotone 2 o
oe basis fourier
fix d 1
dnf learning problem
term size bound
algorithm learnmonotone2 learns
polynomial time membership
ac 0 functions
parseval s identity
space of real
size m circuits
algorithm which learns
d 1 variables
d 1 circuits
distribution over f0
polynomial in n
functions on r
form an orthonormal
f 2 c

corpus/krapavin2000-test/635471.txt
dae
daes
ode
projector
ker
subspaces
im
projectors
decoupling
index
cf
solvable
bdf
commute
stepsize
inherent
ivp
coe
discretization
hessenberg
euler
nullspace
ds
remark
dierential
numerically
leading
dp
differential
continuously
dq
dened
formulated
matched
subspace
dierentiable
densely
regular
properly
solvability
kutta
runge
algebraic
numerical
denition
adjoint
hilbert
onto
abstract
cl
cients
nj
supposed
subintervals
equations
pe
restrik
nullspaces
tischendorf
dissipativity
bvp
higueras
pdae
mrz
dx
ind
exive
hamiltonian
respective
quadratic
dn
nonsingular
bijective
bijection
backward
rewrite
reformulations
semidenite
contractive
fredholm
approved
commutativity
benet
stability
realize
vanishes
remarkable
dierentiate
boundary
nonlinear
coupled
factorization
uniquely
maps
db
cient
integration
nice
berlin
modied
matrices
factorizations
satised
gures
homogeneous
manifolds
transparent
dierent
assertion
obviously
operator
seemingly
matrix
reformulated
invariant
circuit
modication
formulate
nd
smoothly
spaces
stated
injective
advatages
hilbertraum
refactorizations
derlying
bvps
representaions
treatet
dierentiably
dieculties
simulaneously
respresentation
anlogous
nessesary
uncompleteness
contruction
iam
sobering
dissymmetry
nondangerous
kurina
gekoppelter
adsorbing
correspondig
alway
unsightly
linearen
multibody
stiy
ential
orthoprojectors
humboldt
pdaes
contractivity
sjh
toren
entiable
theorie
statet
partiellen
contrac
appers
nite
operators
spanned
assertions
dier
trivially
rewritten
somehow
brevity
admissible
mathematics
di
put
rank
norm
treating
mathematik
uj
systematical
clm
pdes
harmless
systeme
dissipative
brunner
bijectivity
arbitrariness
formula
equation
index 2
index 1
inherent regular
regular ode
dae 2
leading term
numerically well
well formulated
well matched
im d
differential algebraic
properly stated
algebraic equations
dp 1
ode 2
ds 1
remark 2
projector onto
onto n
decoupling commute
stated leading
cf 2
g 1
stepsize restrictions
abstract dae
regular dierential
cf 13
dq 1
explicit ode
bounded maps
euler backward
quadratic control
linear quadratic
continuously dierentiable
initial condition
dn 1
runge kutta
optimal control
coe cient
matrix functions
ker g
ker d
kutta methods
norm sense
dae 5
algebraic systems
normally solvable
properly formulated
exive generalized
hessenberg size
projector function
depend continuously
densely solvable
formulated leading
abstract daes
time invariant
uniquely determined
dierential equation
euler method
integration methods
generalized inverse
adjoint equation
stepsize restriction
im g
value problem
coe cients
hilbert spaces
circuit simulation
numerical integration
remark 3
method applied
re exive
x n
g 2
control problems
nite dimensional
denition 2
size two
dierential algebraic
constant rank
im e
extra stepsize
onto ker
original dae
form dae
abstract index
index case
constant subspaces
leading terms
dae decoupling
restrictions may
index dae
inherent regular ode
dae 2 1
numerically well formulated
d t n
ode 2 24
differential algebraic equations
onto n 1
index 1 case
properly stated leading
along s 1
index 2 daes
regular dierential equation
projector onto n
index 2 f1
dp 1 d
linear quadratic control
equation 2 1
theorem 3 1
x 2 c
regular ode 2
differential algebraic systems
re exive generalized
e t x
given an index
inherent regular dierential
g in circuit
exive generalized inverse
formula 2 23
index 2 dae
d are well
n 1 along
properly formulated leading
runge kutta methods
given a dae
hessenberg size two
dened on l
numerical integration methods
dened on x
remark 2 3
one optimal control
well formulated daes
d t ker
denotes a projector
dq 1 g
index dae 2
versions 3 15
subspaces ds 1
mathematics v 45
regular explicit ode
quadratic control problem
projectors that realize
dierential algebraic equations
abstract differential algebraic
cl im g
dae 5 2
quadratic control problems
dae has index
stepsize restrictions may
without any stepsize
bvp 5 4
euler backward method
approximation x n
proof this assertion
stated leading terms
explicit ode 2
cl ker g
spanned by continuously
treating so called
subspace s ind
solvable and well
partial differential algebraic
constant coe cient
index 1 dae
within this subspace

corpus/krapavin2000-test/1006412.txt
awseem
engines
dcv
engine
altavista
human
precision
yahoo
pages
netscape
tukeys
alltheweb
judgments
infoseek
msn
hsd
web
judgment
hotbot
erent
signi
pearson
cant
relevance
ectiveness
document
correlation
search
documents
query
ranking
retrieval
dcvs
evaluations
downloaded
lycos
queries
di
precisionnetscape
performers
urls
pathak
padcv
googles
consistency
sig
speci
performer
google
participants
bias
trec
salton
searchers
bilkent
mowshowitz
kawaguchi
hawking
automatic
modi
tiveness
ective
ed
submitted
statistically
measuring
gordon
ranks
rank
fig
users
ned
top
returned
scattergram
soboro
spearmans
radcv
voorhees
netscapes
erences
ec
meta
retrieved
gures
rankings
cance
enterprises
consistencies
overture
buckley
inventing
relevant
performing
hypertextual
nes
relevancy
precisions
cgi
calculations
students
null
neto
mcgill
jansen
ribeiro
rst
calculated
worst
around
directory
displayed
page
genuine
partner
intermediary
topics
average
retrieve
business
assessments
links
distinguishing
pool
anatomy
reject
boolean
modern
ect
measures
asked
statistical
eight
effectiveness
judge
response
triangulation
hypothesis
subjects
recommended
assessing
text
sorted
keywords
searches
url
indistinguishable
people
netscapealtavista
magellan
ecommerce
stylistic
fazli
saracevic
spink
pedrito
rabia
conformant
viewable
chowdhury
rabian
yahoos
sei
mccown
excite
opentext
blinding
krowne
listings
maynard
trang
tfc
search engines
search engine
human based
relevance judgments
average precision
based evaluation
pearson r
di erent
tukeys hsd
human judgment
web search
awseem 100
awseem 50
performing search
signi cant
based evaluations
dcv 20
e ectiveness
information needs
recall values
awseem results
precision values
around dcv
human relevance
r correlation
average recall
hotbot infoseek
various dcvs
query document
relevant documents
response vector
downloaded pages
altavista yahoo
average subset
engines precisionnetscape
precisionnetscape 25
n average
search n
information retrieval
worst performing
meta search
using human
p 20
retrieval systems
pathak 1999
infoseek msn
table tukeys
document pairs
alltheweb altavista
relevant pages
erent search
dcv 10
relevance judgment
precision around
cant correlation
engine performance
information need
null hypothesis
web pages
user queries
top two
top 20
values around
engines based
p 10
modern information
r values
see table
two performers
retrieval e
engine evaluation
ec tiveness
found relevant
kawaguchi 2002
hawking et
msn alltheweb
awseem precision
web searching
using precision
ranking algorithm
yahoo altavista
measuring search
googles results
yahoo sig
awseem using
subsets distinguishing
human awseem
subject areas
best performing
e ec
worst performer
particular search
r 20
evaluations using
e ective
automatic method
top 50
search results
speci c
pages used
human based evaluation
precision and recall
human based evaluations
performing search engines
judgment and awseem
pearson r correlation
web search engines
number of relevant
human and awseem
search n average
human relevance judgments
n average subset
worst performing search
engines precisionnetscape 25
performing search engine
around dcv 20
query document pairs
r 0 8340
precision at dcv
hsd for precision
gordon and pathak
table tukeys hsd
consistency between human
search engine performance
using human based
average precision values
using the top
signi cant correlation
best performing search
di erent search
average precision around
pearson r values
search engines based
web search engine
modern information retrieval
altavista and yahoo
values for human
precisionnetscape 25 0
e ec tiveness
awseem and human
meta search engine
engines a b
hawking et al
human and automatic
evaluation and awseem
search engine evaluation
performance of search
based on precision
rank of search
erent search engines
infoseek msn alltheweb
hotbot infoseek msn
correlation of human
based and awseem
recall values around
ectiveness of search
pathak 1999 study
consistency of human
measuring search engine
human awseem results
altavista yahoo sig
dcv of 10
compute the average
particular search engine
evaluation of web
world wide web
number of top
used to measure
search engines using
user information needs
retrieval systems using
sig table tukeys
altavista and lycos
hsd at dcv
search engines b
query query subject

corpus/krapavin2000-test/606912.txt
db
disjunction
dd
succinct
disjunctive
np
disjunctions
snf
dddb
9dd
fp
propositional
fpspace
mr
query
cwa
ground
lives
fplt
atoms
deductive
reductions
pi
dddbs
succ
clause
oracle
pspace
circuit
md
ddexistence
upgrading
negation
hb
predicate
circumscription
logspace
pcwa
enc
databases
datalog
string
pol
definable
queries
dduniqueness
log
lexicographical
herbrand
extensional
joe
reducible
delimiting
computable
entailed
hardness
sentence
iff
deciding
succinctly
witnesses
database
gen
indefinite
metric
clique
flinspace
closed
disjuncts
qa
conp
theta
fl
characterizations
relational
lemma
symbols
subclause
plt
optp
conversion
boolean
atom
reducibility
polynomial
foundations
combined
symbol
quantifiers
logic
succinctness
facts
mm
compensation
descriptive
gates
languages
minimal
expression
language
sat
tuple
tuples
closure
sd
america
predicates
reducibilities
interpretational
hbdb
deq
krentel
arity
literals
stewart
program
cf
nonmonotonic
corollary
successor
loves
dhb
logics
fixpoint
world
ffi
gate
rounds
logarithmic
exponentially
bodies
logical
nullary
subscrpt
obdd
supscrpt
vectorized
clauses
completeness
formula
restricted
classes
uniformly
truth
proposition
semantics
encoding
resp
fc
forgetful
reasoning
ary
interpretation
turing
tools
expressive
max
extract
minimality
circuits
remark
char
mc
protected
encode
hard
bill
negated
immediate
mexico
isomorphic
expresses
querying
concatenating
coding
representations
membership
binary
encodings
expressible
inference
constants
dummy
transitive
formulas
presumably
structures
yr
surpassed
logicum
antagonistic
pdata
nonground
myampersandpgr
hillary
pads
usbekistan
data disjunction
fp np
data disjunctions
np log
unique data
expression complexity
combined complexity
theta p
k dd
propositional complexity
db r
md db
data complexity
fpspace np
p minimal
disjunctive deductive
closed world
pspace np
fl np
disjunctive ground
r c
log log
relation symbol
np k
snf sentence
fplt function
minimal models
minimal model
symbol r
polynomial time
restricted data
parallel queries
world reasoning
input negation
conversion lemma
hb db
mr f
deductive databases
ground facts
snf witnesses
np pol
snf formula
pcwa db
finite relational
gen c
np oracle
relational language
db p
complexity classes
lemma 6
disjunctive datalog
clique size
successor relation
world assumption
algorithm ddexistence
uniformly closed
algorithm dduniqueness
metric reducible
cwa db
metric reductions
ground fact
long b
function problems
compensation lemma
mm db
binary language
f mr
self delimiting
logic programming
decision problems
boolean circuit
query q
time computable
query languages
input gates
query classes
domain elements
generalized quantifiers
succinct representation
bounded query
global p
complexity class
p 2
finite structures
binary string
deciding whether
q b
hardness results
disjunctive logic
d iff
function classes
complexity results
clause c
model m
extensional part
metric reduction
succinctly represented
q extract
clause r
delimiting encoding
succinct circuit
flinspace np
succinct problems
class theta
succinct instances
dddb db
sd l
indefinite information
function computations
np pspace
complexity definition
logical characterizations
problem dd
optp o
descriptive complexity
f reductions
h 1
deductive database
definition 6
p c
free variables
unique data disjunction
disjunction on r
md db r
fp np log
expression and combined
theta p 2
complexity of pi
fl np log
np log log
relation symbol r
complexity of 9dd
closed world reasoning
p minimal model
9dd and 9
models of db
complexity of data
exist a program
restricted data disjunctions
finite relational language
lives in joe
fpspace np pol
fp np k
pcwa db p
disjunctive deductive databases
closed world assumption
rounds of parallel
disjunction over r
language is uniformly
complexity and propositional
disjunctive ground facts
complexity of dd
global p minimal
lives in x
polynomial time computable
theorem 4 1
bounded query classes
lemma 2 3
disjunctive logic programming
property on succ
dd is metric
disjunctive deductive database
self delimiting encoding
model of db
model of c
disjunction on p
m 2 mm
data and propositional
dd is fpspace
propositional and data
clause r c
disjunctive ground fact
complexity of graph
optp o log
class theta p
equivalent 1 q
proof 1 2
c is entailed
theorem 5 1
complete for fp
function h 1
complexity of k
denotes the binary
databases the following
complexity of function
r c d
corollary 5 2
r c 2
theorem 6 5

corpus/krapavin2000-test/608853.txt
huffman
comma
decoder
codeword
td
circuits
compression
lh
pm
encoding
lc
chakrabarty
coding
iscas
bist
jtdj
pseudorandom
encoded
codes
le
circuit
patterns
fsm
vm
gat
decoders
bits
rom
cuts
decoding
occurrence
flmin
fimax
murray
iyengar
flops
strat
xi
precomputed
gentest
codewords
pi
ipi
tgc
flip
chip
skewed
probabilities
wi
cut
coverage
hitec
vij
limm
counter
combinational
clock
bit
leaf
testing
gate
primary
krishnendu
dc
overhead
gen
te
pattern
inputs
deterministic
pp
gatest
ppici
anshuman
unencoded
hbits
cbits
automation
hit
fig
scan
2dlog
chandra
fault
vec
vj
xm
percentage
sequential
sequences
benchmark
fm
tree
vi
proc
stream
tbits
crbits
tgcs
hrbits
jtdjd
compressed
runs
sg
saving
rences
netlist
saab
ith
clocked
parent
conf
literal
fi
prefix
encode
cores
atpg
generation
jointly
literals
duke
electrical
entropy
vol
lowest
cycles
patel
statistical
mini
epoch
counts
statistically
michigan
offset
unmarked
europe
repeating
moderate
diagram
core
ce
det
built
received
near
si
considerably
hardware
storage
probability
niermannandj
fies
pij
test set
run length
huffman tree
unique patterns
test sets
test patterns
encoded test
test application
lh d
primary inputs
comma codes
length encoding
deterministic built
test sequences
comma code
huffman coding
codeword length
length coding
vm m1
huffman code
comma coding
set compression
pattern generation
equal length
fault coverage
sequential circuits
application time
comma encoding
lc lh
iyengar chakrabarty
lc le
statistical encoding
precomputed test
iscas 89
flip flops
multiple cuts
unique pattern
pseudorandom testing
gat strat
hit gat
pattern xi
decoder dc
decoder overhead
gen hit
average length
d imd1
pattern decoder
lc d
average codeword
let p1
d le
pm c
huffman codes
length decoder
huffman codeword
test pattern
test sequence
bit stream
huffman encoded
huffman encoding
pi c
full binary
clock cycles
design automation
satisfy 2
data compression
limm 1
length codes
lowest probabilities
comma decoders
compression achieved
encoding procedure
h td1
single decoder
set td
iscas circuit
test vec
set encoding
unique test
binary tree
d 1
testing time
gate level
shared among
near optimal
krishnendu chakrabarty
d 0
benchmark circuits
ppici 1
d n2
coding equal
optimal huffman
f ppici
unencoded test
prefix free
parent vm
example test
proposed test
percentage compression
strat gen
decoder circuit
anshuman chandra
flmin 1
murray table
sequence generator
c n2qi
codes perform
literal counts
h td2
encoded test set
probabilities of occurrence
huffman and comma
patterns in td
run length encoding
built in pattern
probability of occurrence
test set compression
number of primary
chakrabarty and murray
test application time
equal length coding
hit gat strat
gen hit gat
number of flip
let p1 p2
run length decoder
average codeword length
lc lh d
full binary tree
number of patterns
test data compression
worse than equal
results on test
precomputed test sequences
lh d le
tree for td
run length coding
test set encoding
unique test patterns
equal length codes
test set td
number of clock
number of unique
circuit gen hit
ith unique pattern
lc d imd1
sets for two
using the s444
generation for sequential
cost in literals
codes perform worse
chandra krishnendu chakrabarty
huffman encoded test
iscas 89 benchmark
among multiple cuts
anshuman chandra krishnendu
strat gen hit
comma codes perform
lh d pm
gat strat gen
clock cycles c
length for comma
td is skewed
huffman codeword length
f ppici 1
pi c n2qi
d imd1 ipi
encoding of precomputed
pm d 0
increase in testing
parent vm m1
use of comma
coding equal length
number of bits
iscas 89 circuits
built in self
higher fault coverage
state transition diagram
present experimental results
required to store

corpus/krapavin2000-test/607278.txt
designs
orbits
ff
theta
automorphism
intersection
mesner
mendelsohn
psl
orbit
kramer
kohler
subgroup
automorphisms
sylow
isomorphic
block
intersections
representatives
isomorphism
laue
normalizer
group
prescribed
trung
betten
wassermann
nh
admitting
equations
omega
pairwise
dale
qiu
cosets
kerber
grabmeier
weispfenning
rong
sv
lexicographically
lll
orderly
volker
kaltofen
tran
blocks
fix
pg
ng
stabilizer
johannes
reinhard
erich
york
wu
isomorphisms
gf
subsets
binomial
triangle
sprott
tomorphisms
myampersand
intersection numbers
d ff
ff 9
block intersection
ff 2
ff 3
b h
intersection types
automorphism group
psl 3
non isomorphic
theta 75
global intersection
types ff
theta 74
theta 73
intersection type
h ff
pairwise non
theta 76
theta 71
global intersections
m subset
intersections 6
theta 72
theta 77
kramer mesner
subgroup p
essential block
intersection number
fix omega
theta 78
ng p
sylow subgroup
isomorphism problem
theta 70
arbitrary m
design theory
mendelsohn 10
prescribed automorphism
dale m
tran van
theta 85
theta 69
van trung
theta 79
rong wu
theta 67
simple 8
trung qiu
full group
full symmetric
qiu rong
simple 7
theta 80
m mesner
theta 68
orbit representatives
designs admitting
theta 84
numbers ff
two designs
group theoretic
pg 2
theta 64
theta 10
symmetric group
subset m
k sets
b 0
following way
k subsets
isomorphism problems
theta 82
orderly generation
intersection equations
ordinary intersection
class sizes
ff 2 9
ff 9 b
ff 3 9
d ff 3
d ff 2
block intersection types
psl 3 5
h ff 9
b h ff
group of automorphisms
types ff 9
pairwise non isomorphic
intersection types ff
global intersections 6
global intersection numbers
block intersection type
classes of size
numbers of higher
block intersection numbers
essential block intersection
equations of mendelsohn
full symmetric group
qiu rong wu
prescribed automorphism group
equations of kohler
kramer and mesner
tran van trung
simple 7 designs
parameters and intersection
intersections 6 3
m of v
van trung qiu
pg 2 5
ff t 1
m subset m
arbitrary m subset
dale m mesner
trung qiu rong
solve the isomorphism
two different ways
following table shows
ff i 0
kaltofen volker weispfenning
sets of blocks
intersection numbers ff
kramer mesner system
wu and dale
cited references computer
theta 67 2400
designs with ff
number of orbits
average class size
m with d
theta 64 600
fixed m subset
mendelsohn systems 14
designs are constructed
handbook springer verlag
intersections 6 4
designs with designs
designs with automorphism
class of designs
generalized mendelsohn systems
numbers of designs
late intersection numbers
d 2 ff
kerber laue wassermann
volker weispfenning cited
theta 69 6000
simple 8 designs
ordinary intersection numbers
designs with small

corpus/krapavin2000-test/614325.txt
ijk
ezier
volume
lmn
solids
deformation
tri
abc
energy
uzawa
continuity
olume
solid
dudvdw
primitives
preservation
volumes
deformations
tensor
surfaces
geometric
configuration
surface
variate
primitive
interactive
parametric
animation
tolerances
manipulation
lsq
ijklmnopq
physics
bernstein
cubic
preserving
derivative
pressure
revolution
ffd
gauss
nurbs
interaction
object
ae
lagrange
minimization
du
nw
determinant
cube
hydrostatic
duv
brep
modeling
graphics
physical
boundary
derivatives
orders
outer
breathe
bhrigu
respiration
celly
dilorenzo
constraints
multipliers
configurations
tuning
multiplier
endowing
deriva
unconstrained
inner
squares
chiu
zordan
motif
constrained
smooth
displacement
arbor
deform
mechanical
proportions
iterations
fl
convergence
utilizes
workstations
material
michigan
stokes
mouse
deformed
industrial
bill
deformable
tog
jf
triplet
det
ann
curves
manipulated
lagrangian
mathematical
explains
tive
multiresolution
vanishes
coordinates
jacobian
patches
neglected
dist
inside
hyperpatch
gentaro
renee
ijklnmopq
xabc
hujun
gib
dilating
1det
gineering
ciples
sculpturing
mathematicalrequirements
selectable
trivariate
ffds
abstractsome
stefanie
overstepping
funck
coons
xinguo
manipu
shears
basile
geome
rijk
elber
jaroslaw
dvw
youlus
theisel
georges
multylinear
opq
naftali
terval
baining
amphora
duw
xiaohan
maheshwari
objects
cubes
product
column
cell
notations
ijk ijk
b ezier
control points
free form
control point
z 1z
form solids
volume size
point configuration
volume preservation
continuity constraints
v olume
ezier solid
olume p
linear constraints
tensor product
ijk lmn
form solid
geometric modeling
deformation energy
p z
lmn p
desired volume
point manipulation
tri variate
tri cubic
whose components
physics based
basis functions
lmn lmn
ezier basis
preservation algorithm
column vector
non linear
unit cube
product b
volume preserving
problem m
computer animation
constrained minimization
z abc
ezier solids
points configurations
industrial design
x ijk
variate tensor
fully interactive
bernstein polynomial
tri quadratic
point constraints
form objects
direct manipulation
displacement constraints
energy p
point displacement
form deformations
boundary surfaces
surface design
object design
uzawa algorithm
partial derivatives
minimization problem
finite element
physical properties
p x
linear equations
p p
ae 1
solid modeling
v w
global computation
deriva tive
practical order
mathematical notations
tuning parameters
variate b
unconstrained min
max problem
v nw
constrained deformations
solid primitive
form volume
x lmn
geometric continuity
derivatives abc
inner problem
object composed
body defined
usual geometric
parameters ae
interactive setting
product solids
p ijk
volume sizes
desired volumes
hydrostatic pressure
energy computation
example abc
uzawa based
ensuring high
volume constraint
order continuity
j dudvdw
using gauss
several tensor
original object
abc p
preserving free
animation industrial
simple constrained
current workstations
abc denote
nw linear
local coordinates
dudvdw z
mathematical problem
solid design
iteration limits
d du
write ijk
solid models
order combination
new control
interactive design
ezier volumes
ijk ijk ijk
z 1z 1z
free form solids
control point configuration
v olume p
b ezier solid
free form solid
lmn p z
product b ezier
tensor product b
control point manipulation
olume p p
ezier basis functions
b ezier basis
volume preservation algorithm
constrained minimization problem
u v w
point displacement constraints
control points configurations
p z abc
variate tensor product
free form objects
called the lagrange
tri variate tensor
b ezier solids
lmn lmn p
ijk lmn lmn
physics based modeling
free form deformations
algorithm for non
utilizes the uzawa
r is x
use free form
f j dudvdw
tuning parameters ae
interactive for tri
surface based models
animation industrial design
unconstrained min max
simple constrained deformations
basis functions hence
based on deformation
usual geometric primitives
one control point
dudvdw z 1z
primitive and ensuring
derivatives abc abc
rather than surface
high order continuity
f i dudvdw
tri variate b
number of linear
form solid primitives
resulting in equations
b ezier volumes
one whose components
method for modeling
abc p z
practical order combination
order continuity constraints
ensuring high order
x lmn p
min max problem
tolerance of 10
v nw linear
july 2006 victor
energy or least
p the column
surface of revolution
primitives the method
abc abc p
design and mechanical
every practical order
minimization problem m
paper we integrate
uzawa s method
p whose components
preservation algorithm requires
nw linear equations
preserving free form
p of control
computer animation industrial
configuration to another
free form volume
p x ijk
tensor product solids
endowing the tri
modeling an object
probabilistic point constraints
several tensor product

corpus/krapavin2000-test/1029119.txt
route
reply
adversary
routing
ariadne
endaira
corrupted
conf
msg
initiator
identifiers
identifier
request
compromised
mac
protocol
security
secure
ideal
macs
hoc
attack
protocols
routes
discovery
plausibility
signature
ad
plausible
tape
tapes
attacks
ini
tar
verifies
honest
cryptographic
sys
sndr
rcvr
verifications
world
signatures
adversarial
forged
messages
srp
message
neighbor
sig
configuration
intermediate
hop
flag
authentication
hash
puk
pf
req
neighbors
receives
machines
res
target
indistinguishability
dropped
node
ext
demand
keys
vertices
wireless
signing
ban
replay
signed
neighboring
id
radio
statistically
accumulated
hypothetic
overhear
activated
nodes
negligible
aodv
discoveries
public
reactive
requests
informal
initialized
vulnerabilities
send
digital
wormhole
digitally
received
capabilities
faithfully
vertex
ha
flaws
pub
broadcasts
preceding
sign
accepts
eavesdrop
prk
tesla
nessett
sybil
novelties
rejoinder
undef
olsr
hmac
initiate
discovered
flags
simulation
participants
content
published
adversaries
provably
broadcast
hungarian
rushing
oracle
transmission
rigorous
timer
round
dsr
appends
assurances
imperfections
strand
securing
initiates
active
exchange
provable
scheduler
verify
false
initialization
existent
defend
indistinguishable
parties
devices
forge
sleep
discover
heard
lossy
statistical
reads
networks
authenticate
flooding
intended
reaches
private
band
material
verification
partitions
marked
activation
intend
tolerable
participant
caught
rounds
mobile
accept
successfully
shares
returned
anymore
belong
authenticated
vulnerable
repeating
unavoidable
nb
subtle
accepted
apart
placed
removes
entity
transmissions
receive
route reply
route request
corrupted nodes
routing protocol
world model
ideal world
non corrupted
route discovery
world adversary
hoc routing
routing protocols
ideal conf
ad hoc
node list
corrupted node
real conf
sys ideal
non plausible
intermediate nodes
compromised identifiers
plausible route
plausibility flag
adversarial node
source routing
demand source
hop hash
real world
hoc networks
intermediate node
per hop
negligible probability
endaira protocol
non compromised
secure routing
configuration conf
sys real
neighbor discovery
active 1
request identifier
basic endaira
ext j
compromised identifier
plausible routes
digital signatures
reply messages
sig j
sndr rcvr
routing security
discovery process
machine m
random input
hash value
first adversarial
mac list
discovery part
rcvr msg
following message
accumulated route
statistically secure
identifier z
j q
output tape
dropped due
discovery protocol
reply contains
flag set
protocol faithfully
verifies correctly
honest nodes
second adversarial
ini tar
simulation paradigm
corrupted neighbor
following identifier
key exchange
statistical security
input tape
communication capabilities
reply message
signature scheme
wireless ad
security analysis
exchange protocols
ad hoc routing
hoc routing protocols
sys ideal conf
ideal world model
real world model
non corrupted node
ideal world adversary
per hop hash
demand source routing
ad hoc networks
real world adversary
sys real conf
non corrupted nodes
non plausible route
route reply messages
route discovery process
basic endaira protocol
j q 1
definition of security
protocol for ad
source routing protocols
generates a route
secure routing protocol
active 1 2
route discovery part
hop hash value
non compromised identifier
sndr rcvr msg
first adversarial node
conf a r
route reply message
source routing protocol
vertices in v
set to false
contains a non
secure on demand
send the following
contains the identifiers
receives a route
attack on ariadne
second adversarial node
route reply contains
attack against ariadne
simulation based approach
neighbor discovery protocol
operation of m
plausibility flag set
wireless ad hoc
key exchange protocols
must have forged
protocol under investigation
c i tar
conf a conf
adversary has compromised
initiates a route

corpus/krapavin2000-test/1014994.txt
transition
circuit
redd
circuits
pi
bdd
red
predecessors
oe
bdds
symbolic
ctl
init
checking
relations
pci
smv
inputs
sub
assignment
sequences
generation
gains
sup
bus
subcircuit
verification
endfor
backwards
operator
assignments
temporal
coverage
ex
atpg
trace
reachable
agrees
reproduces
dyn
quantifier
dynamic
unmanageable
reproduce
exterior
ef
signals
projection
partial
endwhile
stage
intel
formula
finished
accessible
industrial
seq
vec
expand
checkers
print
static
agree
twelve
ffl
designs
dynamically
unreachable
receives
precomputed
synchronous
cone
ax
st
recreates
sensitization
returns
explosion
successors
validation
logic
creating
concise
consumption
relation
critical
created
reuses
verifiers
subcircuits
inputing
puzzling
quences
verified
designer
unprimed
behaviors
granted
architectural
operators
sometime
latch
orders
failed
tests
influence
designers
translate
path
traverse
speedup
grow
hierarchical
creates
induces
series
successor
columns
testability
valuations
killed
valuation
expensive
arbitrarily
exploit
eleven
inefficiency
frequently
representations
simulation
verifying
boolean
arrive
width
generator
impressive
rounded
sure
succ
vg
rn
asynchronous
mostly
iteration
extremely
companies
quantifiers
hardware
magnitude
seconds
successful
opposed
relate
counterexample
enhances
endif
prominent
stages
differs
core
silicon
facets
modality
abuse
modalities
produces
plan
symbolically
putation
sm
averages
beforehand
megabytes
environ
schematic
notice
forward
intermediate
formulas
gained
unrestricted
pursue
expands
connectives
deterministically
aspect
popularity
signs
goes
search
gain
reverse
transition relations
dynamic transition
transition relation
test sequence
model checking
p red
test sequences
sequence generation
p redd
partial assignment
symbolic model
partial transition
test generation
sub circuit
generation algorithm
sequence pi
full design
pi sub
next state
assignment oe
sub circuits
good coverage
backwards search
pci local
local bus
global transition
initial state
partial assignments
v 0
variable v
large circuits
input variables
finite state
f depends
state value
dynamic algorithm
logic ctl
static algorithm
relation r
small critical
ex operator
several large
stage ii
sup 0
dynamic validation
critical sub
variables u
u 0
ef p
p holds
gives values
complete circuit
state variables
efficient test
state machine
temporal logic
chosen arbitrarily
operator p
new method
choose oe
reproduce pi
unmanageable due
checking 3
circuit input
operator ex
smv 13
bdd implementation
provide gains
columns relate
atpg algorithms
ffl sub
previously unmanageable
simpler relations
red function
endwhile stage
bus 4
hierarchical design
states assignments
verify circuits
industrial circuits
print sequence
generation failed
relations method
improve symbolic
lines 21
intel circuits
dyn st
dynamic transition relations
set of states
test generation algorithm
symbolic model checking
test sequence generation
partial transition relation
partial assignment oe
transition relation r
test sequence pi
set of predecessors
pci local bus
global transition relation
number of variables
next state value
assignment over u
set of test
set of variables
sets of states
sequence of inputs
method can provide
using dynamic transition
state s init
partial transition relations
next state variables
u that agrees
method in smv
computation of p
finite state machine
represents the set
time and space
show that dynamic
temporal logic ctl
set of inputs
means that p
computes the set
space during verification
pi on u
receives a partial
often be smaller
local bus 4
exploit a partition
partitioned transition relations
transition in n
represented by bdds
architectural level test
depend on v
assignment oe 0
inputs i sub
ffl sub circuits
series of sets
implemented the new
types of circuits
level test generator
value for variables
p red function
called p redd
previously unmanageable due
efficient test generation
small critical sub

corpus/krapavin2000-test/634972.txt
safety
lf
certifying
touchstone
compiler
typed
recipient
bcopy
producer
safe
trusted
dst
evidence
compliance
annotations
edx
pcc
policy
int
csubneq
gcc
assembly
assertions
cons
csubb
src
code
carrying
proofs
certificate
tal
ann
eax
certificates
certified
invariants
movl
ebx
checking
pointer
logical
gnu
compilation
mobile
ecx
hoisted
unpack
qsort
trust
languages
vc
infrastructure
policies
sharpen
kmp
blur
ms
array
validity
nil
certification
verification
checker
language
intermediate
cmpl
vcgen
intg
cedilla
java
simplex
complies
cc
loop
register
null
locals
dereferences
consumer
checkable
compilers
prover
esp
dec
integrity
accumulator
huffman
twelf
imul
elf
jmp
car
cdr
typing
generator
provers
compiled
comply
attached
dependently
tilt
rm
burden
tag
annotated
ret
assurances
certify
jumps
unsafe
program
programs
warrant
unoptimized
judgment
soundness
signature
void
frameworks
excerpt
modula
annotation
checked
isolation
underwritten
anteneh
esi
checkability
underwrite
intgg
instructions
checks
proving
discipline
pf
jump
provably
nop
definitional
dereferenced
hoisting
snippet
cert
caller
inv
accesses
optimizations
unreachable
bars
object
mem
executable
edi
suppliers
mov
security
native
optimizing
ptr
compromises
safety policy
computing base
trusted computing
typed intermediate
proof carrying
certifying compiler
carrying code
code recipient
typed assembly
intermediate languages
logical framework
type annotations
assembly language
object code
logical assertions
mobile code
verification condition
special j
add x1
safety policies
type system
type checking
explicit proofs
safety infrastructure
gnu gcc
proof generator
type list
level languages
certified code
kmp unpack
unpack bcopy
dec cc
sharpen qsort
simplex kmp
blur sharpen
qsort simplex
safety properties
proof checking
memory safety
lf logical
csubb x3
safety certificates
dependent types
high level
type information
well typed
int list
safe mobile
safety invariants
certifying theorem
safety certificate
certifying compilers
code block
generation ms
int r2
code producer
checking compliance
condition generation
verification conditions
cedilla systems
bcopy edge
return address
low level
provably safe
cons h
logical frameworks
code blocks
type checker
source language
type theory
type int
run time
target code
theorem proving
intermediate code
formal representation
theorem prover
program code
theorem provers
type directed
imul x3
add imul
ann inv
safety specification
must trust
bcopy 6arrays6bcopy1aiai
language compiled
pseudo register
f sum
bounds check
flow safety
touchstone compiler
csubneq x1
cons int
pointer arithmetic
ann unreachable
rm mem
nil void
safety 2
add x0
check type
pointer dereferences
movl 4
safe component
safety proof
void cons
type safety
list 2
dependently typed
fault isolation
proof p
null pointer
trusted computing base
proof carrying code
typed assembly language
typed intermediate languages
evidence of safety
evidence of compliance
add x1 4
kmp unpack bcopy
blur sharpen qsort
simplex kmp unpack
qsort simplex kmp
sharpen qsort simplex
lf logical framework
l has type
high level languages
safe mobile code
int r2 fr1
unpack bcopy edge
verification condition generation
csubb x3 sel4
provably safe mobile
v has type
control flow safety
nil void cons
run time checking
bounds and null
h has type
add imul x3
void cons int
cons int list
compiled by touchstone
low level languages
well typed programs
represented as terms
automatic theorem proving
computing base since
system for expressive
decision procedures 12
certifying theorem provers

corpus/krapavin2000-test/628163.txt
client
skyscraper
bandwidth
server
multicast
hmsm
stream
patching
file
sslre
delivery
clients
request
tapping
streams
streaming
play
receive
segment
progression
rate
requests
service
arrivals
merging
video
transmission
demand
optimized
immediate
segments
poisson
grace
derek
deliver
scheduled
arrival
broadcast
buffer
logarithmically
listen
vernon
peer
merges
eager
patch
rates
interactive
media
multimedia
multicasts
merge
duration
transmissions
cluster
broadcasts
merged
mahanti
files
mary
broadcasting
unlimited
anirban
delivers
schedules
cable
scalable
hierarchical
channels
earliest
partitioned
listens
listening
rewind
arrives
dyn
bursty
twice
sky
satellite
rearrangements
units
reasonably
piggybacking
policy
initiated
channel
dynamic
fold
receiving
policies
broadband
servers
pause
talo
xiaobo
yanping
stealing
jussara
haonan
srgio
progressions
stukel
derives
caching
arrive
competitive
savings
anastasiadis
shudong
rocha
zongpeng
maia
cunha
stergios
nearly
controlled
ahead
requested
periods
transmitted
delivered
marcus
campos
nahrstedt
metropolitan
vod
sundaram
segmented
heterogeneous
storage
moderate
waiting
bestavros
azer
klara
cui
delivering
static
audio
ton
cheng
almeida
jin
tight
ca
period
threshold
portion
batching
hilton
progress
impact
served
interactivity
zhong
unicast
marcelo
buffering
disk
live
reviews
skip
fragmented
latest
achievable
principal
arrived
popular
overload
minimally
appendix
family
considers
labelled
ni
networking
yi
bandwidths
altering
singapore
server bandwidth
required server
client request
play rate
dynamic skyscraper
receive bandwidth
client receive
file play
stream tapping
request rate
immediate service
multicast stream
delivery techniques
delivery technique
optimized stream
stream merging
tapping patching
immediate real
client buffer
hierarchical multicast
request arrival
client requests
bandwidth equal
buffer space
partitioned dynamic
provide immediate
provides immediate
segment size
skyscraper technique
transmission cluster
request rates
progression 1
grace patching
skyscraper delivery
lower bound
new practical
l eager
tapping grace
sslre 2
derek l
sslre n
controlled multicast
time service
poisson arrivals
k vernon
size progression
practical delivery
full file
eager mary
mary k
multicast delivery
segment 1
hmsm 2
patching controlled
high client
client b
skyscraper system
broadcast techniques
request arrivals
optimized dynamic
skyscraper method
limited client
interactive functions
real time
given client
minimum required
static broadcast
hmsm technique
patch streams
skyscraper systems
merging hmsm
multicast technique
original dynamic
bandwidth used
average server
fast forward
optimized patching
sky 1
dyn sky
bandwidth savings
greater server
n r
anirban mahanti
new stream
clients c
providing immediate
total server
time delivery
request arrives
two times
new client
media streaming
equation 5
network bandwidth
constant factor
required server bandwidth
client receive bandwidth
file play rate
client request rate
optimized stream tapping
stream tapping patching
immediate real time
client buffer space
multicast stream merging
hierarchical multicast stream
video on demand
bound on required
receive bandwidth equal
partitioned dynamic skyscraper
client request rates
provide immediate service
dynamic skyscraper technique
client request arrival
dynamic skyscraper delivery
service to client
technique that provides
real time service
stream tapping grace
tapping grace patching
derek l eager
times the file
service to clients
eager mary k
twice the file
progression 1 1
l eager mary
new practical delivery
sslre n r
segment size progression
mary k vernon
equal to twice
scalable on demand
minimum required server
optimized dynamic skyscraper
sslre 2 1
hmsm 2 1
high client request
dynamic skyscraper system
provides immediate real
patching controlled multicast
provides immediate service
dynamic skyscraper method
average server bandwidth
static broadcast techniques
bandwidth for hmsm
original dynamic skyscraper
stream merging hmsm
used to deliver
twice the play
range of client
client request arrivals
k and w
rate i e
first two segments
tapping patching controlled
real time delivery
controlled multicast technique
bandwidth for delivery
server bandwidth used
satellite or cable
greater server bandwidth
function of client
sky 1 1
client request arrives
techniques that provide
given client request
total server bandwidth
clients have receive
limited client buffer
request arrival rate
dyn sky 1
derived in section
measured in units
peer to peer
simple to implement
c and d
progress for clients
client is given
interactive client requests
skyscraper delivery technique
hmsm delivery technique
client who requests
lower bound derived
rearrangements of scheduled
request rate n
provide immediate real

corpus/krapavin2000-test/1011932.txt
shiftable
twistable
elds
eld
twist
advection
completion
planck
fokker
gaussian
fourier
diusion
sink
coecient
steerable
shiftability
receptive
cortex
shift
cddg
euclidean
invariance
kanizsa
visual
contour
directional
interpolation
stochastic
gabor
coecients
illusory
wavelet
dierencing
stimulus
grid
invariant
orientation
williams
derivative
decay
simoncelli
gaussians
twistability
neural
frequencies
continuum
basis
biologically
spatial
jacobs
sinks
orientations
discrete
clockwise
triangle
nite
ehrenstein
circle
rotations
mass
dened
source
rotated
coupled
proposition
heydt
thornber
steerability
magnied
transformation
image
rotation
computations
contours
clipped
centered
dirac
anisotropic
evolves
separable
translations
derivatives
particles
ner
freeman
adelson
period
wavelets
directions
neurons
vision
frequency
brownian
translation
series
eigenvector
mm
localized
plane
shapes
cell
equation
mumford
joining
periodic
convolution
primary
continuous
pictures
helix
cortically
isotropy
hypercolumns
implausible
heitger
grating
cells
bar
harmonic
xed
resolution
bases
plausible
periodicity
sources
angle
shifts
straight
symmetries
fragments
integrating
gabors
helical
biological
formation
positions
scale
eectively
angles
modeled
recurrent
bandpass
contradictions
plausibility
twists
particle
salient
formula
artifacts
von
twisted
sampling
rst
experiment
self
density
transform
preference
der
spikes
cortical
reconcile
accurately
contradictory
lter
symmetry
direction
boxes
2d
sparse
equating
appendix
scene
neuron
brain
integral
human
populations
occluded
computa
dierent
shifted
multiscale
rotates
multiplied
perfectly
transformations
evolving
isotropic
product
eect
row
probability
bars
shiftable twistable
completion elds
completion eld
shift twist
fourier basis
stochastic completion
fokker planck
gaussian fourier
twistable basis
planck equation
basis functions
initial conditions
euclidean invariance
euclidean invariant
twist invariant
complex directional
sink elds
receptive elds
coecient vector
directional derivative
visual cortex
r 2
source eld
interpolation functions
fourier series
advection process
shiftable steerable
advection transformation
kanizsa triangle
k x
cddg fourier
basis k
k m
elds due
primary visual
p d
new algorithm
d f
eld coecient
simple cell
nite dierencing
g k
functions k
coecient vectors
cell receptive
visual eld
gaussian cddg
essentially non
twistable functions
dierencing scheme
sink eld
diusion parameter
series frequencies
c k
p x
x 0
equation 2
r 0
contour completion
period x
simple cells
neural network
source elds
coupled basis
initial stimulus
steerable basis
receptive eld
illusory contour
twistable bases
real part
function x
zero fourier
discrete computation
basis function
functions b
periodic function
frequency content
gaussian initial
jacobs 30
evolves according
spatial variables
basic shift
decay constant
discrete computations
simoncelli et
rotated clockwise
contour formation
invariant manner
initial sources
ner scale
biologically plausible
wavelet basis
left column
g x
b k
invariant computation
line completion
initial p
computed using
vector c
vectors p
plane r
m x
proposition 2
equation 5
gaussian fourier basis
shiftable twistable basis
fokker planck equation
shift twist invariant
source and sink
stochastic completion eld
p d f
complex directional derivative
stochastic completion elds
cddg fourier basis
derivative of gaussian
primary visual cortex
williams and jacobs
completion elds due
solving the fokker
essentially non zero
shiftable twistable functions
stimulus in figure
fourier series frequencies
algorithm of 31
nite dierencing scheme
simple cell receptive
k m x
g k x
shiftable twistable bases
p 0 k
coecient vector c
functions k m
interpolation functions b
functions b k
rotation and translation
non zero fourier
using the new
functions on r
position and direction
basis of functions
straight line completion
spatial variables x
zero fourier series
eld coecient vector
form a shiftable
simoncelli et al
sources and sinks
represent the initial
equation 5 9
initial p d
coecient vectors p
shiftable steerable basis
space r 2
equation 2 18
gaussians in x
method of 31
cell receptive elds
illusory contour formation
representing the input
plane r 2
basis functions k
centered at x
fourier basis function
number of basis
rotations and translations
r 0 x
obtained by integrating
diusion decay transformation
notion of shiftability
elds are shown
thornber and williams
positions and directions
d is shift
inside the boxes
computations in primary
completion elds computed
twist invariant manner
fourier basis g

corpus/krapavin2000-test/1007523.txt
students
participants
emacs
testing
compilation
continuous
developer
regression
suites
suite
developers
eclipse
tests
junit
java
staff
worked
statistically
ide
feedback
plug
development
errors
student
prioritization
grade
athena
tool
notification
tools
habits
treatments
questionnaire
productivity
impressions
experiment
success
volunteered
experience
hours
qualitative
distracting
volunteers
threats
effects
ignorance
prioritizing
enjoyed
participant
distract
saff
montana
dialup
unimplemented
coursework
distraction
failing
factoring
edits
assignments
monitoring
edited
treatment
subjects
magpie
perceptions
keystroke
incremental
felt
participate
software
monitored
years
recommend
programmers
demographics
editing
code
mit
users
got
circumstances
clicking
mock
debugging
failed
predicts
fix
mode
questions
reported
teaching
skeleton
predictor
distracted
enjoying
tas
javadoc
annoyance
manual
didn
regarding
completed
tasks
manually
maintenance
editor
modern
ernst
participation
caught
ins
quickly
text
functionality
encouraged
nominal
benefits
validity
striving
elbaum
predictors
ran
tested
experienced
feed
excluded
logs
wasted
benefit
environments
incidental
demographic
helping
compiled
compile
buffers
shadow
believed
quantitative
experimental
empirical
likely
dev
accomplishing
cursor
refactoring
myampersandldquo
classroom
save
deadline
controlled
directory
wanted
reporting
residual
detrimental
tomography
demonstration
familiar
group
watch
excess
surprised
programming
frequent
rapid
passed
knew
cont
louis
professional
remotely
leveraging
methodology
assignment
saved
running
window
compiling
files
envi
sebastian
interoperability
helped
numeric
suggestions
said
privacy
continuous testing
continuous compilation
test suite
problem set
time worked
test suites
statistically significant
regression errors
emacs plug
testing tool
problem sets
development environment
regression testing
regression error
control group
mode line
success rate
regression test
course staff
provided test
test cases
manual testing
using continuous
throughout development
incremental compilation
test factoring
java experience
non participants
development time
software engineering
development environments
statistically significantly
rapid feedback
would recommend
significant effects
experimental treatments
run tests
multiple choice
java ide
participants reported
one said
failing tests
ignorance time
fix time
testing group
programming experience
program changes
test first
work habits
staff provided
wasted development
modern ide
test frequency
delta debugging
student solutions
development 3
testing uses
student developers
emacs development
test driven
junit test
compilation group
better code
qualitative feedback
regression tests
using emacs
tested throughout
students used
used continuous
saff michael
test prioritization
qualitative results
testing continuous
continuous execution
several participants
asynchronous notification
test errors
mock object
shadow directory
driven development
single keystroke
first development
david saff
compilation errors
running tests
plug ins
initial development
programming task
continuous testing tool
run the tests
likely to complete
using the tools
continuous testing group
regression test suite
years of java
tool to others
statistically significant effects
recommend the tool
threats to validity
using continuous testing
complete the assignment
continuous testing uses
saff michael d
provided test suite
first problem set
test first development
compilation and continuous
mock object creation
provided test suites
wasted development time
students were encouraged
test driven development
editing by example
continuous compilation group
significantly more likely
david saff michael
completed the assignment
provided by continuous
creation for test
running the tests
programming by demonstration
using the tool
number of participants
michael d ernst
see section 3
lines of code
whether the extra
continuously run regression
participants using continuous
feature in modern
treatment predicts correctness
development time via
practice of test
controlling the size
evaluation of reading
tests are run
mit s 6
participants and non
testing during development
risk of type
students who volunteered
reducing wasted development
quality of information
state based formal
feedback to developers
used continuous testing
testing and continuous
tests this paper
multiple choice questions
initial failing tests
likely to participate
testing in practice
effective regression testing
prioritization 36 26
second problem set
provided the tools
run regression tests
residual test coverage
striving for compatibility
evolution of software

corpus/krapavin2000-test/623900.txt
ssam
atm
trap
cell
handler
traps
messages
reply
message
remote
workstations
payload
buffer
cells
multiprocessors
sparcstation
clusters
kernel
prototype
device
flow
ss
active
uiomove
read
latencies
void
interface
fiber
sba
send
communication
interfaces
network
driver
buffers
multiprocessor
latency
protection
request
fifo
cluster
operating
receiving
bytes
bandwidths
window
dest
contention
double
trip
layers
sending
fifos
replies
transfer
scheduling
descriptor
pvm
extern
conn
pinned
receive
int
bandwidth
overflow
register
addt
syscall
multiproces
handlers
word
ni
layer
tcp
hardware
registers
coordination
buffering
sbus
ovhd
aal
virtual
interconnected
microseconds
sender
receiver
fore
supercomputing
bulk
workstation
coordinated
comparable
cdrom
instructions
retransmitted
primitives
connection
bus
arrival
polls
networks
reliable
shared
offer
architectures
translation
stream
address
thekkath
readdouble
principally
demultiplexing
futile
rett
delivery
shelf
memory
file
transferred
net
round
reads
pull
networking
processor
aligned
writes
sent
push
loading
kaashoek
culler
losses
protected
ip
reception
peak
overhead
cm
differences
cache
collections
spent
crc
checksum
millisecond
today
breakdown
switches
machines
integration
formatting
decstation
polled
adds
diego
sors
calls
preventing
fd
acknowledgment
sun
id
byte
art
poll
requests
originating
congestion
counter
destination
incoming
processes
software
corruption
dozen
measurements
reliability
across
influenced
paragon
active messages
flow control
network interface
atm networks
atm network
active message
remote memory
network interfaces
system call
user level
address translation
write system
double word
ss 20
communication architectures
operating system
file descriptor
sba 100
device driver
shared memory
receiving end
communication patterns
process scheduling
internal buffer
remote read
messages communication
receive cells
read trap
buffer overflow
communication architecture
reliable delivery
cell loss
parallel applications
per cell
round trip
connection id
handler address
art multiprocessors
reply handler
ssam prototype
atm payload
remote reads
input fifo
control transfer
system calls
tcp ip
user kernel
larger window
communication layer
bulk transfer
communication layers
message data
reply message
system software
memory access
parallel computing
technical point
communication performance
operating systems
low latency
request message
aal 5
receiving network
atm cell
int conn
continuous spectrum
node address
multiprocessor networks
output fifo
operation ss
check fd
int connection
device fifos
syscall overhead
level access
sparcstation active
standard components
extern void
computing setting
cost breakdown
interface access
sparcstation atm
addt l
word aligned
level library
kernel interface
ss 1
ssam implementation
read write
december 04
programming models
split c
coherent shared
protection mechanism
call interface
o bus
experimental set
high performance
supercomputing cdrom
cdrom p
clusters of workstations
remote memory access
active messages communication
write system call
within the network
send and receive
read write system
reads and writes
operation ss 20
cache coherent shared
receiving network interface
network interface access
sparcstation active messages
user kernel interface
messages communication architecture
ss 20 ss
traps to send
clusters and multiprocessors
parallel computing setting
user level library
requests and replies
user level access
conference on supercomputing
december 04 08
flow control information
send a reply
remote memory accesses
cluster of workstations
user level network
system call interface
read and write
diego california united
supercomputing cdrom p
allowed to send
use of standard
acm ieee conference
es december 04
san diego california
california united states
data and control
new communication architectures
polls the receiver
preventing buffer overflow
dec 3 1995
based network interfaces
lack of flow
messages on multiprocessors
trap rett 0
protection in software
loading the cell
bytes of payload
clusters use standard
total for 1
control in atm
g tcp ip
syscall overhead 22
send a request
int connection void
form of protection
buffering and scheduling
system call syscall
write system calls
respect to multiprocessors
bulk transfer rates
fd do uiomove
write entry points
trap which receives

corpus/krapavin2000-test/1011177.txt
rel
monoidal
category
tensor
hypercoherences
poset
functor
coherence
products
morphisms
morphism
jxj
comonad
nite
spaces
coproducts
co
intuitionistic
logic
fne
comonoids
categorical
singleton
powerset
jy
negation
autonomous
closed
fa
denition
coherences
glueing
endofunctor
monoid
compact
candidate
diagrams
symmetric
proposition
biproducts
weakly
girard
exponentials
commutativity
ll
dened
forgetful
lattice
candidates
hx
ha
relations
duality
dual
coincide
preserves
connectives
games
commutative
diagram
pointwise
algebras
monad
satises
collapse
par
fm
faithful
degenerate
comonads
dialectica
lamarche
comonoid
hhx
classical
inequalities
product
fda
suprema
nitary
hom
modalities
underlying
inr
inl
categories
multiplicative
posets
join
isomorphic
constructive
universal
dierent
commute
equipped
restricts
dene
ole
interpretations
fragments
embedding
everything
ie
singletons
ultimately
dierently
fr
joins
diagonal
completeness
chu
encode
exponential
sight
orthogonality
id
yi
units
preprint
identity
seven
sided
motivating
map
largest
maps
multiplication
jaghadeesan
carcinogenic
quantales
hcm
commuting
jxjjy
hypercoherence
comonoidal
cogenerated
flavoured
ehrhard
abramsky
wanted
fd
arrow
picks
universe
transformation
lemma
dening
valued
inequality
cient
jest
hyland
appeals
involution
dually
tidy
semilattices
plete
inma
spoiled
talked
cetera
adjunction
closure
rst
demand
object
facts
dealt
putting
su
genuinely
opponent
contra
ples
abound
rels
plenty
niteness
desired
specied
terminal
really
symbols
spirit
specic
weak
nd
theoretic
meets
circumstances
versus
obvious
spell
subcategory
linear logic
coherence spaces
p f
f set
symmetric monoidal
co products
monoidal closed
compact closed
f sets
tensor product
powerset functor
function space
underlying set
f b
nite powerset
p fne
linear exponential
natural transformation
complete lattice
classical linear
linear function
intuitionistic linear
jxj jxj
largest candidate
exponential comonad
b f
jxj jy
following diagram
categorical structure
autonomous structure
phase spaces
underlying poset
poset valued
valued sets
co product
poset 3
desired inequality
jy j
monoidal category
underlying category
nite products
following diagrams
f f
closed structure
forgetful functor
lemma 7
full completeness
commutative monoid
pointwise join
fa f
monoidal comonad
rel preserves
l _
strictly proof
structure map
constructing models
empty set
universal property
category p
relations rel
resulting category
nite subset
f satises
categorical model
unless p
p f set
f a f
p f sets
symmetric monoidal closed
sets and relations
category of sets
linear function space
f i f
products and co
f b f
models for linear
classical linear logic
intuitionistic linear logic
models of linear
nite powerset functor
linear exponential comonad
products and coproducts
p is symmetric
model for classical
ll in property
b f f
poset valued sets
endofunctor on rel
monoidal closed structure
spaces and hypercoherences
symmetric monoidal category
jxj jy j
category p f
existence of nite
f f b
via the ll
p is autonomous
rel is compact
morphism of p
category of p
n a coherences
functor on rel
model for linear
category of coherence
tensor and par
full and faithful
model of intuitionistic
satises the conditions
x is given
product of two
j jy via
glueing and orthogonality
property lemma 7
unit for tensor
function jxj jxj
morphism of comonoids
linear logic consists
fact that rel
nite subset e
set rel preserves
e of r
linear logic namely
spaces as well
joins and nite

corpus/krapavin2000-test/627737.txt
bayesian
learning
likelihood
probabilistic
networks
sample
fitting
priors
graphical
neural
expert
causal
elicitation
mcmc
symptoms
hidden
causality
mdl
belief
network
buntine
latent
sm
statistics
statistical
markov
artificial
tables
bic
parametric
undirected
gibbs
intelligence
uncertainty
disease
missing
fig
probabilities
feed
conditional
posterior
prior
gaussian
net
mixture
identification
em
tutorial
probability
sigmoid
age
exponential
bayes
methodologies
mining
inference
bivariate
resampling
gaussians
introductions
thinkbank
clim
posteriors
ipf
independencies
valued
occ
heckerman
independence
equivalence
entropy
family
communities
learn
regression
chickering
maxwell
herskovits
tetrad
acquisition
hypothesis
trees
samples
assessment
biases
guide
classification
intelligent
arc
chain
medical
subjective
diagnosis
david
monte
multivariate
forth
russell
rich
pitfalls
pain
stomach
greiner
cart
samplejsm
wermuth
wray
rubric
cjb
weiru
haider
symptomsjdisease
dogma
likelihoods
review
methodology
joint
discovery
selection
medium
carlo
laplace
js
maximization
informative
sampling
diagnostics
phonemes
climate
confounded
spirtes
sajjad
experts
forward
discrete
literature
distributions
moments
social
functional
smoking
whittaker
neat
lauritzen
ovals
stochastic
intervention
classifiers
sparse
parents
maximizing
decision
clustering
lem
incomplete
empirical
greedy
causation
cancer
methodological
casual
agnostic
approximations
popular
arcs
criteria
occupation
nielsen
worked
predictive
nov
directed
training
variety
truth
earliest
scientists
summations
richness
developments
estimate
hybrid
press
prob
fit
forecasting
oxford
decomposable
reproduced
bayesian networks
probabilistic networks
sample likelihood
maximum likelihood
learning bayesian
graphical models
probabilistic network
bayesian network
probability tables
bayesian methods
parameter fitting
model selection
large sample
expert systems
artificial intelligence
likelihood approach
latent variables
exponential family
network structures
neural networks
measure zero
learning graphical
belief networks
feed forward
structure sm
machine learning
conditional probability
hidden variables
complete data
forward neural
structure learning
data assumption
mcmc methods
hypothesis testing
learning probabilistic
net work
statistical methodology
real valued
knowledge acquisition
bayesian approach
bayesian net
true model
sample size
information complexity
medium sample
learning structure
sample phase
bayesian method
fig 6
missing values
sample complexity
information theory
probability distribution
network structure
data mining
probabilistic expert
parameters m
gibbs sampling
classification trees
discrete variables
instance consider
small sample
computational learning
table ii
em algorithm
binary variables
intelligent systems
learning theory
p case
chain monte
learning algorithm
three variables
missing data
likelihood estimate
probability models
probability table
knowledge discovery
hidden markov
single best
chain graphs
sample learning
identification methods
maxwell chickering
represent causality
js d
david maxwell
general probabilistic
identification algorithms
equivalent probability
sigmoid sigmoid
bivariate gaussian
minimum cross
hypothesis space
networks d
greedy search
decision analysis
approximate moments
real values
quality measure
algorithms exist
learning problem
learning v
data analysis
undirected arcs
bayes optimal
informative priors
nov dec
undirected networks
learning research
neural network
learning bayesian networks
maximum likelihood approach
networks from data
literature on learning
learning graphical models
buntine a guide
feed forward neural
uncertainty in artificial
learning probabilistic networks
complete data assumption
methods for learning
conditional probability tables
computational learning theory
forward neural networks
learning of bayesian
given in fig
probabilistic expert systems
learning of probabilistic
chain monte carlo
markov chain monte
maximum likelihood estimate
bayesian networks d
results from computational
nov dec 1997
priors for bayesian
induction of probabilistic
single best model
equivalent probability models
minimum cross entropy
bayesian network structures
set of measure
learning v 29
bayes optimal error
tables for p
general probabilistic networks
e have equivalent
large sample phase
david maxwell chickering
mining and knowledge
machine learning v
journal of machine
machine learning research
learning the structure
structure from data
bayesian net work
feed forward network
hidden markov model
problem of learning
thomas d nielsen
data is related
sample p new
introduces bayesian networks
optimal error rate
variables machine learning
manual knowledge acquisition
real valued variable
area not considered
sample and large
averaging over multiple
provide a rich
small sample medium
use of mcmc
find the structure
structure learn ing
distribution for network
bell weiru liu
structures s d
every two variables
sample medium sample

corpus/krapavin2000-test/627933.txt
declustering
dlb
load
gis
polygons
polygon
spatial
llb
processor
query
processors
grr
speedups
pool
hpgis
balancing
queries
sigma
arr
static
extent
balance
pbm
pdb
chunks
window
declustered
terrain
ids
chunk
polygonization
partitioning
bounding
map
donor
axis
sim
transferring
filtering
idling
parallelizing
hilbert
box
similarity
proceccors
clipped
intersection
imbalance
polygonal
idle
objects
speedup
geographic
avg
metric
decluster
pidset
transferred
overlay
cray
edges
alternatives
graphics
transfer
clipping
maps
engine
iv
pw
population
boxes
visualization
killeen
wsg
apprx
viewport
chains
object
robin
options
peer
secondary
preprocessing
division
parallelization
army
segments
granularity
mimd
density
transfers
grid
leader
sp
iii
otal
lldb
ramachandran
ool
creek
apprxfil
bbox
experimentally
sequential
estimator
sample
trends
parallelizable
dividing
ferhatosmanoglu
imposed
ith
overhead
experiment
finish
subsets
estimating
cells
collections
chunking
overestimates
imbalances
approximator
unpacking
aravind
minimization
increased
files
texas
experimental
achieving
replicated
distributions
join
np
mismatch
approximated
averaged
partition
allocating
hakan
raster
pid
distribute
varied
approximate
requesting
intersects
round
drawback
uniform
disk
expensive
sec
duplicating
dynamic
grids
formulations
allocation
generator
issues
minnesota
adequate
sends
dp
bb
storage
replication
scheduling
statically
systematic
dotted
range query
work load
range queries
spatial extent
declustering methods
extended spatial
similarity graph
gis range
query problem
static declustering
declustering method
load balance
sigma 0
load balancing
load metric
spatial objects
dynamic load
spatial data
dlb methods
axis gives
declustering problem
idle processor
bounding box
extended objects
graphics engine
load density
data partitioning
different processors
terrain visualization
clipped load
polygonal data
sample window
pool size
object ids
load distribution
declustering spatial
polygon data
llb method
processor idling
gis declustering
intersection computation
local load
x axis
intersection points
among different
local data
load imbalance
minimization function
main memory
cray t3d
ith processor
per chunk
different declustering
map overlay
query operation
dlb method
approximate filtering
total work
y axis
distribution based
balancing methods
work transfer
average speedups
good load
based method
static load
static part
line segments
trends observed
filtering computation
static gives
max static
polygon pw
dlb phase
based declustering
pool based
dlb issues
systematic declustering
map 4x
polygon ids
time terrain
declustering extended
static execution
population distribution
donor processor
sim 100
main trends
avg static
gis operations
leader processor
polygon level
iv schemes
balancing techniques
type ii
p processors
run time
point data
mapping function
local processing
bounding boxes
work required
spatial object
work transfers
p subsets
geographic information
high performance
range query problem
gis range query
work load metric
dynamic load balancing
number of processors
extended spatial objects
extended spatial data
among different processors
static declustering methods
number of edges
work load distribution
issues in declustering
x axis gives
y axis gives
chains of line
gis declustering problem
gives the average
good load balance
number of proceccors
set of polygons
sigma 0 003
different declustering methods
extent is assumed
declustering spatial data
local load balance
speedups for different
load balancing methods
improved by using
load balancing techniques
collections of extended
since the declustering
population distribution based
main trends observed
declustering and load
time terrain visualization
methods for parallelizing
segments and polygons
time over 16
range query q
real time terrain
static execution time
declustering extended spatial
static load imbalance
pool based method
granularity of work
range query operation
sigma 0 004
sets of extended
sigma 0 006
gives the number
amount of work
paper we focus
shown in figure
provide a framework
number of polygons
problem is np
declustered into p
metric the spatial
sigma 0 008
similarity graph 100
sim 100 llb
work is transferred
proceccors hilbert sim

corpus/krapavin2000-test/631027.txt
ecs
client
ru
server
cs
clients
dbms
jobs
throughput
queue
job
disk
cached
sqs
qus
update
workstations
orkload
manager
pages
architectures
curves
rad
database
page
upd
unify
cache
mtts
caching
instr
speedup
concurrency
locks
delis
commun
ccm
datapages
ccp
rates
cpu
mpl
lock
workstation
configurations
rd
updates
abrt
quss
locking
workloads
queuing
streams
blocked
experiment
writer
query
decline
abort
perc
sts
lqs
kanitkar
commit
configuration
architecture
logs
generator
workload
increments
diskless
instructions
participating
alue
vinay
resident
rel
multiprogramming
deadlock
curve
accesses
alex
mtt
cmt
rocessingqueue
roussopoulos
mix
consistency
selectivity
queued
packages
disks
request
enhanced
cont
aborted
incremental
msec
writers
dbmss
simulation
scalability
network
read
pertinent
cpus
gains
join
mips
selections
tuples
ready
mainframe
qualifying
percentage
light
site
declines
submitting
kill
transaction
binding
adms
logrd
ddlock
prc
commence
readqueue
notify
requests
memories
submits
examine
depicts
queries
serviced
databases
pure
fract
mbits
mesg
locked
buffered
retrieval
log
deadlocks
requested
stream
resources
lan
dewitt
awaiting
ism
routed
stations
queues
modern
readers
clustered
submitted
responsible
selectivities
timestamped
flushed
bytes
min
volume
requesting
depicted
tuple
multiprogrammed
modifications
predominantly
prototype
serious
rate
counterparts
linearly
decides
utilization
simulators
utilizing
transfers
soft
principal
centralized
coherence
loads
chart
catalog
file
nick
benchmarking
rec
updated
differential
ecs cs
server dbms
client server
ru cs
cached data
rad unify
sqs u
dbms architectures
throughput rates
server disk
concurrency control
w orkload
orkload generator
jobs min
network manager
client disk
update curves
main memory
update rates
enhanced client
cs 8
zero update
ecs architecture
disk access
cs 6
throughput speedup
server database
blocked queue
commun software
client main
alex delis
cs 4
u experiment
dbms architecture
cs ru
clients figure
cs 2
update rate
access time
server relation
workstation server
simulation packages
unify type
light update
update jobs
ecs server
update streams
pure update
ready queue
send queue
control manager
almost linearly
client cache
server architecture
log page
write type
ecs clients
cs configuration
ecs performance
almost proportional
cont caching
one writer
caching perc
increases almost
every client
database architectures
disk reduction
ru ecs
kanitkar alex
update curve
client cpu
ru throughput
ecs model
cs curves
vinay kanitkar
meaning v
sts u
cache memory
disk accesses
queuing model
input queue
shared database
query update
closed queuing
v alue
cs 0
cache consistency
page accesses
database system
non zero
output queue
new data
parameter cont
demand new
active jobs
server relations
page instructions
appear much
incremental access
ecs throughput
diskless client
p rocessingqueue
cs throughput
queue ccm
lqs u
abort queue
tuple selectivity
update queue
update blocked
queue abrt
differential files
ru configuration
server concurrency
cpu mips
software application
update workload
application soft
queue send
dbms configurations
service module
control queue
queue cmt
appropriate client
ecs 2
commit queue
server main
data caching
client server dbms
w orkload generator
cs and ru
number of clients
enhanced client server
non zero update
ecs cs 8
number of workstations
disk access time
client main memory
server dbms architecture
rad unify type
cs 4 ecs
ecs cs 4
cs 6 ecs
cs 8 ecs
zero update curves
client server architecture
concurrency control manager
server disk accesses
ecs cs 2
vinay kanitkar alex
client disk access
cont caching perc
meaning v alue
increases almost linearly
cs 2 ecs
ecs cs 6
ru and ecs
kanitkar alex delis
type of dbms
server dbms architectures
examine the performance
scalability of client
ru cs curves
queue send queue
software application soft
clients the ecs
commun software application
queuing network models
server main memory
ecs over cs
appear much later
pure update workload
server disk access
server concurrency control
ecs 2 ecs
performance of ecs
workstation server architectures
commit queue cmt
concurrency control queue
ecs cs 0
control queue ccm
cs and ecs
sqs u experiment
parameter cont caching
range of 4
abort queue abrt
client server database
demand new data
closed queuing network
main memory size
number of participating
two phase locking
performance and scalability
parallel databases v
simulation results show
distributed and parallel
update rates 1
experiments sqs u
high throughput rates
ru over cs
queue abrt update
client s site
disk tr average
three alternative workstation
instr log page
enhanced workstation server
delis nick roussopoulos
client client client
two system configurations
percentage of server
queue workload generator
pure update workloads
server database architectures
tradeoffs in client
simple database operations
mpl concurrency control
consistency of client

corpus/krapavin2000-test/613633.txt
urn
hfn
dns
url
urls
lookup
hfns
urns
contact
resource
naming
name
service
replica
resources
directory
forwarding
web
proxy
resolution
scalability
leaf
pointer
server
rfc
uri
location
replicas
doi
globe
names
record
lds
subnode
geographical
replicated
caching
servers
named
humans
resolver
locality
browser
records
resolve
resolved
pointers
rds
resolving
friendly
internet
caches
root
worldwide
services
isbn
ietf
mappings
pages
node
responsible
store
shenker
authority
intel
cache
linux
host
insert
scalable
uris
tanenbaum
walfish
arno
subnodes
steen
bakker
sandpiper
visited
email
infrastructure
contacts
org
mobile
visits
src
subdomain
popular
akamai
ldap
namespace
ratnasamy
registry
sigcomm
mapping
human
nl
book
requests
located
load
kbyte
originate
replication
bind
setup
sylvia
campus
vu
gbyte
houston
remembered
fanout
hari
contacting
balakrishnan
domains
nearby
administrative
ip
storing
florida
request
deals
locating
francisco
authorities
parent
scott
identifies
handle
registered
yellow
resolves
stored
miami
prefix
stable
working
subsequently
regularly
delete
corporation
wants
destinations
retrieve
middleware
lightweight
usa
texas
suffix
com
overloaded
cached
responsibility
broadens
friendliness
federations
criticize
rfcs
aurn
transcribable
locators
universiteit
wijngaards
brazier
vrije
registries
hendricks
prisco
cated
mealling
cnrp
posal
overeinder
crispo
area
update
hardly
users
avoids
nodes
html
associates
primarily
hosts
hierarchical
andrew
hashing
fective
akella
misusing
maarten
location service
name service
contact record
lookup operation
web resources
dns name
lookup operations
forwarding pointers
forwarding pointer
lookup length
name server
name space
leaf node
directory node
replica replica
name servers
name resolution
url url
urn mapping
url mapping
name system
hfn resolution
contact records
geographical area
domain name
host name
mobile resources
contact field
resource records
uniform resource
working group
human friendly
replicated web
root node
resolution process
naming authority
urn name
url resolution
large geographical
naming system
average lookup
usa node
common name
resource record
directory services
web browser
insert operation
named resource
popular web
hierarchical name
intel com
handle system
linux org
identify resources
scalability problem
resource model
common names
resource named
existing dns
resolution scheme
lookup requests
url proxy
src linux
leaf domain
uri scheme
pointer cache
globe location
pointer caches
multiple urls
search tree
leaf nodes
resolution service
resolution mechanism
using dns
system dns
m relation
dns infrastructure
wide area
processing load
scott shenker
highly mobile
access information
partitioning scheme
local access
update operations
nodes visited
scheme called
ip addresses
one urn
single urn
server responsible
hfn to url
hfn to urn
domain name system
replica replica replica
set of urls
url url url
path of forwarding
large geographical area
average lookup length
sequence of name
hierarchical name space
urn to url
common name resolution
urn name space
want to support
src linux org
replicated web resources
number of lookup
name system dns
globe location service
highly mobile resources
popular web resources
number of resources
uri scheme called
forward the request
retrieve web resources
replica is added
pointer to n
number of contact
service in step
stored in dns
andrew s tanenbaum
replicated web pages
way to name
requires our name
name web resources
url resolution mechanism
uniform resource identifiers
dns to store
web resources named
resources when possible
need to contact
existing dns infrastructure
form of scalability
lookup operation finds
contact the sequence
human friendly naming
using the domain
human friendly names
hosts and email
scheme called human
called human friendly
node for d
service to provide
n to m
space always originate
using the dns
international doi foundation
service we use

corpus/krapavin2000-test/1035802.txt
latest
secondary
gossip
tertiary
automaton
stamps
automata
primary
asynchronous
events
event
stamp
sentry
prim
processes
ter
frontier
buchi
sigma
ideals
ij
labels
zielonka
ideal
synchronizations
cellular
stamping
agents
determinizing
trace
sec
synchronize
label
locally
flatest
determinization
ha
upto
word
ua
pq
concurrent
transition
inf
track
alphabet
traces
complementation
synchronization
jointly
computable
ary
frontiers
synchronizes
update
sp
recognizable
synchronous
hp
gossiping
timestamping
totally
indexed
reading
agent
heard
qp
bits
asychronous
mazurkiewicz
bmyampersanduuml
thiagarajan
infinite
meets
participating
suffices
disappears
arrays
consistently
shall
ae
fp
assign
synchronizing
knows
labelling
maintain
strings
assigned
communicating
counters
tackle
amongst
views
pairwise
decide
crucial
letter
mappings
proposition
action
counter
sg
passing
participated
constructible
combinatorics
comprehensible
reused
exchange
quadruple
theoretic
causality
logic
lemma
max
bounded
sacrificing
deterministic
abbreviate
unambiguously
remarked
across
communication
induction
convenience
fix
progresses
unused
theta
correctly
belongs
val
involving
keeping
participates
languages
transitive
crash
behaved
communications
incomparable
fprim
gastin
mythical
describable
wolper
asnchronous
dexed
valg
trptl
fsec
sohoni
surpisingly
recedes
dispensed
madhavan
lodaya
varaibles
assimilate
milind
bacabba
fter
israeli
cbadecc
stored
feel
confusion
chi
assertions
fly
message
exchanging
optimizing
entries
hypothesis
temporal
coordination
keep
suffice
klarlund
cybernetica
chronously
reappear
narayan
safra
rq
concurrrent
mukund
synchroniza
parallels
quintuple
closure
latest p
secondary information
latest q
gossip automaton
primary information
q r
p q
secondary p
asynchronous automata
time stamps
primary p
tertiary information
sec p
prim p
time stamp
ter p
event latest
latest information
e u
asynchronous automaton
ij p
secondary q
r sentry
q e
tertiary p
asynchronous cellular
p sec
event e
process p
e 2
primary secondary
secondary events
gossip problem
cellular automata
q 2
p r
r e
p event
q latest
p p
e latest
locally computable
ij q
max p
latest gossip
new event
time stamping
word u
bounded time
frontier pq
latest r
buchi asynchronous
reading w
trace languages
v maximum
trace theory
maximum p
p 2
r 0
p e
initial event
bounded concurrent
local transition
n bits
automata asynchronous
secondary event
q events
r latest
p primary
update primary
compare primary
q event
primary q
p secondary
deterministic asynchronous
indexed set
arrays prim
communication sequence
recognizable trace
determinization construction
asynchronous mappings
event 0
primary events
totally ordered
r 2
synchronous communication
keep track
infinite traces
p theta
local states
transition relation
local state
theta p
finite set
every q
process q
take part
using o
e 0
e 1
latest p q
latest q r
latest p r
event latest p
p q r
primary and secondary
q 2 p
p q e
processes in p
p sec p
asynchronous cellular automata
prim p sec
p and ter
secondary and tertiary
r e u
information of p
q latest p
e 2 secondary
q r e
r 2 p
q r 2
events in e
set of processes
p 2 p
set of events
bounded time stamps
across the system
processes which synchronize
e latest p
latest p p
stored in prim
q e u
maximum p event
compare and update
sentry for p
p theta p
whenever a set
events are totally
p q latest
latest q p
ideal and p
information of processes
q r 0
sec p q
meets the processes
v maximum p
processes in c
p after reading
recognizable trace languages
secondary event latest
set p p
buchi asynchronous automata
arrays prim p
information about r
r 0 r
log n bits
respect to q
every q 2
sets of events
information that p
p with respect
automata on infinite
event in e
p and q
q r p
processes which take
event in ij
deterministic asynchronous automaton

corpus/krapavin2000-test/636696.txt
protocol
akc
ak
mti
public
secret
confirmation
authentication
elliptic
agreement
entity
attack
ephemeral
protocols
ra
keys
authenticated
diffie
security
subgroup
validation
attacks
hellman
cert
secure
curve
entities
wa
prime
rb
vanstone
menezes
adversary
key
oorschot
private
establishment
authentic
static
ansi
mac
intercepts
implicit
logarithms
hash
cryptographic
possess
certificate
pass
computes
shared
possession
prudent
authenti
attributes
terminates
certificates
secrecy
sends
rogaway
bellare
honest
believes
wiener
launched
logarithm
session
field
unknown
deposit
purported
failure
validated
fr
burden
anomalous
verify
yacobi
ah
kea
krawczyk
rbwb
mtb
vaudenay
desirable
curves
share
assured
impersonation
cipher
verifiably
scalar
ca
message
encryption
xq
burmester
kyung
impersonate
sha
bank
proven
attribute
funds
van
derivation
qu
timestamping
blake
party
intractable
shim
tb
wilson
certified
securely
multiplication
transmitted
discrete
cation
mutual
reliance
subgroups
embedded
compromise
generates
divisible
encrypted
holder
integer
messages
pointed
exercised
multiplications
replaces
composite
goals
heuristic
informally
format
validating
recommended
guard
cryptography
coordinate
bits
sent
shs
pohlig
unauthenticated
tiality
ecdlp
graaf
solinas
succumbs
semaev
johann
araki
expo
hellmann
goss
bitlength
headquarters
tillich
confiden
sik
cryptanalysis
skipjack
raimondo
evertse
cofactor
minding
imai
purportedly
kaliski
takashima
subverts
groschdl
strangio
mqv
engages
rawa
szekely
interactiveness
verifies
verifying
knows
key agreement
public key
key confirmation
protocol 1
f q
elliptic curve
ak protocol
shared secret
implicit key
domain parameters
static public
key validation
key authentication
akc protocols
unknown key
protocol run
authenticated key
pass ak
key share
agreement protocol
small subgroup
mti c0
point sends
protocol 2
random integer
b computes
akc protocol
mti a0
subgroup attack
agreement protocols
secret k
protocol protocol
diffie hellman
integer r
protocol 3
private key
secret key
one pass
point k
known key
share attribute
embedded key
three pass
entity b
validation fails
ephemeral public
key derivation
two pass
public keys
protocols described
discrete logarithm
key establishment
key pair
static private
desirable security
share attack
provide implicit
key wa
derivation function
arguments suggest
b terminates
e intercepts
security attributes
mutual implicit
van oorschot
prime order
e f
provide key
elliptic curves
heuristic arguments
base point
r computes
logarithm problem
field f
hash functions
one entity
two entities
active attacks
b generates
finite field
finite point
related protocols
field elements
explicit key
secure ak
ansi x9
cert b
computes mac
ra cert
key security
authenti cation
ra figure
formally proven
purported public
static keys
second entity
mac 0
q fr
authentic copy
ak protocols
honest entities
pass protocol
two field
ephemeral key
proper format
order n
private keys
valid set
divide q
protocols proposed
see x3
performance attributes
parameters q
failure otherwise
message authentication
failure 3
run with failure
implicit key authentication
unknown key share
ak and akc
terminates the protocol
key agreement protocol
authenticated key agreement
random integer r
pass ak protocol
computes the point
e f q
static public key
key agreement protocols
small subgroup attack
generates a random
r a computes
ak protocol protocol
shared secret k
two pass ak
embedded key validation
key share attribute
public key validation
field f q
integer r computes
heuristic arguments suggest
provide key confirmation
ephemeral public key
mti c0 protocol
key share attack
mti a0 protocol
one pass ak
protocol protocol 2
provide implicit key
attributes of ak
discrete logarithm problem
set of domain
q i e
elements of f
said to provide
suggest that protocol
desirable security attributes
shared secret key
subgroup of order
format for elements
two field elements
known key security
possess the unknown
goals of secure
domain parameters q
parameters and static
fr a b
see x3 2
validated as described
listed in x2
described in x3
parameters q fr
verify that n
given a valid
satisfies the defining
validation of ra
oorschot and wiener
n 2 160
equation of e
establish a shared
keys are set
mutual implicit key
static public keys
key derivation function
ak protocol 1
purported public key
explicit key authentication
computes mac 0
authentication and key
generated by p
hellman key agreement
protocol is said
model of distributed
elliptic curve e
fails then b

corpus/krapavin2000-test/634719.txt
recurrence
polynomials
orthogonal
holonomic
classical
pols
swarttouw
koornwinder
polynomial
differential
monic
coefficients
unknowns
maple
equating
meixner
bessel
hypergeometric
standardization
numerator
laguerre
retode
obner
charlier
nonlinear
denominator
exit
warning
hermite
zeros
solutions
equation
identities
gammag
bring
rational
discrete
equate
rewrite
shift
oe
hahn
jacobi
powers
denominators
ae
family
ff
gr
chebyshev
multiples
krawtchouk
pollaczek
equations
falling
multiply
radicals
gammax
degree
accessible
affirmative
maxfn
classified
transformation
transformations
factorial
definite
return
gamman
nonnegative
jn
chapter
lowest
deduce
bases
families
rewriting
gets
orthogonalen
favard
leipzig
rationally
hypergeom
inators
differentialgleichungen
askey
deltarp
htwk
mws
groebner
polynome
liouvillesche
worksheet
imn
durch
racah
hyperterm
koepf
klassischen
pochhammer
charakterisierung
decides
densities
density
ag
substitute
translated
sturm
denom
universities
factorials
strict
transform
fa
xq
pleasant
shifted
summation
agree
classification
difference
qx
nontrivial
lim
coeffi
solve
yields
backward
die
continuous
institutions
boils
amsterdam
tom
abbreviation
algorithmically
summand
thanks
valid
forms
turns
ren
transforms
normal
cn
quantum
vanish
substituting
pn
invariant
analogue
bn
overlap
finitely
besides
formulas
ax
dictionary
question
dx
algebra
brackets
brought
der
html
visit
handbook
shifts
command
applicable
brings
decomposing
linearly
transformed
yet
cients
representations
converse
inverse
tedious
implying
returns
demands
generates
vectors
interval
modification
resolved
operators
assertion
sequel
collect
mathematical
acknowledgment
weight
article
recurrence equation
orthogonal polynomial
orthogonal polynomials
polynomial solutions
classical orthogonal
difference equation
n x
discrete orthogonal
classical discrete
q orthogonal
classical q
three term
term recurrence
q difference
holonomic three
polynomial solution
exists exit
nonlinear system
differential equation
p n
linear transformation
solution exists
c d
standardization given
koornwinder swarttouw
given holonomic
oe x
b c
yet unknowns
maple implementation
k n
c n
linear transformations
ae x
d e
x n
polynomial form
transformation x
gammag f
gr obner
unknowns f
given recurrence
bases methods
x gammag
lowest terms
warning parameters
obner bases
equation 1
resulting equations
polynomial system
polynomial identities
linear transform
one gets
e f
e c
e according
equation x
normal forms
see e
x 7
u n
exit 4
solution vectors
common denominators
monic set
implementation rec2ortho
coefficients equate
degree exactly
table 22
difference equations
q polynomials
shift shift
step according
make monic
applicable 1
e b
degree one
equating coefficients
equation p
chebyshev polynomials
output return
rewriting rewrite
two resulting
information includes
set e
b n
family 1
n given
algorithm 2
parameter ff
algorithm decides
rational functions
define v
algorithm 1
orthogonal polynomial solutions
classical orthogonal polynomial
classical discrete orthogonal
classical q orthogonal
p n x
three term recurrence
term recurrence equation
b c d
n is larger
holonomic three term
solution exists exit
recurrence equation 1
orthogonal polynomial solution
polynomial solution exists
d and e
denominator of e
e c n
unknowns a b
q orthogonal polynomials
q difference equation
q orthogonal polynomial
swarttouw s rec2ortho
discrete orthogonal polynomial
classical orthogonal polynomials
return no classical
c d e
d e f
degree of either
discrete orthogonal polynomials
equating the coefficients
equation has classical
rewrite the recurrence
e a n
coefficients of x
either the numerator
u n x
f and g
e b n
differential equation 3
x or u
obner bases methods
given holonomic three
larger than 4
coefficients a b
zeros of oe
either t n
transformation x 7
linear transformation x
bring them therefore
difference equation 5
therefore in polynomial
x gammag f
implementation these results
ff 2 r
given recurrence equation
gr obner bases
yet unknowns f
using our implementation
n 1 0
see e g
n 2 n
x 7 x
results are obtained
n 1 k
constant with respect
input a holonomic
applicable 1 input
obtained by strict
polynomials are multiples
recurrence equation p
monic set e
solutions and returns
equations this results
difference equation x
cases i e
data if applicable
difference equation 6
e r x
multiply these identities
equation 2 shift
one in x
polynomials are given
consider the recurrence
denominators and bring
recurrence equation 2

corpus/krapavin2000-test/628710.txt
trilinear
views
epipolar
projective
coefficients
homographies
affine
homography
orthographic
pixels
camera
recovering
3d
seven
motion
image
projection
shashua
recognition
plane
bilinear
geometry
trilinearity
amnon
perspective
epipoles
recovered
correspondences
vision
squares
scene
uncalibrated
multiples
bca
reconstruction
nine
cameras
across
quan
eight
noise
intersection
planes
visual
invariants
projected
intelligence
matrices
displacement
alignment
coordinates
collinear
novel
maximal
linearly
avidan
reprojection
lefthand
navab
recover
frame
algebraic
scalar
tensors
lens
columns
correspondence
equations
tensor
object
images
righthand
centers
tri
compatible
fundamental
stereo
gideon
luong
nassir
funding
2d
trials
occlusions
geometries
error
onto
display
calibration
matrix
pgl
ortho
tele
epipole
coming
shape
hypersurface
coplanar
recogni
intertwined
singular
averaged
ronald
stein
shai
frames
metric
scale
ambiguities
imaging
laboratory
reference
lemma
auxiliary
ignoring
undergo
focal
invariant
scaled
infinity
rigid
dealt
robustness
cv
equating
re
pin
sender
pixel
uniqueness
biological
regularities
graphic
ff
curved
emphasized
triplet
phi
sensitive
1d
multiplying
ground
surfaces
cubic
hole
center
canonical
self
combination
projecting
chung
configuration
configurations
behaved
mourrain
lowed
strm
devi
gln
oliensis
sugimoto
funda
alignmentyielding
torfi
1dretinal
jianbo
ortn
marugame
strum
yanlin
bilin
sminchisescu
hayman
hartley
meridian
sturtz
mutsumi
asingle
velten
vince
cartridges
thrhallsson
mirko
bilinearity
heyden
oskarsson
orthographically
kalle
re projection
corresponding points
three views
trilinear functions
epipolar intersection
model views
epipolar geometry
points across
maximal error
linear solution
reference views
seven points
average error
re projected
two reference
perspective views
novel view
orthographic views
across three
fundamental matrices
linear combination
trilinear result
third view
scale compatible
projection error
image coordinates
vision v
visual recognition
machine intelligence
trilinear forms
v 00
amnon shashua
pattern analysis
eight points
intersection method
linearly independent
intelligence v
image noise
least squares
algebraic functions
two model
whose columns
seven corresponding
relative affine
trilinear form
combination method
view 3
v 0
linear least
computer vision
non metric
fundamental matrix
minimal configuration
affine structure
parallel projection
projection using
3d reconstruction
minimal number
two orthographic
trilinearity result
perspective view
lefthand display
maximal re
camera transformation
self occlusions
coefficients ff
error averaged
righthand display
average re
eight corresponding
three perspective
bca gamma1
recovered linearly
nine trilinear
trilinear coefficients
correspondences across
via alignment
x 00
international journal
four equations
five corresponding
bilinear functions
scalar k
long quan
matrix whose
ieee transactions
two views
nine points
achieve reasonable
ground plane
four corresponding
3d visual
y 00
theorem 1
squares solution
v 22
corresponding points across
across the three
multiples of v
pixels and average
two reference views
re projection error
across three views
transactions on pattern
analysis and machine
machine intelligence v
epipolar intersection method
exists a scalar
columns are multiples
number of corresponding
two model views
computer vision v
points were used
structure from motion
linear combination method
seven corresponding points
re projection using
using the trilinear
linear least squares
methods for recovering
journal of computer
number of points
matrix whose columns
intelligence v 22
problem of re
recovering the fundamental
bca gamma1 h
three perspective views
pair of trilinear
eight corresponding points
used for recovering
four corresponding points
average re projection
functions are linearly
coefficients were recovered
maximal re projection
two orthographic views
projection error averaged
functions of views
presence of errors
points across three
third view 3
homographies from 1
functions of image
five corresponding points
x 00 y
need to recover
v 22 n
least squares solution
projective space p
affine and projective
coefficients identical across
using all 34
case v 0
combination of views
one can manipulate
errors in image
linear combination methods
shai avidan amnon
relative affine invariant
three corresponding points

corpus/krapavin2000-test/631253.txt
lqn
requesthandler
client
ioout
server
uml
architectural
pipeline
collaboration
ioin
filters
buffer
processor
semaphore
replications
utilization
ioexec
downstreamfilter
upstreamfilter
rh
software
fig
proc
request
stackout
stackin
telecommunication
collaborations
throughput
serialization
message
services
requests
accessor
submodel
filter
bottleneck
container
synchronous
configurations
queueing
reply
modelling
behavioural
processors
entry
service
behalf
servers
asynchronous
upstrmfilter
coallocation
downstrmfilter
modelled
architecture
forwarding
hardware
rectangle
configuration
utilizations
waiting
critical
clients
passive
devices
usern
pulls
mirandola
raffaela
entries
thread
busy
attributes
proposes
connector
arc
dummy
io
database
phases
demands
tasks
visits
patterns
task
queue
messages
rendezvous
rome
interactions
object
idle
item
shared
bottlenecks
achievable
diagrams
toolset
behaviour
allocation
script
replication
cortellessa
petriu
lifeline
grassi
allocated
excessive
read
measurements
served
sect
submodels
lifecycle
blackboard
callers
wait
transformation
roles
early
alternatives
serializes
weaknesses
saturated
active
structural
quantify
vincenzo
vittorio
arcs
frequently
systematic
slave
broker
arrow
sigsoft
transformations
qn
delegates
accepting
capacity
pattern
response
circle
scenarios
optionally
corba
stochastic
objects
running
utilized
exchanged
loads
layered
bridging
pushes
exposes
insure
exclusive
delays
italy
invoke
named
handler
scheduling
responsible
diagram
cpu
offer
stages
replies
initiating
contained
assess
processes
threads
device
contributions
development
lqn model
architectural patterns
client server
processor node
software architecture
performance models
telecommunication system
performance attributes
task entry
requesthandler replications
software performance
asynchronous message
upstreamfilter downstreamfilter
replications utilization
request arc
performance modelling
processor configuration
processor nodes
critical section
shared object
stackin stackout
processor database
task utilizations
performance engineering
lqn submodel
lqn task
passive object
achievable throughput
performance analysis
software components
useful work
performance model
different processor
synchronous message
server systems
level architecture
downstreamfilter buffer
utilization ioout
proc base
forwarding message
excessive serialization
database requesthandler
buffer upstrmfilter
included services
accessor shared
software bottleneck
architectural pattern
software task
buffer upstreamfilter
semaphore task
object operations
fully modified
upstrmfilter downstrmfilter
server client
class object
queueing network
high level
performance limitations
modified system
server may
model parameters
active objects
execution times
see fig
server pattern
multi server
serialization constraints
section accessor
critical sect
half way
building performance
base case0
modified system0
container contained
raffaela mirandola
lqn models
level architectural
software server
distributed software
performance july
constraint sequential
configuration base
early performance
coallocation container
time demands
way modified
processing power
critical sections
frequently used
systematic approach
buffer figure
software architectures
service requests
different software
system request
next item
hardware devices
architectural connection
performance characteristics
may offer
different configurations
pipeline and filters
number of requesthandler
different processor nodes
requesthandler replications utilization
running on different
pipeline with buffer
client server client
shown in fig
approach to building
high level architecture
upstreamfilter downstreamfilter buffer
due to excessive
structural and behavioural
buffer upstrmfilter downstrmfilter
buffer upstreamfilter downstreamfilter
client server systems
users are running
filters are running
proc base case
pipeline with message
replications utilization ioout
proposes a systematic
number of visits
hardware to software
behalf of different
high level architectural
software task entry
section accessor shared
described in fig
critical section accessor
case of 6
server client server
modified system0 20
building performance models
thread of control
software performance engineering
processor database requesthandler
shared object operations
base case0 20
system is saturated
client server pattern
processor configuration base
july 24 26
performance july 24
modelled as entries
coallocation container contained
half way modified
configuration base case0
maximum achievable throughput
software and performance
software and hardware
workshop on software
notes v 29
n 1 january
co allocation collaboration
request handler ioout
level architectural patterns
task that plays
buffer filter1 1
task are executed
processor ioexec database
object flow carried
task entry seen
queueing network lqn
execution time demands
level software architecture
configurations with one
database requesthandler figure
cause for performance

corpus/krapavin2000-test/627715.txt
inconsistency
esr
sr
cesr
import
query
serializability
ets
transaction
preconditions
imported
precondition
read
cut
item
export
serializable
epsilon
sdb
queries
tp
monotonic
commit
update
limit
committed
updates
consistency
serialization
concurrency
aborts
conflicts
database
accounts
balance
limits
history
steady
acta
escrow
acc
inconsistent
unilateral
conflict
safe
classic
begin
aborted
items
concurrently
monotonically
orderings
metric
tight
imposed
progress
optimistic
banking
begins
writes
interval
uncommitted
molina
ffl
percolate
byproducts
chrysanthis
debited
wiederhold
reads
maintain
lock
garcia
spaces
triangle
savings
inequality
pessimism
tei
qsr
sagas
lok
invoked
distance
management
kuo
expressions
quasi
atomicity
invariant
variation
dollars
credited
locks
bank
write
asynchronous
demarcation
deposits
correctness
divergence
imports
transactions
inconsistencies
violate
compensating
semantics
events
lie
executions
exported
wolfe
tighter
iff
money
interdependent
protocol
concurrent
reservation
derivation
et
autonomy
designer
invariants
relaxed
cycles
lend
imposes
maintained
produced
checking
exceeded
max
histories
asynchronously
millions
bounds
informally
induced
begun
wei
consistent
predicate
prabhu
lyman
abstractepsilon
fcurrent
shavit
aloysius
tamma
yunsheng
debit
deltaf
evaggelia
depeng
serlialized
totok
saga
deltaj
percolates
touitou
pitoura
polarized
wlca
speegle
lagging
indexeddata
obliterated
pamela
juen
old
preventing
taxonomy
philip
final
barbara
tolerate
brevity
maintaining
intervals
null
avoided
execute
intersects
characterization
account
databases
bounded
violates
saw
korth
cut q
c sr
import limit
result inconsistency
q x
limit q
data item
query et
begin read
read q
update transaction
inconsistency q
x import
final change
begin write
update transactions
current x
following precondition
account balance
current change
query q
epsilon serializability
update ets
import inconsistency
write interval
inconsistency imported
update et
bounded variation
x read
classic serializability
x current
initial initial
query ets
inconsistency limit
imported inconsistency
q final
import limits
read interval
data items
export limit
q initial
x operations
database state
concurrency control
values read
history h
transaction management
item x
inconsistency x
inconsistency due
conflict based
write intervals
inconsistency bound
tp system
max change
cesr relations
q begins
data inconsistency
inconsistent data
state space
ffl 0
export inconsistency
q reads
checking account
data read
x q
lock based
monotonic functions
metric spaces
metric space
triangle inequality
inconsistency caused
cesr edge
et queries
end write
concurrent updates
invariant corresponding
distance u
safe q
input inconsistency
et q
inconsistency limits
monotonic queries
distributed tp
ets may
bounded functions
current account
committed cut
stronger invariant
sr relation
inconsistency bounds
steady functions
sr relationship
checking accounts
max inconsistency
unilateral commit
h x
data values
distance function
old state
transaction executions
consistent update
large ffl
application designer
divergence control
amount of inconsistency
limit q x
value of x
import limit q
write t x
read q x
inconsistency q x
x import limit
begin read q
change t current
read by q
precondition for begin
current x import
x q initial
q final change
cut q final
result inconsistency limit
q x import
data item x
sr and cesr
initial initial initial
import inconsistency q
inconsistency limit q
query can lie
database state space
transactions in cut
checking account balance
individual data items
increase in inconsistency
x i initial
current account balance
interval with respect
c sr relation
q reads x
c sr relationship
committed cut q
large ffl 0
cut q begins
safe q x
types of queries
limit t x
inconsistency t x
x i read
definition of esr
read and write
class of queries
respect to x
degrees of consistency
greater than 5
value of f
query et sums
credited the distance
consistent database states
show how esr
x begin read
et for example
serializability is defined
state on disk

corpus/krapavin2000-test/1013722.txt
covertext
alice
stegosystem
stegotext
steganography
bob
hiding
eve
entropy
deltat
adversary
repetition
compression
secure
security
steganographic
prisoners
adversaries
pc
message
secret
passive
encoder
stegosystems
watermarking
universal
authentication
embedding
hidden
pad
eurocrypt
fingerprinting
warden
willems
decoder
theoretic
encoding
fi
kp
distributions
lempel
copyright
hypothesis
coding
ziv
decode
perfectly
active
simmons
bit
alphabet
innocent
block
ff
probabilities
protection
ettinger
covertexts
tology
steganalysis
testing
unconditionally
inactive
embedded
tampering
neyman
pq
maurer
cryp
observing
equilibria
conditioned
decoding
advances
pearson
cryptology
decision
statistics
px
source
probability
accepting
messages
blocks
stochastic
bits
discrimination
legitimate
sent
statistical
encoded
jv
cryptography
indistinguishable
hide
parties
audio
detection
external
monochrome
plenary
cjz
crypto
pcz
falsely
perceptible
blahut
stegotexts
accuses
boyko
perceptional
stego
fumy
prison
zfk
subliminal
blocklength
fool
jail
isln
ueli
error
sends
knows
channel
unrealistic
compressed
conditional
detect
rank
uniformly
distinguishing
watermark
thwart
waidner
realms
exerted
traitor
swiss
buffer
ultimately
concatenation
ranking
fraudulent
xjy
intellectual
suspicious
ban
elias
authenticating
cover
bayesian
terminology
game
text
quantify
stationary
rivest
buyer
recency
pu
gammaffi
literally
ergodicity
retransmitted
illegal
data compression
deltat y
relative entropy
information hiding
block y
covertext distribution
covertext c
repetition time
hypothesis testing
ii error
hidden information
average repetition
universal data
information theoretic
error probabilities
decision rule
perfectly secure
embedded message
type ii
d pc
active adversaries
repetition times
whether alice
hidden message
key k
passive adversary
prisoners problem
passive adversaries
pc c
ffl secure
pc kp
time pad
information theory
theoretic model
secret key
time deltat
bit message
probability distributions
authentication theory
containing hidden
secure stegosystems
covertext source
message c
source coding
secure stegosystem
probability fi
hiding information
pq 0
entropy d
embedding function
random variable
message e
statistical decision
uniformly random
n bit
unconditionally secure
compression algorithms
generated according
compression algorithm
h 0
decision theory
one time
source output
tology eurocrypt
y deltat
x conditioned
copyright protection
covertext distributions
d pq0
blocks y
ziv algorithms
binary partition
source statistics
steganographic system
pearson theorem
covertext statistics
hiding terminology
source r
sending covertext
steganographic systems
called ffl
cryp tology
random source
universal algorithm
encoding c
last occurrence
game equilibria
decoder maintain
pad provides
private random
willems algorithm
cover message
adversary eve
upon observing
alphabet x
universal stegosystem
external information
secret shared
y 0
achieves asymptotically
alice sends
security definition
bob share
universal data compression
alice and bob
type ii error
alice is active
type i error
average repetition time
information theoretic model
one time pad
time deltat y
d pc kp
secure against passive
repetition time deltat
model for steganography
data compression algorithms
containing hidden information
secret key k
relative entropy d
shared by alice
statistical decision theory
q was generated
using a secret
distributions are equal
model the covertext
private random source
bob can decode
time is encoded
y is replaced
covertext and stegotext
error for accepting
lempel ziv algorithms
decides that alice
entropy or discrimination
unconditionally secure stegosystems
probability is denoted
uniformly random bits
compression a universal
sent by alice
kp s thus
data compression algorithm
practice of information
makes a type
quantify the security
approach to steganography
security of steganographic
ii error probabilities
neyman pearson theorem
observing a message
y deltat y
c or stegotext
entropy between two
true then q
d ff fi
d pq0 kpq1
sent from alice
cover message c
random source r
advances in cryp
bit key k
steganalysis and game
c and stegotext
average repetition times
detect a hidden
pc c log
called ffl secure
encoder and decoder
time pad provides
sending covertext c
average error probabilities
bit message e
advances in cryptology
observing the message
information hiding terminology
modeling the security
cryp tology eurocrypt

corpus/krapavin2000-test/624907.txt
zeroin
decisions
maintenance
specialization
delocalized
reuse
interleaving
encapsulation
program
documentation
programmer
henshaw
software
xm
statements
buss
decision
basili
grade
fb
records
erich
confront
printout
zannier
rugaber
interdependencies
abs
sigsoft
fc
facilitated
parameterize
examination
spencer
carmen
mnemonic
abstraction
engineering
specifications
reverse
designer
fa
pieces
maurer
mills
flow
stack
understand
architectural
serve
documenting
pushdown
toronto
loop
centre
interrelated
plans
reflects
ontario
rationale
comprehension
generalization
languages
decomposed
diagnostic
fragments
thought
segments
notes
collaborative
reconstruct
programmers
understanding
lines
save
intent
interpolation
ada
logarithms
abstractions
constructs
activities
manipulated
library
effort
recompute
likewise
prolog
students
ip
developers
developer
hiding
altered
cesar
kamalakar
interviews
soloway
accidently
ornburn
kenny
blackburn
fpd
unwary
hodfa
leblanc
jahnke
prado
webster
balzer
troster
homogenizing
shull
renovationan
knowledgable
marovac
lanubile
verhoef
klint
feather
nebulous
tilley
concerted
gallimore
intrude
karlapalem
hausi
sampaio
chiasson
dak
storey
alternatives
desire
year
express
compensate
frank
invalid
adjustment
fortran
debugging
functionality
computations
responsible
decomposing
structuring
mountains
undocumented
herrera
intertwine
couched
engenders
lengthening
julio
leite
recon
analyzable
cataloging
filippo
biggerstaff
reintroduced
variously
forrest
interleaved
code
stages
easier
canada
design decisions
design information
reverse engineering
design decision
software engineering
fa fb
software maintenance
control flow
delocalized plans
program indicates
erich buss
lines 048
john henshaw
programming languages
library function
programming language
programmer must
sigsoft software
notes v
engineering notes
program development
advanced studies
acm sigsoft
collaborative research
software reuse
line 068
pushdown stack
transformation approaches
maintenance programmer
lines 031
representation must
length array
design recovery
one construct
design ideas
test made
carmen zannier
write statements
restricted one
spencer rugaber
invalid records
frank maurer
conditional adjustment
semantic problems
interrelated decisions
buss john
designing documentation
reuse activities
debugging printout
numeric grade
toronto ontario
assignment statements
flow analysis
variables fa
version s2
program understanding
computing logarithms
ontario canada
next state
target machine
computations may
programming constructs
languages provide
information hiding
variable name
program variables
often useful
early stages
program specification
limited set
effort required
several approaches
maintenance and reuse
representation for design
fb and fc
generalization and specialization
easier to understand
software engineering notes
engineering notes v
sigsoft software engineering
acm sigsoft software
studies on collaborative
centre for advanced
toronto ontario canada
compensate for delocalized
documentation to compensate
encapsulation and interleaving
save the result
trying to understand
specifications are often
survey and classification
decision to use
fixed length array
gets its value
function and relation
design information must
buss john henshaw
example of generalization
tests on lines
categories of design
composition and decomposition
understand the program
framework for program
approaches and techniques
erich buss john
variables fa fb
recovery for maintenance
basili and mills
data and procedure
lines 031 037
program transformation approaches
go to 70
harder to understand
made on line
makes the resulting
counter is used
variables a b
program is shown
responsible for computing
side of line
decomposed into two
number of records
p and q
software engineering p
software engineering v

corpus/krapavin2000-test/627698.txt
hypernode
hypernodes
hd
hnql
digraph
computable
database
hypertext
arc
hfds
passenger
compound
label
digraphs
fds
ao
labels
hag
passengers
isomorphism
null
relational
updates
exe
hfd
update
operators
defining
genericity
fig
strings
axiom
attributes
graphlog
arcs
attribute
integrity
isomorphic
query
att
databases
sound
airline
levene
referential
primitive
hags
airlines
lvalue
deterministic
declarative
member
id
determinism
dependencies
hypersets
cond
turing
returned
text
bridge
title
flies
returns
statement
ex
se
anchor
herein
rvalue
ldm
pfds
incident
atomic
prim
modelling
hyper
london
encapsulated
loop
adj
dbmss
formalism
expressive
nested
te
firstly
semantics
cater
flying
utilise
seat
comprising
untyped
encode
ea
walks
entities
querying
elimination
inferences
flight
facilities
browsing
object
enhanced
inference
identifiers
expressiveness
destination
generic
uppercase
prog
gap
ise
formalising
browsed
ucl
formalisms
formalise
letter
entity
reservation
looping
functional
ba
av
language
copies
referenced
poulovassilis
alexandra
node
college
det
termed
schemas
domains
bases
loizou
journals
adjacent
locally
textual
asserts
readers
copy
hypernode model
based data
computable updates
data models
defining label
graph based
e hd
deterministic operators
computable update
hypernode database
compound statement
database hd
set based
ao computable
relational model
primitive nodes
non deterministic
data model
hnql program
label g
update language
strings beginning
defining labels
two hypernodes
axiom system
whose defining
hypertext database
locally isomorphic
generic computable
copy elimination
returned returns
att hd
otherwise null
n e
atomic values
system comprising
declarative querying
arc dependent
labels hd
turing computable
passenger hypernodes
computable mapping
hypernode databases
hypernode whose
current state
data modelling
section ii
non determinism
nested relational
node set
expressive power
arbitrary member
database satisfying
enhanced database
genericity requirement
condition h1
hypernode defined
hd returns
prim hd
value null
name dependent
order computable
object identifiers
arc set
g log
side effect
object identity
returns true
arbitrary order
database language
single underlying
ex f
condition h2
basic set
functional dependencies
underlying data
complex objects
oriented data
universal relation
query language
g 1
object oriented
based data models
graph based data
non deterministic operators
set based data
choice of p
f a b
based data model
returns an arbitrary
query and update
hd and v
ao computable updates
based and set
null is returned
whose defining label
shown in fig
operators of hnql
hypernodes in hd
gap between graph
state of hd
power of hnql
true if e
hypernode with defining
ao computable update
underlying data structure
generic computable updates
axiom system comprising
hypernode whose defining
turing computable mapping
bridge the gap
false is returned
set of attributes
easily be verified
hag of g
single underlying data
simulated in hnql
hnql s non
databases to databases
class of hypernode
hypernode database hd
system for hfds
returned returns true
arbitrary order computable
used when computing
query or update
object oriented data
statement is executed
defined by g
n i e
section ii c
set of operators
proof see appendix
sets of attributes
follows that f
hd i e
simple airline reservation
semantics of restriction
well founded sets
denote pairwise disjoint
strings to strings
general an open
hnql with respect
arc dependent null
hd the set
new data models
denoted by strings
good g log
hnql program shown
g 1 maps

corpus/krapavin2000-test/627209.txt
dear
lru
oo
seq
cscope
sublists
sublist
replacement
oeo
freebsd
cpp
detection
block
referenced
buffer
scm
glimpse
os
backward
blocks
cache
oof
reference
loop
gnuplot
period
looping
prob
deardear
gli
disk
caching
oos
hei
file
temporally
fd
response
lfu
lrulru
undetect
policy
pattern
forward
attribute
link
policies
acfc
oeoe
distance
frequency
bd
mru
hints
sort
mo
percent
files
clustered
sequential
virtual
optopt
qpqp
twohundredthoustup
snu
upup
acfcacfc
hmbi
hmbiso
qppqpp
wc
controlled
probabilistic
detects
postgres
cs
kr
executions
schemes
victim
hs
prefetching
periods
seoul
avg
qrppp
ssrnet
fivehundredup
vfs
qpppp
qtppp
bwrite
getnewbuf
ioo
hundredthoustup
twothoustup
unix
patterns
utility
qv
management
scheme
accessed
monitoring
text
cf
traces
bread
allocation
kernel
preprocessor
comparably
gnu
ac
invoked
deduced
bp
distances
logical
adaptive
references
lists
cp
media
manager
korea
fr
seconds
database
early
plotting
driven
gap
attributes
detect
compiler
detected
request
measurements
interactive
header
informed
incurs
qvpqvp
multithread
hongik
postgressql
dandelion
choijm
wpwp
qppppqpppp
acms
qrpppqrppp
qtpqtp
qtpppqtppp
vnode
dear scheme
reference pattern
detection period
backward distance
o oo
buffer cache
loop loop
forward distance
block attribute
response time
block reference
application controlled
controlled file
fd sublist
file caching
reference patterns
replacement policy
oeo oof
prob prob
detection results
oof o
dear dear
probabilistic reference
logical block
seq loop
multiple application
oo r
virtual time
replacement policies
sequential reference
average forward
temporally clustered
number virtual
lru dear
blocks referenced
block replacement
oeo oo
distinct blocks
lru lru
lru scheme
different replacement
lru seq
seq 3
detection result
dear lru
single application
block number
looping reference
mo oo
caching 8
sublist bd
attribute types
oo hei
appropriate replacement
b cf
seq seq
oos b
level hints
application case
application executions
buffer space
ordered lists
overall response
freebsd 2
result seq
proposed dear
oo oeo
backward backward
lrulru deardear
forward distances
applications show
cs sort
sublist sublist
detection periods
detected reference
link application
loop 8
time seconds
cache sizes
multiple applications
early detection
file system
ac kr
frequency block
adaptive replacement
forward average
scheme reduces
hs f
avg fd
cscope sort
text files
oo hs
distance distance
smaller forward
sort link
r o
attribute values
different applications
loop 5
monitoring process
new buffer
cache size
based adaptive
reference behavior
application performance
scheme performs
lru replacement
buffer allocation
user level
detection based
disk blocks
block attributes
snu ac
seq scheme
called dear
distance therefore
lfu replacement
cf hmbiso
scheme detection
loop 6
sublist fr
various buffer
hmbi mo
loop 16
dear detection
looping temporally
gli link
detection rule
victim block
disk i os
loop loop loop
number of sublists
controlled file caching
application controlled file
number of disk
scheme in freebsd
oeo oof o
oof o oo
probabilistic reference pattern
number virtual time
lru lru dear
block number virtual
distance and frequency
logical block number
lru dear dear
average of 12
dear lru lru
dear dear lru
block attribute values
seq 3 loop
prob prob prob
sequential reference pattern
seq loop loop
mo oo r
file caching 8
r o oo
oos b cf
r to oo
response time seconds
different replacement policies
block attribute types
o oo hei
oo r o
looping reference pattern
overall response time
fd sublist bd
freebsd 2 2
user level hints
detection result seq
oo a oeo
seq seq loop
oo oeo oo
oeo oo oeo
block reference patterns
backward backward backward
result seq seq
appropriate replacement policy
detected reference pattern
multiple application case
oo hs f
single application executions
average of 8
avg fd sublist
place the block
frequency block attribute
forward average forward
smaller forward distance
block reference pattern
proposed dear scheme
dear scheme performs
average of 23
loop 8 seq
therefore a reference
detection based adaptive
r t x
case of single
number of distinct
oo hei lrulru
called dear detection
loop detection result
policies to different
o oo r
current detection period
hmbiso oos b
lrulru deardear acfcacfc
hei lrulru deardear
m i gamma1
clustered reference pattern
forward distance therefore
patterns of applications
buffer cache sizes
hmbi mo oo
update the block
scheme called dear
proposed scheme reduces

corpus/krapavin2000-test/1008425.txt
job
notification
jobs
greedy
notify
competitive
oe
competitiveness
deadline
charge
goldman
randomized
scheduled
delta
lengths
schedule
scheduler
immediate
twolengths
earliest
deadlines
online
deltae
request
paid
begins
goldwasser
idle
gain
virtually
patience
admission
resource
pays
preemptive
nextidle
customer
classify
witnessed
payment
accepted
scheduling
charging
loosest
4dlog
subtree
queue
tomkins
lipton
arrives
latest
lef
slack
schedules
opt
rejects
blocking
completed
arrived
rejected
blocks
deltato
lateststart
undertake
strictest
deltais
jqj
coin
requests
completing
rooted
dlog
atm
blocked
flip
paging
reject
oblivious
strictly
ffl
executions
fate
release
randomization
behaviors
rule
deterministic
started
randomly
placement
fj
feasibly
princeton
awerbuch
feasibility
adversary
priori
advanced
receives
arbitrarily
claim
randomness
instances
violation
firm
preemption
assures
schedulers
interval
groups
rejecting
contradicts
feasible
owner
evidence
assignment
matching
expectation
pre
inductive
alternate
omega
fields
running
remained
company
video
select
amortized
gaps
loyola
notifica
idles
diagrammed
deltabased
overpayment
deltafrom
processarival
moot
ifor
payout
lessor
entrust
dry
gammae
parwatikar
ros
noti
block
yet
trivially
runs
lemma
maximize
red
meeting
received
units
definitively
fjg
reexamining
tardiness
cjp
unappealing
snoopy
dichromatic
quests
hindrance
outright
consideration
receive
completion
examining
tight
specifically
setting
unfortunately
termed
rely
bounds
suri
leiserson
cormen
contradic
inductively
gains
infeasible
job j
immediate notification
greedy notify
large job
randomized algorithm
small job
job lengths
job l
competitive randomized
goldman et
l f
provides immediate
select technique
virtually scheduled
notification model
small jobs
assignment rule
q delta
randomly select
base algorithm
call control
admission control
begins job
greedy twolengths
distinct lengths
job request
notify algorithm
accepted jobs
large jobs
arbitrary job
begins running
equal length
algorithm greedy
providing immediate
online algorithm
competitive algorithm
earliest deadline
non preemptive
four instances
twolengths modified
ffl behavior
blocks l
charging scheme
oe starts
oe denote
previously accepted
without notification
charge paid
advanced notification
gain opt
ffl instance
notification 10
pre blocks
optimal schedule
job requests
provide immediate
jobs j
two distinct
arbitrary lengths
delta 3
j oe
feasible schedule
rule 6
j 3
deterministic algorithm
lower bound
set q
case l
e charge
jobs stored
earliest violation
three jobs
starts j
notification ffl
notification models
oe begins
deltae competitive
explicitly studies
f blocks
disjoint partition
notification may
technique results
notify begins
charge j
length jobs
4dlog 2
greedy type
k begins
available jobs
j i k
large job l
competitive randomized algorithm
time t k
classify and randomly
goldman et al
provides immediate notification
algorithm which provides
randomly select technique
empty at time
jobs have one
j at time
begins job j
two distinct lengths
l 2 oe
greedy notify algorithm
notification is required
arbitrary job lengths
job with earliest
job l 2
providing immediate notification
one of two
bound of 2
previously accepted jobs
amount of charge
job s 2
consists of j
idle at time
running a job
lengths are equal
greedy twolengths modified
model for notification
jobs have arbitrary
provide immediate notification
jobs have equal
l f blocks
immediate notification may
ffl at time
let oe denote
notification while matching
greedy type algorithm
greedy notify begins
notify begins running
lef t x
lengths are allowed
prior to time
evidence that providing
units of charge
lipton and tomkins
4dlog 2 deltae
completed in oe
value of latest
l will receive
j 2 oe
given by goldman
algorithm greedy twolengths
without any notification
claim that l
algorithms which provide
oe begins job
prove the existence
able to give
delta is empty
online interval scheduling

corpus/krapavin2000-test/629046.txt
ped
dependences
dependence
loop
parascope
interprocedural
pane
transformations
pfc
editor
fortran
ptool
parallelization
parallelism
loops
editing
enddo
interactive
private
button
edits
synchronization
mimdizer
buttons
interchange
array
users
displayed
edit
sink
sigmacs
ptran
inapplicable
transformation
kennedy
assertions
program
ir
skewing
display
dataflow
unsafe
analyzer
faust
vectorizing
scalar
pat
text
symbolic
nest
automatic
race
advice
statements
parallelized
superb
sequential
references
supercomputing
compiler
diagnostic
iteration
tool
vectorization
kathryn
ffis
subscripted
safe
anti
inhibit
programs
ken
conservative
flow
incremental
carried
chau
ffl
statement
tools
supercomputers
scientific
mckinley
wavefront
iterations
enabled
browser
codes
pcf
miscellaneous
unrolling
machines
displays
parallelizing
shared
programmers
reordering
warren
deletion
programming
facility
selects
havlak
postdominator
guidebook
panes
underlined
rice
mouse
anomaly
sequent
optimizing
debugging
preserved
structured
tseng
mechanically
opportunity
dialog
classification
preserve
propagation
imprecise
post
breaking
transforma
interlock
vectorizer
deleted
expert
safely
assist
expose
experiences
source
multiprocessing
hazards
alamos
delete
hide
wen
query
splitting
concert
interchanges
supercompilers
assignment
enhancing
supports
fly
inhibits
steering
dominance
ssa
mature
option
unstructured
assistance
hybrid
override
programmable
directives
utilizes
push
advanced
replacement
tiling
inner
guide
nested
compilers
precision
fusing
notices
headers
arrays
subscript
overlooked
abilities
static
event
driver
overcomes
adjusts
spurious
maintained
environment
discovers
effects
project
enclosing
classifies
elsewhere
permits
testing
errors
sigplan
dependence analysis
dependence graph
parallel programming
parascope editor
interprocedural analysis
programming environment
dependence information
ffl loop
loop carried
dependence pane
text pane
program transformations
ir n
parallel loop
event synchronization
control flow
carried dependences
dependence analyzer
dependence testing
loop interchange
statement dependence
dependence display
enddo enddo
interactive parallel
current dependence
data dependence
constant propagation
iteration space
array references
loop level
reordering transformations
structured transformations
variable classification
control dependence
data dependences
side effects
programming tool
assignment statement
loop may
private variables
parallel fortran
n programming
current loop
ken kennedy
user selects
loop nest
independent statements
loop skewing
level parallelism
subscripted variables
true dependence
program changes
procedure calls
step size
symbolic analysis
experiences using
loop independent
dataflow analysis
program analysis
conservative dependences
pcf fortran
assist users
source reference
mechanically possible
sink variable
ffl defined
dependence list
imprecise dependence
wavefront method
scalar replacement
useful parallelism
scalar dataflow
miscellaneous transformations
sink reference
parallel programs
fortran programs
memory machines
optimizing transformations
transformations dependence
false dependences
loop distribution
interactive program
sequential loop
interprocedural side
incremental dependence
dependence type
transformation algorithms
expert advice
parallel form
ffl statement
distributed memory
nested loops
section analysis
race conditions
regular section
dependence occurs
automatic tools
interactive parallelization
anomaly detection
interprocedural constant
scientific programs
chau wen
wen tseng
precise analysis
parallel machines
run in parallel
parallel programming environment
loop carried dependences
statement dependence graph
parallel programming tool
interactive parallel programming
loop level parallelism
control and data
ir n programming
n programming environment
analysis and optimization
scalar dataflow analysis
imprecise dependence analysis
dependence is preserved
programs for parallel
provided by ped
transformations are enabled
enddo enddo enddo
text and structure
interactive program transformations
dependence s 1
loop and used
incremental dependence analysis
kathryn s mckinley
distributed memory machines
analysis and transformation
running in parallel
regular section analysis
chau wen tseng
static single assignment
data dependence analysis
practical dependence testing
source and sink
conference on supercomputing
detecting data dependences
editor a new
analysis of dependences
improve the precision
graph the statement
ped s dependence
limitations of automatic
variables from one
sets of dependences
focuses on loop
dependence breaking transformations
use of diagnostic
evolution of parascope
compilers a test
notice in figure
analysis of low
dependence filter facility
wait event synchronization
given an opportunity
determine whether two
variable classification dialog
dependence in ptran
programming tool proceedings
information is displayed
analysis a dependence
dependences that cross
analysis for interactive
structured program transformations
skewing the wavefront
propagation with conditional
programming on sequent
new interactive parallel
classes of dependences
match the query
use in optimization
experience with interprocedural
transformations the following
last k iterations

corpus/krapavin2000-test/627837.txt
analogical
reuse
specifications
matching
doublelist
analogies
matches
dbllist
analogy
stack
specification
subproblems
spec
match
query
reusable
expr
similarity
ospl
software
modifies
old
hierarchy
commutative
matchable
cg
expressions
cbr
sort
branch
modification
retrieved
tiered
reqcoll
armp
arguments
equivalence
library
faceted
container
reasoning
reusing
phi
program
schemas
retrieval
distance
candidate
predicate
topelement
addattail
telos
caret
heuristic
connectives
fi
postconditions
lists
operators
ff
pred
push
symbols
matchability
conceptual
theta
clause
reusability
ensures
formal
dershowitz
heuristics
amenable
graphical
similarities
descriptions
cgs
attribution
od
subproblem
projects
universally
associations
postcondition
transformational
permuted
sorted
automated
gg
analogous
sorts
incorporated
minflevel
skolemized
fopl
maiden
trashed
sutcliffe
fms
lassie
conflict
quantified
component
investigations
destructor
carol
widgets
tailorable
scoring
classification
oe
destroy
synthesis
predicates
modifying
retrieving
facilitate
matched
thesaurus
unmatched
atc
cas
distances
relationships
grained
prolog
hierarchies
tail
overviews
precondition
arcs
determination
schema
subsort
pairings
rose
isa
programmer
retrieve
templates
cardinality
frames
development
facilitates
head
facet
customize
attribute
identifier
subsumption
displays
conflicts
pursued
supplied
synthesize
bijective
queue
commutativity
entity
sigma
designs
emphasized
documentation
abstractions
target
logic
effort
browsing
inherit
ancestor
classify
artifacts
return
developer
division
sought
keyword
paradigm
operator
semantic
newelement
bhansali
addathead
algorithsm
didactic
guifa
ail
domainsort
derivational
singlelist
abstractusing
xiaodong
jurisica
spanoudakis
detachattail
matching process
analogical matching
analogical matches
matching two
query specification
software reuse
software components
branch subproblems
query spec
old program
algorithm match
formal specifications
two terms
sort hierarchy
analogical match
match expr
old spec
two expressions
match term
based heuristic
matching algorithm
equivalence class
reusable software
analogical reasoning
modification process
partial matches
program modification
existing components
return match
modifies dbllist
method doublelist
case matching
order sorted
query specifications
matches two
query component
matches theta
tiered hierarchy
stack ensures
old cases
dbllist ensures
input expressions
two input
two tiered
query program
reusable components
components based
software component
candidate specifications
reuse system
component specification
analogy based
ff 7
reuse framework
dbllist element
existing component
modifies stack
existing specification
argument order
automated reasoning
matching algorithms
domain specific
process generates
input terms
commutative operators
term case
method specification
case based
two operators
similarity based
case 6
formal methods
reuse based
existing program
od end
two lists
based reasoning
reasoning systems
design schemas
top stack
ensures top
requires clause
design family
determine software
program synthesis
sorted predicate
analogical relationships
identical associations
program old
given component
equivalence based
matches phi
doublelist modifies
match oe
e matching
design library
two specifications
name identifier
candidate components
new subproblems
match else
ensures method
specification level
stack modifies
lists case
predicate connectives
implementation old
existing set
implementation query
method destroy
formally specified
square root
domain knowledge
predicate logic
conceptual distance
domain analysis
computing similarity
specification query
scoring function
sorted specifications
knowledge base
two methods
analogical matching process
set of analogical
distance between two
algorithm match term
matching two terms
based on analogy
case matching two
set of matches
set of partial
subproblems are generated
matching process generates
algorithm match expr
modifies dbllist ensures
two tiered hierarchy
algorithm for matching
reusable software components
let the distance
components to satisfy
matching two expressions
modifies stack ensures
case based reasoning
call this approach
denoted by d
two input expressions
determine software reuse
numbers of arguments
based on analogies
domain specific information
stack ensures top
method doublelist modifies
order sorted predicate
specifications is used
program old program
matches two operators
sorted predicate logic
e do od
ff 7 gg
match else return
ensures top stack
specification query spec
e ff fi
existing and query
spec and query
doublelist modifies dbllist
match term case
implementation query program
d e ff
pair of lists
similarity based techniques
stack modifies stack
used to determine
program that satisfies
order sorted specifications
software reuse based
set of candidate
satisfy the query
generates a set
based on similarity
given in figure
used to guide
order to increase
matches between old
empty lists case
projects that use
else return case
proposed an analogy
head dbllist element
determination of reusable
term g f
structure based heuristic
match input two
applying formal methods
program modification model

corpus/krapavin2000-test/1029901.txt
invariants
invariant
daikon
flex
incremental
optimizations
utilities
falsified
suppression
trace
samples
antecedent
suppressed
hierarchy
detector
program
sample
pass
detection
instantiated
bottom
exit
checked
leader
runtime
processed
suppressions
java
antecedents
missing
grammar
instantiate
falsifying
instantiating
specifications
upgrades
refactoring
leaders
public
falsification
interning
mbytes
discovering
passes
arg
suites
gigabytes
traces
equivalence
usage
top
batch
child
anomaly
parent
opportunities
unary
equality
bug
fields
instrumented
postprocessing
constants
operational
redundant
ternary
merging
suppressee
diduce
lasti
nadya
ruben
gamboa
kuzmina
multi
instantiates
file
target
odd
dynamically
pag
csail
stands
client
tool
executions
checking
aims
optimization
stateless
ples
dereference
implementations
isolation
portland
leaf
redundancy
null
incompatibilities
copying
reflexive
online
checks
object
permits
abstraction
relate
enter
enabled
likely
watch
maine
steering
automatic
learning
adaptability
modest
field
created
runs
invalidated
mentation
instrumentation
imple
contracts
verifying
evaluates
children
spin
candidate
summand
old
million
undo
experimentally
memory
diagram
positives
discards
publicly
discovers
polymorphic
lexical
preconditions
relied
exits
predicting
storing
latent
sam
library
post
extracting
inductive
bugs
entry
fewer
aggregate
inference
remote
algebraic
dynamic
quickly
analyzer
precondition
fee
localization
eliminating
printed
storage
toh
weakenings
exempted
newsets
accomplishment
mylist
populating
sofien
khemakhem
ntt
jmaiel
unsuppressed
timizations
nimmer
dupli
myvar
pressiveness
arnout
mccamant
henkel
program points
program point
multi pass
incremental algorithm
invariant detection
simple incremental
incremental algorithms
invariant detector
pass algorithm
pass bottom
variable hierarchy
target program
dynamic invariant
daikon utilities
equal variables
derived variables
constant variables
equivalence set
program size
likely invariants
space usage
equivalence sets
dynamic detection
trace file
sample dependent
flex multi
batch algorithm
trace data
program invariants
operational abstraction
utilities multi
falsifying sample
case runtime
old leader
different program
component upgrades
dependent invariants
leaf program
pass batch
hierarchy optimization
invariant must
memory mbytes
non constant
partial order
multiple program
algebraic specifications
discovering likely
exit point
dynamically discovering
anomaly detection
test suites
variables optimization
weaker invariants
candidate invariant
without optimizations
equality sets
optimization opportunities
antecedent properties
redundant properties
remote program
program sampling
extracting implicit
invariant x
object client
detector may
maximum memory
reflexive invariants
procedure exit
algorithm section
checking invariants
trace size
candidate invariants
observed values
point object
test cases
program specifications
likely program
section 8
section 10
g v
diagram shows
program executions
memory usage
two variables
simple incremental algorithm
multi pass algorithm
bottom up algorithm
multi pass bottom
bottom up top
top down algorithm
number of invariants
dynamic invariant detection
algorithms and optimizations
top down incremental
flex multi pass
bottom up incremental
detection of likely
number of program
multiple program points
utilities multi pass
sample is processed
pass batch algorithm
memory before processing
sample dependent invariants
multi pass batch
properties are checked
dynamically discovering likely
number of samples
variables for example
invariant detector may
leaf program point
example x y
points are d
top down algorithms
d the corresponding
suppression of weaker
antecedent is falsified
processing a sample
processing the full
incremental algorithm section
remote program sampling
grammar of properties
time and space
discovering likely program
likely program invariants
number of variables
support for program
created by running
run the target
automatic anomaly detection
without the optimizations
software bugs using
variables are equal
quickly detecting relevant
invariant detection dynamic
errors via machine
object oriented component
algorithm the bottom
invariant is suppressed
algorithms for invariant
relevant program invariants
processed the samples
pass and top
comparison of algorithms
non leaf program
hold other properties
test suites via
via operational abstraction
top down figure
debugging algebraic specifications
simple java classes
algorithms section 8
pass also runs
see section 10
g v v
must be instantiated
suites via operational

corpus/krapavin2000-test/631167.txt
freshness
harmonicity
atg
utilization
periods
producer
consumer
tasks
period
deadlines
offsets
sampler
pruning
deadline
timing
correlation
separation
correlated
offset
inputs
intermediate
solver
chain
foreach
task
precedence
constraints
lcm
priority
producers
scheduling
channels
consumers
constraint
preemptive
feasible
asynchronous
schedulability
restructuring
rates
tightened
jt
buffer
allowable
dinesh
ramanathan
phi
outputs
rajesh
periodic
reads
tightly
seongsoo
dasdan
gerber
assignment
window
feasibility
chains
external
engineers
succ
harmonic
replication
writer
sampling
gcd
possess
bottlenecks
schedulable
writes
read
samples
correlate
subsystems
shadow
cpu
tight
driven
derivation
saksena
ladan
polytope
requirements
channel
successors
elimination
sampled
rate
macros
possesses
gupta
slack
ingredients
esterel
avionics
minsoo
braberman
venture
fabricated
blocking
schedule
imposed
slots
ali
automation
merging
compiler
delivered
rtl
blown
ipc
linearities
synthesizing
kang
constrains
scheduler
buffers
guaranteeing
dm
circularly
confluence
ryu
codesign
solutions
tool
outputting
revisit
looser
stamps
jx
rendered
earliest
handful
mandate
dispatching
drift
delay
tighten
vastly
aggressively
temporally
eliminating
exclusively
head
impose
dong
instantiates
parent
latest
allocation
item
thumb
eliminated
reactive
child
restrictions
outgoing
burns
subgraph
simplification
perhaps
calibration
slicing
objective
imposing
buffered
constituent
replicating
jeff
constraining
bill
predecessors
hong
designs
replicate
accommodate
transformed
analogue
robotics
deriving
constrained
merged
restricting
greatest
instantiate
hopefully
coupled
denoting
nonlinear
temperature
synthesis
task graph
end constraints
intermediate constraints
separation constraints
freshness constraints
real time
constraint solver
producer consumer
correlated inputs
end requirements
timing constraints
correlation constraints
constraint set
solution space
restructuring tool
period variables
w 4
task set
time systems
external inputs
assignment algorithm
data object
output y
variable elimination
different rates
consumer pair
tightly correlated
output tasks
parent pruning
lcm child
output task
period assignment
asynchronous task
child pruning
gcd parent
constraint derivation
u min
buffer allocation
hard real
y 1
f y
dinesh ramanathan
static priority
correlated data
utilization bound
task periods
example application
execution time
search space
linear constraints
feasible set
fully periodic
consumer task
timing parameters
slots 0
harmonicity assumptions
pruning takes
harmonic chain
solution strategy
intermediate task
virtual sequence
harmonicity constraints
sampler task
harmonicity relationship
deadline variables
constraint assignment
chain merging
output separation
intermediate tasks
free variables
constraints c
constraints may
compiler tool
min u
following ingredients
maximum execution
derivation algorithm
rajesh k
k gupta
timing driven
seongsoo hong
candidate solutions
jt 2
ali dasdan
compute y
minimum rate
object d
design automation
input x
simple fact
outgoing edge
reduced set
cpu utilization
feasible schedule
tasks 4
integer solutions
small example
algorithm fails
fixed priority
set c
time tasks
time scheduling
end to end
offsets and deadlines
real time systems
constraint set c
hard real time
producer consumer pair
asynchronous task graph
lcm child pruning
gcd parent pruning
deadlines and offsets
solution to c
set of constraints
data object d
offset and deadline
set of intermediate
window of execution
y is delivered
constraint derivation algorithm
freshness and separation
harmonic chain merging
f y 1
rajesh k gupta
maximum execution time
inputs and outputs
reads and writes
non linear constraints
finding a solution
real time tasks
real time scheduling
read and write
much as possible
interval of time
x to y
atg s structure
intermediate constraint assignment
delivered at time
dasdan dinesh ramanathan
utilization based pruning
sampling of x
straightforward priority assignment
set of asynchronous
single outgoing edge
base clock rate
running at different
sampler s l
edge in figure
constraint w 4
real time designs
consider a task
correlation and allowable
original task graph
burns et al
intermediate constraints c
correlation constraints may
u min u
foreach t l
victor a braberman
tightly correlated inputs
denote this constraint
systems external inputs
real time producer
deadline and period
thus the separation
search time required
reader may use
producer consumer pairs
graph and b
y latest y
ali dasdan dinesh
output tasks 4
n dimensional polytope
task s period
priority based scheduling
freshness and correlation

corpus/krapavin2000-test/1023754.txt
mad
oar
channel
receiver
pac
rev
wireless
receivers
throughput
madpac
probing
mac
sender
transmission
grts
packet
phy
ppdu
sifs
multiuser
diversity
revenue
ofdm
packets
scheduling
rts
arf
cts
lans
goodput
transmitter
fairness
super
tra
flows
fading
gain
rate
duration
ack
rm
lan
sf
ra
octets
plcp
transmit
snr
frame
rayleigh
dcf
backlogged
adaptation
coherence
reception
temporal
dbpsk
header
rates
network
bits
mbps
robin
erence
di
erent
dialogue
reply
layer
madoar
pathloss
preamble
contention
medium
cdma
gains
reservation
dequeued
instantaneous
star
formats
mobile
dmax
favorable
transmitted
slot
psdu
payload
auto
bitmap
topology
opportunistic
radio
queried
downlink
transmitters
pl
highest
transmits
round
nav
fair
retransmission
pad
campus
subfield
overheard
fcs
orts
channels
asymptotic
feedback
queue
nels
wavelan
signal
modulation
overhead
varied
format
frames
serviced
src
selectively
feedbacks
tradeo
field
retry
ts
physical
utilization
exploiting
improvement
link
concatenation
share
query
cellular
networks
interframe
wcdma
sadeghi
navs
hdr
qualnet
miu
scheduler
exploit
improves
tc
ghz
reward
legacy
simulation
tail
service
achieves
hoc
networking
devices
ects
carrier
tentative
respond
flow
rhs
concatenated
benefits
emre
umts
opportunistically
band
senders
ective
division
peak
specifications
sensing
schemes
transmissions
short
scrambled
lucent
csma
awgn
koksal
aloha
channel probing
network throughput
data transmission
channel conditions
k set
relative gain
channel condition
madpac rev
multiuser diversity
wireless lans
ieee 802
mad pac
mad oar
rate adaptation
data rate
wireless lan
set mad
temporal fairness
coherence time
super data
super packet
revenue based
tra c
maximum relative
data ppdu
data rates
gain scheduling
arf oar
sifs sifs
based scheduling
medium access
adaptation scheme
channel coherence
rev mad
phy layer
rayleigh fading
throughput improvement
rate rm
frame control
pac k
star topology
access diversity
set round
overall network
pac rev
temporal share
data packets
data packet
c flows
oar rev
g rts
throughput mbps
transmission dialogue
oar pac
adaptation schemes
oar k
goodput per
multiple receivers
mbps arf
access point
overall throughput
base rate
di erent
current channel
control duration
ppdu frame
existing rate
control frame
di erence
round robin
wireless networks
scheduling algorithms
instantaneous channel
high data
higher data
fairness among
probing data
super frame
random topology
channel quality
highest data
receiver scheduling
expected goodput
exploiting multiuser
receiver 2
rev performs
auto rate
k receivers
using oar
d f
control packet
among multiple
sender receiver
fair scheduling
varying channel
transmission phase
wireless network
transmit data
mac layer
transmission rate
time slot
rev figure
receiver k
pac mad
temporal fair
cts control
mad scheduling
tail 6
service bits
contention window
pad bits
bits service
duration ra
grts packet
c load
n tr
snr value
long training
madpac k
expected network
th transmission
mac tail
frame formats
given channel
duration field
grts cts
mad using
payload size
k set mad
maximum relative gain
ieee 802 11
revenue based scheduling
super data ppdu
relative gain scheduling
rate adaptation scheme
channel coherence time
set mad pac
k set round
set round robin
rev mad pac
mad pac k
set mad oar
sifs sifs sifs
mad pac rev
medium access diversity
pac k set
tra c flows
throughput mbps arf
ieee 802 11a
mad oar rev
rate adaptation schemes
mad oar k
oar k set
oar rev mad
mbps arf oar
arf oar pac
overhead of channel
data ppdu frame
frame control duration
existing rate adaptation
exploiting multiuser diversity
channel probing data
phase of mad
network through put
high data rates
overall network throughput
goodput per data
madpac rev performs
data transmission phase
c d f
value of k
number of receivers
per data transmission
long training symbols
control duration ra
improves the network
bits from mac
mac tail 6
bits service bits
pad bits service
relative gain among
probing data transmission
mac and phy
highest data rate
varying channel conditions
madpac k set
oar pac mad
expected goodput per
tail 6 bits
tra c load
pac rev figure
pac mad oar
share of flows
instantaneous channel conditions
higher data rate
network throughput vs
among di erent
p d f
ad hoc networks
back to back
compares the network
legacy 802 11
sender receiver 1
receiver 1 receiver
independent rayleigh fading
multiuser diversity gain
oar mad oar
diversity in wireless
ppdu frame formats
variants of mad
wireless lan environment
w log 1
ppdu frame format
multiple data flows
multiuser diversity gains
channel condition information
mad using oar
per transmission dialogue
access diversity mad
f is set
transmit at rate
expected network throughput
among multiple data
arf oar mad
frame see figure
exploit multiuser diversity
identify and address
free space pathloss
feasible data rate
current channel condition
short term fairness
receiver 2 receiver
compared to oar
data transmission scheme
subsection 7 1
topology with variable
link goodput optimization
maintaining temporal fairness
asymptotic performance bound

corpus/krapavin2000-test/627561.txt
ldbs
ticket
ldbss
multidatabase
subtransactions
tickets
otm
transaction
serialization
subtransaction
mdbs
serializability
commit
ctm
prepared
cascadeless
concurrency
schedules
serializable
autonomy
commitment
conflicts
schedulers
gsg
itm
optimistic
participating
rigorous
rigorousness
committed
restarts
database
georgakopoulos
sheth
aborted
conflict
timeout
recoverability
abort
mdbss
validation
dbmss
management
serialized
cascadelessness
scheduler
enforcing
orders
rusinkiewicz
recoverable
aborts
indirect
transactions
enter
timestamp
site
wfg
submission
visible
strictness
schedule
heterogeneous
ticketing
commits
conservative
deadlock
altruistic
analogous
trans
submits
locks
mixed
unilaterally
expires
sql
locking
interleave
enforce
dbms
lock
global
violate
issued
strict
enters
datacycle
gte
sybase
arpinar
restarted
resolve
increments
bellcore
sagas
breitbart
recovery
vendor
implicit
timeouts
serial
cas
consistency
cycle
precedes
oe
semi
deadlocks
submitted
occ
houston
blocking
reads
databases
sites
disallow
executions
caused
entered
mechanisms
rda
channeled
sangkeun
younger
hornick
halici
hurson
logar
cadeless
action
globally
ae
execution
interfaces
violated
heterogeneity
laboratories
read
rollback
correctness
ensure
sub
certification
simulated
agent
superdatabases
multidatabases
finished
increment
updates
participate
edges
strongly
decentralized
federated
dimitrios
interbase
larson
refinements
reflect
prepare
autonomous
handshake
transac
pu
allowed
permits
eliminates
removal
controlling
difficulties
trol
nevada
successfully
preventing
reflects
writes
scheduling
environments
uncommitted
expired
permit
ts
preferred
incoming
theta
hwang
chong
op
conflicting
blocked
affecting
ensures
undirected
erations
global transactions
global serializability
commit state
serialization order
global transaction
multidatabase transactions
concurrency control
transaction management
g 1
relative serialization
g 2
multidatabase transaction
participating ldbss
serialization orders
local serialization
transaction g
take tickets
visible prepared
ldbs 2
g j
ticket state
ticket method
global restarts
local transactions
local concurrency
site graph
database systems
corresponding ldbss
ticket value
local serializability
analogous execution
transactions g
multidatabase systems
distributed database
local systems
commitment order
cascadeless otm
ticket conflicts
multi database
sub transactions
sheth enforcing
rusinkiewicz sheth
ldbss ensure
ticket operations
become prepared
ticket methods
georgakopoulos rusinkiewicz
local schedules
strongly recoverable
g c
local transaction
transaction execution
local database
serialization graph
indirect conflicts
multidatabase environment
simulated prepared
semi rigorousness
guarantees global
rigorous schedules
enforce global
ensure local
becomes prepared
ldbs 1
implicit tickets
strong recoverability
implicit ticket
oe oe
sub transaction
non serializable
management mechanism
multidatabase system
execution order
serializable schedules
local autonomy
ticket operation
ldbs autonomy
optimistic schedulers
indirect conflict
direct conflict
conservative ticket
ae ae
relative order
trans action
recently committed
g become
prepared to commit
subtransactions of g
take their tickets
take a ticket
prepared to take
subtransaction of g
relative serialization order
execution and serialization
enter their prepared
local serialization order
global transaction g
enforcing the serializability
local concurrency control
takes its ticket
subtransactions of global
serializability of multidatabase
multidatabase transaction management
enters its prepared
rusinkiewicz sheth enforcing
georgakopoulos rusinkiewicz sheth
transaction management mechanism
guarantees global serializability
aborts and restarts
tickets before g
global transactions g
enforce global serializability
distributed database systems
oe oe oe
order of global
transaction t 1
g become prepared
transactions g 1
sets a timeout
ldbss that use
submits its subtransactions
allowed to interleave
ldbss ensure local
take its tickets
commit or abort
ensure local serializability
ldbss that allow
ae ae ae
local database systems
heterogeneous distributed database
database management systems
z z z
control of ctm
implicit ticket method
conflicts between multidatabase
conflict between g
allowed to commit
orders are analogous
ticket method itm
enforcing global serializability
site graph method
management in multidatabase
serialization order theorem
reflects their relative
otm and ctm
order theorem 1
subtransactions of multidatabase

corpus/krapavin2000-test/626879.txt
displayable
suffix
conflicts
subword
prefix
scd
shadowsearch
nextsuffix
occurrences
entities
conflict
pet
de
vertex
string
getsubwords
occ
sink
ww
afi
sg
sublist
abc
letter
aff
superword
scdawg
pshadow
listconflicts
imp
entity
wm
cde
subwords
wmw
strings
vertices
edges
sigmaj
edge
positions
substring
jlabel
sublistj
noconflicts
display
iff
dm
preceded
alphabet
afl
ms
descendants
extension
spd
superstring
sgr
occurrence
gabcde
psf
scdawgs
visualization
label
sv
incident
invocations
spawned
lemma
protein
optimally
suffixes
maximal
xfflsv
lambdanumber
fthere
bioinformatics
listj
pimage
color
source
ff
jx
dna
descendant
def
truth
conflicting
directed
fabcgabcde
abcde
jde
intrasequence
economical
isn
labels
concatenation
highlighted
homology
radix
nil
suboptimal
fi
text
shadow
jv
occurence
sigma
topological
position
leaving
loop
reporting
rf
substrings
comprising
reverse
modifying
tb
lengths
acyclic
compact
highlighting
followed
overlap
patterns
interactive
compaction
recurring
computes
le
frequency
restricted
biology
molecular
subgraph
originates
dag
character
queries
sc
concatenating
lists
calls
sequences
statement
smallest
sm
sorted
disabled
incoming
inverted
colors
aflff
neng
nilg
sigmajp
abczdefydefxabc
superwords
fpshadow
entiities
affbfi
cdefcdegabchabcde
abcdbcgabcdbchbc
perword
obtaind
owsearch
aflfi
setsuffixes
tomatic
recursively
word
lemmas
transitivity
fg
pattern
traverses
pascal
fundamentals
characters
illustration
se
lines
abcx
fares
xfl
flx
de v
displayable entities
prefix suffix
suffix conflicts
suffix extension
v w
extension edge
subword conflicts
de w
prefix extension
displayable entity
w x
extension edges
w v
d 1
ww de
suffix conflict
de x
algorithm d
d 2
getsubwords v
right extension
algorithm c
shadowsearch v
x afi
start positions
x sublist
v source
conflict free
w b
vertex v
pshadow w
nextsuffix v
takes o
w p
o n
subword conflict
v subword
optimal algorithm
vertex w
re edges
de u
p wmw
p de
entities represented
x aff
procedure getsubwords
conflict occurs
vertex x
v v
end positions
entities d
smallest superword
subword displayable
size restricted
algorithm b
vertex representing
j sigmaj
line 5
x afl
string alphabet
spd w
start position
jx sublistj
conflicts using
distinct conflict
average times
alphabet 500
edges leaving
w 1
display conflicts
maximal patterns
without including
conflicting displayable
end position
label f
recursively let
re edge
prefix suffix conflicts
de v w
v w x
sg s v
pet s v
ww de v
set s v
prefix suffix conflict
prefix extension edge
respect to de
suffix extension edges
occurrences of d
occurrences of de
suffix extension edge
shadowsearch v w
conflicts between de
w x afi
number of occurrences
nextsuffix v v
w and de
pshadow w v
right or suffix
w a ww
greater than k
v in scd
number of conflicts
suffix of de
conflicts between d
computes all prefix
statement of line
occurrences of displayable
w v w
subword of de
edge from x
w p wmw
w x aff
v w v
w b w
occurrences s v
p de v
w v x
displayable entities represented
calls to shadowsearch
w p de
takes o n
v in v
displayable entities d
entities d 1
o n time
right and suffix
procedure getsubwords v
represented by descendants
suffix conflict occurs
size of size
size of string
x in pet
number of prefix
v 6 sink
w x afl
set of invocations
spd w v
abc and cde
alphabet 500 1000
prefix of fi
edges from w
sv s v
w to v
computing all conflicts
time in ms
string alphabet 500
prefix of de
two displayable entities
prefix extension edges
compute all prefix
v with respect
right extension edge
w a w

corpus/krapavin2000-test/614303.txt
vortex
vorticity
vortices
tube
corrector
skeleton
tubes
pressure
predictor
turbulent
flow
core
vortical
cross
seed
cores
shear
visualization
hairpin
grid
skeletons
isosurfaces
velocity
unsteady
tracktur
visualizing
fourier
spiral
plane
radius
perpendicular
rendering
quantities
volumetric
surface
helicity
grooves
feeders
robinson
reconstruction
graphics
elongated
radial
silver
turbulence
animation
integration
fig
3d
gradient
interpolation
moin
spanwise
streamwise
enstrophy
deborah
field
flows
volume
fluid
shaped
locate
helical
sectional
cambridge
viewer
scalar
wall
workstation
stretching
curves
curve
polygonal
reprinted
jiminez
jfm
quadrilateral
skeletal
fields
shape
interactive
circular
polygons
tracking
figs
cylinder
samples
aligned
press
faithful
reconstructed
visualize
wander
filament
intensity
mesh
connective
varying
polygon
coherent
continuation
frames
integral
finely
numerical
display
enhanced
regions
seeds
boundary
frame
compressed
velocities
magnitudes
ellipsoids
spot
sampled
shapes
cell
motion
streamlines
reduction
cray
datasets
image
gigabytes
predicted
storage
wanders
interiors
woodring
marched
feeder
tangle
cantwell
centripetal
resolved
eigenvalues
shen
region
dynamics
isosurface
head
unstructured
spherical
polar
jiang
interpolate
bytes
interior
surfaces
coordinate
rotation
inward
laminar
emanate
physicist
advecting
cylinders
locating
fold
permit
meshes
reconstruct
silicon
center
layer
hundreds
capturing
coefficients
spirals
wireframe
eduard
turk
dissipates
twists
tensor
capture
lie
discarded
identification
curvature
backwards
angle
machiraju
twist
indigo
transitional
intense
reconnection
decimation
flagged
xin
thin
thousand
planes
gradients
vortex tube
predictor corrector
cross section
vortex core
vortex tubes
vortex skeleton
cross sections
vorticity lines
vortex cores
corrector method
skeleton line
seed point
vortex skeletons
low pressure
vorticity vector
corrector scheme
data reduction
time varying
flow field
shear flow
vorticity line
vortical structures
pressure minimum
numerical simulation
unsteady flow
seed points
flow data
cambridge university
fourier series
radius function
pressure gradient
flow quantities
reverse integration
corrector phase
hairpin vortex
polygon count
corrector technique
vortex cross
new vortex
time step
turbulent flow
flow fields
university press
large vorticity
streamwise direction
integral curves
low intensity
deborah silver
average radius
channel flow
integral curve
turbulent channel
velocity gradient
skeleton point
reference vector
turbulent spot
plane l
vortex head
boundary layer
reconstructed vortex
vortex stretching
grid cell
grid point
point p
plane perpendicular
3d grid
predicted point
cross sectional
computational domain
time steps
volumetric data
scale vortices
turbulent boundary
nearly circular
faithful reconstruction
section plane
structures within
degree direction
free shear
boundary layers
finely sampled
locate vortices
direct numerical
shaped vortex
vortical flow
wall normal
jfm v
vorticity magnitude
circular cross
given vortex
skeletal representation
vortical motion
skeleton points
hairpin vortices
visualization system
vector n
vector field
normal vector
forward integration
identification schemes
domain boundary
fig 1e
original 3d
3d grids
planes perpendicular
fourier representation
quadrilateral mesh
dimensional flow
corrector algorithm
per second
predictor corrector method
predictor corrector scheme
cambridge university press
pressure and vorticity
predictor corrector technique
turbulent channel flow
within the flow
plane l k
conference on visualization
magnitude of vorticity
cross section plane
reduction and reconstruction
circular cross sections
reconstructed vortex tubes
note the spiral
permission of cambridge
shaped vortex head
along the core
tube s cross
follows the core
vector n k
isosurface of constant
three dimensional flow
vortex cross section
gigabytes of storage
visualizing time varying
whether a point
predictor corrector algorithm
l k 1
han wei shen
time varying data
tube that ends
finite cross section
corrector scheme provides
machiraju david thompson
time varying volumetric
represent the vortex
visualize vortical structures
grooves follow integral
point vorticity lines
zero cross section
new normal vector
low intensity region
vorticity vector field
predictor corrector skeleton

corpus/krapavin2000-test/1024485.txt
subtype
clp
pred
typing
typed
prolog
coquery
fages
subtyping
francois
inequalities
constructors
atom
predicate
pottier
csld
declarations
substitution
emmanuel
predicates
ssi
prescriptive
int
clause
head
denitional
tclp
infered
coercions
logic
simplication
lakshman
loat
resolvent
acyclic
satisability
pl
sicstus
wallace
parametric
frey
genericity
substitutions
query
polymorphism
herbrand
mycroft
jaar
lassez
oat
clauses
constraint
arity
typable
inference
subtypes
reddy
arities
satisable
keefe
polymorphically
suprema
nite
lattice
programs
renaming
typings
hanus
colmerauer
heuristic
checking
float
resp
dened
symbols
declared
renamed
unsatisable
smolka
beierle
checker
proposition
derivation
func
permissive
constructor
iso
infer
libraries
contravariant
posets
declaration
exibility
denition
topor
djb
smaus
decomp
poterms
inferring
atoms
acyclicity
rule
inequality
covariant
glb
ill
prop
les
rules
metaprogramming
lub
unication
rst
functor
tail
polymorphic
hill
library
occurrence
cubic
le
identication
ub
innite
maximal
valuation
poset
checked
hagl
setof
varleft
denumerable
tiuryn
pfenning
somogyi
kfoury
varright
yardeni
reduction
fd
list
meta
dierent
judgement
height
expresses
raised
subject
arithmetic
kaci
dietrich
ait
overloading
rejected
queries
inferred
bottom
errors
program
triv
predi
reductions
arguments
compile
detected
inferencing
clash
supertype
constraints
induction
append
mutually
assoc
ground
collected
consistency
decreases
greatest
preserves
derivations
resolution
ith
cates
programming
instantiation
sorted
options
type system
subtype inequalities
well typed
constraint logic
logic programs
type constructors
typing constraint
subject reduction
francois fages
emmanuel coquery
type constraints
left linear
type inference
type checking
variable typing
type declarations
prescriptive type
typing u
maximal solution
subtype relations
type list
minimum type
rule atom
declared type
example 7
simplication rules
denitional genericity
type structure
list bottom
reddy 1991
iso prolog
infered type
f loat
lakshman reddy
clp programs
logic programming
execution model
type checked
k 00
parametric polymorphism
rule head
acyclic left
dierent arities
nite types
csld resolution
o keefe
heuristic type
herbrand terms
predicate symbols
type variables
type checker
q 0
constraint domains
substitution steps
programming errors
ill typed
w r
prop 2
sicstus prolog
type systems
int pred
mycroft o
type pred
heuristic infered
ssi problem
solved form
clp x
subtype constraints
pred heuristic
lassez 1987
subtyping order
renamed apart
genericity condition
typed constraint
upper type
csld resolvent
heuristic upper
jaar lassez
clp r
pottier 2000a
function symbols
proposition 2
constraint programming
column indicates
cubic time
typed program
type schemes
list int
pred pred
type substitution
clp fd
basic types
u 00
constraint system
type error
ssi associated
func rule
constructors k
semi unication
contravariant type
constraint logic programs
typing constraint logic
fages and emmanuel
variable typing u
system of inequalities
prescriptive type system
lakshman reddy 1991
declarations for function
function and predicate
types for predicates
constructors of dierent
atom and head
acyclic left linear
program is well
heuristic upper type
coercions between constraint
relations between type
jaar lassez 1987
denitional genericity condition
infered type list
type list bottom
heuristic infered type
libraries of sicstus
checking and type
minimum type list
inference for predicates
pred heuristic infered
mycroft o keefe
system of subtype
checking the satisability
type of variables
k k 0
resolvent of q
posets with suprema
typed with type
type inference algorithms
rejected at compile
abstract execution model
subject reduction w
k 0 g
polymorphic type system
inequalities between parameters
constraints in q
q 0 query
error is raised
bottom pred heuristic
exists a substitution
solving of subtype
type checking algorithm
contravariant type constructors
type is computed
clauses and queries
hill topor 1992
proof by structural
systems of subtype
well typed clp
typed constraint system
reduction w r
prescriptive type systems
satisability of subtype
list f loat
inequalities is satisable

corpus/krapavin2000-test/607707.txt
watanabe
singularities
learning
eq
asymptotic
neural
pole
bayesian
amari
blowing
identifiable
perceptron
stochastic
kullback
expansion
dw
layered
parametric
statistical
algebraic
samples
analytic
density
poles
shun
murata
geometrical
generalization
units
ciently
likelihood
exp
estimation
training
regression
neighborhood
clarify
ichi
priori
dxdy
opper
sumio
su
artificial
hidden
layer
resolution
hierarchical
ups
aic
hironaka
haussler
machines
fisher
ect
ozeki
mixtures
curves
nh
inequality
meromorphic
zeta
unrealizable
fukumizu
atiyah
solla
tomoko
geometry
regular
nk
compact
singular
jw
inequalities
bias
trained
foregoing
entropic
sato
tishby
bic
largest
contained
mellin
conic
minimizes
probability
networks
variance
posteriori
gaussian
akaike
perceptrons
mackay
error
firstly
asymptotics
universal
satisfies
clarified
boltzmann
mathematically
definite
analytically
proven
levin
schwarz
algorithmically
mathematical
continued
realizable
extensively
manifolds
wavelets
rational
statistics
secondly
radial
curve
jensen
log
jacobian
degenerate
miki
dacunha
cousseau
hiroyuki
nakahara
combing
keisuke
castelle
neuromanifolds
hyperfunctions
shinomoto
abic
aoyagi
prehomogeneous
gassiat
identifiablity
reys
hyperparatemeter
prespective
kashiwara
holomorphic
paramaters
hyeyoung
perceptorn
merhav
rissanen
yamazaki
haikun
estimator
mixture
conditional
calculation
rank
cramer
ork
donsker
hagiwara
hartigan
florent
identifiability
machine
adopt
fujita
homogenous
shintani
ror
pth
subsection
speaking
interpolation
inference
empirical
chui
yamanishi
asymptotic expansion
generalization error
stochastic complexity
hierarchical learning
learning machines
learning machine
bayesian estimation
regular statistical
h w
f n
j z
three layer
true distribution
probability density
g n
true probability
parameter space
y x
hidden units
x w
neural networks
largest pole
p y
w j
training samples
parameter w
artificial neural
layer perceptron
watanabe 2001a
algebraic geometrical
w dw
learning curves
analytic function
parametric case
kullback information
non identifiable
density function
su ciently
priori distribution
regression function
algebraic geometry
true regression
watanabe 1999b
error g
q x
w 0
w w
neural computation
ciently large
q y
statistical model
g u
blowing ups
extensively large
shun ichi
independently taken
ichi amari
priori probability
statistical models
parametric model
eq 30
learning theory
probability distribution
neural network
w z
exp 2
samples independently
information matrix
analytically continued
kullback distance
sumio watanabe
exp nh
algebraic variety
asymptotic property
x dxdy
complexity f
statistical estimation
maximum likelihood
z w
fisher information
units k
eq 18
geometrical structure
asymptotic theory
n w
singular points
likelihood method
layered neural
resolution theorem
using samples
n satisfies
natural number
nk 2
parametric models
learning curve
x q
g x
e ect
approximation error
function j
input units
dimensional vectors
trained using
likelihood function
output units
conditional probability
learning model
eq 19
function approximation
ciently small
log p
log n
computation v
previous paper
eq 35
samples watanabe
true parameters
far smaller
levin tishby
p y x
y x w
three layer perceptron
hierarchical learning machines
artificial neural networks
probability density function
hierarchical learning machine
regular statistical models
regular statistical model
h w z
true regression function
watanabe 1999b watanabe
resolution of singularities
true probability distribution
q y x
generalization error g
error g n
parameter w j
su ciently large
number of training
function of w
priori probability density
z w dw
parameter that minimizes
support of w
true probability density
y x q
shun ichi amari
conditional probability density
w z w
log p y
algebraic geometrical structure
poles of j
samples independently taken
non parametric case
complexity f n
end of proof
respectively the largest
function j z
function approximation error
q x dxdy
perceptron with k
trained using samples
w w dw
using samples independently
stochastic complexity f
number of parameters
neural computation v
v w j
layered neural networks
maximum likelihood method
natural number n
x q x
ciently large n
w w 0
n is equal
su ciently small
given by eq
distribution is contained
arbitrary natural number

corpus/krapavin2000-test/608645.txt
qpa
umdl
auction
agents
sellers
strategic
buyers
agent
seller
market
ss
offer
sss
profit
sell
clearing
profits
buyer
bbss
bids
price
multiagent
buy
mc
strategy
ssss
cp
bbs
bss
zi
bs
bid
bbbss
standing
fm
bbbs
bbbbss
bbsss
prices
auctions
durfee
markup
bsss
bbbbs
zlotkin
rosenschein
vickery
matches
offers
social
inefficiency
goods
incentive
surplus
bbbbbsss
bbbbsss
bbbbbss
bbbbbs
bbbsss
efficiency
session
society
smart
designers
services
arrival
dynamics
societies
wellman
bidding
sandholm
emergent
economy
quote
self
decreases
qpas
bbbbbssss
bbbssss
bbssss
bssss
gode
sunder
outsmart
evolve
collective
laws
negotiation
submits
arrives
tradeoffs
payoffs
birmingham
sharply
match
reasoning
submit
double
library
sms
honestly
economies
thinking
seeking
allocation
probabilities
beneficial
designing
architects
competing
valuations
mechanism
matched
population
inefficient
michigan
contracts
digital
settings
reservation
interval
populations
game
lowest
utility
trading
gets
highest
service
advantages
success
transaction
simpler
auctionbot
ubiquitousprovides
uia
ossowski
bbbbssss
brafman
reassuring
extrememaking
bbbbsssss
chaudhury
barbour
backfire
mullen
buttner
bbbsssss
seize
hasn
misrepresenting
sssss
markups
uias
bbsssss
buye
tennenholtz
vain
ionsess
rust
misrepresentation
kicked
santanu
bbbbbsssss
traders
exerting
cera
sascha
rackham
failurefailure
bsssss
hiranmay
incorrect
seconds
participants
preventing
participating
rs
unrealistic
encounter
conventions
strategies
transition
expect
p strategy
p qpa
strategy agents
cp qpa
umdl auction
strategic agents
fm qpa
strategy agent
self interested
mc model
clearing price
market efficiency
umdl system
offer price
zi qpa
interested agents
strategic reasoning
total profit
multiagent system
agents use
umdl service
auction process
mc states
offer interval
sell offer
service market
market society
strategy seller
digital library
mechanism design
buy offer
multiple p
collective behavior
buy offers
standing offers
auction mechanism
simpler strategy
offer rate
agents increases
social laws
standing offer
fixed markup
sell offers
offer becomes
bs ssss
ss bbbbss
emergent properties
simpler strategies
strategic thinking
offer arrives
best offer
agent population
profit seeking
market based
double auction
sell prices
smart agents
bbss state
interested agent
clearing interval
automated negotiation
higher profit
per match
profit per
allocation efficiency
agent societies
cost plus
agent designers
transition probabilities
overall system
strategy called
individual agents
simple strategy
c c
game theory
multiagent systems
surplus extraction
park durfee
incentive engineering
sss bss
bss sss
bbss ss
ss bbss
seeking behavior
zero intelligence
buyer submits
highest buyer
bs sss
smart decreases
price quote
reservation prices
double auctions
sunder 1993
offer rates
query planning
eventually decreases
market inefficiency
designing multiagent
lowest seller
umdl agent
p strategy agents
p strategy agent
buyers and sellers
self interested agents
p strategy seller
number of buyers
umdl service market
service market society
use the p
qpa and p
multiple p strategy
goods and services
c c c
seller who bids
success and failure
bid their true
bids its cost
best offer price
sharply as one
number of p
buy and sell
decrease as sharply
self interested agent
profit per match
number of matches
probability of 0
one might expect
laws for artificial
group of designers
adaptive p strategy
agents use simpler
smart agents increases
auction for qpa
markup a seller
terms of market
ssss bs sss
based digital library
expect the umdl
exhibits certain properties
overall system behavior
bs ssss bs
artificial agent societies
gode sunder 1993
p strategy works
enough other agents
arrival of equally
task oriented domains
submits its bid
equally smart agents
digital library umdl
auction the auction
durfee et al
michigan digital library
since the p
mc model represents
seller s offer
market and allocation
maximize their profits
strategy an agent
sell offer becomes
becomes a standing
market based digital
submit their bids
capability of complex
types of sellers
numbers of p
fm qpa zi
profit seeking behavior
auction mechanism may
payoffs of success

corpus/krapavin2000-test/629437.txt
load
balancing
transfer
particles
diffusion
percent
deltal
tasks
pic
particle
dsmc
locality
eff
balance
gde
computers
ogde
imbalance
diffusive
ffit
reactor
hb
diff
grid
transferred
neighbors
timestep
agde
paragon
plasma
routines
task
remapping
gec
lavg
errmax
thruster
cells
processors
transfers
workload
intel
vectors
concurrent
phases
balanced
efficiency
movement
hawk
scplib
transferring
pde
exchange
solver
field
cray
partition
repartitioning
dhb
partitions
metric
cell
err
library
mapped
const
underloaded
torus
mesh
metrics
disturbance
ode
facilities
comprised
calculate
calculated
phase
knapsack
loads
termination
runtime
move
kwok
scalable
dist
ffl
lowest
ideal
timestepping
changxun
rarefied
propulsion
ffil
powerchallenge
backflow
macroparticles
addendum
exchanges
quantities
heat
initiated
idle
ion
simulations
push
communication
workstations
fromone
bisection
options
meshes
mapping
silicon
scatter
exceeds
costly
synchronization
utilization
randal
million
neighboring
send
poor
selection
simulation
max
diffuse
tori
receive
overloaded
fairly
prediction
lap
physics
min
strategies
undertaken
unstructured
conducted
spectral
gradient
electromagnetic
zhong
balances
laboratory
irregular
accuracy
hl
cheung
color
adjusting
grids
heterogeneous
gather
institute
center
timing
unnecessary
potentials
efficacy
exhausted
distance
moved
iterative
outgoing
rigorous
continuum
cur
burns
asynchronous
converged
norm
closest
dimensional
exposing
extremal
communicating
location
scalar
preserve
thread
multicomputers
parametric
neighbor
remedy
threads
bars
adaptive
granularity
speedup
scalability
destinations
dramatically
converges
expect
evolves
dynamic
rel
load balancing
transfer vectors
transfer vector
load balance
dynamic load
work transfer
task selection
eff min
two computers
vector algorithms
load imbalance
total load
hb method
diffusion algorithm
balancing framework
pic code
balancing algorithm
communication locality
one would
neighbors j
intel paragon
lowest cost
timestep size
task movement
computer must
diff 1
phase two
field solve
balancing steps
scalable concurrent
total work
average distance
one computer
transfer cost
balancing would
ogde diff
ffl max
imbalance exists
particle push
field solver
processors ogde
global norm
load prediction
cost metric
grid cells
cray t3d
overall efficiency
phase one
load evaluation
balancing problem
achieve load
algorithms transferred
programming library
task mapping
would expect
concurrent programming
c l
load distribution
subset sum
hb algorithm
task transfer
processors percent
dimensional exchange
static mapping
ion thruster
balancing system
computer 2
gec reactor
communication list
global load
new load
particles contained
hierarchical balancing
every computer
gradient model
tasks transferred
gde algorithm
sum problem
dsmc code
diffusion algorithms
gde method
lavg eff
various transfer
j 2
percent utilization
varying numbers
diff 2
ideal location
based load
communicating tasks
computer 1
termination condition
phase 1
computing v
prediction model
gather scatter
two large
balancing strategies
local load
l max
dynamic load balancing
transfer vector algorithms
load balancing framework
j 2 n
load balancing algorithm
neighbors j 2
total work transfer
amount of work
computer to another
load balancing steps
cost of load
parallel and distributed
scalable concurrent programming
ogde diff 1
diff 1 diff
load imbalance exists
work transfer vectors
task s state
load balancing would
processors ogde diff
number of processors
one would expect
load balancing problem
achieve load balance
number of tasks
set of tasks
distributed computing v
journal of parallel
percent more work
scatter to obtain
load prediction model
concurrent programming library
authors of 24
based load balancing
tasks to computers
deltal i j
c l n
determine which tasks
mapping of tasks
satisfy its transfer
n i receive
computer 1 computer
lavg eff min
subset sum problem
computer 2 phase
load balancing system
processors percent utilization
various transfer vector
set of computers
two large scale
number of load
number of particles
applied to two
phase 2 phase
load balancing strategies
d dimensional mesh
computing v 64
numbers of processors
maintain an efficiency
case a task
computation this fact
balance the computation
cannot be divided
termination condition based
purpose load balancing
reduced the transfer

corpus/krapavin2000-test/626779.txt
fault
dependability
injection
coverage
nac
ftams
faults
amp
injected
tolerance
tolerant
ftam
readouts
lsc
mtff
assertion
activation
validation
occurrence
esc
asymptotic
arlat
failure
dependable
predicate
impact
transition
faulty
activated
estimator
estimation
characterizing
featuring
experimental
analytical
architecture
delta
ftd
dormancy
testbed
host
duplex
tolerated
powell
mechanisms
esprit
estimators
self
nominal
markov
measures
interactions
depicts
target
jean
defective
designates
aimed
cumulative
forecasting
fantechi
wonnacott
crouzet
bull
laas
ferranti
martins
mtffnode
coverages
procured
eliane
nacs
milanova
fxa
coincident
extraction
testing
confidence
experiment
detection
ryder
avionic
ftmp
bondavalli
deficiency
axiomatic
predicates
reliability
rate
proportion
silent
yves
confinement
hardware
voting
percentages
experiments
instant
checking
carried
configuration
gil
censored
unobserved
pessimistic
removal
extractions
ana
rates
tolerate
limits
absorbing
configurations
prototype
optimistic
estimates
intermittent
repairing
latency
principal
pins
replicas
catastrophic
modeling
helped
refine
noting
estimated
exemplified
computers
transitions
characterizes
calibration
prominent
operational
conditional
sensitivity
temporal
estimations
determination
protocol
errors
detected
latent
repair
error
worth
fu
validating
impacts
expression
bold
proposing
constitutes
establishes
prob
transient
multiplicity
concerning
normalized
fabre
diagnose
xubin
scientifique
readout
kalbarczyk
leber
que
agu
midi
prori
flaviu
fertilization
jenn
vaxcluster
latella
maft
steininger
spek
pdcs
baraza
messaline
fuchs
beus
triplex
rabjac
automatique
equipotential
plc
precompetitive
fault injection
dependability evaluation
fault occurrence
fault tolerance
injection test
delta 4
test sequence
fault tolerant
asymptotic coverage
occurrence process
coverage parameters
injection experiments
target system
self checking
tolerant system
tolerance process
injected faults
observation domain
experimental evaluation
lsc nac
experimental measures
esc nac
failure rate
tolerant systems
l l
nac amp
dependability measures
error detection
g see
checking mechanisms
coverage time
amp software
jean arlat
distributed fault
experimental graph
duplex architecture
amp v2
coverage function
system dependability
tolerant architecture
host computer
conditional coverage
fault forecasting
coverage times
ftam coverage
expression 10
dependability validation
variable characterizing
confidence limits
injection based
tolerance algorithms
analytical dependability
hardware self
equivalent failure
tolerance processes
dependability analysis
mean coverage
random variable
evaluation method
predicate p
transition 1
target fault
fault removal
node failure
near coincident
non infinite
coverage c
cumulative distribution
ratio l
analytical modeling
faulty node
l n
non faulty
based evaluation
asymptotic value
faulty nodes
computers v
time distribution
main characteristics
results obtained
worth noting
mean time
occurrence rates
fault dormancy
g mtffnode
apparently tolerated
time censored
activation modes
intermittent faults
martins jean
task replicas
eliane martins
injection test sequence
fault injection test
fault injection experiments
fault occurrence process
fault tolerant system
fault tolerance process
assertion of p
delta 4 architecture
l l l
fault tolerant systems
model of figure
self checking mechanisms
e g see
nac amp v2
fault tolerant architecture
p in 0
distributed fault tolerant
equivalent failure rate
activated as errors
mean coverage time
delta 4 project
fault tolerance algorithms
fault tolerance processes
hardware self checking
establishes the link
non faulty nodes
target fault tolerant
ratio l n
ftams with respect
random variable characterizing
instant of assertion
esc nac amp
algorithms and mechanisms
based on fault
figure 2 b
transactions on computers
presence of faults
evaluation of dependability
evaluation and experimental
derivation of experimental
lsc nac amp
mtff of one
self checking capabilities
nac the fault
describes the behavior
injection and dependability
fault injection tool
case of fault
e t d
modeling for dependability
hardware error detection
empirical and physical
physical fault injection
fault injection based
arlat yves crouzet
thus be considered
occurrence and fault
delta 4 distributed
failure rate g
dependability evaluation method
typical experimental graph
reliability modeling techniques

corpus/krapavin2000-test/627792.txt
multimedia
sessions
disk
period
latency
bandwidth
session
buffer
equ
video
media
starvation
seek
ms
consumption
latencies
storage
file
audio
leftover
playout
device
ntsc
playback
mb
head
delivery
layout
buffering
transfer
streams
utilization
consumed
switching
timing
rate
allocation
intermedia
polimenis
track
rot
rotate
scheduling
switch
cylinder
compression
vbr
organization
interleaved
retrieval
files
rotating
block
raid
optical
rates
contiguous
unpredictable
disks
policy
interleaving
mbyte
bytes
throughput
recording
cbr
schedule
robin
theta
subtitles
rangan
mpeg
compressed
magnetic
requirements
dt
acceptance
conventional
tasks
khz
arm
cross
physical
transfers
fig
shares
round
uncompressed
miodrag
potkonjak
duration
comprised
heterogeneous
tracks
min
accept
server
tt
jpeg
striping
mth
meet
retrieved
placement
uncommon
lightly
qu
accepted
consume
discipline
synchronization
recorded
normalize
pt
sweeping
text
arrive
service
variance
gang
continuous
refined
dependent
requirement
layouts
availability
frame
surface
cylinders
positioning
demand
park
mbytes
doubly
admission
medium
rotational
devices
blocks
object
streaming
request
oe
insertions
permitting
rotation
loaded
enormous
plus
retrieves
subsystems
ith
synthesis
bits
kb
starves
malena
steams
abstractmultimedia
kandlur
heon
reserviced
equs
kiessling
gss
gemmell
weikum
mesarina
shortages
yeom
timedia
kyungoh
spects
enveloped
aerts
subsys
nerjes
tucson
joep
wren
multizone
probabilistic
heads
organizations
differing
drive
busy
read
byte
max
originating
chose
multimedia sessions
disk bandwidth
multimedia data
file system
non multimedia
seek latency
r c
min period
multimedia object
multimedia session
buffer requirement
consumption rate
dependent multimedia
storage organization
period length
multimedia processes
multimedia file
non real
time dependent
buffer space
working period
layout model
different media
multimedia objects
starvation rate
consumption rates
real time
system must
n head
ms e
sessions plus
rotating disk
multimedia tasks
max period
task switching
sessions supported
switching latencies
disk seek
bandwidth requirement
disk storage
period ms
ms 2
compression ratio
refined model
disk latency
theta r
buffer requirements
buffer allocation
lower bound
disk access
bandwidth utilization
disk array
bandwidth requirements
sessions m
period period
media objects
session switching
additional multimedia
polimenis 14
access schedule
period must
compressed ntsc
equ 10
audio data
hard requirements
mb frame
equ 8
ms buffer
allocation bytes
quality video
dt theta
intermedia synchronization
support multimedia
sessions 4
media data
continuous media
data transfer
transfer rate
rate r
equ 7
physical data
optical disks
physical storage
seek latencies
robin scheduling
probabilistic model
multimedia applications
free memory
storage device
bandwidth consumed
disk head
system synthesis
transfer data
round robin
data organization
timing requirements
time tasks
upper bound
system cannot
buffer constraints
r latency
continuous retrieval
quality audio
next track
conventional rotating
system transfers
delivery requirements
buffer consumption
value units
required buffering
period t period
set of multimedia
number of multimedia
number of sessions
time dependent multimedia
non real time
dependent multimedia data
non multimedia processes
file system must
multimedia file system
bandwidth and buffer
session i shares
r c r
multimedia sessions plus
accept a set
non multimedia tasks
dt theta n
additional multimedia sessions
disk seek latency
requirements of multimedia
ms buffer allocation
period is chosen
period ms buffer
bound t max
within a block
ms 2 oe
organization for multimedia
theta n head
physical data organization
multimedia sessions m
buffer allocation bytes
e t latency
period in order
rate r c
round robin scheduling
data transfer rate
c i r
real time tasks
real time requirements
amount of data
must be greater
sessions including bandwidth
latency r c
disk access schedule
file system cannot
latency i period
video audio text
placement of audio
physical storage organizations
theta t min
latency between sessions
quality video uncompressed
parallel disk array
multimedia data delivery
increase the period
task switching latencies
availability of sufficient
file system transfers
requirement is minimized
average seek latency
potkonjak system synthesis
gamma r c
additional disk bandwidth
compressed ntsc video
multimedia sessions originating
choosing the length
disk bandwidth r
number of supported
grouped sweeping scheme
period to meet

corpus/krapavin2000-test/633055.txt
flows
rat
flights
packets
packet
rtt
congestion
traces
tcp
flight
window
tra
receiver
flow
mss
bytes
sender
transport
internet
limiting
rates
rate
bandwidth
duration
acknowledgment
trace
sf
connections
delayed
connection
slow
sigcomm
link
opportunity
limited
bu
fac
correlations
mbps
stream
avoidance
bottleneck
fastest
msec
correlation
di
er
tool
trip
host
determinations
tcpanaly
fraction
advertised
routers
estimation
nagle
erent
acknowledgments
transferred
transmit
kbps
logr
npd
knowledgments
dummynet
datasets
skewed
mbyte
accounted
router
adus
rtts
deemed
identified
cumulative
big
round
limits
behaviors
transmission
links
dynamics
sizes
loss
peering
plot
networking
backbone
logd
ss
experiencing
factors
ack
rcvr
mtu
sndr
network
captured
validated
traffic
evident
analyzer
lived
measurement
cdf
statistics
candidate
normality
inter
fc
layer
determination
idle
dominant
arrival
lasting
file
exhibited
jan
periodic
routing
saturated
characteristics
plots
sec
experience
simulations
ect
burst
ca
million
percentage
predicted
sarvotham
seqb
specif
lukas
ssthresh
kencl
awndmax
ackf
wilk
validate
summary
origins
duplicate
un
cult
background
across
congested
validation
assess
tests
complementary
causes
percentile
transitions
competing
durations
review
aggregate
varied
successive
transitioned
freebsd
kortebi
erentiate
muscariello
corr
wetherall
janeriro
oueslati
provider
consistent
ip
hours
hour
dataset
experienced
bandwidths
web
estimate
category
spaced
sigmetrics
logs
load
window limited
rate limiting
packet traces
receiver window
flow rates
tra c
application limited
transport limited
bandwidth limited
slow start
delayed acknowledgments
congestion limited
bottleneck link
rtt estimation
opportunity limited
fast flows
acknowledgment packets
flight sizes
without delayed
summary flow
limiting factors
congestion avoidance
packet loss
host window
acknowledgment stream
sender window
data packets
acm sigcomm
bu er
rate limit
cumulative fraction
limiting behavior
limiting factor
candidate rtt
successive flights
flow rate
flows account
limited behavior
round trip
fastest flows
limited congestion
flight size
fraction flow
receiver limited
internet flow
limited flows
tcp connections
congestion window
access links
link bandwidth
accurate within
window sizes
di erent
advertised window
transmit data
nagle algorithm
inter packet
flows transmit
periodic determinations
consecutive flights
background load
flight f
flights f
bytes transferred
data stream
packet level
trip time
first packet
correctly identified
review v
computer communication
communication review
sigcomm computer
flow size
limited application
packet trace
flow characteristics
rate distribution
per flow
delayed ac
trace contains
flow sizes
q plot
limited tra
rate analyzer
limited receiver
single direction
window limits
limited transport
flow level
flows bytes
flow statistics
limiting behaviors
network limits
side estimation
connection sizes
complementary distribution
rat works
mbyte file
total bytes
mss sized
limit determination
ac knowledgments
measurement october
receiver window limited
rate limiting factor
size and rate
size and duration
sender window limited
rate limiting factors
distribution of flow
correlation between size
without delayed acknowledgments
fraction of bytes
rate limiting behavior
host window limited
limited congestion limited
cumulative fraction flow
limited application limited
set of flights
rate and duration
internet flow rates
limited a flow
round trip time
computer communication review
sigcomm computer communication
communication review v
acm sigcomm computer
number of packets
within a factor
internet measurement october
flows transmit data
summary flow data
packets into flights
make a rate
correlation between rate
application limited tra
delayed ac knowledgments
rate limit determination
percentage of bytes
limited tra c
q q plot
limited transport limited
flow is considered
rate limiting behaviors
sender and receiver
factor of 1
number of flows
review v 36
congestion limited transport
window limited using
limited receiver limited
mss sized packets
limited the sender
sequence number seen
receiver limited figure
bytes flows bytes
data and acknowledgment
jan 3 2002
flows bytes flows
traces and summary
fraction of flows
duration and rate
largest sequence number
sender s window
dominant rate limiting
summary flow level
sizes of 2
experience any loss
flows lasting longer
big and fast
rat correctly identified
application limited congestion
consistent with slow
flow s transmission
transitions to un
flow level statistics
host sndr rcvr
rates of flows
transport limited receiver
rate and size
background tra c

corpus/krapavin2000-test/607301.txt
codes
dual
harmonic
extremal
enumerators
weight
designs
polynomials
harm
codewords
self
rx
enumerator
doubly
zc
wc
hahn
macwilliams
wt
juj
jacobi
unimodular
spherical
assmus
lattices
mattson
classication
venkov
characters
nw
coe
cryptography
permutation
xed
xy
word
invariants
dened
jc
announced
tz
krawtchouck
polyno
gaborit
betsumiya
isodual
mials
koichi
formally
rst
lattice
notations
lemma
harada
poisson
mod
polynomial
ozeki
masaaki
denition
code
fourier
ng
unknowns
invariant
chap
equations
cients
strengthening
summation
formula
possibilities
classi
degree
equality
ig
satises
ju
series
cardinality
subgroup
spaces
transform
binary
corollary
milenkovic
quebbemann
dualcodes
kenichiro
enu
reprove
fnw
merators
isoduality
abh
extremality
olgica
masson
pless
tanabe
algebra
combinatorial
remark
subsets
meeting
dierentiation
molien
bijections
uj
bonnecaze
delsarte
magma
bachoc
sits
calderbank
classical
intersection
cw
circulant
isometric
deduces
kin
geom
group
nd
meets
denitions
aw
huffman
matrices
analogy
position
positions
duals
zx
coding
covering
recover
classify
ideals
coset
automorphism
shadows
resp
christine
gathers
valuation
euclidean
usual
cient
nite
analogues
referee
settle
odd
rep
argumentation
weights
modular
homogeneous
ker
bijective
tf
eight
corollaries
transposition
philippe
orthogonal
scalar
specialize
sole
math
preprint
siam
hypothesis
dene
theta
belongs
jt
belonging
dimension
overlap
shadow
play
identied
correcting
self dual
formally self
dual codes
even formally
harm k
harmonic weight
code c
doubly even
weight enumerators
weight 4
extremal even
dual code
xed weight
c f
h k
weight enumerator
hahn polynomials
length 12
z c
w c
even self
relative invariants
zc h
group g
harmonic functions
degree k
cryptography v
designs codes
binary code
even unimodular
theta series
n 2k
xy k
harmonic function
rx k
c form
f 2
assmus mattson
weight 6
intersection numbers
lemma 2
f n
g 2
j l
wc h
mod 24
macwilliams type
characters k
b venkov
wt u
summation formula
poisson summation
u 4
length n
mattson theorem
dual doubly
binary linear
code b
invariant theory
corollary 2
weight 2
v z
b 12
jacobi polynomials
f z
let f
let c
lemma 6
linear codes
fourier transform
c c
u 2
g 1
k w
f x
even weights
six unknowns
betsumiya masaaki
koichi betsumiya
spherical designs
unimodular lattices
krawtchouck polynomials
wt v
wc f
enumerator associated
masaaki harada
clearly n
enumerators wc
four possibilities
certain harmonic
classication result
spherical codes
g 0it
designs supported
harmonic spaces
extremal formally
polyno mials
codewords support
usual weight
theorem 2
one possibility
x k
formally self dual
self dual codes
even formally self
harmonic weight enumerators
self dual code
z c f
f 2 harm
extremal even formally
code of length
w c f
even self dual
doubly even self
codes and cryptography
group g 1
zc h 1
c f x
codewords of xed
word in c
let f 2
weight in c
lemma 6 1
codes of length
theorem 2 1
code b 12
words of weight
k w c
poisson summation formula
wc h k
k t u
weight 4 word
dual doubly even
assmus mattson theorem
v 2 f
set of codewords
self dual doubly
lemma 2 3
group g 2
corollary 2 2
belongs to c
divided by xy
cient of x
solution is trivial
overlap and covering
denitions and properties
code c form
f w c
designs and self
constructed from hahn
case k 0
macwilliams type equality
wc f x
space of relative
xy k w
characters k dened
enumerators wc h
koichi betsumiya masaaki
weight 2 word
doubly even code
betsumiya masaaki harada
harmonic function f
weight enumerators wc
extremal formally self
harmonic weight enumerator
usual weight enumerator
linear code c
otherwise the sum
invariant linear forms
polynomials z c
results of invariant
function of degree
ju t j
element of rx
f are relative
weight 6 words
c of weight
compute the fourier
certain harmonic functions
two such words
weight enumerator associated
juj and ju

corpus/krapavin2000-test/629443.txt
scheduling
tasks
myopic
parallelizable
schedule
parallelization
deadlines
resource
backtracks
feasibility
schedulability
deadline
usep
success
split
task
preemptive
multiprocessor
window
sharep
laxities
scheduler
earliest
fig
num
feasible
laxity
processors
dispatch
max
btrk
est
heuristic
reclaiming
scheduled
parallelized
exclusive
oeae
manimaran
partitionable
processor
ratio
simulation
queues
met
vertex
aperiodic
edf
mode
meeting
siva
offered
sc
arriving
figs
parallelism
eat
murthy
dynamically
backtracking
queue
schedulable
usage
precedence
fixing
meet
integrated
arrive
centralized
studies
qin
multiprocessors
strongly
resources
arm
ready
sublinear
overloading
sensitivity
imprecise
speedup
arrival
behaves
requirements
xiao
check
degree
till
parallelizing
shared
shashidhar
merugu
omari
defago
ecutes
manikutty
paramter
weightage
parm
nonparallelizable
jeopardizing
alghamdi
somani
utilization
2d
robot
dynamics
predictable
periodic
availability
tighter
conflicting
trend
yeon
preemptable
avionic
inoguchi
sublinearity
evaluations
ahead
exclusion
permitted
overhead
degrees
finish
nonpreemptive
parallelizes
reschedule
academy
nuclear
checked
infeasible
ram
wireless
tries
schedules
yuanyuan
ignorant
anand
arcs
hong
worst
upto
avail
saturates
feasibly
abstractmany
yasushi
indian
quebec
executing
commack
nova
dispatched
plant
comma
xavier
varying
executions
exploits
backup
requested
achieving
reliability
arun
spending
dynamic
timing
mohammed
sung
subtasks
montreal
backtrack
portion
res
tightness
jiang
basics
uniprocessor
jong
termination
xie
completion
max split
success ratio
task scheduling
parallelizable task
feasibility check
check window
scheduling algorithm
myopic algorithm
real time
task parallelization
dynamic scheduling
task set
feasible schedule
scheduling cost
dispatch queues
resource requirements
time systems
simulation studies
time tasks
task sets
k tasks
fig 2c
integrated heuristic
strongly feasible
multiprocessor systems
computation time
case computation
search tree
num btrk
earliest available
window k
split tasks
laxity parameter
task queue
partial schedule
ratio offered
shared mode
resource usage
resource constraints
scheduling algorithms
multiprocessor real
resource reclaiming
preemptive algorithm
always higher
computation times
time task
available time
among tasks
fig 2e
ready time
split 1
tasks arrive
fig 2d
dynamically arriving
g manimaran
num split
parameter fig
fig 2a
non preemptive
non parallelizable
current task
h value
current schedule
figs 4
window fig
scheduling problem
proposed algorithm
exclusive mode
task model
constraints among
algorithms 8
new tasks
earliest time
time multiprocessor
different values
ffl let
fig 2b
time scheduling
lower values
tasks taken
best task
next best
max c
constrained tasks
b extend
w parameter
k size
heuristic function
arriving tasks
algorithm backtracks
meeting deadlines
higher scheduling
exploits parallelism
split 4
high schedulability
scheduling considered
parallelizable task scheduling
feasibility check window
values of max
task scheduling algorithm
degree of parallelization
number of backtracks
real time systems
dynamic scheduling algorithm
real time tasks
worst case computation
check window k
success ratio offered
case computation time
size of feasibility
meet their deadlines
multiprocessor real time
algorithm is always
real time task
earliest available time
mode at time
algorithm for scheduling
effect of w
tasks in real
increases the success
offered by max
parallelism in tasks
scheduling in real
check window fig
resource constraints among
figs 4 8
parallelized and scheduled
max split 1
checked for feasibility
constraints among tasks
available for shared
schedule is extended
number of tasks
time multiprocessor systems
given in fig
task s deadline
real time multiprocessor
effect of resource
real time scheduling
set of tasks
hard real time
extensive simulation studies
however the higher
satisfy such requirements
algorithm behaves like
search tree specific
search tree constructed
robot arm dynamics
conducted extensive simulation
dynamically arriving real
look ahead nature
myopic scheduling algorithm
task set given
variety of task
effect of number
tasks are less
uses a resource
preemptive version however
scheduling overhead parallelizable
schedule is strongly
algorithms 8 9
achieving high resource
laxity parameter fig
split maximum degree
availability of processors
non preemptive algorithms
like the myopic
higher scheduling overhead
literature to satisfy
myopic algorithm fig
max split maximum
overhead parallelizable task
simulation studies show
times of tasks
first k tasks
performing feasibility check

corpus/krapavin2000-test/1009027.txt
document
corpus
documents
pd
clusters
baseline
facetsq
prec
lm
topclusters
retrieval
precision
cluster
aspect
interpolation
ranking
bag
idf
pc
smoothing
tf
scoring
zhai
score
specic
rank
facets
language
corpora
template
la
qjc
qjd
topdocs
latent
query
fr
chengxiang
stemmer
avg
dirichlet
trec
select
relevance
similarity
sigir
cjd
jfacetsq
hyeok
lillian
kurland
interpolated
ranked
hoc
seung
hoon
lemur
interp
feedback
oren
clustering
ad
cohort
stemmed
tao
eect
pseudo
yes
smoothed
chains
pus
lavrenko
laerty
salvador
inquery
stopword
modeling
incorporation
bremen
pt
probabilistic
classic
induced
jong
stemming
optional
unsupervised
porter
xuanhui
reexamining
qiaozhu
dint
croft
lee
overlapping
markov
thought
statistics
hofmann
kang
na
hyperlinks
ndings
mei
association
selection
divergence
nal
emphasizing
sloan
suers
competitive
incorporating
dierent
incorporate
curves
docu
eective
lambda
statistically
queries
formation
aggregates
reliance
leibler
brazil
text
utilizing
improvements
kullback
ir
specied
vocabulary
iis
diers
signicance
degradation
kl
bruce
instantiations
wherein
management
concatenating
scores
enhance
germany
cor
dependence
uniform
re
toolkit
yielded
fee
dierences
ment
annual
cussion
detemine
drugs
frequen
mykola
roh
lms
breck
cacy
demonstrably
stoyanov
ves
trieved
rooney
shimon
domshlak
uage
compel
krovetz
detrimen
carmel
conceives
xiaoyong
upset
aspect x
pd q
language models
language modeling
re ranking
interpolation algorithm
facetsq d
topclusters q
language model
pc q
basis select
re rank
uniform aspect
bag select
information retrieval
average precision
set select
la fr
aspect model
x algorithm
tf idf
q m
lm approach
document specic
avg prec
baseline lm
cluster based
corpus structure
modeling approach
pseudo feedback
select set
similarity structure
select algorithm
select bag
baseline basis
document information
based language
individual document
cluster information
precision recall
retrieval information
interpolated precision
information representation
hoc information
topdocs n
hoc retrieval
document language
feedback markov
standard language
p qjc
p qjd
relevance model
optional re
pc d
ranking step
rank step
x uniform
algorithm template
relevant documents
retrieval august
m pd
scoring function
chengxiang zhai
ad hoc
particular document
retrieval time
specic information
c p
international acm
sigir conference
acm sigir
induced language
precision curves
inter document
curves corpus
jfacetsq d
recall 11
hoon na
seung hoon
x precision
recall 48
lm based
cohort d
non interpolated
standard lm
three corpora
interpolation algorithms
p cjd
oren kurland
hyeok lee
select aspect
average non
kurland lillian
qjc p
su kang
component documents
basic lm
jong hyeok
information drawn
qjd c
q jfacetsq
pt precision
document clusters
lillian lee
clusters c
document d
query independent
overlapping clusters
smoothed language
d pc
smoothing method
markov chains
representation e
free parameter
annual international
model 9
cluster size
models proceedings
unsupervised learning
october 31
bremen germany
v 43
k 40
chains algorithm
tao xuanhui
topclusters q m
uniform aspect x
language modeling approach
aspect x algorithm
select set select
prec at 0
based language models
basis select set
baseline basis select
set select bag
select bag select
approach to information
re ranking step
m pd q
x and interpolation
q m pd
pseudo feedback markov
c p qjc
re rank step
cluster based language
document specic information
ad hoc information
ad hoc retrieval
standard language modeling
x uniform aspect
hoc information retrieval
aspect x uniform
information retrieval august
development in information
conference on research
acm sigir conference
international acm sigir
annual international acm
non interpolated precision
document language models
individual document information
p qjd c
clusters in topclusters
induced language models
precision curves corpus
language models proceedings
recall 11 pt
jfacetsq d j
feedback markov chains
bag select aspect
q jfacetsq d
precision recall 11
precision at 0
seung hoon na
d pc q
aspect model 9
pd q jfacetsq
p qjc p
bag select algorithm
pt precision curves
oren kurland lillian
optional re ranking
aspect x precision
kurland lillian lee
c 2 facetsq
select aspect x
information retrieval information
jong hyeok lee
na in su
average non interpolated
clusters in facetsq
processing and management
management an international
degree of dependence
representation e g
research and development
journal v 43
october 31 november
november 05 2005
management october 31
international journal v
number of documents
knowledge management october
v 43 n
original aspect model
respect to average
cluster induced language
learning by probabilistic
avg prec 21
prec 21 03
smoothed language models
recall at n
j 0 redundant
xuanhui wang qiaozhu
top ranked documents
eect of using
ranking by pd
induced from d
n top scoring
retrieval information retrieval
corpus similarity structure
algorithm see table
aspect x interp
facetsq d score
latent dirichlet allocation
expanded query language
aspect x algorithms
q m c2facetsq
document expansion proceedings
average precision corpus
nal output list
dirichlet smoothed language
eect of re
august 06 11
methods we used

corpus/krapavin2000-test/1018488.txt
bccsp
depth
futures
equivalences
behavioural
bisimulation
axiom
preorder
equational
inequation
nested
inequational
closed
substitution
axiomatization
sound
trace
hennessy
equivalence
milner
finitely
axiomatizations
ax
en
axiomatizable
modulo
preorders
pn
lengths
norm
ln
axioms
axiomatizability
epf
modal
glabbeek
inequations
ltss
traces
semantics
simulation
lemma
action
sect
actions
shall
transition
inequa
ccs
equationally
transitions
inductive
afford
induction
soundness
aceto
vaandrager
groote
claim
summands
labelled
algebras
formulae
cit
contradicting
var
depths
proposition
ap
spectrum
congruence
infer
completed
substantial
affords
notions
characterization
technical
branching
behaviour
inductively
concurrency
hai
relations
iff
developments
tionally
processes
aq
contexts
provable
derivable
aforementioned
proven
absorption
fm
language
statement
behaviours
finite
ottir
olfsd
bpa
tyft
pomsets
tyxt
menagerie
algebra
decidable
statements
derivations
summand
van
viz
luca
axiomatized
fokkink
lence
tacitly
brookes
decidability
formula
operational
closure
outgoing
hypothesis
tional
prefixing
proviso
fn
substitutions
logic
amongst
reflexivity
equiva
allocation
proceed
occurring
ready
offer
coarsest
mn
business
remark
grammar
light
arguing
anna
promised
languages
fy
operators
proofs
plotkin
op
distinguishing
interleaving
none
offered
operator
subterm
singleton
merge
pf
associativity
claims
elegant
satisfied
argue
completeness
exhibit
commutativity
kg
fragment
equations
clause
sequences
hole
eg
format
nondeterminism
professor
occurs
presenting
structural
algebraic
play
approximations
symmetry
albeit
bccsp terms
nested simulation
closed bccsp
bccsp term
possible futures
closed substitution
n nested
language bccsp
bisimulation equivalence
nested trace
ax en
q 0
v occurs
depth d
axiom system
trace equivalences
simulation preorder
finitely based
sound modulo
depth p
closed terms
equational axiomatizations
behavioural equivalences
v u
futures preorder
depth u
finite equational
p q
c u
completed trace
modal characterization
equational axiomatization
terms p
n 0
trace equivalence
every n
context c
lemma 2
inequational axiomatization
substantial substitution
finite inequational
v q
closed term
en 1
p 0
p v
labelled transition
may infer
behavioural equivalence
time spectrum
nested semantics
trace semantics
futures equivalence
non finite
depth q
depth allocation
time branching
closed substantial
unique depth
behavioural semantics
finite axiomatizability
depth 0
q n
term u
process algebras
may conclude
inductive hypothesis
van glabbeek
inequation p
language ln
finite index
technical developments
lengths q
x occurs
suppose c
branching time
every closed
image finite
equationally axiomatizable
inequational logic
closed bccsp terms
sound with respect
nested simulation preorder
n nested trace
hennessy and milner
every n 0
possible futures preorder
n nested simulation
nested trace equivalences
sequence of actions
p v q
closed bccsp term
simulation and trace
ax en 1
terms p q
lemma 2 b
closed terms p
u is sound
c u 2
finite inequational axiomatization
terms over action
possible futures equivalence
unique depth allocation
n 2 lengths
n 1 q
time branching time
q be closed
branching time spectrum
linear time branching
q a q
labelled transition systems
p and q
let p q
derived from e
contradicting our assumption
finite equational axiomatizations
equivalence and preorder
non finite axiomatizability
closed substantial substitution
inequation p v
induction on n
p is also
finite axiom system
notions of behavioural
afford finite equational
soundness of e
axiom system e
milner in 18
axiom in e
satisfied by q
equivalence is decidable
groote and vaandrager
left merge operator
bccsp terms p
finite equational axiomatization
bccsp terms thus
nested trace equivalence
pn and q
n or n
occurs at depth

corpus/krapavin2000-test/1011512.txt
coalescing
spill
spilled
coalesced
allocator
coloring
chaitin
chunks
optimistic
aggressive
register
colored
live
coalesce
splitting
briggs
interference
iterated
conservative
colorable
allocation
spilling
oo
colorability
coalescible
copy
spills
copies
stack
xy
impact
colors
heuristic
num
color
registers
instructions
ab
renumber
split
sed
conservativeness
lescing
coa
vliw
node
coalesces
violating
instruction
xyz
splits
scheduling
nodes
interfering
compress
opportunities
pipelining
optimistically
rematerialization
neighbors
simplification
espresso
promotion
edges
phase
degree
aggressively
coalesc
allocators
eqntott
chance
interfere
simplified
removes
heuristics
candidate
freeze
def
undo
oeo
nonnumerical
oof
conservatively
fully
conser
sparc
eliminates
marking
interferes
bors
unroll
pushed
ssa
outweigh
assigning
affecting
neigh
scheduled
target
chunk
eliminated
successfully
pushes
ranges
nest
simplify
potential
benchmark
ingredient
ratio
parallelizing
preferred
negative
exploits
bc
ordering
select
renaming
assembly
wimmer
bouchez
pipelin
takuya
alus
mssenbck
pact
aggres
inagaki
ruin
orability
nakaike
coalescingg
unioned
rastello
alescing
cludes
rematerial
tatsushi
darte
vative
hanspeter
rematerializable
reckless
li
safe
tm
benchmarks
biased
selective
removed
style
opportunity
ignores
elimi
uncolored
hideaki
vatively
appel
ferrante
myampersandamp
pessimistically
komatsu
speculatively
fabrice
premature
overwrites
florent
toshio
nakatani
cisc
compilers
violation
composed
top
concern
neighbor
thing
round
aggressive coalescing
live range
conservative coalescing
coalesced node
range splitting
register allocation
optimistic coalescing
copy related
spill cost
positive impact
iterated coalescing
graph coloring
related nodes
actually spilled
optimistic allocator
o oo
actual spill
interference edges
coloring register
oo o
interference graph
register allocator
significant degree
potential spill
spill instructions
negative impact
violating chunks
phase ordering
briggs optimistic
degree neighbors
low degree
optimistic register
degree node
select phase
candidate chunks
non copy
coalescing heuristics
live ranges
software pipelining
node xy
target nodes
global register
coa lescing
coalescing heuristic
split back
register coalescing
spilled nodes
optimistic allocation
selection phase
every node
via graph
two nodes
instruction scheduling
simplification phase
case allocator
coalescing see
coalesced chunks
two colorable
chaitin style
concern later
coalescing may
build phase
copies eliminated
spill concern
optimistic coloring
spilled chunks
potentially spilled
spilled colored
partially spilled
fully spilled
spill results
colored nodes
conservativeness heuristic
simplify chaitin
machine registers
instructions generated
degree nodes
non interfering
two colors
heuristic called
live range splitting
copy related nodes
impact of coalescing
o oo o
graph coloring register
oo o oo
coalescing on top
coloring register allocation
chaitin s allocator
significant degree neighbors
spilled to memory
briggs optimistic allocator
nodes being coalesced
coalescing or iterated
non copy related
via graph coloring
graph is empty
top of optimistic
global register allocation
source and target
exploits the positive
ordering of optimistic
splits are spilled
spill concern later
coalesced node xy
chaitin s register
simplify chaitin style
low degree node
possible to color
base case allocator
num of nodes
coalescing in table
num of chunks
spill instructions generated
shows the number
x and y
number of nodes
y and z
problem of assigning
c d c
less than k
chunks nodes chunks
nodes conservative coalescing
eliminates more copies
pipelining an effective
improving the overall
improvements to graph
compress sed average
colored with different
ab c d
two split nodes
previous coalescing heuristics
f o oo
effective scheduling technique
outweigh the negative
spilling the allocator
node is significant
first build phase
oeo oo f
select actual spill
assigned a color
nodes in violating
reduced by one
colors are available
coalesced node ab

corpus/krapavin2000-test/627906.txt
ss
mining
traversal
fs
references
reference
web
scans
sequences
scan
database
forward
mf
maximal
dhp
fanout
height
association
syan
itemsets
internal
theta
hung
patterns
chen
backward
candidate
hashing
child
ming
zipf
frequent
joshi
traveling
garofalakis
jumps
transaction
browsing
cpu
selective
jump
trimmed
sales
subsequences
abegh
posters
hxpy
discovery
string
sensitivity
disk
rastogi
pruning
nanopoulos
anupam
option
chang
lee
conducted
logs
alexandros
lin
customer
sigkdd
chih
sec
manolopoulos
jc
leaf
meaningful
items
node
karuna
trimming
holmquist
phoha
subroot
vir
illustrative
cheng
hypertext
parent
mclean
ru
hash
subsequence
yannis
scanned
www
pass
varied
damon
yesha
rajeev
narayanan
minos
yelena
shing
authoring
prominent
tree
utilizing
comparatively
decreases
chiba
peng
fu
paths
linked
interactive
referencing
null
yen
url
synthetic
passes
ho
bar
virginia
rules
log
shao
hari
newsletter
convert
services
outperforms
advantageous
nodes
wic
hw
shim
marketing
devise
shall
sliding
utilizes
poisson
shih
bremen
itemset
explorations
educational
batch
world
logged
databases
management
determining
devised
hua
consecutive
edmonton
proxy
eleventh
hsu
shin
seconds
jp
liang
discrepancy
stock
ali
documents
sequential
ease
explored
users
prefetching
lm
varies
collect
path
yu
tightly
alberta
weight
germany
sessions
tracks
clustering
superset
georgia
environments
navigation
hot
flag
september
probabilities
wen
large reference
reference sequences
maximal forward
forward references
traversal patterns
theta theta
reference sequence
forward reference
traversal tree
internal nodes
determining large
algorithm mf
mining traversal
database scans
association rules
k references
information providing
algorithm ss
c c
data mining
string y
algorithm fs
l k
internal node
user access
selective scan
traversal path
c ss
maximal reference
minimum support
c k
ming syan
syan chen
ss theta
k reference
internal jumps
support c
d f
child nodes
transaction database
sec minimum
o time
frequent traversal
reference path
zipf like
reference paths
database size
time sec
wide web
mining association
large k
world wide
log data
like distribution
various parameters
o cost
fs algorithm
path traversal
scan ss
providing environment
ss algorithm
candidate references
traversal paths
determine large
traversal log
backward references
references obtained
candidate reference
internal jump
traversal pattern
log database
sequences decreases
meaningful user
sensitivity analysis
database scan
mining web
parent node
c 0
candidate itemsets
finding frequent
sales data
tree increases
hung lee
sequential patterns
chang hung
full scan
finding large
large itemsets
international conference
two methods
child node
linked together
o times
pattern mining
access patterns
interactive access
sequences second
facilitate interactive
original log
outperforms fs
mainly made
original sequence
access sequences
scans required
mining meaningful
anupam joshi
scan fs
traversal sequence
determine maximal
mining capability
involves mining
properly utilizing
comparatively analyzed
backward reference
sequences figure
leaf nodes
pruning techniques
sufficient number
cpu time
l 2
n j
two algorithms
web logs
knowledge discovery
knowledge management
execution time
large reference sequences
maximal forward references
theta theta theta
number of large
fs and ss
c c c
mining traversal patterns
determining large reference
c c ss
set of maximal
ming syan chen
support c c
minimum support c
c ss theta
maximal forward reference
ss theta theta
sec minimum support
time sec minimum
forward reference path
zipf like distribution
large reference sequence
world wide web
disk i o
mining association rules
number of child
hashing and pruning
analysis on various
determine large reference
meaningful user access
selective scan ss
frequent traversal patterns
information providing environment
nodes with internal
path traversal patterns
reference sequences decreases
forward references obtained
objects are linked
maximal reference sequences
large k references
number of internal
chang hung lee
set of candidate
time to find
environment where documents
generated from c
scan to determine
convert the original
written to d
cpu time sec
scan ss algorithm
facilitate interactive access
itemsets for association
patterns and association
o time sec
theta i o
data mining capability
sequences in batch
option of selective
access sequences second
large k reference
database d f
made for ease
documents or objects
full scan fs
information providing services
user access sequences
reference sequences figure
ease of traveling
option of determining
database scans required
maximal reference sequence
mining meaningful user
together to facilitate
number of candidate
information and knowledge
conference on information
references i e
new data mining
user access patterns
database size increases
nodes the number
sequence of log
set of large

corpus/krapavin2000-test/626788.txt
displayable
cscd
suffix
imp
scd
circular
scdawg
prefix
vertex
strings
ire
string
substring
redundant
de
xfl
jde
ff
occurrences
linearoccurrences
pred
rr
incident
entities
fl
entity
cv
abc
superword
edges
le
circoccurrences
jpred
edge
vertices
subword
conflicts
ul
traversals
subcase
occurrence
succ
ur
fde
letter
linearize
cabcbab
jocc
yde
flx
scdawgs
rus
conflict
visualization
jsucc
fincoming
vg
label
fi
lus
sink
ab
iff
redirected
abcbab
jflj
csdawg
cabcb
incoming
delete
gabcde
subwords
genomes
jffj
bab
character
labels
processed
queries
leaving
polygons
alphabet
substrings
reset
nil
abcd
preceded
continues
extension
verticesg
gammajfij
retrievable
processprefixredundant
circularize
fiy
scdint
cabc
fidentify
processsuffixredundant
processbothredundant
yfl
jlcs
traversed
corollary
eliminated
fabcgabcde
intrasequence
chain
smallest
ffl
concatenation
homology
linearizing
cde
shades
protein
repetition
sigma
traverse
patterns
successor
re
postprocessing
updated
acyclic
predecessor
conflicting
lemma
induction
cr
recurring
polygon
angle
uniqueness
clockwise
bit
economical
contradicts
redundancy
traversal
pointers
contradiction
curves
listed
arbitrarily
modifications
sm
overlap
dm
inverted
pointer
complexities
affeffeffcfic
fifffl
bfiaffeffeffcficfiefiaffeffeffcficfibffcffdffcff
cabcbabcabcbab
jfij
fwe
fdo
jfl
fsimilar
abcaaaa
babcaa
bcdabcea
abcdabce
fobtain
dawg
cabcaa
dabcg
gammajffj
zde
gammajde
ffj
word
color
fg
brackets
said
pattern
directed
identifies
maximal
de v
circular strings
displayable entities
displayable entity
linear strings
suffix redundant
de w
circular string
prefix redundant
linear string
extension edge
re edge
prefix suffix
extension edges
w 1
last cscd
suffix prefix
v ffl
jde w
ffl v
prefix extension
de u
le edges
suffix extension
re edges
ire last
one re
ffl cv
j n
v j
right extension
jde v
pattern ff
edges incident
w 2
vertex v
leaving v
smallest superword
edge e
ff ff
j last
yde v
right edges
re le
fl ff
two re
ff 2m
left edges
redundant vertices
procedure circoccurrences
d 1
size greater
entities d
redundant vertex
left extension
ff j
vertex representing
u 0
u r
every pattern
ff pred
ff f1g
length greater
edge corresponding
d 2
e r
v 1
v v
vertices representing
le edge
vertex corresponding
de x
suffix conflict
step 3
vertex w
v de
closed curves
occurrences of de
imp s de
rr in cscd
re out edge
linearoccurrences t v
de w 1
de u r
ire last cscd
v v ffl
occurrence of de
jde v j
ff ff ff
incident on v
le out edge
point to w
pred s ff
v j n
v ffl v
v are updated
suffix extension edges
ff j 2
fl i j
incident on w
scdawg for circular
pred t ff
ff of length
u r y
de v v
v ffl cv
jde w 1
greater than k
imp s ff
prefix of de
prefix extension edge
incident on vertices
displayable entities d
entities d 1
extension edge e
edges from v
let the vertex
fde a j
bit which indicates
edges to vg
leaving v let
edges the bit
w their labels
every pattern ff
extended to circular
delete the edge
superword of de
labels are modified
de v de
re out edges
j a ffl
n j n
prefix suffix conflict
occurrences of displayable
de v must
edges to v
de v 2
let the label
represent the concatenation
number of occurrences
used to represent
equal to n
occurrences of d
less than n

corpus/krapavin2000-test/629334.txt
synchronizer
processor
delays
rate
synchronizers
processors
stochastic
petri
dilation
network
nbue
markov
embedding
nets
transmission
distributions
firing
chain
ws
negligible
message
transits
topologies
networks
messages
ff
exponentially
directed
enabled
delta
log
cycle
limiting
vertex
subadditive
gx
ck
ae
ffi
shuffle
pr
fork
convex
ergodic
edges
marked
topology
synchronization
exponential
asynchronous
queueing
quiescent
clock
vertices
realization
beats
proposition
edge
embed
queuing
incoming
ps
deterministic
rajsbaum
awakened
debruijn
chep
slowdown
slow
combinatorial
vg
unam
spanner
probabilities
degraded
synchronous
grows
random
remark
queues
indegree
kb
outdegree
completion
degree
corollary
fi
recursions
cb
logarithmic
induction
butterfly
completed
graphs
arrived
coming
slows
ending
slower
schedulers
diminishes
tentative
sends
join
kd
gammak
sent
identically
strongly
probability
transition
rates
shall
links
bounds
son
inductive
eg
jv
snapshots
acyclic
regular
breadth
st
fx
gamma
techsel
ciudad
dgsca
transmissiondelays
fikm
simplesynchronizer
theassumption
exponentialdistribution
awake
unittime
quentin
westudy
liberty
matematicas
instituto
sideman
unison
therandom
forthe
gurdip
selfloop
theaverage
bfs
lipman
bakr
synchronousnetwork
abottleneck
leastlog
path
minus
bottleneck
finishes
token
recurrence
investigations
routing
optimistic
definite
processing times
processor v
k v
transmission delays
computational step
stochastic petri
directed cycle
random variables
g v
log delta
petri nets
markov chain
level l
limiting probability
k 0
exponentially distributed
every k
marked graphs
mean gamma1
simple synchronizer
negligible delays
log ffi
ff v
k n
slow processor
v k
complete graph
simple directed
network synchronization
times k
ws k
v e
m k
order n
log n
non negligible
r v
asynchronous network
theorem 3
ck log
state ws
computation rate
potential rate
negligible transmission
processing state
regular degree
ergodic theory
chain associated
dilation 2
arbitrary topology
distributed networks
n g
one message
computational steps
different topologies
fork join
strongly connected
variables k
mean 1
distribution f
deterministic case
complete network
probability distributions
r g
k 1
h v
incoming edge
different networks
global clock
n gamma
length k
lemma 4
subadditive ergodic
random processing
kb n
enabled processors
exact computations
stochastic ordering
network k
general distributions
corresponding processing
degree network
ps k
marked graph
stochastic marked
compare networks
steps executed
limiting probabilities
general probability
pr ck
state ps
theorem 4
ff j
lower bounds
deterministic processing
adding edges
combinatorial approach
v 0
c n
constant factor
stochastic petri nets
processing times k
times k v
every k 0
simple directed cycle
path of length
g v e
negligible transmission delays
random variables k
rate of computation
message m k
v k 0
graph with dilation
ck log delta
embed the order
variables k v
number of states
d in v
k v k
one can embed
number of processors
theorem 3 3
time t v
random processing times
edge to processor
exponentially distributed processing
v or simply
deterministic processing times
computational steps executed
markov chain associated
corresponding processing times
strongly connected graph
non negligible transmission
bounds for stochastic
non negligible delays
rate of v
subadditive ergodic theory
ending in v
n gamma l
processor is enabled
stochastic marked graphs
distributed processing times
general probability distributions
n t v
network k n
state ws k
r g v
lemma 4 1
study the effect
theorem 2 1
number of messages
h k v
message transmission delays
independent r v
number of computational
variables with mean
show that adding
v 2 v
path in h
proof of part
theorem 3 8
k 1 v
distributed with mean
class of distributions
networks with different
upper and lower

corpus/krapavin2000-test/631040.txt
keir
lemur
apple
maria
versions
sloth
subversions
orange
subversion
file
rcs
files
vanilla
modules
french
odin
belgian
adele
module
configuration
software
lkm
variants
fred
russian
mouse
variant
graphics
principle
sccs
string
montagunix
bulgarian
import
makefiles
numeric
trunk
join
worlds
japanese
revision
substructure
vm
configure
manager
lisp
prog
comp
makefile
dsee
uselist
gandalf
jasmine
create
command
refinement
subcomponent
montague
intensional
builds
relevant
mm
associative
interface
programmers
noninterfering
joins
unix
correction
unwieldy
versioning
recompilation
proc
dictionary
label
english
controlling
uncommon
families
differing
branches
world
users
axioms
philosophical
toolset
names
development
illusion
hypertext
component
integrated
compromise
applicative
reusability
inequalities
algebra
evolved
object
meaning
ancestors
lattice
packages
significance
compiler
merged
hierarchically
releases
ambiguity
inherit
programs
canonical
simplest
shape
subsystems
reusable
configurations
environments
contraction
compatible
requested
merging
incomparable
protection
cooperation
ideas
labels
brobdingnagian
ands
recuperation
employer
autoload
rcsmyampersandmdash
giants
superversion
plaice
marmoset
lustre
brobdingnag
katakana
hiragana
pioneer
gulliver
horrendously
forks
modeller
francophone
transliteration
blanca
subver
arabic
juggling
bootstrapped
recombining
popshop
boggling
syrian
mancilla
kassios
papaspyrou
bugfix
kanji
glu
intensionalizing
dzhon
anterior
sprout
directory
looks
infinite
extensible
commutative
fast
language
organizing
inheritance
visit
merge
imagine
smart
accords
stipulating
indiscriminately
maxi
fifteenth
versioned
mysterious
scopes
logi
menus
paradoxical
brother
hitherto
marriage
everything
asks
operator
rejected
varies
keir apple
maria orange
fast version
version control
apple version
o file
relevant version
version language
apple fast
complete system
structure principle
version names
orange version
version v
vanilla version
variant structure
orange keir
version space
possible world
software configuration
different versions
software development
desired version
graphics mouse
complete systems
o files
least upper
string correction
refinement relation
every file
version 1
one version
configuration manager
variant substructure
appropriate version
substructure principle
development control
join versions
numeric versions
maria version
revision control
relevant versions
y version
files involved
software configurations
engineering environment
every component
c programs
canonical form
control based
general version
software engineering
would allow
component c
would want
different components
noninterfering versions
compromise version
versions becomes
maria keir
version variables
third version
formally presents
proc keir
prog o
software environments
true lemur
versions would
integrating noninterfering
applicative data
different programmers
version would
odin 3
component files
russian bulgarian
smart recompilation
possible versions
software databases
version instead
french version
system modelling
version requested
vanilla one
apple keir
fast subversion
version name
unix tool
version lemur
one prefer
local significance
version labels
configuration systems
intensional logic
version algebra
dictionary order
block moves
maria orange version
keir apple version
orange keir apple
maria orange keir
variant structure principle
least upper bound
version of component
keir apple fast
string to string
families of software
variant substructure principle
software engineering environment
development control based
software development control
versions of components
versions of complete
concept of variant
version of every
version 1 2
suppose for example
used to create
example one could
representation of families
relevant to v
set of versions
based on system
proc keir apple
base of programs
user interface would
file proc keir
relation between versions
using the variant
apple and maria
version and configuration
toolset for engineering
keir s apple
available are keir
notion of version
shape 13 14
software system modelling
general version possible
exists in versions
maria and keir
version most relevant
based on module
joins of versions
x y version
efficient applicative data
require that every
created to accept
managing reusable software
vm and lkm
approach to version
upper bound operator
problem with block
use version v
hierarchically structured entities
notion of versions
labels the o
manager for extensible
large software development
applicative data types
extension and contraction
infinite precision arithmetic
follows the principle
technique and string
lemur to test
ease of extension
configuration management systems
software configuration systems
engineering software configurations
system modelling facility
integrating noninterfering versions
principle of x4
extensible software environments

corpus/krapavin2000-test/608175.txt
bmd
sov
bmds
fulladder
substitution
circuit
nonterminal
adder
terminal
multipliers
jf
subst
multiplier
backward
wallace
diagrams
substitute
bits
verification
calls
multiplication
substituted
gates
moment
mult
cells
circuits
topological
lambdab
word
gate
cut
labeled
substituting
arithmetic
successor
successors
boolean
su
xm
reverse
substitutions
ca
hsis
aand
edge
product
combinational
recursive
unsigned
node
md
multiplicative
outputs
ast
costs
vlsi
bdds
additionally
partial
verifying
cir
carry
primary
integer
pointing
products
binary
subsection
polynomially
inputs
crossing
rema
theorema
fullad
mediately
fulladders
phdd
hamaguchi
boole
makenode
dividers
automatical
subtraction
forming
vertices
moved
ends
depth
processed
bit
weight
diagram
predecessor
reaches
cuit
substitu
representations
realization
specifications
weights
outgoing
encoding
verified
fa
figured
oneself
handed
ladder
cuits
mtbdds
vertex
bounded
dfg
watching
prematurely
orders
lemma
phi
final
simplifies
multipli
theo
totally
feasibility
summing
bdd
testable
intermediate
incoming
synthesis
onto
ful
superfluous
destroyed
decision
suggestion
argu
thermore
ally
formal
sure
downward
stant
manipulation
constructing
named
diagonal
ago
adds
interrupt
feasible
unchanged
destroy
dag
middle
symbolic
shannon
visualized
spectively
errors
hybrid
mo
divisor
overcoming
add
representatives
decomposes
tree
continually
attain
fur
analyzed
proves
maximally
considerably
breadth
specification
polynomial
extracts
composition
resolving
sizes
afterwards
logic
der
orderings
analyze
please
calculates
nally
partial product
product bits
backward construction
initial partial
variable order
sov structure
adder part
bmd f
binary moment
o jf
terminal node
moment diagrams
fulladder cells
wallace tree
high edge
topological order
reverse topological
high successor
like multipliers
subst calls
input word
nonterminal node
recursive subst
resulting bmd
substitute algorithm
substitution process
f 0
variable x
arithmetic circuits
low path
l xm
bmd constructed
partial products
chosen reverse
carry output
product bit
add calls
tree like
o n
b j
jf 0
word sizes
decision diagrams
node x
execution steps
lemma 4
linear moment
final bmd
b variables
lambdab md
construction applied
multiplier circuit
verifying arithmetic
bmd representing
multiplicative binary
x variables
arithmetic functions
theorem 4
time independent
x k
node labeled
substituting x
variable orders
integer multiplication
recursive calls
word level
terminal vertices
one nonterminal
primary inputs
algorithm calls
level specifications
formal verification
jf j
upper part
boolean variables
give classes
phase lines
high f
time vlsi
named low
variables denote
aand b
hybrid decision
bmd 2
products bits
low x
moment diagram
unchanged otherwise
unsigned integer
mult ends
high successors
v labeled
intermediate bmds
terminal value
specific multiplier
diagonal line
starting bmd
b variable
weighted variables
ends immediately
partial product bits
initial partial product
verification by backward
binary moment diagrams
wallace tree like
reverse topological order
class of wallace
tree like multipliers
bounded by o
sum and carry
bmd in sov
recursive subst calls
substitution of x
method of verification
respect to time
constructing the bmd
jf 0 j
chosen reverse topological
method of backward
input word sizes
j by ca
partial product bit
low and high
respect to space
lemma 4 1
number of execution
verification of arithmetic
o n 2
x l xm
bmd f 0
backward construction applied
substitution is bounded
verification of multipliers
call to mult
multiplicative binary moment
o jf 0
calls to add
o n 4
one nonterminal node
k x l
size of f
x k x
non terminal node
circuits with binary
node with value
reaches its final
substitution of node
diagrams for verifying
structure of f
space and o
multipliers is bounded
delta b j
verifying arithmetic circuits
remains unchanged otherwise
starting bmd f
su and x
substitute the variables
functions over boolean
terminal high successor

corpus/krapavin2000-test/1007767.txt
mst
clustering
agglomerative
gammaffi
clusters
proximity
subquadratic
nns
sparse
cluster
furthest
afn
approximate
ffl
delta
gp
marked
nearest
yao
entry
alta
vista
jp
distance
ffi
euclidean
logn
spanning
iteration
neighbors
tables
sollin
lindenstrauss
closest
ann
entries
neighbor
placed
jth
quadratic
partitions
peleg
union
awerbuch
distances
dimension
retrieves
gammaffl
eppstein
sphericity
oh
mark
ball
naive
witness
hides
partition
broder
edges
gammafi
retrievals
randomized
initialize
linkage
chazelle
dist
probability
big
log
gammad
kleinberg
tm
recognition
geometry
johnson
claim
joined
spaces
centroids
retrieving
biology
ir
diameter
bad
forest
phase
representatives
repeat
engine
mining
ingredient
search
radius
theoretic
breadth
kn
connecting
thest
saks
duing
multilication
cowen
mumspanning
spannning
diamater
decrete
manasse
glassman
hiearchical
oher
minimumspanning
cording
truncated
therein
approximation
web
disjoint
tradeoffs
geometric
handbook
fi
fragments
decomposing
weighted
tering
pens
relatives
afore
kushilevitz
imprecisely
sionality
zweig
xng
closet
appoximation
multigraph
happens
retrieval
history
grows
formulations
lemma
graphs
epsi
diameters
tours
motwani
bles
hierachical
connected
event
status
classification
taxonomies
linial
recogni
indyk
delete
contained
retrieved
grow
statis
berger
plications
unweighted
clus
andrei
jects
hierarchical
connect
returns
dimensional
sketch
gammai
salesman
communica
centered
prob
shrinks
polylog
resorting
mini
ta
eliminating
loop
incorrect
approximating
reduction
curse
implemen
addi
settle
heuristic
dimen
lewis
tice
agglomerative clustering
proximity tables
sparse partitions
n ffi
proximity table
b x
approximate nearest
gammaffi proximity
gp delta
marked 1
mst clustering
x r
f j
sparse partition
approximate mst
jth iteration
log n
closest pair
nearest neighbor
o d
union find
furthest pair
ffl afn
ffl approximate
marked 0
ffl ann
o logn
connected components
neighbor search
e d
high probability
clustering algorithm
alta vista
minimum spanning
ffl r
union operations
n points
dimensional spaces
naive approach
clustering problems
partition clustering
subquadratic time
approximate nns
mst algorithm
vista tm
delta proximity
big oh
approximate delta
delta ffl
graph gp
afn table
ann ffl
ir d
f 0
spanning tree
high dimensional
x 2
running time
ffl delta
clustering rules
set p
complete graph
clustering algorithms
euclidean space
tree mst
b y
data structure
graph theoretic
time complexity
o log
jp j
pattern recognition
computational geometry
j 2
n ffl
data points
l marked
times initialize
good entries
cluster generated
closest x
dimension grows
clustering rule
p contained
sparse graph
r centered
factor ffl
eppstein 7
neighbor algorithms
r proximity
furthest x
theoretic clustering
jp operations
j gammafi
quadratic behavior
linkage distance
cost induced
randomized implementation
exact nns
bad entry
ae e
kleinberg 14
nns algorithms
per table
yao 19
handle n
compute w
tm search
approximate furthest
b x r
n 1 gammaffi
placed in f
points in b
agglomerative clustering algorithm
x 2 e
points in f
point in p
approximate nearest neighbor
nearest neighbor search
gammaffi proximity tables
f j 2
minimum spanning tree
high dimensional spaces
d which returns
ann ffl afn
b y r
problems in high
approximate delta proximity
graph gp delta
alta vista tm
gp delta ffl
ffl ann ffl
sparse partition clustering
points of f
marked by 0
ffl afn table
ffl approximate delta
computing an approximate
o log n
o d 2
type of clustering
f j 1
d 2 n
time complexity o
pair of points
compute the distance
total running time
properties 1 construct
handle n 1
supporting the following
dimension reduction techniques
sparse graph g
gamma n delta
sketch the idea
induced by retrievals
entry is marked
constant from lemma
graph theoretic clustering
distance between clusters
delta proximity table
ffi and k
approximate closest pair
big oh notation
kn 1 gammaffi
awerbuch and peleg
algorithm of 15
good 0 marked
neighbors an efficient
union x y
d the probability
ae e d
iteration we handle
n ffl 2
r proximity tables
takes t jp
data structure consists
approximation factor ffl
size n ffi
sum where d
compute w h
data structure supporting
jp j gammafi
structure for data
returns a point
definition of sparse
union operations performed
l by 1
operations per table
retrievals of good
sparse partitions algorithm
applications of dynamic
approximate furthest pair
number of union
regions of small
x is placed

corpus/krapavin2000-test/1009192.txt
coloring
colorable
colored
pcp
colors
hardness
chromatic
gadget
vertices
pcps
clique
np
gadgets
color
leaf
inapproximability
cliques
legally
row
rows
khanna
legal
template
templates
ground
vertex
fglss
graphs
safra
zpp
adjacent
children
linial
schematic
hard
resorting
selected
miscolors
pure
wraparound
sudan
spur
root
approximating
reduction
selection
tree
constructions
cover
claim
node
murray
edges
coordinate
max
labs
claimed
proposition
hill
bell
receive
sketch
sat
degree
approximate
enforce
urer
timetable
hxyzi
petrank
upenn
ambitiously
pigeonhole
combinatorica
fpcp
iler
madhu
imply
enforces
email
comprises
highlights
connection
lcs
snp
sanjeev
feige
kilian
upshot
partite
enforcing
turing
ask
relying
gap
induce
pp
layered
qualitative
kh
hardwire
venkat
lund
garey
astad
edge
longest
fraction
instances
greedy
semidefinite
goldreich
definiteness
assign
leaves
bits
strong
lemma
prevents
labels
cis
colorings
codeword
aspect
optimum
covering
nodes
checkable
arguing
edu
yannakakis
lth
gramming
sketches
familiarity
sr
bellare
concreteness
gets
permutation
reducibility
labeled
intricate
blum
epsilon
grid
viz
quantifiers
ago
strengthening
completeness
copy
decades
injection
across
distinguish
insert
began
reversal
comput
artifact
internal
colored 3
pcp theorem
colorable graphs
chromatic number
independent set
graph coloring
np hard
hardness result
graph h
third row
leaf level
colorable graph
colored 2
ground vertices
level gadget
colored 1
coloring 3
graph g
color 4
colored 4
r cliques
colored using
tree structures
inapproximability results
max clique
pcp constructions
legally color
graph using
three colors
degree bounded
hardness results
three rows
leaf node
gadget shown
level gadgets
receive color
pcp techniques
selected leaf
basic template
approximate graph
h basic
legal 4
clique r
colors 1
gets colored
g 0
theorem 1
np 6
every constant
node correspond
cliques r
legal coloring
lemma 2
g r
least r
constant h
least one
k vertices
like structures
general graphs
bounded degree
constant 0
approximate within
connection pattern
good covering
range c
vertex colored
number g
khanna linial
assign colors
kind 2
enforcing selection
general 3
require pcps
free bits
strong hardness
receives color
corresponding templates
chromatic numbers
hardness bound
colored either
side node
different rows
vertices h122i
coloring of h
leaf level gadget
colored 3 1
coloring 3 colorable
v i p
l and r
hard to color
colorable graph using
r is pure
hard to approximate
within a factor
legal 4 coloring
coloring a graph
colored 3 2
receive color 4
r in g
node is selected
form of pcp
r cliques r
leaf level gadgets
rows are colored
approximate graph coloring
set of size
given a graph
vertices of g
must be colored
vertices in h
must be selected
cannot be colored
hard to distinguish
color a 3
proposition 3 1
p is selected
tree like structures
adjacent in g
number of g
number of colors
proof of theorem
v in g
number of vertices
templates as f1
interpreted as selecting
labs murray hill
result for coloring
assumption np 6
partitioned into r
coloring a 3
highlights a qualitative
adjacent to h211i
result of 19
linial and safra
strong hardness results
exactly k vertices
approximate the chromatic
hardness of 4
reading from left
three ground vertices
uniform h hardness
colors 1 2
hard to legally

corpus/krapavin2000-test/628124.txt
triplets
lre
triplet
training
colin
aunt
vectors
learning
hinton
family
learn
matrices
modular
goodness
learned
gradient
person
conjugate
concepts
units
giannina
aunts
charlotte
italian
people
modied
dots
relational
ascent
english
pietro
multiplication
principal
hidden
mariemma
dimensions
eq
neural
answers
layer
trained
scaled
rst
squared
discriminative
gure
christopher
specied
tried
dynamics
margaret
iterations
temperature
embedding
kr
penelope
aurelio
nephew
giulio
jennifer
alberto
father
dynamical
correctly
sibling
recurrent
christine
answer
spouse
annealed
brother
representations
tree
relations
rotation
lsa
omitted
concept
matrix
camera
spiral
married
degrees
son
semantic
stars
met
omitting
pca
coded
nipote
pollack
uncle
niece
nephews
diering
grazia
autoencoder
roweis
landauer
nationality
doralice
zii
pose
backpropagation
word
dierent
persons
errors
nd
nds
andrew
freedom
females
raam
dayan
got
intensity
noise
diagrams
exp
arriving
randomly
encoding
latent
images
victoria
penultimate
males
anticipates
marcello
wife
convergence
activity
sensible
parents
maximizing
optimizing
generalization
unobserved
sign
crosses
linearity
weights
multiplying
families
exponents
xed
hundred
dissimilarity
arthur
limitation
marked
connects
criteria
ought
multilayer
generalizing
distance
encodes
endpoints
converged
origin
specic
regularities
missing
multidimensional
row
maria
isomorphic
correct
sam
solid
generalize
perfect
vector
conguration
motions
separable
discrete
held
trick
family tree
number problem
tree problem
numbers operations
modular number
non modular
multiplication r
goodness function
scaled conjugate
linear relational
relational embedding
triplet c
r c
concept vectors
principal components
conjugate gradient
using scaled
hinton 1986
eq 3
hidden state
semantic features
operations f
convergence criteria
triplets randomly
distributed representations
correct answer
squared distance
linear dynamical
training set
algorithm met
english people
tree task
correct answers
vectors obtained
third term
person belongs
solution shown
dimensions lre
second layer
output model
relation aunt
gradient ascent
data set
number 10
intensity images
using gradient
randomly chosen
new matrix
input units
binary relations
output units
b c
learned distributed
operations 0g
correctly complete
line connects
vector endpoints
ones representing
colin aunt
learning distributed
discriminative goodness
modied goodness
distributed encoding
correctly completed
obtained optimizing
exp kr
multidimensional scaling
using lre
local encoding
hidden space
units learned
number problems
threshold distance
lre could
relational term
representing consecutive
two dimensions
components number
recurrent neural
dynamical systems
consecutive numbers
new concepts
components analysis
data consists
generalization performance
family tree problem
c a c
modular number problem
problem with numbers
scaled conjugate gradient
linear relational embedding
multiplication r c
using scaled conjugate
concepts and relations
non modular number
operations f 1
number of triplets
triplets randomly chosen
met the convergence
numbers operations f
family tree task
using gradient ascent
vectors and matrices
number of principal
triplets were used
allowed to learn
shown in g
eq 3 using
lre was able
obtained after learning
linear dynamical systems
used for training
representations of concepts
optimization algorithm met
function eq 3
solid line connects
numbers the dots
modied goodness function
probability of arriving
marked with stars
solution was obtained
able to nd
encoding of relation
principal components number
connects the ones
lines were obtained
units learned distributed
ascent to optimize
optimize the modied
encoding of person
goodness function eq
matrices and vectors
optimizing the goodness
discriminative goodness function
representing consecutive numbers
learned distributed encoding
result of multiplying
minimize the squared
numbers operations 0g
endpoints are marked
ones representing consecutive
operation is outside
learning distributed representations
rst two terms
f 1 1
learn a new
vs the number
modied to include
able to learn
principal components analysis
shown in gure
latent semantic analysis

corpus/krapavin2000-test/627982.txt
generalizability
subdomains
baseline
learning
hypotheses
credit
pwin
timberwolf
subdomain
hypothesis
generalization
anomalies
normalization
temperature
normalized
win
training
learner
intensive
learned
assignment
vc
pac
concept
circuits
median
breadth
explanation
teacher
benchmarks
variance
sample
across
genetics
temporal
orderings
feedforward
statistically
pw
population
apportioning
statistical
placement
neural
default
genetic
feedback
reinforcement
ordering
samples
acceptance
ratios
measures
heuristics
sa
haussler
normalize
circuit
seed
aggregated
concepts
decision
routing
categorizes
mappings
seeds
subspace
quality
signals
probabilities
entails
stimuli
chervonenkis
improvement
degradations
vapnik
speedups
strategies
finishing
driven
brigade
operationality
classifier
dimension
package
learnability
decisions
learn
vlsi
symmetric
trained
theoretic
changed
lean
anns
mitchell
feedbacks
baum
fitness
generalized
artificial
geometric
testing
estimation
depth
annealing
incorrectly
averaged
cpu
learnable
dichotomy
inductive
meant
aggregate
classify
freedom
benchmark
markovian
ratio
sigmoidal
anomalous
medians
consistent
units
ten
infinity
evaluate
tested
raw
generalizing
realizable
discrimination
tendency
generalizations
rules
rank
signal
happen
systematic
schedules
worse
silicon
ffl
tests
ann
attributes
speedup
evaluating
generalize
partitioning
asymptotically
confidence
structural
subspaces
bucket
rule
hidden
improvements
prob
search
backer
dichotomization
devia
subexponentially
subvector
encyclopaedia
blumer
gammadistributed
incumbent
indus
waterman
regressing
quate
erated
limiter
mcnc
ade
eralizability
harmonic
student
ranges
likelihood
guided
cell
distributions
negative
mean
probability
measuring
modifies
respond
past
classified
credit assignment
performance values
parameter set
baseline hypothesis
across subdomains
h 0
fast n
median performance
explanation based
improvement ratio
test cases
symmetric improvement
normalized performance
generalizability measures
improvement ratios
average normalized
vc dimension
generalized parameter
problem space
learned concept
temporal credit
normalization methods
performance ordering
generalization strategies
default parameter
sample mean
data intensive
based learning
intensive methods
domain knowledge
decision theoretic
training examples
learning algorithm
evaluate generalizability
feedback signals
genetics based
random seed
rule space
breadth first
test case
geometric mean
new parameter
knowledge intensive
one hypothesis
depth first
goal concept
subdomain j
different subdomains
concept class
training example
negative examples
first search
performance across
different ranges
acceptance region
loss function
data driven
learning example
genetic algorithms
hypothesis h
two hypotheses
parameter sets
version space
concept learning
approximately correct
learner categorizes
ordering may
temporal scope
general hypothesis
finishing point
mean performance
performance normalization
multiple circuits
cell placement
examples needed
temperature finishing
different normalization
temperature schedules
three benchmarks
called probability
generalizability across
feedback signal
generalization procedure
mitchell 25
measuring generalizability
four computers
example incorrectly
average symmetric
class c
neural networks
performance measures
hypothesis testing
estimation error
may depend
performance value
population mean
classifier systems
generalization problem
o bound
generalization based
aggregate performance
best hypothesis
algorithm l
positive training
normalization method
instance space
parameter values
statistical methods
average performance
valid generalization
different ordering
better than h
learning and generalization
hypothesis is better
anomalies in performance
probabilities of win
baseline is changed
generalized parameter set
temporal credit assignment
default parameter set
placement and routing
probability of win
symmetric improvement ratio
pwin of h
explanation based learning
performance is normalized
performance with respect
concept class c
hypothesis h 0
number of samples
may be difficult
positive training examples
generalizability across subdomains
baseline hypothesis h
performance across subdomains
knowledge intensive methods
average normalized performance
temperature finishing point
genetics based learning
approaches in generalization
whether a hypothesis
instance in evaluating
categorizes a learning
learning algorithm l
data intensive methods
rely on domain
learning example incorrectly
across all subdomains
symmetric improvement ratios
methods to evaluate
baseline for normalization
n of 10
used to evaluate
quality and cost
performance of h
positive and negative
zero and one
breadth first search
depth first search
artificial neural networks
decision theoretic techniques
one performance measure
achieved generalizability measures
generalization and generalizability
form z 0
sa will run
function 1 0
values places another
credit assignment entails
define a problem
values of hypotheses
solutions in measuring
learned concept may
vc dimension named
attributes to classify
ffl we assume
data driven generalization
normalized speedups using

corpus/krapavin2000-test/628066.txt
itemsets
frequent
tid
itemset
clique
eclat
lattice
maxclique
mining
maxeclat
atoms
prex
association
actw
apriori
cliques
maximal
aprclique
topdown
database
intersections
lattices
infrequent
items
acw
pseudo
scans
equivalence
acdtw
hybrid
item
transaction
acd
aw
acdt
acdw
atw
bottom
enumerates
ecient
atom
ac
adt
partition
lists
semilattice
intersecting
discovery
ad
pruning
subsets
condent
powerset
bookstore
cdw
rst
hash
join
search
sub
goethals
enumerated
condence
vertical
act
scan
dierent
datasets
cd
bart
denition
cdt
candidates
databases
karypis
enumeration
ct
enumerating
classes
lexicographic
horizontal
sublattice
layout
longest
rules
counts
induced
decomposition
scanned
identier
covering
doesn
zaki
skew
partitions
breadth
eciently
specied
min
ctw
michihiro
purdom
toon
yudho
adtw
kuramochi
sucahyo
gopalan
calders
dtw
bierstone
cliqlist
giri
sup
discovering
top
gure
mohammed
exive
candidate
enumerate
books
sec
tids
freq
dlg
hcmac
austen
mukund
gucht
boolean
george
buy
memory
intersection
cw
raj
sublattices
customer
sigkdd
conf
intersect
deshpande
sampling
meet
customers
identied
counting
dense
dirk
cov
jrj
newsletter
outperform
lemma
cardinality
format
wg
inversion
circles
locally
list
suer
globally
discovered
jane
dong
bought
deng
explorations
lowered
identies
signicant
fewer
benets
phase
distributive
quickly
nding
usage
density
personalized
australasian
frequent itemsets
tid list
maximal clique
tid lists
clique based
frequent itemset
maximal frequent
hybrid search
sub lattices
maximal cliques
sub lattice
prex based
new algorithms
association rules
pseudo equivalence
eclat clique
equivalence relation
association graph
clique maxeclat
database scans
transaction size
smaller classes
boolean lattice
topdown eclat
minimum support
list intersections
support partition3
aprclique topdown
relation k
relation 1
main memory
sec minimum
frequent items
association mining
powerset lattice
act acd
lattice p
locally frequent
covering set
class x
data mining
based pseudo
minimal infrequent
intermediate tid
clique generation
k association
pseudo class
frequent 2
equivalence class
equivalence classes
time sec
edge density
increasing transaction
min sup
pseudo code
hash tree
top element
search space
maxeclat maxclique
length prex
itemsets figure
horizontal database
algorithms scale
itemset mining
based equivalence
maxclique figure
uses maximal
hybrid phase
adt atw
long itemsets
acw adt
min support
longest frequent
maximal itemsets
acdw acdt
vertical tid
non maximal
reverse lexicographic
maximal elements
previous level
mining association
database scan
potentially frequent
fast discovery
support counting
bart goethals
support values
user specied
mining task
lexicographic order
dierent algorithms
george karypis
breadth rst
two itemsets
infrequent itemset
itemset search
ct cd
k subset
bottom up search
maximal clique based
maximal frequent itemsets
pseudo equivalence relation
top down search
eclat clique maxeclat
equivalence relation 1
number of frequent
topdown eclat clique
apriori and partition
bottom up phase
minimum support partition3
aprclique topdown eclat
sec minimum support
time sec minimum
based pseudo equivalence
tid list intersections
support partition3 aprclique
intersecting the tid
clique based pseudo
set of atoms
number of transactions
frequent 2 itemsets
increasing transaction size
d t w
relation 1 along
k association graph
search it enumerates
equivalence relation k
set of frequent
number of database
set of items
mining association rules
longest frequent itemset
based equivalence relation
intermediate tid lists
prex based equivalence
reverse lexicographic order
locally frequent itemsets
w a c
acw adt atw
powerset lattice p
uses maximal clique
maxeclat maxclique figure
clique maxeclat maxclique
l is called
number of intersections
implies that u
element of p
x 2 p
smaller sub lattices
association mining task
independently in main
non maximal ones
ad at aw
computing f 2
frequent itemsets figure
acdtw cdt act
acdw acdt acdtw
atw acdw acdt
vertical tid list
adt atw acdw
r min sup
frequent itemsets within
exive x x
association graph increases
support 0 25
cdt act acd
item tid lists
long maximal frequent
cd at ad
relation is exive
w ct cd
within each sub
ad acw adt
frequent itemset mining
class x induced
acdt acdtw cdt
enumerates all frequent
enumerates the long
min support 0
engineering v 17
data engineering v
knowledge and data

corpus/krapavin2000-test/1018355.txt
ow
prf
cut
orphans
energy
potts
dinic
segmentation
vision
adoption
saturated
greig
restoration
sink
relabel
pixels
stereo
augmenting
image
parent
residual
bell
stage
seeds
push
augmentation
orphan
cuts
max
passive
terminals
combinatorial
3d
growth
min
minimization
labels
forest
liver
voxels
diamond
capacities
lung
goldberg
tests
africa
graphs
augmentations
fulkerson
energies
quad
images
2d
children
occlusions
edges
active
labelings
interactions
neighboring
edge
labeling
shortest
mr
parents
ford
photo
nd
interaction
pixel
signicantly
darbon
bangay
sigelle
jrme
rst
df
disparity
neighbors
paths
diversify
shaun
penalties
terminates
dierent
pushing
town
cape
terminal
source
augments
cardiac
segmentations
style
complexities
grow
mrf
saturates
jcj
acquire
flow
layers
tree
intensities
camera
nodes
penalty
publications
roots
nite
visualisation
invariants
occluded
reality
outperformed
links
reconstruction
minimized
segment
recognition
marc
restored
connect
label
fastest
originate
conguration
nj
ct
head
optimization
posterior
annealing
remained
breadth
michikawa
sri
livewire
ajit
grabcut
morkel
fhp
funka
chantelle
gool
bellquad
satu
qiong
zhongfu
fujimori
hiromasa
cherkassky
gpu
geys
indra
levelable
south
mn
editing
barbara
santa
augmented
scratch
pentium
gupta
imaging
medical
xiaoou
reuses
tarjan
zabih
recomputes
plugin
gimp
lv
diwan
ichiro
tomoyuki
tsukuba
ramin
veksler
gelautz
bleyer
imum
lobb
cut max
min cut
max ow
ow algorithms
h prf
adoption stage
non saturated
energy minimization
potts energy
push relabel
image restoration
q prf
growth stage
maximum ow
combinatorial optimization
search tree
graph cuts
active nodes
residual graph
greig et
augmenting paths
minimization methods
new parent
p q
free nodes
minimum cut
bell quad
dinic algorithm
energy 1
augmenting path
saturated edge
linear interactions
graph based
experimental tests
standard algorithms
max flow
graph cut
computer vision
tree pair
saturated edges
segmentation examples
stage terminates
head pair
ow algorithm
q 2n
parent q
interactions energy
augmentation stage
random pair
new algorithm
flow algorithms
edge p
neighboring pixels
active node
two terminals
based energy
via graph
g f
al 10
graph g
node p
new min
3d segmentation
camera stereo
style push
passive nodes
residual capacities
cost cut
acquire new
valid parent
running times
image segmentation
new children
edge q
n links
edge weights
ow problems
left image
object segmentation
minimum cost
two labels
path algorithm
graph structures
algorithms based
vision v
cardiac mr
relabel method
orphans o
q add
links connect
interaction penalties
cut algorithms
restoration stereo
reality visualisation
nodes acquire
ow techniques
orphans may
style augmenting
interactive graph
problem exact
vision graphs
variation part
multi camera
two terminal
consider image
standard min
research nj
reality 17
segmentation technique
relabel algorithms
min cut max
cut max ow
max ow algorithms
greig et al
energy minimization methods
number of labels
residual graph g
graph based energy
non saturated edge
linear interactions energy
non saturated edges
p q 2n
max ow algorithm
based energy minimization
cut max flow
edge p q
graph g f
set of free
pairs of neighboring
seeds were placed
methods in vision
prf and q
max flow algorithms
new min cut
new parent q
max ow problems
graph based methods
edge q p
algorithms of combinatorial
cut and max
minimum cost cut
node p 2
acquire new children
style push relabel
applications in vision
nd a new
via graph cuts
et al 10
algorithms on graphs
used to minimize
number of augmentations
style augmenting paths
jrme darbon marc
technique in 3
virtual reality visualisation
visualisation and interaction
two algorithms work
marc sigelle image
relabel algorithm 9
push relabel algorithm
growth stage terminates
push relabel algorithms
algorithms on 2d
graphs in vision
prf and dinic
augmenting path algorithm
2d or 3d
sigelle image restoration
based on augmenting
image of random
restoration with discrete
fulkerson style augmenting
push relabel method
discrete constrained total
edges p q
forest the source
sink is found
based on ford
shortest augmenting path
saturated edge p
vision in section
along non saturated
consider image restoration
stereo and segmentation
image restoration stereo
ford fulkerson style
interactive graph cuts
total variation part
max ow techniques
including the results
constrained total variation
v p q
work consistently better

corpus/krapavin2000-test/635014.txt
semiring
scsp
csps
concrete
abstraction
semirings
sol
galois
soft
abstract
idempotent
scsps
fuzzy
abstractions
concretization
abstracting
satisfaction
preserving
tuple
subtuples
monotonicity
lattice
reals
constraint
coni
tuples
insertion
denition
lattices
naturals
nd
glb
classical
abstracted
hdef
csp
dene
ti
safe
inconsistencies
multiplicative
dened
opt
consistency
clp
dierent
solutions
optimum
intensive
propagation
bring
insertions
formalizations
nding
bistarelli
monotone
ordering
anything
con
valued
safeness
prade
pl
constraints
possibilistic
vs
ha
ordered
didier
rst
maximize
additive
incomparable
easier
opposite
species
idempotence
dubois
multiplying
fd
commutative
preference
gure
coincide
henri
absorbing
locally
branch
onto
correctness
lowering
stefano
map
associative
composition
notice
closer
fig
hints
min
costs
arc
passing
hn
frameworks
combining
semantics
family
simplied
element
topology
reformulation
maps
combine
concerns
interpretation
partial
souhila
bonchi
extensivity
benferhat
timetabling
ellman
intensiveness
giampaolo
interchangeability
myampersandrdquo
semir
abscon
surjectivity
fcsp
ordeing
bella
bipolar
tosca
approximating
expressive
transitivity
theorems
fusion
worse
dening
preservation
def
relate
brings
counterparts
formalization
adjoints
kaci
absurd
analyis
combina
approximation
obtaining
proposals
compiling
satised
arrows
associating
correct
hc
upgrading
duced
interchangeable
notion
shorter
artificial
says
intelligence
uncertainty
recalled
hpl
giunchiglia
posets
intro
myampersandldquo
fausto
disregarded
guiding
monotonic
integers
want
coincides
notions
probabilities
formalism
think
domain
relationship
order preserving
concrete problem
scsp problem
soft constraint
galois insertion
abstract problem
sol p
optimal solution
v 0
problem p
constraint satisfaction
semiring values
f sol
optimal solutions
concrete semiring
semiring value
soft constraints
classical csps
abstraction scheme
constraint problems
solution correct
preserving property
valued csps
f p
abstraction function
concretization function
new problem
abstract problems
abstract semiring
locally correct
value v
satisfaction problems
local consistency
abstract one
concrete problems
constraint problem
abstract domain
semiring element
concrete side
concrete scsp
fuzzy semiring
multiplicative operation
scsp p
abstracted version
partial order
function maps
abstract interpretation
semiring based
fuzzy csps
abstract side
abstracting soft
solution correctness
hdef coni
galois insertions
c semiring
local correctness
safe solution
ti property
concrete lattice
bring back
two semirings
concrete domain
value 0
p 0
see theorem
two abstract
positive reals
two lattices
opt p
domain values
abstract scsp
fuzzy csp
two us
concrete ordering
concrete one
n csps
abstraction framework
v sol
soft csps
fuzzy n
problems concrete
abstraction changes
preserving abstraction
property says
problem say
negative reals
function f
c v
value greater
given an scsp
scsp problem p
solution of p
v s v
solution with value
order preserving property
f sol p
soft constraint problem
soft constraint problems
constraint satisfaction problems
v 0 v
nd an optimal
theory of abstraction
notion of abstraction
obtained by combining
correct and intensive
safe solution correct
easier to solve
f on p
f is safe
p is smaller
consider a function
v 0 2
constraint of p
v in p
greater than 0
smaller than 0
local consistency algorithm
problem p 0
order preserving abstraction
family of abstractions
locally correct w
abstract problems concrete
problems concrete problems
take any tuple
p with value
f is solution
maximize the minimum
abstract problem say
tuple of domain
csps this abstraction
tuples of values
optimum of p

corpus/krapavin2000-test/627680.txt
magic
auxiliary
ff
pasttl
fol
sql
evaluable
formula
dbms
temporal
allgen
starburst
formulas
integrity
fv
ranf
subformulas
commit
ingres
atoms
atom
subformula
toman
chomicki
relational
database
conversion
tables
rematerialization
simplified
transition
constraint
sideways
polyadic
rules
algebra
converted
enforcement
active
transaction
delete
rule
create
relations
rematerialized
insert
precedes
connective
oe
contents
convert
attribs
transformation
approx
quantifier
translation
safe
dml
fi
attributes
history
logic
agrees
quantifiers
tinserted
sips
tdeleted
old
triggered
generator
compiler
inserted
specification
enforce
occurrence
conjuncts
traverse
transformations
employee
constraints
flow
rollback
disjunctions
language
compilation
leaf
salary
mula
past
module
disjunction
occurrences
views
passed
rejected
ffl
constructors
leaves
tuples
negation
optimizations
implementing
docommit
readmitted
annotated
syntax
materialized
converts
converting
constructor
committing
superscripts
updated
update
reformulations
vi
preserve
statements
checking
top
induction
eval
monitor
adornments
deleted
aborted
ordering
false
algebraic
cleanup
triggers
queries
sub
conjunctions
connectives
arity
execute
clause
restrictions
restricting
inductive
truth
union
overhead
body
rela
conjunction
maintained
optimization
architecture
saving
referenced
gen
references
careful
negations
databases
del
triggering
anomaly
stored
null
join
benchmarking
unsafe
languages
modules
safely
clauses
outcome
ideal
select
tods
query
schema
encoding
violations
contexts
referring
violate
guard
declare
attribute
subsystems
arrangement
agreement
maintain
propagate
r ff
magic condition
auxiliary relations
auxiliary relation
active dbms
create rule
simplified formula
level constraint
relational algebra
fol formula
temporal integrity
integrity constraints
top level
transition tables
fol formulas
magic conditions
m r
auxiliary atoms
rule generator
pasttl formula
allgen property
transition information
implementing temporal
temporal constraints
auxiliary atom
active rules
constraints using
rule systems
set transformation
toman implementing
evaluable property
execute procedure
sql statements
original formula
ff 1
algorithm 25
r fi
ff 2
algebra normal
create procedure
auxiliary tables
temporal logic
magic set
relation r
rule system
specification language
create table
state n
free variables
optimization techniques
constraint checking
fv 0
pasttl formulas
auxiliary transition
ff false
overall magic
corollary 29
atom r
input formula
constraint enforcement
temporal constraint
update r
constraint specification
procedure c
original pasttl
evaluation property
additional auxiliary
safe evaluation
precedes c
attributes create
passed sideways
past temporal
rule c
allows easy
rule ff
normal form
rule language
algorithm 16
space overhead
formula f
given formula
first order
ff oe
general architecture
constraint c
top level constraint
m r ff
flow of time
temporal integrity constraints
integrity constraints using
implementing temporal integrity
occurrence of r
r ff 1
condition for r
using an active
insert into r
auxiliary relation r
r ff 2
toman implementing temporal
chomicki and toman
magic set transformation
relation r ff
algebra normal form
relational algebra normal
true in d
overall magic condition
atom r ff
auxiliary transition tables
converted to relational
create rule c
occurrences of r
delete from r
update r ff
set of active
let r ff
r 0 ff
create rule ff
formula i e
fv 0 sets
safe evaluation property
fv and fv
n a o
level constraint c
auxiliary atom r
ff 2 insert
preserve the simplified
inserted then delete
past temporal logic
x c g
relations r ff
o and e
tables r ff
maintain the contents
commit then update
original pasttl formula
formula to relational
commit when inserted
active dbms rules
attribs create rule
commit execute procedure
top level fol
constraint specification language
r ff let
restrict the contents
c create rule
formula is converted
relations are introduced
auxiliary relations r
set of fol
propagate the allgen
auxiliary tables r
auxiliary relations introduced

corpus/krapavin2000-test/1005726.txt
bgp
router
ebgp
routes
route
emulator
ibgp
egress
routers
igp
routing
prefixes
learned
import
ingress
traffic
med
configuration
prefix
signaling
ases
prediction
rr
sessions
network
session
policy
hop
outcome
preference
reflector
tables
interdomain
operators
rrs
id
attributes
policies
destination
decision
timescales
renata
rexford
speaking
advertised
sigcomm
module
reflectors
teixeira
selection
predictions
stable
ip
link
isp
protocol
clients
neighboring
peering
path
shortest
paths
engineering
predicts
neighbors
candidate
jennifer
dynamics
simulators
aman
griffin
shaikh
selects
incremental
validation
effects
live
backtracking
locally
phase
confederations
ssfnet
protocols
tunable
select
advertisements
affect
mismatches
fortunately
ids
predicted
loading
day
intradomain
rebalance
ultimately
predict
tier
neighbor
phases
internet
parsed
errors
inconsistencies
decisions
prototype
adjust
advertises
emulating
suddenly
emulates
tasks
costs
eliminates
destinations
advertise
eliminate
deploying
exit
propagate
optimizations
operator
correctly
jacobus
coast
feamster
tiebreaking
uhlig
pray
converge
maintenance
gateway
upgraded
learns
volumes
visiting
prefers
emulate
border
announcing
advertisement
potato
merwe
igps
planned
provider
simulating
snapshot
configurations
modified
excluded
modeling
applies
mesh
stability
divert
outbound
malfunctioning
lund
deci
troubleshooting
flow
manipulate
inputs
interaction
attribute
portland
carsten
envision
subtleties
mauricio
everyday
tweak
resende
oregon
reachability
configured
origin
database
operational
deferring
configure
failures
converges
lowest
loaded
der
oscillation
accurately
congestion
links
emulation
incorrect
best route
ebgp learned
ebgp routes
learned routes
decision process
bgp route
igp path
bgp decision
best ebgp
route selection
router id
bgp routing
network engineering
import policy
route prediction
signaling graph
traffic engineering
network operators
ingress router
ebgp speaking
local preference
speaking router
best routes
import policies
modified routes
routing tables
routes table
prediction algorithm
configuration changes
bgp emulator
learned route
engineering tasks
path costs
egress point
next hop
per prefix
best bgp
egress router
second phase
ebgp sessions
known routes
route reflector
ibgp signaling
locally best
network operator
routes learned
bgp tables
egress points
modeling bgp
candidate routes
third phase
destination prefix
configuration data
configuration change
egress routers
shortest igp
ibgp session
med value
bgp routes
operators need
router y
ibgp sessions
bgp path
make modeling
live network
path selection
routing table
one router
path cost
selection process
ibgp configuration
message ordering
every router
routing protocol
routing protocols
acm sigcomm
first phase
jennifer rexford
link weights
renata teixeira
bgp neighbor
route attributes
without backtracking
origin type
egress set
constraint 3
speaking routers
router ids
router selects
import table
route reflectors
operators must
emulator based
router x
path length
network configuration
running time
route learned
router configuration
protocol dynamics
routing decisions
best egress
total errors
candidate route
bgp session
route among
bgp configuration
rr clients
model bgp
ebgp learned routes
bgp decision process
bgp route selection
set of best
best ebgp routes
ebgp speaking router
igp path costs
ebgp learned route
best bgp route
route prediction algorithm
pair of routers
ibgp signaling graph
network engineering tasks
igp path cost
shortest igp path
locally best route
best ebgp learned
modified routes table
bgp path selection
group of prefixes
model of bgp
modeling bgp route
flow of traffic
path selection process
ebgp speaking routers
make modeling bgp
bgp routing tables
every other router
parsed and loaded
ibgp and igp
affect the flow
route selection process
egress points table
med and router
emulator s running
known routes table
distinct as paths
set of egress
computing the best
tier 1 isp
large tier 1
end to end
computer communication review
sigcomm computer communication
communication review v
acm sigcomm computer
set of ebgp
modified routes tables
network wide bgp
bgp routing decisions
router can affect
select a route
ebgp route learned
configuration changes typically
local preference attribute
best egress router

