corpus/krapavin2000-test/1005058.txt
recommender
vzpro
customer
association
mining
westdb2
genbus
msweb
breese
dependency
recommendations
customers
products
heckerman
sarwar
datasets
item
dataset
profile
commerce
usocs
ratings
recommendation
confidence
items
cosine
similarity
training
collaborative
predictions
erent
karypis
prediction
filtering
purchase
predictive
historical
sql
verizon
correlation
ms
profiles
similarities
product
2000
sparse
1998
rules
clustering
coe
accuracy
di
networks
active
server
sites
rates
ered
communities
overfitting
2001
decline
sparsity
companies
abilities
loyalty
usoc
caller
pearson
null
scores
toy
er
cient
schafer
microsoft
cluster
ect
recommend
voice
bayesian
scoring
service
euclidian
listing
acceptance
predict
scalability
preferences
votes
news
na
mail
clusters
siteseer
ungar
6631
wtn
underfitting
hettich
konstan
unread
crm
charges
grouplens
6465
7736
resulted
online
published
problematic
rate
ave
regression
neighborhood
benchmark
purchases
industries
usenet
personality
kdd
services
ective
id
successes
she
residential
pennock
methodologies
subsection
05
users
recommended
et
clustered
assist
purchased
measures
51
took
bay
scored
assoc
popularity
web
business
prohibitive
score
levels
format
industry
conditional
summaries
deploying
music
marketing
ects
successful
frequent
learning
foster
ciency
poor
uci
archive
editors
basket
rating
methodology
empirical
reported
ers
pd
neighborhoods
telephone
pruning
minutes
personalized
sales
database
probabilistic
telecommunication
depict
discrepancy
quality
rule
1997
wherein
buy
entries
conducted
remarkably
discover
nonzero
network
frequency
successfully
changing
erence
pages
e vzpro
recommender systems
dependency networks
association mining
recommender system
based recommender
vzpro and
item based
the customer
breese et
customer profile
and association
heckerman et
confidence rate
user based
al 2000
dependency network
al 1998
the dependency
server 2000
active customer
collaborative filtering
the active
support level
association rules
sarwar et
the westdb2
active user
et al
al 2001
in breese
correlation coe
sql server
e commerce
commerce sites
a recommender
westdb2 genbus
user item
karypis 2001
customer profiles
the msweb
null predictions
ms sql
di erent
1998 heckerman
msweb dataset
product 29
westdb2 and
vzpro is
time accuracy
item matrix
similarity measure
test data
and product
of e
the association
predictive abilities
support levels
decline rates
accuracy time
product 26
and msweb
and genbus
genbus and
caller id
and customer
top 5
training data
similarity measures
o er
profile and
the predictive
o ered
of recommender
the recommender
the support
systems based
model based
based methods
the prediction
coe cient
datasets respectively
the rules
the confidence
genbus datasets
vzpro the
genbus dataset
basic voice
voice mail
accuracy rates
mail service
ms commerce
non published
purchase data
published listing
products or
westdb2 dataset
user ratings
1998 as
the training
following subsection
the test
in item
of association
and confidence
confidence levels
acceptance and
each product
s correlation
the recommendations
pearson s
test datasets
customer database
recommendations for
dataset e
commerce server
id name
a customer
to predict
2000 and
the rule
rule base
of customers
systems in
the e
mining is
of items
0 05
and cosine
but 1
product a
mining in
of transactions
this study
the items
product b
sparsity of
memory based
service order
items across
recommend products
genbus msweb
the genbus
microsoft 2000
internal verizon
some products
in karypis
confidence rates
product recommendation
benchmark dataset
vzpro performed
5 recommendations
historical purchase
ave number
better predictions
product 51
known recommender
customer a
in sarwar
schafer et
cluster 5
msweb datasets
on westdb2
certain products
mining models
between customer
toy example
based approaches
the historical
networks based
1 protocol
results from
measures are
e ect
bayesian networks
mining on
the user
cient and
he she
in table
the products
customer has
customers and
lower confidence
product 1
level s
of recommendations
accuracy results
of rules
based algorithms
a dependency
products are
are very
machine learning
second phase
user and
rules for
that exist
the similarity
customers in
based recommender systems
e vzpro and
and association mining
breese et al
the dependency networks
vzpro and association
of e vzpro
heckerman et al
et al 2000
et al 1998
the active customer
sarwar et al
the active user
et al 2001
in breese et
item based recommender
a recommender system
e commerce sites
the support level
recommender systems in
sql server 2000
recommender systems based
for the westdb2
correlation coe cient
ms sql server
the customer profile
1998 heckerman et
the msweb dataset
active customer profile
recommender systems are
the user item
user item matrix
the confidence rate
e vzpro is
al 1998 heckerman
to the active
the association rules
that e vzpro
user based methods
association mining is
westdb2 genbus and
active user and
the dependency network
genbus and msweb
in item based
user based recommender
of the dependency
number of rules
systems based on
the following subsection
s correlation coe
caller id name
the top 5
westdb2 and genbus
ms commerce server
dependency networks based
non published listing
id name and
the westdb2 and
accuracy time accuracy
name and number
but 1 protocol
the westdb2 genbus
voice mail service
a dependency network
customer profile and
all but 1
and genbus datasets
al 1998 as
time accuracy time
on the dependency
commerce server 2000
basic voice mail
networks based recommender
dataset e vzpro
dependency networks is
e vzpro the
dependency networks are
the all but
association mining on
association mining in
if the customer
pearson s correlation
number of items
to o er
association rules for
number of transactions
in this study
a similarity measure
coe cient and
between the items
westdb2 genbus msweb
e vzpro performed
on association mining
the predictive abilities
in sarwar et
predictive abilities of
model based methods
05 0 05
the customer has
item based algorithms
relationships that exist
cient and cosine
and dependency networks
in association mining
ave number of
support level s
and msweb datasets
changing the support
support level and
well known recommender
he she will
the westdb2 dataset
in karypis 2001
recommender system should
and confidence rate
of items across
the recommender systems
schafer et al
of each product
well in terms
recommender systems can
in ms sql
top 5 recommendations
historical purchase data
the genbus dataset
introduced in breese
the training data
and 0 1
and the rule
the second phase
user and the
following subsection we
to find the
of the active
number of cases
of association rules
of the clusters
in equations 1
other model based
of the products
in tables 4
tables 4 and
the test datasets
to the customer
based on association
between the active
the acceptance and
of the rules
the test data
the rule base
of the prediction
al 2000 and
when compared to
0 05 0
the model based
equations 1 and
these measures are
and machine learning
from the test
for the active
0 05 and
of the datasets
this type of
two di erent
the rules and
the similarity measure
reported in table
is reported in
have been successfully
used to predict
been successfully used
based on the
similar to the
is provided in
4 21 2
on the westdb2
the accuracy rates
used in item
2001 sarwar et
association mining table
model based recommender
represent the active
acceptance and decline
ungar and foster
for e vzpro
may have di
recommender system based
the prediction join
association mining based
of recommender system
measure of 1
this study and
for the msweb
performed very well
server 2000 and
construct a dependency
proposed in breese
accuracy results from
products recommender systems

corpus/krapavin2000-test/1005395.txt
vel
event
individuals
verb
axioms
events
hh
history
token
nouns
episode
galton
noun
histories
episodes
quantication
davidson
axiom
calculus
temporal
tense
ai
ti
count
propositions
verbs
entities
dierent
realised
denotation
nominal
dene
prog
shoelace
punctual
allen
1984
logic
operators
world
semantics
ontology
shanahan
hayes
logical
tokens
ctl
denable
frame
quantier
arti
sublanguages
ary
expressions
logics
dened
formalism
assigns
sconfp
gclock
formalisms
intensional
ship
mccarthy
expressive
occurrence
observable
s5
subjective
1986
quantied
formulae
modal
tenses
uential
propositional
action
interval
proposition
participation
perf
vocabulary
worlds
john
atomic
1969
girls
relations
semantic
inferences
representations
reasoning
intervals
leg
obey
branching
intertia
kamp
randell
aspect
precedes
causality
tuple
index
dense
uence
truth
tuples
girl
oles
axiomatisation
fluents
vr
moller
wood
denoting
modalities
modality
tie
overlaps
obeys
eat
woman
pros
compound
modelled
specic
denitions
mcdermott
apple
causation
sergot
kowalski
myampersandldquo
language
predicate
talking
president
commonsense
identity
operator
predicates
unifying
picks
universe
settled
specically
substitute
occurrences
static
versatile
characterise
constructs
symbols
denotations
radical
nishes
governing
co
expression
incorporates
employ
suciently
indices
la
abstraction
spatial
accessibility
quantiers
extensional
strips
burns
theories
specied
nonmonotonic
1979
relationships
syntactic
describing
phrase
meets
axiomatic
trans
entity
1997
1980
1992
situation
derivable
analyses
individual
1987
amongst
talk
meanings
combine
meaning
actions
indivindual
accidents
event types
event type
of vel
an event
of individuals
count nouns
event token
count noun
history tree
the event
hh ti
type e
of type
over which
of event
event calculus
situation calculus
index point
vel is
actual history
within vel
time points
and events
frame problem
a verb
of events
a vel
event tokens
index hh
vel frame
holds at
possible world
token of
time point
h t
a assigns
world state
for vel
quantication over
co realised
davidson s
aspect operators
a proposition
true at
non logical
an individual
is true
the logical
logic of
his shoelace
ary verb
the episode
tense and
token variable
event abstraction
a token
n ary
the logic
our semantics
combine with
h up
individuals in
interval over
an episode
time structure
state s
the world
semantics for
logical form
type expressions
a history
s f
the frame
allen s
axiom system
event of
end points
an interval
the actual
the verb
give axioms
mccarthy and
punctual event
occurs relation
vel we
logical symbol
prog e
ai representations
event logic
static relations
individuals at
vel includes
over individuals
tie his
world states
individuals which
galton 1984
john tie
subjective event
trans world
logic vel
further constrained
nominal type
of tense
world identity
vel that
of allen
period over
of action
actual state
of entities
events in
formal semantics
an expression
the history
variable a
events and
dierent ways
are terms
our formalism
of quantier
of wood
any history
temporal relationships
con uence
partial state
hayes 1969
and hayes
he 1
all episodes
individuals that
picks out
maximal consistent
in uential
these individuals
individual concepts
of ctl
verb with
every index
the occurs
in arti
calculus mccarthy
to refer
the semantics
axioms of
language which
the axioms
where is
h i
an occurrence
each index
a count
a tuple
the interval
entities at
logical functions
n tuples
the individuals
sublanguages of
history h
the construct
just about
expressive power
dynamic logic
true just
on event
to regard
assigns an
the situation
assigns a
just in
expressions of
an axiom
time variable
type c
h 0
the expressive
m h
be specied
world we
relative to
and h
types which
event occurs
ary relation
at dierent
of axioms
and event
tree structure
operators and
tuples of
relation is
of occurrence
events we
type t
relation holds
obeys the
that denotes
tuple of
the truth
of type e
an event type
the actual history
is of type
a token of
the frame problem
the event type
index hh ti
a history tree
the logic of
the situation calculus
time and events
a count noun
of event types
event token variable
variable a assigns
a vel frame
at each index
event type expressions
a assigns a
system for vel
tuple of individuals
an event token
of the world
is true at
the event calculus
interval over which
h up to
event of type
that an event
an n ary
just in case
where is of
to the event
an event of
end points of
the actual state
of vel is
calculus mccarthy and
and hayes 1969
at every index
john tie his
of individuals in
the time structure
the count noun
is true just
n ary verb
set of individuals
subjective event types
period over which
variety of dierent
the logical form
mccarthy and hayes
the time points
just about to
tie his shoelace
the occurs relation
history tree structure
trans world identity
ary relation is
which an event
event types which
sublanguages of vel
action and time
m h t
theory of action
of allen s
is just about
punctual event types
over which the
an occurrence of
is the actual
of action and
n ary relation
true just in
axiom system for
the s are
situation calculus mccarthy
the world we
points of the
formal semantics for
to refer to
an event is
the end points
means that is
the expressive power
expressive power of
a function from
a variable of
of type t
of type i
in the actual
to event types
kowalski and sergot
tense and aspect
really abstract concurrent
and aspect operators
type e and
the holds at
individual that is
concurrent model and
kind of quantier
a really abstract
non logical symbol
e g hayes
partial state s
history h 0
calculus kowalski and
event types and
an vel frame
every index point
of vel the
event token can
point of evaluation
be interpreted within
means that denotes
point an n
of n tuples
frame problem and
co realised by
of possible denotations
that denotes an
the history tree
logic of occurrence
denotes the actual
and count nouns
a pair hh
an expression describing
he 1 precedes
and davidson s
an individual is
ary verb 2
about actions and
picked out by
of world states
many ai representations
events we have
g where is
on event types
a complete axiom
terms of conditions
expression h i
world identity criteria
representations can be
power of ctl
of action sentences
of vel it
a general temporal
episode over which
use the form
time period over
the episode over
of all episodes
standard s5 axioms
form prog e
type c and
of tense and
e which says
or is just
kinds of event
at index hh
time intervals over
count noun picks
the same trans
such as ctl
token of l
and sergot 1986
entities at dierent
as predicates over
an index point
verb is associated
standard axioms of
on one leg
event logic vel
are terms of
if is true
stand on one
of direct participation
s are terms
obeys the standard
of events can
temporal ordering relation
event type can
of count nouns
in an vel
logic the frame
token of a
index point an
of vel that
token can be
of a verb
fully formal semantics
tuples of individuals
a verb occurrence
vel is to
a verb with
the form prog
noun picks out
e and is
from indices to

corpus/krapavin2000-test/1005397.txt
animal
car1
anml
ccalc
car2
car
lmw
nextsegment
zoo
mounted
pos
cars
segment
gate
nonexecutable
mount
animals
homer
tra
jumbo
human
varsigma
rider
anml1
road
p1
positiveorientation
sg
car3
formalization
species
riding
sp
causal
cage
action
choosesegment
seg_cd
cages
position
giunchiglia
getoff
willleave
throwoff
world
opened
ds
caused
actions
speed
positions
uent
loc
gates
laws
none
seg_ab
vacated
maxstep
adult
calculator
landscape
modifiedorientation
travelled
seg_bc
side1
cagea
side2
thrown
specication
neighbor
c1
moves
h1
deliberative
inertialfluent
seg_bc1
rides
distance
move
sides
snoopy
quoted
seg
speeds
humans
segments
velocity
constants
node
grounding
ds1
sdfluent
mounts
humanspecies
thielscher
modifieddistance
seg_ac
maxint
gateao
lifschitz
commonsense
closing
occupancy
scenario
leave
silver
mounting
vehicles
accessible
locations
ahead
posi
constraint
roads
spacecraft
traffic
movement
waiting
defeasible
utexas
seg_bc2
henschel
joohyung
startnode
throwo
largespecies
modifiedsegment
maxspeed
doneby
enter
specic
named
uents
default
front
2003
neighbors
mentions
declared
unspecied
travelling
modelling
surrounding
restriction
safety
nd
elephant
preconditions
integers
query
formalize
motion
outside
drivers
domains
opening
nondeterminism
throw
moving
dened
tag
stay
topography
exogenousaction
ridden
mccain
hudson
geto
dismount
topspeed
horse
bc2
law
circumstances
sort
abbreviation
failed
disjunctions
clause
exceptions
entering
crossings
getting
killing
exogenous
throws
eating
ascii
denite
driving
nondeterministic
rst
language
transitive
supposed
le
dierent
restrictions
agents
a car
the zoo
c world
the animal
zoo world
pos anml
an animal
h anml
nextsegment c
c sg
anml p
tra c
large animal
the tra
p p1
our formalization
distance car1
human cannot
c none
car is
mounted h
car1 none
a position
a gate
to mount
the car
road segment
new segment
segment car1
nextsegment car1
speed car1
of ccalc
the gate
node car1
if nextsegment
distance car2
lmw constraint
large animals
if mounted
giunchiglia et
speed limit
animal can
node c
mount h
after pos
mounted on
pos h
animal moves
the rider
car1 2
p1 g
c sp
a human
the causal
al 2003
the segment
neighbor p
car in
anml p1
cannot attempt
causal calculator
if pos
pos anml1
sides p
formalization of
position at
top speed
animal in
vacated by
another large
safety distance
car1 1
anml if
anml human
neighbor relation
speed limits
the human
segment and
each position
none speed
modelling workshop
segment car2
quoted in
animal cannot
waiting area
nonexecutable mount
causal laws
3 distance
car will
action language
p1 after
speed c
nextsegment car2
logic modelling
just vacated
position just
car2 none
speed car2
loc pos
occupancy restriction
side1 g
side2 g
ccalc to
opened g
pos homer
same segment
each animal
action domains
car2 seg_bc
maximum speed
gate is
the position
cars and
gate if
cage and
moves out
of action
position is
language of
a segment
the speed
the specication
speeds of
of cars
the road
animal s
query maxstep
species are
2003 section
car2 seg_cd
willleave c
pos jumbo
positiveorientation c
car2 1
continuous motion
0 pos
getoff h
choosesegment c
caused speed
segment on
road segments
lmw nonexecutable
none nextsegment
car1 seg_cd
seg_bc nextsegment
deliberative cars
position adjacent
by integers
in giunchiglia
constraint pos
car1 car2
top speeds
animal to
is mounted
anml h
distance travelled
the lmw
car1 seg_ab
same direction
speed of
the action
a node
enter a
input language
of actions
the cars
fails if
c nd
close a
two positions
world in
h g
the traffic
language c
end node
position where
sp if
two large
is thrown
car has
cars are
the neighbor
in front
the formalization
same time
p pos
be mounted
car which
mount an
surrounding tra
dynamic laws
car1 3
car1 seg_ac
none node
throwoff anml
modifiedorientation c
distance car3
users tag
h h1
animal the
tra c world
the zoo world
the tra c
pos anml p
of the zoo
nextsegment c none
of the tra
mounted h anml
a new segment
giunchiglia et al
if nextsegment c
a car is
formalization of the
p p1 g
after pos anml
nextsegment c sg
a large animal
attempt to mount
et al 2003
if a car
a position at
cannot attempt to
language of ccalc
nextsegment car1 none
the causal calculator
sides p p1
pos anml p1
at a node
another large animal
h anml if
neighbor p p1
the neighbor relation
if mounted h
mount h anml
human cannot attempt
our formalization of
nonexecutable mount h
just vacated by
p1 after pos
an animal can
logic modelling workshop
the car in
a gate if
none speed car1
h g if
position just vacated
the animal moves
node car1 none
quoted in section
the same segment
by a human
input language of
moves out of
into a position
of a segment
the same direction
of a car
car2 seg_bc nextsegment
a segment and
zoo world and
getoff h anml
a position just
if pos anml
the distance travelled
animal in each
speed car1 2
the occupancy restriction
al 2003 section
two large animals
if the animal
node c nd
anml human cannot
car in front
choosesegment c sg
close a gate
the animal s
caused speed c
h anml p
fails if the
car1 none nextsegment
seg_bc nextsegment car1
constraint pos anml
expressed by integers
segment car2 seg_bc
speed car1 1
when a car
segment on which
none nextsegment car2
position adjacent to
be performed by
the input language
the same time
a d c
of the car
position at the
out of it
in our formalization
of the segment
at the same
to the side
the position where
in a position
car is in
f after g
top speeds of
2 node car1
a car will
car1 2 node
c world in
if the car
choosing a new
p 0 pos
car1 none node
caused node c
edu users tag
a car at
p pos anml1
car has a
distance car1 2
top speed of
animal s present
c sp if
a waiting area
the speed limit
car1 1 speed
h anml human
a position adjacent
by another large
absence of actions
h p if
anml p if
cannot pass through
its maximum speed
close h g
1 node car1
the logic modelling
loc pos homer
world quoted in
anml p1 after
mount an animal
pos anml1 p
in giunchiglia et
action language c
is a car
1 speed car2
to mount an
gate if he
g human cannot
the segment on
the traffic world
anml p pos
none node car2
riding an animal
surrounding tra c
neighbor relation is
the safety distance
species are large
to the animal
pos h p
same time as
point in time
each point in
and the speed
speed of the
the side of
has a position
enter a new
each car has
the top speed
is thrown into
the gate is
world and the
position at each
of the causal
number of positions
a cage and
to a position
at each point
section 2 1
adjacent to the
utexas edu users
of the gate
cs utexas edu
that the length
if he is
www cs utexas
are expressed by
middle of a
c a d
d c a
the general assumptions
the speed of
end of a
the action is
performed by a
pass through a
where it is
query query maxstep
seg_ab nextsegment car1
human who is

corpus/krapavin2000-test/1005399.txt
robot
brooks
layer
layers
sonar
subsumption
heading
prover
pttp
circumscription
provers
prolog
shanahan
feelforce
nonmonotonic
wander
cwa
theories
golog
fwd
sensors
module
mccarthy
baral
sonars
latches
attachments
force
reiter
architecture
reactivity
levesque
logical
stickel
runaway
halt
agents
manipulators
logic
reasoning
latch
actions
nsonars
circumscribing
lesperance
acl2
circ
nonmonotonicity
reactive
tran
ai
assert
1997
ab
modules
giacomo
fluents
planning
predicates
ahead
dist
outputs
lsa
goals
got
abduction
hol
pushing
axiomatization
agent
negation
intelligent
collide
override
sensory
inputs
1998
antoniou
kartha
informatic
lesprance
elaboration
1996
angle
obstacles
action
paradigm
scription
circum
cliff
brewka
repulsive
wandering
kautz
vicinity
robotics
1986
competence
chitecture
selman
abnormality
behaviors
mobile
behavioral
commands
sure
semantic
overrides
axiomatizations
leaning
stein
lifschitz
embodied
world
axioms
html
precedence
quadrants
cycle
sentences
obstacle
seconds
plan
quadrant
overriding
ar
priority
formalizing
speed
l0
language
readings
inability
decomposition
objects
asserted
object
body
location
physical
decoupling
strength
sensing
moore
documentation
controlling
capabilities
move
difficulties
inferences
fol
society
forces
motivations
asserts
appendix
forward
default
lisp
benefits
loop
moment
nipulators
gabbay
1988b
nomad
creator3d
reactiv
sensor_readings
concur
brains
1988a
rodney
wielding
debut
bibel
soutchanski
1958
extendability
deduc
treewidth
8quad
otter
ox
lesper
konolige
cmd
ligence
kuipers
zeroed
abides
competent
fluent
shana
aimlessly
ultra60
nonmonotonically
1222
troubles
encoders
the robot
subsumption architecture
theorem prover
of brooks
theorem provers
brooks subsumption
layer s
higher layers
robot control
logical theory
robot to
based subsumption
that layer
lower layers
layer 1
layer 0
nonmonotonic reasoning
heading angle
technology theorem
prolog technology
the avoid
semantic attachments
each layer
of layer
layers to
this layer
mobile robot
get force
avoid layer
halt robot
heading speed
in brooks
the pttp
turn heading
logic based
the theory
robot s
common sense
layer is
different layers
layer in
level robot
reading sonar
need turn
brooks system
sonar reading
pushing object
the wander
our theory
a prolog
the logical
a logical
layers and
provers and
the layer
architecture that
lower layer
the subsumption
as failure
language includes
the world
the theories
negation as
two layers
intelligent agents
logical theories
logical approach
circumscribing the
from brooks
of shanahan
fwd heading
circumscription to
levesque 1997
ai architecture
shanahan 1998
action theory
feelforce module
baral and
ab avoid
sonar dist
circumscription formula
more reactive
wander layer
parallel circumscription
ab i
layers may
brooks 1986
brooks architecture
the latches
separate theorem
level layers
the layers
of theories
layers are
goal location
and tran
layer i
the cwa
the output
theory in
a layer
goals to
each cycle
layer are
theory we
high level
our architecture
the prolog
input language
the objects
the force
commands the
the theorem
layers of
for cost
3 seconds
the architecture
a map
higher layer
architecture is
physical sonars
control modules
specify actions
sonar number
1996 shanahan
chitecture we
provers can
agent programming
subsumption latch
provers for
asserts in
r module
sonar direction
priority goals
our layer
behavioral decomposition
turn module
layer will
detected objects
and lisp
for nonmonotonic
model elimination
1996 reiter
give formal
avoid heading
of competence
layers 0
reactive layers
sense informatic
assert in
formalizing common
based ai
avoid objects
1998 lesprance
s circumscription
shanahan 1996
antoniou 1997
min dist
directly ahead
prover of
i ab
towards 0
avoidance capabilities
new heading
prover implementation
reiter 1996
circ layer
logical representation
module checks
1998 focuses
runaway module
let layer
of mind
complex layers
tran 1998
combined repulsive
cwa for
uses their
the golog
the feelforce
obstacles as
provers in
g shanahan
level layer
the runaway
sonar module
output language
extended prolog
object ahead
proof goal
lesperance levesque
robot our
and turn
circum scription
original theory
elaboration tolerance
overall state
as nsonars
theories each
golog program
the robot to
brooks subsumption architecture
technology theorem prover
based subsumption architecture
logic based subsumption
prolog technology theorem
of brooks subsumption
the logical theory
turn heading angle
the avoid layer
higher layers to
a prolog technology
the robot s
of layer 0
sonar reading sonar
for that layer
robot to move
high level robot
theorem provers and
negation as failure
the theorem prover
a theorem prover
this layer are
a separate theorem
the wander layer
language includes the
a mobile robot
fwd heading speed
logical approach to
each layer is
theory of layer
need turn heading
the parallel circumscription
of lower layers
first two layers
the subsumption architecture
avoid layer s
search for cost
baral and tran
to the robot
of a layer
0 3 seconds
the different layers
actions for the
the higher layer
in the theory
the input language
a map of
all the objects
in a lower
robot control system
reiter 1998 lesprance
theorem provers can
1996 reiter 1996
based ai architecture
lesperance levesque 1997
output from layer
an action theory
goals to override
higher layers may
tran baral tran
common sense informatic
semantics to our
al 1996 reiter
for this layer
such as nsonars
commands the robot
planning and execution
of semantic attachments
outputs for that
baral tran 1998
the layer s
model elimination theorem
more reactive layers
1998 focuses on
i ab i
robot control and
different layers and
e g shanahan
of robot control
the original theory
layer 0 by
of that layer
circumscribing the theory
no longer than
an s r
specify actions for
proof search for
heading speed and
cwa for the
a lower layer
collection of theories
let layer i
implementation by an
version of brooks
our theory we
combined repulsive force
of the avoid
on the robot
parallel circumscription formula
goal location is
ab avoid heading
c function get
system of layers
separate theorem prover
g shanahan 1996
a model elimination
this layer in
a logical theory
in brooks 1986
1996 shanahan 1998
that layer the
and min dist
of logical theories
includes the symbols
s r module
formal semantics to
asserts in the
module checks if
language l i
idea of subsumption
more complex layers
such a theory
levesque 1997 in
lesprance et al
1998 lesprance et
the logical representation
theorem provers in
layers 0 and
for nonmonotonic reasoning
theorem provers for
sensors output latches
the feelforce module
logic based ai
layer i ab
logical theory we
logical theories each
during each cycle
layer in the
higher level layers
the runaway module
a logical approach
brooks system and
an extended prolog
levels of competence
was needed leaning
the physical sonars
provers can be
prolog and lisp
layers to observe
and tran baral
formalizing common sense
function get force
mccarthy s circumscription
logical theory as
add the parallel
inferences in 0
theorem prover of
elimination theorem prover
of brooks system
the overall state
layer are the
prover implementation by
theorem prover implementation
give formal semantics
for higher layers
input language includes
mobile robot our
society of mind
sense informatic situation
implemented using theorem
each layer s
the golog program
ar chitecture we
reading sonar dist
the operation of
the work of
general purpose theorem
use of semantic
and negation as
theorem prover for
the theorem provers
in its vicinity
find the required
each cycle of
possible for higher
theorem prover the
the logic based
theorem prover is
that the theory
the output includes
an intelligent agent
the lower layer
layers are not
the frame problem
increasing levels of
an over all
of the layer
the society of
with the operation

corpus/krapavin2000-test/1005453.txt
coloring
superedge
outgrowth
vertex
width
supergraph
clique
perimeter
height
face
colors
vertices
ring
subcubic
bag
minors
balanced
incident
minor
edge
superedges
colorings
edges
surface
graphs
outgrowths
crosscap
bags
degenerate
pointset
surfaces
planar
subgraphs
tree
tw
faces
layers
decontractions
color
subgraph
e2
joins
partition
robertson
corollary
partitions
rings
layer
colored
endpoint
counterexample
witnessed
excluding
heights
seymour
disk
join
integers
ossona
pointsets
jaroslav
neetil
mendez
df
round
boundary
embedded
cyclic
xvi
patrice
rotate
euler
fill
3s
endpoints
reductions
filling
arbitrarily
injective
closed
integer
canonical
proofs
cb
cyclically
embedding
lemma
uv
ke
2r
declared
conjectured
delete
mod
incidence
extensions
deleting
replacing
finitely
constructions
decomposition
deletions
generality
1041
fomin
05c55
9400946
mohammadtaghi
slovene
05c15
leqsf
demaine
encyclings
spannings
hajiaghayi
mda904
893
widlh
thilikos
fillings
punctured
fedor
apex
decontraction
capping
cappings
theorems
2h
incidences
1on
1965
endvertices
1if
1022
thomas
preserving
ers
span
drawing
string
2057
dms
1to
reversals
subexponential
dimitrios
deletion
structural
author
triple
866
disjoint
conjecture
di
sounds
contracting
circuit
hypergraph
genus
continuous
grant
ranging
xx
combinatorics
rd
qualities
louisiana
fund
naval
cap
lemmas
strings
algorithmic
witnesses
forbidden
connected
induced
loss
jacm
deg
wish
parts
2s
homomorphism
noted
corollaries
preserve
bounding
phrases
boundaries
leaves
ce
fractional
characteristic
uniquely
attaching
agency
assigns
n00014
solvable
tree width
every graph
r ring
g h
width at
a graph
a vertex
r outgrowth
face f
vertex coloring
supergraph h
incident with
a face
graph minors
a supergraph
with tree
graph with
of g
a balanced
a clique
h layer
vertex partition
with perimeter
g w
of graphs
partition into
ring r
edge partition
k b
h f
perimeter t
clique join
clique joins
colors form
k tree
full coloring
balanced k
any j
2 edge
h is
of h
that every
f 0
balanced full
an outgrowth
no k
k minor
2 edges
a r
of surfaces
planar graph
graph in
g has
all graphs
is full
of colors
a surface
j parts
parts form
graphs such
an r
has tree
suppose g
l coloring
e2 h
minor closed
minor has
edge coloring
each superedge
r rings
e b
g e
graph g
coloring of
g is
a minor
g 1
at most
excluding a
embedded on
an edge
most k
g 2
then g
height h
in has
coloring if
v q
join of
v g
and subcubic
vertex l
pointset of
endpoint rule
closed disk
vertex extensions
closed class
the pointset
edge partitions
2 w
if g
vertices and
and g
the perimeter
ring with
t n
the face
edge e
a coloring
g v
that g
1 t
form a
coloring c
every face
height in
width of
edge in
face of
we may
graphs g
s round
bounded tree
h on
such that
edge and
a k
w k
and h
the vertex
and edges
a planar
edges in
the height
surface is
and integer
every edge
h by
and edge
the endpoint
is incident
into i
each vertex
surfaces and
v b
by clique
height preserving
outgrowth g
superedge by
full r
corollary let
l colors
low tree
s research
a superedge
graphs other
have height
h layers
partial k
and seymour
joins starting
of bags
are numbers
have heights
superedge has
superedge f
face by
tw g
minor may
crosscap and
handle reductions
balanced edge
bag x
width r
with no
the edges
h 1
theorem let
most j
graph k
that any
the vertices
an integer
j 1
w such
full and
witnessed by
vertices in
g such
r s
r h
all vertices
t x
of width
non degenerate
face is
let k
from h
subgraph of
e h
width at most
tree width at
that every graph
form a graph
with tree width
every graph in
g h f
that any j
graph with tree
a r outgrowth
a graph with
an r ring
such that every
is a r
1 t n
graph with no
a vertex partition
clique join of
set of surfaces
g h is
balanced k b
has a balanced
a clique join
a balanced k
with perimeter t
join of g
r ring r
colors form a
is a clique
h is a
of all graphs
g 2 w
set of colors
is a graph
such that any
j parts form
g e b
a supergraph h
with no k
no k minor
an edge partition
perimeter t 1
graphs such that
parts form a
every graph with
t 1 t
set of graphs
the tree width
tree width of
has tree width
then g has
a vertex coloring
in has a
ring with perimeter
balanced full coloring
h is full
edge partition into
graph in has
face of h
if g h
has a k
g 1 and
g has a
g is a
at most k
and g 2
vertices and edges
of g 1
a face f
a 2 edge
h f 0
such that g
a face of
g a b
of surfaces and
on the perimeter
a closed disk
edge in a
the pointset of
in a supergraph
from h by
minor closed class
vertex extensions of
the endpoint rule
has a vertex
a balanced full
r ring with
j j parts
partition into i
full and subcubic
lemma 1 4
vertex partition into
is a counterexample
vertex l coloring
a planar graph
a k b
a graph and
a graph g
there are integers
is incident with
edges in e
1 and g
is a b
and an edge
f 0 is
bounded tree width
for every graph
coloring of g
edge and a
vertex and edge
there is a
e b is
class of graphs
any j j
corollary 2 2
is a balanced
of g a
g such that
and a vertex
edges of g
at most j
j colors form
h f is
l colors form
graphs other than
this author s
vertex coloring c
on a clique
by clique joins
low tree width
extensions of graphs
l coloring such
clique q with
vertex coloring we
clique joins starting
graph in can
k minor has
a minor of
theorem let be
s research was
joins starting from
partial k tree
supergraph h is
a clique q
h by replacing
j l colors
t n such
balanced edge and
that in 6
into two graphs
a partial k
k minor may
every graph k
witnessed by a
author s research
any j l
there are numbers
excluding a planar
s h layer
outgrowth g h
r h layer
of graphs other
minor may be
theorem for every
into n parts
leaves the vertices
r s h
minor has a
face f 0
in e h
crosscap and handle
a minor closed
v q w
k b coloring
a full r
a balanced edge
a vertex l
constructed by clique
width r 1
closed class of
a k tree
are numbers r
e with endpoints
pointset of f
every face is
and handle reductions
on a surface
and integer j
a surface and
robertson and seymour
exists w such
vertices in w
w such that
g and h
be the set
set of all
the set of
theorem 2 1
this follows from
obtained from h

corpus/krapavin2000-test/1005726.txt
bgp
router
ebgp
routes
route
emulator
ibgp
egress
routers
igp
routing
prefixes
learned
import
ingress
traffic
med
configuration
prefix
signaling
ases
prediction
rr
sessions
network
rr1
session
policy
hop
outcome
preference
reflector
tables
interdomain
operators
rr2
rrs
id
attributes
policies
destination
decision
timescales
renata
rexford
speaking
advertised
sigcomm
module
reflectors
teixeira
selection
predictions
stable
ip
link
isp
protocol
clients
neighboring
peering
path
shortest
paths
engineering
predicts
neighbors
candidate
jennifer
dynamics
simulators
aman
griffin
shaikh
selects
incremental
validation
effects
434
live
backtracking
locally
phase
confederations
ssfnet
protocols
tunable
061
select
620
advertisements
affect
mismatches
fortunately
ids
predicted
loading
day
intradomain
rebalance
ultimately
predict
tier
neighbor
phases
internet
parsed
errors
inconsistencies
decisions
prototype
adjust
554
advertises
emulating
suddenly
emulates
tasks
costs
eliminates
destinations
advertise
eliminate
deploying
exit
propagate
optimizations
313
operator
correctly
jacobus
coast
feamster
tiebreaking
uhlig
pray
converge
maintenance
gateway
upgraded
learns
volumes
visiting
prefers
emulate
border
announcing
advertisement
potato
merwe
igps
planned
provider
simulating
snapshot
configurations
modified
excluded
modeling
applies
mesh
stability
divert
outbound
malfunctioning
lund
deci
troubleshooting
flow
manipulate
inputs
interaction
attribute
portland
carsten
envision
subtleties
mauricio
everyday
tweak
resende
oregon
reachability
configured
origin
database
operational
deferring
configure
failures
converges
lowest
loaded
der
oscillation
accurately
congestion
links
emulation
incorrect
the emulator
the bgp
best route
each router
ebgp learned
ebgp routes
learned routes
decision process
bgp route
igp path
bgp decision
best ebgp
route selection
route at
the ebgp
router id
the as
bgp routing
the route
as path
network engineering
import policy
route prediction
signaling graph
traffic engineering
network operators
ingress router
ebgp speaking
an as
the import
local preference
the egress
speaking router
best routes
emulator s
import policies
of prefixes
modified routes
router in
routing tables
the ibgp
routes table
the igp
as paths
prediction algorithm
of bgp
configuration changes
the router
of best
a router
bgp emulator
learned route
engineering tasks
path costs
egress point
an ebgp
the routing
routers in
the routes
next hop
route that
the outcome
per prefix
best bgp
of ebgp
each ebgp
egress router
these routes
routes with
a bgp
second phase
routes and
phase of
of routers
of ibgp
prefixes with
ebgp sessions
learned at
routes for
known routes
route reflector
ibgp signaling
locally best
the best
the effects
the routers
network operator
outcome of
of routes
routes from
routes learned
routes at
a route
bgp tables
egress points
modeling bgp
candidate routes
third phase
effects of
other routers
at router
router and
that router
the algorithm
the network
destination prefix
same next
configuration data
configuration change
other router
hop as
router that
route for
emulator to
egress routers
shortest igp
ibgp session
med value
bgp routes
emulator can
operators need
ibgp and
router y
ibgp sessions
s route
bgp path
make modeling
live network
each ingress
path selection
routing table
one router
path cost
the signaling
selection process
the decision
of traffic
ibgp configuration
in bgp
message ordering
every router
each prefix
router the
at each
routing protocol
routing protocols
acm sigcomm
first phase
a network
jennifer rexford
link weights
renata teixeira
bgp neighbor
route attributes
without backtracking
origin type
and igp
egress set
constraint 3
speaking routers
router ids
an rr
router selects
the med
import table
route reflectors
operators must
of egress
emulator based
router x
tables and
path length
network configuration
route from
running time
routes in
and router
routes the
route learned
the prefixes
router configuration
med and
all routers
protocol dynamics
the locally
routes a
routing decisions
router can
applies the
best egress
total errors
candidate route
bgp session
route among
routes after
down neighbors
the ingress
bgp configuration
rr clients
model bgp
ebgp learned routes
at each router
the best route
the bgp decision
bgp decision process
of the bgp
bgp route selection
set of best
best ebgp routes
of best ebgp
best route at
in the as
phase of the
ebgp speaking router
the emulator s
igp path costs
that the emulator
route at each
the decision process
the second phase
router in the
ebgp learned route
best bgp route
the outcome of
the effects of
a network operator
the ebgp routes
the route prediction
route prediction algorithm
the import policies
outcome of the
second phase of
in an as
of the algorithm
the third phase
the router id
same next hop
the ebgp learned
pair of routers
ibgp signaling graph
as path length
network engineering tasks
the modified routes
igp path cost
the signaling graph
for each router
next hop as
at one router
the best routes
the emulator can
shortest igp path
the igp path
locally best route
best ebgp learned
the import policy
the locally best
modified routes table
bgp path selection
group of prefixes
the known routes
model of bgp
a bgp emulator
for each prefix
the first phase
the same next
the as path
each router in
a best route
emulator based on
same as path
prefixes with the
the import table
the shortest igp
path cost to
modeling bgp route
the best bgp
third phase of
in the bgp
the ibgp signaling
each ingress router
and router id
best route for
flow of traffic
the emulator to
path selection process
ebgp speaking routers
make modeling bgp
the egress points
of the emulator
to a unique
that each router
bgp routing tables
the as in
the network configuration
the input data
every other router
every router in
parsed and loaded
each ebgp speaking
of egress routers
1 620 061
ibgp and igp
affect the flow
at another router
route selection process
its best route
egress points table
med and router
the ingress router
routes from the
emulator s running
a route reflector
route at the
for traffic engineering
an ebgp speaking
to end validation
operators need to
the egress router
a large tier
of ebgp learned
routes a and
in the egress
known routes table
the same egress
of the prefixes
the third module
of the ebgp
learned routes and
within an as
the bgp emulator
distinct as paths
set of egress
between each pair
a unique solution
routers in the
of the route
the set of
routes in the
routes with the
computing the best
decision process the
to other routers
router has a
tier 1 isp
large tier 1
router in an
each router the
s running time
route that is
the flow of
converge to a
to a destination
verify that the
first phase of
network configuration and
routers in a
the routing tables
the routers in
end to end
computer communication review
sigcomm computer communication
communication review v
acm sigcomm computer
if the best
of the decision
of the best
with the same
from section 4
effects of a
can affect the
hop as as
the best ebgp
best route that
set of ebgp
as paths we
modified routes tables
ebgp routes a
network wide bgp
the bgp tables
the live network
to model bgp
bgp routing decisions
router can affect
select a route
on a live
equally good through
best route is
the best egress
routes to a
ebgp route learned
egress router that
med value and
configuration changes before
configuration changes typically
a full mesh
routes learned at
local preference attribute
best egress router
route for that
each router has

corpus/krapavin2000-test/1006322.txt
bn
collective
bayesian
site
sites
learning
mining
conditional
centralized
kl
probabilities
bns
ddm
dierent
commuicated
ckl
central
heterogenous
asia
samples
observations
alarm
kargupta
parents
likelihood
web
heterogeneous
cross
heckerman
vl
sivakumar
eos
spiegelhalter
network
depicts
coupling
buntine
eecs
learn
server
transmitted
joint
networks
cen
le
astronomy
c2ol
gieger
distrbn
links
learnt
communicated
monitoring
fraction
wireless
session
selective
1997
chickering
dasgupta
estimated
kenji
lauritzen
1995
distance
friedman
weather
chen
vc
card
credit
dataset
condence
mdl
edges
sensor
la
1991
dyspnoea
cheeseman
webserver
dkl
pcntr
gilks
bacchus
stutz
eosdis
probabilistic
parent
download
resources
node
1996
tables
sampling
intranets
goldszmidt
russel
gov
autoclass
hershberger
bronchitis
spirtes
mc
oer
across
records
client
evidence
transaction
datasets
jensen
transmitting
log
oers
demographic
takeuchi
independence
em
xi
veried
associations
discovering
specic
homogeneous
koller
online
split
scalability
scenario
pb
transmission
threshold
sample
1993
probability
gure
pursuing
1998
estimating
keys
toy
distributions
city
pa
geiger
leibler
multinomial
gibbs
discovery
collaborative
hypothesis
kullback
features
hoc
cooperative
incomplete
1994
classication
sales
congurations
faculty
repositories
cooper
relationships
www
dg
multiagent
fig
involve
dicult
uncertain
admission
benet
schema
detected
maybe
diagnosis
logs
estimates
databases
sa
conguration
school
inference
scales
lam
ad
hidden
communication
singh
pictures
missed
indices
dened
world
anaphylaxis
cellphones
wearable
bein
central site
bayesian networks
bayesian network
collective bn
a bn
conditional probabilities
the bn
kl distance
cross terms
from distributed
the collective
the conditional
of bayesian
collective mining
centralized approach
web log
networks from
asia model
site a
heterogeneous data
alarm network
collective learning
our collective
distributed heterogeneous
site b
the local
dierent sites
of observations
a bayesian
mining of
local sites
observations commuicated
a collective
each site
of sites
data mining
the central
local site
bn is
parameter learning
between variables
distributed data
bn learning
collective approach
local bn
ckl distance
bn structure
log le
the centralized
log data
conditional probability
at site
sites a
a centralized
the kl
local variables
nodes 20
variables across
proposed collective
collective method
node 21
collective bayesian
across sites
the cross
the observations
site the
r chen
of node
learning the
local model
commuicated fraction
the ckl
parents of
a central
learning a
sample complexity
the asia
fraction of
the dierent
chen et
network structure
data communication
bayesian learning
distance between
two sites
bn and
to number
bn from
heckerman and
and kargupta
the heterogenous
local bns
centralized method
buntine 1991
cross links
observations communicated
local bayesian
overall bn
data sites
our approach
depicts the
sites this
the web
learning method
evidence of
data at
variables from
error threshold
node e
parameters of
coupling between
site and
structure learning
more sites
the structure
probabilities of
the parameters
that obtained
sites and
transmitted to
of samples
to learn
to learning
learning approach
credit card
site using
homogeneous case
of bn
both sites
the variables
the distributed
sites the
of data
non local
site has
conditional distributions
true distribution
the joint
distributed resources
observations across
distributed sources
involve variables
experiment illustrates
low likelihood
bn model
likelihood computation
bn based
1 asia
right depicts
be evidence
under la
distributed site
joint probabilities
data scenario
commuicated fig
central bn
heterogenous data
clearly even
sivakumar and
bn obtained
dasgupta 1997
observations at
gieger 1995
heterogenous case
mining ddm
between conditional
card transaction
global site
and gieger
learnt at
edges detected
case site
pa x
a selective
local links
local likelihood
conditional independence
incomplete data
site for
of nodes
site in
hoc wireless
bn for
learning error
distributed sites
jensen 1996
to download
associated conditional
learning bayesian
at www
local terms
related through
left depicts
dierent nodes
bn in
scales well
structure of
learn the
at each
and 21
the central site
distributed heterogeneous data
from distributed heterogeneous
bayesian networks from
the conditional probabilities
fraction of observations
networks from distributed
collective mining of
mining of bayesian
of bayesian networks
kl distance between
a bayesian network
a centralized approach
at the central
number of sites
the kl distance
of observations commuicated
a central site
sites a and
the cross terms
at each site
of a bn
web log le
of the collective
the proposed collective
of the bn
r chen et
the web log
the conditional probability
to a central
respect to number
the local sites
observations commuicated fraction
our collective approach
commuicated fraction of
our collective bn
the asia model
learning a bn
the collective method
between variables across
the ckl distance
on our collective
to number of
chen et al
using a centralized
approach to learning
the structure of
conditional probabilities of
to that obtained
central site the
nodes 20 and
variables across sites
the centralized method
depicts the ckl
the collective learning
a collective bn
of observations communicated
collective learning method
the collective bn
conditional probability of
at site b
web log data
20 and 21
learning the structure
of node e
at site a
to the central
are available at
of the local
of our approach
of bayesian network
relationships between variables
the local variables
conditional probabilities for
the parameters of
of a bayesian
distributed data mining
transmitted to the
collective bn learning
true distribution p
experiment illustrates the
the observations for
between conditional probabilities
ckl distance of
sites this is
collective method is
be evidence of
proposed collective learning
to be evidence
a bn from
of node 21
this experiment illustrates
site a with
1 asia model
the observations that
distributed site has
collective approach is
obtain a collective
of collective bn
observations commuicated fig
credit card transaction
heckerman and gieger
data mining ddm
clearly even with
and gieger 1995
in the bn
learnt at the
collective bayesian network
collective approach to
the local likelihood
the error threshold
the distributed resources
bn and the
estimating the conditional
available at site
distributed sources of
collective bn and
the local bn
the overall bn
distance between conditional
local bayesian network
observations across sites
central site using
the associated conditional
collective bayesian learning
set of keys
the cross links
the heterogenous case
bayesian network from
the local model
the local bns
small data communication
from a centralized
bn based on
central site to
even with a
distance between the
close to that
ad hoc wireless
based on our
a and b
bayesian network structure
of parents of
of coupling between
distance of node
network structure is
that obtained from
learning bayesian networks
approach with respect
scales well with
estimated at the
learning a bayesian
well with respect
between the joint
the local models
learning approach to
a small data
probability of node
of the conditional
parameters of a
the sample complexity
at the local
each local site
web log mining
probabilities of the
the scalability of
from incomplete data
at each local
scalability of our
site and the
bayesian network is
approach is quite
is quite close
a single site
the estimates of
obtained from a
0 9 0
of the cross
are most likely
with a small
our approach with
hoc wireless networks
to the distributed
structure of a
ability of the
the performance of
that the structure
most likely to
quite close to
non local bn
are related through
of variables among
local likelihood values
a biased sampling
key that can
every distributed site
by heckerman and
learning of local
ckl distance is
parents of nodes

corpus/krapavin2000-test/1006412.txt
awseem
engines
dcv
engine
altavista
human
precision
yahoo
pages
netscape
tukeys
alltheweb
judgments
infoseek
msn
hsd
web
judgment
hotbot
erent
signi
pearson
cant
relevance
ectiveness
document
correlation
search
documents
query
ranking
retrieval
dcvs
evaluations
downloaded
lycos
pa10
pa20
queries
di
precisionnetscape
ra10
performers
urls
pathak
8340
ra20
padcv
googles
consistency
sig
speci
performer
google
participants
bias
trec
salton
searchers
05
bilkent
mowshowitz
pa3
kawaguchi
hawking
automatic
modi
tiveness
ective
ed
submitted
statistically
measuring
100
gordon
ranks
rank
fig
users
ned
top
returned
200e
scattergram
7070
soboro
spearmans
radcv
voorhees
netscapes
cs533
erences
ec
134
meta
retrieved
gures
50
rankings
cance
enterprises
consistencies
overture
buckley
inventing
relevant
performing
hypertextual
nes
relevancy
precisions
cgi
calculations
students
null
neto
mcgill
jansen
ribeiro
rst
calculated
worst
around
directory
displayed
page
genuine
partner
intermediary
topics
average
retrieve
business
assessments
links
distinguishing
pool
anatomy
reject
boolean
modern
ect
1983
measures
asked
statistical
eight
effectiveness
judge
response
triangulation
123
164
hypothesis
118
subjects
1000
recommended
assessing
text
sorted
keywords
searches
url
indistinguishable
people
1988
pa1
pa15
netscapealtavista
magellan
ecommerce
stylistic
fazli
saracevic
400e
spink
pedrito
7707
7330
3a000
8675
rabia
conformant
pa2
viewable
chowdhury
rabian
yahoos
sei
mccown
excite
opentext
9258
blinding
krowne
listings
maynard
trang
tfc
search engines
search engine
human based
and awseem
relevance judgments
average precision
at dcv
based evaluation
pearson r
of search
each search
di erent
tukeys hsd
human judgment
web search
awseem 100
awseem 50
performing search
signi cant
based evaluations
dcv 20
e ectiveness
information needs
recall values
and recall
the search
awseem results
altavista and
precision and
precision values
for human
around dcv
of awseem
in awseem
human relevance
of human
judgment and
0 05
human and
engines in
precision at
r correlation
average recall
hotbot infoseek
hsd for
various dcvs
of web
query document
for precision
yahoo and
the consistency
relevant documents
the top
engines and
awseem and
response vector
downloaded pages
for awseem
05 engines
altavista yahoo
average subset
engines precisionnetscape
a hotbot
precisionnetscape 25
n average
search n
of relevant
the average
information retrieval
consistency between
50 and
between human
worst performing
meta search
using human
a 0
of retrieval
p 20
retrieval systems
the human
pathak 1999
infoseek msn
table tukeys
and yahoo
document pairs
alltheweb altavista
relevant pages
100 pages
0 8340
gordon and
and pathak
erent search
dcv 10
relevance judgment
the downloaded
precision around
cant correlation
engine performance
engines are
this study
the queries
information need
and human
the web
the correlation
a search
null hypothesis
correlation of
web pages
the precision
engines a
recall at
is signi
with human
subset for
user queries
and 100
consistency of
both methods
top two
engines for
top 20
of urls
values around
engines based
p 10
each query
modern information
r values
see table
pages of
two performers
retrieval e
that human
engine evaluation
ectiveness of
ec tiveness
awseem for
and ra20
by awseem
100 based
judgments and
found relevant
kawaguchi 2002
ra10 values
hawking et
msn alltheweb
awseem precision
cant at
web searching
using precision
ranking algorithm
judgment with
yahoo altavista
and lycos
measuring search
dcv of
pa10 and
googles results
yahoo sig
these gures
awseem using
subsets distinguishing
1999 study
awseem in
with awseem
human awseem
subject areas
1000 words
study we
the null
in fig
best performing
e ec
for 50
our software
engines as
worst performer
particular search
pages if
02 a
r 20
evaluations using
all search
relevant by
on precision
a query
at various
vector of
of top
e ective
the experiments
automatic method
top 50
search results
speci c
pages used
20 p
20 r
s 50
of search engines
human based evaluation
the search engines
each search engine
a 0 05
precision and recall
human based evaluations
the average precision
human judgment and
and recall values
performing search engines
judgment and awseem
pearson r correlation
for human based
web search engines
number of relevant
search engines in
human and awseem
tukeys hsd for
and the worst
of each search
search engines and
50 and 100
for a 0
of web search
search n average
human relevance judgments
n average subset
worst performing search
05 engines precisionnetscape
and awseem results
0 05 engines
average subset for
at dcv 20
subset for a
and human based
engines precisionnetscape 25
a search engine
search engines are
in this study
the consistency of
performing search engine
around dcv 20
the average recall
query document pairs
the response vector
r 0 8340
precision at dcv
hsd for precision
gordon and pathak
table tukeys hsd
consistency between human
search engine performance
using human based
average precision values
of relevant pages
response vector of
using the top
signi cant correlation
best performing search
the downloaded pages
search engines a
di erent search
at dcv 10
of human judgment
and pathak 1999
average precision around
pearson r values
the null hypothesis
search engines for
for precision at
the correlation of
the worst performing
based evaluation and
search engines based
of the search
web search engine
engines based on
this study we
of relevant documents
modern information retrieval
the search engine
dcv 20 the
a hotbot infoseek
signi cant at
altavista and yahoo
values for human
100 based on
yahoo and the
precisionnetscape 25 0
e ec tiveness
awseem using the
found relevant by
information needs of
and yahoo and
awseem and human
meta search engine
engines a b
the user information
altavista and the
this search engine
e ectiveness of
hawking et al
human and automatic
to measure e
20 for human
evaluation and awseem
pages used to
at various dcvs
subsets distinguishing between
human based and
search engine evaluation
performance of search
of human awseem
based on precision
rank of search
erent search engines
are sorted according
infoseek msn alltheweb
hotbot infoseek msn
for 50 and
correlation of human
and awseem 100
is signi cant
a particular search
based and awseem
recall values around
ectiveness of search
and awseem 50
a 0 01
pathak 1999 study
based evaluations in
consistency of human
most e ective
the precision values
measuring search engine
human awseem results
altavista yahoo sig
a meta search
dcv of 10
the e ectiveness
for each search
compute the average
in future experiments
the worst performer
r 10 and
recall values at
all search engines
between human and
the consistency between
the top 20
particular search engine
evaluation of web
at a 0
search engines as
world wide web
the top two
be di erent
the most e
for each query
number of top
according to their
the best performing
by the search
sorted according to
in the evaluation
of the collection
in the experiments
10 and 20
the average of
used to measure
search engines using
user information needs
radcv measures for
retrieval systems using
document pairs are
sig table tukeys
we can reject
altavista and lycos
altavista yahoo and
hsd at dcv
recall values of
pages downloaded from
their pa10 or
search engines b
engines for both
and awseem for
and awseem precision
for human judgment
precision values at
awseem 50 is
the pearson r
query query subject
with awseem 100
for precision and
of bilkent university
search engines were
between the human
and 100 pages
using precision and

corpus/krapavin2000-test/1006425.txt
hypergraph
transversal
branching
mintr
ffn
psi
rossmanith
transversals
niedermeier
branchings
hypergraphs
6737
vertex
6538
mintrnonr
mintrexp
subcase
hitting
vertices
edges
6316
4656
fxg
jhj
yg
kullmann
hyperedges
fx
gammaff
4143
robson
tur
6484
branches
cardinality
dominated
continous
270
reductions
rank
parameterized
edge
poly
zg
jt
loops
maximally
jv
dualization
stavropoulos
vales
kavvadias
hyperedge
tree
ff
worst
polynomial
branch
6k
pick
running
recursion
exponential
qn
removed
spent
delta
return
uniform
ordinary
runs
care
covered
loop
cover
ae
mining
sat
remember
coloring
filling
formulas
correctness
overestimated
cugs
6316n
hypergraps
fzg
caen
meier
transver
60962n
60962ne
berge
solveff
intractabil
dinality
nieder
19228
6538n
disjunctive
tuple
intractability
phylogeny
domination
phylogenies
monotonously
deltan
sal
you
minimal
stirling
confronting
moser
sweden
damaschke
fyg
gammaq
filled
monotone
similarities
proven
labelled
caching
eiter
d0
fvg
obeying
helper
mishra
reduc
formula
tricks
pitt
asymptotics
holland
351
gottlob
min
article
turned
moon
subcases
deals
lengthy
hg
listen
ceiling
smallest
approximating
biggest
settle
occuring
assignment
balance
calculated
divisions
calculating
biology
fills
catches
mathematics
finding
modification
337
halting
graphs
reach
maximal
concrete
reached
catch
overly
school
eg
beforehand
imperfect
spends
evolutionary
regardless
trick
tries
degree
consideration
lem
fe
leaf
temporarily
graduate
polynomially
thorough
motivation
np
labels
subgraphs
car
ity
linking
afterwards
seeks
branching number
2 edges
a hypergraph
psi k
minimum transversal
the branching
hypergraph h
and rossmanith
the hypergraph
o 1
niedermeier and
the transversal
3 uniform
a transversal
branching numbers
running time
hitting set
transversal hypergraph
mintr h
1 6737
psi 0
hypergraph with
for case
f h
case 4
h is
hypergraph is
1 6538
number branching
4 subcase
uniform hypergraph
subcase d
number cases
rossmanith s
edge fx
o 2
transversal of
branching tree
independent sets
exponential space
transversal in
6316 n
transversal problem
smallest transversal
hypergraph problem
1 6316
3 hitting
uniform hypergraphs
fx yg
mintr 0
h 0
r h
for branching
rank 3
polynomial space
2 edge
poly n
in h
d 2
a vertex
vertex x
runs in
1 4656
minimal transversals
mintrnonr h
of mintr
6538 n
transversal t
gammaff n
ordinary graphs
6737 1
k formula
2 270
0 k
the algorithm
of psi
in o
edges are
case analysis
of h
1 gammaff
final case
for psi
the tree
0 ae
v 0
worst case
of cardinality
vertex cover
dominated by
the running
their algorithm
with vertices
cases 1
jt r
use exponential
1 6484
transversal and
fxg 2
algorithm mintr
mintrexp is
1 4143
case branching
maximally reduced
loop fxg
only polynomial
rossmanith 13
transversals and
tur an
4656 ffn
6484 n
maximum d
cases 0
using psi
by niedermeier
needs polynomial
is continous
for 3
search tree
ae v
time o
number is
a running
when k
a branching
k 0
min h
r uniform
hypergraph and
cases for
one 2
maximum independent
n h
if h
related problems
edges of
n time
all minimal
care of
x is
numbers for
with maximum
is o
spent in
s algorithm
time of
t r
h with
n delta
independent set
0 h
every v
of rank
for ordinary
some vertex
f k
the correctness
is dominated
yg and
return 1
pick some
called hyperedges
third branches
empty return
an number
in mintr
these branchings
ffn ffn
the branchings
rossmanith in
by kavvadias
return fxg
branching tuple
transversals t
kavvadias and
cardinality 3
fx zg
hypergraph transversals
associated hypergraph
monotone disjunctive
since case
hypergraphs a
270 k
approximating coloring
branching for
branching b
6737 n
actual branching
mintrexp h
and stavropoulos
is case
no 2
most ffn
h return
degree hypergraphs
mintrnonr algorithm
input hypergraph
output smallest
reductions have
of niedermeier
niedermeier and rossmanith
branching number is
for case 4
o 1 6737
4 subcase d
2 edges are
the minimum transversal
number cases for
subcase d 2
is the hypergraph
number branching number
case 4 subcase
and rossmanith s
cases for case
the branching number
psi 0 k
of 2 edges
the transversal hypergraph
branching number branching
of the branching
branching number cases
a hypergraph h
t r h
1 6316 n
rossmanith s algorithm
the branching tree
transversal hypergraph problem
3 hitting set
for a hypergraph
minimum transversal problem
o 1 6316
running time of
in o 1
of the algorithm
a hypergraph is
number of 2
d 2 x
k formula for
o 2 270
1 6538 n
for branching number
the branching numbers
formula for branching
for psi k
1 gammaff n
3 uniform hypergraphs
3 uniform hypergraph
x is dominated
o 1 6538
cases 1 3
0 ae v
branching numbers for
1 6737 1
transversal of h
values for psi
6737 1 gammaff
the case analysis
the running time
o 2 n
of a hypergraph
time o 1
v 0 ae
the final case
a running time
runs in o
h 0 with
a vertex x
by niedermeier and
mintr 0 h
for minimum transversal
space and runs
0 with vertices
jt r h
values of psi
of mintr h
and rossmanith 13
worst case branching
needs polynomial space
hypergraph with n
still valid and
in the transversal
o 1 6484
edge fx yg
1 6484 n
r h j
to use exponential
edges of cardinality
time of mintr
use exponential space
with maximum d
the smallest transversal
a hypergraph and
branching number of
algorithm mintr h
smallest transversal of
of psi k
a hypergraph with
hypergraph h 0
mintr h is
2 edges is
1 4656 ffn
using psi 0
for ordinary graphs
poly n delta
running time in
is o 1
vertex x is
a transversal of
maximum independent sets
one 2 edge
f h is
runs in time
if h is
of h if
2 edges and
in the in
of all minimal
time spent in
in the tree
of f h
the correctness of
in time o
an independent set
and runs in
is an integer
the in the
for every v
for this case
is dominated by
with n vertices
the worst case
algorithm runs in
time of o
h is the
two algorithms for
and no 2
algorithms for related
return 1 if
d k x
edges e such
at most ffn
give the branching
270 k n
rank 3 hypergraph
having n variables
qn is an
vertex x with
edges are all
monotone disjunctive normal
a loop fxg
fxg 2 h
empty return 1
maximum d x
actual branching numbers
loop fxg 2
r uniform hypergraph
is a transversal
pick a vertex
cases 0 3
cover problem for
occur in h
o poly n
and space o
some vertex x
of psi 0
of rank 3
h input hypergraph
with associated hypergraph
with this parameter
efficient fixed parameter
q 2 edges
x with maximum
one worst case
sat decision and
all minimal transversals
present two algorithms
fx yg and
branching b and
no 2 edges
minimum transversal the
input hypergraph h
dominated by some
by kavvadias and
x is continous
every v 0
1 6737 n
dualization of monotone
2 edge fx
time o 2
sets of bounded
hypergraph h output
the first exact
h output smallest
the h x
in 3 uniform
psi k we
3 hypergraph is
polynomial local work
fixed parameter algorithm
problem where one

corpus/krapavin2000-test/1006427.txt
cells
paging
paged
mobile
devices
device
round
cell
wireless
xr
strategy
nd
rounds
located
quasipartition
minimizes
rst
nding
convex
page
terminal
location
js1
reporting
oblivious
np
pages
chances
telephony
cgt
heuristic
station
stations
cellular
users
strategies
probabilities
enumerator
lemma
lb
xed
boundary
strictly
achieves
hessian
s1
radio
terminals
jtr
j2zr
j2ur
zr
establishing
specically
phone
inductive
aord
eps
dened
tra
320
adaptive
approximation
dene
proposition
family
ciently
gsm
sd
groups
hardness
interior
extremum
lasts
links
317
sr
gd
combinatorial
restate
divisible
yellow
completes
maximize
managers
backbone
search
partition
sign
delay
denite
battery
convexity
uncertain
multidimensional
signals
derivatives
t1
expectation
ratio
broadcasts
consumes
ept
matation
strightforward
4approximation
intersystem
3y
320expected
constantfactorapproximation
repag
inator
repaging
proximation
j2lr
jsr
persisted
cardinality3
317expected
amotz
podc
lagarias
etsi
fam
leah
mobility
probe
searching
denominator
predetermined
personal
generalizes
management
standards
looking
hosts
intractability
nds
johnson
sizes
units
muthukrishnan
awduche
merritt
symmetricity
burkard
shvartsman
epstein
denom
roams
tia
grater
intern
noy
conducts
across
s2
motivated
optimally
base
maximizes
p1
fr
suspects
generous
asaf
roaming
garey
ily
yishay
quadratic
product
pr
directories
mansour
lookups
prevailing
probed
xd
polynomial
expected
signature
eia
lasting
websites
guessed
identier
recursive
calls
seek
expression
cardinality
divide
defective
sx
presently
aects
advisor
newfoundland
predened
expected paging
conference call
cells paged
of cells
call problem
mobile devices
a strategy
mobile device
all mobile
minimizes expected
paging of
the cells
the conference
rst round
the strategy
paged until
paged in
device is
strategy that
devices are
expected number
the device
that minimizes
k cells
cells in
all strategies
the expected
last k
location area
any strategy
one mobile
strategy t
from above
the rst
of nding
device i
cell j
nd a
a cell
located in
is located
the devices
strictly convex
paging for
wireless links
c cells
xr e
are paged
dynamic programming
are found
mobile users
each round
e times
to nd
lemma 5
be paged
a wireless
cells to
above by
has expected
location management
base station
nd the
bounded from
to page
devices have
all devices
located among
the quasipartition
product y
quasipartition problem
paging across
paging equal
xr m
paged by
wireless conference
under delay
page the
most e
until all
can nd
strategy of
base stations
expression on
our heuristic
cells and
of groups
strategies of
proposition 4
of length
np hard
is np
located there
delay constraints
ciently nd
the cell
by lemma
of devices
a mobile
a device
of expected
all cells
the product
round by
round r
performance ratio
terminal is
from below
convex optimization
each mobile
devices in
devices that
are located
pages cells
wireless system
multidimensional convex
minimal expected
establishing wireless
approximation solution
mobile telephony
telephony systems
oblivious algorithms
location areas
search theory
the enumerator
page cells
may page
that pages
expensive wireless
to lb
paging strategy
contains cells
bound the
cell where
most d
a location
that page
of establishing
the boundary
observe that
at most
boundary of
chances of
found is
of time
the expression
been found
problem is
groups for
these cells
round and
length d
nding all
cells during
devices we
reporting and
enumerator is
conference calls
problem to
a i
cells are
the inductive
m 1
cells that
and paging
quadratic assignment
two mobile
which cells
3 c
13 18
strategy is
instance of
the probabilities
e ciently
the terminal
round the
e k
the instance
any cell
cell this
cellular systems
the function
the search
the system
can bound
a call
approximation algorithm
to search
the sequence
sizes of
the family
the sizes
strategy in
right side
family f
d c
to bound
partition problem
the proof
strategies in
the conference call
of cells paged
conference call problem
number of cells
all mobile devices
that minimizes expected
the rst round
mobile devices are
minimizes expected paging
devices are found
expected paging of
the expected paging
a strategy that
expected number of
paged until all
strategy that minimizes
cells paged until
call problem is
the last k
until all mobile
paged in the
last k cells
nd a strategy
strategy of length
the device is
in the rst
of the conference
of the strategy
least one mobile
expected paging for
device is located
one mobile device
paging of the
sizes of groups
from above by
the expected number
in each round
mobile device is
e times the
set of cells
in the cells
cells paged in
bound the product
strategies of length
the expression on
at most e
expression on the
of our heuristic
most e times
expected paging equal
under delay constraints
k cells and
the product y
each mobile device
all strategies of
cells paged by
chances of nding
the quasipartition problem
among the last
device i we
all strategies in
the strategy t
devices have been
any strategy of
mobile device i
are found is
expected paging across
rst round and
of groups for
has expected paging
paging equal to
is np hard
is bounded from
at the boundary
bounded from above
have been found
we can nd
problem is np
performance ratio of
the performance ratio
to the conference
13 18 19
problem of establishing
e ciently nd
instance of the
of the cells
the cells in
of cells to
subset of cells
lemma 5 4
show that the
need to search
e d c
the boundary of
at most d
units of time
the base station
mobile telephony systems
cells to page
rst round by
boundary of h
number of devices
the terminal is
minimal expected paging
paging of any
cells are paged
be paged in
multidimensional convex optimization
the enumerator is
of expected paging
page the last
equal to lb
call problem the
minimizes the expected
only these cells
may page the
located among the
expensive wireless links
that may page
of nding all
a location area
cells and only
across all strategies
wireless conference calls
be a strategy
call problem for
the devices that
is a strategy
with c cells
the minimal expected
a wireless system
if the device
for a strategy
value of expected
a cell j
a strictly convex
use the inductive
paging of a
establish a call
xr m 1
that the conference
establishing wireless conference
given that at
ciently nd a
devices are located
wireless links and
two mobile devices
nding all mobile
all the devices
among all strategies
for each mobile
the sequence s
reporting and paging
is located among
paging across all
mobile devices in
proposition 4 1
are located in
unit of time
by lemma 5
a strategy of
the quadratic assignment
1 k c
a mobile device
ratio of our
and only these
can bound the
that at least
the instance of
right side of
is strictly convex
of mobile devices
a i r
devices in the
i we dene
quadratic assignment problem
all cells in
of establishing a
theorem of the
cells in the
we can bound
the right side
the sizes of
located in the
the cells that
personal communication systems
2 3 c
lemma 5 3
cell where the
the cell where
of length d
proposition 4 2
lemma 3 1
1 the expected
be the event
from below by
recall that by
the value of
side of the
value of e

corpus/krapavin2000-test/1007454.txt
pivot
cycling
expand
simplex
cycle
steepest
tableau
2k
degeneracy
row
degenerate
indefinitely
iterations
column
devex
iteration
tie
nonbasic
columns
behaviour
expanded
pivotal
gill
pivots
proposition
shall
perturbation
tolerance
objective
cyclically
dantzig
cycles
primal
eigenvalues
coefficients
unbounded
vertex
acceptable
lp
wolfe
fletcher
a11
beale
bqpd
a21s
osl
shifted
resolving
ffi
odd
criterion
dual
indefinite
selection
arithmetic
deltag
minos
redundant
edge
breaks
analyse
inexact
constraint
leave
harris
coefficient
roundoff
unshaded
enter
largest
negative
stalling
feasibility
ratio
pattern
scaling
reset
guaranteed
simplest
resolves
nonnegative
preprocessing
gamma
terminate
ff
relied
preprint
repeat
perturbed
candidate
anti
stay
j0842
2262
minos5
2247
gammaaa
coap
12the
reinversion
mckinnon
ifa
xpressmp
zrnig
likelyhood
087
gammaa120
unboundedness
balin
reversed
signs
conjugate
sufficient
repeats
entries
leaving
inequality
gomory
4x
returns
characteristic
encountered
prevent
breaking
theta
breaker
detached
tableaux
direction
infeasible
rows
matrix
feasible
gammaffi
enlargement
normally
singular
extra
numerical
ski
summarises
recalculated
cplex
resetting
julian
perturbing
nonzero
min
entry
tance
tightest
11a
itera
whilst
unaltered
impor
broken
bounds
destroying
relaxes
characterise
rule
break
simplify
stability
encountering
interchanged
solu
pass
finiteness
lexicographic
eventual
basis
met
escape
pivoting
visits
invert
formed
prohibitively
alternation
slack
epsrc
analysed
termination
danger
award
submatrix
sole
55
induction
zeroes
strict
established
introducing
131
elsevier
violations
sided
straightforwardly
a 11
6 cycle
the expand
11 a
cycle examples
a 12
cycle pattern
steepest edge
the pivot
x 2k
2 6
the 2
the simplex
simplex method
2k 2
most negative
reduced cost
pivot in
negative reduced
expand ratio
in row
ratio test
tableau t
largest pivot
row 2
column selection
column 2
row 1
degenerate vertex
basic variables
a 21
column 1
two iterations
the steepest
cycle indefinitely
row selection
expand procedure
pivot row
it follows
the objective
and sufficient
follows that
objective function
12 a
11 1
using expand
edge column
necessary and
sufficient conditions
x x
we shall
the degeneracy
simplex algorithm
11 which
of iteration
start of
prevent cycling
expand row
the nonbasic
the pivotal
odd iterations
pivotal column
objective row
degeneracy in
full step
iteration 2k
shifted cyclically
the devex
gill et
iteration 2
table 4
the basis
min step
pivot is
of expand
to leave
g k
2k 1
11 0
the start
acceptable if
to cycle
leave the
of column
in iteration
theta 2
proposition 1
guaranteed to
in column
columns are
selection rule
5 19
the values
selected in
s k
cost criterion
cost row
also cycle
characteristic equation
than column
repeat after
unique pivot
cycling examples
unbounded direction
cycle order
step ff
resolving degeneracy
feasibility tolerance
chosen rather
16 holds
inexact arithmetic
for cycling
without scaling
even iteration
expand method
conditions for
2 theta
a tie
such examples
exact arithmetic
simplest possible
s gamma
t 1
be chosen
gamma s
the examples
19 5
shall now
is acceptable
variables are
in table
variable values
in exact
the variable
cost column
real eigenvalues
11 x
now shown
satisfies its
are as
to enter
when using
the necessary
iteration the
the changes
cycles for
lp problem
cycling in
of pivot
iterations are
the largest
linear programming
if and
iterations and
x r
test returns
redundant if
2 constraint
so there
of iterations
return to
the conditions
k 0
in iterations
as given
row in
the min
m 1
12 1
m 2
changes in
terminate in
examples a
the behaviour
this occurs
enter the
is chosen
iterations we
the dual
of table
2 matrix
a degenerate
columns to
vertex is
entries in
2 of
to repeat
reversed then
even iterations
cycling still
as beale
gamma a11
cycling example
shows is
new expanded
nonbasic variables
13 55
problem cycles
nonbasic variable
pivot will
2 6 cycle
a 11 a
the 2 6
11 a 11
6 cycle examples
6 cycle pattern
x 2k 2
the simplex method
expand ratio test
the most negative
a 11 1
most negative reduced
the expand ratio
negative reduced cost
if a 11
of the expand
a 12 a
the largest pivot
in row 2
the steepest edge
the basic variables
x x x
12 a 11
the objective function
a 11 which
leave the basis
in row 1
necessary and sufficient
it follows that
and sufficient conditions
steepest edge column
edge column selection
pivot in row
the expand procedure
and a 12
row 2 is
the pivot in
a 11 0
the necessary and
sufficient conditions for
in table 4
at the start
11 a 12
11 which is
in the 2
the start of
2 theta 2
are as given
to leave the
2k 2 a
to prevent cycling
the objective row
expand row selection
tableau t 1
the pivotal column
a 11 and
a 12 1
gill et al
enter the basis
when using expand
the changes in
column 2 of
that a 11
5 19 5
start of iteration
is acceptable if
return to a
in column 2
of the simplex
if and only
the values of
to enter the
in exact arithmetic
the simplest possible
values of variables
is redundant if
redundant if a
rather than column
reduced cost criterion
1 in iteration
given in row
degenerate vertex is
cost column selection
6 cycle order
breaks the 2
the expand row
column selection rule
cycle examples the
pivot in the
so it follows
11 x 2k
a 11 x
that a 12
the min step
columns are selected
a degenerate vertex
tableau t 3
21 a 11
the pivot is
acceptable if and
gamma s gamma
be in row
the full step
reduced cost column
be chosen rather
variable values are
ratio test returns
that the pivot
in iteration 2
values are as
the expand method
will be chosen
and only if
we shall now
only if a
columns to the
at every iteration
theta 2 matrix
conditions of proposition
g k 0
11 1 2
and the expand
the simplex algorithm
1 a 11
2 is acceptable
1 of table
have now shown
since a 11
simplex method to
step is taken
of column 1
follows that a
are selected in
are the simplest
the variable to
11 a 21
of proposition 1
to terminate in
so there is
by the most
values in table
as given in
1 is chosen
in the objective
selected in the
if the conditions
it follows from
examples in this
and it follows
for all k
of table 3
variables at the
a 21 a
in the values
the conditions of
of the basic
for the values
which is true
the first iteration
2 5 19
determines the maximum
is a tie
variable columns shifted
feasibility tolerance ffi
any two iterations
unbounded direction is
the iteration are
have the 2
over two iterations
direction is found
area in figure
4 columns to
row 1 in
2 of t
the x variable
a complex conjugate
holds which implies
column selection criterion
the x columns
of pivot row
and cycle indefinitely
11 gamma a
cycles when using
the nonbasic variables
and 4 columns
after two iterations
iteration 2k 1
of iteration 2
chosen rather than
x x pivot
degeneracy in linear
cycle pattern will
problem is unbounded
2 is chosen
pattern will be
resolves the degeneracy
3 a 11
so the pivot
a 12 0
cycle order then

corpus/krapavin2000-test/1007523.txt
students
participants
emacs
testing
compilation
continuous
developer
regression
suites
suite
developers
eclipse
tests
junit
java
staff
worked
statistically
ide
feedback
plug
development
errors
student
ps1
prioritization
grade
athena
tool
notification
who
tools
habits
treatments
questionnaire
productivity
impressions
experiment
ps2
success
volunteered
experience
hours
my
qualitative
distracting
volunteers
threats
effects
ignorance
prioritizing
enjoyed
participant
distract
saff
montana
dialup
unimplemented
coursework
distraction
failing
factoring
edits
assignments
monitoring
edited
treatment
had
subjects
magpie
perceptions
keystroke
incremental
felt
participate
software
monitored
years
recommend
170
programmers
demographics
editing
code
mit
users
got
circumstances
clicking
mock
debugging
failed
predicts
fix
mode
questions
reported
teaching
skeleton
predictor
me
distracted
enjoying
tas
javadoc
annoyance
manual
didn
regarding
completed
tasks
manually
maintenance
editor
modern
ernst
participation
caught
ins
quickly
text
functionality
encouraged
nominal
benefits
validity
striving
elbaum
predictors
ran
tested
experienced
feed
excluded
did
logs
wasted
benefit
environments
incidental
demographic
helping
compiled
compile
buffers
shadow
believed
quantitative
experimental
empirical
likely
dev
accomplishing
cursor
refactoring
myampersandldquo
classroom
save
deadline
controlled
directory
wanted
reporting
residual
detrimental
tomography
demonstration
familiar
group
444
watch
excess
surprised
programming
frequent
rapid
passed
knew
cont
louis
27th
professional
remotely
leveraging
methodology
assignment
don
saved
running
window
compiling
files
envi
sebastian
interoperability
helped
numeric
suggestions
said
privacy
continuous testing
continuous compilation
the developer
test suite
problem set
students were
the tools
time worked
the tool
test suites
statistically significant
students who
regression errors
emacs plug
testing tool
a regression
problem sets
the tests
plug in
development environment
regression testing
participants who
of continuous
those who
regression error
all students
control group
mode line
that continuous
the emacs
the continuous
the code
were provided
success rate
regression test
developer s
course staff
the students
participants were
the study
provided test
the participants
compilation and
test cases
the experiment
tests in
the mode
the provided
years of
testing in
that students
who had
testing can
manual testing
using continuous
throughout development
participants had
6 170
incremental compilation
test factoring
java experience
non participants
development time
a test
to complete
to run
of students
software engineering
our experiment
provided with
tests are
notification of
said that
with continuous
development environments
of test
likely to
the test
threats to
statistically significantly
to validity
who tested
rapid feedback
participants with
would recommend
significant effects
experimental treatments
run tests
multiple choice
java ide
participants reported
one said
ide s
failing tests
to students
ignorance time
fix time
who were
a continuous
the student
the assignment
testing group
group was
recommend the
programming experience
testing and
tests that
tools and
as continuous
by continuous
program changes
a developer
feedback about
test first
who used
during development
suite and
testing were
complete the
and continuous
to participate
more likely
they were
the experimental
the course
did not
work habits
staff provided
wasted development
modern ide
test frequency
delta debugging
student solutions
emacs and
development 3
testing uses
student developers
emacs development
test driven
junit test
the staff
compilation group
in eclipse
better code
qualitative feedback
regression tests
using emacs
tested throughout
impressions of
perceptions of
testing during
students used
used continuous
saff michael
were encouraged
test prioritization
qualitative results
testing continuous
some participants
continuous execution
0 years
several participants
asynchronous notification
the suites
test errors
mock object
shadow directory
driven development
creation for
single keystroke
and emacs
first development
david saff
volunteered for
to programming
programming by
they would
of participants
effects that
we measured
those without
in emacs
compilation errors
some students
90 would
running tests
mit s
plug ins
tools were
initial development
significant at
by demonstration
programming task
editing by
compilation a
the error
in software
to others
a controlled
of java
the continuous testing
of continuous testing
emacs plug in
continuous testing tool
the mode line
a continuous testing
the emacs plug
continuous testing can
run the tests
likely to complete
continuous testing in
with continuous testing
a regression error
the course staff
continuous compilation and
continuous testing and
after the study
the problem sets
a test suite
using the tools
continuous testing group
who were provided
regression test suite
a regression test
years of java
were provided with
of continuous compilation
the problem set
the continuous compilation
all students were
tool to others
the control group
statistically significant effects
recommend the tool
the developer s
would recommend the
continuous testing were
threats to validity
using continuous testing
that continuous testing
complete the assignment
more likely to
testing can be
to complete the
the tool to
tests in the
of the code
the test suite
regression tests in
continuous testing uses
continuous compilation a
the provided test
a control group
that we measured
asynchronous notification of
saff michael d
provided test suite
90 would recommend
that continuous compilation
first problem set
that students were
significant at the
of java experience
and continuous testing
test first development
of a regression
compilation and continuous
the staff provided
mock object creation
provided test suites
the test suites
wasted development time
students were encouraged
for test factoring
one said that
were given a
those who had
test driven development
object creation for
said that it
perceptions of the
a continuous compilation
continuous testing to
by the course
than those without
editing by example
continuous compilation group
volunteered for the
a java ide
significantly more likely
who used continuous
participants who were
david saff michael
completed the assignment
provided by continuous
creation for test
modern ide s
in software engineering
in our experiment
of a test
running the tests
programming by demonstration
using the tool
the tools and
this paper reports
in the mode
a statistically significant
the study and
number of participants
with the tools
by the tool
that the tool
the success rate
in the background
to run the
michael d ernst
5 0 6
see section 3
of the tests
of the tool
of the experiment
the test cases
as noted above
lines of code
the file input
the shadow directory
lightweight structure in
the tools were
whether the extra
of tests that
distracted by the
continuously run regression
feed back is
participants using continuous
feature in modern
treatment predicts correctness
2 they did
ide s such
participants did not
development time via
background as the
6 170 course
practice of test
i was distracted
enjoyed using the
a different development
controlling the size
evaluation of reading
0 7 i
tests are run
mit s 6
participants and non
impact analysis and
problem sets were
testing during development
risk of type
students who volunteered
a single keystroke
side use of
and 90 would
user perceptions of
reducing wasted development
student use of
quality of information
state based formal
feedback to developers
used continuous testing
were more likely
testing and continuous
tests this paper
no benefit from
such as continuous
4 years of
multiple choice questions
initial failing tests
re ran all
the multiple choice
when developers are
time worked and
which tests are
excess cycles on
incidental features of
the developer edits
the program changes
likely to participate
against the public
other circumstances such
all tests in
testing in practice
success rate and
to run tests
effective regression testing
in development environment
prioritization 36 26
second problem set
provided the tools
run regression tests
residual test coverage
striving for compatibility
evolution of software

corpus/krapavin2000-test/1007526.txt
repok
java
coverage
red
symbolic
precondition
black
treemap
elds
checker
jpf
korat
testing
box
lazy
uninitialized
inputs
trees
specication
preconditions
testera
white
util
initialization
specications
elem
eld
conservative
checking
cr
tests
pc
tvla
symbolically
initialized
cl
generation
pathfinder
destructive
concrete
null
worklist
primitive
koushik
rst
structural
xd
branch
godefroid
ignoreif
fixafterdeletion
marinov
psreanu
deleteentry
structures
manipulating
entry
instrumented
automated
static
software
deos
darko
patrice
public
shelf
isomorphic
sen
del
corina
rover
backtracks
nondeterministically
infeasible
sigsoft
helper
thread
color
foo
cloud
execution
boolean
xi
maine
invariant
remove
counterexamples
tree
predicate
nikolai
k9
tillmann
pelnek
fixafterinsertion
redhasonlyblackchildren
_right_is_initialized
conservative_repok
schulte
astoot
removefirst
_next_is_initialized
_left_is_initialized
scp
verisoft
elems
concolic
_get_elem
rupak
_get_next
programs
heap
code
dierent
backtrack
systematically
initializes
branches
engine
radek
slam
isempty
asml
ecient
predicates
put
aliasing
void
library
wolfram
majumdar
visser
notes
verication
portland
willem
doong
structs
declaration
int
colored
generating
lastly
satisability
threaded
swaps
29th
kingdom
program
acyclic
temporal
uml
created
path
violates
instrumentation
reconstruct
verify
generate
paths
linked
notices
logic
false
shape
e1
oracles
specied
exibility
proach
checkers
exploration
cond
20th
beach
assertion
node
doubly
pointers
unreachable
london
sigplan
object
mem
initializing
dene
engineering
sequences
checks
satises
explores
conguration
parenthesis
constraints
criteria
validating
criterion
behavioral
automating
concurrency
algebraic
symbolic execution
input generation
red black
test input
model checking
model checker
lazy initialization
white box
path condition
black trees
black box
next next
branch coverage
test inputs
input structures
black tree
box approach
the code
the java
the symbolic
input trees
java util
the precondition
input structure
box testing
class invariant
execution tree
structures that
our framework
util treemap
during lazy
if current
color red
uninitialized elds
for black
conservative precondition
generate tests
framework can
software testing
elds and
put and
box test
complex data
to generate
checker to
manipulating complex
of repok
generalized symbolic
execution framework
conservative repok
pc x
generating tests
concrete precondition
tests from
the inputs
the input
generate test
non isomorphic
software engineering
generation for
on primitive
java pathfinder
the conservative
primitive data
checking as
checking to
remove methods
specication based
y pc
jpf model
koushik sen
java treemap
cr null
cl null
solve constraints
java predicate
java predicates
reference elds
as java
code manipulating
unit testing
using model
the concrete
a specication
java programs
of method
y x
test data
the black
on software
the lazy
based testing
and remove
y y
structural coverage
precondition that
public static
data structures
a red
test generation
the model
the coverage
the trees
inputs that
for white
in java
the red
used during
of java
shape analysis
testing criterion
under test
the path
execution and
coverage of
method calls
analysis july
testing and
destructive updates
method preconditions
and korat
isomorphic input
from specications
treemap library
input elds
darko marinov
of put
red return
xd xi
red if
initialized and
checker backtracks
logic engine
patrice godefroid
by get
the repok
symbolically executing
s precondition
conservative preconditions
the jpf
precondition the
s psreanu
precondition by
primitive elds
algebraic specication
pointer assertion
with uninitialized
del xd
repok on
coverage on
program testing
method s
trees we
x y
oriented programs
the shelf
testing proceedings
a symbolic
a java
size 5
static analysis
space exploration
trees up
our symbolic
assertion logic
class node
on reference
the put
and black
code under
corina s
left entry
testing our
an uninitialized
for red
not initialized
based coverage
sigsoft software
notes v
trees of
engineering notes
acm sigsoft
return false
as testing
execution to
should note
constraints on
software model
preconditions can
international symposium
execution of
checking and
also reports
code coverage
thread scheduling
5 september
checking of
a path
of test
code of
test input generation
the model checker
red black trees
red black tree
next next next
the path condition
input generation for
the symbolic execution
the input structures
a path condition
for black box
java util treemap
during lazy initialization
box test input
symbolic execution and
put and remove
symbolic execution of
x y y
to generate tests
model checking to
model checker to
a model checker
to generate test
black box testing
black box approach
trees of size
manipulating complex data
the lazy initialization
symbolic execution tree
generalized symbolic execution
model checking as
the red black
our framework can
a red black
framework can be
x x y
of the code
jpf model checker
the concrete precondition
used during lazy
y y pc
symbolic execution framework
white box test
pc x y
code manipulating complex
checking as testing
the java treemap
and remove methods
white box approach
for white box
the black box
up to a
on software testing
testing and analysis
software testing and
the input trees
using model checking
the class invariant
o the shelf
theory of test
symposium on software
x y x
model checking and
the method s
model checking of
complex data structures
and analysis july
in the java
we should note
with uninitialized elds
black trees we
sequences of put
coverage on the
constraints on primitive
path condition is
non isomorphic input
color red if
the test input
the put and
method s precondition
generate test inputs
as java predicates
in java util
for red black
symbolic execution to
and symbolic execution
y pc x
trees up to
on reference elds
java treemap library
model checker backtracks
of red black
is not initialized
the conservative precondition
red return false
for test input
to solve constraints
checking to generate
that are created
a java predicate
color red return
uninitialized elds and
to test input
del xd xi
assertion logic engine
the jpf model
corina s psreanu
eld is not
pointer assertion logic
the pointer assertion
solve constraints on
generate tests from
our symbolic execution
lazy initialization of
constraints on reference
coverage of the
y x x
y y x
object oriented programs
testing proceedings of
software engineering notes
engineering notes v
acm sigsoft software
sigsoft software engineering
should note that
on primitive data
return false if
a white box
preconditions can be
state space exploration
5 september 2005
the code under
1 model checking
if the path
the input structure
international symposium on
the code of
to a given
a symbolic execution
structures that can
n 5 september
can be used
automated software engineering
proceedings of the
our framework is
30 n 5
20 2006 portland
2006 portland maine
we show how
notes v 30
of the trees
structures that are
data structures that
of the inputs
stop the analysis
generates inputs from
black box fashion
as red black
symbolic execution for
all non isomorphic
encodes constraints on
with destructive updating
current color red
_left_is_initialized cl null
of time partitioning
generating tests from
entry cl current
cl current left
input generation can
of interfaces the
static final boolean
properties of interfaces
during white box
java data structures
validating temporal safety
if current _right_is_initialized
current entry worklist
repok returns true
removefirst entry cl
model checking used
java pathfinder jpf
method under test
null nodes are
the eld to
logic based theory
nodes represent entries
either red or
generating test inputs
a given small
cr current right
testera and korat
inputs from constraints
parameterized unit tests
straight model checking
of conservative repok
right if current
entry worklist removefirst
an input structure
branch coverage on
by symbolically executing

corpus/krapavin2000-test/1007540.txt
selector
mode
steering
robots
robot
modes
controller
team
training
teams
tournament
battery
upgraded
team26
radio
environmental
program
saver
enemy
brightness
rand
spoofing
selectors
droid
battle
deceptive
materials
wars
attack
mode1match
programmer
gps
sleep
raw
jamming
learners
laptop
coded
runs
executions
counterexamples
score
competition
unanticipated
programs
behaviors
situations
controllers
old
reboot
refactoring
unexpected
ore
allies
team20
suite
terrain
preconditions
nearby
profile
operational
augmented
games
simulates
software
rank
matches
chooses
profiling
learner
operating
upgrades
rendezvous
army
augmentation
quantities
modalities
designers
human
daikon
damage
modeling
centralized
selecting
display
routers
adaptability
invariants
detection
abstraction
tournaments
dcpower
rebooting
ncnb
enemies
scouting
team10
game
train
participants
messages
mit
did
abstractions
anomaly
alternately
bad
throws
damaged
radios
contest
refactored
unforeseen
reboots
richer
invoked
failures
wrote
optimizations
policy
additionally
ranking
anticipated
load
phones
unmodified
foresee
replay
correlating
circumstance
aliased
inputs
bugs
augmenting
hardware
generalizes
instructions
circumstances
developers
policies
switch
supscrpt
execu
wished
combat
dissipation
behaved
int
selects
bias
reflections
anticipate
worthwhile
environments
resources
augment
home
render
inclusive
vironment
attacking
particularly
creating
dc
unable
runtime
column
match
maps
learning
upgrade
utilizes
meeting
se
specialized
decomposable
base
default
switching
pick
power
environment
accommodates
selection
denial
won
month
hypothesize
indicate
transitions
applicability
poorly
abilities
coverage
expert
signal
outperformed
interference
location
had
mode selector
program steering
new mode
the mode
a mode
training runs
the robot
modeling step
the robots
original mode
mode selection
multi mode
the program
battery 0
raw materials
the team
each mode
original program
control programs
control program
the original
selector that
the modeling
saver mode
power saver
change rand
program original
battery 1
mode selectors
original upgraded
standard mode
upgraded change
robot control
program state
the modes
the training
droid wars
deceptive gps
change simulates
environmental changes
selector and
the new
hard coded
the old
the controller
new maps
a robot
column gives
new environments
selector may
steering the
environmental change
this environmental
sleep mode
machine learners
0 battery
old mode
selector for
old one
operating conditions
test suite
the base
the models
with program
invariant detection
hardware failures
new controller
our mode
value profiling
the teams
current program
selector in
per mode
mode power
steering technique
original programs
laptop display
2 battery
profile directed
steering is
other robots
radio spoofing
original controller
radio jamming
steering process
new environment
our technique
indicate when
operational abstractions
selector is
resulting models
the laptop
operational abstraction
were true
the programs
did not
modes and
the programmer
dynamic invariant
pick up
when to
training data
target system
controller that
run time
of program
different modes
is operating
a multi
a programmer
applying program
selector chooses
steering can
increased resources
selector was
robots to
team26 s
mode transitions
centralized intelligence
among modes
systems built
if battery
robots are
our tools
mode program
the deceptive
mode brightness
require designers
controller augmentation
that mode
dc power
random mode
runs can
each robot
original environment
brightness battery
mode software
the tournament
mode system
mode sleep
robots in
the spoofing
signal strength
a controller
rank of
each team
interactive program
the upgraded
train on
directed optimization
bias is
mode was
generalizes from
of teams
steering a
video games
policies for
mode is
the technique
the augmented
the system
mode but
conditions but
mode with
invoked when
called program
in operating
robot is
or selecting
appropriate mode
the rank
at run
a software
as desired
the hard
to switch
anomaly detection
runs to
which program
code coverage
program states
program and
sub optimal
program by
mode the
method calls
selecting among
a program
to pick
most similar
might be
a model
the model
our program
score for
such approaches
be worthwhile
machine learning
for program
maps the
new mode selector
the new mode
the mode selector
the original mode
the modeling step
the training runs
a mode selector
the program steering
original mode selector
mode selector that
the original program
original upgraded change
robot control programs
a new mode
battery 1 0
power saver mode
upgraded change rand
program original upgraded
and the mode
a multi mode
of program steering
battery 0 2
mode selector and
the old one
column gives the
old mode selector
environmental change simulates
mode selector may
with program steering
the old mode
this environmental change
mode selector for
when the program
current program state
program steering is
the original programs
mode selector in
standard mode power
program steering process
the hard coded
0 2 battery
the original controller
program steering technique
program steering the
mode power saver
mode selector is
to pick up
0 battery 0
new mode selectors
the new environment
the resulting models
the target system
dynamic invariant detection
that the programmer
of the programs
a test suite
systems built using
in operating conditions
the mode with
sleep mode brightness
which program steering
profile directed optimization
to train on
2 battery 1
multi mode software
built using such
of a mode
when to switch
mode sleep mode
the laptop display
using such approaches
mode brightness battery
new maps the
interactive program steering
called program steering
mode selector was
mode with the
the original environment
mode selector chooses
multi mode system
require designers to
selector for the
the deceptive gps
changes in operating
our program steering
our mode selector
training runs can
the raw materials
augment the original
saver mode sleep
1 0 battery
operating conditions but
random mode selector
applying program steering
in the original
of each mode
operational abstraction is
program state and
original program with
invoked when the
for each mode
the robot control
program steering a
an operational abstraction
rank of the
at run time
the robot is
situations in which
be worthwhile to
of the robot
from the training
of the old
as noted above
approaches based on
per pair of
software controlled radios
specification based analysis
the change column
a random mode
program steering might
compute score for
the augmented program
reports properties that
mode based on
model and scheduling
dc power is
change rand radio
use of self
optimization and synthesis
good respectively bad
during the training
scheduling techniques for
increased resources the
for process management
object to render
round robin tournament
the mode whose
in radio range
in profile directed
use the new
0 score 75
the modes themselves
represents a mode
mode selector which
invokes the new
steering program steering
based infrastructure for
bibliography of interactive
change simulates a
function variants for
point such as
efficiently under normal
that respond to
the original column
is operating as
a hard coded
3 mode selection
a bias is
droid wars competition
accommodates unexpected performance
may also indicate
it is operating
self checks and
instance a particular
information to assist
that each mode
the state satisfies
in new environments
dissipation and signal
if battery 0
generalizes from the
among existing modes
were true of
program steering tool
induced by reflections
state satisfies the
a robot discovers
computing value profiling
s control program
data by running
not affect correctness
signal strength or
and scheduling techniques
battery 0 0
weights to different
the robots were
the modes and
chooses a mode
lines column gives
selects the mode
state program steering
teams with centralized
the teams with
pair of teams
the droid wars
selector is richer
the technique called
range of changes
for program steering
learning step the

corpus/krapavin2000-test/1007547.txt
xpath
xml
stockid
promela
msl
requestlist
macro
register
translation
wsat
web
exp
conversation
int
document
intvalue
g1
i1
bpel4ws
gfsa
outtree
services
gk
schema
intree
spin
mtype
t8
g0
blank
ltl
i3
gencode
sas
payment
message
fig
boolean
guard
service
verification
investorid
t14
accountnum
investor
insertandreplace
attribute
request
sb
inv
qualified
tag
node
macros
expressions
parent
location
declaration
stock
wsci
markchild
tree
t3
transition
checker
bill
i2
i4
ret
hashtable
string
cancel
jwig
markall
embedment
0002
bresult
typedef
xsd
matchinsert
i5
creditcard
bres2
expression
handling
owner
standards
peers
mode
manipulation
predicate
rd
documents
exp2
init
var
exp1
intermediate
specification
code
split
semantics
0001
synthesized
paths
tags
index
reject
latest
operator
composite
ack
array
peer
indices
predicates
9984822
stockids
unranked
owl
ret2
0425
0101134
insertall
ret1
w3c
bres1
bres3
vip01
bpel
0341365
position
prefix
fragment
r1
marked
leaf
iis
57
sent
root
blanks
n6
subexpressions
c2
interacting
composition
syntax
segment
protocol
op
appearance
declared
automata
markup
bandera
wildcard
names
c1
motivating
inherit
children
evaluates
child
nsf
trees
pre
name
embedded
51
records
facto
realizability
broker
occ
ccr
efforts
path
business
delicate
attributes
generates
protocols
exchange
skip
quadruple
msg
career
java
translating
guards
arithmetic
flows
manipulating
initialization
basically
manipulate
terminal
translated
registration
msl type
location path
xml document
web services
xpath expression
of xpath
xml data
type tree
promela code
xpath expressions
to promela
an xml
location paths
an xpath
type node
the xml
translation algorithm
web service
xml schema
in fig
tree sequence
register message
the promela
g1 gk
msl types
equation 2
xml variable
promela translation
the msl
macro tree
the translation
of xml
translation of
an msl
boolean xpath
int 5
stockid in
the stockid
exp is
data manipulation
node test
composite web
requestlist stockid
if macro
xpath location
step stockid
handling of
verification of
of last
code for
last call
node indices
the code
for xml
model checker
xml tree
in promela
conversation protocols
variable register
for macro
qualified names
and xpath
step s
of web
c d
xml documents
software systems
the register
a location
our translation
basic type
code segment
51 to
absolute location
integer variable
node 5
the type
semantics of
the step
last stockid
statement macro
type trees
a conversation
from xpath
stockid of
register requestlist
xpath to
analysis service
tree sequences
to 57
index i1
t g0
marked node
only marked
empty macro
position last
lines 51
qualified name
the xpath
message classes
tool wsat
latest request
conversation protocol
pre calculation
of msl
ltl property
the outtree
t3 requestlist
msl to
document tree
stock analysis
test n
register stockid
relative location
input c
the verification
model checking
hand side
request message
of equation
a type
of node
web based
a macro
syntax rules
service analysis
in xml
the sas
intermediate type
the blank
the intree
each macro
boolean expression
the handling
a step
root node
right hand
the semantics
the input
message being
macro is
normal mode
being sent
techniques presented
if exp
the boolean
indices in
tree in
expressions in
fig 5
output node
input node
type declaration
the pre
a relative
transition condition
ltl properties
processed mode
step int
corresponding promela
stockid i1
payment accountnum
spin is
int intvalue
k split
promela the
of conversation
end model
bresult is
bounded xml
xml manipulating
attribute definition
stockid position
parent reference
attribute var
each msl
xsd int
function gencode
a promela
else skip
side corresponds
blank of
i1 intvalue
from msl
exchange xml
conversation specification
transition t8
intree to
macro trees
t8 and
i2 and
stockid which
copy mode
xpath 22
node value
manipulating software
parent type
schema 23
to 63
single xml
a location path
an xpath expression
an xml document
an msl type
of web services
the xml document
the register message
stockid in the
of xpath expressions
the promela translation
xml data manipulation
the translation algorithm
example 2 3
of equation 2
of an xpath
input c d
in the promela
the msl type
type tree for
a type tree
a node test
a tree sequence
boolean xpath expression
the translation of
tree in fig
the last call
in fig 5
a relative location
51 to 57
a conversation protocol
xml variable register
in our translation
the latest request
n c d
location path is
composite web services
the last stockid
node indices in
for an xpath
node test n
lines 51 to
an if macro
the only marked
verification of web
the type tree
only marked node
msl to promela
stock analysis service
xpath location paths
if exp is
the pre calculation
a macro tree
based software systems
value of last
web service analysis
service analysis tool
relative location path
message being sent
web based software
analysis tool wsat
xpath to promela
the semantics of
equation 2 the
the handling of
the input node
in fig 4
the techniques presented
techniques presented in
of xml data
in fig 1
in equation 2
in the register
right hand side
presented in this
shown in fig
set of macro
of an xml
translation of xpath
attribute definition for
that exchange xml
bounded xml data
the stockid of
a single xml
of conversation protocols
xml tree sequence
corresponding type tree
and xpath expressions
verification of xml
the msl types
member is of
promela code segment
the location path
xml schema 23
a k split
xml manipulating software
stockid i1 intvalue
promela code for
input type node
of macro trees
hand side corresponds
on basic types
when g g1
ltl properties of
xpath expressions we
translation algorithm which
register requestlist stockid
the step stockid
xpath expressions in
g t g0
location path for
translation of equation
latest request message
the promela code
side corresponds to
for equation 2
semantics of xpath
xml document tree
the type node
xpath expression is
macro is generated
given an xml
absolute location path
promela translation of
its parent type
the blank of
test n and
an empty macro
an absolute location
step stockid in
constitute the basis
leaf node value
document in fig
composition of web
to promela the
from xpath to
location paths in
back end model
paper constitute the
of the xml
of node indices
set of node
our translation algorithm
of the msl
in example 2
the boolean expression
code for the
the code for
for example when
is of type
translation of the
to the verification
a step s
path for example
the output node
the normal mode
the evaluation of
evaluates to true
that corresponds to
this paper constitute
model checking techniques
which records the
corresponds to the
equation 2 is
and the translation
presented in fig
a root node
the resulting tree
the right hand
if g is
for example the
the appearance of
side of equation
given in example
g if g
is generated for
of software systems
fig 5 is
the generated code
is a set
is not hard
not hard to
from left to
set of values
a set of
hand side of
the root node
a list of
in fig 6
evaluation of the
techniques to the
is embedded in
or a set
left to right
to the whole
loop searching for
requestlist stockid 0001
analysis of interacting
generated promela code
a promela code
from msl to

corpus/krapavin2000-test/1007763.txt
median
configuration
nk
bins
weight
guha
sampling
weights
0it
clustering
indyk
balls
dbe
randomized
nonnegative
thorup
bin
interpoint
krw
nmaxfk
kr
approximate
black
assignment
reals
successive
thrown
box
distances
plaxton
jb
polylogarithmic
ng
probability
lemma
ball
online
uniform
claim
sufficiently
nonzero
failure
postprocessing
facility
weighted
sohler
mettu
coupon
coresets
log
chernoff
extraction
brevity
metric
opt
sample
frac
maxfk
x2x
recurse
sub
distance
rw
samples
remark
collector
fix
succeeds
bk
bernoulli
running
demands
incomplete
appearing
diameter
gaussians
variant
partition
preceding
closest
nonempty
covers
sublinear
approximation
learning
mixtures
triangle
christian
ju
union
establish
configurations
success
develop
gereon
kobbi
raskhodnikova
2cost
monemizadeh
npg
morteza
gyeongju
frahling
sofya
aside
italic
trials
invocation
incur
landed
straighforward
redistributing
commensurately
expends
nonnegligible
medoid
ask
asks
deterministic
rapidly
quick
streams
succeed
1w
prams
nissim
prioritize
sedona
charikar
ratio
runs
fraction
remainder
ptas
tk
feldman
mishra
twenty
viewing
annual
simplifies
unweighted
feeding
443
toss
shai
throughout
generality
belongs
location
vacuously
ug
throw
mistake
lie
penalty
bounds
objective
trouble
medians
stream
fx
iff
produces
inequality
nearest
logarithmic
425
tosses
omits
adam
lemmas
combinatorial
center
ally
neg
foundations
korea
257
crude
tations
2t
arizona
appropriately
substantially
corpus
favorably
unsupervised
hides
greg
statistical
iterations
probabilistic
widely
paragraphs
197
remarked
constituent
doubles
covered
k median
median algorithm
median problem
1 configuration
o 1
k o
1 approximate
uniform weights
approximate k
sub bins
successive sampling
o nk
k configuration
configuration x
guha et
sampling algorithm
step follows
input points
cost x
lemma 2
weights k
complete sub
arbitrary weights
a k
log ng
the k
m o
total weight
an m
high probability
any positive
our sampling
an o
r w
weight of
positive real
m configuration
nk time
online median
clustering variant
indyk s
al 5
black box
k 0
small space
o k
the uniform
r d
with high
w f
bins is
1 assignment
nonzero weight
real such
median algorithms
running time
n k
k log
most e
in u
the weight
in o
that 0
sufficiently large
k means
configuration with
constant factor
the running
0it 0it
weights algorithm
weight r
interpoint distances
nmaxfk log
box k
kr w
our successive
incomplete sub
o nmaxfk
a approximate
failure at
problem instance
0 i
i t
of arbitrary
facility location
a configuration
a x
f m
the black
w u
a sufficiently
of points
failure probability
point y
an assignment
of uniform
claim then
its clustering
nonnegative reals
box algorithm
point weights
log n
m 0
approximation ratio
all i
randomized o
extraction technique
u j
the claim
e b
m a
approximate algorithm
the online
desired approximation
o n
points x
algorithm of
follows from
j u
assignment we
sampling technique
balls x
uniform demands
demands k
dbe balls
o krw
standard chernoff
algorithm small
our uniform
ng time
nk 0
bin i
sub bin
at most
weight function
w x
success probability
w g
of failure
we let
cost at
probability of
for any
point in
s i
configuration we
large choice
m bins
real there
any randomized
good points
approximate clustering
s algorithm
that w
with probability
is o
brevity we
a ball
produces an
metric space
holds with
f i
u i
the input
location problems
of nk
denote the
of clustering
minimum cost
and k
the distance
d x
from lemma
configuration from
a successive
cost i
algorithm for
to develop
x denote
the median
i w
assignment with
succeeds with
has cost
constant fraction
configuration by
i such
runs in
second step
a black
then follows
et al
small range
first step
in x
x we
distance function
points a
above algorithm
the points
k median algorithm
k median problem
o 1 configuration
k o 1
o 1 approximate
the k median
approximate k median
1 approximate k
a k o
guha et al
step follows from
m o 1
0 i t
that 0 i
complete sub bins
uniform weights k
weights k median
the uniform weights
with high probability
for any positive
log n k
the total weight
for the k
of arbitrary weights
algorithm for the
et al 5
such that 0
our sampling algorithm
k configuration x
point in u
of uniform weights
o nk time
case of arbitrary
at most e
case of uniform
an m configuration
o 1 assignment
k median algorithms
indyk s algorithm
median algorithm of
in o nk
real such that
a k median
an m o
successive sampling algorithm
failure at most
of failure at
an o 1
any positive real
an o k
the black box
total weight of
set of points
the running time
the input points
a positive real
a sufficiently large
j u j
for the uniform
its clustering variant
sub bins is
most e b
black box k
n k o
the online median
definition of i
o nmaxfk log
positive real such
second step follows
median problem that
uniform weights algorithm
online median algorithm
our successive sampling
median problem and
1 configuration with
median algorithm on
nmaxfk log ng
1 configuration we
median algorithm for
a k configuration
for all i
with probability of
probability of failure
weight of the
from lemma 2
first step follows
all i such
black box algorithm
desired approximation ratio
obtain a k
lemma 2 7
e k 0
k log n
of the weight
running time of
choice of such
m a b
the desired approximation
o k o
for the case
o k log
follows from lemma
is an m
cost at most
median algorithm is
claim then follows
standard chernoff bound
median algorithm to
1 configuration from
incomplete sub bins
median problem the
produces an o
bound of nk
demands k median
0 j t
a standard chernoff
an m a
sufficiently large choice
of input points
in u to
of our sampling
our uniform weights
uniform demands k
any k configuration
and its clustering
exists a sufficiently
of small space
configuration with high
box k median
1 approximate algorithm
a successive sampling
configuration we then
algorithm small space
log ng time
i t 0
positive real there
weight of any
r w k
the uniform demands
randomized o 1
w f i
in o nmaxfk
that r d
successive sampling technique
d x y
denote the set
the case of
sampling technique that
compute a k
real there exists
the point i
large choice of
m and any
t 0 j
most e k
point y in
the claim then
failure probability of
the first step
of such that
lemma 2 3
i such that
the failure probability
a randomized o
time algorithms for
factor approximation algorithm
exists a positive
the second step
union of the
a black box
running time is
the union of
sufficiently large constant
a constant fraction
problem and its
x in x
our lower bounds
the definition of
the above algorithm
sample of the
j and m
that runs in
and k 0
constant factor approximation
there exists a
time required for
a constant factor
algorithm of section
the weight of
appearing in the
in the definition
can assume without
runs in o
sections 2 and
to the k
that the total
in the running
factor in the
the previous step
particular sub bin

corpus/krapavin2000-test/1007765.txt
opt
mistakes
agreements
clustering
clusters
disagreements
ptas
cluster
jc
wrt
mopt
vertex
vertices
edges
clean
agnostic
singleton
cautious
edge
learning
maximizing
triangles
mistake
partition
fw
pick
lemma
moses
incurs
1ggraph
classifier
ja
erroneous
inside
planted
noise
removal
labels
tester
jn
partitions
picked
approximation
negative
median
sided
correlation
picking
agrees
minimizing
xif
8mopt
guruswami
dissolving
2mopt
2ke
partitioning
lemmas
italic
documents
dense
believes
8i
probability
triangle
affiliations
jzj
whp
venkatesan
doubly
clusterings
charikar
perfect
9i
supscrpt
additive
ij
external
enter
joachims
bonn
22nd
thorsten
exponential
f1
disjoint
suffices
you
maximizes
labeled
density
bj
facility
bad
ments
your
inline
agree
divide
graphs
entity
items
sc
ccr
2e
fu
02
formulation
weights
coloring
penalty
np
goodness
shuchig
persson
ailon
myampersandotilde
whizbang
surajit
mjc
uniq
0105488
lingas
tkdd
immorlica
ganti
raghav
mwith
x3c
ptass
dissolved
0085982
fnikhil
nicole
jansson
sarma
tsaparas
lundell
eva
finley
jesper
afresh
alantha
yigal
ently
yael
mellon
veg
deduplication
mia
dessmark
jjc
theroy
0122581
3jc
giotis
dissolve
charge
firstly
nearly
approximating
notice
testing
1g
please
spectral
weight
polynomial
unsure
mcsherry
2the
gionis
condon
sponding
gnc
avidan
heikki
kaushik
bejerano
newman
hopcroft
chaudhuri
carnegie
aristides
rameter
domly
mislabeled
apx
1167
lies
trying
internal
plus
guess
neighbors
qualitative
random
labelings
avrim
goldwasser
c opt
opt 0
positive edges
of agreements
good wrt
a clustering
maximizing agreements
a ptas
edges between
optimal clustering
jc opt
edges inside
vertex addition
negative edges
between clusters
singleton clusters
minimizing disagreements
mistakes made
of opt
c 0
in opt
for maximizing
0 good
of disagreements
edge labels
agnostic learning
vertex removal
probability at
clustering opt
3 good
internal mistakes
least opt
external mistakes
least 1
the vertex
u i
fw i
non singleton
0 j
this clustering
the mistakes
mistakes of
clustering that
a cluster
at most
a 0
of positive
that jc
jc 0
correlation clustering
divide choose
inside clusters
positive edge
addition step
negative mistakes
of mistakes
factor approximation
the clustering
clusters and
opt and
ptas for
the clusters
clustering on
clustering with
partition of
with probability
ja 0
is clean
a v
u v
0 i
good with
us the
of edges
constant factor
property tester
erroneous triangles
removal step
general partitioning
clusters plus
opt n
addition phase
to opt
edge disjoint
for minimizing
u w
the optimal
vertices in
cluster a
incurs a
the classifier
gives us
the cluster
opt k
wrt a
good partitions
agreements in
or min
agreements we
and v
v w
lemma 13
clustering of
of w
no vertex
clustering is
using lemma
edge weights
same cluster
a cost
k median
opt i
linear cost
that agrees
i g
at least
clustering problem
vertices from
let opt
clusters of
m 0
disagreements in
removal phase
sided noise
clean cluster
agrees as
planted partition
disagreements and
mistakes is
the planted
wrt c
opt 3
agreements of
good partition
2 agreements
positive mistakes
disagreements the
algorithm divide
7 good
1 jc
the edge
clusters in
different clusters
cost due
and cluster
all vertices
exponential in
edges are
made by
w i
high probability
is at
fully connected
this gives
to bound
symmetric difference
opt j
doubly exponential
negative edge
produce a
approximation for
edge u
of negative
a partition
any good
theorem 17
opt denote
to fw
clusters are
cluster and
and negative
notice that
inside a
an additive
the graph
a i
the partition
for at
median problems
most n
the density
denote the
we will
v in
density of
partitions of
get the
of clusters
u and
cluster then
facility location
graph partitioning
pick a
graph g
mistakes in
by opt
argument similar
partition that
random noise
o n
number of agreements
of positive edges
the optimal clustering
the vertex addition
edges between clusters
for maximizing agreements
mistakes made by
number of disagreements
at least 1
fw i g
the edge labels
positive edges between
exponential in 1
at least opt
the number of
number of edges
with probability at
c 0 j
ptas for maximizing
a clustering that
edges inside clusters
vertex addition step
number of mistakes
the vertex removal
good with respect
gives us the
in the vertex
a 0 i
a cost of
probability at least
this gives us
non singleton clusters
inside a cluster
constant factor approximation
a ptas for
factor approximation for
in c opt
vertex addition phase
produce a clustering
density of positive
vertex removal step
positive edges inside
in opt 0
negative edges between
c opt k
clustering opt 0
for minimizing disagreements
clusters plus the
of mistakes made
approximation for minimizing
optimal clustering on
3 good wrt
c opt i
the general partitioning
a constant factor
is at most
number of positive
and v w
v are in
u and v
a high probability
the same cluster
from c 0
incurs a cost
a clustering of
of edges between
plus the number
with a high
if u and
u i s
probability at most
c 0 i
lemma 13 we
inside clusters plus
opt n 2
n 2 agreements
a negative edge
edge labels in
learning to match
vertex removal phase
if the classifier
us the following
clustering that agrees
to fw i
during the vertex
that jc 0
a positive edge
that agrees as
u w and
for graph partitioning
the planted partition
of agreements of
least opt n
w are positive
vertices from c
of opt and
of edges inside
1 jc 0
clusters of opt
internal mistakes of
and negative edges
7 good wrt
cluster a i
clusters in opt
external mistakes made
hold for some
algorithm divide choose
of negative edges
opt denote the
a clean cluster
agrees as much
that jc opt
0 good partition
match and cluster
good wrt a
let c opt
ja 0 j
is 3 good
minimizing disagreements and
cost due to
the density of
present in a
respect to fw
a linear cost
doubly exponential in
partition of w
jc 0 j
facility location and
m 0 a
not know of
of c opt
of any good
to match and
w 2 c
linear cost function
know of any
number of clusters
0 i in
0 j is
let opt denote
account for at
a fully connected
in m 0
denote the optimal
approximation algorithms for
at most n
in a 0
in different clusters
1 in m
v w are
number of negative
for at least
and v are
a i is
the total number
as possible with
possible with the
number of edge
cost of 1
total number of
we get the
of u i
an argument similar
argument similar to
at most 2
at least half
algorithm is as
in the cluster
do not know
much as possible
so we have
edge u v
to denote the
runs in time
values of i
agreements is at
opt 0 in
the negative edges
two edges and
is doubly exponential
of disagreements the
for negative mistakes
negative mistakes on
a clustering c
jc opt and
opt incurs a
is 11 clean
u opt v
and cluster large
all non singleton
extend some of
disagreements and a
clusters and negative
opt the mistakes
pick a w
such a w
spectral partitioning of
both u w
as internal mistakes
clustering on g

corpus/krapavin2000-test/1007767.txt
mst
clustering
agglomerative
gammaffi
clusters
proximity
subquadratic
nns
sparse
cluster
furthest
afn
approximate
ffl
delta
gp
marked
nearest
yao
entry
alta
vista
jp
distance
ffi
euclidean
logn
spanning
iteration
neighbors
tables
sollin
lindenstrauss
closest
ann
entries
neighbor
placed
jth
quadratic
partitions
peleg
union
awerbuch
distances
dimension
retrieves
gammaffl
eppstein
sphericity
gamma2
oh
mark
ball
naive
witness
hides
partition
broder
edges
gammafi
retrievals
randomized
initialize
linkage
chazelle
dist
probability
big
log
gammad
kleinberg
tm
recognition
geometry
johnson
claim
joined
spaces
centroids
retrieving
biology
8i
ir
diameter
bad
forest
phase
representatives
repeat
engine
mining
ingredient
search
radius
theoretic
breadth
kn
connecting
2c
thest
saks
duing
multilication
cowen
mumspanning
spannning
diamater
decrete
manasse
glassman
hiearchical
oher
minimumspanning
dn2
cording
truncated
therein
approximation
web
disjoint
tradeoffs
geometric
handbook
fi
fragments
decomposing
weighted
tering
pens
relatives
afore
kushilevitz
imprecisely
sionality
zweig
xng
closet
appoximation
multigraph
happens
retrieval
history
grows
formulations
lemma
graphs
epsi
diameters
tours
motwani
bles
hierachical
connected
event
status
classification
taxonomies
linial
recogni
indyk
delete
contained
retrieved
grow
statis
berger
plications
unweighted
clus
andrei
jects
hierarchical
connect
returns
dimensional
sketch
gammai
salesman
communica
centered
prob
shrinks
polylog
resorting
mini
ta
eliminating
loop
incorrect
approximating
reduction
curse
implemen
addi
settle
heuristic
dimen
lewis
tice
agglomerative clustering
1 gammaffi
proximity tables
sparse partitions
the points
n ffi
proximity table
points in
b x
an ffl
approximate nearest
the clusters
gammaffi proximity
gp delta
marked 1
mst clustering
in f
x r
f j
placed in
the mst
sparse partition
the agglomerative
approximate mst
jth iteration
log n
of clustering
closest pair
1 ffl
nearest neighbor
o d
union find
furthest pair
ffl afn
ffl approximate
marked 0
ffl ann
o logn
clustering is
connected components
in b
neighbor search
cluster s
e d
iteration we
high probability
clustering algorithm
alta vista
minimum spanning
an approximate
the dimension
entry is
in high
ffl r
union operations
most n
n points
the approximate
distance between
dimensional spaces
naive approach
is marked
clustering problems
clustering with
the distance
are placed
in subquadratic
partition clustering
subquadratic time
approximate nns
mst algorithm
the alta
vista tm
delta proximity
big oh
approximate delta
delta ffl
graph gp
afn table
ffi each
ann ffl
ir d
each proximity
probability that
f 0
spanning tree
high dimensional
the jth
at most
an entry
x 2
running time
point in
that phase
of points
retrieves a
and peleg
ffl delta
clustering rules
a subquadratic
each table
set p
any x
r that
complete graph
with high
clustering algorithms
euclidean space
15 these
tree mst
for approximate
the sparse
b y
computing an
ffl for
data structure
search in
the euclidean
the entry
on ffl
to exact
0 during
takes t
a sparse
graph theoretic
clusters in
marked by
time complexity
a point
o log
table for
clustering of
in p
our methods
the big
a witness
jp j
each iteration
pattern recognition
a union
the clustering
computational geometry
j 2
2 e
n ffl
the graph
by 0
is placed
the probability
the cluster
problems in
of iteration
use such
data points
the nodes
the sphericity
l marked
times initialize
good entries
cluster generated
closest x
dimension grows
clustering rule
as clusters
p contained
sparse graph
the johnson
r centered
factor ffl
eppstein 7
that mst
neighbor algorithms
r proximity
furthest x
an mst
gamma2 gammad
theoretic clustering
for agglomerative
jp operations
j gammafi
quadratic behavior
linkage distance
mst and
cost induced
randomized implementation
exact nns
by retrievals
bad entry
ae e
kleinberg 14
nns algorithms
per table
yao 19
handle n
retrievals of
compute w
tm search
approximate furthest
or furthest
sollin s
b x r
n 1 gammaffi
placed in f
the points in
all the points
points in b
1 gammaffi proximity
in b x
in f 0
2 e d
agglomerative clustering algorithm
the jth iteration
is the cost
x 2 e
points in f
point in p
approximate nearest neighbor
nearest neighbor search
are placed in
gammaffi proximity tables
an ffl ann
is marked 1
of an ffl
with high probability
f j 2
of f j
each iteration we
at most n
any x 2
is at most
a point in
minimum spanning tree
high dimensional spaces
the probability that
e d the
the alta vista
d which returns
ann ffl afn
b y r
the sparse partitions
problems in high
clustering problems in
approximate delta proximity
graph gp delta
a union find
an ffl approximate
the big oh
alta vista tm
gp delta ffl
ffl ann ffl
each proximity table
1 ffl r
most n ffi
the agglomerative clustering
sparse partition clustering
points of f
marked by 0
ffl afn table
of 15 these
n ffi each
ffl approximate delta
in subquadratic time
computing an approximate
in high dimensional
is placed in
o log n
for any x
in each iteration
as the dimension
o d 2
x r that
type of clustering
f 0 during
the cluster s
f j 1
e d which
d 2 n
the distance between
r that are
time complexity o
other applications of
all the nodes
which returns a
the connected components
pair of points
compute the distance
x for any
connected components of
of the clusters
probability that the
the total running
the resulting graph
total running time
properties 1 construct
handle n 1
supporting the following
x returns an
of sparse partitions
dimension reduction techniques
sparse graph g
each table for
gamma n delta
sketch the idea
induced by retrievals
entry is marked
the entries whose
of gp delta
the graph gp
constant from lemma
graph theoretic clustering
structure supporting the
for agglomerative clustering
distance between clusters
a sparse partition
c fi be
delta proximity table
ffi and k
approximate closest pair
marked 1 there
of some graphs
big oh notation
an approximate mst
than 1 ffl
k be as
kn 1 gammaffi
a subquadratic algorithm
awerbuch and peleg
at most jp
15 these results
algorithm of 15
search algorithm of
an efficient construction
in f j
good 0 marked
each class are
p contained in
the johnson lindenstrauss
cluster generated in
the points listed
0 marked entries
neighbors an efficient
1 ffl delta
union x y
d the probability
mark l by
approximate mst and
all gamma n
ae e d
for data structure
iteration we handle
n ffl 2
r proximity tables
takes t jp
data structure consists
approximation factor ffl
proximity table is
mst clustering is
that mst can
of union operations
size n ffi
sum where d
compute w h
randomized implementation of
data structure supporting
subquadratic algorithm for
jp j gammafi
structure for data
returns a point
search cost for
we handle n
1 gammaffi sets
in each proximity
furthest pair of
2 ir d
syntactic clustering of
the same connected
proximity tables each
in p contained
of the agglomerative
the dimension grows
can compute w
and every fi
definition of sparse
union operations performed
l by 1
operations per table
gamma2 gammad 1
and the sphericity
same connected component
retrievals of good
by retrievals of
sparse partitions algorithm
h p a
u retrieves a
applications of dynamic
approximate furthest pair
number of union
regions of small
the sphericity of
x is placed

corpus/krapavin2000-test/1007852.txt
mesh
untangling
untangled
feasible
vertex
meshes
invalid
tangled
untangle
eulerian
ale
lagrangian
jacobian
volume
knupp
objective
barely
2d
1d
patch
quadrilateral
corners
valid
untangles
optimization
conguration
vertices
triangle
interior
boundary
zoom
alamos
inverted
congurations
subcells
rezone
gure
triangles
procedures
volumes
reposition
polygon
3d
connected
corner
remapping
repositioning
repositioned
unstructured
quadrilaterals
quad
eect
simplex
czech
quadratic
movement
rayleigh
polygonal
horseshoe
plassmann
14d
hydrocodes
teran
irving
fedkiw
xing
tetrahedral
xed
fig
los
hexahedral
smooth
laboratory
freitag
rst
gradient
shaded
metal
deformation
shear
13a
intersection
minimized
element
ele
460
aected
ow
taylor
denition
7a
minimization
dr
smoothing
numerical
nd
simulations
modied
polyhedron
continuum
laplacian
convex
mechanics
half
eq
invertible
placement
signed
validity
simulation
quality
area
degenerate
ccw
vachal
17c
raphal
bfoe
subcell
fcgo
0586
15c
endorse
interrupting
7405
gdho
rourke
nonsimplicial
quads
aeoh
demarcating
congura
13c
reevaluated
17a
loubre
39e
tangling
liska
15d
parametrization
berndt
shashkov
redenition
institu
14e
planes
national
forming
dierent
perturbation
improvement
kovalev
pentagon
16c
14c
endeavor
17b
15a
staggered
prague
indiscriminately
everywhere
speeds
center
neighbors
determinants
cavities
15b
impractically
16d
13b
sandia
acd
mikhail
16a
reentrant
14a
hydrodynamics
formed
keeping
ments
maximizing
dotted
spaces
squares
entangled
chasing
relocating
16b
republic
14b
success
dened
moves
positions
xes
uncommon
detrimental
650
feasible set
the feasible
the mesh
optimization procedure
the vertex
objective function
untangling of
the optimization
untangled mesh
set method
the untangling
valid elements
mesh after
connected to
of untangling
for untangling
the untangled
mesh is
set approach
2d meshes
mesh shown
untangling by
invalid elements
arbitrary lagrangian
barely valid
to untangle
lagrangian eulerian
mesh untangling
jacobian at
untangling procedure
elements connected
vertex connected
vertex is
a vertex
meshes by
all elements
x 9
positive volume
invalid element
untangle the
set polygon
elements valid
untangling meshes
zero volume
original mesh
local function
mesh nodes
a mesh
of mesh
step procedure
mesh optimization
the objective
area triangles
inverted elements
one invalid
untangles the
to invalid
tangled mesh
valid mesh
ale simulations
reference jacobian
the tangled
interior vertices
feasible sets
in untangling
this mesh
mesh by
mesh with
set for
mesh the
the gure
mesh vertex
connected elements
quadratic objective
mesh generation
volume elements
and x
make all
x 4
the elements
x 3
corners of
global objective
numerical optimization
by optimization
some elements
8 x
zoom in
boundary vertices
nodes connected
element is
optimization method
in 2d
x 8
los alamos
set is
for vertex
area volume
invalid quadrilateral
mesh improvement
repositioned to
ale methods
eulerian methods
its feasible
lagrangian step
taylor simulation
mesh conguration
untangle meshes
past line
connected neighbors
distinct corners
1d mesh
mesh patch
element volumes
improvement procedures
connected element
rayleigh taylor
node repositioning
solution transfer
unstructured 2d
number based
the jacobian
mesh as
based optimization
decomposition into
elements as
be xed
the boundary
in figure
3 step
elements are
mesh to
optimization of
mesh quality
mesh but
patch of
quad with
zero area
nd three
edge connected
in ale
procedure 4
procedure performs
loop over
feasible region
volume of
eect of
in of
the interior
procedure for
vertex can
b mesh
mesh b
all connected
multi step
of triangle
minimization of
is valid
function at
b fig
for mesh
of element
a 1d
optimization based
optimization approach
alamos national
conguration of
the intersection
triangles and
of half
simplex method
each connected
inequality constraints
meshes in
half spaces
national laboratory
a local
a line
to nd
x 6
meshes with
condition number
shown in
the quadratic
the denition
intersection of
to x
the simplex
one element
eulerian hydrocodes
quadrilateral elements
the barely
respective feasible
g irving
local iteration
and metal
x element
and eulerian
method 17
based rezone
the feasible set
of the feasible
feasible set method
of the mesh
the optimization procedure
feasible set is
feasible set approach
feasible set for
mesh shown in
the untangled mesh
arbitrary lagrangian eulerian
of the vertex
feasible set of
elements connected to
by the feasible
vertex connected to
the objective function
the mesh shown
feasible set polygon
untangle the mesh
the mesh after
shows the mesh
barely valid elements
the vertex is
for a vertex
shown in figure
set for a
the mesh is
set is a
the original mesh
nodes connected to
connected to the
untangling of a
zoom in of
the untangling of
8 x 9
optimization procedure for
mesh after the
to untangle the
connected to invalid
untangles the mesh
x 8 x
least one invalid
the jacobian at
connected to at
all the elements
to the vertex
corners of the
the boundary vertices
global objective function
and the vertex
is a line
area of triangle
lagrangian eulerian methods
3 step procedure
a valid mesh
the untangling procedure
based optimization procedure
a feasible set
mesh improvement procedures
each connected element
for arbitrary lagrangian
a vertex can
edge connected neighbors
to invalid elements
all connected elements
make all the
untangling by the
to nd three
feasible set the
untangling by optimization
condition number based
procedure 4 5
jacobian at v
success in untangling
rayleigh taylor simulation
for vertex connected
which the mesh
optimization procedure 4
unstructured 2d meshes
the elements connected
untangled mesh is
of mesh untangling
its feasible set
which all elements
for one element
set for vertex
the mesh but
for untangling meshes
in the gure
of a vertex
that the feasible
at the vertex
quadratic objective function
the optimization method
eect of increasing
the local function
4 5 which
the procedure performs
vertex can be
feasible set and
set method and
conguration of the
and x 4
to the original
objective function is
set of a
los alamos national
the mesh with
the vertex in
by the intersection
step in which
the mesh as
alamos national laboratory
to at least
the mesh the
to make all
and the optimization
of the triangle
0 12 0
on the mesh
the denition of
the simplex method
center of the
a vertex is
of the objective
to untangle meshes
valid at the
feasible region for
keeping the mesh
feasible sets a
if it moves
simple laplacian smoothing
o f g
mesh after improvement
the mesh while
cannot be xed
vertex for which
by the mesh
the vertex inside
mesh close to
preliminary results are
the old mesh
g irving j
the global objective
the optimization approach
their respective feasible
irving j teran
three distinct corners
all elements were
for mesh untangling
mesh is presented
a vertex connected
old mesh to
the vertex are
vertex is repositioned
jacobian optimization based
with minimal impact
x 9 and
computing method for
procedure for untangling
and eulerian hydrocodes
and reposition the
an ale simulation
untangle meshes by
an invalid element
the quadratic objective
mesh while keeping
is considered valid
meshes by the
vertices connected to
interior vertices connected
method 17 18
untangling the mesh
with all positive
triangle formed by
x as many
denition of element
intersection of half
x element x
smooth and convex
lagrangian step of
accurate solution transfer
elements as possible
eulerian computing method
nd three distinct
make all connected
sets a feasible
because the feasible
the global function
shows the untangled
and x 9
local function at
positive area triangles
into positive area
all positive volume
lagrangian and eulerian
of an ale
making the feasible
positive volume elements

corpus/krapavin2000-test/1007924.txt
hcc
adv
diam
blowup
placement
coff
poff
files
loop
caches
preserves
paging
parent
cache
i2
deact
capacity
caching
child
incurs
ine
coloring
request
competitive
online
landlord
4bk
depth
cooperative
file
i3
anc
swapp
harvest
white
i1
children
guard
lru
colorable
react
ch
diameter
load
incurred
root
off
ultrametric
nuca
bartal
hierarchical
metrics
lemma
outer
requests
competitiveness
epoch
black
serverless
dist
inequality
descendants
moves
nonzero
down
missing
act
ton
arbitrarily
toff
evict
ultrametrics
swapc
sleator
game
confusion
adversarial
feasible
node
claim
placed
adversary
nonuniform
incur
fakcharoenphol
tarjan
squid
nonconstant
retrieval
predicate
preserve
od
internal
hierarchy
invariant
field
cooperate
branch
nonnegative
diameters
relocation
ancestor
copy
rooted
terminates
shell
colorings
placements
consistency
consistent
serves
initially
exchanging
penalty
polylog
departments
opt
deterministic
iteration
fields
cap
lemmas
everywhere
leaf
furthest
ect
incurring
descendant
subtree
guesses
metric
ancestors
removes
separated
tree
seminal
sibling
lines
offline
swap
sized
modify
migration
log
equals
executed
sd
requested
department
amortized
incorrectly
serving
updated
derivation
dren
walnut
empowers
chil
nonidle
xfs
algorith
competiveness
predicament
korupolu
unachievable
wisely
eviction
maintains
approximating
old
discovery
statement
brevity
ects
copies
adds
terestingly
maxu
deactivation
reactivation
gration
partment
erature
operative
evicted
fill
guess
erarchy
deci
ratio
replication
hierarchies
erent
s0
desc
idle
count
awerbuch
lit
pulled
down loop
up loop
the down
capacity blowup
before line
the up
parent diam
cooperative caching
o ine
line 12
hcc algorithm
request sequence
lemma 4
line 4
line 15
hcc problem
of files
outer if
only lines
loop preserves
holds initially
hierarchical cooperative
distributed paging
child of
guard of
incurs a
a placement
the guard
just before
initially because
the hcc
preserves p
paging problem
poff is
x field
loop moves
is white
internal node
main loop
x value
competitive ratio
if statement
b feasible
that line
the caches
the competitive
every iteration
lines that
of caches
every internal
line 14
online algorithm
of adv
constant competitive
placement p
algorithm off
of coff
after line
loop proof
associated coloring
moves to
depth of
children of
loop invariant
tree metrics
and 15
the claim
a file
diameter of
retrieval cost
file f
the diameter
loop and
a capacity
node i
the x
the depth
4 12
an hcc
because root
constant capacity
e child
online hcc
blowup of
second branch
any online
black child
old node
caching problem
preserves i2
ine algorithm
depth 4bk
placement poff
diam parent
constant competitiveness
preserves i1
the harvest
on incurs
statement takes
i1 i2
nonzero value
a request
to 0
last is
invariant of
the capacity
a child
the placement
cost incurred
the files
that modify
an arbitrarily
the outer
e parent
proof every
only line
coloring c
hence line
is colorable
child and
iteration of
inequality is
always consistent
loop terminates
a cost
12 is
blowup in
positive x
and i3
avoid confusion
lower bound
of requests
caches in
in missing
confusion we
ine hcc
4bk 1
poff to
adv is
swapp p
g depth
holds everywhere
15 preserves
files placed
adv generates
adv we
in anc
coff is
placement to
bartal 3
load deact
coff proof
in coff
feasible placement
most parent
root just
global invariant
in adv
penalty f
case off
off incurs
that coff
the cache
x values
line that
initially and
the request
an o
first inequality
lines 4
a nonzero
incurred by
no cost
line 8
the predicate
of line
line 5
parent and
by lemma
its placement
by bartal
child with
every line
that root
lines 14
dist u
off that
cost is
claim holds
descendants of
a loop
p holds
files in
metrics by
arbitrary metrics
colorable and
approximating arbitrary
lru and
a hierarchical
the change
the down loop
the up loop
of the up
just before line
of the down
the only lines
the outer if
only lines that
guard of the
hierarchical cooperative caching
set of files
line 12 is
outer if statement
the guard of
inequality is due
loop moves to
the hcc problem
holds initially because
the competitive ratio
incurs a cost
node i e
every iteration of
loop invariant of
a loop invariant
loop and the
every internal node
4 12 and
to the guard
down loop preserves
before line 4
up loop and
lines that modify
an o ine
12 and 15
the depth of
equal to 0
the diameter of
the main loop
iteration of the
invariant of the
is a loop
a nonzero value
o ine algorithm
the old node
of an hcc
the second branch
12 is executed
ratio of any
i e child
constant capacity blowup
diam parent diam
after line 4
cooperative caching problem
the x values
takes the second
confusion we use
claim holds initially
consistency of coff
parent diam parent
a capacity blowup
avoid confusion we
initially because root
a positive x
statement takes the
execution of line
the hierarchical cooperative
old node i
proof every iteration
i e parent
before line 8
the only line
x values of
moves to its
if statement takes
the x field
only line that
by lemma 4
sequence of requests
new node i
proof the claim
on the competitive
holds initially and
lemma 4 3
competitive ratio of
and y to
to avoid confusion
cost incurred by
the new node
is at most
we use to
preserves the consistency
online hcc algorithm
is colorable and
line 4 or
preserves p because
positive x value
a global invariant
depth 4bk 1
files placed in
ine hcc algorithm
use to refer
set both x
to a nonzero
most parent diam
black child of
files in a
set of caches
4 or line
the capacity blowup
down loop and
this case off
thus the change
lines 14 and
capacity blowup of
execution of adv
up loop moves
down loop moves
algorithm off that
every line of
a cost at
the placement poff
at most parent
moves to one
and any pair
of the caches
a placement p
placement to the
root just before
change in is
hcc algorithm is
or line 12
o ine hcc
the caches in
off incurs a
line 15 is
loop preserves i1
that coff is
of any online
it preserves p
before line 15
p holds initially
a child of
the first inequality
of a file
the claim holds
by the definition
the execution of
od end of
an arbitrarily long
first inequality is
the request sequence
online algorithm is
and the down
dist u v
is always consistent
copy of f
from lemma 4
the change in
after the execution
to its parent
arbitrary metrics by
total cost incurred
that modify the
on approximating arbitrary
approximating arbitrary metrics
a file in
in the down
that the outer
metrics by tree
by tree metrics
line of code
the children of
of the outer
to denote the
is due to
the consistency of
lemma 4 7
lemma 4 6
a function from
the cost incurred
follows from lemma
the total cost
of f is
every node in
lemma 4 4
has a positive
set of nodes
the subtree rooted
14 and 15
of the nodes
an internal node
a cost of
subtree rooted at
values of all
b feasible online
denote the old
loop terminates lemma
k k h
swapp p is
holds everywhere in

corpus/krapavin2000-test/1007977.txt
inorder
spine
preorder
fold
bftf
roll
flatten
forest
tip
preorderf
traversal
converse
breadth
reductivity
revzip
ziptree
zipforest
rebuild
inversion
haspreorder
execwith
tree
invert
height
foundedness
reductive
concat
surjective
xok
bft
prefix
xs
exec
commands
ys
hylomorphism
prefixok
trees
functor
datatypes
datatype
aforest
rbr
coreflexive
labelling
traversals
dom
subtrees
generalised
fst
jointly
strings
heights
lookahead
snd
fusion
fuse
okasaki
isnext
moor
newtree
cpy
inverse
relational
ws
string
bin
lbr
folds
unfold
id
fork
forests
bs
inverses
inverted
int
foldtree
spinei
coreflexives
foldrn
demonic
su
founded
parsing
parse
exercise
inverting
lists
map
join
specification
font
tupling
determinism
boldface
xu
derivation
haskell
ins
del
deterministically
bfl
printing
invariant
list
loop
add
character
cons
rebuilding
init
ran
ok
minsplit
flattenf
zipping
foldr
monotype
relator
doornbos
rollpf
flattens
xof
angelic
zipped
minadd
issu
deques
building
monotonic
eq
converts
functional
edit
ht
knuth
dijkstra
upwards
invent
catamorphism
catamorphisms
backhouse
tournament
talked
char
imperative
optimised
inr
inl
flattening
says
move
erent
labelled
internally
backwards
tail
greedy
contravariant
cursor
tips
duplicated
reflexive
reader
monotonicity
calculus
di
bird
homomorphisms
wraps
admitting
locate
postcondition
optimise
consumed
apparently
fs
command
relations
valued
factored
ta
isomorphism
binary
implementable
cat
folding
fig
conversion
cult
wider
recursive
generalise
fa
theories
generalisation
termination
reverse
refinement
a tree
the fold
converse of
a spine
tree a
a fold
breadth first
spine a
the spine
f well
x us
the converse
forest a
preorder traversal
list a
to invert
jointly surjective
function theorem
a relation
f reductive
inorder traversal
program inversion
first labelling
well foundedness
given list
building trees
su xok
spine tree
xok x
inorder roll
partial function
add a
traversal of
a tip
a forest
e f
a list
haspreorder x
left spine
base functor
concat map
minimum height
f reductivity
revzip a
prefixok x
first traversal
inverse of
data tree
a xu
the forest
tree with
a roll
add is
map snd
preorderf map
snd us
relation add
its preorder
fold fusion
tip tree
zipforest bftf
a b
su x
step a
the inverse
the preorder
empty lists
two strings
the tree
the left
valued binary
binary tree
traversal is
a function
f a
is f
b d
inversion in
tree whose
a x
the list
a a
relation r
boldface font
newtree a
fold we
vs ws
rbr a
bs us
since dom
fork preorder
greedy theorem
a hylomorphism
tip valued
bin a
lookahead x
monotonic on
tip a
an unfold
the inorder
de moor
its inversion
following datatype
are jointly
tree from
of commands
theorem 3
non deterministically
functor f
to fuse
last x
fold to
refinement calculus
a f
the subtrees
has type
trees with
well founded
defined by
two trees
binary trees
a e
a relational
theorem 1
in words
eq a
r f
inversion of
the invariant
new node
strings and
a partial
the relation
locate a
base a
non determinism
preorder inorder
converse operation
foundedness and
preorderf t
edit problem
duplicated elements
fusion theorem
spine representation
roll vs
lbr a
preorder the
map flatten
rebuilding a
type aforest
flatten roll
empty strings
generalised theorem
reductive if
ht a
us su
map fst
its traversals
fold in
bin b
dom s
b bs
tree int
inorder and
source string
the coreflexive
xu x
a rebuild
relational fold
where step
where add
printing and
fold function
ok x
rebuild x
aforest a
a xs
string edit
for breadth
t us
inorder traversals
labelled binary
fst us
us newtree
of bftf
bfl as
dom r
invert a
the loop
the derivation
tree and
list of
up a
d e
traversals of
prefix of
c a
the generalised
height x
fold on
converse of a
the converse of
a tree a
a function theorem
of a function
as a fold
breadth first labelling
su xok x
a spine a
f well foundedness
breadth first traversal
the inverse of
c a e
a tree with
the left spine
revzip a f
a spine tree
inorder traversal of
tree a tree
the given list
a e f
a partial function
a list a
a tree from
non empty lists
su x of
preorderf map snd
are jointly surjective
into the fold
map snd us
tree from its
f a b
d e f
b d c
e f b
e f a
traversal of a
inverse of a
a relation r
r a b
with minimum height
tip valued binary
the base functor
r is f
of the fold
as a hylomorphism
building a tree
up a v
valued binary tree
is f reductive
f well founded
the following datatype
is f well
and its inversion
sequence of commands
building trees with
relation r a
preorder traversal of
a a tree
as a relational
is defined by
function as a
eq a a
adding a new
d c a
of a binary
rebuilding a tree
f reductive if
the source string
a xu x
by the list
duplicated elements the
join a t
algebra of programming
spine a tree
fork preorder inorder
a relational fold
roll vs ws
to invert a
and preorder traversal
fold fusion theorem
bin a x
a simple relation
the relation add
xok x us
is monotonic on
map fst us
the string edit
its preorder traversal
newtree a xu
add a xu
concat map flatten
the fold fusion
the converse operation
a is mapped
us newtree a
along the left
a roll vs
since dom s
inorder and preorder
preorder traversal is
a tree whose
preorderf t u
from its traversals
us su xok
a forest a
well foundedness and
a tip valued
the fold to
in boldface font
program inversion in
the two strings
tree int int
an unfold the
for breadth first
x us su
string edit problem
base a a
along the spine
prefixok x us
the greedy theorem
prefix of the
a new node
linear time algorithm
conditions under which
theorem 3 is
f r f
list of labels
for non empty
the preorder traversal
a su x
trees with minimum
f a x
f b d
and is defined
function can be
are about to
b d e
a single tree
inversion in the
the domain of
a list of
can thus be
a given list
traversals of the
to a tree
a function as
reader is referred
c d e
a binary tree
a tree and
t u v
tree to the
is a partial
u v w
tree on the
that in section
written as a
to insert a
a total function
now we will
of a partial
a relation is
a b d
the reader is
the current position
is to prove
as a b
a b is
to derive a
x i 1
a b b
theorem 1 to
a x y
of the given
not di cult
under which the
is a relation
of empty strings
breadth first order
v up a
y non deterministically
under the spine
and output types
write the inverse
label a tree
inversion and strongest
of f well
height x i
relational theory of
concat map cons
a fold we
its traversals via
roll add a
isnext x a
printing and parsing
its fold function
maps a list
to invert it
a tip tree

corpus/krapavin2000-test/1008135.txt
cgls
lanczos
multishift
attainable
recurrences
alg
krylov
residual
cg
shifted
squares
conjugate
iterates
tridiagonal
rounding
precision
perturbation
gradient
matrix
residuals
roundo
accuracy
subspace
erence
errors
recurrence
perturbed
arithmetic
paige
tikhonov
damped
quantities
qmr
di
orthonormal
norm
coupled
ill
numerical
proposition
inversion
diagonal
greenbaum
conditioned
vectors
roundoff
cients
coe
regularization
factorized
recursions
dstqds
chromodynamics
normwise
quantity
erences
floating
scaling
stagnates
orthogonalization
utrecht
qd
restarted
quantum
picture
bidiagonal
phillips
ingredient
shift
ax
products
eigenvalues
dash
gmres
dl
summarized
computations
families
implementations
iterate
stable
ects
error
vector
impact
shifts
mathematically
symmetric
cult
proposals
consult
influence
ciently
forward
ingredients
cancellation
iterations
perturbations
orthogonal
overwhelming
eigenvector
columns
convenience
accurate
cient
confirm
solving
argued
lemma
mr
attain
expression
subspaces
bold
norms
euclidean
exact
attained
1iteration
elfving
foxgood
lscg
modynamics
ursell
stroke
3508
colinear
tridiagonalizing
algorithmus
chro
quotienten
erenzen
eshof
quark
financially
2iteration
strako
capitals
insight
minus
stability
contribution
alternative
monotonically
ultimate
characters
factorization
relations
definite
eventually
inequality
orck
rences
stiefel
bidiagonalization
sylvester
dhillon
parlett
rutishauser
035
hestenes
dot
band
zeros
bounding
gap
su
variants
formulation
guess
unconventional
masses
warn
canceled
precisions
outlook
inspection
stress
plays
variant
250
tries
inner
stationary
dotted
cf
celebrated
arnoldi
countless
bicgstab
approximations
lattice
outcome
thankful
positivity
erential
nwo
dutch
dashed
multiplying
cgls method
the cgls
multishift cgls
the multishift
the lanczos
lanczos method
lanczos part
attainable accuracy
the attainable
cgls lanczos
least squares
cg method
conjugate gradient
standard lanczos
the shifted
krylov subspace
shifted systems
finite precision
the cg
the iterates
alg 1
matrix a
cgls recurrences
rounding errors
the matrix
the krylov
accuracy of
16 alg
lanczos relation
the perturbation
gradient method
precision computations
alg 2
tridiagonal matrix
squares problems
shifted system
alternative lanczos
forward error
squares problem
the vector
linear systems
computer arithmetic
shifted linear
true residual
the computed
method based
di erence
errors in
starting vector
damped least
perturbed lanczos
w vectors
iterates for
inversion part
perturbation term
for shifted
numerical experiments
a t
relative error
the conjugate
method applied
in finite
two term
coupled two
on coupled
condition number
w 3
7 16
of rounding
a perturbed
the residuals
term recurrence
w 1
method the
of shifted
stable method
qmr method
recurrences in
squares residual
the qmr
coupled recurrences
of cgls
for solving
matrix vector
the standard
proposition 2
ill conditioned
method is
t k
exact arithmetic
lanczos vectors
normal equations
orthogonal basis
roundo errors
term recurrences
the tridiagonal
r k
2 6
the di
basis for
in exact
three term
matrix t
method it
6 5
errors made
with starting
relatively close
orthonormal basis
vector a
the residual
an orthonormal
error analysis
to applying
the error
a multishift
cg type
x cgls
multishift version
cgls methods
vector updates
for least
multishift versions
lanczos process
the damped
future convenience
exact conjugate
the least
diagonal elements
erence in
computation of
the quantities
t b
6 4
r j
solution of
summarized by
special structure
vector w
method and
direct application
method for
lanczos type
b ax
residuals r
recurrence relations
subspace k
residual gap
that depends
the norm
the inversion
g 12
expression for
coe cients
norm of
approximate solution
erence between
s k
6 3
in 5
side b
mathematically equivalent
the ill
the iterate
previous proposals
factorized form
recurrences for
lanczos and
abstract formulation
the contribution
the computation
the true
square of
right hand
with diagonal
point arithmetic
16 theorem
in 2
hand side
vector product
15 6
matrix s
the impact
to bound
method in
is summarized
inner products
floating point
a with
v k
key ingredient
part on
di erences
part as
quantities in
type methods
implementations of
this quantity
test problems
an orthogonal
multishift cgls method
the multishift cgls
of the multishift
the cgls method
the lanczos part
the attainable accuracy
attainable accuracy of
of the cgls
the cgls lanczos
the standard lanczos
cgls lanczos method
the cg method
standard lanczos method
the matrix a
for the lanczos
of the lanczos
cgls method is
on the attainable
accuracy of the
for the krylov
the krylov subspace
conjugate gradient method
the shifted systems
cgls method based
the cgls recurrences
in the lanczos
for the shifted
the least squares
the lanczos method
least squares problems
errors in the
in the cgls
shifted linear systems
in finite precision
least squares problem
method based on
finite precision computations
rounding errors in
the conjugate gradient
the true residual
starting vector a
damped least squares
cgls method it
vector a t
the perturbation term
matrix t k
the lanczos relation
cgls method the
contribution of w
in the multishift
to the matrix
method applied to
based on coupled
lanczos method for
coupled two term
for the least
basis for the
a t b
a t a
of rounding errors
in 2 6
for the multishift
the iterates for
the qmr method
for shifted linear
iterates for the
errors made in
of the cg
least squares residual
a with starting
for the cg
orthogonal basis for
on the cgls
vector w 3
of the perturbation
the forward error
in exact arithmetic
the condition number
implementation of the
with starting vector
on the square
of the iterates
two term recurrences
the di erence
the computation of
expression for the
proposition 2 1
summarized by the
three term recurrence
the vector w
the norm of
computation of the
orthonormal basis for
matrix a t
di erence in
of the matrix
exact conjugate gradient
lanczos part and
multishift cgls methods
with diagonal elements
rounding errors made
cgls method in
in computer arithmetic
recurrences in 2
cgls method and
w vectors for
hand side b
that the cgls
the inversion part
forward error is
of the shifted
5 4 8
multishift versions of
cg type methods
matrix s k
applying the cgls
for the cgls
16 alg 1
recurrences for the
that the multishift
for future convenience
16 alg 2
cgls method for
the multishift version
lanczos part on
for least squares
the damped least
a multishift cgls
the w vectors
an abstract formulation
a perturbed lanczos
the shifted system
the ill conditioned
7 16 alg
cgls method to
the alternative lanczos
influence of rounding
future convenience we
in the computation
lemma 4 1
on the error
that depends on
the contribution of
direct application of
an orthonormal basis
right hand side
of the vector
applied to the
e g 12
of the attainable
the normal equations
to applying the
j 1 6
2 6 can
abstract formulation of
special structure of
t a with
floating point arithmetic
krylov subspace k
tridiagonal matrix t
the residual gap
an orthogonal basis
on the numerical
given in 4
the three term
k j a
on coupled two
the finite precision
4 5 4
relatively close to
matrix vector product
di erence between
norm of the
of the standard
w 1 and
a direct application
the matrix vector
of the conjugate
the error in
the square of
as an alternative
the expression for
for solving linear
solving linear systems
6 2 6
the vector x
of t k
in 6 2
the special structure
condition number of
j a b
made in the
numerical experiments in
of w 1
and therefore the
of the method
matrix a with
upper bounds on
and right hand
the numerical solution

corpus/krapavin2000-test/1008136.txt
ritz
lbd
lanczos
singular
irlanb
bidiagonalization
harmonic
bidiagonal
restarted
triplets
deflation
eigenvalues
tol
eigenvalue
restarts
arnoldi
aa
reorthogonalization
jdqz
matrices
factorization
residual
matrix
implicitly
matlab
1e
shifts
refined
qr
irbleigs
convergence
pseudospectra
odt
irblsvds
smallest
converged
svd
sparse
davidson
implicit
tridiagonal
arpack
eigenproblems
restarting
hermitian
augmented
ective
eigensolvers
eignum
bulgechasing
sleijpen
symmetric
givens
restart
krylov
jacobi
shift
kahan
larsen
hessenberg
tolerance
golub
norm
blsz
vorst
3719
991
svds
sorensen
propack
grcar
lr
av
orthonormal
runtimes
rank
rr
sec
clustered
triangular
subdiagonal
vectors
bases
vis
200000
subspaces
approximations
reorthogonalize
reichel
jwph
3737
nbls
normest
1850
calvetti
qz
jmax
2373e
petrov
atel
2756e
baglama
neuch
9600e
4861e
eigs
stability
noting
clustering
diagonal
codes
owes
pseudospectrum
purging
squaring
jmin
orthogonal
orthogonality
inexact
numerical
bulge
uncontrollability
worth
subspace
ill
cf
conditioned
enhance
min
dw
nonsymmetric
galerkin
updated
decomposition
rescaling
cholesky
squared
approximate
abs
100000
dimension
2048
invert
van
eigenvectors
jia
shifted
depict
20th
digits
century
squares
eigenvector
math
remedy
frameworks
seek
unitary
inverse
rotation
acknowledged
seeking
permit
largest
decompositions
2270
nonsquare
deflated
bidiagonaliza
stathopoulos
pseudoiverse
maxit
pmaa
bqr
irlbsvds
premultiply
irbl
dooren
grimme
jbaglama
disuss
hochstenbach
8391e
eigendecompositions
aggravate
lsqr
errikos
bidiago
hypatia
hercma
pencils
kontoghiorghes
aspired
comptutation
fokkema
deflating
bodossaki
ruu
contine
8754
ritz values
harmonic ritz
singular values
smallest singular
implicitly restarted
singular triplets
lanczos bidiagonalization
tol 1e
of lbd
singular value
l 1
augmented matrix
starting vector
convergence tolerance
the smallest
of restarts
lanczos factorization
restarted lbd
refined residual
of irlanb
b l
the augmented
lower bidiagonal
partial reorthogonalization
of lanczos
matrix c
the singular
u l
bidiagonal matrix
eigenvalue problems
large sparse
restarted lanczos
singular vector
eigenvalues of
the refined
restarted arnoldi
the lanczos
the eigenvalues
relative error
jacobi davidson
ritz vector
of implicitly
the lbd
qr steps
implicit restarting
tolerance tol
sparse matrices
triplets of
10 sec
an implicitly
refined singular
lbd algorithm
approximate singular
lbd factorization
symmetric eigenvalue
the bidiagonal
computation of
the harmonic
e ective
rank one
on lanczos
with harmonic
of aa
v l
right singular
of large
c l
irbleigs irblsvds
lanczos on
ritz value
symmetric eigensolvers
1e 10
error ritz
to tol
matrix free
as shifts
implicit qr
1e 8
ritz shifts
aa or
that irlanb
ritz harmonic
refined ritz
restarts relative
singular vectors
in matlab
condition numbers
tridiagonal matrix
y l
numerical experiments
eigenvalue problem
a matrix
upper bidiagonal
lanczos method
upper hessenberg
1e 6
of pseudospectra
of few
and lanczos
diagonal matrices
a jacobi
sec 8
c m
applied on
with partial
clustering of
matrix b
values of
and harmonic
was set
l y
compute the
we next
worth noting
norm of
value decomposition
in 34
of harmonic
the bases
restarts of
one modification
aa u
sleijpen and
inexact inverse
the implicitly
orthogonality among
and singular
givens rotation
either aa
matlab codes
davidson type
is orthonormal
to lanczos
an lbd
ritz number
lanczos applied
bases u
the bidiagonalization
shifted qr
deflation techniques
implicit shifts
lbd is
implicitly shifted
small singular
and jdqz
implicit restarts
lbd the
bidiagonalization with
on aa
symmetric rank
aa 1
lbd was
tolerance was
0 3719
eigenvalues i
irlanb with
a symmetric
applied directly
large matrices
to implicitly
following relations
values we
the symmetric
the updated
special structure
bidiagonal form
residual and
of residual
restart we
approximations to
the norm
b k
basis vectors
lower triangular
the computation
l and
search space
z c
directly on
the orthogonal
arnoldi methods
has converged
to compute
the residual
noting that
experiments with
y r
the convergence
and refined
matrix algorithms
shifts in
for large
few of
and right
convergence behavior
ill conditioned
compute one
therefore b
of singular
that illustrate
the smallest singular
harmonic ritz values
singular values of
smallest singular values
smallest singular triplets
augmented matrix c
the augmented matrix
of the smallest
implicitly restarted lbd
number of restarts
smallest singular value
the refined residual
u l 1
the singular values
implicitly restarted lanczos
singular triplets of
implicitly restarted arnoldi
an implicitly restarted
convergence tolerance tol
the harmonic ritz
tolerance tol 1e
large sparse matrices
values of a
ritz values of
of implicitly restarted
with partial reorthogonalization
triplets of large
the eigenvalues of
a c m
the computation of
l 1 is
of large sparse
of the augmented
implicit qr steps
steps of lbd
with harmonic ritz
tol 1e 6
tol 1e 8
bidiagonal matrix b
computation of few
singular values we
of harmonic ritz
a jacobi davidson
the symmetric eigenvalue
of restarts relative
values of aa
10 sec 8
error ritz harmonic
and harmonic ritz
tol 1e 10
ritz harmonic ritz
equivalent to implicitly
right singular vector
from the eigenvalues
to tol 1e
of large matrices
restarts relative error
the lbd algorithm
to implicitly restarted
restarted lanczos on
applied directly on
z c l
sec 8 6
relative error ritz
the bidiagonal matrix
refined ritz vector
c l 1
of a symmetric
computation of pseudospectra
c m n
of b l
the starting vector
of a matrix
clustering of the
approximations to the
worth noting that
for the symmetric
e l 1
singular value decomposition
was set to
the following relations
harmonic ritz number
convergence tolerance was
set to tol
rank one modification
symmetric eigenvalue problem
the lanczos factorization
one modification of
ritz values as
an lbd factorization
behavior of irlanb
matrix b k
qr steps on
bidiagonalization with partial
matrices a s
a symmetric rank
lanczos applied on
ritz number of
symmetric rank one
lanczos bidiagonalization with
either aa or
implicitly shifted qr
matrix a c
refined residual and
singular value and
ritz value of
tolerance was set
singular values that
lbd is equivalent
refined singular vectors
irlanb with harmonic
approximate singular values
l 1 e
computing the smallest
equivalent to lanczos
ritz values and
for the computation
of the residual
few of the
compute the eigenvalues
and right singular
on lanczos bidiagonalization
lanczos method for
to the singular
singular values are
on the augmented
norm of the
of c l
modification of a
v l and
to compute one
the norm of
the e ective
be applied directly
values of l
methods for large
computation of the
parallel computation of
is worth noting
the singular value
applied on the
eigenvalues of a
of the matrix
implicit application of
of algebraic eigenvalue
restarts abs of
jacobi davidson iteration
for large eigenvalue
application of polynomial
step arnoldi method
we select to
the 20th century
of polynomial filters
partial singular value
starting vector u
when seeking few
filters in a
k step arnoldi
with related methods
eigenvalues of c
triplets of a
the eigenvalues i
a partial singular
pseudospectra of large
and possibly sparse
restarted lanczos bidiagonalization
right refined singular
of aa 1
the square lower
compute the harmonic
our target is
small singular triplets
a matrix free
of lbd was
obtain a lanczos
y l and
compute few of
of diagonal matrices
upper bidiagonal matrix
to the lanczos
to lanczos applied
shift and invert
singular triplets in
lbd factorization of
6 2756e 5
petrov galerkin condition
values of large
implicitly restarted block
of lbd the
in the 20th
for linear eigenvalue
and tol 1e
very large sparse
orthogonal deflation transformation
largest ones it
36 sec 4
algorithm we call
b l 1
matrices using odt
experiments with irlanb

corpus/krapavin2000-test/1008286.txt
dc
gb
des
leak
ltl
tts
gas
chop
dpe
transition
duration
trajectory
burner
timed
hmp94
burn
ignition
ae
transitions
formulas
axiom
temporal
oe
flame
premises
logic
invariance
trajectories
tltl
zhr91
ignite2
rrh93
req
refinement
tla
stuttering
untimed
lam93
ignite1
goidle
sigma
axioms
ht
formula
durations
action
primed
pe
pi
predicate
actions
lam94
interval
reactive
units
modality
def
sound
iff
separation
linking
induction
purge
verification
calculus
specification
specifications
modalities
idle
fqg
reals
asserts
position
positions
al92
zh96a
dqe
consecution
lrl98
mp92
mp81
recapitulates
ttss
timing
heat
dense
deduced
bounded
structural
premise
validity
diligent
css
yardstick
al91
rules
semantics
ss
satisfaction
frameworks
neighbourhoods
liveness
methodologies
corollary
suffix
satisfies
style
connectives
responsiveness
sequencing
fairness
variability
fpg
lasts
reasoned
overlapping
proving
elementary
rule
valid
modelling
occurrence
modelled
correctness
initiation
disciplines
operators
reasoning
2p
ni
response
predicates
denotational
enters
stopped
stand
inductive
enabled
provable
satisfied
behaviour
entered
compositional
safety
meaning
koy89
hz97
ors96
rehr98
dre
fpgt
lrl97
intv
liu96
flon
zh96b
rav95
manna
lam77
xu97
unlit
ah90
dimensionaldomain
traj
durational
fld
instanta
consolidation
pnu77
ad90
fae
ph88
reoccur
heaton
seconds
clocks
automaton
specifying
link
linked
refined
observable
stable
abstract
progress
critical
soundness
safeness
kel76
chopped
neously
pnueli
valve
culus
operational
rigid
saying
singleton
refine
hybrid
gb 1
transition system
trajectory ae
timed transition
gb 2
a trajectory
transition systems
of gb
the gas
system gb
gas burner
position p
minimal separation
in dc
time units
in hmp94
duration calculus
ae over
the chop
state variables
real time
s sound
bounded response
bounded invariance
temporal logic
a state
state predicate
linear temporal
r r
temporal formula
state transitions
the premises
invariance property
temporal formulas
time point
of des
d pe
within e
des 2
chop operator
and ltl
bounded unless
duration formula
induction rules
time domain
the timed
time systems
in gb
an action
of state
the dc
s valid
a tts
bounded progress
chop modality
leak in
of leak
a dc
des 1
dc this
bounded critical
gb 3
tts framework
des des
interval logic
critical duration
original dc
the tts
a duration
structural induction
at position
over sigma
the logic
a transition
an implementation
reactive systems
and verification
a temporal
r true
an interval
a bounded
holds at
least l
rules for
specification and
verification of
p holds
satisfied by
system s
r 0
of states
properties and
action formulas
of trajectories
duration formulas
for durations
finite variability
dpe is
untimed transition
let leak
for gb
duration properties
in rrh93
combined logic
ltl style
hold iff
property d
dc framework
req of
separation property
heat request
position ht
in zhr91
duration terms
3 ss
leak 2
style specification
leak 1
the conclusion
by ae
ae 1
trajectories and
dc to
primed variables
induction rule
dc for
to dc
p state
and leak
formula f
meaning of
proof system
taken at
dynamic systems
asserts that
rule 3
timing constraints
dc and
any trajectory
dc is
for bounded
requirement and
oe is
validity of
oe 0
and bounded
for at
remain valid
true over
state predicates
a timed
state sequence
any state
time bound
the temporal
first order
r x
high level
satisfies the
stable for
embedded real
d time
predicate over
invariance properties
axioms and
of positions
the semantics
state transition
predicate p
p is
and reasoning
is satisfied
invariance and
of duration
a position
the meaning
the structural
logic is
p should
ae and
semantics of
logic of
the transition
d e
formulas we
of actions
of time
position m
s validity
super dense
flame failure
sound rules
observation over
x dpe
the burn
axiom 8
premise in
explicit clocks
interval b
axiom 6
a trajectory ae
transition system gb
timed transition system
the gas burner
r r r
at position p
of gb 1
a temporal formula
a transition system
timed transition systems
the timed transition
system gb 2
real time systems
a state predicate
linear temporal logic
taken at position
transition system s
the chop modality
in gb 1
leak in gb
state predicate p
property of gb
rules for bounded
the original dc
bounded critical duration
of the gas
ae 1 p
the structural induction
is satisfied by
is a temporal
a time point
the logic is
at least l
oe is a
specification and verification
temporal logic of
of state transitions
and verification of
trajectory ae over
the chop operator
untimed transition systems
a duration formula
refinement of gb
system gb 1
position p 2
d time units
of a duration
the finite variability
true over a
for gb 1
is s valid
by a trajectory
oe oe 0
by ae over
for a trajectory
requirement and design
2 r 0
of gb 2
in dc this
a minimal separation
minimal separation property
satisfied by ae
gb 2 has
stable for at
dc and ltl
the tts framework
for at least
a state transition
of the conclusion
axioms and rules
holds at the
p holds at
a p state
a timed transition
of a transition
set of state
is true over
the transition system
the meaning of
validity of the
is taken at
state variables and
of real time
the time domain
embedded real time
time systems the
2 has the
an invariant of
formula f is
and high level
the temporal logic
a real time
the semantics of
can be proved
an occurrence of
the correctness of
is any state
reflects the engineering
can establish by
for the gas
the combined logic
a special action
r true holds
bounded response property
interval b e
bounded response properties
until p has
if r d
oe 0 it
engineering disciplines of
structural induction rules
as a dc
temporal formula and
holds and r
by 3 ss
prove a bounded
gas burner example
premise in the
units since the
corollary 2 and
des des des
reasoned about in
within e time
any trajectory ae
req of the
a bounded invariance
the yardstick properties
any state predicate
hold until p
the requirement req
conventional dynamic systems
temporal formula it
abstract liveness and
over an observation
bounded invariance property
of leak in
e holds and
ae and an
the premise in
proofs of des
dpe d pe
and leak 2
bounded invariance properties
the interval logic
section 4 satisfies
transition system consists
still s sound
system gb 3
simple error recovery
for timed transition
convention that the
f is s
their values for
chop operator is
ae over sigma
real time point
timed linear temporal
and design specifications
property is of
since the change
ae over an
the burn phase
position p there
critical duration property
deduced from corollary
for a position
hold iff phase
occurrence of q
gb 1 of
a semantics and
an observation if
a dc formula
3 ss with
ltl style specification
liveness and fairness
bounded invariance and
c time units
s validity of
e 1 property
d e holds
2 property of
a non overlapping
of the premises
value from r
underlying transition system
dense chop operator
this time domain
from dc and
for bounded progress
than c time
property asserts that
trajectory over sigma
cannot hold until
least l time
observation over an
minimal separation is
for bounded unless
a step is
s sound rules
des 1 is

corpus/krapavin2000-test/1008415.txt
seat
seats
4s
accommodating
requests
intervals
station
competitive
reservation
6i
request
price
interval
stations
fair
passenger
accommodated
nrequests
adversary
accepted
ntimes
decit
accommodate
train
rst
randomized
late
sequences
mod
coloring
tickets
boyar
5n
ratio
ticket
oblivious
rejected
surplus
minft
groups
joan
9k
satised
reservations
3i
2n
1of
placed
gap
fit
subintervals
group
early
as4
alcom
17k
7k
5nrequests
bungalows
17for
9510244
accommodates
4n
fig
asymptotic
extra
14k
vacation
quests
dened
prob
travels
dierent
1from
larsen
3s
dotted
5k
deterministic
pricing
asymptotically
optical
programme
eu
congruent
1c
ist
fall
calculated
ext
divisible
adversaries
sigact
jiang
fraction
tao
proceeds
processed
expects
1d
overlaps
1a
conguration
1b
unit
trip
people
expectations
colors
clique
5nk
3np
4these
5original
7of
dextrous
7for
ogp0046613
3are
unnamed
3on
minimums
amortization
earns
journey
7083
knrequests
14186
accom
least4
3is
3nadditional
bering
ucr
5nin
1when
3some
3when
stee
reassign
competive
fths
2cg
kmod3
3cg
lene
morten
favrholdt
income
cito
chrobak
modated
4to
1now
3as
5np
20244
scheduling
fairness
vertical
routing
giving
kim
1for
unsatised
ticketing
passengers
bach
nishing
reestablish
1on
krarup
fich
2the
purchases
faith
route
receive
tight
news
grant
concrete
612
denmark
earned
sold
6c
3the
refuse
unoccupied
wavelengths
corollary
dominates
overlap
ratios
marked
spill
traveled
1x
purchased
line algorithm
accommodating sequences
on accommodating
seat reservation
unit price
reservation problem
the seat
price problem
competitive ratio
on line
the competitive
seat 1
the intervals
extra intervals
of requests
o line
seat 2
k mod
on seat
requests in
first fit
the on
the requests
optimal o
request sequence
the unit
ratio on
starting station
same seat
the accommodating
the rst
nrequests for
4s 2
start station
original interval
e interval
seats which
form 4s
station s
accommodated by
the train
two intervals
the request
intervals which
even on
the interval
request r
the adversary
price seat
from station
two seats
adversary proceeds
interval 4s
the decit
intervals 6i
fair deterministic
accommodating ratio
fair on
late group
sequences proof
2 4s
no request
early groups
for fair
requests r
intervals of
sequences for
competitive on
accommodate all
are placed
rejected interval
of seats
rst interval
early group
a seat
randomized on
two requests
to station
joan boyar
to accommodate
interval in
proceeds with
placed on
the expected
expected number
in u
empty from
k competitive
fair algorithms
problem k
rejected intervals
ratio for
intervals are
expected fraction
interval graph
oblivious adversary
before i
whose starting
randomized algorithms
be on
algorithm will
intervals in
is accepted
f k
all requests
additional requests
seat as
interval 6i
original intervals
train between
will accommodate
the seats
seats to
a train
9 k
seats is
4s 5
4s 3
late groups
requests accommodated
2n 27
9k 9
end station
27 2n
fair randomized
fair o
station minft
request k
three requests
asymptotic upper
6i 8
requests accepted
with nrequests
optimal fair
subintervals of
ntimes for
4s 4s
prob i
ntimes ntimes
m seats
early late
associated rejected
then seat
who want
randomized fair
decit of
minft t
6i are
upper bound
requests are
dotted line
interval with
in fig
requests the
be accommodated
deterministic algorithms
that fall
requests for
sequence i
is at
satised on
a passenger
next interval
call control
competitive even
interval scheduling
sequences when
accepted the
accepted is
next group
vertical dotted
gap on
an interval
in s
an on
can accommodate
accommodate the
of stations
the surplus
any fair
the oblivious
of intervals
before s
were supported
fall into
part by
be accepted
interval and
interval which
fit is
1 request
to requests
requests which
are accepted
for randomized
accepted if
accepted by
the optimal
theorem 3
s 1
on accommodating sequences
on line algorithm
the unit price
seat reservation problem
unit price problem
o line algorithm
for the unit
the competitive ratio
the seat reservation
optimal o line
the on line
ratio on accommodating
competitive ratio on
the same seat
line algorithm will
even on accommodating
accommodating sequences for
the request sequence
the form 4s
requests in u
competitive on accommodating
i and k
the accommodating ratio
requests in s
reservation problem is
unit price seat
for the seat
the adversary proceeds
accommodating sequences proof
fair on line
the optimal o
the intervals 6i
adversary proceeds with
nrequests for the
price seat reservation
4s 2 4s
number of requests
sequence of requests
an optimal o
intervals of the
line algorithm is
in the request
are placed on
the expected number
the requests in
line algorithm can
randomized on line
requests r 1
f k competitive
e interval in
number of seats
receive the interval
empty from station
the rst interval
on seat 1
the interval 4s
accommodating ratio for
price problem k
of the requests
algorithm can accommodate
that fall into
expected number of
of the intervals
on the competitive
the intervals of
to accommodate all
will be accepted
competitive ratio of
an on line
be on the
placed on the
interval in the
is at most
for the interval
fair o line
station minft t
two requests in
competitive even on
the optimal fair
the extra intervals
to station minft
fail to accommodate
seat 1 request
who want to
27 2n 27
8 the on
line algorithm a
first fit is
with nrequests for
the original intervals
minft t 1
on the train
is no request
intervals which are
optimal fair o
accommodated by random
for the intervals
problem the seat
price problem is
reservation problem with
of extra intervals
sequences proof the
accommodating sequences the
6i are placed
the e interval
fair algorithms for
requests are satised
on seat 2
accommodate all requests
whose starting station
9k 9 k
9 k mod
requests accommodated by
asymptotic upper bound
the decit of
k competitive even
of requests accepted
seat 2 is
people who want
the train between
same seat as
randomized fair on
accommodating sequences when
ntimes ntimes for
of requests accommodated
starting station s
ratio for the
to be on
of requests in
were supported in
vertical dotted line
the next group
the oblivious adversary
t 1 g
of people who
theorem 3 1
in part by
line algorithm for
the expected fraction
expected fraction of
problem is at
on the same
for the rst
algorithm for the
number of people
sequences for the
algorithms for the
that the expected
by an optimal
on line algorithms
case where there
want to be
requests for the
the same sequence
the special case
1 4s 3
q i seats
these extra intervals
accepted is at
after these requests
first fit and
k mod 9k
ntimes for ntimes
reservation problem the
algorithm will accommodate
investigate the competitive
a single seat
request but fail
k mod 14k
interval could be
each request denote
i 5n the
intervals marked with
denote the request
can accommodate exactly
n the optimal
4s 4s 4
k mod algorithm
we assign requests
accommodating sequences is
satised on seat
the rst seat
consists of either
on case 1
fall into cases
request in s
all re quests
give the request
form 4s 5
compared to n
rst interval which
sequences the competitive
interval which prevents
same seat then
the accommodating function
late early groups
each late group
problem k more
starting stations are
line algorithm accommodates

corpus/krapavin2000-test/1008425.txt
job
notification
jobs
greedy
notify
competitive
oe
competitiveness
deadline
charge
goldman
randomized
scheduled
delta
lengths
schedule
scheduler
immediate
twolengths
earliest
deadlines
online
deltae
request
paid
begins
goldwasser
idle
gain
virtually
patience
admission
resource
pays
preemptive
nextidle
customer
classify
witnessed
payment
accepted
scheduling
charging
loosest
4dlog
subtree
queue
tomkins
lipton
arrives
latest
lef
slack
schedules
opt
rejects
blocking
completed
arrived
rejected
blocks
deltato
lateststart
undertake
1js
strictest
deltais
jqj
coin
requests
completing
rooted
dlog
atm
blocked
flip
paging
reject
oblivious
strictly
ffl
executions
fate
1from
release
randomization
behaviors
rule
deterministic
started
randomly
placement
fj
feasibly
princeton
awerbuch
feasibility
adversary
priori
advanced
receives
arbitrarily
claim
randomness
instances
violation
firm
preemption
assures
schedulers
interval
groups
rejecting
contradicts
feasible
owner
evidence
assignment
matching
expectation
pre
inductive
alternate
omega
fields
running
remained
company
video
select
amortized
gaps
loyola
notifica
7together
idles
2that
diagrammed
deltabased
7on
overpayment
l3b
deltafrom
1and
remaining3
processarival
moot
ifor
payout
1as
lessor
5i
1it
entrust
dry
l3a
gammae
parwatikar
ros
noti
block
yet
trivially
runs
lemma
maximize
red
meeting
received
units
definitively
fjg
reexamining
tardiness
cjp
unappealing
snoopy
dichromatic
quests
hindrance
outright
consideration
receive
completion
examining
tight
specifically
setting
unfortunately
termed
rely
bounds
suri
leiserson
1to
cormen
contradic
inductively
gains
infeasible
job j
immediate notification
greedy notify
large job
a job
jobs have
time t
all jobs
randomized algorithm
at time
small job
job lengths
j i
in oe
2 oe
job l
job s
competitive randomized
the job
of charge
goldman et
the resource
l f
provides immediate
select technique
virtually scheduled
notification model
the competitiveness
classify and
the scheduler
small jobs
by goldman
assignment rule
4 competitive
q delta
and randomly
randomly select
base algorithm
empty at
the classify
call control
notification is
admission control
no notification
notify is
begins job
greedy twolengths
those jobs
paid out
when jobs
distinct lengths
gain of
j at
instance i
all job
job request
the notification
competitiveness of
t k
1 competitive
job with
i k
2 deltae
2 competitive
notify algorithm
accepted jobs
large jobs
with earliest
that job
arbitrary job
begins running
notification can
oe we
equal length
as witnessed
which q
what point
algorithm greedy
providing immediate
delta is
algorithm which
job is
a randomized
online algorithm
competitive algorithm
earliest deadline
non preemptive
the randomized
the greedy
lengths are
four instances
notification while
twolengths modified
ffl behavior
idle at
no advanced
blocks l
charging scheme
oe starts
oe denote
previously accepted
without notification
any notification
charge paid
advanced notification
gain opt
ffl instance
notification 10
pre blocks
scheduled we
optimal schedule
at what
or before
not empty
bound of
the setting
have one
when all
the earliest
which provides
jobs in
each job
before time
3 competitive
with immediate
the patience
was accepted
job requests
arrived on
provide immediate
for notification
jobs j
resource is
on or
a scheduler
oe and
a base
the queue
running a
is idle
two distinct
existence for
patience of
arbitrary lengths
delta 3
point during
to run
scheduler is
the gain
an instance
jobs and
jobs of
j oe
feasible schedule
rule 6
l will
the deadline
j 3
deterministic algorithm
execution in
lower bound
which provide
set q
have arbitrary
is virtually
request will
of greedy
case l
e charge
jobs stored
earliest violation
three jobs
flip at
starts j
notification ffl
notification models
oe begins
the loosest
notification to
deltae competitive
explicitly studies
notification we
0 assignment
while matching
f blocks
disjoint partition
notification may
randomization in
both jobs
technique results
notify begins
any job
that jobs
charge j
s pays
length jobs
4dlog 2
greedy type
k begins
available jobs
job j i
at time t
all jobs have
j i k
large job l
a large job
a job j
competitive randomized algorithm
time t k
classify and randomly
goldman et al
and randomly select
when all jobs
small job s
provides immediate notification
algorithm which provides
randomly select technique
empty at time
q delta is
which provides immediate
the classify and
a small job
job lengths are
jobs have one
randomized algorithm which
j at time
begins job j
not empty at
a base algorithm
greedy notify is
when jobs have
by goldman et
two distinct lengths
the notification model
l 2 oe
have one of
in which q
greedy notify algorithm
notification is required
at what point
arbitrary job lengths
job with earliest
job j at
job l 2
with earliest deadline
a 4 competitive
providing immediate notification
or before time
of the notification
a job request
time t and
execution in which
the competitiveness of
before time t
on or before
one of two
is not empty
of two distinct
lower bound of
for the setting
bound of 2
the scheduler is
previously accepted jobs
notification model on
amount of charge
arrived on or
job s 2
consists of j
idle at time
in oe and
is virtually scheduled
running a job
point during the
with immediate notification
2 oe we
lengths are equal
ffl instance i
the greedy notify
small jobs and
greedy twolengths modified
immediate notification while
have equal length
model for notification
jobs have arbitrary
s 2 oe
provide immediate notification
4 competitive randomized
jobs have equal
the optimal schedule
of the randomized
notification can be
all job lengths
begins running a
have arbitrary lengths
delta is not
no advanced notification
the gain of
q 1 is
we are able
on this instance
this case l
the existence for
an instance with
that l f
some point during
the patience of
a randomized algorithm
the resource is
the randomized algorithm
the case that
at that time
as a base
are able to
case when all
as witnessed by
a feasible schedule
and j 2
time at which
strictly less than
which q delta
randomized algorithm we
l f blocks
immediate notification may
ffl at time
let oe denote
the earliest violation
j 1 was
notification while matching
virtually scheduled we
2 deltae competitive
greedy type algorithm
base algorithm for
the job s
greedy notify begins
which provide immediate
notify begins running
lef t x
is 2 competitive
jobs have the
lengths are allowed
paid out by
prior to time
explicitly studies the
that providing immediate
the schedule produced
0 assignment rule
disjoint partition of
all four instances
evidence that providing
units of charge
lipton and tomkins
than 7 3
which q 1
oe denote the
4dlog 2 deltae
technique results in
completed in oe
s is virtually
for admission control
value of latest
coin flip at
when all job
l will receive
starts j at
which explicitly studies
a disjoint partition
on all four
deterministic algorithm which
a 3 competitive
randomization in on
j 2 oe
given by goldman
algorithm greedy twolengths
without any notification
all previously accepted
claim that l
out at most
jobs stored in
algorithms which provide
that job j
when arbitrary job
oe begins job
during the interval
prove the existence
from the queue
able to give
setting in which
the setting with
particular execution of
and thus at
the non preemptive
a single resource
delta is empty
online interval scheduling
an oblivious adversary
algorithm runs the
jobs can be
that a job
for a job
a coin flip

corpus/krapavin2000-test/1008470.txt
hosts
election
reset
feedback
skip
rounds
round
host
multicast
btw94
reply
messages
implosion
elect
bolot
rnd
population
collision
receivers
history
send
transmissions
aggressive
rv97
idmaps
pip81
undershoot
replies
representatives
tracers
channel
overshoot
polled
entity
elected
electing
estimation
active
rs90
maxguess
rfijmg
packets
council
fig
polling
else
tsybakov
bits
message
penalty
dependency
users
init
leader
maxfn
multiplicity
colliding
elections
sends
packet
ma
resolution
protocols
unicast
ternary
conservative
transmitted
joining
robustness
initialization
transmitting
500
bit
representative
drawings
transmission
measurement
draws
optimum
convergence
converges
regardless
balanced
vi
improvement
video
anonymous
suggest
sent
collided
tsy80
kazakos
collides
5log2
tatives
candi
23number
dershot
astonishingly
am94
pervious
likhanov
plicity
papantoni
gpk82
lyn97
nb98
pippenger
matias
tml83
3basic
14number
abku99
candidacy
vanroose
ruszink
tire
fijng
rs
target
pseudo
inaccurate
congestion
leaving
5000
received
receives
massey
jargon
georgiadis
lps
silence
tracer
therefor
sidi
reactivation
nificantly
lixia
enyi
responders
members
servers
group
feed
aware
estimating
sender
rom
jjj
popu
erd
1970s
rolls
distributively
steep
stayed
azar
elects
1980s
confidence
receiver
unknown
successful
spirit
simulations
flat
afek
underestimation
depicts
probability
suggested
drops
big
polls
ues
quarter
pay
net
gain
iv
achieves
payment
poll
overestimation
dates
occurred
synchronous
examined
advertised
formance
framing
decoded
suppression
allocations
coins
balls
central
represen
simulation
knows
skip reset
algorithm skip
n c
the hosts
expected number
users n
of rounds
of messages
u 8
the election
reset with
hosts is
send reply
send feedback
basic algorithm
the feedback
of hosts
n expected
feedback implosion
feedback n
active hosts
election process
to elect
the host
with history
one round
n n
than l
of users
feedback message
target range
bolot et
if n
t n
elect a
8 c
previous round
reset choice
election the
by bolot
each host
the expected
multiple access
c l
of replies
collision resolution
algorithm t
feedback is
reset is
a reset
c number
of n
while n
population size
c u
be polled
ma networks
multicast video
rnd c
multiplicity feedback
feedback 3
received feedback
video distribution
host algorithm
n hosts
implosion problem
estimating n
hosts to
al btw94
initialization round
in btw94
if rnd
the aggressive
1 u
l 4
the estimation
this round
a collision
improved algorithm
round is
of algorithm
transmitting entity
successful transmissions
c sends
c 8
the population
reset when
1 init
init 2
history for
in ma
of receivers
the receivers
of active
estimation is
algorithm that
two rounds
penalty of
hosts are
the multicast
examined a
6 else
and n
a round
c n
host to
0 fig
4 u
of representatives
n bits
hosts and
round and
leader election
else if
suggest itself
feedback messages
reply 11
u 10
inaccurate estimation
colliding hosts
and rounds
assumes hosts
hosts it
election rounds
multicast feedback
the idmaps
rounds that
central entity
8 send
n dependency
6 conservative
13 send
pip81 rv97
c 13
n 500
balanced allocation
conservative aggressive
avoid feedback
9 else
aggressive algorithm
replies fig
6 send
10 send
representatives out
distributed leader
maxfn n
p rfijmg
reply 14
confidence simulations
full multiplicity
11 else
typical rs
7 send
choice algorithm
rounds skip
like multicast
n 5000
feedback bounds
else 12
messages skip
election message
r received
additional round
t 500
hosts this
rounds required
overshoot is
choice history
small number
for t
the improvement
for typical
n is
for algorithm
c 5
l u
round the
for n
the algorithm
a pseudo
the penalty
8 n
of anonymous
messages algorithm
else 7
of colliding
feedback the
history 1
round c
in multicast
15 s
size when
hosts may
networks scalable
protocols performance
5 send
n maxfn
reset 1
else 15
with estimating
algorithm skip reset
number of messages
expected number of
number of rounds
of users n
if n c
skip reset with
users n expected
n expected number
the expected number
u 8 c
send feedback n
n c l
the basic algorithm
and n n
number of users
reset with history
of algorithm skip
1 u 8
bolot et al
of active hosts
number of hosts
c n c
l 1 u
to elect a
in the feedback
number of replies
algorithm t n
skip reset choice
the previous round
n c u
n c number
by bolot et
t n and
1 n c
n c 0
less than l
the number of
c number of
the estimation is
in one round
for the host
n and n
c 0 2
elect a small
the hosts to
skip reset is
et al btw94
1 6 else
basic algorithm t
regardless of n
feedback n c
feedback n 1
the feedback message
the election the
feedback implosion problem
feedback 3 if
if rnd c
8 c 5
for algorithm skip
the feedback implosion
hosts is known
l 4 u
with history for
rnd c n
multicast video distribution
4 u 8
received feedback 3
when the feedback
1 init 2
the host algorithm
video distribution in
c 5 6
2 n c
of hosts is
algorithm that requires
init 2 n
number of active
the improvement in
0 2 n
n n for
value of n
performance of algorithm
n n i
the population size
a pseudo code
an algorithm that
a small number
small number of
log n bits
n n is
is a need
a need to
of n the
the algorithms presented
of messages sent
protocols performance and
examined a model
with history 1
s 1 8
a central entity
round and n
messages for typical
6 conservative aggressive
to be polled
while n 4
messages and rounds
c u 10
the target range
for typical rs
the distributed leader
estimation is reduced
l 5 send
messages skip reset
send reply 14
else 12 if
of rounds skip
feedback the hosts
inaccurate estimation of
0 3 while
host to maintain
colliding hosts is
for the election
of replies fig
send reply 11
skip reset 1
s 1 5
multiplicity feedback is
13 send reply
feedback message to
representatives out of
8 n 500
basic algorithm for
n l 1
number of colliding
reply 11 else
5 6 conservative
active hosts this
3 send feedback
group of hosts
c r received
l 6 send
of messages skip
applications like multicast
skip reset when
for t 500
15 s 0
in ma networks
around the optimum
distributed leader election
n hosts and
c l 6
model assumes hosts
c sends the
host algorithm skip
control for multicast
n dependency on
else 7 send
reset with estimating
full multiplicity feedback
r received feedback
4 s 1
that requires each
access protocols performance
of hosts may
of successful transmissions
multiple access protocols
c l 5
reply 7 s
n c 8
estimation of n
of rounds that
the choice algorithm
else if 9
if 9 if
6 send reply
anonymous networks scalable
users n l
12 if rnd
will be elected
with estimating n
rounds to elect
5 if n
n c r
avoid feedback implosion
to avoid feedback
u 10 send
3 while n
4 if n
c g fig
n 0 3
9 if n
n c 13
suggest itself as
1 8 else
rounds skip reset
n n 5000
the aggressive algorithm
10 send reply
of n decreases

corpus/krapavin2000-test/1008818.txt
oaep
ciphertext
wayness
decryption
rsa
oracle
askh
security
plaintext
gammaow
encryption
adversary
succ
asked
cca2
gammapd
attacks
shoup
public
cbad
ind
event
oracles
permutation
rbad
gbad
askg
pkcs
trapdoor
unpredictable
sbad
pr
pd
gammak
success
attack
query
askrs
dbad
ffi
secret
ow
reduction
bad
simulator
sk
fail
bits
semantic
pk
her
cryptosystem
fl
outputs
hash
queries
attacker
askr
malleability
ds
awareness
asymmetric
simulation
probability
decrypted
rogaway
coppersmith
ut
v2
adaptive
answers
she
stronger
secure
believed
ff
inverted
lattice
answer
unlikely
exponent
recover
lemma
encrypt
victor
against
events
partial
adv
cryptosystems
coins
proven
bellare
asks
reject
reducibility
notions
random
adversaries
encrypted
concatenated
famous
rejects
reaction
repair
gets
delta
plain
strongest
scenario
k1
queried
fresh
feistel
rfc2437
2k0
thanq
gammaae
maskeddb
maskedseedkmaskeddb
gammaoe
xff
wording
misbehaving
epoc
lunchtime
onewayness
cca1
spotted
maskedseed
asking
lattices
soon
equalities
corrected
challenge
f0
1g
gaussian
modular
thanks
simulate
plaintexts
multiplicatively
anybody
rameter
conversion
uniquely
semantically
simulates
meaningfully
boneh
encryptions
fraction
message
reconsidered
forgetting
repairs
reduc
root
phi
wants
corrects
plications
univariate
encrypts
lists
correctly
omega
recalls
flaw
trailing
extractor
resp
theta
pre
image
preclude
indistinguishability
rabin
runs
looks
ae
oe
split
notations
conditioning
alice
insecure
mutation
self
2t
modulus
former
probabilistic
messages
negligible
insist
overwhelming
bookkeeping
one wayness
decryption oracle
domain one
partial domain
wayness of
the decryption
rsa oaep
success probability
asked to
of oaep
chosen ciphertext
semantic security
the rsa
ciphertext c
been asked
public key
s gammapd
oracle simulation
gammapd gammaow
oracles g
adaptive chosen
of rsa
h list
the adversary
h respectively
oracle and
and h
security of
ciphertext attacks
succ pd
2 gammak
pd gammaow
significant bits
the ciphertext
the reduction
q g
the security
is unpredictable
succ s
event that
g and
the partial
random oracles
a ciphertext
gammaow a
g list
probability succ
the oaep
within time
the encryption
the random
the event
to g
to h
h s
set partial
random oracle
q h
adversary a
security result
cca2 adversary
pkcs 1
h ffi
oaep is
ind cca2
succ ow
gammak 0
rsa function
th root
adversary against
j askh
key encryption
against adaptive
the success
h queries
ciphertext attack
e th
hash functions
security against
random value
pre image
any adversary
encryption scheme
q d
functions g
list and
that oaep
trapdoor one
ciphertext this
security notions
partial pre
proof 3
asymmetric encryption
encryption oracle
fail cbad
gaussian reduction
plaintext awareness
a cca2
gammaow succ
event fail
rsa problem
making q
challenge ciphertext
queries asked
pr fail
way permutation
of plaintext
valid ciphertext
event means
askh occurs
oracle simulator
time bound
g delta
function f
the permutation
bits of
d q
the public
bounded by
outputs a
secret key
the plaintext
an good
split according
permutation f
victor shoup
modular equation
ciphertext of
full domain
g fl
the secret
encryption schemes
query answer
whose running
query c
algorithm k
unpredictable and
queries to
probability of
denotes the
of f
f means
stronger assumption
running time
upper bounded
the g
constant fraction
which on
most significant
with probability
is upper
the hash
oracle model
be proven
than 2
one gets
least significant
reduction is
a random
security analysis
under the
delta 2
the h
and thus
implies askg
awareness 1
askh q
plaintext attack
former event
oracle indeed
any ciphertext
having asked
a decryption
occurs h
of decryption
since partial
any trapdoor
gbad implies
quite unlikely
events about
when askh
ffi h
trapdoor permutation
simulations below
bad values
rsa with
oaep from
oaep conversion
proven under
one outputs
new computational
plaintext checking
been encrypted
pr askg
latter event
event askh
public data
reaction attacks
answers whether
attacks 10
domain one wayness
one wayness of
partial domain one
the decryption oracle
the partial domain
wayness of the
to the decryption
been asked to
asked to h
wayness of f
g and h
adaptive chosen ciphertext
and h respectively
succ s gammapd
s gammapd gammaow
asked to g
oracles g and
the one wayness
decryption oracle and
the success probability
chosen ciphertext attacks
succ pd gammaow
random oracles g
has been asked
the event that
set partial domain
under the partial
within time bound
decryption oracle simulation
functions g and
denotes the event
the random oracle
public key encryption
against adaptive chosen
oracle and the
adversary against the
q g delta
the rsa function
success probability succ
security of rsa
s is unpredictable
of the decryption
for any adversary
of rsa oaep
2 gammak 0
the e th
q d q
semantic security against
d q g
against the semantic
g list and
hash functions g
g and q
e th root
and q h
success probability of
the security of
of the permutation
of the reduction
semantic security of
significant bits of
chosen ciphertext attack
q h queries
h s is
h queries to
the semantic security
q g and
a random value
queries to the
most significant bits
the hash functions
the secret key
under the one
from the encryption
the gaussian reduction
event means that
a cca2 adversary
of f means
the encryption oracle
r is unpredictable
and h list
g delta 2
a is upper
cca2 adversary against
the partial pre
decryption oracle simulator
queries asked to
trapdoor one way
making q d
be a cca2
of the rsa
gammapd gammaow a
one way permutation
the random oracles
security of oaep
the challenge ciphertext
delta 2 gammak
th root of
the g list
h respectively then
r has been
list and h
of plaintext awareness
the public key
security against adaptive
the h list
r to g
least significant bits
split according to
and the hash
a ciphertext c
is upper bounded
f means that
any adversary a
whose running time
time is bounded
upper bounded by
bits of the
to g and
bounded by where
denotes the time
random oracle model
means that for
of function f
the reduction is
to the partial
to the random
the time complexity
by the adversary
the rsa problem
an good lattice
latter event means
proof 3 based
askg j askh
one outputs a
and random oracles
between two messages
that relation holds
such a security
full domain one
list of queries
these simulations below
askh occurs h
application of oaep
event that r
having asked r
significant bits are
checking oracle which
plaintext awareness 1
the latter event
corrected definition of
the oaep conversion
given a message
be proven under
to be decrypted
asked r to
oracle simulation ds
of any ciphertext
key encryption schemes
respectively see the
shoup s result
actually be proven
as the ciphertext
pd gammaow a
security proof exists
quite unlikely that
event that query
should be negligible
respectively then succ
of her choice
occurs h s
the random self
defined and thus
the oaep cryptosystem
than 2 gammak
adversary a whose
chosen plaintext attack
one wayness the
the underlying permutation
the corrected definition
15 recently showed
concatenated to the
except the challenge
gammaow a is
any trapdoor one
be split according
rsa oaep can
of our reduction
the set partial
probability succ s
secure under the
pre image s
partial pre image
image s of
shoup 15 recently
is quite unlikely
succ ow a
of oaep from
time bound t
is an good

corpus/krapavin2000-test/1009027.txt
document
corpus
documents
pd
clusters
baseline
facetsq
prec
lm
topclusters
retrieval
precision
cluster
ap88
aspect
ap89
interpolation
ranking
bag
idf
pc
smoothing
tf
scoring
zhai
score
specic
rank
facets
language
58
corpora
57
89
template
la
qjc
qjd
topdocs
latent
query
fr
chengxiang
stemmer
avg
dirichlet
trec
select
relevance
similarity
sigir
cjd
jfacetsq
cluster_size
c2facetsq
hyeok
lillian
kurland
interpolated
ranked
hoc
seung
hoon
lemur
interp
feedback
oren
clustering
ad
cohort
stemmed
tao
eect
pseudo
yes
smoothed
chains
pus
lavrenko
laerty
salvador
inquery
stopword
modeling
incorporation
bremen
pt
probabilistic
classic
induced
jong
stemming
optional
unsupervised
porter
xuanhui
reexamining
qiaozhu
dint
croft
lee
overlapping
markov
thought
statistics
hofmann
kang
na
hyperlinks
ndings
mei
association
selection
divergence
nal
emphasizing
sloan
suers
competitive
incorporating
dierent
incorporate
29th
curves
92
docu
eective
lambda
statistically
queries
14th
formation
020
aggregates
reliance
leibler
brazil
text
utilizing
improvements
kullback
46
ir
specied
vocabulary
iis
28th
diers
signicance
65
degradation
kl
bruce
instantiations
wherein
06
management
concatenating
scores
enhance
1000
05
germany
cor
dependence
uniform
re
toolkit
yielded
fee
dierences
ment
annual
cussion
3261
detemine
drugs
frequen
mykola
roh
lms
breck
cacy
demonstrably
4805
stoyanov
ves
trieved
rooney
shimon
0329064
domshlak
uage
compel
krovetz
detrimen
carmel
conceives
xiaoyong
upset
aspect x
pd q
language models
language modeling
re ranking
interpolation algorithm
facetsq d
topclusters q
language model
the aspect
pc q
basis select
re rank
ap88 89
uniform aspect
bag select
information retrieval
average precision
the baseline
set select
la fr
aspect model
x algorithm
tf idf
q m
lm approach
the interpolation
document specic
avg prec
baseline lm
cluster based
precision at
corpus structure
modeling approach
by pd
pseudo feedback
and ap88
select set
similarity structure
prec at
select algorithm
the corpus
clusters in
select bag
baseline basis
ap89 and
document information
at 0
documents in
based language
individual document
the document
cluster information
precision recall
the clusters
retrieval information
interpolated precision
information representation
hoc information
topdocs n
hoc retrieval
in topclusters
document language
feedback markov
standard language
p qjc
p qjd
relevance model
optional re
pc d
ranking step
rank step
x uniform
algorithm template
a document
relevant documents
the cluster
our algorithms
retrieval august
m pd
document s
scoring function
chengxiang zhai
ad hoc
of clusters
particular document
retrieval time
specic information
c p
in information
international acm
sigir conference
acm sigir
the bag
to information
and interpolation
and corpus
2 facetsq
induced language
precision curves
inter document
for la
c2facetsq d
curves corpus
to choice
11 pt
jfacetsq d
recall 11
in facetsq
hoon na
seung hoon
x precision
recall 48
lm based
at retrieval
cohort d
non interpolated
standard lm
three corpora
interpolation algorithms
p cjd
oren kurland
hyeok lee
select aspect
average non
kurland lillian
qjc p
su kang
component documents
basic lm
jong hyeok
for ap89
information drawn
qjd c
q jfacetsq
pt precision
our aspect
document clusters
lillian lee
clusters c
on research
induced from
management an
precision for
ranking is
document d
competitive with
query independent
overlapping clusters
the lm
22 45
smoothed language
d pc
smoothing method
eect of
facets of
markov chains
on pc
58 2
representation e
free parameter
in su
the scoring
na in
the documents
annual international
a cluster
development in
the optional
model 9
clusters as
our framework
corpus we
from documents
cluster size
a query
incorporation of
of documents
and management
the language
and development
models proceedings
unsupervised learning
recall and
31 november
october 31
0 57
an international
2005 bremen
bremen germany
14th acm
yes no
05 2005
v 43
methods we
k 40
chains algorithm
s emphasizing
57 89
tao xuanhui
topclusters q m
the interpolation algorithm
the aspect x
uniform aspect x
language modeling approach
aspect x algorithm
select set select
prec at 0
based language models
by pd q
basis select set
and ap88 89
baseline basis select
set select bag
aspect x and
modeling approach to
select bag select
ap89 and ap88
to information retrieval
the clusters in
approach to information
of the corpus
pd q and
re ranking step
m pd q
x and interpolation
q m pd
in topclusters q
pseudo feedback markov
c p qjc
re rank step
cluster based language
document specic information
ad hoc information
lm approach and
ad hoc retrieval
standard language modeling
re ranking is
x uniform aspect
hoc information retrieval
aspect x uniform
in information retrieval
of the interpolation
information retrieval august
the language model
sigir conference on
development in information
conference on research
acm sigir conference
international acm sigir
annual international acm
on research and
and development in
in facetsq d
non interpolated precision
document language models
individual document information
the standard lm
to choice of
our aspect x
p qjd c
the optional re
clusters in topclusters
induced language models
c2facetsq d pc
precision curves corpus
language models proceedings
recall 11 pt
jfacetsq d j
feedback markov chains
the baseline lm
for la fr
interpolation algorithm s
the aspect model
in su kang
the standard language
at retrieval time
information drawn from
bag select aspect
for ap89 and
q jfacetsq d
the basis select
the basic lm
at 0 57
and interpolation algorithms
the bag select
hoon na in
precision recall 11
11 pt precision
2 facetsq d
of re rank
precision at 0
seung hoon na
d pc q
aspect model 9
similarity structure of
pd q jfacetsq
that the aspect
p qjc p
bag select algorithm
of dependence on
pt precision curves
oren kurland lillian
optional re ranking
aspect x precision
kurland lillian lee
c 2 facetsq
select aspect x
information retrieval information
jong hyeok lee
for our algorithms
na in su
average non interpolated
clusters in facetsq
information processing and
and management an
processing and management
management an international
degree of dependence
of the aspect
with respect to
documents in the
precision for the
a particular document
representation e g
research and development
competitive with the
journal v 43
an international journal
for information retrieval
14th acm international
05 2005 bremen
in the nal
october 31 november
november 05 2005
management october 31
models proceedings of
31 november 05
international journal v
2005 bremen germany
for the language
facets of the
can be thought
number of documents
knowledge management october
the 14th acm
v 43 n
original aspect model
respect to average
cluster induced language
all three corpora
learning by probabilistic
the re rank
avg prec 21
prec 21 03
smoothed language models
in the bag
recall at n
j 0 redundant
xuanhui wang qiaozhu
top ranked documents
by dint of
eect of using
ranking by pd
induced from d
pd q is
lm basis s
and zhai s
n top scoring
language models and
retrieval information retrieval
corpus similarity structure
algorithm see table
aspect x interp
the similarity structure
facetsq d score
latent dirichlet allocation
our algorithm template
expanded query language
ap88 89 k
89 k 40
aspect x algorithms
unsupervised learning by
bayesian extension to
q m c2facetsq
11 point precision
document expansion proceedings
our novel algorithms
the uniform aspect
model induced from
89 58 16
average precision corpus
nal output list
the 29th annual
dirichlet smoothed language
eect of re
august 06 11
methods we used
s set s
cluster_size 40 baseline

corpus/krapavin2000-test/1009186.txt
powerset
algebra
sparse
relational
nested
nonemptiness
flat
expressible
paredaens
database
suciu
nesting
gebra
schema
fixpoint
proposition
expressions
equa
equations
parity
databases
expression
query
delta
transitive
fxg
fagin
sparsity
ef95
ahv95
closure
operator
equation
kolaitis
fewp
sym
fragment
np
alge
unambiguous
equals
bra
frg
deed
polynomial
subgroup
sp97
kol90
fag74
liebeck
9so
all86
wonder
names
vianu
abiteboul
primitive
pi
analogue
schemas
permutation
unnesting
polynomially
tuples
asking
appendix
jrj
sentence
alt
automorphism
enumerate
operators
ary
tc
monadic
singleton
logic
rid
occurring
relation
relations
strategy
cardinality
rg
innermost
intermediate
fx
undecidable
assum
hillebrand
roundabout
gsvg95
gv95
lie83
blows
wel
detective
biguous
bochert
ah95
ebbinghaus
imprimitive
tf86
av91
disequations
disequation
directness
jaut
vdb
aszl
gyssens
frivolous
contri
flum
grumbach
erful
arity
complements
theta
name
invoking
remark
tuple
existential
solutions
accepting
fragments
constructs
equality
unnest
jgj
unam
aut
gucht
turing
permutations
alternating
neighbors
fr
rediscovered
disguise
definability
babai
crux
unresolved
elegant
enumeration
nothing
gin
automorphisms
conjecture
sufficiently
showed
duction
definable
formu
stars
talking
symbol
disallow
pow
recalls
finite
uation
deterministic
introduces
tg
strictness
closures
oe
express
evaluates
lation
argu
recognizable
inclusions
transitively
standpoint
guages
augmented
clutter
invert
who
merely
decided
subexpression
stem
bution
spectra
quantifier
conversely
equivalently
recursively
las
conjectured
ready
stands
atomic
ask
exponential
nested relational
equation algebra
relational algebra
powerset algebra
algebra expression
the powerset
sparse equations
the nested
the equation
algebra expressions
finite domain
natural evaluation
database b
expression e
polynomial space
relation names
evaluation strategy
free e
relation variables
sparse equation
an equation
relation name
not expressible
nonemptiness problem
a sparse
of type
transitive closure
al gebra
sparse powerset
fixpoint query
parity query
the nonemptiness
powerset operator
relational databases
a solution
e 1
expressible by
a database
suciu and
over s
domain d
the parity
type 0
schema s
any database
b over
expressible in
and paredaens
algebra equation
nesting operator
equation expression
over fxg
solution operator
a relation
order logic
is expressible
all equations
have free
fagin s
e 2
form e
all solutions
the relation
flat relational
using sparse
equation e
a relational
a over
an expression
proposition 7
equation is
input database
solution on
algebra is
s theorem
recursively evaluating
powerset expression
nesting is
of sym
every fixpoint
logic sentence
0 tuples
algebra are
sym d
equations occurring
flat variable
sparse if
space fragment
that database
a flat
of flat
relation of
the natural
equations that
the appendix
can write
in np
for equation
databases over
asking whether
operator itself
equality type
of fagin
occur free
relation variable
define definition
database over
empty if
database schema
of relation
fragment of
subgroup of
evaluate an
permutation groups
evaluating e
finite model
alge bra
set delta
r equals
with finite
result by
intermediate results
in deed
equa tion
pi r
write a
fixed set
equals the
on any
the transitive
equa tions
delta of
database schemas
the constructs
each database
polynomially many
given database
are sparse
is empty
closure of
query language
power set
model theory
constructs of
solution set
database a
e b
algebra to
for nested
the nesting
this proposition
let r
a schema
polynomial size
algebra we
query is
neighbors a
e 6
domain as
relation r
gebra the
natural strategy
existential second
expression proof
solution expression
fag74 ef95
equation over
by kolaitis
equations so
powerset expressions
suciu paredaens
expressible using
r ary
most polynomially
np properties
sparse fragment
nonemptiness problems
theorem fag74
many accepting
fxg with
paredaens sp97
expressions over
variable equation
algebra proposition
algebra either
flat databases
abiteboul and
over fr
the suciu
e tc
equations only
an equa
proposition given
expression sparse
same finite
algebra by
equation alge
flat schema
space powerset
any fixpoint
the nested relational
nested relational algebra
the equation algebra
the powerset algebra
algebra expression e
natural evaluation strategy
equation algebra expression
relational algebra expression
finite domain d
nested relational databases
a database b
of the nested
in the powerset
the natural evaluation
by a sparse
is not expressible
a sparse equation
a relational algebra
relation of type
e 1 and
expressible by a
expressible in the
on any database
the parity query
equation algebra expressions
database b over
in the equation
1 and e
and e 2
of the equation
of type 0
the powerset operator
the nonemptiness problem
sparse equation expression
database a over
write a relational
fagin s theorem
b over s
relational algebra equation
nonemptiness problem of
we have free
all solutions of
not expressible by
for equation algebra
suciu and paredaens
be a relation
with finite domain
empty if and
the polynomial space
a relation of
can write a
of an equation
that on any
given a database
in polynomial space
in the appendix
is empty if
the form e
recursively evaluating e
fixed set delta
equals the relation
the finite domain
using sparse equations
all equations occurring
parity query is
an equation algebra
b with finite
the equation e
relation variables of
equations occurring in
powerset algebra expressions
r 0 tuples
to the nested
relational algebra are
of fagin s
of relation names
a sparse powerset
equation algebra is
powerset algebra expression
order logic sentence
on each database
by recursively evaluating
strategy for equation
a over fxg
every fixpoint query
subgroup of sym
neighbors a t
space fragment of
sparse powerset expression
a relation name
evaluation strategy for
polynomial space fragment
finite domain as
for the constructs
database b with
a schema s
transitive closure of
on a database
such that on
fragment of the
to the powerset
one can write
r equals the
constructs of the
form f x
that the parity
to evaluate an
finite model theory
not expressible in
first order logic
only if x
the transitive closure
if x a
proposition 6 1
in the nested
that e 1
the constructs of
solutions of an
of all solutions
of the form
a fixed set
the relational algebra
on each input
of this proposition
of the powerset
of polynomial size
in the relational
if and only
and only if
a query language
without using the
a solution of
query is not
the form f
a subgroup of
equations in the
let r be
equation al gebra
polynomially many accepting
equation algebra either
theorem to nested
logic sentence is
extension of fagin
same finite domain
flat relational databases
the relation names
fixpoint query is
space powerset algebra
the equation al
enumerate all databases
machine that has
proposition 7 2
if all equations
expressions e of
e b equals
occur free in
showed that transitive
the natural strategy
database over s
expression sparse if
polynomial space powerset
many accepting computations
name of type
e free e
expressions over the
not primitive in
of nested relational
polynomial size on
flat relational algebra
database c over
strategy to evaluate
an equa tion
for expressions e
nonemptiness problem is
and paredaens sp97
relational databases we
e b one
nested relational data
a result by
any database c
of type on
e 2 can
that transitive closure
on that database
appendix is a
nested relational al
of flat relational
this proposition given
relation names of
each relation name
relation names that
to nested relational
is true on
sentence is true
theorem fag74 ef95
computational complexity theory
nesting is expressible
al gebra the
the equation alge
unique solution on

corpus/krapavin2000-test/1009192.txt
coloring
colorable
colored
pcp
colors
hardness
chromatic
gadget
vertices
pcps
clique
np
gadgets
color
leaf
inapproximability
cliques
legally
h211i
h123i
row
rows
khanna
h332i
h221i
h231i
h112i
h122i
legal
template
templates
ground
vertex
h113i
h212i
h332ig
h331i
fh331i
fglss
3g
graphs
safra
zpp
adjacent
children
linial
schematic
hard
resorting
selected
fh221i
h323i
h113ig
fh112i
miscolors
h223i
h322i
h121i
varepsilon_0
h223ig
pure
wraparound
sudan
spur
f1
root
approximating
reduction
selection
tree
f3
constructions
cover
claim
node
murray
edges
coordinate
max
labs
claimed
proposition
hill
bell
receive
sketch
sat
degree
approximate
enforce
2g
urer
timetable
hxyzi
petrank
h111i
upenn
h312i
ambitiously
pigeonhole
19104
combinatorica
fpcp
iler
madhu
f2
imply
enforces
email
comprises
highlights
connection
lcs
snp
sanjeev
feige
kilian
upshot
partite
enforcing
turing
ask
relying
gap
induce
pp
layered
qualitative
02139
kh
hardwire
venkat
lund
garey
805
astad
edge
longest
fraction
instances
greedy
semidefinite
8j
goldreich
definiteness
915
assign
leaves
bits
strong
lemma
prevents
labels
cis
545
colorings
codeword
aspect
optimum
covering
nodes
checkable
arguing
edu
yannakakis
lth
gramming
sketches
familiarity
sr
bellare
concreteness
gets
permutation
reducibility
393
1g
labeled
intricate
223
blum
epsilon
grid
viz
quantifiers
ago
strengthening
completeness
copy
decades
injection
across
distinguish
insert
began
reversal
comput
artifact
332
internal
3 colorable
4 coloring
colored 3
pcp theorem
colorable graphs
coloring of
chromatic number
the pcp
independent set
t i
be colored
is colored
graph coloring
hardness of
np hard
hardness result
graph h
the chromatic
is np
third row
leaf level
colorable graph
for coloring
the vertices
colored 2
ground vertices
level gadget
the hardness
vertices in
not selected
in g
any 4
hard to
colored 1
coloring 3
coloring a
graph g
a graph
of g
row of
color 4
colored 4
r cliques
this hardness
colored using
4 colors
i p
tree structures
is selected
inapproximability results
max clique
is pure
the leaf
of h
1 colors
3 coloring
4 colorable
pcp constructions
the gadget
legally color
graph using
vertices of
to color
color a
our proof
selection at
three colors
are colored
degree bounded
coloring the
a 3
rows in
the schematic
hardness results
colors is
any legal
three rows
be selected
r i
v i
coloring is
2 3g
leaf node
colorable then
templates at
gadget shown
level gadgets
receive color
the fglss
fh331i h332ig
pcp techniques
selected leaf
basic template
approximate graph
h basic
legal 4
clique r
colors 1
h112i h113i
has colors
gets colored
g 0
the tree
in h
colors in
the r
of theorem
proof of
theorem 1
of colors
selected but
np 6
every constant
imply some
node correspond
of pcp
linial and
cliques r
color all
legal coloring
its children
lemma 2
is adjacent
g r
the proof
of 19
pattern between
most it
h is
the third
an independent
f1 2
the graph
least r
constant h
is 3
least one
are adjacent
k vertices
like structures
selected and
each row
a legal
hardness for
resorting to
using just
general graphs
the root
of independent
tree t
of vertices
adjacent in
the clique
adjacent to
the reduction
rows of
a node
bounded degree
constant 0
vertices are
approximate within
for chromatic
h123i is
connection pattern
to h211i
good covering
range c
vertex colored
fh112i h113ig
number g
colors this
khanna linial
assign colors
to legally
kind 2
enforcing selection
h212i and
now start
general 3
gadget in
0 fraction
require pcps
and fh331i
6 zpp
spur further
free bits
strong hardness
receives color
pcps in
corresponding templates
chromatic numbers
hardness bound
h231i and
h113ig fh221i
pcps are
colored either
side node
different rows
pure so
vertices h122i
4 coloring of
the pcp theorem
3 colorable graphs
np hard to
is np hard
it is np
the chromatic number
3 colorable graph
coloring of h
the third row
leaf level gadget
any 4 coloring
a 3 colorable
colored 3 1
coloring 3 colorable
the graph h
is colored 3
a graph g
the hardness of
third row of
v i p
is 3 colorable
of independent set
is not selected
t i p
the leaf level
3 1 2
of the vertices
l and r
for coloring 3
this hardness result
hard to color
chromatic number of
which is colored
the three rows
hardness results for
colorable graph using
r is pure
in any 4
be colored 3
vertices in each
colored 2 and
an independent set
hardness result for
i p and
hard to approximate
within a factor
f1 2 3g
the tree structures
tree t i
the vertices in
r i of
independent set of
t i j
situation where t
4 colorable then
legal 4 coloring
are colored 3
coloring a graph
4 coloring a
colored 3 2
cliques r i
coordinate of each
receive color 4
to color a
r in g
pcp theorem and
node is selected
clique r i
any legal 4
pattern between the
into r cliques
form of pcp
selected and it
r cliques r
legally color all
leaf level gadgets
rows are colored
on the hardness
is colored 1
most it is
approximate graph coloring
is 4 colorable
least one of
set of size
given a graph
in g 0
our proof is
vertices of g
i of g
must be colored
independent set in
vertices in h
must be selected
at most it
of the pcp
cannot be colored
node correspond to
hard to distinguish
color a 3
each node correspond
for every constant
at least one
the proof of
proposition 3 1
the vertices of
p is selected
a graph h
tree like structures
colors in the
g 0 for
adjacent in g
1 i r
of theorem 1
of t i
vertices in the
p and t
i p 1
number of g
at least r
of l r
number of colors
that the third
where t i
proof of theorem
v in g
number of vertices
each t i
t i s
to the situation
of the tree
is adjacent to
i j is
in t i
the corresponding templates
fh221i h223ig and
pure so that
templates as f1
2 now if
of each t
selected one of
the ground vertices
khanna linial and
to the pcp
0 fraction of
interpreted as selecting
labs murray hill
and r will
result for coloring
the r cliques
h123i is adjacent
the vertices h122i
p v i
assumption np 6
shared across all
partitioned into r
i e coloring
coloring a 3
the basic template
highlights a qualitative
the 4 coloring
rows in its
and to both
hardness result does
three rows in
adjacent to h211i
result of 19
the pairs fh112i
can legally color
fh112i h113ig fh221i
graph using only
3 the connection
linial and safra
strong hardness results
exactly k vertices
for approximate graph
connection pattern between
only 4 colors
as selecting a
if g r
just 4 colors
approximate the chromatic
h223ig and fh331i
right form an
hardness of 4
the gadget shown
gadget shown in
which reading from
of 4 coloring
pcp theorem in
in its template
labels differ in
reading from left
colorable graphs and
three ground vertices
uniform h hardness
colors 1 2
an instance g
hard to legally
such graphs can

corpus/krapavin2000-test/1009317.txt
liveset
probe
cells
gradient
cell
descendant
iceberg
gradients
oronto
quant
grad
cube
descendants
mining
avg
pruning
cubes
info
significance
cubing
hpdw01
price
prb
constrained
driven
anti
mismatch
prune
ancestor
cubegrade
header
matchable
sibling
cient
constraint
sales
ancestors
sig
transactional
cnt
aggregated
dimension
business
toronto
association
siblings
jm
probes
tuples
ika02
dimensions
growth
attributes
monotonic
pruned
threshold
montreal
g1
jan
customer
vancouver
multidimensional
scalability
transaction
gcell
mds
grp
city
bins
household
runtime
di
g3
erent
solid
ciency
olap
mismatches
feb
bought
cust
sold
count
cp
education
erence
tree
sam98
br99
depth
items
1500
confined
monotone
huge
g2
measures
databases
sector
sectors
1900
gqs
imielinski
itemset
aggregates
itemsets
constraints
attribute
parent
fp
tuple
pairs
top
mutation
monotonicity
month
sharing
exploration
compressed
hyper
pc
weaker
rudimentary
dimensional
average
grow
pushing
ski
mined
5e
cd
4000
significant
dvd
dl99
drill
mdss
datacubes
potential
erences
explored
000
comparable
thresholds
item
examine
rough
deeply
house
rp
prices
schema
base
specialization
leaf
measure
roll
database
ovhd
hopeful
shopping
matchability
live
10000
frequent
buy
query
west
g4
professionals
interestingness
buyers
explores
ciently
link
attr
prod
ascending
queries
scalable
sql
weakly
matching
roughly
100
labeled
constrain
cardinality
prunes
1800
search
rules
relational
searches
links
ok
mine
warehousing
subsection
microsoft
probe cells
c g
c p
gradient cell
gradient cells
probe cell
liveset driven
cell c
constrained gradients
the liveset
of probe
all significant
gradient constraint
the gradient
h tree
significant pairs
quant info
k average
data cubes
t oronto
liveset c
gradients in
top k
data cube
gradient analysis
gradient probe
avg price
c grad
significance constraint
mining constrained
interesting gradient
a gradient
header table
e cient
descendant of
constraint c
of c
driven algorithm
grad c
c sig
h cubing
probe constraint
solid mismatch
c prb
price c
to prune
the probe
constrained gradient
a descendant
of cells
a probe
anti monotonic
significance threshold
the significance
base table
transactional databases
a jm
table h
cells in
a cell
g c
the measure
a sibling
prune the
cells and
matchable with
probe pairs
cells p
d cell
gradient threshold
is matchable
measure values
probe constraints
each probe
sibling of
c 3
depth first
potential to
c g1
its descendants
for pruning
anti monotone
of liveset
in liveset
one solid
base cells
cube computation
side link
cell constraint
iceberg cube
avg k
in transactional
cells to
association rules
of probes
an ancestor
average of
and probe
be pruned
pruning of
descendant cell
measure attributes
pairs algorithm
pairs liveset
100 average
liveset of
iceberg cubes
significance constraints
driven figure
potential gradient
all probe
gradient constraints
some descendant
dimension matching
in data
cells c
p is
cell and
the top
for mining
to mining
sig and
constraint is
and c
multi dimensional
set oriented
of gradient
the cells
an e
cells that
and gradient
significance and
top 100
c g2
oriented processing
the quant
probe pair
ancestors descendants
hyper tree
comparable cells
computing iceberg
the cubegrade
side links
weaker anti
average price
cells w
cient iceberg
aggregated cells
per probe
liveset for
in hpdw01
descendants can
no mismatch
gradient mining
c g3
ancestor of
of dimensions
w r
cell to
the search
descendants of
our study
multidimensional space
descendants and
g is
of tuples
the constrained
e ciency
p c
m c
bins to
di erent
of constrained
search space
r t
changes in
c is
the all
maximal sharing
cubegrade problem
matching analysis
aggregated cell
our scope
dimensional gradient
pairs let
descendants have
measure value
prb and
base cell
or descendants
mismatch but
complex measures
of cp
sales price
iceberg growth
interesting gradients
c gcell
has potential
threshold all
dimensional cells
of probe cells
all significant pairs
set of probe
constrained gradients in
top k average
c p is
of c g
mining constrained gradients
the gradient constraint
a gradient cell
liveset driven algorithm
g c p
descendant of c
the liveset driven
c g c
c grad c
in data cubes
gradient cell c
c g is
interesting gradient probe
liveset c g
constrained gradient analysis
gradients in data
header table h
c g and
a sibling of
is a sibling
avg price c
probe cells and
a probe cell
gradient probe pairs
cell c g
grad c g
probe cell c
the top k
a descendant of
a cell c
cell c p
a data cube
probe cells p
probe constraint c
cell c is
constraint c prb
sibling of c
constraint c sig
is matchable with
significance constraint c
to prune the
of c 3
for each probe
in transactional databases
the all significant
one solid mismatch
the significance constraint
for mining constrained
p is matchable
gradient cell constraint
each probe cell
the gradient cell
number of probes
all pairs liveset
probe cells to
c sig and
c g if
constraint c grad
liveset driven figure
significant pairs algorithm
an interesting gradient
top 100 average
d since c
the probe cells
iceberg cube computation
cells c p
100 average of
the probe constraint
gradient constraint c
pairs liveset driven
price c g
gradients in transactional
potential to grow
is a descendant
w r t
g and c
the top 100
the base table
c p c
c p in
an e cient
number of cells
and c p
is an ancestor
interesting gradient cells
gradient constraint is
set oriented processing
c g or
the liveset of
be interesting gradient
a gradient constraint
gradient cell and
gradient probe pair
pairs of cells
cells w r
in liveset c
average of c
e cient iceberg
all probe cells
per probe cell
of all significant
of bins to
significance and probe
the h tree
gradient cells w
the significance and
k average of
and probe constraints
of gradient cells
the quant info
probe cells c
the measure attributes
sharing of computation
the significance threshold
c p and
an ancestor of
of c p
c d since
example one may
to be interesting
cells in the
the set of
p and c
number of tuples
can be pruned
the data cube
used for pruning
multi dimensional space
average of the
the complete set
potential to be
descendants of c
solid mismatch but
quant info in
the average price
its descendants have
and its descendants
driven algorithm is
probe constraints to
bins to 3
a significance constraint
potential gradient cells
c p v
threshold all pairs
the header table
1 a jm
c g can
c p such
of data cube
c prb and
a multidimensional space
significant probe cells
data cube and
a probe constraint
matchable with c
has potential to
gradient analysis problem
descendant cell c
depth first order
mismatch but no
gradient probe cell
oriented processing and
if the gradient
set of gradient
depth first descendant
descendants and siblings
price c p
cube computation algorithm
weaker anti monotonic
ancestors descendants and
m c p
the dimensional attributes
probe cell in
the gradient threshold
the 0 d
the gradient cells
ancestor of c
but no mismatch
to mining constrained
the two algorithms
c 3 is
number of bins
2 and c
the measure m
j 1 a
p c p
and sum of
and the probe
number of probe
using the gradient
complete set of
prune the search
of c 2

corpus/krapavin2000-test/1010995.txt
erlang
locker
client
crl
starvation
pending
clients
resources
specication
resource
locks
demanded
exclusion
verication
ok
mutual
server
release
eects
request
checker
huch
gen_server_reply
identier
callback
rst
requests
supervision
loop
ericsson
reply
evtfollow
handle_call
mcrlarg1
checking
processes
toolset
self
yn
releases
starve
notied
promela
pathfinder
send_reply
eect
java
tag
supervisor
alternation
viz
y1
transition
requesting
eld
stamp
served
module
translate
gen
scenario
roy
modules
generic
translation
deadlock
actions
locks2
fredlund
check_availables
erlangterm
obtainables
axd
ebaran
newlocks
chanchal
csar
all_pendings
xs
message
atm
calculus
critical
action
noll
ald
access
tool
hours
prover
dierent
tallinn
ication
bandera
estonia
liveness
elds
conguration
scheduler
development
translated
sigplan
lars
lock
repeatedly
uml
requested
priority
wonder
gets
appending
hd
spin
removing
crashes
exclusive
million
301
congurations
instantiated
started
scheduling
specic
transformation
eq
monitors
spec
statements
abstracts
veried
return
nd
portland
init
safety
verify
oregon
formulating
append
fault
promote_pending
map_f
resourcesg
ingenuity
svensson
itrue
benac
spawn_link
hubert
conrmation
cordy
therewith
noreply
wcallresult
pendings
boil
izak
dilian
map_release_lock
earle
claessen
garavel
congu
rcallresult
jaco
sics
alpes
aldbaran
promissing
banani
locks_updated
gen_server_call
advises
clientserver
ake
gen_server
critical_section
langevelde
gurov
fty
rhone
nite
programs
list
workshop
lists
calls
kumar
loops
clara
unsettled
koen
frequest
fokkink
pol
mateescu
caesar
noties
innite
excluded
the locker
the erlang
crl specication
the client
model checking
the crl
client 3
access pending
the pending
mutual exclusion
client 1
generic server
no starvation
erlang programs
in erlang
the clients
the resource
pending list
demanded resources
of erlang
transition system
side eects
clients and
server call
client 2
on erlang
handle call
model checker
side eect
pending 3
critical section
resources are
pending processes
locker algorithm
gen server
supervision tree
erlang code
all demanded
two resources
in crl
erlang modules
client is
call function
of resources
pending access
callback module
erlang to
repeatedly request
erlang september
erlang program
alternation free
this locker
one crl
and locker
y1 yn
locker self
locker resources
clients repeatedly
end locks
starvation is
to crl
the specication
a resource
access to
of clients
3 access
exclusion property
eect free
resources and
three clients
get access
all resources
with side
specication the
the resources
verication of
resources the
exclusion and
resource a
few hours
the mutual
loop locker
notied and
free functions
starvation problem
gets access
demanded resource
requests resource
ok self
to erlang
pending lists
erlang processes
rst come
locker process
come rst
a client
sigplan workshop
and resources
the generic
case study
return value
resource is
resource the
specication language
the gen
is notied
the handle
source transformation
case statements
clients the
the rst
time stamp
we translate
a release
one resource
checking tool
formal verication
resource and
data types
available if
the supervision
a million
this tool
the critical
design patterns
of deadlock
the locks
clients that
to source
a rst
the model
the list
list of
the transition
the development
this loop
access eld
deadlock mutual
resource b
requests b
give access
specic conguration
1 pending
within ericsson
locker are
process identier
check_availables resources
stamp the
implementation language
rst serve
crl a
release client
self locker
resource after
huch 15
resources again
1 releases
both resources
translate erlang
axd 301
ok message
2 pending
gen_server_reply client
which monitors
to starve
obtainables locks
erlang transformation
starvation for
3 requests
list access
scenario s
free calculus
requests both
client ok
csar ald
access 2
hd mcrlarg1
a locker
locker the
reply ok
erlang function
causes client
x y1
classical properties
301 atm
xs y1
call stack
starvation since
starvation in
contain side
access 1
locks false
an ok
ald ebaran
locker and
self locks2
into crl
formally veried
kumar roy
atm switch
the crl specication
pending 3 3
the client is
to the resource
in the erlang
the pending list
resources are available
gen server call
the generic server
the transition system
of erlang programs
on erlang september
3 3 access
crl specication the
of the pending
side eect free
workshop on erlang
clients repeatedly request
of the locker
demanded resources are
the erlang modules
the clients repeatedly
all demanded resources
the mutual exclusion
the model checking
the critical section
mutual exclusion property
with side eects
mutual exclusion and
sigplan workshop on
acm sigplan workshop
three clients and
rst come rst
eect free functions
the erlang program
access pending access
a rst come
clients and locker
pending access pending
absence of deadlock
clients and resources
the supervision tree
the gen server
client 1 and
access pending 3
the handle call
handle call function
gets access to
one crl specication
loop locker resources
to the crl
functions with side
is notied and
in the pending
the pending processes
access to the
number of clients
number of resources
of clients and
resource and the
to source transformation
a model checker
get access to
a resource is
model checking tool
case study we
a few hours
source to source
in the transition
model checking for
of the resource
the locker process
list of pending
3 access pending
if all demanded
access 2 pending
implementation in erlang
ok self locker
list of resources
in crl a
of the crl
a 1 action
to erlang transformation
specication the erlang
pending list access
28 2005 tallinn
3 to starve
and no starvation
want to access
resource as an
clients and two
deadlock mutual exclusion
xs y1 yn
and 3 clients
the erlang code
is no starvation
no starvation is
which all demanded
causes client 3
erlang september 26
clients that want
come rst serve
chanchal kumar roy
this generic server
resource a client
client 3 requests
a specic conguration
approach of huch
client is notied
resource the client
of side eect
callback module the
check_availables resources locks
starvation for the
client 3 in
a million states
list of clients
and two resources
x y1 yn
csar ald ebaran
generic server design
the erlang processes
specication is used
into one crl
of pending processes
request of a
locker is implemented
access 1 pending
f x y1
in the arguments
alternation free calculus
in the callback
exclusion and no
erlang program for
a crl specication
the callback module
request an arbitrary
repeatedly request an
contain side eects
server call function
301 atm switch
requests both resources
pending list in
client 2 releases
locker process is
client 1 releases
erlang to crl
the pending lists
erlang september 16
use of model
client ok self
only one resource
transition system the
axd 301 atm
starvation is an
give access to
of the erlang
gen_server_reply client ok
erlang to erlang
and removing the
client 1 requests
2 pending 3
are two resources
that contain side
call function are
this loop we
implemented in erlang
requests resource a
starvation in the
is eventually followed
releases and requests
self locker self
the process identier
a real implementation
time stamp the
all resources that
side eects in
in the crl
the locker the
end locks false
september 26 28
erlang code that
client 3 to
which the clients
using the generic
and model checker
non deterministic choices
around this problem
functions that contain
a realistic setting
transition system is
16 2006 portland
the model checker
september 16 16
the clients the
16 16 2006
the request of
using model checking
a side eect
26 28 2005

corpus/krapavin2000-test/1011175.txt
alat
category
pequ
functor
equilogical
assm
equ
assemblies
lattices
equivalence
dom
codense
spaces
modest
dper
cartesian
berger
algebraic
pca
realizers
subobjects
fibration
equivariant
mod
jdj
totality
morphism
mappings
subcategory
powerset
powered
functionals
categorical
categories
i2x
realizability
topological
subobject
topos
kreisel
realizer
lattice
ershov
pcas
ja
countable
topology
closed
quotient
tripos
coproducts
morphisms
jej
dense
cocomplete
regular
adjoint
comprehension
continuous
object
kleene
domains
equalizers
top0
chevalley
beck
ccc
jaj
quotients
analogy
sigma
faithful
theta
fibred
terminal
pullback
jlj
equalizer
rosolini
fibrations
combinatory
externalization
coequalizers
relations
universe
constructions
products
family
adjoints
reindexing
scott
omega
pers
calculus
dependent
pcp
jt
separable
preserves
completions
manuscript
embed
objects
maps
embedding
reinhold
subcategories
toposes
closedness
coequalizer
carboni
ufam
hjaj
typed
flat
partial
split
suggestion
hd
surjective
dn
exponentiation
tracked
retracts
heckmann
impredicative
colimits
logic
ni
hm
jf
arrows
separating
identity
sublattices
fu
embeds
ex
tracks
subspace
inclusion
codomain
reflection
isomorphic
iterated
hierarchy
map
familiar
limits
canonical
top
jacobs
forgetful
isomorphism
lambda
factorizations
realizable
f0g
theories
underlying
formed
theorems
pure
shall
jk
closure
exponential
preserve
polymorphic
internal
synthetic
id
faithfully
virtue
triples
preprint
vertically
families
representatives
likewise
subsets
projection
union
realized
product
co
lifting
injective
axiom
classes
assembly
think
genesis
sentatives
contians
equailizer
isomorphically
relizer
jpcp
coequailizer
the category
mod alat
algebraic lattices
cartesian closed
partial equivalence
category of
equivalence relations
assm alat
modest sets
equilogical spaces
equivalence relation
type theory
a pca
per dom
dper dom
algebraic lattice
the functor
well powered
alat and
the equivalence
dependent type
of assemblies
equ is
in mod
and assemblies
assemblies over
regular subobjects
i2x i
berger 4
alat is
countable functionals
i theta
closed category
topological spaces
domain theory
equivalence classes
category equ
of equilogical
of realizers
theta a
a e
subcategory of
an object
full subcategory
top 0
regular subobject
m jdj
a realizer
spaces and
a category
a morphism
of algebraic
topological space
is cartesian
functionals of
kleene kreisel
is codense
terminal object
functor r
quotient types
over algebraic
of assm
in pequ
sigma topology
numbers object
with totality
sets over
category is
of per
of mod
finite types
of modest
continuous mappings
of topological
the powerset
the regular
a domain
powerset spaces
realizer for
alat the
in dper
internal category
a ex
0 space
category assm
assemblies and
equivariant mappings
object of
category with
the sigma
object i
f x
l l
of equivalence
x a
relation on
sets and
subobjects of
a full
the categories
natural numbers
continuous functions
domain d
of constructions
dom is
of dependent
mappings between
a cartesian
a topological
is separating
alat are
totality on
0 spaces
powered and
pequ is
a totality
co well
category pequ
chevalley condition
parallel arrows
codense and
the modest
i i2x
subset types
comprehension category
beck chevalley
domains with
lattices is
over a
the mappings
i x
spaces is
dom and
an algebraic
of domains
omega a
functor p
1 objects
with categories
finite limits
whose underlying
of continuous
topology on
x g
function space
limits and
the topology
and faithful
underlying domain
the kleene
continuous extension
and dense
pca is
universe of
i i
the partial
the algebraic
t 0
types and
categories of
theorem 4
the family
is modest
open sets
the morphism
b y
the terminal
analogy with
category the
type in
that equ
fibration of
equivalent proof
over pcas
split coproducts
tracks f
alat such
top adding
ccc of
of equ
alat since
and rosolini
sub ccc
the fibration
flat domain
hd m
a fibration
both assm
equ and
in berger
a codense
of pequ
category mod
and berger
partial combinatory
n jej
the externalization
adding functor
kreisel countable
codense set
the category of
over a pca
partial equivalence relations
i i theta
i theta a
of algebraic lattices
dependent type theory
in mod alat
cartesian closed category
partial equivalence relation
modest sets and
theta a e
of the category
of equilogical spaces
of per dom
sets and assemblies
the partial equivalence
the equivalence relation
full subcategory of
a full subcategory
category of assemblies
category of algebraic
the category equ
modest sets over
and assemblies over
equivalence classes of
l l l
is cartesian closed
equivalence relation on
over algebraic lattices
the sigma topology
of mod alat
natural numbers object
assemblies over a
the regular subobjects
countable functionals of
of equivalence relations
of modest sets
of assm alat
equilogical spaces and
an algebraic lattice
of topological spaces
a cartesian closed
that the category
i a x
a topological space
category of equilogical
regular subobjects of
t 0 space
assm alat and
the terminal object
x a ex
algebraic lattices is
category assm alat
the algebraic lattice
domains with totality
a realizer for
j b y
in dper dom
the functor r
mod alat and
is a full
the equivalence classes
an object i
of partial equivalence
a partial equivalence
x a e
f x g
in the category
to the category
i i2x i
a totality on
of dependent type
cartesian closed the
the function space
beck chevalley condition
of parallel arrows
and mod alat
the category pequ
the kleene kreisel
follows 1 objects
f i i2x
subset types and
universe of realizers
an internal category
the category assm
a pca is
mod alat the
of assemblies and
co well powered
well powered and
codense and dense
category of equivalence
t 0 spaces
mod alat are
the natural numbers
equivalence relations over
of finite types
has a continuous
full and faithful
a category is
equivalence relations on
1 objects are
a continuous extension
an object of
an object x
a domain d
dper dom and
the powerset spaces
of equivariant mappings
top adding functor
sigma topology on
the flat domain
the regular subobject
equivalence relations is
finite limits and
alat and mod
of type theory
functor r is
category of partial
underlying domain is
in berger 4
kreisel countable functionals
the category with
the category mod
the functor p
over the category
model of dependent
both assm alat
the extension theorem
a ex and
alat such that
regular well powered
spaces and the
categories defined over
the effective topos
analogy with categories
category mod alat
to the morphism
ex and y
of assemblies over
classes of continuous
of countable functionals
ccc of per
a small cartesian
cartesian closed categories
kleene kreisel countable
a generic object
a regular subobject
sub ccc of
maps a morphism
of dper dom
regular co well
that the functor
algebraic lattice is
the fibration of
type in context
small cartesian closed
functionals of pure
internal category in
of continuous mappings
a codense set
b e y
subcategory of per
alat is a
are the equivalence
type theory in
the top adding
sets over a
y b e
category of realizers
mod alat is
a e with
maps an object
whose underlying domain
the modest sets
continuous mappings between
see e g
to show that
a model of
is a cartesian
a right adjoint
dom be the
that the equivalence
be the category
theory and logic
object x a
has a right
2 jt j
i x z
continuous functions between
calculus of constructions
dom is a
of a topological
as a full
domain d is
type theory and
category in the
and y b
the analogy with

corpus/krapavin2000-test/1011176.txt
cpo
pcf
nat
lift
dyn
static
adequacy
sund
denotational
snf
operational
denable
semantics
compile
compilation
undenedness
dened
dapp
dund
cpos
pred
dynamic
interpretation
denition
d2
d1
hf
junk
residual
lemma
binding
arrow
compiled
induction
lambda
distinction
equational
sd
interpreted
ifz
typed
commutes
undened
substitution
name
interpret
evaluator
languages
uence
gi
handbook
purely
language
functor
termination
calculus
closed
factorisations
morphisms
formation
terminate
dene
embeds
counterpart
categorical
pragmatics
hypothesis
pow
lazy
partial
interpretations
pd
denotation
reductions
00
statically
relate
conversely
untyped
morphism
ut
usual
polymorphic
cartesian
intended
valid
rst
reduction
machinery
bool
rules
lifting
translation
interpreting
correctness
phases
semantic
nthen
parametrisation
postponent
compil
ftrue
plift
cuted
enrichment
2lpcf
hid
leeuwen
category
subtraction
specialized
continuous
terminating
wise
invalid
propagating
logical
soundness
interpretative
eugenio
unde
hearn
culus
lcf
falseg
id
diagrams
evaluations
chains
underlines
parametrised
intuitionistic
moggi
directed
isolation
rule
monotone
failure
respected
pv
fragment
abstraction
program
behaves
nal
murst
specialisation
formedness
evaluators
hh
essentially
contexts
preserves
deserve
seman
borrowing
px
exe
postponed
canonical
behaviour
categories
immediate
naturals
ned
xx
constructs
lemmas
cult
projection
postpone
asserting
novelty
judgement
conrms
versions
logic
crucial
macros
succ
cal
recursion
adequate
interplay
exibility
booleans
reconsider
equivalences
understand
syntactic
diagram
modications
behave
exponential
tics
comparatively
ness
relations
incorporate
calculi
2 level
dynamic terms
partial evaluation
the cpo
level pcf
dynamic types
call by
by name
operational semantics
type nat
in snf
the static
term m
d2 g
dyn f
the dynamic
denotational model
at compile
m 0
r d1
in cpo
compile time
interpretation of
of type
adequacy theorem
level languages
static reduction
lift n
name pcf
the interpretation
at run
semantics of
binding time
and dynamic
a term
logical relation
pcf the
directed partial
the compilation
non termination
the denotational
b r
the operational
run time
closed term
dynamic type
the semantics
static and
an operational
induction hypothesis
r d2
cpo is
denable functions
sub term
d lift
static adequacy
dynamic adequacy
pred m
x lift
of dynamic
type directed
a dynamic
the language
of pcf
type formation
of dyn
level language
case m
a static
purely dynamic
residual program
nat nat
x m
denotational semantics
type d
hypothesis on
two level
be compiled
not terminate
between static
terminate at
to interpret
cpo of
dynamic arrow
term sund
partial evaluator
dynamic ones
cpo x
pairs hf
lift 0
environment x
static components
hf gi
point wise
terms like
interpret dynamic
functor categories
type assignment
m 00
static undenedness
lift sund
lazy calculus
category cpo
dynamic evaluation
immediate otherwise
some junk
gi such
by induction
equational theory
semantics and
x x
c 7
types and
if m
dened by
d 0
evaluation a
a denotational
f 6
by lemma
of partial
up n
type unit
formation rules
substitution lemma
is point
of cpo
an adequacy
execution phases
the model
f b
compilation and
the rule
r d
is dened
account of
term can
by value
the type
give an
during compilation
typed term
static types
cartesian closed
unit unit
terms and
cases case
have seen
time analysis
by x
t 00
be x
base types
evaluation the
rule is
valid in
a categorical
d1 d2
dene a
if f
of types
m d
f be
the environment
indicates the
that m
in partial
are interpreted
handbook of
relate the
by denition
a closed
dened as
the interpretations
evaluation is
a semantic
types are
least element
is interpreted
of static
are valid
f r
relation is
of terms
dynamic counterpart
of undenedness
terms pred
static term
reduced dynamically
m pred
dapp dyn
usual interpretation
adequacy in
sd m
like call
standard pcf
m sd
not denable
dynamic numbers
component dened
2 level pcf
call by name
is in snf
of type nat
at compile time
a 2 level
2 level language
of 2 level
the interpretation of
dened by x
at run time
by name pcf
type directed partial
two level languages
give an operational
directed partial evaluation
the operational semantics
a closed term
of the language
an operational semantics
of partial evaluation
interpretation of dynamic
the type formation
induction hypothesis on
the denotational model
r d2 g
d lift n
not terminate at
x a p
and a denotational
the semantics of
of dynamic types
f b r
static and dynamic
operational semantics and
partial evaluation a
m is in
of type directed
binding time analysis
between static and
that a term
can be compiled
and dynamic evaluation
semantics of dynamic
the environment x
dyn f r
purely dynamic terms
compilation and execution
x m 0
d2 g c
gi such that
is immediate otherwise
terminate at compile
r d1 d2
d1 d2 g
the category cpo
b r d2
b r d
pairs hf gi
of dynamic terms
the static components
be c 7
type formation rules
a type assignment
f r d1
a denotational model
hf gi such
be the environment
dynamic type d
denable functions of
to interpret dynamic
compile time and
by induction hypothesis
call by value
for partial evaluation
term of type
closed term m
interpretation of terms
in partial evaluation
during the compilation
denition of dyn
m 0 if
we have seen
let f be
a term can
partial evaluation is
rule is not
semantics of a
dened as follows
have to show
a term m
each i 2
does not terminate
is not valid
term can be
and execution phases
that a static
obtained from pcf
by value or
m m sd
g c but
between the semantics
dynamic evaluation the
functor categories and
for the lambda
m pred m
down a by
if its denotation
for some dynamic
be statically reduced
and m d
the dynamic term
type unit unit
a semantic account
a dynamic arrow
some dynamic value
dynamic adequacy theorem
identity on x
semantic account of
interpret terms like
a partial evaluator
model of 2
must have dynamic
f 6 and
pred m pred
dynamic sub term
operational semantics the
from pcf by
base types are
level pcf the
reductions can be
valid consider the
theory and a
type nat in
the and rules
time information inside
each dynamic type
before the dynamic
a logical relation
a t 00
r d1 c
sd m 0
polymorphic binding time
static normal form
on m 0
are the dynamic
handbook of logic
n conversely if
dynamic value d
if taken in
dapp dyn f
dyn f b
given to relate
by x lift
in snf and
static components of
are pairs hf
statically reduced to
lemma t if
execute it at
dene a translation
to interpret terms
in snf the
logical relation r
by name the
snf and m
consider only some
f a t
like call by
is the lift
a component dened
on d 0
environment x i
of non termination
kinds of undenedness
b r d1
and the denotational
term m 00
dyn f 6
a dynamic sub
f be x
the cpo one
m let f
lemma 16 hence
the dynamic adequacy
m sd m
taken in isolation
bounds of chains
the cpo case
in static normal
type nat then
relation is essentially
semantics an equational
the exponential in
cpo is dened
level pcf and
f be c
by name if
a by lemma
d m 0

corpus/krapavin2000-test/1011177.txt
rel
monoidal
category
tensor
hypercoherences
poset
functor
coherence
products
morphisms
morphism
jxj
comonad
nite
spaces
coproducts
co
_
intuitionistic
logic
fne
comonoids
categorical
singleton
powerset
jy
negation
autonomous
closed
fa
denition
coherences
glueing
endofunctor
monoid
compact
candidate
diagrams
symmetric
proposition
biproducts
weakly
girard
exponentials
commutativity
ll
dened
forgetful
lattice
candidates
hx
ha
relations
duality
dual
coincide
preserves
connectives
games
commutative
diagram
pointwise
algebras
monad
satises
collapse
par
fm
faithful
degenerate
comonads
dialectica
lamarche
comonoid
hhx
classical
inequalities
product
fda
suprema
nitary
hom
modalities
underlying
inr
inl
categories
multiplicative
posets
join
isomorphic
constructive
universal
dierent
commute
equipped
restricts
dene
ole
interpretations
fragments
embedding
everything
ie
singletons
ultimately
dierently
fr
joins
diagonal
completeness
chu
encode
exponential
sight
orthogonality
id
ourselves
yi
units
preprint
identity
seven
sided
motivating
map
largest
maps
multiplication
jaghadeesan
carcinogenic
_g
quantales
hcm
commuting
jxjjy
l27848
hypercoherence
comonoidal
cogenerated
flavoured
ehrhard
_x
abramsky
wanted
fd
arrow
picks
universe
transformation
lemma
dening
valued
inequality
cient
jest
hyland
appeals
involution
dually
tidy
semilattices
plete
inma
spoiled
talked
cetera
adjunction
closure
rst
demand
object
facts
dealt
putting
su
genuinely
opponent
contra
ples
abound
rels
plenty
niteness
desired
specied
terminal
really
symbols
spirit
specic
weak
nd
theoretic
meets
circumstances
versus
obvious
spell
subcategory
linear logic
coherence spaces
p f
f set
symmetric monoidal
on rel
the tensor
a f
co products
monoidal closed
category of
compact closed
a morphism
f sets
f a
the category
products and
tensor product
f i
i f
and co
morphism of
structure on
and relations
of coherence
powerset functor
for tensor
function space
a category
underlying set
f b
nite powerset
of hypercoherences
p fne
linear exponential
natural transformation
a singleton
complete lattice
in rel
classical linear
linear function
of sets
a candidate
intuitionistic linear
tensor and
functor on
jxj jxj
is autonomous
largest candidate
exponential comonad
candidate for
b f
for linear
a poset
sets and
tensor of
closed as
and coproducts
jxj jy
unit for
is symmetric
ll in
following diagram
the ll
categorical structure
rel to
endofunctor on
autonomous structure
hypercoherences is
phase spaces
underlying poset
jxj to
poset valued
comonad on
valued sets
fm i
co product
poset 3
and hypercoherences
desired inequality
lattice then
jy j
in property
the structure
the nite
the underlying
models for
of linear
commutativity of
of intuitionistic
products the
a monoidal
rel and
monoidal category
underlying category
nite products
product on
following diagrams
our construction
p is
spaces and
if p
the unit
f f
our category
closed structure
forgetful functor
the pointwise
the poset
is compact
a p
all candidates
lemma 7
for classical
a model
satises the
a categorical
the categorical
full completeness
commutative monoid
tensor is
pointwise join
fa f
monoidal comonad
an endofunctor
have biproducts
rel preserves
morphisms we
i fm
a coherences
l _
strictly proof
structure map
constructing models
the desired
closed and
morphisms of
empty set
the linear
a a
the empty
for coherence
rel it
universal property
ha a
category p
from rel
relations rel
and par
our chosen
their units
resulting category
of rel
the collapse
view as
the dual
in p
of p
i i
set is
candidates for
via the
and faithful
nite subset
f satises
rel is
for models
categorical model
for co
the modalities
product of
preserves the
a tensor
logic such
the forgetful
denition of
join of
we will
of nite
given by
the commutativity
spaces is
a negation
completeness for
negation is
unless p
spaces as
category we
logic the
on p
on 3
category is
full and
denition for
related with
a complete
is equipped
spaces the
with itself
its structure
p f set
f a f
p f sets
a f a
the category of
symmetric monoidal closed
sets and relations
of coherence spaces
i f i
category of sets
linear function space
for linear logic
of sets and
f i f
of linear logic
products and co
and co products
is symmetric monoidal
of p f
a morphism of
f set is
the unit for
a f b
the tensor product
f b f
is a singleton
models for linear
as a category
the nite powerset
classical linear logic
a complete lattice
the linear function
is a morphism
tensor product of
intuitionistic linear logic
the underlying set
for classical linear
a linear exponential
the tensor of
models of linear
nite powerset functor
is compact closed
the largest candidate
coherence spaces and
linear exponential comonad
on the category
if p is
products and coproducts
a natural transformation
the ll in
the following diagram
structure on the
p is symmetric
compact closed and
model for classical
largest candidate for
the underlying poset
the desired inequality
ll in property
b f f
poset valued sets
for tensor and
endofunctor on rel
function space of
co products the
monoidal closed structure
tensor product on
spaces and hypercoherences
complete lattice then
a candidate for
symmetric monoidal category
jxj jy j
linear logic the
a symmetric monoidal
the following diagrams
commutativity of the
the underlying category
of intuitionistic linear
is a candidate
a model for
a a a
category p f
existence of nite
f f b
linear logic such
via the ll
p is autonomous
rel is compact
f set has
morphism of p
i fm i
co products in
in p f
powerset functor on
the categorical structure
pointwise join of
category of p
coherence spaces the
a p f
n a coherences
full completeness for
functor on rel
closed structure on
and relations rel
monoidal closed as
jxj jxj to
f satises the
rel preserves the
model for linear
category of coherence
coherence spaces is
f set will
an endofunctor on
then p f
the pointwise join
tensor and par
for coherence spaces
the empty set
f i i
in the category
p is a
a categorical model
join of all
i f a
for models of
unless p is
full and faithful
linear logic we
nite products and
q n a
model of intuitionistic
a f i
the resulting category
the structure on
of all candidates
is given by
recall that a
a tensor product
the commutativity of
the forgetful functor
view as a
underlying set of
satises the conditions
categorical model of
that the dual
f f a
set is a
candidates for the
is related with
i i i
of the structure
x is given
obtained via the
will in general
to the category
is equipped with
we will make
product of two
the value 1
function space in
has nite products
and to _
j jy via
from rel it
from jxj jxj
glueing and orthogonality
a constructive denition
the poset 4
relations we can
linear logic what
property lemma 7
a suitable structure
a set jxj
a degenerate model
the category p
unit for tensor
the outer diagram
function jxj jxj
1 exactly on
morphism of comonoids
constructing models of
linear logic consists
fact that rel
the units for
a singleton or
co product is
and orthogonality for
nite subset e
set rel preserves
a commutative monoid
e of r
the other connectives
linear logic namely
not compact closed
functor on the
has jxj jy
our chosen representation
spaces as well
a function jxj
joins and nite

corpus/krapavin2000-test/1011479.txt
loc
predomain
leino
st
abadi
denotational
specifications
calculus
thetast
m2m
val
imperative
fixpoint
object
logic
oe
phi
specification
bm
rec
flat
predomains
calculi
scott
hoare
predicate
functional
recursive
id
monotonic
denotationally
recl
tm
admissible
semantics
store
cit
mild
cardelli
existence
untyped
ob
pitts
predicates
induction
soundness
logics
recursion
counterexamples
thetarec
8o
bval
ocl
predom
closures
fields
theta
inv
formation
reasoning
oriented
resp
languages
transition
algol
predi
modelling
uniqueness
spec
record
interpretation
families
objects
garbage
cates
diverges
field
creation
java
ject
update
invariants
realizations
countable
2s
closed
typed
ambient
employing
invariant
ae
machinery
finds
precondition
op
fresh
indisputable
r65190
o2o
recm
schwinghammer
thetao
2st
dubious
endo
bifree
coalgebraic
gested
nuffield
evid
o2s
stval
reus
sug
00244
v2val
hv
8evid
freyd
definedness
knaster
o2i
thetaa
endomap
a2o
tarski
letx
variant
recursively
verifying
alter
assertions
grams
inheritance
accordance
domains
iii
coinduction
cristiano
exemplify
gously
mysterious
hearn
notationally
calcagno
lcf
oei
prospective
handy
bifunctor
parison
records
operational
sake
continuous
relational
var
awkward
embarking
uncountable
viously
derivability
inclined
nineties
presupposes
characterising
2a
nonempty
obvi
aliases
employ
lattice
labels
semantic
syntax
simplifies
distinguish
fixpoints
conceive
clone
reminds
smalltalk
wp
locations
extensions
validity
greatest
implication
programs
adaption
pcf
fication
fulfilling
specifica
clarified
overriding
ful
313
bernhard
plementation
object calculus
object specifications
abadi leino
imperative object
logic of
f st
e o
e oe
the store
scott closed
object calculi
the abadi
leino logic
the imperative
of object
a denotational
rec loc
st e
loc thetast
fixpoint induction
o m
e e
functional object
theta st
denotational semantics
of specification
is scott
transition specifications
unique s
st with
method update
flat predomain
p o
the object
oe 0
a logic
f e
flat part
m o
the functional
object oriented
o 0
2 l
specification s
i a
p e
a predomain
admissible predicate
recursive object
condition iii
theorem 4
it follows
partial continuous
functional case
of predomains
phi y
recursive type
oriented programs
l i
object logic
condition y
only refer
p id
existence theorem
finds its
the flat
o o
basic values
st for
oe 00
val theta
st val
object formation
phi satisfies
store i
domain equations
loc theta
unique with
object expression
non flat
op theta
order store
relational properties
val thetast
method closures
loc cit
a op
st m2m
any predicates
object specification
hoare calculus
s loc
interpretation within
recursive objects
specifications under
phi a
of objects
oe m
the specification
reasoning about
oriented languages
the predicate
of recursive
predicate s
inv a
provided s
environment ae
program logic
introduction rule
presented approach
with provided
mild assumptions
and imperative
induction principle
that f
a m
n w
an object
calculus for
of phi
existence of
v id
by fixpoint
o thus
2 phi
iii of
oe n
thus by
object creation
specifications is
abadi and
the admissible
the recursively
logic 2
its interpretation
calculus of
follows that
store and
recursive types
class based
w r
of specifications
logic but
fixpoint of
method m
the existence
by y
semantics for
a t
that phi
a monotonic
definition 3
a specification
m e
recursively defined
fields and
thetast and
2s o
verifying java
that bm
constrained design
store oe
natural counterexamples
recursively specified
alter data
domain equation
o 2a
field update
defined predomain
f val
needs recursion
8o 0
p ffi
calculus without
programs recursive
greatest fixpoint
loc ob
java realizations
quite in
theta val
algol like
imperative untyped
loc rec
l loc
a hoare
loc n
and families
ocl constrained
guarantee existence
3 imperative
abadi cardelli
bm x
loc val
result specifications
untyped object
programming logics
and leino
garbage and
thetast val
cates resp
l i a
f e e
e e o
abadi leino logic
the object calculus
the abadi leino
imperative object calculus
f st e
logic of object
of the store
a logic of
o m o
notion of specification
unique s 2
the imperative object
a unique s
s 2 l
flat part of
of object oriented
e o m
the flat part
functional object calculus
to the flat
for the imperative
object calculus of
of phi a
of the abadi
st e e
object oriented programs
e oe 0
denotational semantics for
only refer to
theorem 4 4
show that f
of theorem 4
a denotational semantics
oe 0 n
provided s is
and logic of
object expression a
is scott closed
that f st
of recursive objects
calculus of 1
store i e
with provided s
by fixpoint induction
inv a t
loc theta st
val theta st
is unique with
a op theta
relational properties of
the functional object
interpretation within the
o m e
logic of recursive
theta st m2m
functional and imperative
the store i
e v id
the predicate s
higher order store
of object calculi
2 phi y
the admissible predicate
by y that
oe n w
logic of predomains
within the recursively
phi a t
i a op
environment ae 2
that e oe
s is unique
m o 0
a flat predomain
i a l
m e o
condition iii of
that i e
theorem 4 2
object oriented languages
exists a unique
it follows that
e e oe
properties of domains
o p o
p o p
the condition y
the functional case
the presented approach
e f e
w r t
properties of objects
a l i
y 2 l
lemma 7 1
the store and
that a m
be the predicate
of the functional
of the object
definition 3 3
in the object
refer to the
part of the
not distinguish between
semantics for the
garbage and program
st theta val
quite in accordance
f st for
e oe n
for any predicates
loc n is
its introduction rule
3 as e
untyped object calculus
call method update
on o o
fixpoint induction principle
phi y x
0 2s o
l loc st
rec loc rec
also suggests extensions
specifications and their
a fresh location
partial continuous functions
4 definition 3
3 imperative object
and program logic
is scott open
of specifications under
its interpretation within
induction hypothesis p
object calculus without
e o 2a
fixpoint of phi
object based a
classes in algol
the existence theorem
y of theorem
recursively defined predomain
st loc thetast
2s o m
method call method
through the store
the underlying store
theta i a
phi satisfies the
to guarantee existence
of ocl constrained
interpretation of object
transition specifications that
the object formation
loc rec f
of loc cit
and families of
p ffi e
that phi satisfies
w oe 0
recursive object types
that alter data
2 functional object
simple imperative languages
predicates and families
thetast val thetast
for verifying java
oriented programs recursive
a locally continuous
logics for object
for object calculi
in the store
functional object specifications
o thus it
theta val theta
specification as the
needs recursion in
recursion through the
f by y
st with provided
the complete lattice
alter data structures
imperative object specifications
n w e
object calculus which
2 p o
finds its interpretation
existence of specifications
a a predomain
one needs recursion
fresh location not
any predicates and
constrained design models
hoare calculus for
condition y of
verifying java realizations
n w oe

corpus/krapavin2000-test/1011512.txt
coalescing
spill
spilled
coalesced
allocator
coloring
chaitin
chunks
optimistic
aggressive
register
colored
live
coalesce
splitting
briggs
interference
iterated
conservative
colorable
allocation
spilling
oo
colorability
coalescible
copy
spills
copies
stack
xy
impact
colors
heuristic
num
color
registers
instructions
ab
renumber
split
sed
conservativeness
lescing
coa
vliw
node
coalesces
violating
instruction
xyz
splits
scheduling
nodes
interfering
compress
opportunities
pipelining
optimistically
rematerialization
neighbors
simplification
espresso
promotion
edges
phase
degree
aggressively
coalesc
allocators
eqntott
chance
interfere
simplified
removes
heuristics
candidate
freeze
def
undo
oeo
nonnumerical
oof
conservatively
fully
conser
sparc
eliminates
marking
interferes
bors
unroll
pushed
ssa
outweigh
assigning
affecting
neigh
scheduled
target
chunk
eliminated
successfully
pushes
ranges
nest
simplify
potential
benchmark
ingredient
ratio
parallelizing
preferred
negative
exploits
bc
ordering
select
renaming
assembly
1478
wimmer
911
bouchez
7530
pipelin
takuya
16818
alus
mssenbck
stack223h
pact
103032
aggres
inagaki
9228
ruin
d212spill
orability
2311
103457
nakaike
12731
coalescingg
unioned
6524
rastello
71366
6614
alescing
9659
cludes
rematerial
744637
tatsushi
4134
darte
vative
2987
hanspeter
rematerializable
reckless
li
safe
tm
benchmarks
biased
selective
removed
style
opportunity
ignores
elimi
uncolored
3156
hideaki
vatively
appel
ferrante
myampersandamp
pessimistically
komatsu
629
speculatively
fabrice
premature
overwrites
florent
1399
toshio
nakatani
1554
cisc
compilers
violation
composed
top
concern
neighbor
thing
round
aggressive coalescing
live range
conservative coalescing
coalesced node
chaitin s
range splitting
register allocation
the spill
optimistic coalescing
copy related
spill cost
positive impact
iterated coalescing
of coalescing
graph coloring
related nodes
a coalesced
actually spilled
optimistic allocator
o oo
the allocator
of optimistic
the stack
actual spill
interference edges
coloring register
oo o
num of
interference graph
register allocator
significant degree
be colored
the coalesced
potential spill
spill instructions
colorability of
the positive
negative impact
the graph
coalescing on
s allocator
violating chunks
phase ordering
the colorability
the coloring
coalescing and
coalescing is
spilled to
coalescing in
briggs optimistic
degree neighbors
of spill
coalescing which
be spilled
being coalesced
impact of
the interference
to color
low degree
splitting in
are spilled
coalescing the
coalescing or
optimistic register
degree node
chunks and
or iterated
select phase
candidate chunks
non copy
coalescing heuristics
of conservative
nodes being
the negative
splits are
to coalesce
any spill
of live
of nodes
on top
live ranges
software pipelining
of chunks
top of
the conservativeness
of briggs
node xy
coalescing by
spilled and
by chaitin
in aggressive
target nodes
global register
by live
coalescing that
coa lescing
coalescing heuristic
split back
those chunks
register coalescing
that aggressive
of spilled
the chaitin
spilled nodes
by optimistic
node is
nodes in
the optimistic
optimistic allocation
selection phase
the heuristic
are colored
the simplification
every node
be simplified
to memory
the select
coloring of
of copies
a color
via graph
chunks in
is split
two nodes
any more
graph is
of significant
instruction scheduling
ab is
nodes that
and target
simplification phase
case allocator
s register
chunks by
coalescing see
coalesced the
coalesced chunks
two colorable
chaitin style
by aggressive
coalesce any
that coalescing
coalescing has
after coalescing
colorable any
concern later
coalescing may
been coalesced
build phase
those copies
copies eliminated
spill concern
allocator in
the coalescing
optimistic coloring
spilled chunks
any coalesce
coalescing a
spilled if
coalesces any
potentially spilled
spilled colored
partially spilled
fully spilled
spill results
spilling the
colored nodes
conservativeness heuristic
simplify chaitin
machine registers
the register
node that
ordering of
of aggressive
of successfully
instructions generated
splitting it
pushed on
in optimistic
degree nodes
of copy
non interfering
allocation it
the phase
a copy
a node
node for
each heuristic
two colors
the copy
opportunities for
source and
heuristic called
and optimistic
too early
code with
to live
color the
copies by
live range splitting
the positive impact
copy related nodes
the spill cost
a coalesced node
positive impact of
impact of coalescing
o oo o
graph coloring register
colorability of the
the negative impact
oo o oo
can be colored
coalescing on top
the coalesced node
coloring register allocation
chaitin s allocator
phase ordering of
the interference graph
of live range
significant degree neighbors
spilled to memory
the colorability of
of conservative coalescing
briggs optimistic allocator
nodes being coalesced
coalescing or iterated
the select phase
non copy related
or iterated coalescing
of significant degree
of spill instructions
conservative coalescing or
the potential spill
spill cost of
the coloring of
on top of
for the potential
of nodes in
the chaitin s
via graph coloring
to be spilled
graph is empty
by live range
range splitting in
that aggressive coalescing
the phase ordering
of the coloring
top of optimistic
and target nodes
is split back
global register allocation
degree neighbors of
by chaitin s
source and target
the number of
negative impact of
on the stack
of the interference
of the graph
of the stack
split back into
exploits the positive
copies eliminated by
in those chunks
ordering of optimistic
interference edges of
the conservativeness heuristic
splits are spilled
splitting it is
are actually spilled
spill concern later
the selection phase
by optimistic coalescing
in aggressive coalescing
of briggs optimistic
of optimistic allocator
coalesced node xy
target nodes being
of optimistic coalescing
chaitin s register
simplify chaitin style
splitting in a
the spill concern
optimistic allocator in
low degree node
nodes in those
possible to color
base case allocator
s register allocator
num of nodes
range splitting it
colorable any more
coalescing in table
of aggressive coalescing
a potential spill
num of chunks
spill cost is
for global register
of interference edges
spill instructions generated
conservative coalescing and
coalesced node is
aggressive coalescing on
chunks and the
actually spilled to
shows the number
an average of
x and y
every node is
the source and
the graph is
to color the
in the stack
of the optimistic
coloring of the
instructions generated by
pushed on the
a graph coloring
the register allocation
the approach of
number of nodes
node will have
the graph coloring
register allocation and
in the select
as in figure
from the graph
in figure 5
results indicate that
and the number
y and z
e d a
a node that
problem of assigning
node that has
has never been
a node x
et al have
c d c
to the positive
top of the
less than k
the degree of
connected by an
nodes can be
chunks nodes chunks
nodes conservative coalescing
and pushed on
eliminates more copies
coloring one of
pipelining an effective
is empty significant
optimistic allocation it
improving the overall
improvements to graph
coalescing can be
an interference edge
compress sed average
colored with different
some splits are
to memory this
ab c d
is any coalesce
two split nodes
be spilled to
previous coalescing heuristics
f o oo
effective scheduling technique
aggressive coalescing which
on the coloring
of the conservativeness
up coalescing too
coalesced node for
outweigh the negative
spilling the allocator
node is significant
a register allocator
first build phase
are spilled while
and iterated coalescing
spill graph is
the first build
optimistic coalescing in
of machine registers
oeo oo f
select actual spill
of spilled nodes
of iterated coalescing
the four coalescing
assigned a color
nodes in violating
be actually spilled
interference graph when
coalesced due to
fully exploits the
reduced by one
colors are available
coalesced node ab
that of spill

corpus/krapavin2000-test/1011810.txt
stably
population
agents
agent
live
computable
timer
leader
interactions
batons
counter
sensors
counters
predicates
baton
protocol
flock
interaction
sensor
turing
conjugating
semilinear
bit
encounters
protocols
birds
parity
predicate
q5
stabilizes
elevated
fn
ra
configuration
randomized
multiset
zeroing
configurations
petri
q0
nondeterministic
automata
stable
initiator
responder
convention
transition
quotient
transitions
reachable
catalytic
tokens
encounter
fairness
wireless
stabilize
gn
temperatures
marks
winner
modulo
encoding
urn
majority
simulated
populations
su
alert
complementation
outputs
sensing
pn
inputs
eventually
rl
nonzero
expressible
signal
computes
passively
interact
probability
members
sampling
bits
output
eisenstat
u6
bigraphical
yc
erent
intriguing
decrement
assignments
conventions
mobile
communicate
initialization
tape
chemical
assignment
nets
loser
interac
cx
plete
halts
aggregation
nl
integers
infinitely
pairing
waits
simulates
machines
temperature
decrements
complementing
boolean
simulate
weakly
di
bird
alphabets
swaps
mobility
station
sketch
integer
simulating
characterization
copies
kp
capacity
symbols
interacting
increment
power
subterm
u1
weakest
arithmetic
ciently
count
n1
flips
symbol
net
questions
log
computa
t2
maps
blank
decidability
atomic
communicating
mod
valued
hn
pairwise
cient
t1
stopped
capable
families
machine
enabled
lightweight
swapping
severely
expressions
fee
coordinates
computations
bile
crippling
0305258
teractions
pritchard
0098078
parikh
0081823
diamadi
tersection
usely
volzer
ginsburg
0795
respon
boudol
conven
tually
subpopulations
catalyst
vices
egecioglu
zafiropulo
subprotocol
9820888
live bit
stably computable
population protocol
a population
population protocols
stably computes
the population
bit equal
the leader
interaction graph
with live
of interactions
computable predicates
data bit
stable computation
counter machine
a stably
agent with
the timer
global start
the flock
start signal
component i
turing machine
the output
counter i
its live
the sensors
conjugating automata
timer k
integer quotient
by population
the interaction
protocol a
the input
the agents
least 5
every agent
finite state
input assignment
other agent
sets its
the counter
a timer
configuration c
population configurations
semilinear sets
of conjugating
ra x
interactions until
are stably
of population
source counter
output assignment
predicate output
transition function
the states
a counter
an agent
high probability
of agents
two agents
of birds
an interaction
initialization phase
the live
input and
the multiset
agents with
with high
and gn
is stably
leader encounters
the semilinear
output convention
that stably
predicates computable
randomized turing
the stably
encoding convention
agent u
population configuration
stabilizes to
expected total
encounters the
computable by
log n
1 s
with probability
expected number
the correct
to 0
agents in
computational power
of stable
whether at
flock of
state agents
reachable from
quotient of
population of
and output
of error
n k
a nonzero
counter to
equal to
fn and
counters of
single valued
expression language
the state
bit to
bit is
the predicate
0 0
modulo a
abstract machine
fairness condition
agents we
to 1
machine with
this model
output of
input x
sensor networks
all agents
to five
of petri
the parity
any population
based input
stably computed
output map
let fn
baton and
the batons
population members
timer in
the chemical
1 counters
in populations
sensor values
c reachable
input map
5 ones
remainder modulo
agents assigned
p rl
chemical abstract
random pairing
responder in
alert state
timer if
unique leader
capacity o
assignment x
have elevated
elevated temperatures
atomic expressions
space turing
randomized population
input assignments
stably compute
output assignments
population pn
birds in
nonzero constant
o 1
to interact
sum of
count to
interactions in
a row
probability 1
the turing
the expected
power of
one agent
bit and
correct answer
infinitely often
it encounters
a finite
the inputs
predicates are
agent to
sensors are
output encoding
2 sum
on interactions
of characterizing
or predicate
be stably
stabilize to
pairwise interactions
a transitions
under complementation
i x
of boolean
a population protocol
live bit equal
bit equal to
with live bit
number of interactions
stably computable predicates
population protocol a
the interaction graph
a stably computes
agent with live
its live bit
global start signal
of the population
an agent with
the live bit
by population protocols
at least 5
probability of error
number of 1
of 1 s
equal to 1
with high probability
the transition function
stably computes the
the timer k
integer quotient of
the source counter
the global start
of conjugating automata
of stable computation
interaction graph is
the integer quotient
the data bit
ra x y
stably computable by
are stably computable
in the input
0 0 0
in a population
graph is complete
expected total number
in a row
times in a
the initialization phase
k times in
by a population
the semilinear sets
sets its live
a counter machine
predicate output convention
computable predicates are
live bit to
the leader encounters
randomized turing machine
fn and gn
counter machine with
model of conjugating
leader encounters the
timer k times
the stably computable
computable by population
agents with live
of interactions until
the predicate output
bit to 0
is stably computable
count to five
encounters the timer
expected number of
input and output
the output of
in the interaction
with o 1
whether at least
finite state agents
every other agent
flock of birds
in this model
s in the
with probability 1
the turing machine
the expected number
a population of
n k 1
o 1 counters
protocol a stably
function or predicate
birds in the
the chemical abstract
of population configurations
families of boolean
of capacity o
m and 3
source counter to
chemical abstract machine
population protocol with
stabilizes to output
be stably computed
an input assignment
define a model
the counter machine
interaction that involves
randomized population protocol
in the flock
c reachable from
the output assignment
quotient of m
agent based input
stably computes a
mod 2 sum
1 counters of
interactions until the
one other agent
every agent to
the input map
counters of capacity
capacity o n
condition on interactions
in populations of
have elevated temperatures
the mod 2
a configuration c
a nonzero constant
in p rl
computes a predicate
the output map
the flock of
as a timer
machine with o
input assignment x
an interaction that
fairness condition on
predicates computable with
the sum of
computational power of
of an integer
the correct answer
the states of
is 1 if
of boolean functions
sum of the
turing machine can
closed under complementation
power of stable
2 sum of
is single valued
a timer and
reachable from c
a fairness condition
that the leader
can be stably
0 s in
the agent based
and the population
1 s in
to 0 and
agent with a
this model are
the sensors are
of the sensors
whether the number
input output relation
an infinite computation
the correct output
the number of
of the states
the output is
the question of
power of this
to 1 is
to a mapping
the expected total
bit and the
of a population
the input is
computed by a
can be simulated
from x to
say that c
all the agents
is closed under
the product of
1 s is
we say that
an open problem
the computational power
transitions of the
and a constant
characterization of the
1 0 1
predicates such as
of finite state
the input and
in which case
x y holds
a constant and
the power of
of the inputs
set of predicates
which case we

corpus/krapavin2000-test/1011820.txt
gke
ideal
sys
adversary
protocol
servers
server
tc
session
sk
consensus
id
secure
hybrid
cons
crash
crashed
security
adv
break
resilient
cor
secrecy
opt
asynchronous
gcs
corruption
agreement
messages
ins
cor_in
coin
exchange
protocols
resilience
trusted
rounds
fs
configuration
attacks
message
connections
keys
secret
ppt
net
crashes
authenticated
outputs
indistinguishable
um
tag
2tc
cor_out
round
pseudorandom
tolerates
tape
versary
black
host
service
1g
group
authentic
configured
cachin
pfitzmann
idjcs
halts
itm
f0
box
encryption
contribution
th
steiner
receives
waidner
simulator
public
forward
byzantine
complexities
delivered
enc
canetti
party
failures
6n
composable
key
joint
string
master
diffie
stage
attack
breaks
delivers
tocol
katz
hellman
tapes
interface
composition
tcn
bresson
gcss
net_out
net_in
fvar
gk2n
bit
comprises
receiving
nish
tolerate
adversaries
ij
rekeying
fstate
dealer
contributory
sends
connects
detector
reactive
finish
connection
shares
cryptographic
var
ensembles
interacts
liveness
send
sent
received
universally
mes
scheduler
internal
learn
feeds
happens
sub
sim
adds
argue
activated
outputting
k0
terminate
chooses
yung
y2
distinguishable
share
configurations
coins
rabin
tolerant
provably
simulated
proposes
live
amir
slowest
computes
communication
un
participate
suffices
network
idealized
member
modular
terminates
encrypted
anymore
oracles
purely
computationally
sages
members
tolerating
proceeds
adaptively
constructive
repeatedly
detects
investigate
authentication
schedule
interact
weak
init
ad
broken
sys real
system sys
gke protocol
real n
sys ideal
session key
ideal system
a ideal
a server
consensus protocol
the session
the adversary
group key
server i
every server
key exchange
a real
the servers
as secure
a gke
a hybrid
secure as
a tc
session id
for gke
sys hybrid
of sys
key agreement
out i
real system
adversary a
an ideal
th gke
the ideal
key sk
ideal f
corruption model
tc servers
break ins
non crashed
cons n
the protocol
run of
as sys
hybrid cons
trusted host
server m
hybrid system
a run
1g k
h and
a session
user h
for consensus
th cons
cor in
crashed servers
gke n
tag id
servers crash
tc resilient
a consensus
forward secrecy
for id
break into
protocol in
sub system
ideal gke
with tag
service f
ideal k
fs gke
to adv
cor out
adv th
server j
a protocol
exchange protocol
ideal service
from adv
optimal resilience
ideal g
break in
resilient consensus
hybrid run
host th
adv net
our construction
2 messages
y i
black box
the trusted
internal state
security of
ideal configuration
joint view
h a
all servers
configured with
in i
real configuration
most tc
gke and
that sys
contribution values
at out
th fs
strong corruption
tc t
among non
on cor
id i
gke protocols
protocol 0
v ideal
n tc
connection cor
resilient gke
b resilient
all messages
an adversary
the security
t b
the group
upon receiving
a message
the consensus
the hybrid
breaks into
with failures
forward secure
conference key
with sub
id v
the interface
ideal and
a configuration
m i
bit string
rounds and
f0 1g
session with
messages among
session keys
f n
protocol a
of h
with h
contribution y
sub protocol
protocol coin
tolerates tc
adversary delivers
master scheduler
n 2tc
network net
un t
ppt itm
through connections
gke with
resilient group
real the
var k
id provided
real in
weak corruption
m receives
round complexity
contribution value
ideal run
id at
pseudorandom function
purely asynchronous
in out
servers in
the framework
our protocol
we model
is as
ad versary
of break
id then
single session
asynchronous reactive
authenticated group
hybrid the
composition theorem
delivers all
in m
value y
protocol and
servers and
first stage
the real
group communication
protocol is
protocol for
this happens
communication rounds
over f0
sys real n
the session key
system sys real
group key exchange
system sys ideal
real system sys
the ideal system
as secure as
is as secure
a server i
of sys real
ideal system sys
a gke protocol
n is as
and a hybrid
real n is
h and a
a run of
in a run
sys hybrid cons
view of h
secure as sys
sys ideal f
a consensus protocol
adversary a ideal
cor in i
non crashed servers
as sys ideal
ideal f n
f0 1g k
hybrid system sys
sys ideal gke
adversary a real
system sys hybrid
tc servers crash
h a real
a tc resilient
into a server
the trusted host
with tag id
session key sk
the real system
and a real
key exchange protocol
a server m
sys ideal g
trusted host th
user h and
that every server
hybrid cons n
cor out i
corruption model where
sub system sys
an ideal system
run of the
a real system
to the adversary
that the adversary
is a tc
th fs gke
a hybrid run
resilient consensus protocol
tc t b
among non crashed
session with tag
strong corruption model
tc resilient consensus
t b resilient
at most tc
real n with
the hybrid system
gke protocol in
a tc t
all messages among
most tc servers
the strong corruption
resilient gke protocol
configured with h
at out i
joint view of
of h and
if this happens
the joint view
the security of
a session with
that a server
n 2 messages
an adversary a
connection cor in
the adversary delivers
run of sys
weak corruption model
the consensus protocol
number of break
delivers all messages
in a hybrid
of break ins
break into a
servers in m
b resilient gke
th gke n
contribution y i
v ideal k
n h a
real n where
a session id
crash the following
the weak corruption
the ad versary
where the servers
ideal system for
ideal g n
messages among non
a real the
resilient group key
id provided that
solution for gke
gke protocol with
of a gke
to adv th
to every server
un t c
a protocol a
computes the session
servers crash the
adversary delivers all
the master scheduler
in an ideal
the first stage
by the assumption
of a configuration
with h and
the key sk
out i and
asynchronous reactive systems
a single session
internal state we
ideal and a
how to build
h in a
internal state of
of our construction
n consisting of
over f0 1g
of the real
of the session
in the ideal
assumption that is
not in m
where the adversary
the second stage
of the group
the view of
of an ideal
real where the
tc resilient group
in out in
with sub system
holds if all
an authentic network
the ideal service
from adv th
connections to adv
every server that
real n we
sys hybrid g
where at most
a real configuration
we assign round
adversary breaks into
an ideal run
if sys real
secure as an
a hybrid in
the fully asynchronous
for gke with
if all non
connections are used
h a ideal
protocol a tc
for every run
then they all
for group key
id then they
system for consensus
adv th and
starts a session
start a session
ideal cons n
on a sub
gke with failures
contribution value y
the connection cor
and waidner 23
black box simulation
provide forward secrecy
the sub system
cachin et al
i starts a
and if for

corpus/krapavin2000-test/1011932.txt
shiftable
twistable
elds
eld
twist
advection
completion
planck
fokker
gaussian
fourier
diusion
sink
coecient
steerable
shiftability
receptive
cortex
shift
cddg
euclidean
invariance
kanizsa
visual
contour
directional
interpolation
stochastic
gabor
coecients
illusory
wavelet
dierencing
stimulus
grid
invariant
orientation
williams
derivative
decay
simoncelli
gaussians
twistability
neural
frequencies
continuum
basis
biologically
v1
spatial
jacobs
sinks
orientations
discrete
clockwise
triangle
nite
ehrenstein
circle
rotations
mass
dened
source
rotated
coupled
proposition
heydt
thornber
steerability
magnied
transformation
image
rotation
computations
contours
clipped
centered
dirac
anisotropic
evolves
separable
translations
derivatives
particles
ner
freeman
adelson
period
wavelets
directions
neurons
vision
frequency
brownian
translation
series
eigenvector
mm
v2
localized
plane
shapes
cell
equation
mumford
joining
periodic
convolution
primary
continuous
pictures
helix
cortically
isotropy
hypercolumns
implausible
heitger
grating
cells
bar
harmonic
xed
resolution
bases
plausible
periodicity
sources
angle
shifts
straight
symmetries
fragments
integrating
gabors
helical
biological
formation
positions
scale
eectively
angles
modeled
recurrent
bandpass
contradictions
plausibility
twists
particle
salient
2e
formula
artifacts
von
twisted
sampling
rst
experiment
self
density
transform
preference
der
spikes
cortical
reconcile
176
accurately
contradictory
lter
symmetry
direction
boxes
2d
sparse
equating
appendix
scene
neuron
brain
integral
human
populations
occluded
computa
dierent
shifted
multiscale
rotates
multiplied
120
perfectly
transformations
2p
evolving
isotropic
product
eect
row
probability
bars
shiftable twistable
completion elds
completion eld
shift twist
fourier basis
stochastic completion
a shiftable
fokker planck
gaussian fourier
twistable basis
the fokker
planck equation
basis functions
initial conditions
the advection
the gaussian
euclidean invariance
euclidean invariant
twist invariant
and sink
elds in
complex directional
sink elds
receptive elds
coecient vector
directional derivative
visual cortex
r 2
source eld
the diusion
the completion
interpolation functions
the basis
fourier series
advection process
shiftable steerable
advection transformation
kanizsa triangle
k x
invariance of
source and
cddg fourier
in v1
basis k
of 31
k m
the continuum
eld in
the source
elds due
primary visual
the interpolation
p d
new algorithm
d f
eld coecient
and jacobs
the shiftability
simple cell
is shiftable
nite dierencing
transformation a
derivative of
the complex
basis the
in primary
williams and
the initial
the stochastic
k t
s 1
g k
2 s
functions k
coecient vectors
a shift
of gaussian
of period
cell receptive
visual eld
stimulus in
gaussian cddg
essentially non
is shift
twistable functions
dierencing scheme
sink eld
diusion parameter
series frequencies
on r
c k
elds are
p x
a gaussian
x 0
equation 2
the grid
r 0
contour completion
gaussians in
period x
simple cells
neural network
computations in
source elds
coupled basis
of contour
initial stimulus
and direction
elds were
steerable basis
the cddg
the shiftable
shiftability and
receptive eld
illusory contour
twistable bases
the kanizsa
real part
and directions
coecients of
function x
zero fourier
the decay
discrete computation
basis function
frequencies of
functions b
the shift
the euclidean
centered at
of functions
localized in
periodic function
the receptive
a euclidean
the visual
frequency content
gaussian initial
jacobs 30
pictures of
evolves according
spatial variables
basic shift
twist of
clockwise by
decay constant
discrete computations
simoncelli et
of illusory
rotated clockwise
of shiftable
clipped above
contour formation
invariant manner
above at
initial sources
ner scale
biologically plausible
the input
functions on
a wavelet
30 31
the product
and translation
wavelet basis
basis as
eld is
the coecient
left column
of positions
functions are
g x
t x
b k
the continuous
invariance is
rotation and
position and
gaussian in
and sinks
of essentially
invariant computation
line completion
initial p
the spatial
the discrete
computed using
x is
equation in
vector c
basis of
14 0
and translations
of euclidean
vectors p
plane r
m x
proposition 2
equation 5
gaussian fourier basis
shiftable twistable basis
the fokker planck
the gaussian fourier
fokker planck equation
2 s 1
r 2 s
shift twist invariant
a shiftable twistable
source and sink
stochastic completion eld
p d f
and sink elds
the initial conditions
completion elds in
the completion eld
complex directional derivative
on r 2
directional derivative of
the stochastic completion
elds in the
the completion elds
the complex directional
in the basis
the basis functions
c k t
stochastic completion elds
cddg fourier basis
euclidean invariance of
derivative of gaussian
the interpolation functions
in the gaussian
the p d
the euclidean invariance
the advection process
advection transformation a
the source eld
primary visual cortex
elds due to
of a shiftable
in primary visual
a shift twist
in the continuum
williams and jacobs
completion elds due
planck equation in
of the advection
solving the fokker
the new algorithm
the source and
a shiftable steerable
essentially non zero
shiftable twistable functions
stimulus in figure
is shift twist
the shift twist
fourier series frequencies
completion eld in
the advection transformation
in a shiftable
algorithm of 31
nite dierencing scheme
simple cell receptive
a euclidean invariant
of the source
basis functions are
of the basis
p x t
of the completion
k m x
g k x
and translation of
of simple cells
the cddg fourier
shiftable twistable bases
p 0 k
the visual eld
the basis k
coecient vector c
the kanizsa triangle
functions k m
interpolation functions b
functions b k
the coecient vector
of the fokker
of gaussian cddg
of the gaussian
rotation and translation
in r 2
of the visual
of a gaussian
non zero fourier
r 2 and
using the new
computed using the
the left column
functions on r
the product of
translation of the
of functions on
position and direction
invariance of our
basis of functions
straight line completion
completion elds are
spatial variables x
of essentially non
zero fourier series
eld coecient vector
evolves according to
the diusion parameter
shift twist of
form a shiftable
simoncelli et al
sources and sinks
represent the initial
equation in a
of the shift
equation 5 9
of euclidean invariance
of period x
initial p d
the initial sources
coecient vectors p
of shiftable twistable
shiftable steerable basis
space r 2
equation 2 18
sink elds in
gaussians in x
method of 31
and jacobs 30
of illusory contour
frequency content of
cell receptive elds
is shiftable twistable
fourier basis the
illusory contour formation
the frequency content
clipped above at
notion of a
invariance of the
of basis functions
on the grid
representing the input
plane r 2
a periodic function
basis functions k
the real part
the initial p
eld in the
centered at x
fourier basis function
of the stochastic
is given by
integral of the
number of basis
rotations and translations
new algorithm the
at x 0
s 1 of
r 0 x
the plane r
in equation 2
the computation in
basis functions in
obtained by integrating
the integral of
is the product
computation in the
the algorithm of
probability distribution of
diusion decay transformation
have average value
the basic shift
elds in a
of contour completion
notion of shiftability
periodic function of
steerable basis of
elds are shown
the receptive elds
initial conditions have
and direction constraints
the shiftability of
thornber and williams
positions and directions
and sink eld
d is shift
inside the boxes
computations in primary
completion elds computed
condition centered at
were clipped above
a simple cell
twist invariant manner
the regions inside
t k x
in the shiftable
fourier basis g

corpus/krapavin2000-test/1012676.txt
metering
secret
clients
realizing
sharing
corrupt
audit
schemes
server
servers
agency
qualified
lsss
frame
client
coalition
visits
gamma
visited
frames
ker
parties
secrets
ideal
visiting
access
web
pinkas
ads
optimality
ae
secure
advertising
sigma
dealer
stinson
jc
participant
shares
initialization
auditing
visit
pricing
naor
mappings
rate
lssss
nishizeki
coupons
auditable
brickell
explication
monotone
money
participants
surjective
gf
absolutely
sites
advertisers
x2x
ito
lightweight
proofs
saito
jackson
capital
dv
substructures
simmons
bounds
lncs
duals
accounting
letter
shamir
subsets
receives
security
reconstruct
algebraic
indices
threshold
scheme
pi
assisted
jf
distributes
received
cardinality
dim
log
62
attained
nuovi
lighweight
misure
nuove
compartmented
karchmer
ecnica
leichter
7287
aplicada
donate
polit
sul
576590
sicuro
attaining
1895
rrg008bf3
departament
pubblicit
blakley
ormonotone
tigh
afterwards
random
vol
distributing
relies
interaction
benaloh
revenues
1403
inflating
masucci
sss
reciprocally
fpr
atica
decomposition
pp
field
universitat
franklin
pooling
newspaper
matem
catalunya
enables
prime
martin
phase
besides
malkhi
wigderson
online
reconstruction
count
advised
equiprobable
jcj
sends
pay
realized
advertisements
mx
isps
geometric
share
verifiable
authorized
ffl
exposure
hospitality
constituted
oe
map
relationship
enable
fag
supremum
consult
honest
boldface
scenario
dual
restate
realizes
charged
showed
companies
kernel
jp
barcelona
collected
cn
shannon
satisfies
communication
passed
helping
family
concepts
author
spain
multilevel
spaces
secret sharing
access structure
metering schemes
sharing schemes
metering scheme
scheme realizing
sharing scheme
linear secret
structure gamma
a metering
time frame
audit agency
information rate
frame t
the audit
realizing the
any access
of clients
realizing any
time frames
a secret
the information
the secret
corrupt servers
variable associated
clients in
server s
the access
information distributed
access structures
schemes realizing
any server
realizing an
a qualified
corrupt server
of corrupt
an access
random variable
same access
s j
client c
the metering
corrupt clients
of metering
qualified set
optimal information
initialization phase
associated to
visited by
servers in
of secret
been visited
and secret
of definition
the scheme
the random
62 gamma
clients which
between metering
of secrets
algebraic approach
clients and
any linear
bounds on
schemes and
holds that
linear map
log jc
communication complexity
the servers
the optimality
optimality of
the clients
linear algebraic
schemes in
servers and
a server
in time
the coalition
any holds
design metering
qualified subset
relies upon
a lsss
s metering
2 gamma
distributed to
scheme is
to clients
its proof
schemes with
given access
server during
clients c
realizing it
coalition of
scheme satisfies
jc t
of parties
definition 2
formally for
and servers
schemes for
denote by
each client
linear mappings
new bounds
a corrupt
when visiting
c i
a linear
the linear
for any
to construct
web sites
finite field
linear mapping
p t
the initialization
ideal linear
structure namely
0 ker
agency to
the lsss
agency a
and pinkas
schemes these
clients x
frames t
an audit
geometric secret
phase ffl
ae c
optimal metering
absolutely no
threshold metering
schemes obtained
secrets p
shares in
with pricing
for secret
to metering
a coalition
proofs for
schemes were
t j
distributed by
rate of
the web
scheme with
gamma we
the server
construct a
we denote
information that
gf q
satisfies property
the corrupt
naor and
a visit
scheme according
rate ae
proof p
general access
gamma with
the shares
properties provide
during a
property 2
that log
that 0
schemes a
us suppose
ae gamma
this access
gamma from
log ae
information known
gamma it
pi t
vector space
from any
a method
structure on
any we
gamma can
schemes this
information received
server receives
any client
is log
no information
to measure
lower bounds
from property
method relies
compute the
properties about
new lower
with set
secret sharing schemes
secret sharing scheme
access structure gamma
linear secret sharing
a metering scheme
metering scheme realizing
the access structure
time frame t
any access structure
the audit agency
scheme realizing the
server s j
in time frame
a secret sharing
sharing scheme realizing
variable associated to
random variable associated
realizing the access
an access structure
the information distributed
construct a metering
information rate of
realizing any access
the information rate
associated to the
been visited by
scheme realizing an
of secret sharing
client c i
realizing an access
same access structure
has been visited
of definition 2
the random variable
the same access
set of clients
on the information
bounds on the
any linear secret
metering schemes realizing
information distributed to
scheme realizing any
schemes and secret
of metering schemes
from any linear
optimal information rate
and secret sharing
metering schemes and
optimality of the
definition 2 1
linear algebraic approach
relationship between metering
a linear algebraic
qualified set of
of corrupt servers
during the initialization
access structure is
complexity of metering
schemes realizing any
between metering schemes
algebraic approach to
sharing scheme with
by the audit
formally for any
realizing the same
given access structure
to the information
the optimality of
the initialization phase
method to construct
visited by a
that the scheme
the communication complexity
of the secret
on the communication
to clients and
a method to
to design metering
of clients which
access structure we
metering schemes in
the given access
any holds that
a linear secret
of time frames
measure the interaction
scheme realizing it
in time frames
n m c
access structure on
s metering scheme
in a metering
j the random
design metering schemes
clients in x
distributed to clients
sharing scheme is
a qualified subset
access structure the
the linear map
of the metering
metering schemes for
the linear secret
set of secrets
information distributed by
for any holds
relies upon the
c s metering
m c s
the scheme satisfies
the secret sharing
log jc t
j in time
upon the optimality
any time frame
clients and servers
we denote by
s j in
to construct a
3 of definition
approach to design
new bounds on
property 2 of
the server s
communication complexity of
of the information
servers in a
t j the
2 of definition
of the linear
schemes in this
this access structure
the metering schemes
sharing schemes these
for secret sharing
is log jc
bounds the optimality
properties provide some
audit agency a
these properties provide
an audit agency
sharing schemes with
a qualified set
server during a
naor and pinkas
compute its proof
schemes obtained by
of secrets p
gamma it holds
any we denote
with set of
sharing schemes and
metering schemes with
and servers in
sharing schemes for
geometric secret sharing
absolutely no information
sharing schemes in
a time frame
metering schemes obtained
corrupt servers in
to these bounds
any server which
schemes these properties
the client c
corrupt servers and
scheme satisfies property
provide some new
the proof p
p t j
proof p t
b in time
general access structures
of clients x
subset of clients
servers and let
metering scheme is
compute the proof
compute the information
method relies upon
a coalition of
metering schemes a
threshold metering schemes
to the audit
x 62 gamma
audit agency to
time frames t
t the random
sharing schemes were
schemes with pricing
information rate ae
of corrupt clients
server which has
these bounds the
in the coalition
a corrupt server
subsets of clients
structure gamma can
some new bounds
structure gamma with

corpus/krapavin2000-test/1013562.txt
pebble
mso
pas
ras
pebbles
automata
ra
1n
fo
string
automaton
hypersets
strings
1d
nlogspace
alphabets
hyperset
register
configurations
xml
erent
pa
francez
kaminski
configuration
2d
2a
alphabet
pcp
registers
lmow
transitions
symbols
weak
accepts
delimiter
di
definable
alternating
undecidable
ga
emptiness
transition
lmo
accepting
symbol
head
parties
positions
universality
dialogue
membership
tape
alternation
expressiveness
infinite
languages
protocol
ptime
agap
accessible
monadic
strong
logics
reverse
accepted
logspace
position
gtm
reachability
lift
dom
placed
containment
deterministic
quantifier
logic
exp
2i
expressive
party
successors
agent
closed
proposition
val
encodings
simulate
iw
dialogues
regular
syntactically
decidable
2n
subsumed
labeled
variants
formula
vertex
quantification
encodes
erence
universal
kleene
dtd
segoufin
metafinite
etl
schwentick
adel
milo
equiped
globerman
formalisms
sym
walking
encode
sentence
messages
discipline
existential
trees
equality
harel
pebbled
vianu
suciu
transformers
xslt
subcomputations
yardstick
guesses
decidability
conjunct
closure
split
ph
tuple
inductively
stack
collapse
language
inclusion
theoretic
computable
lifting
gurevich
determinism
claim
incomparable
leftmost
stay
encoded
equip
assignment
recognize
finite
heads
occurrence
message
contradiction
dc
applies
encoding
star
depth
luc
lifts
unary
simulated
leaves
turing
nondeterministic
sweeps
checks
equals
ers
concatenation
formulas
express
undecidability
inclusions
rounds
accept
accessibility
completes
sends
liberal
numbered
web
quantifying
abbreviate
occurring
replies
sink
lifted
formalism
acts
enters
query
pebble automata
2d ra
pebble is
1n ras
reverse closed
1n ra
infinite alphabets
in mso
di erent
in u
q q
and francez
input string
1d pa
register automata
kaminski and
ras and
pebble i
the automaton
the string
data values
1d pas
1n pa
weak 1d
2a ra
strong 1d
string w
over d
u v
weak 1n
ga w
pcp instance
pas are
of configurations
a string
over infinite
two way
a configuration
hypersets over
second pebble
dom w
strong pas
of 1n
i 1
on w
the pcp
in v
state q
communication complexity
pebbles are
of pebbles
non emptiness
u and
a finite
lmow a
multi head
position l
2 hypersets
for nlogspace
d strings
automata models
2 hyperset
decision problems
strings of
i q
automata and
labeled with
new pebble
on strings
theoretic assumptions
the pebble
the pebbles
a pebble
ra is
regular languages
p v
automata we
the input
a accepts
current symbol
head automata
ordered reachability
current pebble
2d ras
val w
nlogspace and
in fo
weak pas
hard for
finite alphabet
v q
finite set
transition i
w is
q u
transition relation
complexity theoretic
strings over
an automaton
is undecidable
ra can
ras are
string u
is accessible
ra a
pairs q
initial configuration
of xml
accepted by
form u
automaton can
place new
configuration if
b i
each position
pebble assignment
i hyperset
s 2i
stack discipline
u equals
n di
pebble model
k pebble
pa proof
mso formula
strong pebble
that pas
consider strings
and pebble
split strings
2a pa
lmo u
hyperset over
i hypersets
for 1n
third pebble
fo and
pebble and
register assignment
and alternating
final configurations
finite alphabets
right delimiter
pebble to
infinite alphabet
d symbols
standard decision
syntactically correct
an accepting
of states
x x
and v
the symbol
definable in
exp 2
closed i
communication protocol
non deterministic
one way
a transition
q 0
a run
is placed
the position
one pebble
a 2a
initial register
ras can
ras is
x vertex
pa can
0 q
can simulate
the agent
of symbols
automata are
a solution
w l
complete for
current position
vertex x
the proof
monadic second
first position
finite memory
to ii
the symbols
an i
is hard
the current
be simulated
the language
string the
q i
we next
s p
the formula
assume w
cycles through
containment of
kaminski and francez
the input string
the pcp instance
over infinite alphabets
i s p
s p v
the second pebble
strong 1d pa
pebble is placed
u and v
of the string
of 1n ras
complexity theoretic assumptions
form u v
weak 1d pas
over d is
weak 1n pa
p v q
strings of the
is hard for
of the form
hypersets over d
multi head automata
the current symbol
pebble automata and
the initial configuration
for each position
a string w
is a finite
sets of configurations
input string w
the transition relation
the form u
t t t
a finite alphabet
finite set of
we show that
in u and
set of states
the first in
a finite set
the third pebble
decision problems for
q q q
hard for nlogspace
the right delimiter
1n ras is
that non emptiness
standard decision problems
of d strings
x vertex x
a on w
1n ras and
ra is complete
on strings of
a 2 hyperset
n di erent
lmo u a
a 2d ra
of pairs q
initial register assignment
the string the
string u v
reverse closed i
u equals the
the set of
o g that
is of the
of the pcp
the automaton can
based on communication
the initial register
pairs q q
the current position
is complete for
to the right
assume w l
of b on
with data values
configuration of a
a transition i
set of symbols
on communication complexity
string w is
the first position
the last in
monadic second order
position of the
l o g
w l o
b i 1
and two way
q q and
the proof of
x x x
placed on the
of a on
set of transitions
second order logic
v where u
q is the
i and ii
d 1 2
the form i
is placed on
with a finite
u v where
an infinite alphabet
1n ra is
represent a solution
pebble i 1
for 1n ras
q q d
accepts an input
a 2a ra
1n ra a
on split strings
s q q
state q and
erent data values
lift current pebble
show that pas
a run where
notion of regular
in ga w
the first pebble
b on w
the top pebble
show that universality
weak 1d pa
a weak 1n
fo and mso
place new pebble
strong pebble automata
pa can be
pebble i is
new pebble is
in some register
that strong pas
and kleene star
on w is
s in u
q 0 0
ras and pas
w a configuration
in the registers
transition i s
and francez 15
ra a that
the tape alphabet
and their logics
for reverse closed
accepted by b
p applies to
pcp instance has
d that applies
a strong 1d
finite memory automata
strings over infinite
non emptiness of
each position i
pebble on the
pebble automata are
of 2 hypersets
register and pebble
that pas are
concatenation and kleene
definable in mso
set of pebbles
are successors in
automata and their
non emptiness is
x x vertex
k pebble automaton
a 1n ra
one left to
1d pas can
each position l
by kaminski and
closed i for
a pebble is
the same dialogue
the 2d ra
defined in mso
the input is
are di erent
there is a
of theorem 5
on the current
the position of
there is an
the regular languages
an input string
where u and
a that accepts
first introduce some
q 0 q
over an infinite
of final states
in u or

corpus/krapavin2000-test/1013566.txt
impl
metalogical
maude
logic
rewriting
itp
theories
meta
frameworks
ective
equational
ection
module
logics
induction
inductive
metatheory
subsort
deduction
membership
metatheorem
metalevel
initiality
metatheoretic
sentconstant
reasoning
nat
rewrite
mb
makenewgoalsetf
universal
logical
arrow
entailment
formalize
extractrulesystem
metatheorems
inference
prover
axioms
principles
meseguer
bool
denitions
formula
axiom
reflection
intstring
metarepresentation
modules
abstractly
mod
sort
parameterized
formulae
reied
concretely
soundly
idx
sentences
clauses
horn
scoped
alpha
proving
vars
constructors
jos
dened
findsortv
getvars
fmod
metalogic
implicative
metathe
gomyampersanduml
8fx
proveininitial
reflective
dierent
ory
deductive
derivations
rules
beta
calculus
metamathematics
nuprl
syntax
sound
formalized
satised
conditional
lf
subscrpt
inductively
specied
ected
goals
proven
minimal
proofs
sequents
hol
rosser
none
re
signature
church
rewrites
rl
isabelle
theorems
strategies
implication
fs
quantied
denable
institutions
eective
formalization
rst
propositional
realization
gateway
xs
sen
del
sorts
object
conservatively
hilbert
calculi
equality
lm
shorthand
families
modulo
universally
modal
constructions
thesis
exible
interpreter
extracts
predicate
fs0
fixedpoint
noncommittal
proveinitial
basin
goalset
bow
destructors
neutrality
sublogic
meqtl
emptygoalset
internalized
endm
verdejo
logician
xedpoint
vquantification
metarepresentations
eker
proveinvariety
rwlogic
theoremhood
ecumenical
algebra
tm
italic
terminating
commutative
assertions
abstract
semantics
dening
formal
structuring
falseg
slogan
interrelationship
oliet
nitary
narciso
metaobject
subsorts
extensionally
durn
supercompiler
trueg
entailments
sentential
metareasoning
discriminators
bruni
clavel
yaw
rewriting logic
impl a
re ective
framework logic
metalogical frameworks
logical framework
the module
meta reduce
deduction theorem
re ection
metalogical framework
minimal logic
membership equational
universal theory
equational logic
induction principles
the deduction
module meta
initial models
logical frameworks
meta level
impl impl
impl b
mb impl
a impl
inductive denitions
theorem mb
in itp
logic is
logics and
of sort
rewrite theory
the maude
a metalogical
sentconstant formula
in maude
metatheoretic reasoning
ection and
in rewriting
a logic
logic as
have initial
case s
s itp
the metatheory
theory u
and initiality
subsort sentconstant
maude system
formula subsort
subsort theorem
sort term
logic with
of rewriting
b theorem
a theorem
logic and
reasoning about
maude s
theorem formula
inductive theorem
the framework
inference rules
a theory
theories in
step s
a re
object logic
arrow is
a logical
and impl
sub goals
arrow impl
b impl
mod arrow
module itp
bool subsort
ective logic
including bool
a none
this metatheorem
c impl
none none
reduce arrow
a rewrite
theory e
rewrite rules
the universal
logic in
induction step
higher order
with re
theorem prover
reflection in
object logics
each theory
object level
order abstract
is including
of theories
induction over
module m
representation function
jos meseguer
formal systems
for reasoning
a module
induction is
for rewriting
in minimal
sound reasoning
metarepresentation of
axiom a
ective metalogical
metatheory in
entailment relations
eective metalogical
formalize theories
the metalevel
the metarepresentation
inductive definitions
are reied
zero nat
metatheory of
that rewriting
function makenewgoalsetf
module t
framework theory
ective logical
mb a
meta metalevel
module minimal
logic has
theories and
theory t
reasoning principles
rule induction
equational theory
base case
is re
and rewriting
and induction
an inductive
theorem is
the logic
theorem and
to formalize
induction on
the representation
the object
the inference
principles for
formula theorem
for equational
conditional rewriting
membership algebra
reason about
abstract syntax
the logical
horn logic
inference system
of constructions
meta programming
theories have
the term
a framework
of minimal
term t
of parameterized
in membership
that dene
of re
a term
is proven
a universal
clauses that
order logic
logic the
logic to
extended with
theorem proving
its representation
the inductive
a membership
re ected
strong enough
with equality
theorem in
the formulae
induction and
framework with
the variable
using re
metathe ory
maude to
initiality are
intstring idx
logic independent
about logics
underlying equational
the framework logic
the deduction theorem
in the module
membership equational logic
impl a impl
module meta level
a impl b
the module meta
impl impl a
a logical framework
rewriting logic is
a re ective
in rewriting logic
case s and
have initial models
theorem mb impl
re ection and
induction step s
the universal theory
base case s
logic as a
of rewriting logic
sentconstant formula subsort
of sort term
inductive theorem prover
formula subsort theorem
is re ective
a rewrite theory
b theorem mb
a metalogical framework
subsort theorem formula
with re ection
the maude system
subsort sentconstant formula
impl a b
mod arrow is
mb impl impl
b impl impl
impl b theorem
impl a theorem
meta reduce arrow
c impl a
theorem and impl
reduce arrow impl
is including bool
impl b c
a b impl
and impl a
impl a none
b c impl
logic is re
arrow impl a
of minimal logic
a universal theory
arrow is including
bool subsort sentconstant
re ective logic
including bool subsort
a none none
mb impl a
the inference rules
for rewriting logic
of the deduction
a theorem and
rewriting logic the
rewriting logic as
order abstract syntax
the object logic
higher order abstract
theories in the
the logical framework
in the framework
induction over the
with higher order
higher order logic
extended with the
theories have initial
the metarepresentation of
step s that
ection and initiality
each theory in
s and induction
programming in logic
deduction theorem is
metatheory of rewriting
the rule induction
the metatheory of
re ective metalogical
at the metalevel
the function makenewgoalsetf
the module minimal
represented in itp
re ective logical
metarepresentation of the
the module m
clauses that dene
the module itp
a framework logic
of re ection
and induction step
the inductive theorem
in the logic
induction principles for
in membership equational
conditional rewriting logic
logic and its
equational logic and
that dene the
calculus of constructions
a representation function
horn logic with
logical framework with
meta programming in
terms of sort
and rewriting logic
logic with equality
with a strategy
for reasoning about
the calculus of
theorem is true
and the induction
logic in the
as a logical
in a logic
on the variable
as a framework
of the module
dene the set
for the inductive
induction on the
the induction step
theory in the
a logic in
rewrite theory e
families of theories
specied in itp
logic and rewriting
sound reasoning principles
object logic and
formal systems in
both abstractly and
the appropriate base
intstring idx 1
mb a theorem
module m the
and initiality are
logic with an
the axiom a
be re ected
using re ective
universal theory u
abstractly and concretely
and its representation
universal theory for
logics and their
rewriting logic in
of inductive denitions
associated methodology that
rewrite theory t
rewriting logic maude
in itp we
term mod arrow
for each theory
strategy dened in
logical framework to
rule induction along
an associated methodology
metatheory on inductive
framework with re
logical frameworks with
is shorthand for
the membership axiom
appropriate base case
the equations e
an inductive theorem
theorem formula mb
the sub goals
true in minimal
ective metalogical framework
eective metalogical framework
a strategy dened
logic of implication
metalogical framework we
good logical framework
nontrivial kinds of
this metatheorem with
internal strategy languages
b is proven
that rewriting logic
framework rewriting logic
ective logical frameworks
reasoning with higher
using the equations
re ection in
following goal for
subsort zero nat
rewriting logic has
that logical frameworks
minimal logic as
of the metatheory

corpus/krapavin2000-test/1013681.txt
player
adversary
jobs
competitive
target
er
job
sjt
signal
airs
gene
wrr
targets
breakpoint
adversarial
chance
tjs
probabilities
scheduling
chromosome
breakpoints
suppressor
irr
genes
knows
signals
bayesian
harmonic
players
ratio
she
rmax
regret
scenario
fractions
completion
strategy
dierent
clinical
xed
diuse
nonclairvoyant
rightmost
preemptive
candidate
jt
candidates
games
assigns
denition
entropy
tumor
online
randomized
root
decision
partner
gets
nished
robin
her
deadline
unknown
sjr
nish
costs
weights
sn
adversaries
who
devoted
clairvoyant
damaged
st
innite
malicious
omniscient
damaschke
randomization
minimizing
game
posterior
schedules
ignorant
shut
deterministic
versions
xes
devote
maximized
density
searching
strategies
achieves
raise
schedule
freely
resembles
round
dene
rst
spent
prex
stretch
likelihoods
slowdown
children
equidistant
smith
motivation
moment
interval
rr
monotone
comparative
intervals
proportional
axis
constantly
permanently
shannon
decreasing
weighted
xn
sided
minimize
against
ith
prior
forwarded
overloaded
dened
selects
actions
falsication
lthi
devotes
nerman
searcher
imagines
somatic
grange
amazingly
matical
knocked
unforeseeable
vivid
olle
looses
uniformityo
omnipotent
sahlgrenska
misinterpreted
martinsson
dures
slighted
gothenburg
unawareness
bergkvist
cells
fraction
ik
robot
dier
remark
object
child
completes
favor
dening
objects
wishes
informative
nally
nds
opt
tommy
1355
1339
uncountably
probabil
normalizations
healthy
surprises
fortune
fools
grows
supposed
decrease
minimized
preemptions
mathe
wheel
fatal
chalmers
searchers
mutations
tree
multiplicative
action
line player
on line
competitive ratio
the on
the target
the adversary
decision times
the competitive
chance node
p sjt
the jobs
target probabilities
line strategy
the signal
the p
target is
c i
player gets
the airs
p i
x tjs
knows the
adversarial root
target job
rightmost breakpoint
chance nodes
optimal competitive
completion time
c j
signal s
player s
of chance
suppressor gene
i jt
t st
signal density
candidate genes
l o
the bayesian
s i
all jobs
o g
w l
x k
the c
signal probabilities
decision time
player knows
adversary who
bayesian model
problem versions
job i
jobs results
start processing
ratio er
target candidates
airs model
adversary assigns
decreasing c
player does
of competitive
scenario 2
line scheduling
an adversary
target and
chosen according
competitive analysis
an on
s t
deterministic strategy
and adversary
job as
player and
target decision
the optimal
optimal solution
ratio for
of jobs
in scenario
are equal
jobs are
that she
who knows
the rightmost
airs framework
er n
diuse adversary
short job
results scenario
player who
harmonic achieves
randomized strategies
scenario 4
target completion
scenario 5
partner chromosome
target candidate
xed s
nonclairvoyant scheduling
b i
prior probabilities
optimal strategy
jt j
adversary has
the expected
probabilities p
against an
a chance
targets and
the adversarial
st c
xed weight
random signal
time fraction
and competitive
one target
times c
jobs not
deterministic on
player has
expected completion
deadline scheduling
the weights
lemma 4
er for
of targets
models where
line problems
strategy has
strategy is
probabilities and
i but
and deadline
both players
smith s
comparative analysis
object t
spent on
signal and
we may
can start
round robin
game is
and unknown
s rule
scenario 1
following strategy
a signal
all objects
jobs in
non decreasing
of candidate
ratio of
theorem 3
preemptive scheduling
a i
for s
are proportional
adversary may
p s
i c
object i
the strategy
we remark
running jobs
scheduling search
job did
shows theorem
before shut
target probability
adversary node
root entropy
can w
randomized adversaries
er measures
multiplicative regret
airs setting
breakpoint falls
against randomized
jobs before
line players
sjt for
ordered targets
fractions to
unknown decision
adversary xes
gene search
who selects
probabilities but
sided signals
all targets
achieves er
expected index
down online
to nish
given probabilities
scheduling online
overloaded systems
clairvoyant scheduling
robot searching
on line player
the on line
the competitive ratio
the p i
that the on
on line strategy
the target is
the c i
line player gets
knows the target
l o g
w l o
competitive ratio for
the optimal competitive
line player knows
the target job
in the airs
line player s
s i jt
the rightmost breakpoint
optimal competitive ratio
is chosen according
an on line
to the p
for s t
is the target
the bayesian model
on line scheduling
line player and
start processing the
a chance node
non decreasing c
processing the jobs
i jt j
the signal density
of chance nodes
and can start
the airs model
of competitive ratio
knows the p
line player does
of candidate genes
the jobs results
competitive ratio er
the adversary assigns
where the on
to all objects
can start processing
s p sjt
chosen according to
p s i
competitive ratio is
i to all
who knows the
of the target
x k x
competitive ratio of
an adversary who
but not the
x k 1
in the bayesian
s t for
denition of competitive
player and adversary
nodes the on
signal s is
c i but
level of chance
times c i
line strategy is
the target candidates
player gets the
known and unknown
i as input
t st c
st c t
target probabilities and
player does not
deterministic on line
and deadline scheduling
target completion time
chance nodes the
line player has
target is chosen
and decision times
player knows the
an optimal solution
of the p
the target and
on the target
the expected completion
expected completion time
the optimal strategy
0 for s
i but not
if the target
on line problems
smith s rule
against an adversary
be the time
e s t
models where the
to the on
object is the
and 0 for
k x k
i c j
of on line
the following strategy
of the on
1 the adversary
then the optimal
to x the
are proportional to
that the adversary
we remark that
one by one
the x i
the adversary may
for any xed
theorem 3 4
scheduling online computation
er measures the
has competitive ratio
where the jobs
independent of s
competitive ratio a
p sjt where
bayesian model with
target probabilities p
that the competitive
has to x
has devoted at
beyond competitive analysis
online parallel heuristics
same actions available
even knows the
on the partner
preemptive on line
jobs adversarial root
the signal probabilities
but the on
not nished yet
job as target
to all jobs
o g consider
decision times in
with known and
one sided signals
the competitive framework
adversarial root the
before shut down
the adversary needs
jobs results scenario
the bayesian setting
an adversary node
competitive ratio can
the adversary even
jobs before shut
any xed s
scheduling jobs before
the expected target
assigns target probabilities
totally ordered targets
the diuse adversary
searching under the
decision times and
are of similar
on line players
short job did
the strategy has
unknown decision times
the airs setting
she has to
the p sjt
decision times c
p sjt x
devoted at most
under the competitive
heuristics and robot
the slow job
all jobs adversarial
and a signal
target and assigns
o line player
chance node is
know the c
target candidate points
jobs not nished
c t in
non clairvoyant scheduling
adversary needs only
the target with
signal s i
jobs one by
o g the
targets and one
reached c j
the target probabilities
as target in

corpus/krapavin2000-test/1013707.txt
cts
snd
extraction
df
extr
buf
channels
dom
csp
traces
ep
communicating
refusals
koutny
channel
refusal
behaviour
burton
pappalardo
ref
processes
eg
uninterpreted
trace
refinement
divergences
specification
di
interface
relating
realisability
compositionality
actions
unfinished
erent
transition
compositional
interfaces
bm
dp
action
eg2
idch
nak
vcts
failures
abstraction
ack
er
patterns
verification
diverging
composition
erence
alphabet
blocked
deadlock
domall
engage
ge
collapses
target
compound
transmission
hiding
ak
sim
failure
vertical
fault
divergence
refining
event
unambiguous
prefix
labelled
proposition
twice
arcs
interpreted
arc
stipulate
horizontal
treatment
reachable
composed
concurrency
sender
mapping
ep4
csp3
rensink
gorrieri
unboundedly
disambiguating
breached
cult
communication
interpret
bu
signals
te
suitably
lc
specifications
concrete
tolerant
a1
respective
refuse
implementations
verifying
modelling
contribute
regarded
targets
replicated
restatement
monotonic
device
explosion
formedness
adhering
technically
pattern
bisimulation
transducers
mappings
sources
base
implements
entailment
realm
faulty
ours
erences
treatments
prone
hidden
internal
verify
graphs
identity
interprets
io
associative
arrows
outgoing
extract
semantics
transitions
extracted
amenable
modelled
infinite
ambiguous
imposed
progress
constraining
unacceptable
denotational
intended
strict
amounts
highlighted
algebras
transmissions
sequences
enabled
deleting
collapse
ambiguity
sensible
liveness
coincide
motivations
interact
fig
composing
reliable
algebraic
duplicated
connecting
wish
deterministic
correctness
notions
annotations
interpretation
disturbers
realis
accomplishments
csp4
ctss
ployed
csp2
terpreted
overtaken
pcts
izontal
implementation relation
extraction patterns
cts u
extraction pattern
communicating transition
relating communicating
the implementation
of extraction
extraction graph
m koutny
koutny and
j burton
g pappalardo
burton m
communicating processes
of channels
an extraction
base process
extraction graphs
dom q
extraction mapping
the extraction
in dom
of cts
d 1
the interface
an implementation
ref t
vertical implementation
snd 2
base processes
action refinement
and buf
transition system
snd and
process p
a trace
the specification
process q
implementation process
traces in
standard horizontal
graph eg
interface di
s ack
cts n
of traces
di erent
specification and
communication on
channels in
t dom
b i
traces and
snd 1
extr q
csp process
in cts
output channels
dom ep
a communicating
interface refinement
trace over
the refusal
a process
t r
of q
of csp
all traces
interface of
output channel
that snd
input channels
eg i
implementation relations
of snd
transition systems
processes and
input channel
1 d
the channels
of processes
traces of
r 1
target process
system cts
specification component
non diverging
a df
and df
eg twice
csp processes
source channels
channel b
snd buf
behaviour abstraction
traces over
extr t
deadlock properties
extr ep
and cts
refusal bounds
interfaces of
same interface
channels of
r 0
and g
if t
and extraction
communicating sequential
the event
non empty
p p
di er
for every
channel d
cts and
channels b
implementation system
a specification
sequential processes
of interface
di erence
a failure
the communication
processes in
parallel composition
v a
dom i
by ref
t u
q a
the behaviour
q 0
of p
system q
q p
failure of
buf c
interfaces di
the refusals
q implements
uninterpreted channel
s nak
uninterpreted channels
placed upon
by cts
the composed
that extr
and extr
local failures
blocked t
interpreted channel
implementation processes
refusals of
nak r
prefix closure
to engage
cts buf
extr all
network composition
for cts
bm n
are uninterpreted
on refusals
standard csp
set extr
an unfinished
ep twice
for traces
q df
local failure
implementation conditions
failures divergences
behaviour on
buf are
implementation component
sim min
r dom
ep eg
subset closed
and refusals
mapping ref
identity extraction
and implementation
q satisfies
refinement is
event that
alphabet of
two processes
patterns in
of refinement
behaviour is
to verify
of abstraction
a w
all channels
p and
specification system
a bu
the implementation relation
relating communicating processes
koutny and g
and g pappalardo
m koutny and
j burton m
burton m koutny
of the implementation
1 d 1
set of channels
of extraction patterns
communicating transition system
traces in dom
communicating transition systems
d 1 d
the communication on
extraction graph eg
snd and buf
an extraction graph
extraction patterns in
specification and implementation
in the event
the interface of
cts u and
base process p
vertical implementation relation
the extraction mapping
an extraction pattern
a communicating transition
a base process
of all traces
1 r 1
of an implementation
of the specification
the same interface
a non empty
implementation process q
and cts n
of extraction pattern
of cts u
a trace over
event of interface
the implementation process
transition system cts
extr q a
sets of channels
communication on the
the input channels
extraction patterns and
of interface di
if t r
a t w
p s ack
a standard horizontal
t b i
if v a
communicating sequential processes
set of all
a failure of
of the interface
r and s
process p is
domain of q
v a t
set of extraction
b is a
p p p
in the implementation
the set of
contribute to a
1 p n
the event that
such that v
to a failure
of the arc
snd buf c
model of csp
implementation relation is
the implementation conditions
a csp process
process q with
interface di erence
simulation for cts
defined for traces
r dom q
traces and refusals
over the source
t r p
in cts u
blocked t r
u and cts
s 1 r
the extraction patterns
systems and extraction
and extraction graphs
b i dom
cts u has
failure of q
of channels in
interfaces di er
and buf are
by ref t
t r dom
s nak r
the source channels
is an extraction
for cts u
an implementation process
notion of extraction
behaviour on a
of cts and
the extraction pattern
i dom i
graph of cts
interface of an
an implementation relation
sequence of traces
the behaviour of
a process p
interface of the
shown in figure
the initial state
the specification and
and t u
high level action
b i s
a simulation for
of capacity one
p r 0
we denote v
is no t
a bu er
is a non
p 1 p
we can extract
the state explosion
over r and
the initial node
notion that a
state explosion problem
nodes reachable from
denoted by dom
the event of
is the set
the b i
the alphabet of
the parallel composition
a more concrete
v a w
parallel composition of
is a trace
transition systems and
i a t
that a process
of processes and
v i a
the two processes
a graph theoretic
in the sense
from the initial
in terms of
that the implementation
0 r 1
and for every
v is a
for every t
q and p
verification of the
implementation in the
the implementation and
a set of
the notion that
a trace of
that the communication
for traces in
to implement p
q implements p
snd 2 can
interfaces of communicating
system cts u
implementation relations and
definition of extraction
i cts u
connecting their respective
that ep eg
process to that
implementation relation which
process q as
that being an
w in cts
implementation relation collapses
of extraction graphs
in dom we
s ack s
by connecting their
nak r 0
that snd and
transition systems representing
from a specification
several connected systems

corpus/krapavin2000-test/1013722.txt
covertext
alice
stegosystem
stegotext
steganography
bob
hiding
eve
entropy
deltat
adversary
repetition
compression
pq0
secure
security
steganographic
prisoners
she
adversaries
pc
pq1
message
secret
passive
encoder
stegosystems
watermarking
universal
authentication
embedding
hidden
pad
bla87
eurocrypt
fingerprinting
warden
willems
decoder
theoretic
encoding
fi
kp
distributions
lempel
copyright
hypothesis
coding
ziv
decode
perfectly
active
simmons
bit
alphabet
innocent
block
ff
probabilities
protection
ckls96
ettinger
zl77
covertexts
wil89
tology
steganalysis
kpq1
testing
unconditionally
inactive
embedded
tampering
neyman
pq
maurer
cryp
observing
equilibria
conditioned
decoding
advances
pearson
cryptology
decision
statistics
px
source
probability
accepting
messages
blocks
stochastic
bits
discrimination
legitimate
sent
statistical
encoded
jv
cryptography
indistinguishable
hide
parties
audio
detection
external
ett98
monochrome
sim85
mas91
plenary
pw97
cjz
bgml96
crypto
pcz
z2z
falsely
perceptible
blahut
eli87
stegotexts
accuses
boyko
and96
ct91
pfi96
cjc2c
sim84
perceptional
sha48
stego
fumy
prison
zfk
ber85
nfc94
subliminal
bcw90
blocklength
ap98
sim91
mau96
fool
jail
isln
ueli
error
sends
knows
channel
unrealistic
compressed
f0
1g
conditional
detect
rank
uniformly
distinguishing
ps96
watermark
thwart
ns95
q0
waidner
realms
exerted
traitor
swiss
buffer
ultimately
concatenation
ranking
her
fraudulent
xjy
intellectual
suspicious
ban
elias
authenticating
cover
bayesian
against
terminology
game
text
quantify
stationary
rivest
buyer
recency
pu
gammaffi
literally
ergodicity
retransmitted
illegal
the covertext
data compression
deltat y
relative entropy
information hiding
block y
covertext distribution
covertext c
stegotext s
repetition time
the stegotext
hypothesis testing
alice is
and bob
ii error
alice and
hidden information
a stegosystem
average repetition
universal data
information theoretic
error probabilities
decision rule
the adversary
perfectly secure
embedded message
type ii
the security
d pc
i error
by alice
steganography with
active adversaries
the prisoners
repetition times
against passive
pq0 and
whether alice
hidden message
security of
type i
key k
if alice
and pq1
the encoder
is active
passive adversary
prisoners problem
for steganography
and stegotext
passive adversaries
pc c
ffl secure
kp s
pc kp
time pad
of steganography
a universal
to bob
information theory
theoretic model
secret key
time deltat
bit message
a hidden
probability distributions
the embedded
authentication theory
containing hidden
secure stegosystems
stegosystem is
covertext source
message c
source coding
steganography is
secure stegosystem
the stegosystem
probability fi
the embedding
she is
encoding and
secure against
hiding information
pq 0
entropy between
entropy d
embedding function
from alice
a secret
knowledge of
random variable
an embedded
a passive
a message
message e
statistical decision
uniformly random
a type
c or
n bit
for information
unconditionally secure
alice s
bob can
compression algorithms
generated according
that alice
compression algorithm
h 0
an information
distributions are
the relative
a block
decision theory
one time
the probability
the block
the entropy
advances in
the source
the average
the type
and fi
source output
tology eurocrypt
a steganographic
y deltat
x conditioned
hiding on
copyright protection
px and
covertext distributions
d pq0
hide an
blocks y
stegosystem with
hiding has
or stegotext
ziv algorithms
binary partition
source statistics
stegosystem that
stegosystem for
steganalysis and
compression a
eve does
covertext and
in copyright
steganographic system
the neyman
pearson theorem
that eve
covertext statistics
to steganography
hiding terminology
source r
sending covertext
of steganographic
steganographic systems
called ffl
cryp tology
random source
in cryp
universal algorithm
encoding c
last occurrence
game equilibria
decoder maintain
pad provides
with alphabet
private random
between pc
willems algorithm
cover message
equilibria an
adversary eve
upon observing
adversaries if
alphabet x
universal stegosystem
all parties
is inactive
pq0 kpq1
of deltat
steganography can
external information
secret shared
conditioned on
entropy of
this model
y 0
observing the
the conditional
was generated
for accepting
achieves asymptotically
the repetition
alice sends
security definition
bob share
the covertext distribution
universal data compression
alice and bob
type ii error
the relative entropy
alice is active
type i error
the security of
a hidden message
for information hiding
a block y
average repetition time
information theoretic model
the average repetition
the type i
whether alice is
pc kp s
covertext c or
one time pad
time deltat y
d pc kp
the stegotext s
secure against passive
an embedded message
against passive adversaries
pq0 and pq1
of the covertext
of a stegosystem
repetition time deltat
model for steganography
a passive adversary
an information theoretic
theoretic model for
security of a
of information theory
steganography with a
data compression algorithms
the covertext c
the covertext source
containing hidden information
secret key k
covertext distribution is
the block y
stegotext s is
ffl secure against
if the covertext
the decision rule
by alice and
i and type
decision rule is
relative entropy d
on knowledge of
covertext c and
was generated according
if alice is
and type ii
relative entropy between
the prisoners problem
type i and
shared by alice
a type i
a universal data
the embedding function
statistical decision theory
with a passive
knowledge of the
generated according to
a type ii
hypothesis testing is
a secret key
that the adversary
h 1 is
the probability distributions
in this model
q was generated
be to model
source statistics are
information hiding on
has to decide
using a secret
distributions are equal
model the covertext
private random source
bob can decode
hypothesis testing we
deltat y the
a one bit
time is encoded
y is replaced
covertext and stegotext
is called ffl
information hiding has
error for accepting
lempel ziv algorithms
decides that alice
entropy or discrimination
x conditioned on
unconditionally secure stegosystems
covertext source as
then q was
probability is denoted
passive adversary is
the type ii
and game equilibria
uniformly random bits
compression a universal
sent by alice
kp s thus
passive adversaries if
a universal stegosystem
a perfectly secure
or stegotext s
data compression algorithm
a binary partition
is active or
to hide an
in cryp tology
practice of information
for steganography with
of data compression
makes a type
data compression the
a steganographic system
with active adversaries
quantify the security
approach to steganography
of a steganographic
is perfectly secure
steganography is the
security of steganographic
ii error probabilities
neyman pearson theorem
in copyright protection
i error and
observing a message
the embedded message
eve does not
the adversary eve
decoder maintain a
and stegotext s
of steganographic systems
y deltat y
c or stegotext
entropy between two
secret shared by
true then q
d ff fi
error probabilities are
s containing hidden
d pq0 kpq1
the source output
sent from alice
cover message c
the neyman pearson
of the stegotext
and decoder maintain
to all parties
random source r
the source statistics
hiding on the
advances in cryp
bit key k
steganalysis and game
c and stegotext
average repetition times
active adversaries is
relative entropy or
of deltat y
detect a hidden
relative entropy and
between pc and
pc c log
called ffl secure
encoder and decoder
time pad provides
sending covertext c
of the prisoners
average error probabilities
of source coding
hiding has been
the one time
game equilibria an
bit message e
advances in cryptology
of a hidden
that the covertext
data compression a
block y is
or discrimination between
steganography can be
a hypothesis testing
active or not
observing the message
the stegosystem is
information hiding terminology
deltat y and
modeling the security
cryp tology eurocrypt
is denoted by
source as a

corpus/krapavin2000-test/1013757.txt
npmv
pmf
safe
nondeterministic
recursion
bellantoni
jxj
leivant
multifunctions
rm
minimization
seqbnd
dened
polymax
fp
recursive
nml
conguration
computable
thm
np
cobham
dene
denition
denable
primitive
polynomial
poly
multifunction
conp
mod
composition
brn
analog
cook
rec
accepting
srn
witnessing
oracle
register
guess
honest
instructions
mach
reject
contents
jyj
bwm
arguments
rejects
characterizations
analogy
polytime
nite
successors
denitions
bits
accept
jwj
bounded
proposition
characterization
jxjjyj
smash
honesty
ado
undened
tier
a0
oracles
registers
weak
congurations
denes
swm
jzj
jmj
9y
accepts
operator
hierarchy
partial
computability
9u
selman
verication
pr
totality
dom
9g
characteristic
kleene
induction
quantier
jej
ought
acc
jy
nondeterministically
tape
reverse
projections
transition
sharply
halts
normal
mention
enters
instruction
coding
implicit
asserts
hx
closed
reducible
prop
identied
predicate
s1b
unproblematic
totalize
tiering
ramied
shines
jnj
philosophically
balcazar
gabarro
spreen
impredicatively
maxfjajg
iaz
stahl
jzjp
unpleasantness
jj
deterministically
executing
tm
somehow
specically
fy
analogous
outputs
valued
bit
predecessor
cfg
onward
reinforced
naturality
reinforce
rej
jvj
impredicative
jtj
semicolon
ministic
ran
turing
rst
predicates
schemes
predicative
nullary
ate
stores
theoretic
operators
unnatural
rosser
subtlety
arithmetic
yi
ranges
simultaneous
backed
yg
verications
verbatim
retrospect
z
dierent
codes
direction
resources
referring
identication
arguing
deter
jz
multivalued
1m
delimit
machines
he
dierence
resource
x5
safe recursion
partial recursive
recursive functions
pmf s
2 npmv
7 y
state d
on notation
a pmf
recursion on
nondeterministic rm
p jxj
x a
polynomial time
primitive recursive
seqbnd e
is dened
weak minimization
poly bounded
2 np
a nondeterministic
of fp
is poly
minimization operator
input x
conguration of
on input
polymax bounded
npmv is
of pmf
np conp
nondeterministic safe
dened by
time computable
analog of
x 7
by safe
bounded recursion
npmv and
computation sequence
of npmv
c safe
run m
of minimization
safe arguments
x z
mod 2
m on
a 7
the primitive
contents of
smallest class
safe composition
thm 3
the partial
f x
partial functions
by bounded
the contents
on x
nondeterministic recursion
q jxj
nondeterministic state
that npmv
bounded witnessing
by leivant
safe weak
jxj j
is polymax
normal arguments
cobham s
bellantoni and
e nml
total multifunctions
binary successors
register machine
primitive recursion
higher type
bits of
with output
reverse direction
functions denable
some z
cook s
and cook
or safe
recursion and
partial function
closed under
total functions
single valued
np i
suppose that
of m
the denition
a conguration
m accepts
functions computable
an accepting
low order
have x
denition of
then 2
then f
a 2
states t
2 c
on pmf
composition brn
computable on
of thm
rm m
type computability
denable with
tier 0
bounded version
bellantoni s
leivant 6
total minimization
implicit computational
guess y
pmf is
recursive sets
npmv i
rm s
multifunctions of
d a0
brn and
class npmv
in npmv
successors s
minimization are
j seqbnd
total multifunction
poly checking
a polynomial
i there
polynomial q
from and
that x
that 2
the class
the safe
of partial
a computation
forward direction
bounded on
fp with
direction suppose
accept and
the polytime
accepts with
to adding
nondeterministic polynomial
resource free
z mod
a mod
b mod
bounded or
is closed
z a
view is
of total
and otherwise
then accept
the rm
order bits
with code
is undened
it rejects
composition is
composition and
z is
d a
computed by
compute x
states d
accepting computation
under composition
functions of
the polynomial
e p
code of
z 7
and safe
accepting state
length p
of nondeterministic
from when
to state
dene a
denitions of
set then
by induction
denable in
nite set
the reverse
in polynomial
change to
characterization of
partial recursive functions
recursion on notation
the partial recursive
a nondeterministic rm
x 7 y
on input x
is dened by
nondeterministic safe recursion
dened by safe
the primitive recursive
primitive recursive functions
analog of the
a 2 np
x a 2
seqbnd e p
a 7 y
run m on
bounded recursion on
e p jxj
to state d
is poly bounded
of partial functions
smallest class of
safe recursion on
of pmf s
f x a
the contents of
the smallest class
m on input
polynomial time computable
for the reverse
x a b
a computation sequence
change to state
be a pmf
p jxj j
dened by bounded
state d k
class of total
class of pmf
safe weak minimization
2 np i
is polymax bounded
mod 2 7
bellantoni and cook
suppose that x
the reverse direction
i there is
is the contents
is closed under
if x a
on the denition
a conguration of
suppose that 2
x z a
the total functions
is the code
the code of
of the partial
is computed by
higher type computability
have x a
and cook s
on pmf s
by bounded recursion
the safe arguments
j seqbnd e
is poly checking
direction suppose that
output of x
np i there
a b mod
that 2 npmv
nondeterministic rm m
2 np conp
accept and output
on notation is
polymax bounded on
z 7 y
bounded on x
successors s 0
the forward direction
x a c
npmv is the
accepts with output
composition brn and
version of minimization
x a 7
2 npmv i
computation sequence of
in state d
a total multifunction
conguration of n
computable on a
by safe recursion
contents of 0
that npmv is
implicit computational complexity
of total multifunctions
weak minimization is
bounded or safe
2 q jxj
a set then
m on x
is some z
reverse direction suppose
characterization of fp
state d a
the states t
set then a
of nondeterministic recursion
then accept and
denable in c
functions denable with
length p jxj
binary successors s
under composition brn
the class npmv
we have x
the class c
class of partial
that x 7
of higher type
that is poly
nondeterministic polynomial time
recursive functions and
low order bits
order bits of
is an accepting
state d i
bounded by q
if it rejects
when in state
now suppose that
d i if
of a nondeterministic
closed under composition
by a nondeterministic
then a 2
nite set of
for all x
2 7 0
x a is
denition of c
a is dened
in polynomial time
z is the
the proof that
is a polynomial
and s 1
f x z
that is closed
the denition of
x and a
a 2 c
is polynomial time
code of a
the polynomial time
0 and s
as the proof
a partial function
induction on the
of length n
a notion of
essentially the same
for which there
if a is
executing instructions in
then 2 c
exactly the total
npmv i 2
containing b 0
nondeterministic rm with
2 npmv such
every nondeterministic state
k when in
induction that if
jej e the
p jxj and
that fp is
z seqbnd e
x is undened
described by e
proof of thm
and output y
m accepts with
polynomial q such
poly checking on
a deterministic rm
new recursion theoretic
from and written
7 y mod
repeated any number
d acc and
rm with code
resulting class of
a partial multifunction
i if j
simultaneous safe recursion
recursive functions we

corpus/krapavin2000-test/1013758.txt
bll
realizability
polytime
morphism
lambda
resource
monoidal
witnessed
ne
morphisms
substitution
dyadic
functor
computable
polynomials
xyz
witnesses
goerdt
pwq
xy
untyped
theoretic
formulae
tally
positively
negatively
sequent
resp
category
sequents
girard
polynomial
categorical
valuations
waste
forgetful
pnq
yx
functoriality
homologous
syntax
denotations
logic
calculus
typed
proofs
axiom
arity
lists
constructive
successor
da
lh
proposition
representable
weak
cut
composition
extensional
storage
closed
monotone
erent
formula
interpretation
polymorphic
ambient
induction
light
pairing
stratified
characterizations
computability
lemma
justifies
quantification
functional
formulas
normalization
st
formers
n28436
antitone
subquotient
uneasy
eponymous
normalisable
monoidalness
sleight
scedrov
bck
dereliction
connectives
lemmas
interpret
elimination
universe
axioms
derivations
indexed
semantics
def
ij
products
soundness
odel
retracts
feels
lll
retractions
polymorphically
sloppily
gentzen
topos
substitu
occurring
capturing
generous
fibred
bears
zf
ptime
pers
mathematician
inductively
says
notice
shall
compilation
cf
provability
gurevich
peano
fst
yz
characterisations
defini
er
strength
di
formalize
qa
subterms
logspace
lncs
stipulate
multisets
iteration
occurrence
inductive
remark
validates
presumed
combinators
foundational
componentwise
encompasses
constructively
constructions
categories
ternary
valuation
xx
defect
write
usual
characterizing
ectively
intriguing
nx
connective
extends
polymorphism
pspace
interprets
isomorphisms
inverses
congruence
carrier
ordinary
tracked
bijection
epsrc
subsumed
witness
multiset
distinctions
389
encoded
atomic
universal
primitive
merits
sublinear
weakening
rules
concrete
altering
binomial
syntactical
realizability set
a realizability
over x
realizability sets
a morphism
resource variables
a ne
ne lambda
of bll
linear logic
b x
dyadic lists
resource polynomials
witnessed by
set theoretic
n x
resource polynomial
is polytime
substitution from
x p
lambda term
of resource
set over
second order
bounded linear
order environment
be witnessed
lambda terms
a substitution
of realizability
bll formula
environment over
a bll
over y
computable in
v x
x to
f n
p x
free resource
a a
x x
x is
for bll
x xy
a over
is computable
x y
we write
morphism from
of dyadic
light linear
e x
p a
t a
most x
sets over
untyped lambda
positively in
the realizability
from x
x n
proposition 4
a b
morphism over
weak x
sequent a
tally natural
iteration lemma
bll formulas
polytime algorithms
bll in
xy x
the bll
e witnesses
witnesses f
bll are
in bll
polytime computable
n n
we notice
e is
time computation
occurs positively
symmetric monoidal
order variable
a monoidal
ne linear
monoidal closed
a sequent
a f
lemma 4
polynomial time
that e
positive in
from n
x and
x we
f a
this says
forgetful functor
is witnessed
morphism f
morphisms between
definition 4
set a
lambda calculus
natural numbers
n p
an untyped
cut elimination
the forgetful
order variables
a is
write a
t x
f e
2 x
let be
i p
notice that
a functor
time computable
that x
to y
is positive
denotations of
p p
algorithm e
set theory
function n
x be
x 0
goerdt s
indexed products
resp negatively
ne variant
logic characterizing
consider morphisms
polytime the
negatively in
useful examples
constructions 2
resp see
xyz x
resource variable
of tally
complexity lambda
bounded storage
size increasing
type primitive
representing zero
a extends
defined t
bll which
inductive constructions
non size
are polytime
functions representable
realizability model
are proofs
our ambient
valuations over
bll syntax
the homologous
and xyz
computational strength
increasing polynomial
u indexed
homologous p
ambient set
of polytime
application st
entire discussion
linear types
bll 3
y yx
satisfying x
logic bll
between realizability
iteration principle
stratified functional
bll we
functor proof
by x
example 4
e y
write p
a second
the function
function f
function e
complexity classes
to b
proof of
let a
by e
polynomial p
by induction
a be
a realizability set
a ne lambda
realizability set over
t a a
a substitution from
substitution from x
is a morphism
set over x
of realizability sets
bounded linear logic
x p a
be witnessed by
second order environment
ne lambda terms
realizability set a
n 2 x
free resource variables
set a over
is a realizability
be a bll
a bll formula
a over x
is computable in
a second order
from x to
x is positive
e is polytime
most x is
ne lambda term
of resource variables
realizability sets over
the realizability set
a f e
computable in time
of dyadic lists
may be witnessed
witnessed by e
polynomial time computation
set of resource
e is computable
light linear logic
is positive in
p in a
at most x
x to y
n x n
f n n
a morphism from
we notice that
to a functor
are a ne
n p x
of resource polynomials
e witnesses f
positive in t
second order variable
order environment over
syntax of bll
morphism f n
from n x
tally natural numbers
a sequent a
be a realizability
is a monoidal
environment over x
a morphism over
that e is
x is a
x be a
is witnessed by
over x is
order variable of
of a sequent
a ne linear
be a morphism
morphism from a
second order variables
a morphism f
an a ne
a be a
proof of a
let be a
n x to
the forgetful functor
over x the
function f n
extends to a
e x y
a 1 a
t x 0
let a be
is a second
x y t
that x is
p x and
let x be
a a is
in a is
a is a
x is defined
polytime computable in
a realizability model
occurrence of resource
define a realizability
the categories b
x xy x
increasing polynomial time
a ne variant
over and let
some useful examples
type of dyadic
categorical structure to
valuations over x
resource polynomial q
a set theoretic
write a substitution
and morphisms between
functions representable in
appropriate categorical structure
a function e
of bll which
have the appropriate
bll formula with
lambda terms we
environment over y
that is polytime
resp see 3
sequent a 1
bll in terms
6 2 of
higher type primitive
x n p
iteration lemma for
inductive constructions 2
resource polynomial p
homologous p in
possibly containing the
theorem 4 21
in n moreover
of inductive constructions
u indexed products
by e y
realizability set n
each i p
of tally natural
the algorithm e
a functor from
linear logic bll
programs and computational
a the homologous
linear logic characterizing
our ambient set
of resource polynomial
categories b x
calculus of inductive
n n that
e v x
an untyped lambda
resource variables in
n n this
a is such
p p x
x set is
over x of
realizability sets must
xy x xy
size increasing polynomial
classes by higher
sets definition 4
if y occurs
are some useful
cf lemma 6
dyadic lists of
t let z
can be witnessed
of bll are
variant of bll
x y yx
the appropriate categorical
realizability sets definition
representing zero and
and non size
e y x
polynomial q and
occurs positively in
and a realizability
over y we
by higher type
is defined t
resource variables from
the homologous p
between realizability sets
morphism from n
a resource polynomial
sets over x
type primitive recursive
formalize the entire
of the bll
is polytime computable
a is witnessed

corpus/krapavin2000-test/1013817.txt
hull
convex
inplace
situ
hulls
graham
chan
planar
clockwise
vertices
3n
nding
rst
sorting
seidel
scan
median
vertex
log
bridge
kirkpatrick
slope
insitu
lexicographic
megiddo
recurses
pq
merging
array
recurse
cient
paired
place
round
leftmost
abscissa
partitioning
fpg
nd
stable
2d
discarded
geometry
storage
swaps
unprocessed
tangent
stack
mergesort
recaps
yap
ham
csy
candidates
sort
ultimate
recomputing
sorted
jarvis
leftward
carleton
comparisons
bottommost
recompute
grouping
dual
mcgill
snoeyink
maximal
tests
fqg
slopes
signs
dimensions
computes
partition
implementable
ks
topmost
rounds
polar
beginning
js
jsj
extra
modications
separated
stored
nal
brute
swap
245
school
modication
consecutively
trick
intersection
lp
duality
consecutive
lines
shuing
5b6
sandwich
jiaconog
fmorin
engi
explicity
katajainen
fhbr
d3n
algorithmxs
gra
jyrki
neering
sirakov
danish
godfried
treesort
9801749
piercings
morrisong
k1s
shamos
diku
smoothsort
klee
marily
colonel
council
rightmost
pseudo
runs
shifts
groups
opt
care
favourably
horowitz
vahrenhold
undiscarded
wenger
cgm
paritioning
nikolay
metrotech
copenhagen
herv
tangents
brnnimann
unpaired
intersecting
half
concatenation
solves
running
radially
ottawa
pri
endpoints
sorts
fig
4e
1125
bhattacharya
ordinate
brooklyn
dk
11201
indices
phrased
polytechnic
1972
cis
polytopes
voronoi
sized
dierent
probably
maximality
postprocessing
reordered
programming
movement
constants
cs
2n
resp
identi
collinear
farthest
medians
sensitive
convince
referee
randomized
odd
325
download
primal
convex hull
hull of
the convex
in situ
in place
upper hull
convex hulls
graham inplace
n log
hull algorithm
log h
inplace hull
h time
lower hull
o n
planar convex
in o
right turn
g i
of s
graham s
linear time
log n
in clockwise
clockwise order
space e
the upper
s 0
upper bridge
inplace scan
linear programming
the rst
round i
of graham
of chan
2d linear
to graham
inplace sort
hull candidates
lower convex
3n 4
turn tests
hull computes
programming problem
e cient
n time
hull is
hull algorithms
hull the
s 1
an in
place sorting
kirkpatrick and
median nding
and seidel
s scan
hull vertices
chan s
n points
s algorithm
maximal elements
the array
the algorithm
cient algorithms
o 1
hulls of
computational geometry
in linear
s into
sets s
input points
recurse z
z recurse
place implementation
seidel s
insitu hull
recurses on
z output
situ and
output hull
situ algorithms
of g
running time
time algorithm
vertices of
1 additional
using o
computes the
additional memory
array s
hull figure
s i
and s
o log
additional storage
practical in
where h
the points
time using
runs in
0 s
point set
place and
candidates z
stable merging
order beginning
bridge problem
median slope
slope in
chan inplace
separated 2d
abscissa x
slope s
computing convex
seidel 21
median abscissa
elements problem
hull z
storage used
points in
sorting and
upper or
space efficient
original algorithm
s 2
x 0
of convex
hull can
four space
place algorithms
output sensitive
place algorithm
hulls in
n additional
of recomputing
hull are
n g
call to
right of
for planar
of vertices
the line
s h
is on
h 1
n right
scan to
h is
the leftmost
the stack
the solution
an o
fpg and
storage where
end result
or lower
constants in
comparisons and
rst half
sorting in
for computing
of lines
one call
point p
algorithm then
l 0
only o
the partitioning
on l
set s
the vertices
we nd
all points
the running
a point
order at
the lines
the constants
the pairs
to partition
algorithm is
inplace lp
leftmost vertex
no lexicographic
h vertices
extra storage
and recurses
swaps to
opt graham
lp 2d
z move
log there
hulls convex
not above
3n h
ultimate planar
describe four
1 leftward
ultimate algorithm
turn test
the convex hull
convex hull of
hull of s
o n log
n log h
on the convex
log h time
the upper hull
in o n
space e cient
graham inplace hull
convex hull algorithm
of the convex
hull of g
in clockwise order
upper hull of
computes the convex
planar convex hull
an in place
the upper bridge
graham inplace scan
linear programming problem
s 0 s
n log n
0 s 1
right turn tests
sets s 0
hull computes the
2d linear programming
log n time
convex hull algorithms
of n points
in linear time
hull of a
point of s
planar convex hulls
kirkpatrick and seidel
to graham inplace
n g i
in place sorting
call to graham
lower convex hull
and s 2
vertices of the
e cient algorithms
points of s
hull of n
o 1 additional
of the array
where h is
the array s
in place and
runs in o
on the upper
1 and s
time in place
convex hulls of
practical in place
of graham s
in situ and
inplace hull computes
lower hull of
output hull figure
graham s scan
lower hull candidates
h time in
the lower convex
of chan s
chan s algorithm
in situ algorithms
is in place
in place implementation
z output hull
z recurse z
s 1 and
n points in
an o n
algorithm for planar
points in o
h is the
is on the
the input points
the maximal elements
o log n
number of vertices
the upper or
of vertices of
and s 1
or lower hull
computing convex hulls
convex hull the
abscissa x 0
place implementation of
1 additional memory
clockwise order at
computes the upper
of planar convex
upper bridge problem
n time using
the 2d linear
place sorting algorithm
additional storage where
convex hulls in
and seidel 21
seidel s algorithm
storage where h
implementation of graham
separated 2d linear
maximal elements problem
right of x
time using o
chan inplace hull
convex hull vertices
scan to compute
cost of recomputing
of graham inplace
median abscissa x
and three dimensions
hull candidates z
n right turn
log n additional
upper or lower
hull of the
the constants in
algorithms for computing
the algorithm then
of s is
of s 0
elements of s
in two and
in place algorithms
using o 1
that the convex
computing the convex
computing the upper
hull can be
in place algorithm
s h 1
linear programming in
convex hull are
of x 0
of the upper
n time and
of s that
end result is
of s into
is the convex
one call to
of s and
running time of
time algorithm for
is the upper
the rst half
the end result
the running time
that s 0
the sets s
log n 1
beginning of the
the solution to
the linear programming
and runs in
for computing the
two and three
of the algorithm
done in o
the line of
constants in the
the original algorithm
linear time algorithm
at the beginning
solution to the
in the rst
the vertices of
appear on the
the second half
the resulting algorithm
s that are
the last element
set of n
is the index
result is the
algorithm megiddo inplace
sampling in computational
array s and
log n levels
and recurses on
partitioning in linear
o g i
inplace hull theorem
right turn test
hull algorithms in
or more s
o n right
recurses on s
convex hull vertex
to implement each
call the convex
the hull vertices
the separated 2d

corpus/krapavin2000-test/1013820.txt
mts
mix
elgamal
voting
voters
authorities
voter
ballot
jury
tally
ballots
honest
cgs97
bulletin
secret
votes
encryption
authority
electronic
election
dkg
vote
parties
homomorphic
board
dishonest
protocol
cast
privacy
verifiable
ciphertexts
jurors
adversary
elections
public
secure
ben87
abe98
verifiability
by86
cf85
cryptosystem
sect
cramer
jakobsson
proposals
dex
disclose
ciphertext
hirt
cha81
sako
party
participants
permutation
cryptographic
2r
verifier
civil
abe
implied
overwhelming
private
receipt
nk
besides
mixing
communicational
verdict
mtss
hs00
posting
tallying
jak98
deliberate
publicly
diffie
security
channel
membership
hellman
schemes
proposal
posts
tallies
interactive
henceforth
unconditionally
anonymous
jointly
validity
shares
pi
concerning
encryptions
designated
servers
chaum
member
permute
randomization
insures
declared
phase
observers
hide
jak99
schoenmakers
conicyt
1981182
deliberations
jj99
dk00
kurosawa
fondap
discloses
eligibility
chile
gjkr99
juries
verification
committee
government
emitted
undesirable
robustness
desires
revealing
participant
relies
correctly
belongs
threshold
witness
succeeds
criminal
verifiers
wallet
fondecyt
onion
cipher
decrypting
logarithms
malicious
robust
pedersen
coalition
accompany
canceled
untraceable
matem
suffices
universally
gennaro
desmedt
cryptographically
hiding
dept
decryption
coerced
homomorphisms
disruption
universal
sized
formed
exceeds
permuted
provers
shuffle
multiparty
rsa
sell
drop
signatures
protocols
primes
securely
cryptosystems
authorized
ff
equality
lhs
verifying
nothing
tracing
networks
la
batches
her
breaking
letting
stress
completeness
scoring
proofs
negligible
judge
twelve
contradict
outputs
bulletin board
mix network
election scheme
electronic voting
each authority
our mts
basic mts
mix networks
the tally
the mix
mix phase
jury voting
the bulletin
voting schemes
the votes
elgamal encryption
work performed
verification phase
that implied
an elgamal
electronic election
dkg protocol
besides that
the voter
voting scheme
non interactive
anonymous channel
tally of
final tally
homomorphic encryption
voter s
the voters
in cgs97
authority during
encryption of
our basic
x l
on mix
zero knowledge
0 l
t h
interactive proof
verifier zero
by86 ben87
of voters
dishonest authorities
verifiable secret
the vote
elgamal ciphertexts
cf85 by86
honest verifier
declared valid
output phase
2r z
receipt free
l 6
z q
information concerning
security parameter
proof pi
the elgamal
of mix
the adversary
overwhelming probability
a voter
performed by
electronic jury
jointly generate
robust threshold
hirt and
the authorities
abe abe98
correctly formed
universal verifiability
of cramer
dex protocol
of abe
and sako
designated area
honest authorities
the dex
mix servers
of elgamal
elgamal cryptosystem
cramer et
of validity
implied by
an electronic
each l
authorities are
are honest
voters and
shares s
voting protocol
o nk
6 t
in sect
public key
phase is
the public
by honest
s protocol
party computation
m l
by each
the honest
the voting
a public
case t
the work
diffie hellman
by whether
2 s
elgamal re
vote tally
mts proposal
testing scheme
universally verifiable
scheme mts
a verdict
correctly emitted
henceforth refer
network proposals
on homomorphic
ballots are
proposal relies
by posting
communicational complexity
ballot elections
voting phase
sako s
their designated
ballot the
concerning electronic
emitted ballots
posting y
the dkg
jakobsson and
a bulletin
civil case
the jury
ballots besides
secret ballot
formed ballot
each voter
research concerning
efficient anonymous
public value
formed ballots
the mts
re encryption
knowledge proof
not declared
l 2r
the verification
k bit
sect 3
the computational
drop in
not t
any information
every l
belongs to
voter can
negligible probability
t 62
one desires
randomly permute
membership testing
a ballot
parallel lines
of parties
privacy of
valid then
be undesirable
a robust
protocol is
hide the
the protocol
l m
randomization and
for electronic
with overwhelming
the tracing
secure multi
ballots and
as proof
the correctly
to hide
s 0
o k
of knowledge
discrete logarithms
and permutation
permutation and
computational work
h belongs
fixed sequence
62 s
in case
the bulletin board
by each authority
our basic mts
electronic voting schemes
work performed by
the work performed
electronic election scheme
performed by each
the mix phase
that implied by
besides that implied
non interactive proof
the verification phase
that x l
tally of the
l 6 t
each authority during
proof of knowledge
l 2 s
honest verifier zero
authority during the
the final tally
cf85 by86 ben87
of the bulletin
verifier zero knowledge
2r z q
s 0 l
x l 6
on mix networks
in case t
for each l
designated area of
the dex protocol
or not t
hirt and sako
an elgamal encryption
cramer et al
electronic jury voting
of the votes
of elgamal ciphertexts
the tally of
during the mix
list of elgamal
order to hide
proof of validity
6 t for
voter s protocol
implied by whether
verification phase is
elgamal encryption of
the output phase
proposed in cgs97
z q and
information concerning the
each l 2
to hide the
for every l
a robust threshold
parallel lines of
secret ballot elections
zero knowledge proof
correctly formed ballots
jury voting protocol
t h belongs
correctly emitted ballots
to this non
by posting y
of the elgamal
is not declared
not t h
mix network proposals
concerning electronic voting
the voter s
this non interactive
for electronic voting
efficient anonymous channel
the elgamal cryptosystem
some information concerning
henceforth refer to
and sako s
the dkg protocol
we henceforth refer
testing scheme mts
by whether or
a bulletin board
succeeds in learning
ballots besides that
of cramer et
two parallel lines
elgamal re encryption
based on mix
proof as proof
randomization and permutation
s that x
research concerning electronic
of research concerning
membership testing scheme
of abe abe98
t 62 s
declared valid then
not declared valid
of t h
the computational work
knowledge proof of
re encryption of
interactive proof as
their designated area
mix phase and
l 2r z
t 2 s
a mix network
a non interactive
may be undesirable
the mix network
of our basic
of knowledge for
lines of research
t j l
secure multi party
case t 2
in the security
security parameter k
multi party computation
with overwhelming probability
of the mix
the correspondence between
sequence of integers
h belongs to
phase is not
belongs to s
fixed sequence of
the security parameter
phase is o
in order to
area of the
whether or not
mn n k
application to electronic
sake we review
basic mts proposal
all current proposals
anonymous channel and
and all nothing
log g y
case were only
in cf85 by86
j l 2r
over runs over
is indeed of
both equalities in
on permutation networks
of hirt and
of equality of
of two parallel
publicly verifiable secret
that all current
independence efficiently and
interactive proof that
k per voter
protocol is linear
an efficient procedure
for non cryptographic
in learning some
a simple publicly
sharing scheme and
o k per
of correctly emitted
subgroup g q
tallying the votes
observers proofs of
this suffices for
schemes disclose the
equalities in 1
the first electronic
fondap in applied
with unconditionally secret
a new multiple
proof sketch by
a modular multiplication
all nothing election
every l and
any additional information
multiparty unconditionally secure
current proposals for
simple publicly verifiable
work is proportional
concerning the tally
public value y
information concerning t
jakobsson and desmedt
the case were
l for an
pre specified set
voters varies the
jury voting scheme
proofs of partial
between the voters
mathematics 1999 2000
are honest the
indeed a valid

corpus/krapavin2000-test/1013843.txt
exposure
sensors
sensor
deployment
target
exposed
deployed
unauthorized
deploying
obstacles
region
fusion
energy
detection
east
alarm
grid
west
targets
010
emitted
periphery
detecting
lep
monitored
erent
activities
dijkstra
traversing
chapter
fictitious
040
speed
060
path
travels
050
speeds
obstacle
030
noise
deployments
segment
sensing
di
traveling
false
coverage
probability
field
density
traversal
alarms
surveillance
deploy
activity
weight
paths
signal
intensity
coe
020
decision
placement
south
measured
idling
collaborate
north
detect
threshold
collaborative
probabilistic
exposures
likelihood
distance
tradeo
cient
detections
detectability
mum
decay
collaboration
cumulative
segments
cd
decays
490
fault
energies
emits
weights
chi
network
varying
000
minimizes
confidence
networks
mini
profile
detected
530
grids
90
probabilities
shape
ciently
gaussian
420
shortest
position
monitoring
maximize
wireless
ut
fine
attempts
ective
hour
er
simulator
log
reached
reaching
240
highlighted
horizontally
finding
presence
investigates
freedom
desired
simulations
formulation
square
simulation
450
cs
formulated
peer
connecting
tolerant
fx
crossing
goodness
randomly
926
mlogn
4480
posure
weight1
breach
073
970
2440
8944
070
agriculture
9number
100100300500700cost
3544
obstruct
10080120160200cost
peripheries
seconds
corrupted
crosses
develops
vertices
analytical
hoc
traverses
80
tolerance
travel
closest
5443
053
website
civil
crease
tar
931
pollution
divider
covered
84
finer
cients
intersecting
cross
achievable
su
ect
measurement
location
012
ery
servations
minimum exposure
least exposed
the sensors
exposed path
of sensors
the region
the sensor
the target
exposure of
sensors deployed
detection probability
a target
the exposure
sensor field
decision fusion
deployment is
false alarm
exposure is
of deployment
the energy
target is
detecting unauthorized
unauthorized activities
activities using
sensor network
emitted by
the least
sensor deployment
alarm probability
a sensor
target detection
constant speed
sensor networks
sensors are
the detection
energy measured
value fusion
when deploying
this chapter
di erent
variable speed
of exposure
the deployment
the minimum
sensors at
sensors is
dijkstra s
desired exposure
energy emitted
path exposure
of obstacles
west east
point u
measured by
of detecting
d u
of sensor
sensors to
detecting a
sensors can
sensors the
n sensors
e d
be deployed
deployed the
region monitored
exposure in
deploying sensors
target activities
exposure e
010 010
probabilistic exposure
exposure for
sensors and
the obstacles
for target
target and
the false
expected cost
obstacles are
sensors have
deployment of
grid point
are deployed
a region
of deploying
a deployment
target that
speed targets
unauthorized traversal
to east
target travels
deployed at
one sensor
deployment strategy
west to
cost of
the probability
path p
finding the
the cost
detection algorithms
the path
path for
g p
the obstacle
the west
the grid
deployment the
deployment region
sensor at
alarm and
target in
probability of
a path
line segment
possible paths
log g
least exposure
unauthorized traversing
sensing range
from west
monitored region
exposed paths
travels along
deploying one
exposure level
target traveling
lep west
exposure when
monitored deployment
for deployment
region nodes
detection attempt
traveling at
not detecting
detection attempts
target activity
of target
the noise
of interest
and detection
the distance
and decision
signal emitted
false alarms
detection performance
deploying the
speed problem
this grid
weight path
sensor placement
assumed to
s algorithm
probability is
the threshold
for varying
to detect
find the
distance from
a desired
grid points
varying number
sensor nodes
of targets
the periphery
each sensor
the east
is above
detecting the
weight of
is developed
path is
target to
obstacles in
distributed detection
three di
to deploy
each grid
the signal
path the
grid size
be monitored
deployment in
is assumed
exposure density
sensors randomly
fictitious point
detection level
sensors this
multiple speed
lep for
a fictitious
m sensors
east west
signal intensity
namely value
detecting sensors
when obstacles
exposure has
least exposed path
number of sensors
the least exposed
the minimum exposure
the sensor field
of sensors deployed
using a sensor
in the region
detecting unauthorized activities
unauthorized activities using
activities using a
by the sensors
a sensor network
false alarm probability
emitted by the
the exposure of
the detection probability
by the target
the target is
the false alarm
measured by the
minimum exposure of
presence of obstacles
energy measured by
detecting a target
the energy emitted
energy emitted by
exposed path for
minimum exposure is
dijkstra s algorithm
of the target
of sensors to
cost of deployment
value and decision
and decision fusion
the desired exposure
for target detection
of the region
the target and
point of interest
a target is
and the sensor
find the least
the cost of
when deploying sensors
of minimum exposure
alarm and detection
log g p
detection probability of
target is assumed
alarm probability is
false alarm and
one sensor at
exposure of the
the energy measured
sensor at a
of a target
figure 1 4
finding the least
of the sensor
of the sensors
to find the
target and the
cost of deploying
the deployment is
minimum exposure in
least exposed paths
the least exposure
to each grid
of deployment is
weight of 0
distribution of minimum
of not detecting
deploying one sensor
desired exposure is
deployment region nodes
a constant speed
signal emitted by
the sensors can
sensors have a
the target travels
sensors deployed the
region monitored deployment
and detection probability
exposure e d
west to east
a target in
lep west east
a target traveling
deployment is to
log m l
networks for target
the signal emitted
sensors are deployed
monitored deployment region
sensor networks for
at every step
of the least
each grid point
of the distance
exposure of a
grid point on
obstacles in the
have a value
the sensors the
sensors can be
for varying number
d v u
of detecting the
to be deployed
between the target
region to be
in this chapter
d d u
is assumed to
varying number of
to be monitored
of detecting a
that the sensors
the sensors are
a weight of
from the target
the presence of
distance from the
the region in
above the threshold
three di erent
target in the
that the minimum
in the sensor
at a constant
the distance from
to evaluate the
region of interest
probability that the
position of target
sensors it is
from west to
a region to
collaborative target detection
of deploying the
a fictitious point
the net probability
when obstacles are
path exposure is
that minimizes log
probability of detecting
detected at any
find the path
figure 1 6
detecting the target
sensors deployed in
the west east
minimum exposure e
detection probability d
the target increases
the probabilistic exposure
sensors is above
by a target
detection probability is
net probability of
the sensors as
deployed in each
point u p
east figure 1
variable speed targets
west east figure
not detecting a
deploying sensors randomly
target to the
of detecting sensors
the sensors this
on the energy
sensors minimum exposure
cost assignment is
tolerance in collaborative
west east unauthorized
the dijkstra s
minimum exposure for
of exposure for
a target that
traversing the region
the region from
figure 1 9
figure 1 7
any point u
cover the region
line s i
on this grid
minimum exposure density
exposure is above
sensors at every
distributed sensor networks
minimizes log g
1 d u
erent target activities
1 expected cost
a value above
the monitored region
sensors deployed at

corpus/krapavin2000-test/1013859.txt
beta
lattices
pv
lattice
quasicrystals
tiling
delaunay
tiles
meyer
crystallographic
integers
symmetry
tilings
rotations
plane
cyclotomic
crystals
rotational
pisot
tile
rotation
law
algebraic
quasiperiodic
laws
distributive
asymptotic
quadratic
ring
additive
expansion
multiplication
asymptotically
multiplicative
translations
counting
bravais
crystallography
quasicrystallographic
vijayaraghavan
parry
galois
quadrilateral
rotationally
group
crystal
conjugate
decorated
periodic
abelian
elementary
cos
artin
recurrence
invariant
freely
decoration
pentagonal
penrose
schreier
fold
behaviour
actions
invertible
associative
conjugates
isometries
internal
shall
substitution
arithmetics
groups
appendix
self
denser
proposition
action
semi
translational
alphabet
units
eventually
regime
sl
joining
generically
ordinary
vertices
similarity
ls
symmetries
leaving
equivalently
endowed
operators
distortion
ss
isomorphic
integer
assert
thinking
canonical
contraction
rings
composition
quasimultiplicative
distorts
z0
nombres
imitating
quasiadditive
quasicrystalline
bieberbach
conjugation
quasicrystal
arithmetically
myampersandbgr
dodecagonal
reexpressed
decagonal
harmonique
motives
5with
consequence
ll
ball
horizontal
deduced
inversion
mathematical
cited
sgn
moduli
aperiodicity
superpositions
perron
packings
imitation
decorate
potentiality
historically
noncommutative
618
zeros
letters
axis
acting
infinitely
said
hopeless
game
z
infinite
bertrand
idealization
indi
dense
behaves
displayed
duals
equip
golden
easiest
recover
article
aperiodic
endow
hexagonal
plication
salem
delicate
eligible
richness
radius
kind
adapted
q2
orbit
erently
18th
realm
compatible
digit
tempting
ergodic
trivially
bm
inclusions
deformed
classical
spheres
merit
symmetrical
striking
countable
1985
origin
rotates
ered
digits
beta integers
beta lattices
of beta
lattice 1
the beta
beta lattice
quadratic pv
delaunay set
the lattice
beta expansion
for beta
b n
pv number
point sets
lattices in
symmetry group
case 2
group for
pv unit
plane group
a tiling
distributive with
meyer sets
a delaunay
on 1
case 1
pv units
rotational properties
a meyer
meyer set
plane groups
z z
the plane
in case
of 1
s n
a quadratic
r d
additive and
group of
eventually periodic
internal laws
point group
on beta
beta integer
algebraic integer
conjugate is
a pv
asymptotic behaviour
freely generated
a beta
and multiplicative
is solution
r q
semi direct
u q
2 cos
rotationally invariant
tiling of
counting function
self similarity
the law
r n
z is
the tiles
function s
direct product
symmetry of
mathematical quasicrystals
for invertible
canonical alphabet
and beta
tilings and
counting system
the quasicrystallographic
its trivial
delaunay sets
for quasicrystals
like lattices
multiplicative properties
quasicrystallographic numbers
rotation actions
quadrilateral tile
adapted rotations
not rotationally
bravais lattices
elementary quadrilateral
trivial tiling
invertible operators
and lattices
pisot vijayaraghavan
this tiling
rotations and
the rotation
expansion of
set z
t z
joining points
n fold
lattices 1
a crystal
direction defined
symmetry plane
abelian group
action of
real numbers
defined on
a ring
q l
the substitution
q b
of order
with symmetry
points left
an abelian
group structure
law for
new internal
cos 2
lattices the
by q
the additive
point set
the counting
behaviour of
integers in
n z
the semi
we shall
is finite
sets based
proof case
lattices is
properties of
a plane
of letters
a integer
integers are
lattice for
and along
of rotations
integers as
by when
for instance
the action
number then
the algebraic
an algebraic
the present
number such
holds true
points along
in appendix
integers we
result proposition
lattices and
instance for
set r
of r
integers for
by joining
groups for
the asymptotic
appendix b
r 1
asymptotically like
tiles l
crystallography the
ordinary multiplication
counting systems
cyclotomic pv
ordered ring
quasicrystals the
crystallographic groups
translational properties
the decorated
artin schreier
lattice case
additive group
elementary tiles
observed quasicrystals
to beta
group structures
extended rotations
tiling obtained
is symmetry
crystallographic group
laws on
we trivially
given beta
all quadratic
two tiles
ls sl
tiling there
recurrence we
a crystallographic
fold bravais
quasiperiodic point
positive beta
crystallographic cases
of beta integers
the lattice 1
set of beta
of beta lattices
a delaunay set
of the lattice
distributive with respect
quadratic pv unit
of the beta
a quadratic pv
for beta lattices
group of 1
in case 2
the beta expansion
beta lattice 1
the beta lattice
beta lattices in
a meyer set
quadratic pv units
additive and multiplicative
in case 1
in the plane
lattices in the
is a quadratic
z z z
beta expansion of
rotational properties of
a plane group
counting function s
the counting function
group for the
a pv number
by q l
is a meyer
q b n
asymptotic behaviour of
symmetry group of
1 r n
of r d
symmetry of order
semi direct product
is solution of
the action of
the set z
its trivial tiling
together with q
beta integers as
direction defined by
b n z
point sets based
on beta integers
the asymptotic behaviour
1 is eventually
on 1 by
is eventually periodic
the direction defined
the canonical alphabet
joining points along
a tiling of
new internal laws
and its trivial
with symmetry of
beta lattices is
expansion of 1
points left and
based on beta
rotations and beta
beta integers for
for invertible operators
freely generated by
not rotationally invariant
multiplicative properties of
is a pv
conjugate is 1
and multiplicative properties
defined on 1
not a integer
a beta lattice
n 2 1
have for invertible
axis and along
tiling of the
the quasicrystallographic numbers
d 1 is
2 cos 2
direct product of
is the semi
r n 2
an abelian group
left and its
point sets and
the semi direct
r d is
the new internal
number of letters
by joining points
symmetry group for
of 1 is
number such that
of 1 we
along the horizontal
case 2 we
and along the
horizontal axis and
for instance for
proof case 1
sets based on
points along the
a point set
along the direction
are defined on
said to be
addition and multiplication
case 1 the
0 r 1
1 in case
is said to
the horizontal axis
if is a
of order n
an element of
a real number
beta lattices the
the positive beta
with a tiling
that every ball
of tiles s
tilings and lattices
r contains at
definition of multiplication
of this tiling
point group for
for the law
invertible operators when
positive beta integers
build the point
thinking about at
the substitution is
point group of
u q are
recall that from
radius r contains
w 1 by
exists k z
elementary quadrilateral tile
algebraic integer 1
galois conjugate is
rotation operator r
lattices in r
following operators are
recover the definition
plane groups for
with an abelian
the point group
point set which
operators when we
becomes distributive with
numbers and and
group for beta
can equivalently say
that is solution
operators are defined
that a beta
be a delaunay
class of beta
all quadratic pv
beta integers are
beta expansion which
periodic tilings and
or by b
pv unit of
are not rotationally
the values assumed
set z is
we can equivalently
groups for beta
tiling obtained by
kind is such
quasiperiodic point sets
the beta integers
2 n fold
beta lattices are
its conjugate is
a crystallographic group
are the positive
beta rotations and
n either by
the tiles are
say that every
a choice becomes
bravais lattices in
recurrence we have
in asymptotic regime
operator r 1
tiles of the
pv number such
either by or
beta integers in
that z z
q are defined

corpus/krapavin2000-test/1014075.txt
pseudopredicates
formulas
mining
extents
miner
pseudoformulas
food
pseudopredicate
foxsports
pseudoformula
chaining
predicates
beverly
espn
scores
pagerank
query
head
importance
glen
frequent
itemsets
formula
stanford
steve
conjoining
substructures
predicate
simrank
studentb
studentc
queries
web
association
similarity
com
students
prof2
indian
objects
advisor
pages
chinese
datalog
likes
undergrads
prof1
studenta
dopredicates
pseudopredi
mlb
student
hits
home
mine
cates
enormous
nexus
masters
hubs
pseu
authorities
citation
blocks
someone
went
relationships
jennifer
explanations
dangling
precomputation
notions
univ
singleton
analyses
posed
ranking
members
apriori
people
undergrad
iit
importances
molfea
satisfied
extent
database
jing
qi
appearing
personalized
depth
inductive
building
arguments
mulas
goethals
nonuniformly
pointed
preferences
hector
interrelationships
schools
sriram
prompt
advisors
bussche
discovery
178
subtree
pseudo
club
hyperlinked
bart
authoritative
uc
jects
ranked
score
attributes
identifying
relational
argument
publications
professors
says
analogues
basket
challenge
den
chain
molecular
cliques
renamed
eleventh
manageable
pose
publication
sources
analogously
xml
sole
forest
person
rules
utility
ourselves
berkeley
fragment
expanded
predefined
logic
deeper
recursive
iteratively
databases
explanation
enabled
sigkdd
who
feasibility
summing
chris
precomputed
edges
edge
superset
chicago
72
intersection
deemed
append
brian
renaming
conjunctions
satisfies
returned
riety
dbpubs
oformula
2353
pseudopred
1854
legibility
djoko
74197
peo
clubnexus
india
surnjani
2852
intelligibility
2244
aidong
eveline
interlinking
gspan
deemphasized
madras
2469
f miner
e p
set argument
important formulas
their extents
p k
foxsports com
of pseudopredicates
property mining
pseudopredicates and
importance scores
head pseudopredicates
data mining
query types
espn com
frequent itemsets
building blocks
a pseudopredicate
satisfied by
in f
association rules
p a
of formulas
head variable
frequent substructures
formulas that
of importance
the formulas
g i
be constructed
for mining
mining the
experimental system
the formula
our framework
the importance
the space
graph properties
database group
set arguments
objects input
basic building
importance of
of properties
space of
most important
similar objects
the query
formula f
all formulas
query space
formulas and
pointed to
web pages
g f
miner system
8 user
someone who
the pseudoformula
the pagerank
computing importance
pseudoformulas and
indian food
enormous size
pagerank 20
in common
predicate p
most similar
formulas are
formulas can
the framework
the extents
not appearing
7 user
base set
f is
s e
the enormous
head predicate
of graph
predicates in
the f
a s
the web
web search
of head
to by
by s
the objects
good authorities
com espn
chaining f
formulas corresponding
miner experimental
studenta studentb
mining framework
of pseudoformulas
pseudo formula
pseu dopredicates
important pseudopredicates
a pseudoformula
intersection closure
user 178
formula g
and hits
16 algorithms
all point
by chaining
pseudopredicate is
mlb com
from california
went to
some formulas
likes chinese
as undergrads
hits 16
the pseudopredicates
and conjoining
pseudopredi cates
of chaining
formula h
41 user
posed on
predicates satisfied
f and
of objects
query for
query results
computational resources
data set
a formula
data sets
p i
traditional data
blocks for
similar because
1 predicate
depth at
letters to
chaining and
formulas from
formulas this
co citation
6 41
the property
tree structures
from p
which satisfy
k e
extents of
personalized web
and feasibility
mining queries
other students
satisfying assignment
graph data
some predefined
our experiments
look for
a graph
constructed from
formulas in
21 7
enabled by
be posed
mining frequent
and g
we develop
the predicates
existing systems
graph structures
with head
not supported
scores are
of datalog
in g
properties as
objects which
objects in
of property
class objects
utility and
those sets
variable a
the set
formulas is
as first
work well
knowledge discovery
extent of
the user
u i
important if
formulas which
a labeled
formulas as
important aspects
p s
from which
importance for
e p k
p a s
and their extents
the space of
the f miner
space of properties
can be constructed
satisfied by s
basic building blocks
formulas that can
most similar objects
similar objects input
most important formulas
e p i
the most important
the query space
pointed to by
formulas can be
of the formulas
importance of the
for mining the
s e p
the enormous size
objects which satisfy
enormous size of
f miner system
traditional data mining
head variable a
the formulas that
of graph properties
k e p
of head pseudopredicates
space of graph
p k e
the set of
f and g
the importance of
g f is
of all formulas
and e p
building blocks for
of e p
e p a
only the most
set of all
a formula f
20 and hits
in f miner
pagerank 20 and
6 41 user
letters to denote
utility and feasibility
be posed on
formulas corresponding to
miner experimental system
personalized web search
most important pseudopredicates
set of pseudopredicates
satisfying assignment a
f miner experimental
the pagerank 20
the property mining
chaining and conjoining
all formulas and
the domain we
base set of
head pseudopredicates and
of the pseudopredicates
objects in u
similar because they
the intersection closure
with head variable
intersection closure of
closure of e
hits 16 algorithms
query results for
property mining framework
the importance scores
predicates satisfied by
represents the property
a pseudo formula
formulas and their
a set argument
predicates in f
not supported by
and hits 16
of property mining
pseudopredicates and their
of basic building
the head variable
the base set
all point to
mining the space
set of objects
section 2 2
in our framework
discussed in section
of the framework
of importance for
have in common
because they are
be constructed from
in data mining
to work well
is important if
predicate p a
as first class
in our experiments
of the query
on knowledge discovery
v for which
the query results
first class objects
association rules of
in the f
which satisfy the
the extent of
as a graph
p k and
in f and
p k 1
the set p
of the domain
to be the
in g i
set of formulas
that can be
be constructed by
shown in figure
set of head
relational association rules
a foxsports com
patterns and relations
important by the
two query types
work well empirically
lot in common
studentb and studentc
uc berkeley stanford
web search the
call to chain
21 7 user
who likes chinese
the properties themselves
of all head
a espn com
importance scores are
satisfies e a
set of pseudoformulas
although they can
data mining we
user 98 user
computing importance on
substructures from graph
someone who knows
the database group
look for important
are both pointed
results for uc
of datalog 23
frequent substructures from
set p k
they all know
of the extents
g i renamed
7 user 98
notions in data
both pointed to
1 predicate pseudoformulas
of f miner
8 user 9
a pseudopredicate is
graph properties a
and studentc are
analogues in the
its set argument
construct formulas from
pseudopredicates satisfied by
from graph data
its head predicates
foxsports com espn
or espn com
in common this
students are related
pseu dopredicates p
computed importance of
foxsports com satisfies
not appearing anywhere
of computing importance
what the objects
5 the set
related because they
database group survey
in a forest
and formulas are
the computed importance
of formulas that
analyses have been
specific measures of
set argument is

corpus/krapavin2000-test/1014532.txt
global1
ioa
automaton
ballot
daikon
invariants
paxos
chooseval
cons
interpreter
consensus
assignval
internaldecide
specication
lp
automata
verication
actions
abstain
init
makeballot
inv6
ndr
ballots
prover
toolkit
thenodes
simulation
internal
executions
paired
larch
action
detector
val
vote
nondeterminism
eort
voted
inv3
suite
purported
od
methodology
quorums
invariant
inv1
lemmas
verifying
human
lockstep
witness
scripts
block
forward
failed
unsound
proofs
veried
provers
correctness
behaviors
simulated
inv4
inv2
dilsun
abstained
lsl
inv5
aballot
ecgn01
mocha
tlc
kcd
fail
nite
imple
mentation
corrected
specications
succeeded
signature
decide
guidance
veri
proving
ignore
execution
smv
prelude
supply
assist
traces
tomata
correspondence
formulating
dead
discover
toolset
denition
dynamically
se
auxiliary
unexpected
tools
trace
checking
departures
reveal
external
pre
checked
transition
specializing
resume
bookkeeping
initiated
fragment
checks
speci
reported
validity
provable
nil
nd
legal
eects
automating
au
formal
prz01
peppered
explicating
pll00
lengthier
rintanen
falsied
ly01
lt89
prompting
solidify
gl98
ghg
abstaining
ne02
gsv01
lam98
bog01
ahm
multisorted
reies
veriers
cutions
ioa2lsl
buttress
ecutions
imaginative
parliament
rin00
inductiveness
reporting
attempting
node
organizing
deductive
assistance
existential
transitions
style
program
soundness
denes
detected
freeing
gg91
asml
transcription
eters
investing
approval
lyn96
hindrance
automates
rst
examining
imperative
reachable
candidate
innite
cope
detection
implements
programmers
succeed
simulates
theories
obscuring
axiomatize
fate
postulate
the ioa
simulation relation
i node
b ballot
v value
proof block
ioa interpreter
o automaton
forward simulation
the automaton
level automaton
simulated execution
decide i
output decide
init i
the interpreter
for internal
input fail
in ioa
ioa toolkit
fail i
step correspondence
i re
dynamic invariant
invariant detector
internal chooseval
automaton global1
automaton cons
ignore for
specication automaton
i o
start state
the specication
ioa language
a ballot
reported properties
internal actions
test suite
i v
paxos algorithm
consensus value
set ballot
paired execution
assignval b
ballot ignore
the paxos
machine checked
in global1
internaldecide b
input init
b pre
chooseval v
v pre
two automata
the proof
an automaton
theorem prover
case study
a proof
the purported
od for
of cons
daikon s
of correctness
invariant detection
to cons
the daikon
invariants and
automaton the
in verifying
execution can
do f
a specication
node v
node b
by daikon
internal internaldecide
re internal
abstain i
global1 succeeded
internal start
implementation automaton
l se
consensus the
invariants such
and inv6
checked proof
vote i
makeballot b
ballot v
ndr program
ballot in
global1 val
global1 to
internal assignval
from global1
actions of
consensus in
denition 1
program properties
the lp
simulation relations
verifying distributed
value do
execution fragment
v representing
the larch
value v
the simulation
is unsound
o automata
daikon invariant
of consensus
external actions
formal verication
our methodology
a forward
execution or
automaton model
cons the
the methodology
actions are
distributed algorithms
the consensus
imple mentation
b set
theorem provers
state systems
model checking
properties that
of automata
potential problems
an i
theorem proving
f i
nite state
b such
execution based
a machine
the test
executions and
block in
automaton is
and internaldecide
inv4 and
signature input
invariants inv1
predicate relating
b val
failed failed
assignval and
human guidance
candidate simulation
chooseval global1
value internal
ndr programs
decide action
via simulated
start thenodes
daikon reported
ballot do
human eort
the decide
machine veried
satises property
imperative style
node init
value output
detected invariants
global1 with
global1 the
simulates execution
lp proof
daikon provide
purported simulation
block contains
larch prover
1 specication
re chooseval
interpreter simulates
re output
and vote
re input
in cons
automaton paxos
such bookkeeping
global1 allows
execution provides
v od
internal makeballot
internal vote
abstain and
using lp
makeballot abstain
fully characterizes
veried proof
auxiliary invariants
the ndr
val b
internal abstain
the ioa interpreter
i o automaton
the simulation relation
node v value
the proof block
f i re
the ioa toolkit
i node v
output decide i
input fail i
forward simulation relation
the ioa language
of the automaton
the paxos algorithm
ignore for internal
a simulation relation
the specication automaton
decide i v
init i v
do f i
i node b
input init i
ballot ignore for
the test suite
a forward simulation
our case study
dynamic invariant detection
of b such
an i o
internal chooseval v
v representing the
in the ioa
decide i node
ballot v value
v value do
internal assignval b
machine checked proof
of the paxos
i re internal
internaldecide b ballot
b set ballot
init i node
e l se
a machine checked
from global1 to
internal internaldecide b
global1 to cons
simulation relation is
node b set
reported properties are
fail i node
that the purported
b ballot v
invariants such as
re internal chooseval
o automaton model
assignval b ballot
ioa language and
o automata and
correctness of an
the reported properties
verifying distributed algorithms
the start state
the daikon invariant
daikon invariant detector
i o automata
a theorem prover
b such that
that f a
of an implementation
proof of correctness
a distributed algorithm
actions of the
proof that the
chooseval global1 val
else f i
node init i
invariants and simulation
b ballot ignore
ioa interpreter the
the internal actions
how to cope
prelude to formal
simulates execution of
v od for
high level automaton
that value must
a predicate relating
consensus in ioa
automata in ioa
abstain i node
vote i node
low level automaton
pre output decide
daikon s output
the decide action
simulation relation and
implementation of consensus
machine veried proof
i re input
v value internal
invariants and lemmas
and that value
b pre internal
an input action
of two automata
the automaton global1
b ballot do
checked proof of
signature input fail
fail i failed
makeballot b ballot
the implementation automaton
re output decide
simulation relation from
simulated execution can
style as a
i v representing
purported simulation relation
to a specication
the larch prover
and simulation relations
can reveal unexpected
as a prelude
fully characterizes the
automaton cons the
dynamically detected invariants
ballot in global1
interpreter simulates execution
implementation automaton the
the purported simulation
ioa toolkit the
for the init
value output decide
paired execution provides
inv4 and inv6
formulating and checking
cons figure 1
simulated execution to
v value output
of this invariant
an imperative style
the automaton s
proof block the
the consensus value
for internal internaldecide
in formulating and
do e l
val b val
proof block in
internal makeballot b
i v od
failed failed i
input actions are
of consensus in
internal chooseval global1
makeballot abstain and
assignval and internaldecide
the automaton cons
a step correspondence
set ballot ignore
reported properties may
suite fully characterizes
simulation relation in
global1 val b
preserve the simulation
via simulated execution
se else f
l se else
lp proof that
the lp proof
i node init
resume by specializing
the ioa simulator
relation satises property
internal start thenodes
internal abstain i
value do f
in ioa the
test suite fully
step in verifying
execution based techniques
i b pre
value must have
action with the
abstain and vote
what a human
internal vote i
o automaton is
candidate simulation relation
i failed failed
the for statements
for internal assignval
i v pre
the witness execution
node b ballot
simulation relation satises
we did not
f a b
of the implementation

corpus/krapavin2000-test/1014970.txt
primal
dual
routers
byers
lps
lp
feasible
router
connections
flow
agents
ln
bartal
raz
xl
rounds
nm
approximation
luby
opt
makers
yl
feasibility
connection
agent
nisan
phase
od
iteration
inequality
sequential
monotonically
amax
polylogarithmic
papadimitriou
claims
ratio
tradeo
claim
optimum
centralized
precondition
yannakakis
technion
solutions
phases
normalized
israel
ect
neighbors
logarithmic
serial
globally
azar
distributively
initialize
iterations
policies
completes
packing
ij
awerbuch
transmits
convert
rates
message
intermediate
round
repeatedly
network
amin
multicommodity
objectives
running
administrator
atm
objective
final
quality
berkeley
fractional
capacities
competitive
broadcast
cs
duality
deadlock
polynomially
min
routes
corollary
lemma
yairb
formulative
huji
dorit
9416101
shmoys
accrues
intranetwork
9304722
sicomp
safe
trials
fairness
program
ciently
rate
initialization
routing
transformation
termination
programs
boston
binational
una
regulating
liated
recombine
hebrew
depiction
hochbaum
haifa
stated
il
share
substituting
pp
incident
ending
flows
bandwidth
clarifies
regulatory
inject
awaiting
jerusalem
associate
communicate
send
multiplicative
runs
instant
revenue
emulating
upcoming
tardos
35th
allocation
bounds
department
eliminates
terminates
danny
iq
ncr
panel
stimulating
subprogram
multiplying
fast
ac
dividing
throughput
karp
subprograms
informing
complicating
understandable
dick
ecting
unsatisfied
packet
passing
constituting
christos
plotkin
simplifications
act
working
cient
obtains
establishing
bottleneck
mentation
retransmissions
imple
erations
implemen
implementable
programming
scaled
settings
neighboring
violated
paying
complications
bu
subdivide
proving
positive linear
primal feasible
y j
flow control
approximation ratio
dual feasible
fast approximation
primal variables
ln m
byers and
d raz
y bartal
bartal j
positive lps
feasible solution
feasible solutions
dual variables
for positive
connection j
w byers
approximation algorithms
claim 2
final inequality
linear program
each connection
linear programs
linear programming
the primal
g q
the distributed
running time
primal and
o nm
the approximation
fact 2
for z
do until
r ln
primal variable
and routers
inequality holds
the dual
j w
of primal
the sequential
and dual
of rounds
each phase
of phases
intermediate primal
connections and
standard form
r r
router i
solution y
special form
distributed algorithm
a phase
sequential case
normalized form
each router
of dual
decision makers
a primal
1 approximation
the value
phase i
holds by
local information
of flow
nm ln
distributed decision
to connections
approximately solving
phase number
1 factor
dual feasibility
primal agent
is primal
the network
the final
distributed setting
variables y
to positive
approximation to
local communication
the lp
of connections
value of
have that
the algorithm
global objective
holds from
increase monotonically
2 7
bound the
o r
y y
control policies
the optimum
2 8
a ij
the centralized
an iteration
in o
generate feasible
between connections
may broadcast
dual agents
safe algorithm
router update
claims 2
globally known
xl r
luby and
dual agent
each primal
intermediate dual
feasible r
of luby
distributed rounds
distributed model
global objectives
r time
our algorithm
the running
rounds and
connections in
the routers
of claim
the quality
based only
tradeo between
end of
papadimitriou and
global operations
fast distributed
lp in
polylogarithmic number
r approximation
optimal solution
the values
the solution
algorithms for
quality of
algorithm produces
a 1
feasible for
a polylogarithmic
ratio obtained
centralized algorithm
a approximation
sequential implementation
rate based
current phase
to special
theorem 2
the connections
a feasible
connections which
and yannakakis
for approximately
per phase
desired approximation
solutions to
values of
of iterations
approximation algorithm
on local
programming solution
to flow
a distributed
runs in
an lp
the tradeo
phase by
in standard
x i
first inequality
all j
prove that
program in
iteration i
and d
the bound
the course
2 1
stated in
each agent
working on
the end
phase do
lp z
distributed case
case knowledge
having distributed
optimum primal
increase all
logarithmic approximation
final primal
fast approximation algorithms
algorithms for positive
byers and d
w byers and
y bartal j
j w byers
for positive lps
bartal j w
and d raz
positive linear programs
approximation algorithms for
connections and routers
the final inequality
primal feasible solution
the approximation ratio
the value of
r ln m
a 1 approximation
variables y j
inequality holds by
primal and dual
in the sequential
theorem 2 1
in o nm
positive linear programming
to positive linear
the distributed algorithm
final inequality holds
solutions to positive
figure 2 1
of flow control
approximation to the
number of rounds
to the optimum
dual feasible solutions
each router i
of each phase
holds by the
y y y
the values of
number of phases
the sequential case
value of the
for positive linear
primal feasible solutions
flow control policies
is primal feasible
claim 2 8
positive linear program
of dual variables
nm ln m
holds from the
dual variables x
o nm ln
feasible for z
distributed decision makers
solution for z
each connection j
for z and
primal variables y
1 approximation ratio
of the approximation
y j is
of the solution
quality of the
the dual variables
dual feasible solution
of claim 2
we have that
and the quality
tradeo between the
in standard form
the running time
the optimal solution
the linear program
the quality of
algorithm produces a
of the dual
the algorithm produces
feasible solutions are
primal feasible for
solution y j
papadimitriou and yannakakis
o r 1
the distributed setting
to special form
the centralized algorithm
ln m the
of local communication
approximation ratio obtained
and dual feasible
a 1 factor
feasible r approximation
claim 2 7
ln m r
of primal variables
m the algorithm
number of connections
approximation ratio and
a positive linear
values of dual
algorithm of luby
between connections and
for approximately solving
inequality holds from
a primal feasible
claims 2 7
fact 2 5
generate feasible solutions
1 the distributed
0 r ln
y j s
feasible solution y
intermediate dual feasible
bound the approximation
of our algorithm
the end of
at the end
r r r
based only on
end of each
in the distributed
stated in theorem
only on local
linear programming solution
a polylogarithmic number
of the primal
in o r
feasible solution by
7 and 2
and 2 8
the solution y
polylogarithmic number of
to flow control
fact 2 4
the sequential implementation
in the network
number of iterations
to the value
values of the
e r r
the desired approximation
of the algorithm
prove that the
in theorem 2
the tradeo between
let x denote
we let x
over the course
feasible solutions to
denote the value
the course of
of the optimal
the first inequality
we bound the
2 7 and
of the program
the x i
feasibility of the
a distributed algorithm
x i t
proof of claim
the number of
the network and
the change in
runs in o
variables x i
a feasible solution
sum of the
dual agent i
globally known in
the modified lp
lp z in
1 5 16
distributed model we
take a feasible
lemma 9 to
turn to bound
solutions are necessarily
transformation to special
sequence of inequalities
a primal agent
prior to an
m r time
decisions based only
fact 2 6
values of primal
optimum primal linear
approximate solutions to
extend their model
control problem and
act as the
case knowledge of
agent with each
linear program lp
where the final
on phase i
dual feasible and
of intermediate primal
the safe algorithm

corpus/krapavin2000-test/1014977.txt
laurent
framelet
wavelet
anti
refinable
symmetric
banks
cients
coe
filter
polynomials
filters
gcd
symmetry
tight
qun
mra
mo
splitting
detm
moments
vanishing
pass
frames
spline
polynomial
generators
orthonormal
han
frame
compactly
proposition
odd
antisymmetric
matrix
z
irreducible
nonzero
cz
shall
riesz
satisfied
ualberta
sq
bank
2n
zeros
necessity
detw
fej
mask
bn
bin
fir
2k
degrees
wavelets
su
daubechies
nontrivial
det
ciency
decimal
sa
alberta
k1
sd
claims
identically
v_1
u_2
v_2
u_1
framelets
integer
deduce
multiplying
symmetries
roots
trivial
equations
bhan
2g1
haar
math
factorize
sm
multiresolution
chui
t6g
factorizing
generates
freedom
u2
impulse
auxiliary
u1
homogeneous
k2
edmonton
ca
v2
er
canada
valued
sibling
cient
bases
unitary
unknowns
v1
sp
discontinuous
normalization
2c
consequently
35x
su1
polyphase
15a54
15a23
803127158568155
coef
tamir
zheludev
07391
ams
sv1
sv2
ducible
ficients
42c40
dilates
58x
multiwavelets
su2
9515104959378669
qquad
valery
petukhov
1647
parity
generator
convention
da
dual
lemma
shifts
averbuch
tempered
g121210654
selesnick
overcomplete
nonconstant
stimulate
autocorrelation
verify
contradiction
desirable
verified
subband
nonnegativity
denoising
1632
unnatural
2z
parameterizing
cu
multirate
integers
reconstruction
sciences
conjecture
forall
irre
evident
signal
rewrite
calculate
iv
parameterizations
degree
dirac
dyadic
demonstrated
coefficients
remind
amir
classifications
nserc
lectures
motivated
lot
observing
split
sequently
cv
sv
bs
shift
laurent polynomial
laurent polynomials
anti symmetric
framelet filter
real coe
symmetric laurent
tight wavelet
filter banks
1 z
pass filters
coe cients
all z
z 0
with real
z t
wavelet frame
high pass
symmetric framelet
cients such
even integer
with symmetry
two high
a laurent
and framelet
polynomials with
refinable function
wavelet frames
u 1
symmetric tight
polynomial d
matrix splitting
splitting with
and qun
qun mo
han and
vanishing moments
an even
low pass
of laurent
proposition 2
are anti
filters a
theorem 2
symmetry and
is anti
gcd condition
integer for
m z
pass filter
a symmetric
b spline
g z
a z
frame with
z z
orthonormal wavelet
z g
0 for
in theorem
a 1
p 2n
compactly supported
are satisfied
d z
z a
polynomial with
z 1
linear equations
spline function
of symmetric
r z
by proposition
z d
v 1
refinable functions
gcd a
banks with
a refinable
2 5
the laurent
mra tight
p z
z u
filter a
every x
2 7
we shall
a 2
the gcd
that 2
polynomial p
must have
bin han
be anti
matrix m
wavelet basis
h z
d h
splitting a
z p
shall present
on splitting
trivial laurent
nonzero laurent
cz k
two generators
two anti
z 2k
su ciency
z b
2 4
z 2
with two
and v
polynomial a
filter bank
step algorithm
1 1
is easy
b 1
frames with
an anti
there exist
cients then
5 holds
we must
2 z
can assume
even number
condition in
be true
c 1
have z
b z
2 r
it follows
2 matrix
z and
system of
is odd
of linear
when k
the degrees
solution c
four anti
riesz lemma
symmetric high
have symmetry
good vanishing
detm laurent
condition detm
3 vanishing
nontrivial irreducible
common zeros
polynomials real
polynomials a
identically zero
q z
and su
the symmetry
symmetric and
a nonzero
conditions in
a tight
z c
most n
l 2
c z
an orthonormal
easy to
the mask
is symmetric
a matrix
in 4
that 4
symmetric refinable
exist four
zeros in
follows from
theorem 1
generates a
of u
the claims
2k 1
algorithm 2
d 1
by step
of generators
auxiliary results
ualberta ca
mask a
not identically
two symmetric
1 and
z for
of theorem
that and
q 1
step by
a trivial
real coe cients
with real coe
framelet filter banks
anti symmetric laurent
all z t
high pass filters
for all z
z 0 for
tight wavelet frame
symmetric laurent polynomials
laurent polynomials with
symmetric framelet filter
cients such that
coe cients such
an even integer
a laurent polynomial
two high pass
and framelet filter
0 for all
polynomials with real
even integer for
laurent polynomial d
with symmetry and
symmetric tight wavelet
matrix splitting with
symmetry and framelet
filters a 1
and qun mo
splitting with symmetry
han and qun
tight wavelet frames
theorem 2 4
theorem 2 3
a 1 and
wavelet frame with
symmetric laurent polynomial
pass filters a
are anti symmetric
is anti symmetric
and a 2
of laurent polynomials
is an even
low pass filter
1 and a
and v 1
in theorem 2
u 1 and
with two high
a 1 z
a symmetric tight
z z 1
we must have
by proposition 2
theorem 1 1
1 and v
proposition 2 1
polynomial with real
laurent polynomial with
be an even
r z z
laurent polynomial p
of u 1
l 2 r
pass filter a
matrix of laurent
d 1 z
the gcd condition
g z 0
system of linear
proposition 2 2
m z 0
2 5 and
b 1 z
z u 1
1 z a
u 1 z
b spline function
degrees of u
orthonormal wavelet basis
that 2 5
banks with two
filter banks with
polynomials with symmetry
anti symmetric and
a tight wavelet
integer for all
splitting a matrix
must be true
of linear equations
conditions in theorem
z t and
it follows from
it is easy
a refinable function
v 1 are
must be an
for every x
the low pass
is easy to
the conditions in
by step algorithm
generates a symmetric
polynomial d with
d with real
bin han and
be anti symmetric
even number for
every x 1
of symmetric framelet
an anti symmetric
laurent polynomial a
mra tight wavelet
z t by
5 and 2
algorithm 2 5
in l 2
can assume that
is the graph
number for every
an orthonormal wavelet
the b spline
1 are at
follows from 2
when k is
we shall present
and 2 7
we can assume
polynomial a with
on splitting a
p z 0
laurent polynomials a
z b 1
b z b
polynomials a 1
nonzero laurent polynomial
two anti symmetric
equations in 4
a nonzero laurent
trivial laurent polynomial
zeros in c
spline function of
z g x
framelet filter bank
since a z
2 4 are
with two generators
x 1 0
a matrix of
all the conditions
the matrix m
in c 0
of theorem 2
b and c
algorithm 5 1
coe cients then
examples of symmetric
a z 0
4 are satisfied
z p z
2 2 matrix
z d 1
integer for every
all the claims
wavelet frames and
an even number
in 4 1
a step by
the degrees of
a b and
the graph of
conditions a b
defined in 2
by the proof
at most n
function of order
wavelet frames with
filter a and
four anti symmetric
2 are anti
3 vanishing moments
construction of symmetric
no common zeros
7 are satisfied
z t since
result on splitting
polynomials real coe
symmetric high pass
gcd condition in
wavelet frame and
good vanishing moments
m be defined
exist two anti
z for some
laurent polynomials in
u z u
be a nonzero
detm laurent polynomial
low pass filters
p 2n 1
a symmetric framelet

corpus/krapavin2000-test/1014985.txt
adornments
termination
gamma1000
acceptability
ld
symbolic
guard
predicate
tuned
atom
interargument
adorned
atoms
prolog
1000
prefix
clause
normalised
mappings
ag
numerical
rel
denominators
queries
inferring
inference
clauses
query
adorning
arguments
infers
analyse
recursive
program
positions
integer
subgoals
mapping
computations
x1
predicates
continued
fq
terminates
schreye
numbervars
terminating
finiteness
head
inequalities
definite
conjunct
logic
dershowitz
adornment
gamma1g
0g
gamma1
mutually
atomic
aq
collect
acceptable
body
apt
naturals
characterise
programs
maximal
transformation
c2
disjunction
a2a
occuring
argument
declarative
unify
arithmetic
disjunctions
appearing
corollary
terminate
hints
integers
prefixes
traversing
transformed
inequality
ground
ap
behaviour
decreases
notions
conjunctions
cocco
6w
goa
a2aq
acceptabil
irrel
fcollect
integerg
a62a
temination
decorte
situating
analysers
evant
serebrenik
bossi
oeg
descent
founded
arity
rule
heads
partially
orderings
floating
automatic
fc
calls
extensions
integrating
norm
counterparts
sld
adorn
100g
sumed
proving
inferred
correctness
fa
fr
munity
exp1
c1
subgoal
arithmetics
ackermann
initialised
foe
foundedness
plied
analyser
occured
relaying
characterisations
defining
derivation
danny
generalises
summarises
oscillating
incorporating
correctly
infer
vacuously
unfold
10g
attracted
organised
constraint
integration
coefficients
qg
formalise
conjuncts
satisfiability
extending
methodology
ae
l0
negations
141
tations
unified
combine
preserved
superscripts
analysed
loops
infinite
ditions
corollaries
characterised
compu
rejecting
ready
primitive
gcd
redefined
fixpoint
ideal
position
inherited
pg
overcoming
gorithm
of adornments
level mapping
integer argument
guard tuned
termination of
numerical computations
level mappings
p be
argument positions
let p
p ag
termination condition
a program
p a
program p
p x
termination analysis
x 1000
a predicate
to termination
q be
symbolic conditions
partially normalised
symbolic condition
in p
a termination
argument position
acceptable with
rel q
integer arguments
logic programs
call p
maximal prefix
c p
adornments for
p x1
atomic queries
automatic termination
tuned set
termination inference
program let
predicate p
with respect
arguments of
the termination
respect to
of termination
mapping is
termination conditions
m p
p is
to analyse
the level
of acceptability
adornments of
proving termination
conditions over
every rule
a symbolic
of numerical
is acceptable
for p
a p
prove termination
let q
a query
ld terminating
analyse correctly
1 gamma1000
inferring termination
correctly examples
1000 n
gamma1000 x
adornments let
continued the
position denominators
known framework
adornments and
integer computations
integer inequality
interargument relations
p gamma1000
called integer
ag be
be a
an atom
mutually recursive
predicate in
p q
of p
of symbolic
integer variables
a guard
program and
p 1
is ld
first clause
extended program
definite program
x gamma1
ag q
inference of
the integer
framework of
following program
1 x
1000 is
terminates for
practical issues
transformed program
for inferring
on termination
the acceptability
the symbolic
a q
of integer
the arguments
if p
atom p
not recursive
program obtained
rule r
a level
the predicate
allows one
1000 the
a definite
following notion
1 1000
prefix of
the rule
a 2
p with
condition for
on integer
constraint logic
of atomic
example 2
condition c
for every
termination in
of prolog
finiteness of
q m
7 let
examples such
in prolog
p and
the transformation
and let
example 6
the maximal
in example
that p
integer inequalities
hints at
right selection
and adornments
atoms to
implies termination
interargument relation
tuned sets
2 continued
adornments in
recursive cases
report termination
unified with
symbolic counterparts
infers adornments
acceptability condition
transformation formally
x1 it
acceptability with
fa j
tuned 2
not guard
ld tree
mapping should
examples appearing
numerical loops
fq a
adornments a
c rel
is guard
unify numbervars
the adorning
normalised if
inequalities over
programs depending
mapping pairs
ground unify
adornments presented
x terminates
1000 x
normalised program
adorning process
gamma1000 gamma1
natural level
thus termination
to fq
set of adornments
be a program
p be a
let p be
integer argument positions
the level mapping
1 x 1000
with respect to
acceptable with respect
level mapping is
p 1 x
sets of adornments
a program p
a termination condition
is acceptable with
over the integer
of numerical computations
q be a
be a predicate
over the arguments
termination condition for
be a set
let q be
a predicate in
numerical computations in
the maximal prefix
a level mapping
is a termination
tuned set of
for every rule
guard tuned set
termination analysis of
of symbolic conditions
a guard tuned
predicate in p
of atomic queries
integer argument position
be a query
p a 2
in p a
conditions over the
every rule r
a predicate p
a program and
to prove termination
set of atomic
program p is
respect to p
the arguments of
of adornments let
program obtained as
let p ag
analysis of numerical
p ag be
symbolic conditions over
argument position denominators
m p ag
argument positions of
well known framework
is ld terminating
analyse correctly examples
a symbolic condition
q m p
p ag q
the integer argument
level mapping the
ag be a
p gamma1000 x
x 1000 is
an integer inequality
understanding of termination
the level mappings
p is ld
a program obtained
arguments of p
x 1000 n
then m p
program let q
gamma1000 x gamma1
the rule if
known framework of
a q be
1 1 1000
maximal prefix of
correctly examples such
to analyse correctly
to termination analysis
p is called
prove termination of
1 0 x
the first clause
a definite program
program and let
program is obtained
to p a
a set of
the following program
termination of the
is not recursive
7 let p
body of r
a program let
the transformed program
program with respect
query and let
respect to a
allows one to
all queries in
c p and
for the recursive
obtained as described
the following notion
that p a
and let q
a call to
a 2 a
respect to s
in example 5
of p x
prefix of the
examples such as
respect to the
only if p
s if and
of logic programs
a 2 is
s be a
of a predicate
a query and
a p is
of the predicate
integer arguments of
to right selection
the adorning process
first order built
level mapping should
example 6 12
normalised if all
symbolic condition over
acceptability with respect
adornments a p
p x1 it
and adornments of
call p x1
conditions for numerical
for atoms of
approaches to termination
called integer argument
transformed program with
symbolic condition c
an adorned predicate
transformation that allows
interargument relation for
set 5 6
recursive call p
program let p
framework of acceptability
guard tuned sets
report termination for
right selection rule
is not guard
call to process
should be transformed
terminates with respect
can be unified
and p gamma1000
traversing the rule
1 gamma1000 gamma1
adornments for p
argument positions denominators
a set 5
level mappings on
termination inference problem
the symbolic condition
atomic queries and
termination of numerical
of adornments for
ground unify numbervars
clause is applicable
q are mutually
of termination conditions
inference of adornments
level mappings and
a fa j
for numerical loops
be f 1
respect to fq
ld derivation of
atom and let
2 continued the
adornments presented in
example 2 continued
of level mapping
to termination of
while traversing the
thus termination of
x1 it holds
termination behaviour of
tuned sets of
q a w

corpus/krapavin2000-test/1014992.txt
mtbdd
mtbdds
prism
pctl
csl
ctmc
probabilistic
sparse
kanban
ctmcs
bdds
mdp
gethin
kwiatkowska
dtmcs
hybrid
symbolic
matrices
checking
osets
kronecker
parker
marta
vertex
mdps
coin
terminal
norman
matrix
traverserec
vertices
traversal
jor
unreachable
markov
leader
reachability
diagrams
oset
numerical
cient
reachable
cudd
baier
christel
ine
specication
dtmc
transition
logics
row
iterative
protocol
minimise
analyse
sigmetrics
col
376
modied
bdd
chains
steady
engines
transient
ciesinski
probverus
marca
katoen
david
specications
seidel
compact
quantitative
gauss
smart
ciardo
elseif
behaviour
tool
signicant
optimisation
jacobi
multiplication
entries
var
ir
marcus
smv
gspns
columns
labelled
analyser
indices
checker
elected
432
546
iteration
engine
attach
summarise
y2
presently
parameterised
store
ctl
miner
475
decision
colorado
parser
454
randomized
conversion
boolean
logic
column
compactly
y1
vn
checkers
analysed
web
diagram
448
veri
encode
temporal
valued
traversing
storing
encoding
simplex
x2
173
fig
fm
136
dierence
fx
probabilities
chain
consensus
storage
itai
ciencies
m04617
represention
studentship
boulder
pdgs
carroll
buchholz
probmela
pallets
mathfit
younes
typied
groesser
stevens
deds
satisifes
stocastic
2fig
mtbbd
mciver
manip
hermanns
annabelle
unites
mtbbds
sproston
boudewijn
ingenious
joost
tacas
uniformisation
039
grer
negligle
inception
magnitude
species
stochastic
sub
children
fairness
frank
unpredictable
queueing
asynchronous
x1
savings
opt
queue
modules
supports
proba
birmingham
bilities
model checking
the mtbdd
an mtbdd
hybrid approach
symbolic model
sparse matrices
probabilistic symbolic
david parker
prism a
marta kwiatkowska
kwiatkowska gethin
gethin norman
probabilistic model
probabilistic systems
with prism
iteration vector
norman and
sparse matrix
checking with
the prism
coin protocol
numerical computation
time markov
the coin
of probabilistic
sub matrices
and david
mtbdds and
reachability based
prism web
mtbdd representation
the kronecker
terminal vertex
iterative methods
the tool
a hybrid
the matrix
e cient
matrices and
of pctl
the ctmc
and csl
row col
ctmc and
modied mtbdd
mtbdds we
equation system
pctl and
mtbdd data
v row
reachable states
case studies
probabilistic models
using mtbdds
during traversal
unreachable states
else v
decision diagrams
checking of
boolean variables
data structure
performance problems
based computation
and analyse
using sparse
markov chains
continuous time
transition matrix
system description
the sparse
temporal logics
vector multiplication
zero terminal
full array
and ctmcs
mdps and
page 31
mtbdds the
and bdds
christel baier
in prism
matrix entry
mtbdd representing
mtbdds can
and jor
matrix entries
and kanban
the kanban
our hybrid
decision processes
matrix diagrams
vertex then
mtbdd and
mtbdd m
of ctmcs
dtmcs and
and sparse
non terminal
the modied
steady state
linear equation
binary decision
a ctmc
prism is
var v
jacobi and
multi terminal
the iteration
a leader
matrix vector
the hybrid
novel hybrid
matrix based
real valued
evaluation review
web page
acm sigmetrics
sigmetrics performance
to minimise
checking algorithms
gauss seidel
these performance
performance evaluation
variable ordering
of reachable
description language
for probabilistic
model checker
markov chain
and column
to store
march 2005
and explicit
s 0
checking for
32 n
v 32
protocol and
row and
the model
bdds binary
ctmc in
concurrent probabilistic
mtbdd with
cient mtbdd
2 546
from osets
key dierence
mtbdd based
matrix diagram
dtmc and
reactive modules
mtbdd the
iteration vectors
explicit approaches
sparse hybrid
prism system
2 376
use mtbdds
2 vertex
identical sub
opt coin
symbolic probabilistic
overall matrix
for pctl
376 448
coin 4
ctmc model
pure mtbdds
baier frank
in mtbdds
recursive traversal
and simplex
ciesinski marcus
elseif v
non probabilistic
hybrid opt
rst constructs
identical children
kronecker approach
then traverserec
an mdp
mtbdd size
other mdp
linear optimisation
kanban examples
rate matrix
matrix techniques
mtbdd implementation
546 432
2005 christel
shared vertices
mtbdds multi
mdp models
analyse probabilistic
osets on
with mtbdds
mtbdd which
kanban 4
use bdds
symbolic model checking
probabilistic symbolic model
marta kwiatkowska gethin
kwiatkowska gethin norman
norman and david
and david parker
with prism a
prism a hybrid
the coin protocol
checking with prism
probabilistic model checking
gethin norman and
model checking with
a hybrid approach
the iteration vector
of the mtbdd
time markov chains
continuous time markov
model checking of
v row col
for the coin
the mtbdd data
mtbdd data structure
using sparse matrices
reachability based computation
linear equation system
prism web page
the modied mtbdd
the prism web
pctl and csl
the sparse matrix
review v 32
of probabilistic systems
32 n 4
a linear equation
matrix vector multiplication
binary decision diagrams
an mtbdd m
coin protocol and
mtbdd and sparse
zero terminal vertex
web page 31
protocol and kanban
jacobi and jor
in an mtbdd
the hybrid approach
these performance problems
mtbdd representing the
system description language
sparse matrix based
to the mtbdd
mtbdd representation of
our hybrid approach
model checking for
analysis of probabilistic
hybrid approach we
row and column
the transition matrix
a novel hybrid
model checking algorithms
acm sigmetrics performance
performance evaluation review
sigmetrics performance evaluation
evaluation review v
computation which is
of reachable states
of a linear
storage requirements for
solution of a
s s 0
v 32 n
of the tool
requirements for the
we nd that
a row vertex
0 of making
mtbdds have been
checking of concurrent
from osets on
other examples which
such as smv
then traverserec else
slow or infeasible
almost match the
4 43 136
the standard binary
the atomic proposition
system 5 2
use bdds binary
the mdp as
of reachability based
explicit sub matrices
subset of pctl
the key dierence
heuristics to minimise
ctmc and its
numerical computation which
a non terminal
from the prism
e cient mtbdd
prism a tool
mtbdds and bdds
2005 christel baier
4 an mtbdd
row vertex then
be found on
an mtbdd implementation
model checking times
symbolic and explicit
case studies for
coin 4 43
dtmcs mdps and
sparse hybrid hybrid
frank ciesinski marcus
non terminal vertex
like data structure
the mtbdd the
elseif v is
ctmc in figure
of unreachable states
sparse matrix and
using mtbdds and
and analyse probabilistic
hybrid hybrid opt
a full array
represent and analyse
baier frank ciesinski
the ctmc in
checking for probabilistic
than with sparse
about the conversion
the mtbdd which
march 2005 christel
on the prism
to express properties
sparse matrix for
representing the ctmc
overcome these performance
4 454 475
identical sub matrices
from to ir
and kanban examples
a linear optimisation
markov decision processes
linear optimisation problem
traverserec else v
through the mtbdd
mtbdds multi terminal
a ctmc and
opt coin 4
mtbdd m over
hybrid opt coin
array to store
sparse matrix techniques
probabilistic models and
mapping from to
boolean variables to
the kronecker approach
6 2 376
of the kronecker
christel baier frank
the sub matrix
its rate matrix
probabilistic model is
modied mtbdd representing
solution we adopt
model n states
symbolic probabilistic model
bdds binary decision
probabilistic temporal logics
model checkers such
speed of sparse
x 2 vertex
s to s
vertex then traverserec
model checking engines
mtbdd sparse hybrid
with sparse matrices
checking times for
mtbdds can be
the overall matrix
5 2 546
in the mtbdd
logics pctl and
studies we have
veri symbolic model
case studies we
kanban 4 454
and column indices
and explicit approaches
else v row
2 376 448
making a transition
store the iteration
these shared vertices
parameterised by n
page 31 probabilistic
checking for a
power jacobi and
the zero terminal

corpus/krapavin2000-test/1014994.txt
transition
circuit
redd
circuits
pi
bdd
red
predecessors
oe
bdds
symbolic
ctl
init
checking
relations
pci
smv
inputs
sub
assignment
sequences
generation
gains
sup
bus
subcircuit
verification
endfor
backwards
operator
assignments
temporal
coverage
ex
atpg
trace
reachable
am
agrees
800m
reproduces
dyn
quantifier
dynamic
unmanageable
reproduce
exterior
ef
signals
projection
partial
endwhile
stage
1m
intel
formula
finished
accessible
industrial
seq
vec
expand
checkers
print
static
agree
twelve
ffl
designs
dynamically
unreachable
receives
precomputed
synchronous
cone
ax
st
recreates
sensitization
2301
returns
explosion
successors
validation
logic
creating
concise
consumption
relation
critical
created
reuses
verifiers
subcircuits
inputing
puzzling
quences
verified
designer
unprimed
9v
behaviors
granted
architectural
operators
sometime
latch
orders
failed
tests
influence
designers
translate
path
traverse
speedup
grow
hierarchical
creates
induces
series
successor
columns
testability
valuations
killed
valuation
expensive
arbitrarily
exploit
595
eleven
inefficiency
frequently
representations
simulation
verifying
boolean
arrive
width
gamma1
generator
impressive
rounded
sure
succ
vg
rn
asynchronous
mostly
iteration
extremely
companies
quantifiers
hardware
magnitude
seconds
successful
opposed
relate
counterexample
enhances
endif
prominent
stages
differs
core
silicon
facets
modality
abuse
modalities
produces
plan
symbolically
putation
sm
averages
beforehand
megabytes
environ
schematic
notice
forward
intermediate
formulas
gained
unrestricted
pursue
expands
connectives
gamma2
deterministically
aspect
popularity
signs
goes
search
gain
reverse
transition relations
dynamic transition
transition relation
test sequence
model checking
p red
test sequences
of states
sequence generation
p redd
partial assignment
symbolic model
partial transition
test generation
sub circuit
generation algorithm
the circuit
sequence pi
full design
pi sub
next state
the transition
assignment oe
i sub
over u
a test
sub circuits
of predecessors
the test
variables in
of variables
good coverage
s init
predecessors of
the pci
backwards search
pci local
local bus
pi on
a partial
n i
the dynamic
assignment over
the support
a bdd
i v
global transition
state s
initial state
partial assignments
pi in
v 0
the sub
variable v
of inputs
of test
an assignment
the inputs
init and
red a
large circuits
input variables
finite state
support of
circuit the
sequences that
inputs to
f depends
state value
on v
a transition
projection of
dynamic algorithm
logic ctl
that agrees
static algorithm
sequences for
a state
states a
in i
the algorithm
v i
relation r
the full
small critical
ex operator
several large
the subcircuit
stage ii
in smv
sup 0
dynamic validation
critical sub
states in
the projection
variables u
circuits the
u 0
stage i
on u
oe over
the bdd
and sup
the backwards
ef p
on i
relations can
p holds
an initial
sequence for
gives values
complete circuit
that agree
the variables
agrees with
state variables
relation is
exploit a
inputs i
efficient test
relation into
circuits that
r i
state machine
of p
the temporal
oe i
a formula
of circuits
the ex
variables that
and space
operator is
the partial
u that
temporal logic
chosen arbitrarily
operator p
a i
the set
all variables
receives a
set a
through these
that dynamic
in lines
transition in
the design
the operator
assignment that
their size
same idea
relations and
new method
choose oe
reproduce pi
unmanageable due
checking 3
circuit are
circuit input
operator ex
smv 13
bdd implementation
sub in
provide gains
in symbolic
redd is
assignments over
columns relate
atpg algorithms
ffl sub
a backwards
previously unmanageable
as partitioned
sub if
sub be
simpler relations
red function
endwhile stage
reproduces the
bus 4
very concise
1m of
hierarchical design
circuits than
states assignments
verify circuits
industrial circuits
by bdds
pi that
print sequence
generation failed
relations method
improve symbolic
lines 21
init s
intel circuits
5 1m
dynamically for
dyn st
dynamic transition relations
set of states
test generation algorithm
a test sequence
symbolic model checking
the transition relation
a partial assignment
test sequence generation
of p red
partial transition relation
partial assignment oe
the sub circuit
the full design
the test sequence
of the circuit
of test sequences
the partial transition
the dynamic transition
transition relation r
test sequence pi
set of predecessors
the test generation
the next state
an initial state
in the support
a transition relation
pci local bus
variables in i
the pci local
of predecessors of
transition relation is
global transition relation
test sequences that
of states a
test sequences for
the support of
a set of
the set of
number of variables
transition relations can
of variables u
next state value
partial assignment over
the p red
test sequence for
of dynamic transition
s init and
assignment over u
transition relations and
the dynamic algorithm
set of test
set of variables
the projection of
predecessors of a
over u that
variable v i
p red a
of states in
sets of states
the global transition
the variables in
states in a
initial state s
values to all
sequence for the
that agrees with
sequence of inputs
model checking the
these results show
inputs to the
a good coverage
to all variables
on v i
the static algorithm
our test generation
and sup 0
method can provide
pi on i
that dynamic transition
assignment to i
using dynamic transition
state s init
the ex operator
state value for
the backwards search
sequence pi in
transition relation into
transition relations the
partial transition relations
next state variables
u that agrees
assignment oe over
p holds in
generation algorithm that
transition relations to
the operator p
method in smv
through these sets
good coverage of
of the design
computation of p
finite state machine
variables in the
of a we
represents the set
the new method
an assignment that
the complete circuit
that agree with
time and space
support of a
f depends on
state variables that
show that dynamic
temporal logic ctl
projection of s
a set a
the inputs to
in the full
parts of the
the circuit the
n i s
model checking and
a variable v
that p holds
in the circuit
algorithm is the
set of inputs
means that p
is a partial
to the sub
computes the set
a finite state
the temporal logic
to two orders
is an assignment
the algorithm is
the computation of
up to two
the same idea
not exist in
common and most
space during verification
v 0 does
in i when
pi on u
0 over u
receives a partial
5 1m of
goes through these
often be smaller
local bus 4
exploit a partition
the symbolic model
partitioned transition relations
relation at each
transition in n
the design however
represented by bdds
p redd is
architectural level test
depend on v
assignment oe 0
from i v
inputs i sub
1 6 of
ffl sub circuits
series of sets
agrees with s
every in i
at an initial
of states assignments
that every n
full design that
of the pci
implemented the new
types of circuits
from the exterior
as partitioned transition
of partial assignments
level test generator
and most expensive
an architectural level
value for variables
p red function
and symbolic model
all all a
in smv and
on several large
oe 0 over
large circuits our
called p redd
circuits it is
previously unmanageable due
efficient test generation
small critical sub
transition relation and
sub circuit and
were previously unmanageable
run it on

corpus/krapavin2000-test/1015045.txt
tgdh
gdh
ckd
str
bd
blinded
member
members
agreement
exponentiations
sponsor
group
membership
secure
keys
protocol
diffie
protocols
hellman
controller
spread
leave
contributory
rsa
broadcasts
rounds
milliseconds
join
merge
br
1024
token
round
multicast
512
broadcast
communication
synchrony
security
jhu
reliable
peer
wan
modular
cliques
dh
icu
verifications
exponentiation
exponent
session
messages
toolkit
lan
key
attacks
testbed
openssl
securering
secret
msec
ensemble
uci
collaborative
costs
signature
signatures
modulus
message
daemon
management
expensive
groups
cryptographic
library
bk
partition
burmester
thirteen
tree
service
services
pcs
desmedt
authenticated
leaving
ika
antigone
pfs
wans
party
bit
events
secrecy
rekeying
outsider
unicasts
totem
establishment
centralized
sender
refreshing
securing
exchange
event
server
isis
agreed
height
public
conceptual
keying
receipt
authentication
partitionable
oldest
notable
unicast
hopkins
brk
tzeng
rekey
teleconference
rightmost
insecure
virtual
platform
five
channels
provably
delay
horus
avl
sponsors
2h
irvine
shallowest
sages
bits
client
fault
joining
ring
tolerant
root
mem
multiplications
666
blown
multicasts
steer
refreshes
rampart
transis
mhz
sessions
mes
delivery
network
wide
insider
trip
entity
integrated
pairwise
bimodal
rus
performer
distribute
negligible
computes
policy
ber
imbalanced
balanced
contribution
pentium
receiving
chinese
logarithmically
lans
merging
integrity
hl
bers
leaf
hidden
passive
overhead
robustness
deteriorates
sensor
korea
charged
machines
runs
setup
factoring
cpu
area
group key
key agreement
the group
group communication
group controller
group size
diffie hellman
agreement protocols
group membership
blinded keys
key management
secure spread
key tree
communication system
group member
of group
gdh str
membership service
reliable group
a group
group members
str and
keys and
other protocols
r br
and blinded
br r
the sponsor
1024 bit
modular exponentiations
bd is
new member
current group
and tgdh
bd ckd
tgdh is
ckd gdh
and ckd
the key
all members
wide area
secure group
gdh and
key server
str tgdh
512 bit
merge protocol
virtual synchrony
new group
and broadcasts
hellman key
the cost
agreement protocol
the token
the protocol
cost of
new key
group diffie
membership change
membership changes
computation costs
the controller
size members
bd protocol
blinded key
of exponentiations
ckd and
bits bd
msec group
and gdh
than gdh
a leave
protocol runs
milliseconds for
and leave
join and
peer groups
time msec
remaining member
rsa signature
members leave
member can
every member
key exchange
runs as
party diffie
signature verifications
that tgdh
group keys
leave event
hidden cost
tgdh membership
key distribution
a secure
each member
protocols in
a reliable
two rounds
member of
of rounds
contributory key
modular exponentiation
bit modulus
security services
the protocols
communication and
the merge
members are
broadcasts the
communication rounds
keys on
new members
peer group
gdh protocol
str is
group step
dh 512
tgdh protocol
five protocols
sponsor sponsor
member leave
extended virtual
partial keys
ckd is
the securering
system spread
session random
all blinded
tgdh and
in secure
most expensive
communication systems
a member
two party
the keys
the spread
the bd
dynamic peer
members join
broadcast message
512 bits
in bd
one member
average time
and computation
token to
the membership
average cost
1 messages
all group
factor out
join or
broadcasts it
the members
of key
the cliques
the broadcast
the root
the conceptual
less expensive
costs of
area networks
other members
the joining
members and
key and
ordered message
toolkit supports
tgdh the
secure channels
leaving member
that bd
ckd protocol
verifications and
burmester desmedt
exponent n
the gdh
new exponent
leave dh
1 gdh
securing group
dynamic groups
and str
membership protocol
gdh is
50 members
in tgdh
underlying group
expensive protocol
bit diffie
the blinded
establish secure
area group
lan setting
high delay
hellman parameter
refreshing its
of tgdh
management protocols
remaining group
group key agreement
key agreement protocols
group communication system
group key management
the group key
reliable group communication
of the group
to the group
the key tree
the key agreement
the group size
the group controller
keys and blinded
and blinded keys
r br r
of group key
ckd gdh str
key agreement protocol
the cost of
join and leave
milliseconds for a
bd ckd gdh
the new group
str and tgdh
br r br
gdh str tgdh
diffie hellman key
for a group
the other protocols
hellman key exchange
group diffie hellman
bits bd ckd
new group controller
group size members
time msec group
runs as follows
msec group size
protocol runs as
group communication systems
the protocol runs
of the key
a group key
communication and computation
secure group communication
party diffie hellman
the current group
ckd and gdh
current group controller
compute the group
number of exponentiations
str tgdh membership
two party diffie
member of the
of the membership
the group membership
with the group
a reliable group
contributory key agreement
group of size
and computation costs
generates a new
number of rounds
the most expensive
with a reliable
tgdh is the
extended virtual synchrony
group membership changes
group size of
all blinded keys
gdh and ckd
communication system spread
a new key
blinded keys and
the five protocols
n 1 messages
512 bits bd
for a leave
dh 512 bits
the merge protocol
the membership service
a group member
1024 bit modulus
in group key
dynamic peer groups
keys on the
agreement protocols in
the average cost
cost of the
broadcasts it to
to a group
the root node
the token to
of the five
a group of
upon receipt of
wide area networks
diffie hellman parameter
each member m
reliable and ordered
membership service figure
tgdh and str
list of partial
members leave dh
group membership service
performance of group
of partial keys
securing group communication
every member can
partition and merge
all the keys
area group communication
wide area group
gdh ika 3
a leave event
the group step
leave of a
the lan experiments
key management is
each group member
short term group
group controller the
most expensive protocol
the key server
a group size
centralized group key
peer group communication
a new exponent
rsa signature verifications
size members leave
tgdh membership service
underlying group communication
lan experiments we
agreement protocols with
member can compute
contributory group key
bit diffie hellman
in secure spread
blinded keys on
leaves the group
signature verifications and
secure channels with
efficient group key
a secure group
key distribution scheme
members join dh
the two party
the keys and
spread group communication
group key and
size members join
of group communication
local and wide
members are added
centralized key distribution
scale linearly with
and ordered message
key management protocols
gdh str and
a leave operation
the new member
the new key
512 bit case
channels with all
a new member
of the members
wide area network
services such as
all group members
two communication rounds
key establishment in
robustness in group
efficient conference key
in a lan
exploring robustness in
is the most
key agreement in
then broadcasts the
many to many
the group members
integrated with a
to m n
it to the
costs of the
of a member
the other members
protocols in the
and wide area
token to the
mhz pentium iii
related with the
the first round
the group the
to the root
on the performance
performance of the
receipt of the
less expensive than
of the protocols
constant number of
a constant number

corpus/krapavin2000-test/1015499.txt
bu
flows
tcp
router
er
ers
packets
lived
congestion
rtt
window
routers
ns2
tra
queue
link
ering
backbone
pkts
flow
packet
bursts
utilization
thumb
sawtooth
afct
wmax
burst
sizing
sender
bottleneck
synchronized
gsr
outstanding
bandwidth
linecard
overbu
12410
dram
ect
sigcomm
ered
short
internet
10gb
sawtooths
pauses
trip
cisco
mb
avoidance
slow
buffer
erent
throughput
queueing
di
250ms
oc3
desynchronized
delay
simulations
buffers
fifo
doesn
today
links
synchronization
occupancy
aggregate
persuade
dynamics
busy
sram
underutilized
5gb
networking
nick
simulation
40gb
2tp
mckeown
windows
acks
mix
99
dropped
bw
drop
arrivals
evolution
tail
predicts
leith
mtu
util
sommers
barford
200
poisson
completion
erence
attacks
latency
congested
000
round
reno
goodput
job
measurements
ll
fairness
chips
pareto
trough
modem
dos
senders
network
sending
red
arrive
drops
lengths
mixes
manufacturers
lose
bytes
sure
ected
capacity
speeds
chip
ack
underflow
steadily
provisioning
pause
halved
10500
ansnet
yashar
155mb
25ms
villamizar
drains
underflows
linecards
ganjali
5gbits
propagation
shorten
rate
goes
net
cult
pins
timeouts
devices
halves
load
500
duffield
aimd
rtts
drams
joel
commercial
exp
1500
carrying
400
fill
review
cascades
rfc
11000
lockstep
outdated
card
networks
ram
gateways
amos
asics
gsm
mbit
topology
aggregated
complicates
loss
ton
telecommunications
idle
argue
board
oscillating
multiplexed
tailed
bu er
the bu
bu ers
er size
of flows
window size
long flows
tcp flows
short flows
router bu
the router
long lived
bottleneck link
of bu
lived flows
rtt c
queue length
of tcp
bu ering
tra c
tcp flow
of thumb
the sender
the queue
access links
short lived
flows and
slow start
mb s
the window
flows are
rule of
a router
flows the
congestion control
er is
a bu
the link
the bottleneck
the flows
lived tcp
er requirements
flow completion
goes empty
flows we
congestion window
many flows
congestion avoidance
of long
m g
e ect
wmax 2
of congestion
flows in
cisco gsr
required bu
bu ered
gsr 12410
smaller bu
pkts figure
the congestion
minimum required
computer communication
acm sigcomm
communication review
sigcomm computer
round trip
backbone routers
s link
router with
outstanding packets
the rule
the bandwidth
di erent
dynamics of
the dynamics
flows as
of rtt
queueing delay
a bottleneck
10gb s
sizing the
thumb comes
short flow
internet routers
backbone router
ns2 simulations
flow lengths
congestion windows
000 flows
ers in
queue pkts
aggregate window
link utilization
review v
average queue
the tcp
packet loss
simulation and
control algorithm
the short
single flow
single tcp
a congestion
and experiments
doesn t
1 model
a tcp
tcp s
our model
trip time
go empty
large bu
with bu
delay bandwidth
rtt bw
the afct
flow length
queue occupancy
ns2 and
using ns2
ers of
ers are
overbu ering
to persuade
lose throughput
phase synchronization
12410 router
concurrent flows
er to
small bu
packets outstanding
5gb s
routers with
ect on
we ll
the flow
evolution of
g 1
a flow
window sizes
the average
link the
model predicts
and so
2 5gb
in backbone
ns2 simulation
never goes
bandwidth product
not synchronized
flows with
the utilization
graph shows
size is
network tra
sending rate
synchronized and
length distribution
1 queue
avoidance mode
average flow
flows is
access link
backbone networks
net work
a burst
in phase
a backbone
all flows
our results
of short
rate c
completion time
link is
utilization and
n shorten
sender pauses
required buffer
backbone links
lived flow
infinite bu
non tcp
a 10gb
bottleneck router
s queue
er will
ering needed
er never
core router
nick mckeown
the sawtooth
40gb s
packet bu
router design
over bu
physical router
router linecard
internet backbone
200 mb
the bu er
bu er size
number of flows
rule of thumb
of bu ering
the bottleneck link
router bu er
long lived flows
the rule of
the window size
bu er is
amount of bu
router bu ers
number of long
m g 1
a bu er
lived tcp flows
the bu ers
bu er requirements
the queue length
long lived tcp
short lived flows
the router bu
computer communication review
sigcomm computer communication
communication review v
acm sigcomm computer
required bu er
of long lived
of rtt c
that the bu
congestion control algorithm
a tcp flow
the dynamics of
a bottleneck link
average queue length
bu ers in
smaller bu ers
of thumb comes
queue pkts figure
thumb comes from
g 1 model
dynamics of tcp
simulations and experiments
of the flows
of the router
round trip time
e ect on
sizing the bu
delay bandwidth product
the short flows
flow completion time
with many flows
flows we will
large bu ers
a backbone router
the delay bandwidth
aggregate window size
in backbone routers
er size is
the flows are
cisco gsr 12410
single tcp flow
small bu ers
never goes empty
the aggregate window
a congestion control
minimum required bu
observations on the
er size we
bu er to
of a congestion
rtt c n
of the bu
the long flows
point of congestion
average flow completion
bu ers of
gsr 12410 router
2 5gb s
bu ers are
on the dynamics
a single flow
a single tcp
g 1 queue
of flows and
the link and
graph shows the
the congestion window
the model predicts
congestion avoidance mode
the average queue
dynamics of a
single point of
of the queue
evolution of the
of the link
review v 36
the number of
the flow length
at the bottleneck
in a backbone
short flows in
the time evolution
flow completion times
length distribution is
an e ect
congestion control algorithms
and 200 mb
the sender pauses
200 mb s
network of real
flows in practice
bu er will
80 and 200
of the sawtooth
with a bu
bu er never
wmax 2 packets
single long lived
for short flows
if the bu
long flows as
bu ering needed
tcp flow through
are not synchronized
at rate c
a 10gb s
of long flows
model predicts the
a cisco gsr
infinite bu ers
10 000 flows
with bu ers
minimum required buffer
time evolution of
bu ers for
through a bottleneck
of bu er
trough of the
short and long
an m g
of tcp s
and the bu
to make sure
review v 35
in an m
of network tra
bu er of
while the sender
of the congestion
of tcp flows
average congestion window
the minimum required
bottleneck link the
s congestion control
40 80 and
the sender has
through a router
and the sender
of flows the
the average flow
of short and
in slow start
the line rate
tcp s congestion
its window size
of flows we
and so the
window size and
window size in
bandwidth delay product
where the rule
network tra c
topology in figure
completion times for
a single point
the amount of
probability distribution of
it only depends
size we can
on the load
random early detection
slow start and
the first packet
number of outstanding
of the sum
v 36 n
is to make
a small multiple
q t is
that the queue
standard deviation of
that the rule
networking v 51
window size is
a mix of
v 35 n
the standard deviation
the probability distribution

corpus/krapavin2000-test/1015505.txt
eid
sid
sids
eids
ip
intermediaries
resolution
middleboxes
delegation
host
dns
flat
namespace
names
transport
naming
internet
identifiers
infrastructure
endpoint
service
peer
dhts
addresses
services
hosts
mail
fara
dht
namespaces
intermediary
layer
packets
destination
routing
hip
triad
layers
proposals
uip
packet
delegate
mobility
architecture
endpoints
identifier
nats
resolve
proposal
web
destinations
resolves
borrow
architectural
i3
firewall
overlay
ipv6
persistent
network
59
s1
homing
homed
s2
protocol
server
indirection
protocols
principle
p2p
receiver
adus
administrative
lookup
tcp
principles
sender
name
urn
overlays
security
gateway
urls
org
session
mobile
denial
address
named
descriptors
protection
nimrod
rsps
unmanaged
adu
sfr
http
persistently
today
triples
triple
trust
entity
smtp
ipv4
pathname
ani
delegated
routers
logically
layered
recipient
resolving
party
functionality
addressing
binding
port
envision
dos
abc
destined
handles
descriptor
cryptographic
deploy
firewalls
globe
bind
isps
attacks
router
proxies
scalable
send
location
saltzer
napts
interposition
troubling
unfriendly
jpg
conviction
diaries
ipnl
interme
p6p
peernet
architecturally
oceanstore
entities
connections
networking
home
connection
behalf
opaque
innocuous
owners
uld
shield
virus
genre
adherence
alterations
invoked
clients
authority
tied
economic
owner
seemingly
readable
interposed
scalably
ephemeral
genres
aren
resolver
sos
don
identifies
motivations
intended
header
bindings
caching
meta
semantics
frastructure
prematurely
chord
shenker
reconsidering
hash
controlled
initiate
forwarding
deployment
ip addresses
the eid
ip address
the sid
resolution infrastructure
an sid
flat names
the resolution
eid resolution
e mail
flat namespace
resolution layer
the internet
of sids
sids and
sid resolution
user level
the ip
network level
principle 1
an eid
to eids
and eids
level descriptors
eids and
a flat
peer to
to peer
network elements
name resolution
our proposal
and ip
a service
borrow the
domain names
eid level
delegation in
eid to
of destinations
eid e
naming layers
of delegation
mail addresses
to ip
we borrow
the destination
the transport
the endpoint
design principles
services and
eid and
naming architecture
resolution service
transport protocols
and services
the firewall
transport protocol
mobility and
of ip
the packet
an endpoint
a web
s eid
of intermediaries
network handles
service identifiers
abc org
and uip
level descriptor
multi homing
intermediaries the
multi homed
endpoint identifiers
to sids
dns names
sid to
host identifiers
destination eid
eid of
host software
persistent names
web server
application level
service or
open network
ip layer
resolution step
layered naming
internet s
be flat
names should
and service
denial of
names and
architecture we
architecture that
third party
of names
hosts and
end host
50 51
principle 3
the architecture
the host
and data
internet architecture
named by
carried in
service and
names are
our architecture
an ip
first class
with principle
the delegated
level delegation
p2p systems
tables dhts
transport port
principle 4
network locations
sid is
layer between
new naming
a delegate
internet mobility
eid layer
the adu
global namespaces
internet indirection
fara s
sids to
indirection infrastructure
or eid
against denial
eid in
i3 53
a dht
sid level
infrastructure a
resolution layers
sids the
distributed hash
our motivations
host identity
of triad
smart packets
should bind
delegated host
level intermediaries
urn literature
user domain
of middleboxes
this architecture
identifiers and
resolution of
of service
the naming
the identifiers
names for
globe project
an intermediary
peer overlays
principle 2
internet protocol
bind to
gain access
host mobility
that humans
project 4
sid s
control if
these proposals
ip routing
resource names
mail server
changes to
an architecture
destined for
today s
represented a
the intermediary
dns based
the urn
identifiers to
host s
design principle
addresses to
general principles
and transport
the routing
the service
network architecture
the network
web page
every packet
to host
of name
end hosts
the globe
the resolution infrastructure
services and data
peer to peer
sids and eids
user level descriptors
data and services
eid resolution layer
a flat namespace
borrow the idea
the e mail
we borrow the
e mail addresses
the eid resolution
in the resolution
the ip address
and ip addresses
the resolution step
the sid resolution
the third party
at the sid
the destination eid
user level descriptor
open network handles
mobility and multi
and multi homing
denial of service
the internet s
of ip addresses
an ip address
to ip addresses
a web page
hash tables dhts
at the eid
the urn literature
of our motivations
access control if
the delegated host
the eid layer
sid resolution layer
internet indirection infrastructure
of flat names
globe project 4
control if it
of name resolution
protection against denial
service or data
against denial of
distributed hash tables
resolution infrastructure a
to eids and
new naming layers
a service or
end host identifiers
sequences of destinations
the sid is
the resolution of
a web server
owner of the
to peer overlays
be carried in
the globe project
gain access to
layered naming architecture
the ip layer
32 33 35
to a sequence
as the destination
one or more
of the address
e g a
at the network
ip address of
the owner of
end to end
a sequence of
of the internet
address of a
we don t
section 3 2
dns based names
packets are logically
application level intermediaries
sequence of intermediaries
resolution service ip
eid to ip
or receiver can
role of names
if a service
of eids or
ip addresses as
have in hand
at an sid
p2p systems scalable
routinely violated in
today s middleboxes
be first class
which changes to
resolution infrastructure can
intermediaries the source
service and data
resolves the eid
of a delegate
name resolution from
generally deal with
as a peer
to host software
eid level delegation
humans and the
the mechanics of
a transport connection
and service layers
using eid resolution
of sids and
how names should
up data in
might use multiple
urn literature 23
literature 23 50
network handles 37
s location would
of networks september
dynamic network architecture
four basic design
wants one or
rsps would have
our point here
host s home
should relate to
an sid s
eid to the
internet has only
if s represented
class internet objects
of destinations in
flat namespace is
storage management and
reconsidering internet mobility
auxiliary mapping service
logically destined for
for which changes
name resolution infrastructure
a layer between
namespaces dns names
dynamic interconnection of
and eids should
the eid level
the network level
us to claim
to the ip
layer resolves the
objects in that
an auxiliary mapping
host identity protocol
dns names and
mobile ip 34
key management from
of network architects
use multiple triples
management from file
looking up data
from file system
bind to eids
eid in the
send the e
returned ip addresses
level descriptor to
semantics of ip
location and identity
23 50 51
authenticate each other
sequence of sids
an e mail
networks september 02
semantic free referencing
middleboxes such as
address as a
a chosen delegate
in every packet
and caching in
of these namespaces
for multi homed
resolve s to
layer between them
ipv6 as a
in the http
and uip 14
names as we
a dht based
issue of naming
multi homed hosts
layer to re
we make only
a flat identifier
a pathname on
recipient controlled delegation
use a layer
level the delegation
third party service
explicitly invoked by
the eid to

corpus/krapavin2000-test/1015755.txt
sgplvm
poses
motion
pose
animation
lgp
latent
lik
xi
training
character
wk
gp
gaussian
posing
2d
interpolation
style
learning
ik
mog
yi
tting
synthesis
lawrence
likelihood
keyframing
baseball
tog
siggraph
kinematics
styles
markers
speci
annealed
popovi
learned
pdfs
pca
eurographics
motions
active
3d
pitch
graphics
learn
sgplvms
jovan
pdf
human
vienna
gaussians
hertzmann
neil
animator
eugene
yt
ef
objective
capture
wright
joint
austria
ne
articulated
kernel
optimizes
parameterization
rbf
dragging
orientation
interactive
gps
annealing
trajectory
neural
variance
angles
minima
smooth
humans
missing
mackay
sketching
interpolated
scaled
animating
optimizing
frame
unknowns
modi
posterior
image
plot
sumner
nocedal
shmm
igarashi
gesticulation
bfgs
rasmussen
storyboarding
puppetry
gesture
moscovich
yk
believable
hagan
yamane
hollywood
lik0
lik1
keyframed
mogs
sigchi
unannealed
plvm
handrix
animations
dif
additionally
inverse
smoother
acceleration
aaron
virtual
ln
velocity
interpolate
qi
hsu
optimization
sqp
karen
avatars
legged
rbfs
adverbs
rigging
entertainment
fiume
arm
rst
symposium
principled
interpolating
synthesized
vision
reconstructions
neff
corvalis
kinematic
nakamura
bayesian
angeles
correspondences
interpolates
zoran
ps
reconstruction
optimize
heuristic
gradients
realtime
feet
july
de
novel
los
04
noise
tells
nearby
neal
subtracted
hughes
warped
verbs
regression
sg
ned
video
02
scaling
sheng
mao
numerical
nd
reconstruct
soft
warping
qin
alternates
mouse
1978
constraints
california
y1
animated
marker
active set
motion capture
the sgplvm
new poses
the active
latent space
gaussian process
human motion
computer animation
style based
the training
process latent
training data
poses are
latent variable
inverse kinematics
objective function
model parameters
eurographics symposium
graphics tog
tog v
acm siggraph
the latent
siggraph eurographics
poses in
based ik
training poses
original poses
new pose
on graphics
gaussian processes
the pose
3 july
the character
numerical optimization
speci c
variable model
sgplvm model
gp model
scaled gaussian
lawrence 2004
the gp
over tting
2006 vienna
baseball pitch
animation september
joint angles
de ne
04 2006
vienna austria
data sets
real time
the model
from 2d
2006 acm
an sgplvm
character posing
the baseball
likely pose
handle constraints
interactive character
jovan popovi
xi wk
poses given
missing markers
each pose
and wk
pose synthesis
02 04
on computer
our system
the likelihood
september 02
2d image
x values
p y
the learning
likelihood of
hard constraints
kernel matrix
ef cient
tting and
of poses
motion data
virtual humans
select new
a 2d
july 2005
feature vector
the 2006
motion synthesis
the 2d
v 24
24 n
set points
a learned
xi and
learn the
for learning
acm transactions
likelihood function
the parameters
articulated figure
motion transformation
mackay 1998
posing from
capture with
ps y
2d constraints
motion graphs
conventional pca
model sgplvm
capture poses
these 2d
xi values
of lik
lgp is
log posterior
an mog
mog model
and acceleration
sgplvm and
trajectory keyframing
time motion
the xi
automated extraction
character pose
symposium on
kernel function
the unknowns
animation proceedings
x x
y q
parameters of
animation of
y 0
low dimensional
and parameterization
learned model
aaron hertzmann
poses we
xi yi
ik we
automatically synthesized
dif cult
yi we
by lawrence
poses the
soft constraints
of human
space of
we rst
latent variables
july 29
variable models
a speci
the interpolated
of character
31 2005
2005 los
the animator
motion by
pose from
small data
learn a
c q
optimization algorithm
proceedings of
of motion
the space
the features
neural networks
y 1
ne the
motions in
variance 2
learning we
to learn
an objective
animation july
of motions
an interpolation
of articulated
are nearby
with missing
new active
parameterization of
optimization of
learning algorithm
learning process
in real
procedure for
training set
this objective
velocity and
learned from
as described
constraints in
learning p
interpolation of
the active set
process latent variable
gaussian process latent
transactions on graphics
graphics tog v
on graphics tog
siggraph eurographics symposium
eurographics symposium on
on computer animation
acm siggraph eurographics
symposium on computer
the latent space
style based ik
the original poses
n 3 july
3 july 2005
tog v 24
computer animation september
2006 acm siggraph
september 02 04
2006 vienna austria
04 2006 vienna
animation september 02
latent variable model
24 n 3
the model parameters
02 04 2006
in the active
the 2006 acm
the training data
constraints in real
the sgplvm model
interactive character posing
active set points
of motion capture
most likely pose
p y 0
scaled gaussian process
the parameters of
of the 2006
acm transactions on
v 24 n
of the training
the likelihood of
the space of
proceedings of the
x x x
in real time
training data the
animation proceedings of
this objective function
real time motion
automated extraction and
to the unknowns
of motions in
of the character
motions in large
motion capture with
motion capture poses
space of poses
the training poses
of poses in
variable model sgplvm
c q 0
the baseball pitch
of the sgplvm
over tting and
in large data
the joint angles
select new active
capture with missing
extraction and parameterization
parameterization of motions
the objective function
small data sets
an objective function
parameters of the
and parameterization of
a speci c
numerical optimization of
the gaussian process
new active set
in the latent
the kernel matrix
from a 2d
the most likely
a 2d image
animation july 29
latent variable models
2005 los angeles
29 31 2005
31 2005 los
of human motion
2005 acm siggraph
de ne the
july 29 31
as described in
position and orientation
to be sensitive
large data sets
the training set
computer animation july
with respect to
for small data
tells us how
machine learning p
conference on machine
of the 2005
in the 2d
be sensitive to
on machine learning
to learn a
of the original
we nd that
los angeles california
applications interactive character
of human poses
to immediate 3d
parametric hidden markov
for all examples
a statistical image
human motion for
purpose probability distribution
o hagan 1978
for virtual humans
a more principled
with missing markers
background on gaussian
automatically synthesized motion
character posing trajectory
the latent variables
by knowledge enhanced
knowledge enhanced motion
for exploring expressive
virtual humans from
motion transformation inferring
have been learned
poses and the
time motion capture
optimization of lgp
we learn the
gesticulation behaviors for
motion by knowledge
learned we have
sigchi international conference
the full optimization
pose qi has
satisfying those constraints
c karen liu
interpolation parameter s
of the gp
the character pose
shadow puppetry motion
the scaled gaussian
3d structure with
eugene fiume methods
chen mao sheng
kinematics system based
yamane and nakamura
of legged figures
williams and rasmussen
of avatars animated
hughes spatial keyframing
negative log posterior
f hughes spatial
rasmussen 1996 for
liu aaron hertzmann
the mouse in
posing from a
interactive control of
global position and
points yi we
a gp model
enhanced motion transformation
set we then
latent space in
for synthesis and
nocedal and wright
on gaussian processes
animated with human
an annealing like
active set this
poses in the
ln 2 x
general purpose probability
the new pose
the gp model
motion synthesis from
on a learned
local minima during
describes the mapping
storyboarding to immediate
wright sketching out
points are more
hertzmann zoran popovi
ln p y
david k wright
inferring 3d structure
aaron hertzmann zoran
articulated figure motion

corpus/krapavin2000-test/1016052.txt
quicksort
parametric
roots
sorting
cole
echet
megiddo
comparisons
nlogn
proc_f
godau
spawn
polygonal
logp
fr
cgal
batch
batches
generic
outcome
bitonic
alt
pivot
logn
comparison_base
search
pt
aks
mn
resolve
memfun_1
resolving
median
decision
array
valiant
curves
sort
mnlog
memfun_2
process_base
collect
running
member
batching
resolved
scheduler
suspending
registered
ellipses
calls
permuting
g3
polynomials
resuming
geometric
leda_real
leash
solves
concrete
parallelism
distance
curve
binary
processes
lie
slope
sharir
monotonous
progressively
interval
intersections
resume
void
g2
g1
serial
1980s
iterations
fashion
optimization
complicated
arrays
toledo
abort
invocations
care
diagram
batched
slowing
implementing
items
double
resumed
dog
sub
euclidean
finished
representable
walking
doesn
considerably
suspended
merge
diameter
lg
agarwal
processors
monotone
sign
isn
96
squares
128
public
pointers
repetitions
progresses
tells
asymptotic
randomization
explain
attain
advocated
advice
root
sorted
tutorial
hidden
crewpram
erew
schwerdt
5055
clogn
proc_h3
commanded
preparata
proc_g3
fortu
lognloglogn
shame
f16
proc_h1
theoreticians
proc_g2
logk
proc_g1
proc_h2
stw
seem
drawbacks
italic
suffices
collision
child
moving
proximity
illustration
recursion
gave
cited
critical
man
uif
leda
128g
disrupts
685
671
084
frchet
088
072
late
fewer
implement
boundaries
randomly
leiserson
logm
pram
014
nately
1970s
042
663
469
cormen
workings
spawned
518
704
his
consecutive
unknown
sorts
collecting
rivest
013
commented
parametric search
based parametric
the roots
sorting based
generic algorithm
fr echet
binary search
echet distance
the fr
the generic
of parametric
a s
cole s
s optimization
sorting algorithms
the decision
o nlogn
running time
polygonal curves
decision problem
the comparisons
decision process
search fashion
and godau
the outcome
parallel sorting
of roots
pivot element
quicksort based
outcome of
o pt
nlogn t
the framework
the pivot
alt and
comparisons in
parallel steps
sub array
roots are
these roots
the running
two sorting
spawn new
pt p
distance problem
that quicksort
l l
bitonic sort
t s
of calls
the batches
expected running
p l
on parametric
to batch
sub arrays
the aks
decision algorithm
aks network
long double
search framework
two polygonal
roots is
s logn
godau 3
in sorting
roots in
calls to
resolve the
sorting algorithm
critical values
f l
the sorting
search is
the parametric
l is
the median
running times
cole 9
implementing algorithms
quicksort as
optimization 9
roots associated
slope selection
s logp
quicksort can
from comparison_base
polygonal curve
p t
takes care
the comparison
batch of
value l
is o
of quicksort
for parametric
geometric optimization
comparisons made
megiddo s
use quicksort
p j
a binary
of comparisons
the scheduler
applications of
the concrete
o mn
search approach
three functions
member functions
concrete version
this determines
p i
on l
and resolve
been resolved
input size
algorithms that
roots of
comparisons and
that seem
in line
search the
that solves
the technique
explain his
progressively smaller
o logp
technique 16
all comparisons
megiddo 16
moving points
roots r
associated roots
number type
all roots
quicksort has
consecutive roots
o mnlog
parallel merge
minimum diameter
randomly permuting
ellipses with
often suggested
search 0
by megiddo
batch comparisons
child processes
batching of
from alt
that megiddo
care of
the input
t p
functions in
optimization technique
merge sort
class derived
member function
to o
search can
n processors
solves the
l 0
search we
by alt
comparisons that
sorting networks
the parallel
l the
we implemented
the o
in step
permuting the
o notation
s log
squares in
o logn
version a
to collect
our framework
framework that
run a
the diagram
far and
interval that
the expected
in o
i p
of o
comparisons for
seem reasonable
reasonable in
o n
execution of
step i
framework to
the array
the intersections
the squares
based parametric search
of parametric search
the generic algorithm
sorting based parametric
fr echet distance
the fr echet
as the generic
cole s optimization
the decision process
of the roots
the decision problem
the outcome of
binary search fashion
the pivot element
alt and godau
of the decision
a binary search
applications of parametric
nlogn t s
o nlogn t
parametric search is
number of calls
outcome of the
of a s
in a binary
of calls to
two sorting algorithms
o pt p
the parametric search
the running time
expected running time
parallel sorting algorithms
on parametric search
echet distance between
number of roots
generic algorithm in
quicksort based parametric
the aks network
t s logn
parametric search framework
parametric search the
p t s
and godau 3
functions in line
in sorting based
pt p t
the binary search
two polygonal curves
of the generic
roots of p
the roots are
calls to the
p l is
resolve the comparisons
comparisons made by
with the framework
t s logp
a long double
that the roots
based on parametric
binary search approach
call a s
of o nlogn
roots associated with
parametric search can
echet distance problem
sorting algorithms that
quicksort as the
o n processors
for parametric search
the two sorting
the decision algorithm
s optimization 9
algorithm in sorting
running time of
to a s
takes care of
of the comparison
to the decision
value of l
and p j
the concrete version
the roots in
determine the outcome
algorithm a s
i and p
have been resolved
this determines the
p t p
calls to a
of p i
p and q
use quicksort as
that quicksort can
over the batches
the interval that
roots in a
these roots is
show that quicksort
then p l
that we implement
certain conditions that
a s on
seem reasonable in
parametric search we
is o pt
t s log
of sorting based
polygonal curves of
between two polygonal
quicksort can be
is often suggested
running times that
randomly permuting the
to o nlogn
we use quicksort
two consecutive roots
cole 9 shows
if p l
a s that
from alt and
median of lines
parametric search in
s that solves
ellipses with the
the minimum diameter
binary search 0
to batch comparisons
critical values in
the roots associated
time of parametric
as the aks
the comparisons made
a s will
parallel merge sort
decision problem p
all l l
solves the decision
reasonable in practice
roots are uniformly
by alt and
permuting the input
batch of roots
for sorting based
bounds on l
class derived from
batching of comparisons
that seem reasonable
derived from comparison_base
conditions that seem
a polygonal curve
the three functions
each sub array
for all roots
with the boundaries
computing the fr
the roots of
used as the
as the pivot
the parallel sorting
the comparisons in
the squares in
known to lie
l l 0
class that we
l is known
that the comparisons
i p j
in which l
determines the outcome
that solves the
p i and
use the framework
in the o
times that are
invocations of the
in line 4
which l is
the comparisons that
of the squares
squares in the
decision process for
l l l
running time is
so far and
sign of a
the expected running
the o notation
decision problem for
l is true
a s in
p l 0
the intersections of
0 to m
the number of
paper we show
a parallel version
s t s
the functions in
the sign of

corpus/krapavin2000-test/1016179.txt
cedf
wfq
session
packet
sessions
hop
delay
deadlines
rate
percentile
deadline
1030507090110130150
server
98th
ae
lights
hops
packets
edf
traffic
gm
rpps
03
additive
token
earliest
queueing
service
multiplicative
delays
coordination
randomness
servers
link
burst
coordinated
scheduling
injection
tokens
protocol
4l
inj
disciplines
ki
analytical
98
parekh
backlogged
liebeherr
gps
fig
green
fair
fifo
discipline
network
rand
conserving
leighton
sharing
qos
ferrari
bits
tenet
lmax
gallager
erin
andez
fern
switching
rates
congestion
serviced
networks
plots
georgiadis
prev
preemptive
oe
services
admission
ring
light
curves
obtains
vin
maggs
leaky
manhattan
shaping
goyal
verma
accumulate
links
weighted
1ms
car
processor
rabani
paths
double
cbr
1mb
jitter
mk
figures
integrated
simulation
bounds
coexist
passes
cut
gu
quickly
suffer
injected
interfering
subsequent
randomization
40
robin
bucket
emphasize
configuration
success
plot
sivarajan
gm1
wrege
harchol
richa
simistic
hluchyj
pgps
maxft
essentiallyae
1245
ostrovsky
golestani
cipline
balter
1000b
priority
dead
utilization
scenarios
probabilistic
italic
interfere
neighboring
comparable
outperform
antonio
off
incremented
routing
waiting
entering
red
switched
reshaping
unconsumed
strained
reshaped
wrr
peris
grossglauser
ofae
buffer
achievable
generalized
suffers
suite
delayed
contention
theta
contend
tention
kurose
jorg
passed
successful
buffers
emulates
pes
shenker
keshav
tardos
mth
stamping
spread
networking
showed
traversing
behaves
avenue
cruz
ther
towsley
slopes
rate 0
delay bound
session i
s cedf
long session
03 rate
1 rate
end delay
mean delay
15 rate
0 03
session length
length rate
to end
end to
the deadlines
hop sessions
1 hop
0 15
delay due
4 rate
6 rate
a packet
of wfq
3 rate
2 rate
delay bounds
the long
98 percentile
long sessions
processor sharing
i packet
percentile delay
7 fig
fair queueing
hop delay
to wfq
additive bound
earliest deadline
98th percentile
k i
ae i
1030507090110130150 98th
percentile session
delay session
generalized processor
weighted fair
wfq 1030507090110130150
0 7
a session
all sessions
multiple long
server m
integrated services
each link
the packet
under wfq
session rate
hop paths
probabilistic on
wfq and
of cedf
40 hop
cedf the
0 6
theta k
each session
the network
the bound
first server
under s
off source
deadline first
0 4
delay of
0 2
an additive
for session
burst size
0 3
r m
session due
analytical bound
services networks
servers quickly
multiplicative bound
subsequent servers
delay guarantees
for wfq
packet service
sharing approach
ae s
per session
packet switching
0 1
deadlines are
our protocol
hop path
multiple hop
double link
link network
network rate
bound of
a server
on off
curves for
the delays
15 fig
its subsequent
a delay
the session
packet with
in integrated
scheduling discipline
single hop
that once
the multiplicative
the analytical
the additive
server it
to flow
the 1
the curves
form 1
analytical bounds
4l i
coordinated earliest
delay guarantee
cedf is
1030507090110130150 mean
packet passes
rpps in
simple coordination
uniform packet
small burst
gives priority
cedf 1030507090110130150
additive delay
non cut
session processing
simple cedf
the gm
work conserving
i ki
gm s
in packet
oe i
the delay
deadline for
packet size
speed networks
to s
the earliest
the sessions
meet all
actual delays
packet p
rate ae
sessions have
size oe
sessions at
each server
bound for
randomness is
of sessions
service time
scheduling in
flow control
through its
2 fig
the traffic
packets are
packet is
packet from
each hop
cut through
packet has
of session
packet sizes
simulation results
a multiplicative
through all
1 theta
bound 1
bounds in
once a
deadlines for
can pass
its first
chosen from
protocol is
bound in
the protocol
for networks
passed through
success probability
real time
t i
all packets
each packet
1 rate 0
0 03 rate
rate 0 1
0 1 rate
rate 0 15
03 rate 0
the long session
rate 0 03
to end delay
15 rate 0
0 15 rate
rate 0 2
end to end
session length rate
length rate 0
delay due to
0 6 rate
3 rate 0
2 rate 0
rate 0 7
0 4 rate
6 rate 0
rate 0 3
0 2 rate
0 3 rate
4 rate 0
rate 0 6
rate 0 4
0 7 fig
1 hop sessions
session i packet
to s cedf
98 percentile delay
due to wfq
due to s
the 1 hop
of the long
mean delay due
delay session length
an additive bound
1030507090110130150 98th percentile
weighted fair queueing
generalized processor sharing
98th percentile session
percentile delay due
multiple long sessions
to wfq 1030507090110130150
percentile session length
a session i
probabilistic on off
theta k i
under s cedf
the curves for
on off source
earliest deadline first
delay of the
end delay bound
a delay bound
long session due
its subsequent servers
session due to
mean delay session
control in integrated
subsequent servers quickly
in integrated services
first server it
packet service time
through its first
double link network
1 theta k
the delay bound
deadlines are defined
of network rate
40 hop paths
0 15 fig
processor sharing approach
a generalized processor
delay bound of
length of network
s cedf the
network rate 0
integrated services networks
sharing approach to
from the long
its first server
the end to
the earliest deadline
each session i
through all its
once a packet
all its subsequent
for session i
to flow control
approach to flow
that once a
0 2 fig
in high speed
protocol is successful
cedf 1030507090110130150 98th
meet all their
the single hop
end delay bounds
s cedf 1030507090110130150
additive delay bound
out the deadlines
single hop delay
1 i ki
burst size oe
means that once
wfq 1030507090110130150 98th
has passed through
the multiple hop
size oe i
1030507090110130150 mean delay
of a session
non cut through
gives priority to
wfq 1030507090110130150 mean
the analytical bound
all their deadlines
the deadlines are
coordinated earliest deadline
all sessions have
rate ae i
of session i
mean delay of
a packet passes
it can pass
of wfq and
the gm s
to 0 8
services networks the
multiple hop delay
packet with the
pass through all
per session processing
flow control in
high speed networks
session i is
the packet with
packet from the
server it can
can pass through
i ae i
at each link
the deadline for
with the earliest
to the packet
curves for the
the protocol is
priority to the
the parameter is
number of servers
the bound for
the path of
k i and
bound of the
the form 1
networks with a
delay bounds in
network mean delay
small burst sizes
guarantees of o
ensure that once
fair queueing wfq
wfq scheduling discipline
delay bound is
session is likely
scheduling in packet
form 1 ae
processor sharing rpps
traffic entering the
and r m
hop delay bound
distributed packet switching
routing with per
link network mean
r mk log
time protocol suite
an integrated services
illustrate the end
long session is
cedf does not
hop path and
server utilization factor
not accumulate a
for time 1
comparable to their
integrated services packet
the multiplicative bound
the logarithmic term
must suffer delay
path of session
georgiadis gu erin
passed through its
a packet from
session rate ae
bound for cedf
packet delay guarantees
accumulate a delay

corpus/krapavin2000-test/1016210.txt
junta
vr
sided
1g
variation
juntas
coordinates
walk
queries
f0
detectable
permutation
probability
adaptive
rejects
independence
partition
testing
boolean
denition
accepts
subsets
dn
3r
accept
testable
rst
fourier
blocks
nz
jj
walks
kp
dependency
xj
summand
coordinate
reject
proposition
2er
learning
regards
ur
f1
distributions
soundness
singletons
monotonicity
cherno
block
claim
pcp
rejected
declared
isolated
negligible
degenerate
multiplicand
x2g
iterations
ces
su
query
2t
dependence
random
donation
passes
cients
2k
coe
pac
tests
abound
32k
jij
subsection
proven
pr
supposedly
dened
monomial
20k
expectation
uniformly
satises
accepted
lemma
ln
checkable
xed
chebyshev
poset
discard
poly
quadratic
randomly
detected
inequality
logarithmic
summands
log
permutations
ciently
deviation
inputs
jsj
contrary
fraction
monotone
proofs
characterizations
dene
polynomials
ja
probabilistically
summing
dominated
convolution
appendix
attribute
induced
equals
agrees
polynomially
ert
dictators
that4
2sh
1vr
showa
1906
proclaiming
4er
5the
qit
rubinfeld
qdenes
gutfreund
14conditioned
2rh
ncoordinates
16er
qwe
probability8
farness
cidence
uninformed
z2q
withapplications
hardness
harmonic
irrelevant
combinatorial
dier
odd
induction
biased
picks
shift
specically
characters
detect
advance
threshold
formulae
completeness
cient
equidistributed
abusing
undiscarded
sudan
1given
1if
7as
amplication
uential
subcubes
sidedness
subcube
bounded
fix
averaging
said
tilde
10k
cayley
approxima
goldwasser
i2x
chockler
amplied
walsh
1the
compact
dominates
cube
relaxed
discarded
subspace
k junta
with probability
vr f
probability at
independence test
1g n
the partition
subsets in
adaptive test
the test
size test
f0 1g
non adaptive
test with
a k
the independence
z q
partition i
least 2
sided test
two sided
permutation of
test rejects
variation at
b l
f is
of queries
at least
jj j
junta test
negligible variation
1 sided
random walk
i j
probability 1
the coordinates
least 1
f1 1g
testing algorithm
if f
of coordinates
on z
boolean function
a permutation
test to
the probability
junta is
whose variation
variation free
a junta
being a
2 f0
the blocks
the variation
f on
an k
that f
dependency on
test for
p t
property testing
the junta
step distribution
have variation
unique variation
1g q
that vr
detectable subsets
variation is
for every
least t
the walk
testing that
least k
f j
high probability
a boolean
probability that
non negligible
distribution p
that jj
sided error
most k
is at
set i
the adaptive
function h
walk on
the proof
iterations of
rejected with
n f1
declared variation
if vr
of detectable
j nz
not isolated
nz x
junta and
h iterations
ur f
fourier coe
kp t
junta then
with regards
regards to
the property
a random
a block
function f
any permutation
query complexity
bounded by
passes the
v j
of being
lower bound
at most
far from
testing algorithms
contains i
coordinate i
f passes
xj j
1 k
is bounded
it accepts
test that
q queries
proposition 3
the distributions
with high
a test
j 2
boolean functions
d p
variation of
the subsets
on k
error probability
input which
every k
as required
linear in
least 3
quadratic dependency
n boolean
coordinates into
test accepts
2er and
returns accept
on coordinates
invariant shift
partition whose
sided non
junta that
compact analysis
junta with
g xj
1 far
has variation
1g be
with variation
test is
test it
partition that
its variables
q 2
q 1
o k
have non
we reject
lemma 3
i r
j k
queries that
z x
k subsets
property of
of g
found to
proof of
of f
the check
one sided
p x
queries required
good then
satises p
2 sided
adaptive testing
1 fraction
queries made
rejects with
accepts every
accepts with
approximation parameter
distributions d
t 2
q we
a k junta
probability at least
with probability at
in the partition
the independence test
f0 1g n
subsets in the
the size test
least 2 3
number of queries
being a k
at least 2
the two sided
vr f j
the adaptive test
variation at least
for the property
f j 2
two sided test
if f is
a permutation of
non negligible variation
independence test to
test with probability
the partition i
jj j k
of the independence
with probability 1
is a k
at least 1
2 f0 1g
z q 2
a boolean function
property of being
of f on
an k junta
whose variation is
that f is
dependency on k
variation of f
f is a
the probability that
is at least
the property of
a non adaptive
i i r
of being a
lemma 3 3
iterations of the
according to k
on z q
partition i i
that jj j
non adaptive test
k junta test
linear in 1
permutation of g
that vr f
in 1 k
k junta is
at least t
at least k
probability 1 2
a set i
x 2 f0
with high probability
at most k
least 3 4
of the blocks
f is independent
random walk on
least 1 1
of the partition
test for the
with regards to
a random walk
1g n and
0 with probability
rejected with probability
if vr f
every k junta
1g n f1
found to depend
the test with
step distribution p
fourier coe cients
v j nz
number of detectable
n f1 1g
reject the input
j nz x
f passes the
testing that f
contains i j
k junta and
k junta then
variation is at
declared variation free
have non negligible
the subsets in
of queries that
least 1 2
the variation of
that the test
z q 1
on b l
we reject the
any permutation of
are at least
is a permutation
is bounded by
the random walk
the query complexity
1 with probability
permutation of a
the partition that
of the test
there are at
that a function
a test for
set of coordinates
p t 2
is found to
is far from
at least 3
that p t
is at most
i j is
then with probability
f1 1g q
have variation at
the unique variation
the test rejects
junta then it
sided non adaptive
2 assume on
depend on b
walk on z
2er and let
of queries made
j 2 assume
the step distribution
the test returns
returns accept with
dominated by j
test rejects with
t 2 k
h iterations of
kp t p
size test rejects
adaptive test the
more compact analysis
i r of
partition whose variation
the k junta
prove that jj
with variation at
not an k
that have non
g xj j
vr f i
every z and
distributions d p
the partition whose
an input which
b l is
a test with
log 2 r
junta with probability
if f passes
least a 1
quadratic dependency on
to a permutation
properties of boolean
test returns accept
partition that have
p and dn
how to test
accepts with probability
an invariant shift
uniformly from f0
a 1 sided
f1 1g be
let f f0
1g be a
is an k
permutation of h
is not isolated
accepts every k
k junta with
the coordinates into
1 far from
every i 2
1g n for
of detectable subsets
a function f
the probability of
to depend on
the coordinates in
the proof of

corpus/krapavin2000-test/1016490.txt
iso
surface
shrinkwrap
triangles
abc
curvature
triangulation
triangle
sphere
deltav
saddle
radius
penguin
surfaces
nowhere
voxel
ok
wyvill
skeleton
fi
unacceptable
fepts
edges
vertex
curve
rv
skeletal
raphson
acceptability
vertices
bloomentha
tesselation
mesh
penetrate
polygonisation
acceptable
newton
polygons
equilateral
spheres
edge
fflfi
splitting
plane
subdivided
adaptive
iterations
split
gradient
sectors
na
evaluations
samples
topological
ffl
nb
homeomorphic
thick
ab
gradually
1a
round
ae
cubic
triangulated
ci
extremes
perpendicular
sufficiently
0will
unlabel
fept
planes
ffi
normals
midpoint
sin
shape
spherical
plate
ray
nishimura
convex
intersecting
polygon
curved
shrink
bill
tracing
geometry
s1
gorithm
blended
grad
bloomenthal
rubbery
v0
convergence
86
segments
modelling
move
robustness
flat
quantitative
1f
minimise
sampling
smooth
gradients
accuracy
depicted
designates
taylor
geometric
sector
c2
tetrahedron
centres
normalised
fig
offset
adaptivity
appendix
holes
c1
regions
lay
cube
approximated
away
submission
ning
triangular
regards
multipliers
unnecessarily
elsewhere
phi
88
1d
deformations
cylinder
vicinity
neighbourhood
animation
beforehand
intersected
1e
behaviour
expansion
coordinate
stays
nc
visualise
onalised
perpendicularity
falsi
guin
polygonomial
topologicalchanges
additionaladvantage
tesselating
ruptures
cwamvo
coherant
ab96
bloomental
polyg
jeopardize
minkowsky
calgary
oversized
octtree
minimisation
culated
artihmetic
wards
kees
protruded
0from
9389
comparitive
overveld
occtree
cubical
rupture
polygonizing
eut
slender
regula
7640
graphicsjungle
shrinkingof
polygonisationof
polynomialsare
cylindrically
sederberg
accpetable
porcess
iso surface
the surface
the iso
fi k
triangle abc
iso surfaces
an iso
n steps
the shrinkwrap
curvature radius
a sphere
v r
shrinkwrap algorithm
with radius
v 0
triangulation ok
surface is
ae i
ok shrinkwrap
the penguin
curvature of
a triangle
the triangle
non acceptable
the curvature
saddle point
the triangulation
radius fi
triangles in
of iso
than fi
radius ae
iso value
newton raphson
function v
radius of
the plane
sphere with
surface with
r saddle
short edges
unacceptable edges
wyvill 86
rv r
surface cannot
local curvature
be sufficiently
edge is
round a
abc is
away than
a saddle
surface in
further away
of triangles
voxel based
function evaluations
do begin
to split
normal vectors
the algorithm
an edge
this curve
the triangles
topological changes
the gradient
surface this
0 k
of fepts
is nowhere
to shrinkwrap
split edges
edge ab
sphere round
of shrinkwrap
scale structure
underlying surface
acceptable edge
surface v
color plate
per triangle
shrinkwrap 3
v saddle
for acceptability
fflfi k
adaptive triangulation
splitting edges
polygonisation algorithms
offset surface
thick curve
of deltav
plane through
skeletal elements
shrinkwrap process
the vertices
convex polygons
r v
i v
v e
ray tracing
triangle a
phi p
each cube
all edges
the skeleton
the geometry
geometry of
surface for
b and
in fig
the final
surface the
point m
points line
statement s1
na and
acceptable the
a b
gradients in
surface a
4 iterations
a newton
sufficiently close
is adaptive
for fi
perpendicular to
v d
line segments
edges are
v v
surface which
triangular mesh
point r
all vertices
the radius
surface that
taylor expansion
adaptive algorithm
the extremes
the normal
value v
and c
plane of
iterations we
the sphere
triangulation of
few iterations
algorithm ffl
capture all
these points
vertices are
appendix b
make quantitative
three spheres
dashed thick
shrinkwrap 4
quantitative statements
shrinkwrap as
voxel boundaries
skeleton elements
value fi
skeleton element
fig 1f
vertices onto
and centres
many unnecessary
shape detail
initially unacceptable
adjust themselves
great train
equilateral triangles
of skeletal
e grad
shrinkwrap 2
average curvature
b topological
this regards
nowhere smaller
ab should
with voxel
with earlier
triangles that
circle sectors
v0 1
paper self
coarse outline
shrinkwrap a
triangulation shrinkwrap
surface should
affine arithmetic
be nowhere
all shape
incomplete triangulation
deltav is
new triangles
i designates
next v
higher iso
cannot penetrate
new unacceptable
the iso surface
of the surface
an iso surface
of the iso
the shrinkwrap algorithm
v 0 k
triangulation ok shrinkwrap
on the surface
the surface with
curvature of the
ae i v
of the shrinkwrap
with radius fi
than fi k
is non acceptable
radius fi k
radius ae i
with radius ae
i v 0
b and c
the local curvature
number of triangles
the surface is
how to split
that the iso
the triangle abc
iso surface is
function v r
a b and
to the surface
of the algorithm
a sphere with
a saddle point
of iso surfaces
further away than
of a sphere
that the surface
radius of the
of the triangle
value of v
in these points
the underlying surface
for fi k
of fi k
v r in
large scale structure
the shrinkwrap process
sphere with radius
to split edges
iso surface cannot
the curvature radius
the plane through
curvature radius of
value for fi
class of iso
to the iso
a newton raphson
an edge ab
should be sufficiently
ok shrinkwrap 3
the geometry of
of v 0
in order to
fi k and
triangulation of a
points line segments
v r v
for n steps
iso surface and
v v r
the algorithm ffl
the curvature of
perpendicular to the
of the triangulation
triangles in the
the surface for
to the plane
the radius of
the algorithm is
collection of points
cannot be too
to capture all
all edges are
in a point
the surface in
the plane of
a b c
close to the
3 or 4
for every vertex
the normal vectors
m 1 in
and p 3
how can we
geometry of the
should be taken
3 and similar
all edges c
number of fepts
gradients in these
unacceptable edge is
away than fi
scale structure of
now it suffices
i designates a
quantitative statements about
unacceptable edges may
the set ae
values v 0
final iso surface
surface cannot penetrate
surface has nowhere
non acceptable the
iso surface it
iso surface which
the sphere round
by abc is
k and centres
value of deltav
fi k from
been split but
surface similar as
segments and convex
of the triangles
value v saddle
this regards the
abc is bounded
paper self contained
set ae i
grad v v
nowhere smaller than
v e grad
since the iso
intersecting the surface
edges and triangles
make this paper
give a coarse
vertices are on
surface should be
a triangle is
an adaptive triangulation
and the plane
from a sphere
fi k for
this paper self
value for n
the average curvature
triangles that is
with earlier algorithms
edge ab should
b topological changes
iso surfaces for
split edges and
an unacceptable edge
approximated by abc
spheres with radius
great train rubbery
comparison with earlier
minimal value for
acceptability for an
local approximation of
ray tracing is
and the sphere
incomplete triangulation shrinkwrap
nowhere further away
higher iso value
for now it
m 0will be
unacceptable edges have
this condition should
split but new
and similar for
sphere round a
of points r
from the iso
next higher iso
and c with
triangulation shrinkwrap 2
a sample density
and centres a
the gradients in
surface for every
v0 1 0
appendix b topological
to make quantitative
that is approximated
surface in other
of skeletal elements
initially unacceptable edges
designated surface is
distance fflfi k
triangle abc the
an offset surface
ab should be
coarse outline of
for each triangle
less than fi
voxel based methods
shrinkwrap algorithm as
the designated surface

corpus/krapavin2000-test/1016857.txt
macros
mrflow
regexp
macro
format
schemeql
syntax
formatting
string
embedded
interpreters
tmp
stx
plt
match
matcher
runtime
languages
printf
cursor
continuation
invariants
interpreter
analyses
arguments
subs
drscheme
library
combinators
primitive
specifier
datum
dispatch
expression
lisp
positives
char
regular
lambda
statically
false
host
errors
combinator
language
clock
expressions
args
compiler
strings
lexical
identifier
transformer
cons
programmers
e1
flow
cayenne
hygienic
ghost
submatch
submatches
quoted
e2
expansion
hoc
unfolding
swap
tags
literal
guard
hex
aaa
subpatterns
exp
static
pseudo
template
append
contexts
programs
functional
substring
anal
ad
matched
specialize
primitives
program
partially
bbb
suc
parenthesized
query
id
hindley
componential
hygiene
hexadecimal
augustsson
unparsing
formatter
car
ysis
arrow
precision
guage
consume
matches
partial
programmer
subexpression
alternation
succeeds
prefixed
zzz
subpattern
subexpressions
spurious
lookup
abstract
rules
pattern
conservative
imprecise
analyzing
identifiers
simulates
specialized
ocaml
implementor
renames
compositionally
expand
expansions
laying
flagged
analyzer
disappear
tag
http
excerpt
flowing
argument
operator
raise
undetected
precise
accepts
invokes
debugger
kleene
referential
failure
milner
underlined
references
java
row
binds
arrows
flows
haskell
phone
lan
list
inspect
binding
contents
forms
syntactic
cond
specializing
conservatively
inside
overloading
gcd
checking
character
expanded
constructs
matching
displayed
expects
cess
branch
discover
wrong
branches
rewrite
transparency
invoked
text
edu
server
evaluated
success
object
exposed
url
regexp match
embedded languages
partial evaluation
the macro
regular expression
syntax object
the format
plt scheme
syntax rules
the embedded
host language
macro expansion
embedded interpreters
embedded programs
abstract value
if expression
syntax id
id rules
scheme macros
formatting string
the interpreters
at runtime
the regular
of embedded
partially evaluating
syntax case
format char
the analysis
static analysis
of format
macros to
embedded language
format specifier
failure continuation
format s
the formatting
format primitive
string append
stx syntax
compiler macros
lambda stx
let tmp
set based
dependent types
runtime the
three elements
the string
s exp
false positives
library functions
partially evaluated
macro system
a list
the syntax
a string
the if
a syntax
the interpreter
type system
a z
the primitive
object datum
define syntax
the schemeql
if expressions
lookup subs
cons lookup
pseudo type
in plt
dispatch on
macros and
value flow
case stx
of regexp
known statically
embedded program
transformer procedure
clock e
pseudo types
precise analysis
result list
and third
the host
in scheme
macros can
macros that
for scheme
specific embedded
format is
scheme s
ad hoc
regular expressions
substring s
analyses in
original function
additional arguments
based analysis
first argument
the result
flow analysis
program analysis
case dispatch
format function
for printf
analysis cannot
schemeql query
for mrflow
if tmp
tag corresponds
pattern guard
success continuation
or macro
drscheme s
z line
partially evaluate
runtime errors
macro template
append format
dispatch second
to format
closure analysis
format hex
tmp tmp
aaa bbb
spurious errors
second pattern
a schemeql
three embedded
formatting language
http a
third r
the plt
mrflow can
of schemeql
set clock
string given
and syntax
compute precise
bbb edu
match http
the partial
second and
to specialize
a macro
type checking
of arguments
expression and
the pattern
domain specific
expressions is
based program
evaluation to
match the
of scheme
macro that
interpreters with
their host
macros this
might evaluate
macros are
macro in
second r
imprecise analysis
macros the
of macros
macros in
a cursor
hoc manner
abstract values
scheme program
rules form
list of
string the
the list
the lexical
s syntax
expression language
term 3
the original
the false
precision of
errors that
the programmer
the precision
in embedded
present case
that constructs
string is
the match
an ad
character and
third are
the c
to match
the abstract
expression the
or false
the library
primitive is
as strings
the regular expression
syntax id rules
the partial evaluation
the host language
the if expression
of embedded languages
partial evaluation of
of the if
the formatting string
the format primitive
of the format
the result list
the abstract value
precise analysis of
at runtime the
cons lookup subs
lambda stx syntax
the format specifier
stx syntax case
syntax object datum
syntax case stx
dispatch on the
a syntax object
set based analysis
in plt scheme
evaluation of embedded
of regexp match
either a list
number of arguments
second and third
of the macro
specific embedded languages
the original function
partial evaluation to
the static analysis
a list of
if tmp tmp
the analysis cannot
based program analysis
string append format
for if expressions
regexp match is
three elements the
http a z
embedded languages we
syntax rules and
with a macro
of format is
value flow analysis
the embedded languages
the embedded programs
the second pattern
to partially evaluate
and syntax id
a z line
their host language
of embedded interpreters
the embedded program
regexp match http
embedded languages the
append format char
aaa bbb edu
regular expression language
three embedded languages
match http a
of a schemeql
host language we
rules and syntax
tag corresponds to
of scheme macros
case dispatch on
a schemeql query
to the original
the precision of
the macro expansion
using partial evaluation
ad hoc manner
flow of values
regular expression and
list of three
the term 3
imprecise analysis of
target of an
invariants that are
partial evaluation the
domain specific embedded
in the embedded
the syntax rules
of three elements
the result of
partial evaluation is
a list with
to the analysis
the cases where
an ad hoc
the present case
of partial evaluation
of the result
the c programming
in the result
a z a
the results of
in an ad
z a z
the target of
result of the
branch of the
to a list
the same program
the user s
the contents of
in the user
embedded interpreters with
format substring s
tmp e2 the
http aaa bbb
z line if
plt scheme s
raise syntax error
implemented as macros
the plt web
same program as
tmp e1 if
the analysis correctly
0 string append
derived expression forms
format s exp
can compute precise
each embedded language
closure analysis in
the three embedded
macros to partially
ad hoc solution
swap a b
might evaluate to
whether partial evaluation
embedded languages contain
these arguments must
a useful technique
programmers know that
flow sensitive analysis
graph that simulates
the analysis then
regexp match returns
formatting a class
match returns a
set clock e
of indexed submatches
one error because
by regexp match
and identifier a
abstract values that
the regexp match
the original functional
checking time to
enforced by their
syntax object representing
a string given
static analysis in
that the primitive
case stx swap
clock e clock
subs cons lookup
tmp tmp e2
let tmp b
format specifier is
value from flowing
flow into the
useful technique for
in application position
specialize dependent types
at type checking
embedded in scheme
tmp b set
web with high
returned by regexp
the syntax object
the value 3
r process url
analysis of regexp
dispatch second r
when format is
the precise analysis
2 regular expressions
e2 the macro
chain of cons
for regexp match
bbb edu zzz
regexp match figure
r dispatch second
a hindley milner
after partial evaluation
match a b
a transformer procedure
syntax rules form
a let tmp
specific languages and
object datum s
an explicit chain
regexp match a

corpus/krapavin2000-test/1016897.txt
ospf
heurospf
routing
unitospf
arcs
arc
invcapospf
flow
utilization
worldnet
phi
jxj
weight
capacity
randomospf
demand
tabu
opt
backbone
waxman
shortest
weights
canonical
capacities
destination
opt0
neighborhood
max
hashing
clause
diversification
mpls
paths
a2a
5000
demands
3sat
274
loads
splitting
packet
evenly
satisfiable
oblivious
611
inapproximability
load
hardness
uncap
going
traffic
units
zegura
routings
links
90
psi
hash
cycling
heuristic
fx
np
2jxj
calvert
cisco
internetworks
congested
flows
commodity
settings
outgoing
heuristics
splits
zemel
l2ospf
optospf
woodruff
52ff
search
literals
synthetic
recommended
rodrigues
router
collisions
internet
escape
descent
astad
dijkstra
leading
visited
projected
congestion
701
clauses
1997
graphs
glover
optimizing
setting
assignment
leaving
inversely
ramakrishnan
moves
normalized
jjxj
aly
otchel
ffc
tecchiolli
wess
capacitated
arcs2610140
arcs261014
bley
concrete
network
115
iv
intra
1993
optimize
iterations
uncapacitated
resorted
awduche
jp
balancing
path
incoming
gap
goes
occurrences
1996
x2x
rexford
evening
battiti
tables
associate
sent
exploration
sat
node
clever
proportional
gammaffi
pretty
vx
guiding
morning
stays
objective
maximal
gets
split
tx
jq
scalings
optimality
secondary
hard
800
nodes
spreads
sx
attributes
encountered
link
distance
fi
primes
distances
drawback
piecewise
vendor
protocol
scaled
leaf
approaching
winner
networks
cope
arriving
schemes
solutions
207
1979
00
decrease
closer
unit
spots
jn
jennifer
universal
ff
hour
max utilization
weight setting
ospf routing
local search
canonical flow
general routing
t x
unitospf heurospf
t worldnet
worldnet backbone
the ospf
of flow
ospf weight
jxj units
to t
search heuristic
phi a
p c
the flow
proposed at
tabu search
at t
shortest paths
our local
cost function
demand matrix
invcapospf unitospf
weight settings
w a
f x
v x
opt0 20
heurospf opt0
611 4
90 90
demand invcapospf
opt figure
utilization demand
heurospf opt
clause c
q x
optimal general
above capacity
setting problem
each arc
s x
function phi
4 max
weight equal
20 611
the max
an arc
shortest path
psi a
even splitting
c fx
the neighborhood
routing problem
normalized cost
optimal ospf
cost demand
non canonical
a satisfiable
demand unitospf
90 274
waxman graphs
arc a
units of
the oblivious
going through
the capacity
the optimal
np hard
is np
traffic flow
a demand
2 level
a weight
each clause
ospf weights
splitting flow
backbone with
through t
node u
a canonical
the arcs
flow corresponding
neighborhood structure
the capacities
commodity flow
for max
our cost
x and
flow to
the weights
from s
the load
arcs and
the cost
1 unit
cost phi
packet cost
optimizing ospf
flow going
flow leads
phi uncap
destination t
our concrete
satisfiable assignment
hashing tables
flow from
hard to
a w
in cost
unit of
through f
multi commodity
nodes and
w 0
the demand
paths going
v w
the weight
paths from
single weight
100 nodes
in ospf
the routing
l t
cost functions
a factor
or f
arcs in
00 0
utilization in
of cost
c a
heurospf is
oblivious heuristics
leaving u
improving moves
our heurospf
non improving
a2a psi
and waxman
destination pair
by cisco
level graphs
neighborhood exploration
other arcs
capacity jxj
source destination
not split
optimal cost
leading to
u v
the paths
flow between
all paths
x or
1 00
literals and
the demands
current solution
s t
unit weight
3 literals
50 nodes
level graph
of ospf
capacities are
intra domain
recommended by
clause has
to max
with 50
a a
a node
weights for
same weight
weights we
the shortest
cost of
routing is
x t
1 01
on shortest
cost factor
graph with
a flow
the network
s to
a clause
the clauses
a 2
theorem 4
load on
bit integer
traffic engineering
flow are
at t worldnet
t worldnet backbone
units of flow
ospf weight setting
the max utilization
our local search
local search heuristic
proposed at t
invcapospf unitospf heurospf
unit of flow
to t x
np hard to
it is np
max utilization demand
jxj units of
heurospf opt0 20
demand invcapospf unitospf
611 4 max
opt0 20 611
4 max utilization
unitospf heurospf opt
20 611 4
unitospf heurospf opt0
heurospf opt figure
a 2 a
s to t
p c fx
general routing problem
a canonical flow
cost function phi
t x or
weight setting problem
is np hard
weight equal to
the general routing
phi a a
demand unitospf heurospf
or f x
the proposed at
through t x
x or f
for max utilization
from s to
t x and
for each arc
a w a
x t x
the paths going
the ospf weight
our cost function
optimal general routing
a non canonical
the weight setting
psi a l
through f x
90 90 90
max utilization in
a weight equal
of the ospf
multi commodity flow
flow corresponding to
paths going through
a a 2
1 00 0
the optimal ospf
utilization demand invcapospf
a demand matrix
going through f
non canonical flow
the normalized cost
to max utilization
local search in
flow leads to
going through t
the canonical flow
hard to optimize
each clause c
arc a 2
of flow going
the flow to
path p c
shortest paths from
within a factor
if the flow
the optimal cost
100 nodes and
the 2 level
1 unit of
in ospf routing
the optimal general
each arc a
shortest paths to
f x and
normalized cost and
worldnet backbone with
optimal ospf routing
3 c a
source destination pair
a max utilization
clause has 3
optimizing ospf weights
setting with respect
h a w
cost demand invcapospf
where each clause
v x f
weight setting with
non improving moves
the other arcs
2 level graph
2 level graphs
50 nodes and
level graph with
graphs in figures
with 100 nodes
graph with 50
decrease in cost
of flow are
the oblivious heuristics
utilization demand unitospf
recommended by cisco
a satisfiable assignment
has 3 literals
pair s t
graph with 100
with 50 nodes
and waxman graphs
a2a psi a
flow are sent
in q x
to a max
q x and
we associate a
a local search
s x and
the shortest paths
a single weight
v x t
on shortest paths
each clause has
distance d t
1 01 0
u to t
does not split
equal to 3
the same weight
for the proposed
leading to a
cost of at
each node u
flow can be
to optimize the
dijkstra s algorithm
leads to a
hard to find
the current solution
x and t
and t x
of theorem 4
the same cost
flow to t
canonical flow corresponding
literals and each
find even an
an approximately optimal
and jxj units
commodity flow routing
of the oblivious
701 800 of
if the canonical
ospf routing is
arcs leads to
of optimizing ospf
the even splitting
arc capacities are
of the demand
while the paths
3 literals and
have jxj units
satisfiable instance of
the direct path
woodruff and zemel
concrete objective function
optimize the ospf
the capacities of
the flow from
node u we
each p c
instance of max
our concrete objective
evenly splitting flow
to avoid cycling
a weight setting
paths p c
with our concrete
worldnet backbone as
for at t
function phi a
of ospf routing
demand matrix d

corpus/krapavin2000-test/1017155.txt
default
door
hd
defeasible
evidence
unblocked
conseq
videocamera
oe
compatible
observation
gammai
extensions
degr
defeated
refined
sensor
observations
84
logic
iff
consequent
readings
rules
cofinal
obs
prioritized
fusion
theories
qg
cumulative
proposition
satisfaction
incompatible
refining
cnd
robot
layered
obsi
sceptical
extension
rg
defeat
incomparable
sonar
fp
degrees
defaults
sigma
open
straight
normal
prerequisite
00
gamma
modelled
hm
numeric
pieces
reasoning
derivable
blocked
conflicting
ordering
nonmonotonic
directedness
closed
th
cautious
expectation
justification
interpretation
hf
79
image
reiter
logics
tautology
supplement
maximally
reality
inconsistent
sensory
interpreted
facts
notions
monotonicity
preferential
sensors
careful
priorities
proximity
minimal
regularity
mirroring
dg
rule
justified
priority
pg
fdg
ordinary
semantics
frg
believing
perception
founded
exceptions
induced
consistent
background
reading
agent
orderings
sentences
accordance
top
probabilistic
priori
interpretations
supposed
traditionally
play
believes
angle
intersection
applicable
minimality
ff
considerable
sight
satisfies
clause
bodies
argued
inference
behaviour
preferred
weaker
formulas
vision
expectations
deltai
prefence
gammaig
subsidized
unprioritized
restricitive
interpeted
harmonizing
bacground
pionier
disagreeing
harmonize
diffculty
stopperedness
subsymbolic
consitute
amended
consequence
sequentially
preference
belief
adequately
maximal
free
situation
stronger
incomplete
unreliable
justify
analogous
fi
acquired
underlying
intended
conclusions
tweety
perceptions
rendition
pgs
savage
poole
cetera
regular
possibilities
variants
concrete
additionally
refine
agents
consisting
62
insufficiently
servations
cancelling
pitman
reminder
withdraw
justifications
default rules
the door
observation models
observation theory
default theory
door is
observation model
an observation
more refined
default rule
of default
default logic
observation logic
free default
1 extensions
d 0
hd gammai
of d
normal free
the observation
e 0
refined evidence
refined than
degrees open
the default
oe e
model m
of hd
a default
straight observation
degr open
84 degrees
e 00
sensor fusion
level observation
observation based
videocamera image
gamma conseq
than e
m d
the evidence
extension of
consequent of
84 degr
th fp
of conclusions
is 84
well ordering
compatible extension
1 extension
defeasible observations
th f
one level
is open
ordering oe
theory hd
hd gamma
obs d
image taken
an extension
the satisfaction
first order
of evidence
rules are
default theories
q rg
and th
d iff
the consequent
conseq d
top less
conclusions supported
evidence than
compatible extensions
sensor readings
extended observation
the observations
of extensions
of observation
theory d
extensions of
m of
e is
normal default
theory has
a compatible
layered extension
conseq m
is defeated
compatible observation
extension th
consequence operation
observation theories
order models
th gamma
q e
d such
of extension
p e
theory is
m 0
gamma i
defeated by
the conclusions
d is
for default
specific proposition
open without
unblocked extension
for observation
minimal default
evidence underlying
logic using
rule d
prioritized default
gammai is
conflicting observations
on evidence
defeasible observation
information image
or 84
a videocamera
fusion process
cofinal observation
open 79
hm obsi
p q
of compatible
pieces of
background knowledge
of normal
is modelled
open is
evidence e
fp qg
unique extension
order model
d consisting
models of
a normal
conclusions of
e and
reasoning with
0 is
r e
observation is
of sensor
every model
and e
modelled by
observation that
less refined
observations oe
from considerable
th m
observation logics
gammai generated
the videocamera
prioritized normal
exact angle
m obs
open 84
other observations
multiple extension
rules representing
less observation
at close
unblocked extensions
considerable distance
correspond with
79 or
door that
model hm
layered extensions
f p
logic for
on more
conclusion that
compatible with
models m
that gamma
probabilistic interpretation
proposition 10
semantics for
interpretation of
that e
a robot
is called
the refining
a defeasible
fp q
is th
closed default
p qg
a prioritized
satisfaction relation
oe and
blocked by
the robot
the conclusion
the door is
that the door
an observation theory
of an observation
the default rules
of default rules
extension of d
default rules are
is more refined
door is open
normal free default
more refined than
observation model m
more refined evidence
m of d
84 degrees open
of hd gammai
is 84 degrees
door is 84
one level observation
a default rule
extension of hd
an observation model
84 degr open
observation based on
model m of
and e 0
the consequent of
a default theory
d 0 is
well ordering oe
observation models of
of the default
the default theory
be an observation
refined than e
videocamera image taken
hd gamma i
th f p
the observation theory
r e 00
consequent of d
models of an
q e 0
level observation models
straight observation models
conclusions supported by
compatible extension of
a normal free
set of conclusions
default rules of
refined evidence than
pieces of evidence
of a default
e is an
e and e
an extension of
of d such
d such that
free default logic
conseq m d
gamma conseq m
of sensor fusion
is a compatible
on more refined
satisfies the consequent
evidence than e
observation theory d
first order models
a compatible extension
e 0 is
a well ordering
default theory has
of default logic
0 is more
of d is
of observation models
extended observation models
oe e is
the observation logic
straight observation model
of d iff
observation model of
and th f
theory d consisting
free default rules
door is closed
a videocamera image
observation theory is
based on evidence
th fp qg
of d proof
0 of d
default rule d
set of default
degrees open and
first order model
of one level
information image of
hd gammai is
sensor fusion process
1 extension of
conclusion that the
based on more
is modelled by
by the observation
is an extension
default theory hd
d consisting of
default rules and
default theory is
default rule is
extensions of an
as a logic
the evidence e
layered extension of
th fp q
assumed to represent
taken from considerable
of normal free
observations oe e
theory hd gamma
1 extensions of
image taken from
hd gammai generated
m obs d
conseq d 0
rule is called
the conclusions supported
default rules representing
interpretation of default
from considerable distance
theory is regular
every model m
door that the
observation theory hd
by 1 extensions
multiple extension problem
open 84 degr
degr open 79
p q rg
an 1 extension
at close proximity
of proposition 10
obs d satisfies
situation of example
minimal default rules
of straight observation
to the door
is open without
m j d
observation logic using
fp q rg
situation is modelled
or 84 degr
gamma conseq d
using 1 extensions
the observation based
close proximity to
free default theory
top less observation
e 0 where
denotes the observation
rules of d
compatible observation models
on a videocamera
is e is
gammai generated by
of the door
the evidence underlying
default rules in
the multiple extension
observation model hm
of conclusions of
observation models m
the door that
79 or 84
logic using 1
of compatible observation
model hm obsi
an information image
0 where oe
theory hd gammai
proximity to the
level observation model
e 00 is
d d 0
the conclusion that
the satisfaction relation
observation that the
consisting of the
normal default theory
f p qg
proposition 10 the
notion of extension
given the evidence
oe e and
f p q
is open is
default logic is

corpus/krapavin2000-test/1017463.txt
nonfaulty
clock
pulse
clocks
processors
luck
processor
byzantine
pulses
faults
stabilizing
configuration
jumping
coin
averaging
synchronization
protocol
lc
toss
jump
period
5t
faulty
anchor
2t
protocols
wl
fault
tossing
drift
3f
synchronous
gammaf
chinese
synchronized
increments
intervenes
nonanchor
self
scheduler
increment
tosses
agreement
ffi
physical
message
ae
safe
dim
elapsed
transient
tolerant
interventions
tolerate
incremented
synchronizing
counter
receives
apart
fixes
assigns
88
blowup
multisets
messages
stabilization
dhs
game
midpoint
chooses
successive
lsp
intervene
melliar
multiset
executes
delta
gamma
wrap
reached
reliability
generals
randomized
permanent
collecting
reach
finds
assign
logical
dl
wraps
validity
stabilizes
wrapping
remainder
resumes
2f
86
presence
cope
severe
waits
received
halves
surrounded
sent
prime
lamport
election
pc
failures
semi
hs
inexact
mod
impossibility
reaching
reaches
lm
accelerate
destinations
round
converges
resilient
win
leader
synchronize
trip
kn
st
approximately
tamu
sheva
dij
2ae
napping
daliot
bgu
coan
incre
gurion
investigator
84105
halve
rsb
misbehave
drifts
9158478
absrtact
games
delay
91
arrive
triggered
unifying
realistic
85
temporary
tolerance
lemma
synchronizes
implementer
trueg
swami
garner
rhee
injong
84
unexpected
subsequently
responses
spite
wait
procedures
distinguished
rounds
smith
correctness
contradiction
pigeon
dolev
shlomi
presidential
reintegration
mented
beer
elapse
around
bounded
agree
omission
excellence
denver
ticks
residue
gp
ariel
funds
devices
execution
nonfaulty processors
clock values
clock value
the nonfaulty
nonfaulty processor
the clock
its clock
clock synchronization
physical clock
byzantine faults
clock i
self stabilizing
processor p
jump procedure
m lc
processors are
the averaging
clock of
s clock
the jump
of clock
every nonfaulty
averaging procedure
safe configuration
the clocks
a pulse
last increment
gamma f
a clock
pulse p
for clock
jumping period
a nonfaulty
the jumping
averaging function
a processor
p i
n gamma
clock j
a coin
the protocol
scheduler luck
within ffi
common pulse
wl 88
new clock
clocks of
stabilizing protocols
coin toss
the processors
the processor
p j
increments its
case 2
a safe
chinese remainder
faulty processors
logical clocks
the chinese
synchronous protocol
of byzantine
its physical
clocks are
first pulse
first configuration
jumping procedure
semi synchronous
synchronization protocols
n gammaf
most 2t
every pulse
bounded clocks
successive pulses
processor that
period of
processors to
clock by
2t r
remainder theorem
a configuration
synchronized in
clocks in
their clocks
every processor
the scheduler
the pulses
with clock
toss results
pulse in
p increments
of pulses
without tossing
clock drift
5t j
clock validity
a jumping
luck intervenes
anchor processors
tolerant clock
anchor processor
distributed counter
luck game
pulses are
processor measures
ffi from
fault tolerant
of faults
protocols that
are within
processor executes
a period
configuration in
our protocol
and clock
n 3f
0 receives
logical clock
tosses a
increment i
around when
value thus
expected time
the presence
by 1
the synchronous
are faulty
same clock
message system
executes the
value 0
at most
presence of
configuration is
processors have
two successive
is reached
transient faults
clock in
fault model
processors is
c 1
clock to
system reaches
least n
processor s
assign 0
clock agreement
reduced clock
tossing a
2t j
ffi range
of dim
approximate agreement
physical clocks
receives 0
randomized self
their clock
and fixes
r apart
within expected
from clock
synchronizing clocks
values list
dim 91
drift and
tolerant averaging
then luck
ffi 8
collecting clock
all nonfaulty
dim 95
symmetric clock
of luck
m pc
nonanchor processor
the message
when appropriate
small range
before p
each processor
p s
the range
value by
the coin
clock is
of faulty
of processors
processors with
has elapsed
two randomized
first protocol
clocks the
i chooses
jump function
else case
a bounded
0 to
1 without
values 0
in case
the nonfaulty processors
all the nonfaulty
the clock values
the jump procedure
nonfaulty processors are
of the nonfaulty
clock values of
of the jump
clock of a
n gamma f
a safe configuration
every nonfaulty processor
the averaging procedure
of the clock
nonfaulty processor p
its clock value
the clock of
presence of byzantine
increments its clock
a nonfaulty processor
case 2 2
self stabilizing protocols
its physical clock
of byzantine faults
processors are within
the clock value
clock values that
the chinese remainder
clock synchronization protocols
the jumping procedure
of clock values
new clock value
clock value of
nonfaulty processors to
at most 2t
the first pulse
p s clock
a clock value
least n gamma
its clock by
clock value by
to its clock
clock value thus
the first configuration
2 n gamma
a common pulse
clock values in
processor p i
in the presence
the clocks of
chinese remainder theorem
clocks in the
processor executes the
clocks of the
case 2 1
the presence of
processors with the
coin toss results
two successive pulses
tolerant clock synchronization
nonfaulty processors have
a pulse p
1 without tossing
clock synchronization in
the coin toss
of faulty processors
the clocks are
around when appropriate
range of clock
the new clock
p increments its
the scheduler luck
the logical clocks
clock by 1
of clock j
scheduler luck game
a jumping period
number of pulses
fault tolerant clock
configuration in which
a processor measures
same clock value
last increment i
the message system
the value of
in c 1
of the processors
presence of faults
period of length
tosses a coin
configuration is reached
of a 0
execution of the
system reaches a
the same clock
that are equal
than a third
of each other
the system reaches
between two successive
values that are
at least n
a small range
a processor p
1 last increment
real time elapsed
processors are faulty
most 2t r
the synchronous protocol
all the clock
two randomized self
clock values at
s clock is
nonfaulty processors in
clock values list
tolerant averaging function
collecting clock values
1 to its
clock value 0
a s clock
is a jumping
the symmetric clock
c 1 all
a configuration in
the reduced clock
2t r apart
clock values 0
and physical clock
the anchor processors
0 receives 0
tossing a coin
else case 2
randomized self stabilizing
all nonfaulty processors
for clock synchronization
the averaging function
p i chooses
for clock values
safe configuration is
pulse in which
within ffi from
executes the jump
6 n gammaf
a pulse in
byzantine faults a
the pulses are
synchronizing clocks in
a more severe
the jump function
nonfaulty processors with
fault tolerant averaging
reduced clock values
a period of
by the use
of all the
in case 2
the first protocol
that the clocks
take a step
state and physical
in the range
1 all the
value of a
value thus the
n 6 n
the processors are
within a small
the fault tolerant
follows the first
number of faulty
of p s
0 to m
lemma 3 1
to be 1
are equal to
third of the
the case 2
set of processors
2 2 2
of p j
of a processor
values of all
synchronous protocol a
t 1 ae
with clock values
pulse while the
pulses that is
clock drift and
nonfaulty processors is
wait free clock
achieving clock synchronization
a new fault
values vector 0
the previous pulse
states that after
of luck is
to their clocks
clock values is
assign 0 to
that in c

corpus/krapavin2000-test/1017478.txt
plugin
haskell
plugins
ghc
loader
loading
api
plugs
ghci
runtime
library
edsl
pdynload
edsls
interface
file
rsrc
module
host
parser
dsl
compilation
compiled
dynload
apitypeconstraint
stringprocessor
load
safe
linking
typing
loaded
import
stringprocplugin
languages
safety
libraries
polymorphic
emacs
stub
pantheon
typed
files
compiler
infrastructure
string
dsls
stringprocapi
obj
syntax
dynamic
resource
dynamically
configuration
pan
checker
dynamics
lightweight
unsafe
foreign
staged
hs
fromdynamic
python
putstrln
compiling
invoking
manager
err
scripting
language
symbol
object
expects
checksum
hi
statically
compile
hooks
reload
jvm
linker
package
interpreter
unchecked
circlereg
irc
hmake
hep
checking
dependencies
loads
code
ui
declarations
interactive
source
eval
plication
existential
exported
trust
glasgow
circle
export
num
typeable
reloading
marshalling
named
parse
loaders
chasing
attribution
ast
dependency
ty
monad
caml
clean
inference
lisp
modules
embedded
parsers
animc
mapm_
recompile
typecheck
incs
circleanim
______
writeout
plu
newtyconstraint
dlopen
yampa
mailconfigapi
impulses
session
ffi
animations
extensible
_
evaluator
temporary
ml
enables
slider
pkgs
frac
usr
caller
char
client
java
extension
wrap
plug
animation
generics
prompt
estonia
andersson
tallinn
tmp
bool
native
strings
author
applica
internally
luckily
str
apis
crash
int
functionality
cast
resolving
sigplan
shell
forall
snowbird
displaying
functional
ap
mod
arranges
advocate
music
radius
enabling
invokes
implements
name
dirac
transparently
flags
gui
default
the plugin
dynamic loader
a plugin
host application
plugin s
dynamic types
extension language
plugin library
ghc s
dynamic typing
a haskell
the haskell
the host
haskell plugins
our plugin
plugin source
type safety
in haskell
dynamic loading
extension languages
interface file
object code
type checking
dynamic type
compilation manager
plugin infrastructure
the application
the dynamic
type safe
of plugins
api interface
plugins in
of plugin
runtime system
domain specific
source code
type checker
the type
s dynamic
haskell source
staged type
the interface
the stub
configuration file
an application
specific languages
to load
type information
at runtime
type inference
a library
the compilation
object file
loader can
and plugin
objective c
of ghc
hi file
plugins and
the api
existential types
apitypeconstraint module
the apitypeconstraint
the compiler
runtime type
of haskell
object files
type dynamic
haskell compiler
interface files
dynamically loaded
to haskell
safety of
code into
application s
the object
and load
stringprocplugin done
interactive haskell
haskell code
the dsl
plugin as
haskell value
plugin resource
the ghc
plugin api
plugin code
plugin is
plugin interface
where import
and loading
make and
application and
error messages
user input
haskell as
a dsl
dynamically typed
dynamic linking
interface interface
embedded languages
source file
loader the
full type
haskell we
haskell is
type check
compiled and
is compiled
data interface
the ffi
an interface
abstract syntax
loading the
c program
statically typed
configuration files
of dynamic
application can
host language
a lightweight
the configuration
application author
haskell and
the checksum
ghc as
load obj
haskell interpreter
plugins using
plugin author
perform type
loaded plugins
of dynamics
plugins to
interface hi
export list
loading package
edsls and
package base
linking done
linking of
the edsl
ghc to
plugin to
lightweight parser
s configuration
haskell parser
following plugin
embedded domain
plugs is
using haskell
code plugins
mod rsrc
function named
temporary module
plugin where
c string
done loading
haskell p
external process
module name
plugins are
typed extension
plugin that
runtime compilation
an unchecked
unchecked load
in plugin
hs plugins
invokes ghc
by ghci
plugins that
invoking ghc
infrastructure library
the stringprocessor
safe plugins
dynamics implementation
haskell plugin
haskell environment
safe dynamic
polymorphic values
hs eval
function interface
base linking
type system
file is
loading of
a type
using dynamic
written in
types and
s address
and dynamic
invoking the
the glasgow
polymorphic languages
separate compilation
typing for
checking by
in polymorphic
the host application
the dynamic loader
the plugin s
of the plugin
the compilation manager
an extension language
the plugin library
the plugin source
s dynamic loader
the interface file
by the plugin
staged type inference
into the application
domain specific languages
our plugin library
the dynamic type
dynamic loader can
that the plugin
a plugin s
host application and
the apitypeconstraint module
type safety of
dynamic types and
runtime type checking
the plugin infrastructure
haskell source file
make and load
a haskell source
to the plugin
an interactive haskell
using dynamic types
our plugin infrastructure
data interface interface
plugins in haskell
dynamic loader the
the application s
s address space
in haskell we
and dynamic loading
the configuration file
the type safety
operating system s
form of dynamic
by the host
as a library
the type checker
plugin s interface
and objective c
of plugin code
where data interface
via the ffi
ghc s dynamic
interface hi file
loading the plugin
an unchecked load
application and plugin
in the stub
plugin library s
between the host
the application author
plugin infrastructure library
an external process
resource where import
haskell as an
loading package base
a host application
written in haskell
c and objective
type safe dynamic
of our plugin
on haskell p
of type dynamic
base linking done
the following plugin
type safe plugins
package base linking
extension languages and
typed extension language
compiling and loading
embedded domain specific
foreign function interface
the plugin author
as an extension
the application can
the glasgow haskell
the runtime system
workshop on haskell
dynamic typing in
glasgow haskell compiler
dynamic typing for
s source code
in polymorphic languages
the type information
dynamic loading of
a dynamic type
object code is
the object file
its source code
the java virtual
from the host
file i o
a statically typed
java virtual machine
the source code
languages such as
by the application
to an application
discuss the use
of the type
to type check
sigplan workshop on
acm sigplan workshop
to the application
in the interface
the use of
if a plugin
a symbol of
ghc base string
s recent support
obtains a handle
of generics and
symbol name but
plugin authors with
compiled and loaded
standard dynamics library
statically typed extension
the object loading
the correct symbol
a matching interface
the ghc runtime
correct symbol name
from the plugin
emacs the extensible
to compile load
building domain specific
interactive haskell environment
the api type
the value exported
differentiation with dirac
with the api
v load obj
of plugins using
5 type safety
module and library
expression plugin resource
dynamic loader to
lightweight implementation of
haskell and xml
the application base
mapm_ putstrln err
compilation manager to
functions from continuous
value exported by
using haskell plugins
load a plugin
haskell is used
generics and dynamics
type checking using
use the plugin
declarations from the
as safe as
plugins can be
plugins using dynamic
haskell compiler s
application configuration files
4 22 37
api interface this
ad hoc language
parts of ghc
ghc s recent
i o dynamic
the type representation
user friendly edsls
of a plugin
and white image
of staged type
of plugins in
canonical name of
sort 7 3
ghc runtime system
and type dependent
generate a plugin
s type checker
haskell execution platform
loop mod rsrc
host applica tion
plugin s functions
dynamically loaded plugins
object code into
haskell runtime system
manager is the
into a plugin
dynamically checked plugins
type checker on
can perform type
the plugin is
automatic differentiation with
plugin resource api
plugin s source
plugins in this

corpus/krapavin2000-test/1017779.txt
rem
event
algebra
events
composite
primitive
laws
occurrences
restriction
stream
expressions
policy
neg
occurrence
streams
subexpression
semantics
ak
detected
subexpressions
detection
instances
algebraic
reactive
operators
snoop
instant
erent
temporal
t5
detecting
invalidated
identifier
negation
operator
algebras
foreach
expression
comply
react
timber
frp
trivially
a4
resources
di
informally
refered
samos
esterel
alarm
disjunction
declarative
dis
interval
timing
logic
temperature
ode
justify
facilitate
resource
a5
pressions
ciency
cient
auxiliary
button
conditionals
notified
identifiers
restrictions
extent
store
calculus
intuitive
propagated
interpretation
conjunction
active
reasoning
reaction
simultaneous
transformed
a3
formal
sequences
correctly
petri
timeout
targets
nested
intuition
fee
meaning
responds
solicitor
anchez
lished
curs
v5
substitutive
consecu
augusto
timebase
compose
mn
instantaneous
dom
accordance
policies
transformation
equivalence
permission
unintended
subex
alent
unintuitive
dices
estab
0b
subexpres
galton
occurring
imperative
driven
violation
criteria
scenario
stating
singleton
ect
automata
semantically
occurences
repeatability
pressed
subscribe
alge
valid
statically
contradicts
proofs
erties
bra
reactions
stances
occured
primer
limitations
external
semantic
stored
detect
alarms
remembered
duction
databases
conditional
junction
pisa
expiration
equiv
behaviour
else
correlation
occurred
specification
copies
organised
clarified
oc
temporally
simplify
formalise
consumers
unrolled
expressive
separation
conformance
dition
reacts
mechanism
labeled
limited
stant
detectable
congruence
unified
presentation
formally
understand
database
attached
recursively
unsuitable
responding
retaining
eral
carefully
the algebra
restriction policy
event stream
composite events
event expressions
current instance
event streams
primitive event
an event
algebra semantics
primitive events
with limited
composite event
start t
temporal restriction
neg s
event expression
event instance
start time
event detection
for event
rem e
maximum start
an occurrence
q i
equivalent expressions
limited resources
s s
a i
rem a
algebraic laws
the operators
event instances
transformation algorithm
instance of
occurrences of
event occurrences
application logic
rem s
event algebra
of rem
time instant
occurrence of
algebra with
algebraic properties
b a
s t
the detected
algebra is
with start
limited memory
be detected
the restriction
a b
events can
a primitive
facilitate formal
u neg
for equivalent
streams s
end u
i ak
start u
event algebras
each identifier
and rem
is invalidated
detecting a
user of
s holds
end time
di erent
of b
t start
when restriction
and end
of algebraic
a j
of primitive
the instances
what extent
expressions a
the event
stream s
that facilitate
formal reasoning
single event
extent the
t t
instance is
interval based
active databases
foreach e
a followed
operators comply
event patterns
end s
is none
rem dis
identifier p
showing to
if rem
following laws
u start
valid restriction
rem neg
restriction policies
which detection
detected event
t5 start
end e
detected with
semantics and
the primitive
e j
with maximum
restriction is
declarative semantics
detection mechanism
each operator
algebra for
the expression
in e
event specification
the subexpressions
and justify
event types
event type
i variable
start s
an implementation
then a
the start
e i
expression as
instance with
instances with
ak a
end times
denoted a
for detecting
reactive systems
or if
to what
laws that
with intuition
the laws
l i
the composite
events in
t and
i a
reasoning and
s end
for sequences
of composite
i then
system should
else a
semantics by
a composite
b b
instances of
policy is
algebra to
comply with
t i
a t
of e
specification language
e cient
an expression
for composite
detection can
start of
the current
whole rather
our algebra
than detecting
many expressions
disjunction operator
specifying timing
treated uniformly
laws hold
stream specified
which rem
output instance
criteria under
transformed expression
expression equivalence
notified at
memory complexity
primitive instance
dis a
temperature alarm
matching instance
semantics described
detection algebra
intuition finally
with restriction
the restriction policy
of the algebra
the algebra semantics
the current instance
current instance of
b a b
an event stream
a b a
instance of b
maximum start time
with limited resources
neg s t
then a i
s s s
an occurrence of
a primitive event
to the detected
with maximum start
the algebra is
definition of rem
for event expressions
of algebraic laws
what extent the
occurrence of a
events can be
restriction is applied
for equivalent expressions
detected with limited
number of algebraic
facilitate formal reasoning
formal reasoning and
for event streams
event streams s
the expression as
event expressions a
u neg s
when restriction is
t start t
event stream s
rem a s
extent the operators
with limited memory
start t start
that facilitate formal
an event algebra
event instance is
by the algebra
an event instance
where a where
i then a
user of the
start time of
t t with
the composite event
start t and
a composite event
can be detected
to what extent
occurrences of a
in q i
a user of
is an event
or if there
to the expression
a s holds
rem e i
showing to what
which detection can
justify the algebra
a temporal restriction
of primitive event
a i ak
restriction policy is
rem neg s
the following laws
t with start
by showing to
a followed by
of time instant
reasoning and justify
primitive event stream
foreach e in
an event expression
event stream is
algebra semantics by
a i holds
e in q
rem s s
the operators comply
operators comply with
the event stream
i ak a
is an occurrence
the algebra to
there is none
transformation algorithm is
s end s
algebraic laws that
streams s and
a valid restriction
event specification language
else a i
start of time
semantics by showing
with start u
and justify the
start u start
the transformation algorithm
algebra is defined
valid restriction of
the primitive events
of a followed
instances of b
laws that facilitate
comply with intuition
the system should
of the operators
the algebra with
denoted a b
of composite events
expressions a and
in e e
of primitive events
timing constraints and
expression as a
be detected with
instance of e
e i a
in the definition
rather than to
s t and
the application logic
from the instances
q i then
a i then
occurrences of the
a where a
e e a
s t u
a single event
set is empty
algorithm for detecting
a t t
to 3 for
detection can be
start and end
with the restriction
of a composite
of the composite
i a j
the start of
in the expression
expressions can be
be performed with
the system that
of q i
the occurrences of
condition in the
of a that
di erent operator
if rem s
the value domains
individual operator occurrences
same start and
expressions to be
approaches to event
t 12 2
that responds to
and end t
separate the mechanism
detected event occurrences
j end e
a primitive instance
the detected occurrences
rem dis a
in the algebra
formal restriction policy
whole rather than
a restriction policy
refered to 3
identifier p p
an algebra with
is refered to
computes an event
handle this type
event stream specified
ak a i
criteria under which
a if ak
dis a j
a formal restriction
end times this
temporal restrictions can
through an expression
an imperative algorithm
restriction policy and
the primitive event
the transformed expression
intuition finally we
to be instantaneous

corpus/krapavin2000-test/1017794.txt
fft
fun
rets
dir
bind
staging
monadic
staged
rap
circuits
fftw
z1
liftcm
l1
generators
zy
circuit
abstract
optimizations
retn
ys
rec
metaocaml
lit
zx
l2
interpretation
mg
merge
floating
xs
multiplication
conc
mv_add
multiplications
hardware
posteriori
double
float
y0
stage
exp
ret
platform
add_s
expressivity
maybevalue
fpgas
safl
languages
resource
additions
reconfigurable
ta
monads
i1
code
generator
sv
duplication
configurable
annotations
y1
manifest
mvconc
sub_s
w_s
mult_s
quotations
add_a
tukey
power3
retn_v
unstaged
concrete_code
x_234
retn_va
__fun_def
r2
r1
cooley
verilog
ruby
ms
verifying
programmer
deployment
ocaml
concretization
mv
untyped
generation
fragment
constructs
operator
quadrant
fourier
abstraction
cos_signs
add_ta
add_sv
escaped
w_a
codelets
emir
fft_ms
csh
x1_235
hardwarec
merge_ms
sin_signs
xc6200
float_of_int
hml
hydra
abstract_code
herrmann
typed
language
brackets
_
avoids
unnecessary
tagged
static
haskell
realizable
avoiding
style
arithmetic
comprehending
asts
kiselyov
microarchitectural
inspecting
pi
escapes
cbn
subtractions
expressive
literal
bool
val
combinatorial
bindings
match
cf
temporaries
datatypes
cos
correctness
mult
specialisation
oleg
computations
recurrence
concrete
aware
library
verified
trivial
operators
programmable
naively
boundedness
safety
datatype
butterfly
interfaces
express
christoph
gcc
ensuring
functional
transform
generic
n1
viz
worlds
variant
discriminate
mul
intensional
guarantees
programs
unity
i2
lift
int
losing
gate
else
compiler
verification
sa
refinements
classifiers
imaginary
seeking
reusable
abstract interpretation
generated code
the fft
double double
let rec
bind rets
the staged
the generated
l1 l2
x z1
z1 fun
the code
fun x
mg l1
rap languages
bind mg
code value
bind liftcm
floating point
multi stage
a monadic
input vector
resource bounded
a posteriori
hardware description
deployment platform
the rap
in bind
staging constructs
aware programming
monadic style
resource aware
y fun
combinatorial circuits
the generation
of abstract
complex arithmetic
type system
bind f
y ys
posteriori optimizations
match l1
dir n
dir l1
configurable computing
z1 bind
l1 let
manifest interfaces
l2 match
b _
r1 i1
fun zx
i1 r2
a zy
zy b
fun z1
exp dir
zx a
fun zy
staging the
multiplications additions
point multiplications
zx bind
efficient circuits
by fftw
fft function
rec mg
static type
multiplication by
the generator
the multiplication
fast fourier
the abstract
abstract type
development platform
circuits by
xs y
power n
l2 with
code fragment
the deployment
the programmer
generation time
languages provide
abstract domain
guarantees about
x x
x xs
code duplication
1 0
partial evaluation
second stage
as let
description languages
cooley tukey
mg xs
w_s dir
retn v
stage computation
rets zx
type circuit
liftcm retn_va
mult_s w_s
tukey recurrence
look inside
mv_add x
programming rap
generated circuits
stage programming
fft circuits
concrete type
b rets
minimal example
specific optimizations
generated programs
else l
ys j
the fftw
x exp
_ rets
circuit realizable
monadic sharing
liftcm retn_v
of power3
y0 y1
zy bind
merge dir
1 fun
dir y0
merge ms
staging annotations
reconfigurable hardware
monadic library
fft ms
rets in
of float
at generation
fft dir
merge mv
fft the
ys bind
fft algorithm
the type
fourier transform
of verifying
domain specific
x any
type systems
xs ys
list length
code type
interpretation on
program generators
fun a
single assignment
for hardware
generation of
annotations to
for fft
complex number
if list
add s
verifying a
that abstract
to avoid
platform and
abstraction mechanisms
programmer to
computation and
code for
with x
the input
the monadic
interpretation and
of floating
circuits are
generator and
hardware design
j y
program the
function that
an expressive
for avoiding
circuits in
one one
code we
avoid the
more information
the correctness
rap type
mvconc x
cos is
tool as
fun y
the maybevalue
a rap
code resulting
connect operator
trivial operations
generated computations
the generated code
double double double
x z1 fun
mg l1 l2
of abstract interpretation
resource aware programming
the deployment platform
the input vector
use of abstract
fast fourier transform
dir n j
zx bind rets
the code value
z1 fun zx
l1 l2 match
l2 with x
z1 bind rets
the development platform
r1 i1 r2
language for hardware
xs y ys
zy b _
a posteriori optimizations
fun zx bind
z1 fun zy
let rec mg
floating point multiplications
l1 let rec
match l1 l2
fun z1 bind
x xs y
a zy b
in the fft
dir l1 let
zx a zy
l2 match l1
rec mg l1
with x xs
l1 l2 with
about the code
n j y
a single assignment
hardware description languages
1 0 1
the code fragment
0 1 0
the generation of
y ys bind
cooley tukey recurrence
abstract interpretation is
xs ys j
zy bind mg
b rets zx
y fun z1
bind mg l1
that abstract interpretation
j y fun
mg xs ys
generated by fftw
abstract interpretation on
bind mg xs
b _ rets
programming v 62
rets zx a
rets in bind
multi stage programming
else l in
mult_s w_s dir
avoid the generation
of the fft
at generation time
fun a b
a b rets
the code type
if list length
bind liftcm retn_v
1 fun a
dir y0 y1
abstract interpretation and
_ rets in
development platform and
aware programming rap
bind liftcm retn_va
a monadic style
concrete type to
w_s dir n
l if list
j 1 fun
ys j 1
in bind mg
domain specific optimizations
fun zy bind
in the code
of the generated
generated code we
the abstract type
generate the code
guarantees about the
the paper proposes
to avoid the
the programmer to
circuits in the
the abstract domain
number of floating
x x x
that the generated
the correctness of
of floating point
abstract interpretation of
more information about
62 n 1
information about the
computer programming v
section 2 1
to express a
science of computer
avoiding code duplication
the second circuit
advantage of configurable
round off errors
the fft algorithm
which is bool
expressed within the
y0 bind f
multiplications additions in
languages are primarily
the concrete type
power n 1
rec power n
code resulting from
x fun x
single assignment programming
use abstract interpretation
circuits by refinement
mv_add x y
treat the tool
of multiplications additions
monadic library for
embedding a microarchitectural
int __fun_def double
the staged function
solutions in configurable
intensional analysis of
of rap languages
else x power
seeking solutions in
language within haskell
bind f e
e fun y0
identity x to
i exp dir
in place update
rets sub_s x
space and functional
add staging annotations
x power n
return 0 the
of the rap
pi 2 i
non standard run
complex arithmetic functions
and functional in
the cooley tukey
mapping a single
the generated programs
circuits are correct
arithmetic circuits by
power n if
defined as let
fun y bind
to reconfigurable systems
the verification point
exp dir pi
the tool as
f l if
abstract interpretation just
l in bind
box in which
the density advantage
bind rets mult_s
o fun y1
to represent circuits
a posteriori optimization
staged fft function
the complex number
known at generation
4 point fft
that a posteriori
paper proposes the
language to reconfigurable
x any 1
l else l
l2 rets a
interpretation just as
array of four
sound reduction semantics
add_s x z1
computes the fft
bounded space and
the fast fourier

corpus/krapavin2000-test/1018238.txt
oading
surrogate
jvm
engine
device
mobile
inference
javanote
fuzzy
offloading
availmem
pervasive
remote
java
triggering
biomer
linguistic
stretch
platform
splitclass
bandwidth
wireless
lru
trigger
prototype
newmemsize
migrated
partition
monitoring
dence
partitioning
oaded
oad
availbw
plans
mb
devices
v1
delay
kb
interaction
heap
plan
rpc
vk
transparent
candidate
accesses
chaivm
coign
jvms
resource
composite
con
memory
adaptations
moderate
runtime
guration
msk
elevator
interactions
mbps
migration
trace
invocations
baseline
adaptive
hp
rpcs
footprint
utilization
membership
speci
rtt
modi
ef
vi
monitor
triggers
pm
ps
dia
driven
redhat
7500
gured
gurability
4150
isnative
delity
basement
jini
accessfreq
objects
ne
constrained
802
metrics
metric
ed
execution
relieving
mincut
5500
ck
decides
linux
master
relieve
discovery
native
grained
8000
overhead
traces
simulator
splitting
850
pulled
traf
wi
fidelity
laptop
slave
cant
decision
bytes
merged
editor
800
bi
eld
classes
multimedia
adaptability
ned
adaptation
service
selects
incurring
spectra
ubiquitous
transferred
degradation
edge
nition
v2
person
aware
module
1500
ce
cl
threads
object
overcoming
adaptively
rst
card
middleware
elds
article
developers
developer
crash
900
lifetime
delivering
merging
consumes
174
fv2
vng
behrooz
oads
uctuation
3002001000
msmax
creations
ride
fuzzi
shumao
puppeteer
lingvar
bmax
surrogates
placeholders
thinkpad
bandwidthrequirement
smert
kayak
monet
stairway
kalasapur
sesco
1diabiomer
insigni
upnp
shirazi
of oading
oading inference
inference engine
mobile device
the of
the surrogate
the mobile
oading platform
candidate partition
application execution
partition plan
execution graph
adaptive of
pervasive computing
oading system
fuzzy control
partition plans
wireless bandwidth
the fuzzy
oading triggering
average interaction
making approaches
different decision
decision making
program objects
interaction stretch
con dence
lru algorithm
oading delay
fuzzy trigger
the java
mobile devices
application partitioning
bandwidth requirement
memory size
remote data
constrained memory
availmem is
by as
in pervasive
linguistic variable
data accesses
trace driven
control model
memory constraint
object reference
the memory
oading rules
of oaded
partitioning cost
triggering inference
remote function
surrogate and
and availbw
stretch by
the javanote
fuzzy inference
splitting large
prototype experiments
of oad
threshold based
oading and
javanote application
memory utilization
java class
available memory
cost metric
the application
wireless network
a jvm
requirement by
be migrated
generic fuzzy
linguistic values
device and
the wireless
total memory
and remote
partitioning from
plan generation
membership function
execution time
memory sizes
the linguistic
much as
of total
memory is
memory of
total execution
then newmemsize
rpcs between
splitclass fuzzy
oading action
interaction delay
engine decides
baseline memory
two jvms
remote interaction
surrogate is
if availmem
time stretch
composite metric
comparison ratio
approaches figure
smaller memory
each jvm
oading decisions
monitoring overhead
the pervasive
bi k
device runs
and biomer
oading the
availbw is
surrogate discovery
new of
con guration
the lru
total bandwidth
fuzzy sets
as much
of memory
runtime of
a composite
computing environment
remote execution
with v1
8 mb
remote objects
for pervasive
ef cient
graph edge
graph node
objects should
partition selection
delay by
utilization on
memory footprint
java heap
hp s
large classes
heap the
triggers of
classes that
the baseline
large class
calls and
a surrogate
simple threshold
partition on
speci c
approach different
engine s
edge cost
new memory
by figure
the remote
the prototype
the execution
the partition
low is
modi ed
ne grained
numerical value
service composition
accesses and
control based
and decrease
resource constrained
fi k
by of
four different
for mobile
the monitoring
available bandwidth
current prototype
and stability
ieee 802
the inference
of candidate
by four
device to
fuzzy logic
name space
component based
function calls
device is
the master
the total
un optimized
surrogate can
slave device
oading prototype
7500 8000
the elevator
constrained devices
during application
for javanote
expensive application
application speci
the of oading
of oading inference
oading inference engine
the mobile device
of oading platform
on the mobile
adaptive of oading
of oading system
candidate partition plan
of oading triggering
decision making approaches
different decision making
candidate partition plans
the fuzzy control
of oading delay
average interaction stretch
by as much
fuzzy control model
total of oading
application execution graph
to the surrogate
the application execution
the memory constraint
of candidate partition
pervasive computing environment
the lru algorithm
of oading and
partition plan generation
the average interaction
the javanote application
in pervasive computing
of oading rules
generic fuzzy inference
runtime of oading
four different decision
fuzzy inference engine
in the of
as much as
memory size of
bandwidth requirement by
the execution graph
mobile device and
of total memory
total execution time
program objects should
on the surrogate
mobile device to
of oading decisions
splitting large classes
making approaches figure
utilization on the
into one node
requirement by as
simple threshold based
and data accesses
by the of
inference engine decides
by of oading
triggers of oading
the partition on
oading triggering inference
partition on the
the surrogate and
memory utilization on
approach different decision
inference engine s
if availmem is
the java class
new of oading
numerical value of
of oading the
the surrogate is
remote data accesses
of oading action
and availbw is
objects of two
decrease the bandwidth
the pervasive computing
by four different
the baseline memory
stretch by as
the monitoring overhead
the fuzzy trigger
interaction stretch by
new memory utilization
in the pervasive
the adaptive of
oading delay by
between the objects
objects should be
the numerical value
mobile device is
of two classes
the memory size
of memory of
the generic fuzzy
for mobile devices
the wireless network
total bandwidth requirement
the bandwidth requirement
the total execution
function calls and
of the java
the available memory
and decrease the
of the application
the total of
classes that are
reduce the average
of the of
selects the best
illustrated by figure
of the mobile
the objects of
the partitioning cost
to remote objects
framework for quality
the surrogate at
remote function calls
complete of oading
largest edge cost
linguistic variable availmem
of resource utilization
simulations and prototype
mobile device then
classes can reduce
available memory is
the con dence
2 resource monitoring
nition for the
4 surrogate discovery
oading platform the
between two jvms
application partitioning the
availmem is within
bandwidth requirements and
application execution monitoring
java classes that
trigger our approach
lru algorithm compared
4150 5500 7500
whether of oading
amount of free
a pervasive computing
from the surrogate
trigger approach different
the java classes
remote function call
that availmem belongs
and prototype experiments
if the numerical
stochastic con dence
inference engine uses
response time stretch
making problems in
the above candidate
s of oading
the splitclass algorithm
partitioning cost metric
expensive application rewriting
the java heap
requirements and interaction
a composite cost
each large class
transparent rpcs between
from another jvm
fuzzy control based
de nition for
resource constrained devices
the surrogate to
frequencies and have
system for mobile
best partition plan
the other jvm
con dence that
of oading can
neighbors of v1
a constrained memory
to support transparent
are directed back
memory of oading
uses a composite
the largest edge
should be triggered
the inference time
linguistic of oading
the linguistic variable
partition plans generated
dence values of
delay by as
linguistic value low
vi and vk
composite cost metric
con gurability and
target memory utilization
enable more precise
decision making problems
the composite metric
best partitioning from
availmem is low

corpus/krapavin2000-test/1018355.txt
ow
prf
cut
orphans
energy
potts
dinic
segmentation
vision
adoption
saturated
greig
restoration
sink
relabel
pixels
stereo
augmenting
image
parent
residual
bell
stage
seeds
push
augmentation
orphan
cuts
max
passive
terminals
combinatorial
3d
growth
min
minimization
labels
forest
liver
voxels
diamond
capacities
lung
goldberg
tests
africa
graphs
augmentations
fulkerson
energies
quad
images
2d
children
occlusions
edges
active
labelings
interactions
neighboring
edge
labeling
shortest
mr
parents
ford
photo
nd
interaction
pixel
signicantly
darbon
bangay
sigelle
jrme
rst
df
disparity
neighbors
paths
diversify
shaun
penalties
terminates
dierent
pushing
town
cape
terminal
source
augments
cardiac
segmentations
style
complexities
grow
mrf
saturates
jcj
acquire
flow
layers
tree
intensities
camera
2n
nodes
penalty
publications
i4
roots
nite
visualisation
invariants
occluded
reality
outperformed
links
reconstruction
minimized
segment
recognition
marc
restored
connect
label
fastest
originate
conguration
nj
ct
head
optimization
posterior
annealing
remained
breadth
michikawa
sri
livewire
512x512x5
ajit
grabcut
450mhz
morkel
fhp
2051
funka
chantelle
gool
bellquad
256x256x13
200x300
100100
satu
qiong
zhongfu
fujimori
512x512
hiromasa
cherkassky
gpu
512x256
geys
112136
indra
2042
levelable
south
mn
editing
barbara
santa
augmented
4th
scratch
pentium
gupta
imaging
medical
xiaoou
reuses
tarjan
zabih
recomputes
plugin
gimp
333mhz
lv
1164
diwan
ichiro
tomoyuki
tsukuba
ramin
veksler
gelautz
bleyer
imum
lobb
cut max
min cut
max ow
ow algorithms
the potts
h prf
adoption stage
non saturated
energy minimization
potts energy
push relabel
image restoration
q prf
growth stage
maximum ow
combinatorial optimization
in vision
search tree
the sink
graph cuts
active nodes
residual graph
greig et
augmenting paths
prf and
minimization methods
new parent
p q
the source
free nodes
the adoption
of labels
the residual
the growth
minimum cut
bell quad
dinic algorithm
energy 1
augmenting path
saturated edge
linear interactions
graph based
experimental tests
the search
standard algorithms
max flow
in combinatorial
in s
graph cut
tree s
algorithms on
computer vision
tree pair
saturated edges
segmentation examples
stage terminates
restoration with
head pair
ow algorithm
q 2n
parent q
interactions energy
augmentation stage
random pair
of energy
new algorithm
stage the
flow algorithms
edge p
neighboring pixels
active node
two terminals
on graphs
the graph
graphs in
12 2
ow from
based energy
via graph
vision the
sink is
from s
source to
g f
al 10
graph g
node p
t cut
to nd
a cut
s to
other min
new min
3d segmentation
children from
camera stereo
style push
passive nodes
residual capacities
cost cut
acquire new
valid parent
and dinic
of greig
seeds were
s t
running times
nd a
our new
image segmentation
source s
edges in
a labeling
new children
an orphan
edge q
n links
edge weights
our tests
ow problems
left image
the augmentation
sink t
this energy
object segmentation
and segmentation
the algorithm
of image
the active
minimum cost
and 3d
a graph
of neighboring
tests on
27 2006
were placed
two labels
vision in
stage is
the passive
path algorithm
the forest
segmentation by
graph structures
the nodes
the energy
our algorithm
the tests
labels is
by pushing
the segmentation
algorithms based
nodes in
of free
p from
ow in
interaction in
of combinatorial
a forest
this stage
vision v
cardiac mr
about graphs
2006 cape
the orphans
no active
relabel method
diamond and
orphans o
q add
links connect
interaction penalties
cut algorithms
in africa
restoration stereo
reality visualisation
nodes acquire
ow techniques
orphans may
style augmenting
interactive graph
orphans during
problem exact
vision graphs
no orphans
variation part
multi camera
pixels or
two terminal
consider image
standard min
research nj
on ford
passive the
reality 17
segmentation technique
18 13
t links
or voxels
relabel algorithms
min cut max
cut max ow
max ow algorithms
the search tree
greig et al
the potts energy
the adoption stage
energy minimization methods
the growth stage
number of labels
a new parent
the residual graph
h prf and
to the sink
from the source
in combinatorial optimization
residual graph g
ow algorithms on
search tree s
the maximum ow
source to the
from s to
s to t
graph based energy
non saturated edge
linear interactions energy
of free nodes
non saturated edges
p q 2n
of energy 1
max ow algorithm
based energy minimization
minimization methods in
image restoration with
the source to
the sink is
cut max flow
edge p q
edges in the
our new algorithm
graph g f
s t cut
set of free
pairs of neighboring
adoption stage is
min cut and
new children from
seeds were placed
of combinatorial optimization
a non saturated
methods in vision
prf and q
max flow algorithms
of the potts
growth stage the
other min cut
a maximum ow
new min cut
new parent q
max ow problems
with two terminals
of neighboring pixels
in vision in
graph based methods
edge q p
algorithms of combinatorial
cut and max
minimum cost cut
children from a
node p 2
and q prf
p in s
acquire new children
style push relabel
to nd a
applications in vision
nd a new
the minimum cut
ow from the
via graph cuts
the sink t
et al 10
algorithms on graphs
the source s
used to minimize
of edges in
on a graph
algorithms based on
of the graph
in the graph
graphs that are
in s the
can be minimized
the running times
that our algorithm
algorithm that we
number of augmentations
style augmenting paths
of labels layers
for q prf
jrme darbon marc
while working with
technique in 3
for min cut
relabel methods and
an active node
virtual reality visualisation
visualisation and interaction
two algorithms work
left image of
marc sigelle image
remains in s
relabel algorithm 9
push relabel algorithm
no active nodes
in the potts
than a large
the data term
maximum ow is
4 14 3
in both 2d
to a penalty
10 12 2
tests including the
growth stage terminates
push relabel algorithms
free nodes the
algorithms on 2d
graphs in vision
on augmenting paths
active nodes are
prf and dinic
two labels the
augmenting path algorithm
2d or 3d
sigelle image restoration
based on augmenting
image of random
restoration with discrete
with linear interactions
fulkerson style augmenting
disparity map for
push relabel method
we developed while
discrete constrained total
edges p q
forest the source
sink is found
ow algorithms of
rst cycle of
based on ford
in vision we
augmentation stage the
shortest augmenting path
the path found
saturated edge p
an orphan again
vision in section
along non saturated
consider image restoration
optimization is that
stereo and segmentation
maximum ow in
image restoration stereo
ford fulkerson style
of greig et
of other min
parent in s
orphans during the
interactive graph cuts
total variation part
12 2 in
of min cut
max ow techniques
add q to
stage terminates when
a p q
be minimized exactly
was signicantly faster
with discrete constrained
can not grow
at the initialization
all computer vision
the active nodes
including the results
constrained total variation
the residual capacities
all active nodes
into a forest
and algorithms based
maximum ow from
of random pair
with graph cuts
v p q
on ford fulkerson
and max ow
the graph cut
work consistently better
27 2006 cape
2006 cape town

corpus/krapavin2000-test/1018405.txt
adv
counterexample
discrepancy
res
comm
airdepth
disc
inputs
suc
assertions
assertion
rectangle
circuit
product
circuits
resource
depth
units
nrs94
xor
strong
fair
kr
weather
kd
protocols
nw94
decision
trees
lemma
fairness
forests
guessing
amplification
bits
protocol
imp95
prw97
hardness
forest
tensor
communication
rectangles
nisan
hard
repetition
yao
norm
erent
wigderson
spectral
imbalanced
kc
disjointness
xk
direct
orest
2qk
2qkr
gnw95
spending
computable
boolean
attempting
intuition
matrix
coordinates
core
proving
sided
item
ciently
bit
beneficial
raz
stronger
randomness
leaf
supposed
matrices
pseudorandom
players
unbiased
av
black
fraction
remark
unavoidable
contradict
gcd
di
vectors
inequality
plugging
su
intuitively
cd
queried
glance
eigenvalue
parnafes
bfs86
kn97
raz92
x2014
fv96
multiplicativity
yao82
leafs
repetitionmyampersand
lev85
cbit
cg88
stv99
smartly
impagliazzo
ks87
pw86
raz98
kthis
strengthenings
4528762
supposes
iw97
eigenvalues
coin
d2
lot
heads
generators
tree
x1
outputs
correctly
products
expectedly
rudich
qk
trapdoor
evan
unfairly
concatenation
restrictions
formulation
exclusive
correlating
contra
schwartz
conversations
probability
corollary
variant
imposing
setup
probabilistic
theoretic
proofs
cherno
unnatural
ruled
avi
countless
box
induction
restriction
roughly
distributional
airs
activates
induces
draw
resources
attempts
unpleasant
tempted
insures
unaware
advisor
correlate
unpublished
padding
flaw
existence
seems
preparing
textbook
unbalanced
unfair
coins
absolute
simplify
nice
quantity
impose
defects
ks
lemmas
impressive
weaken
fk
direct product
strong direct
the counterexample
product assertion
hard on
product assertions
decision trees
adv comm
communication protocols
r units
size s
compute f
the discrepancy
f k
product theorem
disc a
depth d
the resource
is hard
bit communication
low discrepancy
f airdepth
res r
communication complexity
a strong
decision tree
units of
discrepancy of
c bit
product question
communication protocol
hard core
xor lemma
suc res
comm c
fair decision
parallel repetition
of depth
for communication
on average
boolean circuits
the inputs
that adv
spectral norm
all functions
product results
adv res
s xor
repetition theorem
k decision
hardness amplification
this counterexample
the direct
circuit which
tensor product
counterexample is
computes f
f on
given r
fair if
probabilistic communication
assertions are
rectangle r
average for
a rectangle
f is
the rectangle
theorem for
the spectral
for fair
yao s
bits from
computational models
the function
the hard
resource and
sided discrepancy
suc size
that suc
rectangle such
fairness restriction
strong product
adv size
hard given
of nrs94
more units
product problem
airdepth kd
itself k
that disc
negative coordinates
given slightly
the tensor
function f
the circuit
di erent
a decision
our intuition
function 0
proof of
h y
fact 1
functions computed
proving strong
advantage greater
vectors such
general counterexample
to compute
function which
its inputs
inputs on
random guessing
assertions for
its resource
computed correctly
the advantage
of lemma
prove a
to denote
of fact
assertion for
d 1
0 1
the algorithm
matrix a
u v
have that
a communication
follows from
which attempts
item of
over random
k times
lemma 4
with probability
assertion is
attempting to
than r
of inputs
c a
trees of
the protocol
have h
with entries
with itself
now have
to prove
a function
one sided
fact 2
ask weather
assertion holds
assertion the
discrepancy then
depth kd
forest model
weather an
adv depth
stronger computational
easy given
decision forest
made formal
on yao
such assertions
item note
our counterexample
optimal direct
generally what
adv f
weak randomness
over guessing
k adv
counterexample has
nisan and
kd it
amplification techniques
from res
algorithm attempting
contradict our
formal in
decision forests
t av
r kr
forests of
over inputs
discrepancy using
erent inputs
spending a
too well
of prw97
of raz
r su
weather a
help bits
how imbalanced
comm kc
previous calculation
kr units
unbiased bits
average given
strong direct product
direct product assertions
direct product assertion
hard on average
a strong direct
is hard on
units of the
of the resource
to compute f
r units of
the direct product
denote the class
for communication protocols
direct product theorem
c bit communication
product theorem for
direct product question
the discrepancy of
f is hard
given r units
compute f on
fair decision trees
a decision tree
of depth d
which is hard
the spectral norm
the resource and
of the inputs
yao s xor
the counterexample is
parallel repetition theorem
attempting to compute
s xor lemma
prove a strong
a function 0
direct product results
bit communication protocol
on average for
of all functions
a function which
function which is
the circuit which
function 0 1
tensor product of
proof of lemma
probabilistic communication complexity
1 x k
c a d
class of all
the tensor product
to denote the
a communication protocol
that adv comm
bit communication protocols
is hard given
slightly more units
of fact 1
of the counterexample
product assertion for
have h y
in the counterexample
a with itself
a strong product
such that suc
product assertions are
that disc a
theorem for fair
resource and easy
attempts to compute
adv comm c
item of fact
f airdepth kd
given slightly more
the hard core
proving strong direct
a general counterexample
greater than p
with itself k
compute f k
product assertions for
0 1 l
for fair decision
itself k times
rectangle such that
direct product problem
be computed correctly
discrepancy of a
over random guessing
one sided discrepancy
hard given r
the rectangle r
of its inputs
decision trees of
functions computed by
now have that
advantage greater than
for decision trees
inputs on which
the class of
the assertion is
f k to
larger than r
matrix with entries
of the spectral
a i 1
of size s
trees of depth
x 1 x
the decision tree
number of inputs
compute the function
which attempts to
1 d k
d 1 d
we now have
on the function
follows from the
family of functions
a matrix a
a 2 is
the function f
x k is
on the algorithm
of a communication
computes f k
entries in 1
result of prw97
discrepancy then a
be stated this
words the circuit
on particular inputs
bound the discrepancy
weather a strong
size s f
a fairness restriction
strong product assertion
weather an input
assertion holds for
k decision trees
with r units
restrictions can we
di erent inputs
computations on di
all known proofs
adv f airdepth
for boolean circuits
made formal in
assertion for f
spending a lot
f airdepth d
generally what kind
to ask weather
comm c the
easy given slightly
every circuit of
disc a a
in size s
conclude that adv
all k inputs
assertions are true
of c bit
of functions computed
average to algorithms
nisan and wigderson
algorithm attempting to
r su ciently
product assertion hold
can we place
kind of restrictions
the algorithm attempting
let f airdepth
of depth kd
communication protocols 1
unbiased bits from
for specific models
the average to
plugging this in
has low discrepancy
d k decision
known proofs of
and easy given
k inputs and
dependence on c
discrepancy using the
supposed to compute
then a strong
on every path
be vectors such
technique of raz
fairness restriction is
that suc size
conclusions for specific
f has low
probability of heads
uses its resource
is made so
low discrepancy then
the discrepancy using
that of nrs94
measures how imbalanced

corpus/krapavin2000-test/1018452.txt
processors
log
adversary
oracle
crashes
coordinators
failures
alg
balancing
processor
synchronous
failure
prone
tasks
attended
adv
coordinator
pram
crash
message
iterative
passing
load
simulations
unattended
specic
w3
shared
phases
solves
round
omniscient
perfect
denition
alive
stop
bounds
seti
subcases
wn
ciency
shvartsman
rst
dene
teach
fault
rounds
lemma
tolerant
georgiou
chryssis
block
undone
solved
stops
progress
phase
chlebus
tids
jf
1a
extant
doall
bcc
8p
1b
fail
views
restatement
utility
dened
consensus
pid
derivative
stand
adequately
kill
expended
analyses
certified
messages
quantity
leaves
2b
surviving
byzantine
2f
lemmas
matching
w2
memory
pattern
tentative
existed
idempotent
2a
moderate
simulate
pr
faults
tolerating
assess
induction
impossibility
cient
iteration
iteratively
stage
2e
exceed
gathering
abstracts
establishes
task
performing
sent
fragmentable
flp
needlessly
worker
venerable
maxf1
denitive
w4
refute
pids
tings
homemyampersandmdash
fiterations
scratchpad
delphian
timeprocessor
ces
iterated
alexander
asynchronous
delays
multicast
faulty
dr
sensitive
whp
kills
crcw
unknowingly
dariusz
specics
kanellakis
minates
newest
asynchrony
rescheduling
tight
am
loads
patterns
deterministic
cooperative
loop
caused
mergeable
rolls
survives
strengthens
3p
martingale
elucidated
supercial
denitions
ideally
idling
kowalski
landscape
ticks
colleague
traversal
eect
crashed
identier
uc
omni
totally
tells
cause
sketch
partitionable
russell
gossip
347
ine
fernndez
rened
assists
simulating
proceeds
stale
identiers
dissimilar
multiplicities
dependability
do all
log p
p log
p f
iterative do
log log
all o
all problem
work complexity
r do
f log
the do
prone processors
failure pattern
shared memory
f p
n f
o n
the oracle
algorithm w
algorithm an
load balancing
message passing
the work
perfect load
all n
crash prone
work w
the adversary
message complexity
log n
algorithm simulations
r log
failures f
n tasks
of algorithm
of do
n log
lower bounds
of processors
complete analysis
failure prone
for do
synchronous shared
attended phases
r iterative
all algorithm
block step
block steps
progress tree
solves do
balancing assumption
of failures
log f
n p
of work
p processors
all algorithms
an we
stop failures
of crashes
the processors
lemma 3
with work
the iterative
log b
r p
pattern f
local views
the attended
adversary adv
wn p
algorithm alg
any failure
p n
the progress
c p
that solves
when f
memory model
bounds for
passing model
failure free
write all
best known
f can
analysis of
c log
solved with
a phase
alg that
on crash
unattended phases
processor algorithm
the unattended
phase w3
failure patterns
steps b
let do
be solved
on work
memory models
all tasks
each processor
the rst
a do
f the
f c
the failure
processors that
the perfect
p lemma
b p
u p
one coordinator
n problem
with crashes
processors perform
upper bounds
the complexity
complexity of
processors with
any execution
p and
work o
memory algorithm
failure model
new bounds
two subcases
log c
22 30
any algorithm
the message
all is
r r
we dene
the r
n processor
failures we
q p
f denote
and f
of block
work for
c 0
cases case
fail stop
matching upper
with f
simulations of
the coordinators
fail stops
coordinators and
processor steps
undone tasks
n stand
f sensitive
f stop
synchronous processors
on failure
passing algorithm
of undone
processor crashes
p crash
p failure
f problem
local view
using work
r instances
complexity w
crashes f
theorem 3
work of
is log
phases and
f when
any c
r n
the denition
n note
p r
the computation
given any
tasks and
tasks are
algorithms on
now give
during all
passing and
denition of
processors and
step i
processors in
0 f
e ciency
the synchronous
complexity arguments
cause more
all work
processors assigned
p log p
log log p
do all o
iterative do all
log p log
all o n
r do all
the do all
do all n
do all problem
log p f
p f log
p log log
of algorithm an
r p f
r r p
perfect load balancing
o n f
all n f
for do all
the iterative do
the work complexity
c p log
f log p
do all algorithms
f c p
of do all
n f can
failure prone processors
complete analysis of
p and f
log n log
log b p
f p r
for the do
solves do all
a do all
p r log
f p log
do all algorithm
b p f
load balancing assumption
crash prone processors
r iterative do
q p f
the progress tree
synchronous shared memory
the perfect load
number of failures
can be solved
the work w
the number of
number of processors
shared memory model
execution of algorithm
p lemma 5
under the perfect
all the attended
of block steps
of r do
algorithm an we
for any failure
do all is
the attended phases
f log log
of the do
n p log
log p and
log p lemma
any failure pattern
the message passing
message passing model
f can be
in any execution
n log p
any c 0
f the number
for this case
any execution of
the best known
shared memory models
attended phases and
any algorithm alg
log log f
an we have
round of r
the unattended phases
number of crashes
their local views
failure pattern f
log c 0
bounds on work
let do all
of work complexity
shared memory algorithm
work complexity of
of n p
in the progress
analysis of work
f p n
do all in
c log p
on crash prone
progress tree is
the r iterative
passing and shared
alg that solves
of failures f
algorithm alg that
therefore the work
case as o
all the unattended
that solves do
we let do
use of do
number of block
analysis of the
the work of
with work o
o n there
log p for
a unit of
be solved with
the shared memory
two cases case
the analysis of
cases case 1
n r r
analysis of algorithm
unit of work
and shared memory
in the message
during all the
upper bounds for
range of f
number of processor
log log log
r n r
leaves in the
tasks in a
of the failure
n p and
p f and
not cause more
the oracle model
adversary that causes
jf j f
algorithms on failure
of solving a
arguments on the
p failure prone
all problem in
message passing algorithm
failure pattern with
all problem that
all n problem
log p we
stop failures f
pattern with f
work complexity w
new analysis of
solved by running
algorithms on crash
on failure prone
each block step
all problem for
u log p
least one coordinator
r instances of
complexity arguments on
n f problem
case is b
bounds for do
1 f p
log n p
failure model f
p log c
new bounds for
p crash prone
f when f
all problem as
a failure pattern
of undone tasks
block steps b
o n note
on p crash
log p therefore
depends on f
n stand for
the r do
failure free processors
the failure pattern
wn p f
synchronous message passing
f stop failures
log pr f
as o u
the synchronous shared
n log log
message passing and

corpus/krapavin2000-test/1018488.txt
bccsp
2m
depth
futures
equivalences
behavioural
bisimulation
axiom
preorder
equational
inequation
nested
inequational
closed
substitution
axiomatization
sound
trace
hennessy
equivalence
milner
finitely
axiomatizations
ax
en
axiomatizable
modulo
preorders
pn
lengths
norm
ln
axioms
axiomatizability
epf
i2i
modal
glabbeek
inequations
ltss
traces
semantics
simulation
lemma
action
sect
actions
shall
transition
inequa
ccs
equationally
transitions
inductive
afford
induction
soundness
aceto
vaandrager
groote
claim
summands
labelled
algebras
a4
formulae
cit
contradicting
var
depths
proposition
ap
spectrum
congruence
infer
completed
substantial
affords
notions
characterization
technical
branching
behaviour
inductively
concurrency
hai
relations
iff
developments
tionally
processes
aq
contexts
provable
derivable
aforementioned
proven
absorption
6j
a1
fm
language
statement
behaviours
finite
ottir
olfsd
bpa
tyft
pomsets
tyxt
menagerie
3mg
algebra
decidable
statements
a2
derivations
summand
van
viz
luca
axiomatized
fokkink
lence
tacitly
brookes
decidability
formula
operational
closure
outgoing
hypothesis
tional
prefixing
proviso
fn
substitutions
logic
amongst
reflexivity
equiva
allocation
proceed
occurring
ready
offer
coarsest
mn
business
remark
grammar
light
arguing
anna
promised
languages
fy
operators
proofs
plotkin
op
distinguishing
interleaving
none
offered
operator
subterm
singleton
1g
merge
pf
associativity
claims
elegant
satisfied
argue
completeness
exhibit
commutativity
kg
fragment
equations
clause
148
sequences
hole
eg
format
nondeterminism
professor
occurs
presenting
structural
algebraic
play
approximations
symmetry
147
albeit
a 2m
bccsp terms
nested simulation
closed bccsp
at depth
bccsp term
possible futures
closed substitution
n nested
language bccsp
bisimulation equivalence
2 nested
nested trace
depth t
is sound
ax en
q 0
v occurs
depth d
axiom system
trace equivalences
have that
sound with
simulation preorder
finitely based
sound modulo
over action
hennessy and
depth p
and milner
closed terms
that depth
action a
equational axiomatizations
behavioural equivalences
v u
not finitely
t u
bccsp is
actions s
futures preorder
depth u
finite equational
an axiom
p q
in t
c u
a closed
the language
t v
of actions
the inequation
completed trace
modal characterization
over bccsp
a bccsp
equational axiomatization
occurs in
terms p
n 0
that p
term t
a q
axiom in
no finite
trace equivalence
lengths t
terms over
of bccsp
2m a
for bccsp
we shall
every n
2 a
a m
context c
the closed
t at
induction on
lemma 2
2 lengths
inequational axiomatization
substantial substitution
norm t
2m 6
finite inequational
and closed
v q
that t
the axiom
closed term
en 1
t n
p 0
follows that
p v
each n
labelled transition
in equational
of behavioural
may infer
behavioural equivalence
for n
by lemma
and trace
that norm
time spectrum
nested semantics
trace semantics
futures equivalence
non finite
depth q
by hennessy
depth allocation
time branching
based over
closed substantial
unique depth
behavioural semantics
finite axiomatizability
depth 0
q n
term u
process algebras
it follows
yields that
was to
simulation and
that q
may conclude
inductive hypothesis
van glabbeek
axiomatization for
sound for
the axioms
proof of
q a
by induction
the soundness
soundness of
equivalences for
contradicting our
inequation p
axiomatizations for
language ln
axiomatizations over
finite index
technical developments
2m v
from ax
2m 2
bccsp the
lengths q
equivalence is
infer that
which was
the 2
x occurs
be shown
the relations
and q
suppose c
are sound
the proof
this end
a j
we prove
0 such
the n
of bisimulation
in ln
proven from
and preorder
over closed
that pn
we may
u by
from e
of t
substitution and
equivalence and
branching time
the claim
2m 1
equivalence for
the modal
every closed
and a4
the possible
t j
for every
axioms in
be closed
a term
trace of
bccsp that
in en
image finite
equationally axiomatizable
inequational logic
2 a 2m
closed bccsp terms
the language bccsp
2 nested simulation
occurs in t
at depth d
t v u
the n nested
over the language
v occurs in
we have that
a q 0
in t at
sound with respect
the 2 nested
over action a
t at depth
which was to
nested simulation preorder
n nested trace
hennessy and milner
to be shown
was to be
is not finitely
every n 0
of actions s
nested simulation and
possible futures preorder
is sound modulo
the possible futures
that is sound
a bccsp term
a closed substitution
n nested simulation
nested trace equivalences
for every n
sequence of actions
p v q
closed bccsp term
that a 2m
modal characterization of
an axiom in
simulation and trace
bccsp term t
2m a m
a 2m a
ax en 1
it follows that
v u is
for each n
terms p q
a 2m 6
we may infer
may infer that
that depth t
is sound with
lemma 2 b
closed terms p
bisimulation equivalence is
u is sound
c u 2
that v occurs
finite inequational axiomatization
terms over action
a p 0
the axiom system
be a closed
n 0 the
q 0 such
completed trace of
possible futures equivalence
a closed bccsp
unique depth allocation
by hennessy and
n 2 lengths
suppose c is
are sound with
a unique depth
n 1 q
lemma 2 a
bccsp terms over
time branching time
be closed bccsp
q be closed
branching time spectrum
finitely based over
linear time branching
and closed terms
is sound for
of all that
the soundness of
may conclude that
u 2 a
q a q
each n 2
labelled transition systems
p q be
2 c u
to this end
p and q
by induction on
c is of
let p q
derived from e
0 such that
q 0 with
not finitely based
a 2m 2
s of length
that are sound
equational axiomatizations over
bccsp term with
s q 0
contradicting our assumption
bccsp terms and
the technical developments
a 2m v
finite equational axiomatizations
the language ln
the context c
equivalence and preorder
the modal characterization
non finite axiomatizability
of bisimulation equivalence
actions s of
over closed bccsp
closed substantial substitution
2m 6 2
the closed substitution
inequation p v
of the n
is a q
to the effect
we may conclude
with respect to
for n 2
be proven from
assumption that t
the effect that
induction on n
of the form
induction on the
the linear time
6 2 c
p is also
for the possible
that q s
such that t
the inductive hypothesis
the proof of
be derived from
that p s
now proceed to
the axioms in
that t s
of length d
by lemma 2
a2 and a4
bisimulation equivalence over
finite axiom system
term u and
notions of behavioural
afford finite equational
soundness of e
that depth p
terms p and
axiom system e
milner in 18
axiom in e
satisfied by q
a finite inequational
equivalence is decidable
groote and vaandrager
of bccsp terms
left merge operator
bccsp is the
bccsp terms p
over bccsp is
over image finite
for bccsp that
t s u
finite equational axiomatization
bccsp terms thus
each formula in
a 2m 1
depth d by
nested trace equivalence
at depth 0
pn and q
that ax en
length d such
n or n
or n for
a4 in table
bccsp that is
and milner in
occurs at depth
not finitely equationally
the relations a
in ax en

corpus/krapavin2000-test/1022335.txt
lh
father
sublabel
label
animal
terminological
kb
resolution
sorted
pn
sort
symbols
hierarchy
lb
sorts
ancestor
fn
p1
human
predicates
kaneiwa
labels
unary
subsort
tom
formulas
llb
subordinate
hierarchical
parent
john
labeled
mother
signature
deduction
assertional
substitution
substitutions
predicate
usages
lottery
daughter
clause
child
descendant
mgu
erent
logic
ary
clausal
son
p2
hierarchies
won
subpredicate
terml
roles
ken
inconsistent
declaration
om
symbol
declarations
reasoning
clauses
interpreted
constants
bird
interpretation
lucky
names
individuals
sublabels
tojo
language
elimination
di
rules
unifier
beierle
formula
atomic
semantically
relationships
relations
inference
expressions
rela
rule
f1
satisfiable
walking
un
conceivable
kinds
replacements
proposition
lexical
xm
expresses
hierarchically
diversity
complicated
fig
employed
formality
steamroller
culture
attributive
actualizes
fbr
undescribed
olution
kayamori
14780311
iucludes
superlabels
base
sentence
regarded
viewpoint
login
subsorts
inconsis
schubert
refutation
variously
occurring
interacting
logics
languages
satisfaction
rigorous
exclusive
negation
relabeled
derivability
tent
cohn
vl
advancement
informational
inductively
nonempty
semantics
pragmatics
reflexivity
lattice
semantic
logical
syntax
ontologies
relation
consistently
usefully
concisely
mere
chy
redesign
enrich
ministry
sports
insu
flexibly
hierar
composed
enriched
partially
res
sis
conciseness
denotation
ordinary
enhanced
recognizes
entail
conforms
defer
unification
separated
classifies
compositions
role
losing
spectively
develop
query
binary
straightforwardly
investigates
education
derivable
declare
conform
embed
respec
tively
gained
derivation
formalisms
label based
l s
a label
l pn
resolution system
label hierarchy
labeled signature
l fn
i l
sort hierarchy
hierarchical resolution
order sorted
sorted resolution
l p1
terminological knowledge
a labeled
sorted logic
a lh
for label
resolution rules
based language
of sort
label terms
based formulas
sublabel relations
x l
resolution for
knowledge base
of labels
lh be
kb lh
labeled substitution
sublabel relation
lh structure
lh interpretation
with sort
label formulas
sort predicates
lh model
hierarchical relationships
labeled substitutions
l lb
constants functions
assertional knowledge
empty clause
let lh
hierarchical representation
a sorted
formulas in
of symbols
of label
a sort
in hierarchical
lb is
ken kaneiwa
sorted substitution
a sublabel
human s
sort symbols
child father
unary predicates
a unary
elimination rule
symbol names
base kb
father mother
the label
unary predicate
n ary
a knowledge
animal s
subset relation
mother son
complicated sublabel
father is
won in
john human
terminological hierarchy
and sorts
sort l
of terminological
label clauses
sublabel rule
animal ancestor
of subordinate
language llb
pn l
subordinate relations
label clause
a lottery
kb is
di erent
of sorts
l c
son daughter
subsort relation
the labels
symbols are
predicates and
parent child
a subsort
ancestor p2
1 un
un u
and assertional
signature lh
sorts constants
daughter john
hierarchy lh
p1 l
deduction rules
relation l
ary predicates
if kb
i animal
the sublabel
john c
ancestor descendant
john is
the hierarchical
relation of
hierarchy is
an order
logic with
substitutions and
each label
symbols in
father and
human animal
the lh
binary predicates
and tom
and predicates
terms and
the sorted
and formulas
inconsistent set
symbols of
interpreted by
s s
i ancestor
t om
fn l
terml s
simple sublabel
resolution rule
deduction rule
based expressions
kb be
sorted substitutions
role symbols
animal lb
a terminological
sorted variable
human human
john tom
label father
kb has
subpredicate relation
substitution a
label formula
hierarchical expressions
subordinate relation
unary function
erent kinds
animal p1
tom human
human won
sorts as
father parent
ancestor animal
s father
and labeled
based sort
usages of
then kb
that kb
s d
the sort
of symbol
predicate symbols
signature and
interpretation i
substitution is
proposition 5
the empty
c f
the resolution
if l
descendant parent
a father
john and
various symbols
and hierarchical
1 l
function symbols
formulas and
erent types
for john
and kb
label based language
a label hierarchy
x l s
a label based
a labeled signature
order sorted logic
hierarchical resolution rules
for label based
based formulas in
label based formulas
in hierarchical representation
formulas in hierarchical
resolution for label
i l s
sorted resolution system
i l pn
lh be a
let lh be
an order sorted
be a label
the empty clause
be a labeled
a sort hierarchy
a knowledge base
kinds of symbols
a labeled substitution
a lh interpretation
the hierarchical resolution
sort hierarchy is
l s d
logic with sort
knowledge base kb
won in a
be a knowledge
types of subordinate
i l fn
parent child father
as a unary
of terminological knowledge
i l p1
symbols of labels
mother son daughter
complicated sublabel relations
in a lottery
a label clause
i x l
father mother son
order sorted resolution
child father mother
a unary predicate
c f p
terms and formulas
as i l
functions and predicates
a subsort relation
animal s and
subset relation of
u 1 un
based language llb
1 un u
labeled signature lh
sort l s
of sort l
unary predicates and
son daughter john
of subordinate relations
l lb is
a sorted substitution
animal ancestor descendant
sorts constants functions
the resolution system
and assertional knowledge
label hierarchy lh
a lh model
a sublabel relation
with sort hierarchy
l pn l
l p1 l
and hierarchical resolution
labeled substitutions and
of n ary
u i l
terminological knowledge and
un u i
substitutions and hierarchical
n ary predicates
lb is a
constants functions and
lh interpretation i
labeled signature and
i l c
l s i
u u 1
hierarchy is a
is a sorted
as a sort
of a label
base if kb
be a lh
a unary function
derive the empty
the sorted resolution
t l s
label based expressions
of label terms
set of sort
knowledge and assertional
label terms of
the lh structure
in a label
label based sort
1 let lh
simple sublabel relations
the elimination rule
system for label
pn l pn
a lh structure
john and tom
a terminological hierarchy
of sort symbols
and labeled substitutions
resolution system for
daughter john tom
labeled substitution is
kb be a
resolution system with
label terms and
predicates and sorts
hierarchical resolution system
human won in
erent kinds of
label clause and
descendant parent child
and i l
the label based
knowledge base if
hierarchical relationships among
the sublabel rule
di erent kinds
base kb is
with sort predicates
the label father
relation l s
for hierarchical expressions
usages of labels
if kb lh
based sort hierarchy
and kb be
roles of symbols
l 1 l
i i a
set of labels
set of label
ancestor descendant parent
sets of individuals
the condition i
1 l n
there are l
di erent types
erent types of
is a pair
l s the
b i i
representation and reasoning
substitution is a
an atomic formula
proposition 5 2
s and i
is a set
is a label
of the sort
and be a
a b i
i a b
a set of
the knowledge base
i b i
the complicated sublabel
present a label
expression of sort
first order symbols
terminological hierarchy section
and formulas and
l pn for
a mgu for
with assertional knowledge
the label hierarchy
a father and
their unique roles
ary predicates and
based language we
i animal s
symbol names of
kaneiwa and tojo
ancestor descendant human
together with assertional
predicate logic with
and a predicate
resolution system without
the label human

corpus/krapavin2000-test/1022634.txt
cage
cages
disk
qudg
chains
sat
realization
quasi
gc
hoc
wire
sensor
chain
ad
embedding
mortar
coordinates
crossing
udg
orientable
drawing
interior
literal
terminals
plane
virtual
clause
wattenhofer
grid
routing
connectivity
directed
hinge
satisfiable
2t
embed
unit
v1
wireless
np
adjacent
terminal
double
euclidean
embedded
mortars
tn
vertex
3sat
localization
perimeter
vertices
disks
4t
clauses
impossibility
away
realized
roger
approximability
hop
networks
packing
fabian
breu
directable
ralg
gu
upwards
hooked
kirkpatrick
intersecting
infinity
geographic
packed
lemma
im
inapproximability
moscibroda
capped
capacity
neighboring
cycle
mobile
horizontal
ptas
tw
networking
dist
kuhn
dell
closer
mere
u2
approximation
edge
344
towards
gd
component
graphs
wires
u1
realizable
erent
located
prominent
hard
transmission
distance
v2
recognition
geometry
neighbors
oriented
west
evolutionary
forces
radius
edges
radio
coordinate
peer
connecting
orientability
goafr
meghanathan
gfg
sirer
saikat
sabhnani
isfiable
lotker
sextant
anycast
gpsr
corrollary
densest
funke
nieberg
ratajczak
katharina
girishkumar
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111001111001111001111001111001111001111001111001111001111001111001111
mirjam
manes
zollinger
octagons
amitabh
krller
concretized
44th
giorgetti
pfisterer
south
literals
direction
lemmas
distant
italic
goes
unstable
stefan
internet
6th
ts
ratio
di
geometric
nodes
florida
intractability
north
tends
border
gianni
rohan
fekete
murty
sndor
encircled
emin
approximatively
glaring
squeeze
chasm
circle
usa
imposed
contradiction
assigning
neatly
sedona
gianfranco
regina
nent
lehmann
florence
fulfils
secures
unit disk
disk graph
quasi unit
virtual coordinates
d qudg
a cage
d quasi
g sat
grid drawing
disk graphs
hoc and
ad hoc
directed away
sat c
a unit
a realization
a d
and sensor
sensor networks
double chain
qudg with
single chains
is directed
an embedding
realization of
crossing component
is orientable
chains or
directed towards
the crossing
is np
graph g
np hard
the cage
be directed
the plane
one double
clause component
adjacent cages
defined interior
lemma 3
embedded in
with d
the grid
of gc
variable component
the component
towards the
r g
approximation ratio
the interior
the chain
gc as
intersecting edges
wire is
length 2t
any realization
3 sat
connectivity information
away from
oriented towards
realized as
coordinates for
two single
instance c
the chains
u v
drawing of
of g
the euclidean
is satisfiable
a wire
interior of
lower bound
euclidean plane
v1 is
d 1
d d
the clause
is embedded
plane and
quasi udg
gc is
directed upwards
all chains
literal vertex
embed in
orientable if
chain between
good embedding
cage has
realization r
if v1
cage closer
networks proceedings
of 3
clauses and
chains are
multi hop
approximation algorithm
finding a
component the
wireless ad
distance 1
hoc networks
are directed
geographic routing
the cages
embedding r
given unit
of cages
embedding which
the hinge
cage and
roger wattenhofer
cages and
dist u
3sat instance
for ad
or one
to embed
be realized
two adjacent
positive literal
n goes
sat is
all terminals
hard to
closer to
length k
in ad
of virtual
be packed
component 3
the variable
r c
to infinity
a cycle
in wireless
edge between
embedding of
an edge
euclidean distance
components it
goes to
c is
of length
be embedded
graph with
mobile ad
nodes u
a graph
d 2
find a
neighboring nodes
localization from
terminal can
from mere
and literals
adjacent cage
two literal
cage in
realizable as
chain vertex
realization for
chains have
graph gu
chains on
mortars are
cage by
fabian kuhn
from connectivity
geometric routing
prominent application
without location
apart as
hooked together
ralg g
not satisfiable
sat such
joint workshop
coordinate information
assigning virtual
cage if
graph recognition
usa fabian
the wire
unit disks
cages is
geometric ad
chain must
cages this
chain being
clause vertex
with unstable
horizontal terminals
unstable transmission
robust position
literal components
breu and
unit disk graph
a unit disk
quasi unit disk
a d quasi
a d qudg
d quasi unit
hoc and sensor
g sat c
ad hoc and
and sensor networks
unit disk graphs
directed away from
d qudg with
as a d
the grid drawing
a realization of
is np hard
d 1 2
in the plane
disk graph g
single chains or
directed towards the
of g sat
disk graph with
qudg with d
two single chains
or one double
towards the component
grid drawing of
one double chain
of a cage
well defined interior
embedded in the
d 2 3
np hard to
realized as a
drawing of g
with d 1
realization of a
of 3 sat
gc as a
virtual coordinates for
finding a realization
be directed away
two adjacent cages
sat c is
is directed towards
graph with d
chains or one
it is np
of a d
in a d
oriented towards the
away from the
the interior of
lemma 3 4
be realized as
from the component
the euclidean plane
with d 2
interior of a
hard to find
networks proceedings of
if the underlying
disk graph is
of virtual coordinates
variable component the
embedding r g
r g of
chain is embedded
are directed away
of gc as
virtual coordinates in
an embedding which
cage closer to
c is orientable
on virtual coordinates
realization of g
find a realization
a quasi unit
instance c of
in any realization
component 3 3
a good embedding
if v1 is
is directed upwards
coordinates for ad
the crossing component
graph g sat
disk graph in
any realization r
given unit disk
the positive literal
wireless ad hoc
d and d
of a unit
in ad hoc
to find a
ad hoc networks
for ad hoc
0 as n
a given unit
the variable component
dist u v
the unit disk
theorem 3 1
as a unit
of length k
to 0 as
goes to infinity
graph g it
n goes to
must be directed
by lemma 3
have a well
in the euclidean
and d d
for the problem
the plane and
sensor networks proceedings
given in 3
d d and
a cycle of
for large enough
a well defined
an approximation algorithm
in wireless ad
nodes u and
embedding of a
between two nodes
our lower bound
mobile ad hoc
is a unit
euclidean distance between
is embedded in
an edge between
u and v
it is now
g as a
chain between two
recognition is np
virtual coordinates and
an embedding r
3 2 as
ratio of o
closer to each
in the cage
that gc can
in a cage
all unit disk
distance 1 then
joint workshop on
sat is satisfiable
non neighboring nodes
realization r g
another impossibility result
the chain between
or the variable
far apart as
a double chain
neighbors can be
from connectivity information
the adjacent cage
good embedding of
breu and kirkpatrick
each cage has
344 n 1
length 2t or
tn is directed
as 3 2
euclidean plane is
given a unit
its connectivity information
adjacent nodes to
as far apart
two literal components
graph given by
connectivity graph have
quality of an
instance of 3
11 november 2005
is not satisfiable
adjacent pair of
modeling ad hoc
if the 3sat
of the hinge
robust position based
wire is oriented
assuming w l
usa fabian kuhn
that the crossing
c of 3
quasi udg for
construction of gc
foundations of mobile
either the clause
routing without location
2 is np
as n goes
terminals are directed

corpus/krapavin2000-test/1023754.txt
mad
oar
channel
receiver
802
pac
rev
wireless
receivers
throughput
madpac
probing
mac
sender
transmission
grts
packet
phy
ppdu
sifs
multiuser
diversity
revenue
ofdm
packets
scheduling
rts
arf
cts
lans
goodput
transmitter
fairness
super
11a
tra
flows
fading
gain
rate
duration
ack
rm
lan
sf
ra
octets
plcp
transmit
snr
frame
rayleigh
dcf
backlogged
adaptation
coherence
reception
temporal
dbpsk
header
rates
network
bits
mbps
robin
erence
di
erent
dialogue
reply
layer
madoar
pathloss
preamble
contention
11b
medium
cdma
gains
reservation
dequeued
instantaneous
star
formats
mobile
dmax
1mbps
favorable
transmitted
slot
psdu
11g
payload
auto
bitmap
topology
opportunistic
radio
queried
downlink
300m
transmitters
pl
highest
transmits
round
nav
fair
retransmission
pad
campus
subfield
54mbps
6mbps
overheard
fcs
orts
channels
asymptotic
feedback
queue
nels
wavelan
signal
modulation
overhead
varied
format
frames
serviced
src
selectively
feedbacks
tradeo
field
retry
ts
physical
452
utilization
exploiting
improvement
link
concatenation
share
query
cellular
networks
7mbps
interframe
wcdma
sadeghi
5005152535
navs
600m
hdr
qualnet
miu
scheduler
exploit
improves
tc
ghz
reward
legacy
simulation
tail
service
achieves
hoc
networking
devices
ects
carrier
tentative
respond
flow
rhs
concatenated
benefits
emre
umts
opportunistically
band
senders
ective
division
peak
specifications
sensing
schemes
transmissions
short
scrambled
lucent
2mbps
csma
awgn
koksal
aloha
channel probing
network throughput
of mad
data transmission
802 11
channel conditions
k set
relative gain
channel condition
madpac rev
multiuser diversity
wireless lans
ieee 802
mad pac
mad oar
rate adaptation
the channel
data rate
wireless lan
set mad
802 11a
temporal fairness
coherence time
super data
in mad
the sender
super packet
revenue based
tra c
maximum relative
data ppdu
data rates
gain scheduling
the receiver
of channel
the super
arf oar
sifs sifs
oar and
in wireless
all receivers
a receiver
based scheduling
medium access
11 wireless
adaptation scheme
channel coherence
by mad
rev mad
phy layer
the network
rayleigh fading
throughput improvement
rate rm
for mad
frame control
receivers are
pac k
star topology
access diversity
set round
overall network
pac rev
temporal share
data packets
receiver i
a sender
data packet
of receivers
mad is
c flows
oar rev
g rts
throughput mbps
11 mac
transmission dialogue
oar pac
adaptation schemes
oar k
goodput per
11 dcf
multiple receivers
mbps arf
diversity in
for channel
access point
transmitted at
overall throughput
base rate
802 11b
di erent
current channel
from mac
control duration
for receiver
ppdu frame
existing rate
in 802
to oar
control frame
and receiver
to transmit
receiver with
di erence
round robin
the ieee
wireless networks
scheduling algorithms
receiver will
probing and
instantaneous channel
the mad
high data
a transmitter
pac and
higher data
sender to
erence between
each receiver
fairness among
probing data
a grts
super frame
oar the
pac is
random topology
channel quality
highest data
receiver scheduling
mad the
expected goodput
exploiting multiuser
receiver 2
rev performs
auto rate
the goodput
and phy
k receivers
using oar
with madpac
packet in
d f
control packet
the mac
topology with
among multiple
throughput by
sender receiver
through put
of flows
and ack
receivers for
fair scheduling
varying channel
transmission phase
a wireless
packets in
wireless network
packets are
the transmitter
receiver in
transmit data
mac layer
mac and
is varied
transmission rate
time slot
the transmission
rev figure
receiver k
pac mad
temporal fair
cts control
mad scheduling
tail 6
service bits
contention window
that receiver
pad bits
the multiuser
bits service
duration ra
grts packet
c load
mad to
n tr
snr value
long training
madpac k
expected network
th transmission
mac tail
frame formats
802 11g
given channel
pac the
duration field
grts cts
mad using
payload size
the network throughput
k set mad
maximum relative gain
ieee 802 11
revenue based scheduling
super data ppdu
relative gain scheduling
rate adaptation scheme
channel coherence time
802 11 wireless
set mad pac
the channel probing
for data transmission
k set round
set round robin
rev mad pac
mad pac k
set mad oar
sifs sifs sifs
mad pac rev
medium access diversity
pac k set
of channel probing
the ieee 802
the super packet
tra c flows
throughput mbps arf
802 11 mac
ieee 802 11a
802 11 dcf
mad oar rev
rate adaptation schemes
mad oar k
oar k set
oar rev mad
mbps arf oar
arf oar pac
channel condition is
star topology with
overhead of channel
channel probing and
the super data
11 wireless lans
data ppdu frame
frame control duration
in wireless lans
existing rate adaptation
the data transmission
a wireless lan
the access point
di erence between
multiuser diversity in
exploiting multiuser diversity
the overall network
when the channel
the temporal share
channel probing data
phase of mad
network through put
network throughput by
with madpac rev
high data rates
overall network throughput
goodput per data
temporal share of
madpac rev performs
data transmission phase
in a wireless
is set as
c d f
is varied from
to the sender
value of k
number of receivers
the multiuser diversity
a star topology
the c d
per data transmission
for channel probing
long training symbols
control duration ra
improves the network
the highest data
bits from mac
mac tail 6
at rate rm
bits service bits
pad bits service
from mac tail
relative gain among
probing data transmission
mac and phy
highest data rate
varying channel conditions
the channel conditions
madpac k set
mad oar and
a super packet
oar pac mad
and receiver scheduling
expected goodput per
tail 6 bits
the current channel
a random topology
tra c load
service bits from
pac rev figure
pac mad oar
t th transmission
share of flows
instantaneous channel conditions
the relative gain
higher data rate
for receiver i
network throughput vs
the overall throughput
throughput improvement over
in the super
among di erent
n f is
p d f
packets in a
each data transmission
d f of
reception of the
data transmission is
receiver with the
data transmission the
ad hoc networks
back to back
to a receiver
of the packets
network throughput with
compares the network
of rate adaptation
legacy 802 11
sender receiver 1
receiver 1 receiver
madpac rev is
each receiver will
independent rayleigh fading
data transmission and
multiuser diversity gain
is near its
oar mad oar
diversity in wireless
ppdu frame formats
variants of mad
and phy layer
to the ieee
wireless lan environment
w log 1
the subsequent data
802 11a phy
ppdu frame format
with ieee 802
multiple data flows
multiuser diversity gains
four variants of
to exploit multiuser
channel condition information
reply with an
of the super
in 802 11
mad using oar
802 11 physical
per transmission dialogue
access diversity mad
f is set
transmit at rate
expected network throughput
among multiple data
all receivers are
arf oar mad
frame see figure
exploit multiuser diversity
throughput gain and
identify and address
free space pathloss
feasible data rate
current channel condition
short term fairness
1 receiver 2
receiver 2 receiver
compared to oar
sender decides to
the duration field
all the mechanisms
while maintaining temporal
throughput by up
data transmission scheme
subsection 7 1
the channel condition
the goodput per
the expected goodput
topology with variable
by maximum relative
link goodput optimization
maintaining temporal fairness
asymptotic performance bound

corpus/krapavin2000-test/1024018.txt
prs
circuits
circuit
gate
poly
acyclic
gates
slp
polynomials
eval
delta
idempotent
polynomial
replacement
accepting
deterministic
counting
subcircuit
idem
fictive
mineval
pc
np
psi
thetag
wurzburg
hardness
sect
straight
phi
pspace
representations
arithmetic
monomials
trees
maxeval
membership
subcircuits
nonterminal
fp
depth
informatik
venkateswaran
wag84
ven92
cvp
subtrees
instructions
sa
corp
ef
wires
exponential
universitat
inputs
lemma
stockmeyer
ch
boolean
multivariate
incoming
primes
reductions
subtree
unwinding
exerzierplatz
97072
ebec
cmtv98
subsect
wuerzburg
val79
mr95
montr
gj79
wag86
allender
sm73
rules
surprise
ke
meyer
replace
unary
theoretische
unwind
resp
iff
logarithmic
coefficients
nonnegative
eal
divisors
sos
evaluates
finitely
containment
evaluate
dfg
succinctness
upcoming
formulas
reflexive
instruction
clause
versa
monomial
qu
logspace
paths
modulo
derivations
vice
witnessing
diophantine
fi
counts
equivalence
fx
predecessor
pt
log
wagner
member
1g
questions
nondeterministically
wire
maximization
k2
prime
uni
unambiguous
edges
analogously
predecessors
ki
nontrivial
integer
evaluating
stratified
conjunctive
families
theta
permanent
formula
transitive
triggers
logcfl
aad97
ik1
dimatia
tompa
mckenzie
dspace
prss
caussinus
kal88
inessential
h3c
massaged
et98
all98
6128
fcar
umontreal
erationnelle
aab
ville
kosub
renumbering
ik0
inequivalence
aml98
vy
iro
165f
reexpress
vollmer
nump
sch80
jia92
sud78
sp13
vsbr83
cup
lan93
vt89
4xg
vin91b
an8
im83
mat93
bf91
retarded
removement
vin91a
tubingen
yan99
unambiguity
poly s
proof circuits
acyclic prs
proof trees
simple deterministic
circuit c
and acyclic
range s
prs s
a prs
replacement systems
simple acyclic
output gate
deterministic and
polynomial replacement
input x
simple prs
counting proof
eval delta
under log
range delta
s poly
poly delta
the gates
a circuit
straight line
of polynomials
p complete
lemma 5
prs and
deterministic prs
gate g
membership problems
all representations
2 range
s idem
line program
arithmetic circuits
for simple
of proof
delta and
theorem 6
boolean circuit
complete under
1 poly
line programs
variable membership
delta be
prs is
slp representation
integer circuit
idempotent simple
accepting subtrees
delta are
np complete
and deterministic
circuits with
polynomial p
a polynomial
circuits is
of accepting
simple and
the circuit
g s
gates of
arithmetic circuit
the prs
f thetag
gates v
of replacement
on input
c x
and poly
for depth
of c
a gate
n inputs
in p
sect 3
p a
the complexity
m c
and eval
let delta
reduction from
accepting subtree
thetag circuits
has incoming
accepting paths
ef representation
every gate
prs the
eval s
prs delta
prs we
prs to
representations 1
of monomials
an gate
that poly
prs for
the idempotent
circuits of
logarithmic space
circuits and
an input
s range
circuit with
s is
incoming edges
c on
f g
is p
is np
from fx
systems s
acyclic systems
counts proof
phi p
gate with
are np
x j
s such
complexity of
complete for
in logarithmic
the eval
a psi
replace every
the polynomials
the polynomial
edges from
definition 5
many one
an accepting
statement 2
and range
2 n
variables x
sa h
replacement system
describe p
for idempotent
circuit value
gates level
all gates
1 gates
integer circuits
n member
unique polynomial
subcircuit of
mineval delta
one reduction
proof circuit
many representations
slp s
start polynomial
eval problem
nonterminal variable
pc fact
2 poly
in corp
idempotent systems
that counting
the rules
c c
hand side
input variables
trees and
p has
an output
left hand
evaluate to
delta 2
an exponential
systems definition
integer coefficients
stockmeyer and
full representation
hardness follows
one polynomial
integer expressions
versa can
representation p
of sect
input gates
trees of
p is
system s
an arithmetic
a straight
is simple
polynomials in
depth 4
of poly
range we
acyclic then
every simple
fi fi
these circuits
simple deterministic and
deterministic and acyclic
and acyclic prs
number of proof
polynomial replacement systems
straight line program
simple and deterministic
for all representations
simple acyclic prs
of proof trees
counting proof circuits
poly s poly
s poly s
a circuit c
with an output
and deterministic prs
poly s and
an output gate
acyclic prs s
straight line programs
circuits with an
complete under log
idempotent simple deterministic
variable membership problems
simple and acyclic
proof trees and
incoming edges from
number of accepting
a 2 n
an input x
of c on
is p complete
2 range s
and poly s
lemma 5 7
in logarithmic space
with n inputs
let delta be
proof trees of
s range s
delta be a
the complexity of
boolean circuit c
on input x
a simple deterministic
reduction from the
are np complete
that poly s
log 1 t
f thetag circuits
all representations 1
acyclic prs to
p complete under
an integer circuit
poly s are
trees and proof
proof circuits is
lemma 5 13
an arithmetic circuit
evaluate to 1
s is simple
phi p a
prs s such
prs and for
computed in logarithmic
p a psi
of accepting subtrees
c on input
gates of c
circuit c and
of proof circuits
has incoming edges
sum of monomials
the output gate
range s range
s and poly
for simple acyclic
and proof circuits
is np complete
c c x
s such that
2 n n
of the gates
lemma 5 8
a straight line
if s is
for all a
theorem 6 2
probabilistic algorithms for
delta and eval
range is np
the prs s
for every simple
be a prs
circuit value problem
of counting proof
eval problem for
versa can be
is simple deterministic
acyclic prs and
range s and
1 poly s
systems s such
u v x
counting proof trees
proof circuits of
np complete 3
we describe p
arithmetic circuits and
given a circuit
p 2 poly
essential in p
and eval delta
j has incoming
for idempotent simple
a simple prs
slp representation of
circuits is p
s be simple
representations of polynomials
are p complete
representations 1 poly
1 poly delta
under log proof
gates v i
for a prs
counts proof circuits
systems definition 5
s are finite
at an gate
replace every x
integer circuit with
replacement systems definition
stockmeyer and meyer
that counting proof
of polynomials and
such a circuit
circuits of c
2 poly s
for every gate
prs to the
many one reduction
the eval problem
every x r
are systems s
range delta and
2 range delta
3 the transformations
a reduction from
x y such
complexity of the
left hand side
by lemma 5
a gate with
the transformations from
evaluates to 1
the reflexive and
the minimal element
circuit c with
circuit with n
be the reflexive
complete for p
element is obtained
vice versa can
a boolean circuit
from the circuit
exists a simple
s is acyclic
np complete under
give a reduction
and a 2
theorem 6 1
the following problem
in the variables
and transitive closure
the output variable
for simple and
there are systems
and for all
c into a
reflexive and transitive
if p has
input x and
then f g
c and an
that x i
into a tree
the input variables
in polynomial time
and vice versa
consists of the
of a circuit
f g a
the straight line
is obtained if
polynomials in the
be a simple
is essential in
that the problem
of c which

corpus/krapavin2000-test/1024022.txt
bipartite
bipartiteness
vertices
vertex
queries
testing
graphs
odd
walks
edges
dense
deg
reg
walk
neighbor
ddeg
mmax
degree
avg
poly
rejects
query
sparse
incidence
cycle
colorability
dmax
uniformly
adjacency
edge
sided
reject
tilde
expanders
accepts
sampling
sufficiently
krivelevich
neigbhor
64m
distance
item
accept
emulate
subgraph
alon
matchings
violating
min
degrees
dn
expander
acyclicity
gen
probability
sqrt
asks
roughly
log
lists
certificate
incident
a0
tester
regular
gap
neighbors
prof
modifications
constructions
nonetheless
extremes
corollary
randomly
2since
dpoly
tali
noga
ommitted
krivelev
bipratite
npoly
obtains
fraction
shall
probe
distributions
partition
selecting
cdot
venture
aviv
v2g
tight
specifically
necessity
a1
ramanujan
dana
tau
subsection
sample
probabilistic
pr
tel
conjectures
indepen
dently
emulating
confronted
harm
external
selects
bounded
freeness
decouple
suitable
exhibit
returns
quadruples
kaufman
builds
outputs
allowed
emulation
polylog
land
depart
matrix
random
establishing
quadruple
regularized
supervision
seventeenth
2d
linked
aids
tightness
ron
279
th
de
almost
underlies
288
dd
miami
loops
distinguish
proofs
sublinear
artifact
israel
items
ph
bridge
entries
siam
adapts
perfect
ju
running
je
seeking
transformation
seeing
thesis
rm
stays
amortized
2g
gaps
clique
returned
asking
subgraphs
eigenvalues
traced
aside
michael
densities
prepared
directed
parity
preferable
predetermined
cycles
traverses
64
traversed
florida
significantly
bounds
suffice
detected
transformed
il
undirected
relying
g 0
from bipartite
testing bipartiteness
odd cycle
in g
vertex pair
test bipartite
property p
far from
pair queries
average degree
the graph
bounded degree
bipartite with
bipartite reg
cycle s
query complexity
is bipartite
neighbor queries
of edges
d avg
dense graphs
odd length
o min
a graph
every graph
graph g
poly log
is far
incidence lists
th neighbor
having property
degree graphs
for testing
of testing
testing algorithm
random walks
algorithm test
of vertices
bipartiteness in
from having
deg v
an edge
lower bound
graph is
the algorithm
length cycle
of queries
vertices in
graphs that
general graphs
property testing
graph that
ddeg v
bipartiteness of
degree incidence
length poly
lists model
to having
to g
all graphs
regular graphs
probability at
a vertex
d n
with probability
distance parameter
sided error
edges m
adjacency matrix
of g
3 every
maximum degree
degree in
least 2
v de
multiple edges
degree is
an odd
m g
bipartite then
min queries
avg g
returns found
query access
almost regular
bipartiteness with
neighbor of
graphs in
log n
g n
x v
for graphs
the adjacency
n vertices
h v
rejects with
perform queries
testing algorithms
bipartite and
bipartite if
from g
vertex in
if g
of distance
s returns
graph properties
almost uniformly
uniformly in
the walk
then output
generated according
g is
n d
and running
in 9
and vertex
queries the
found then
that asks
graphs having
graph property
vertices s
k colorability
modifications should
procedure sample
starting vertices
testing sparse
testing properties
matrix model
bipartite gen
v d
suitable for
the vertices
sufficiently large
the bounded
edge between
this model
complexity and
algorithm may
roughly the
two distributions
g contains
paper 12
sample vertices
reg on
probabilistic construction
graph generated
algorithm rejects
accepts every
p g
same order
the property
degree and
degree d
the query
of graphs
each vertex
most suitable
sparse graphs
rejects a
queries allowed
testing graph
if odd
vertex v
actual number
every vertex
distance to
is roughly
its vertices
with respect
to sampling
constant degree
respect to
edges in
v in
queries in
edge is
for constant
e p
u and
is o
algorithm that
bound holds
allowed a
graphs whose
our algorithm
any algorithm
cycle of
the complexity
v the
it obtains
given distance
o n
then show
i v
a property
theorem 3
upper bound
queries and
far from bipartite
in g 0
number of edges
vertex pair queries
odd cycle s
from bipartite with
test bipartite reg
the average degree
is far from
type of queries
far from having
complexity of testing
bipartite with respect
for testing bipartiteness
in the graph
poly log n
algorithm test bipartite
having property p
th neighbor of
least 2 3
bounded degree graphs
odd length cycle
an odd length
the query complexity
graph that is
probability at least
with probability at
distance to having
of length poly
the bounded degree
ddeg v de
bounded degree incidence
having a property
complexity and running
length poly log
query complexity and
testing bipartiteness in
degree incidence lists
i th neighbor
of testing bipartiteness
deg v d
e p g
2 3 every
every graph that
3 every graph
construction of g
average degree in
incidence lists model
uniformly in g
g is far
a graph is
of g 0
the adjacency matrix
problem of testing
according to g
to g n
of edges m
the graph is
at least 2
notion of distance
if g is
g 0 is
and running time
that is far
length cycle of
cycle s returns
and vertex pair
from having property
access to g
found then output
queries in g
g n d
d avg g
s returns found
query access to
o min queries
queries and vertex
with respect to
as the average
the algorithm may
maximum degree is
rejects with probability
most suitable for
to having a
in general graphs
the testing algorithm
g is bipartite
an edge between
every graph g
the lower bound
the graph that
number of vertices
generated according to
cycle of length
g n 2
degree in g
of vertices in
vertices in the
v in g
n 2 d
is bipartite then
bounds for testing
bipartite reg on
graph generated according
reg on g
bound holds for
the algorithm test
rejects a graph
equivalent to sampling
returns found then
graph property p
almost uniformly in
degree is of
for dense graphs
given distance parameter
is o min
lists model in
to having property
uniformly from g
test bipartite gen
modifications should be
obtains the property
a graph generated
is g 0
is bipartite if
testing bipartiteness with
adjacency matrix model
this paper 12
a graph it
bipartiteness in general
bipartite then so
algorithm that asks
of an odd
if odd cycle
given query access
it obtains the
graph is bipartite
roughly the same
of edges in
graph g 0
in theorem 3
vertices in g
the complexity of
we then show
the same order
the number of
of the graph
the maximum degree
an edge is
in h v
very high probability
graphs that have
that it obtains
be far from
graph is said
one sided error
testing graph properties
is bipartite and
define a graph
so is g
then g 0
if d n
g 0 it
n 2 n
actual number of
same order as
the actual number
2 if g
of queries are
vertex in g
a one sided
property p is
steps in which
g 0 and
the vertices in
of the algorithm
2 n 2
n 1 5
is roughly the
to be far
that a graph
of queries the
n 2 m
s in g
on g 0
order as the
a given distance
neighbors of v
the algorithm can
graphs in the
log n in
respect to m
the i th
to the actual
for all but
p for a
graphs that are
reduce the problem
of its vertices
the graph g

corpus/krapavin2000-test/1024079.txt
colamd
factorization
amdbar
colmmd
matlab
pivot
sparse
amd
row
symamd
pivoting
matrices
cholesky
ordering
superlu
nonzeros
column
symbolic
mc47bd
orderings
absorption
deciency
nonzero
super
symmmd
matrix
nonsymmetric
lu
rows
kr
columns
permuted
aggressive
metric
multifrontal
elimination
kc
dense
fkg
interchanges
factorize
toms
netlib
ll
symmetric
sparsity
uid
twotone
preordering
rothberg
cfd2
goodwin
permutation
aq
nite
median
diagonal
oating
outer
triangular
gaussian
unsymmetric
numerical
ex40
msc00726
finan512
pwt
3dtube
gran
entries
gilbert
pattern
factorized
struct
hall
ata
householder
pds
aect
qr
update
chemical
discarded
aa
submatrix
frg
saad
degree
rectangular
ansi
approximate
blas
26355
supernodal
ex20
nfkg
mathworks
30053
raefsky2
callable
larimore
gearbox
ufl
unassembled
lhr17c
136476
75008
8xx
markowitz
ex14
airlift
quality
ng
ow
davis
nonsingular
cancellation
nds
grimes
harwell
cise
837
jaj
external
lc
degrees
fill
timothy
nnz
836
nding
iso
storage
dynamics
sixteen
dissection
package
www
representative
product
http
mathematical
die
faster
square
routine
florida
navier
ia
stokes
routines
george
modied
cfd
org
partial
superior
gave
ij
military
transposition
tested
irreducible
supercomputers
factors
bug
subsequent
ja
ju
regardless
solely
requiring
du
jc
92
quotient
costly
58
pressure
count
doron
7740
6929
wang1
cavity25
138187
pressurized
duff
enseeiht
isothermal
34518
kaess
umfpack
2606
4562
69981
bova
94444
17576
1592
partial pivoting
column ordering
ordering algorithm
pivot row
cholesky factorization
the amd
aggressive row
row absorption
the symbolic
symbolic factorization
lu factorization
symbolic update
ordering time
the pattern
amd metric
row degree
for sparse
pattern of
minimum degree
column c
nonzeros in
the pivot
outer product
colamd and
ordering quality
sparse matrix
the cholesky
a column
factorization of
symbolic lu
ll in
the matlab
the ordering
external row
super columns
the colamd
better orderings
matlab metric
colamd colmmd
sparse partial
numerical factorization
nonzero entries
gaussian elimination
symmetric matrices
a k
nite element
mathematical software
matrix a
the nonzero
row i
multiple elimination
colmmd amdbar
pivot column
row interchanges
amdbar and
nonzero pattern
super column
kr r
to factorize
kr i
orderings than
a t
of nonzeros
elimination with
matrices in
in matlab
approximate minimum
factorization algorithm
column k
nonsymmetric matrices
rectangular matrices
r k
the factorization
permutation p
software toms
toms v
c k
factorization time
of colamd
degree algorithm
colamd ordering
ordering q
strong hall
zero free
row ordering
uid dynamics
than amdbar
approximate deciency
square nonsymmetric
free diagonal
colamd is
degree ordering
test set
with partial
the matrix
row k
row r
step k
at step
on mathematical
row permutation
kc c
ordering and
the lu
t a
k of
and ng
sparse cholesky
l k
super row
and symamd
symmmd amdbar
colmmd and
amdbar the
symamd symmmd
amd approximation
multifrontal method
colmmd ordering
symmetric ordering
and mc47bd
initial matlab
super rows
computational uid
n fkg
matrix colamd
during numerical
rows i
of column
column j
of row
r r
to compute
is selected
the super
sparse gaussian
th pivot
pivot rows
aa t
chemical process
sparse matrices
the row
and u
k th
oating point
point operations
columns of
matrices for
linear programming
matlab s
we tested
is sparse
l and
of super
any row
of l
k 1
selected as
the sparse
and colmmd
column preordering
pivoting with
s colmmd
on colamd
dense row
nonzero patterns
initial metric
amdbar mc47bd
timothy a
initial aggressive
pattern multifrontal
median result
amd row
of florida
pds 20
gilbert and
median time
and aggressive
ordering methods
product step
absorption is
colamd was
by matlab
arbitrary row
ansi iso
candidate pivot
a davis
and amdbar
y saad
matlab approximation
matrices colamd
e rothberg
seconds matrix
result relative
with amdbar
process separation
columns in
in l
entries in
bound on
metric for
the pattern of
aggressive row absorption
the symbolic update
a column ordering
a t a
pattern of a
of a k
symbolic lu factorization
sparse partial pivoting
external row degree
the amd metric
at step k
the cholesky factorization
with partial pivoting
of a t
colamd colmmd amdbar
kr r k
the ordering time
number of nonzeros
columns of a
l and u
nonzeros in the
elimination with partial
column k of
a k 1
software toms v
the pivot row
cholesky factorization of
on mathematical software
of nonzeros in
mathematical software toms
transactions on mathematical
gaussian elimination with
minimum degree algorithm
minimum degree ordering
by the super
approximate minimum degree
kc c k
nonzeros in l
square nonsymmetric matrices
degree ordering algorithm
lu factorization algorithm
zero free diagonal
our test set
a zero free
for the cholesky
sparse cholesky factorization
during the symbolic
row k of
factorization of a
the minimum degree
has a zero
the outer product
a is sparse
matrix colamd colmmd
kr i k
during numerical factorization
initial matlab metric
the symbolic factorization
the pivot column
column ordering q
k th pivot
column ordering of
row permutation p
matrices in our
symamd symmmd amdbar
amdbar and mc47bd
the symbolic lu
sparse gaussian elimination
nonzero pattern of
the colamd ordering
for sparse cholesky
rows i in
colamd and symamd
computational uid dynamics
k of u
nonzero entries in
the k th
selected as the
to compute the
linear programming problems
c to minimize
oating point operations
of l and
k of a
c k and
of the matrix
used by matlab
row ordering p
for square nonsymmetric
of super columns
super columns in
the matlab approximation
ordering time in
better orderings than
and aggressive row
operations to factorize
the nonzero patterns
timothy a davis
median time relative
the row ordering
of gaussian elimination
matlab s colmmd
in seconds matrix
k of l
compute the sparse
to factorize the
th pivot row
outer product step
k n fkg
the matlab metric
colamd ordering algorithm
nonzero patterns of
with row interchanges
partial pivoting with
symmmd amdbar mc47bd
sparse matrix product
for chemical process
colamd and colmmd
patterns of l
the ordering quality
george and ng
median result relative
initial aggressive row
ordering of m
the nonzero pattern
toms v 30
super row r
pattern multifrontal method
in the symbolic
a symmetric ordering
chemical process separation
result relative to
row absorption is
the column ordering
l u and
in the set
pattern of the
rows and columns
time relative to
of row i
the factorization of
as the pivot
relative to 1
the matrices in
the lu factors
an approximate minimum
l k n
the lu factorization
amount of ll
of ll in
for symmetric matrices
the set c
when a is
the patterns of
all rows i
p is selected
of nonzero entries
the ordering and
acm transactions on
bound on the
the bound on
of large sparse
metric for the
the sparse matrix
not aect the
and a k
is selected as
solution of large
is included in
a matrix a
represented by the
in the matrix
of the matrices
the same pattern
every three stages
column c that
node selection strategies
same nonzero pattern
matrix a where
bound the pattern
absorption during the
of the householder
nonsymmetric matrices rectangular
kr i n
toms v 33
and non symmetric
selection strategies for
matrices rectangular matrices
of a obtained
factorization and ordering
computes the factorization
since it gave
a column approximate
university of florida
candidate pivot rows
k by kr
ordering quality nonzeros
a nonsingular and
matrices matrix n

corpus/krapavin2000-test/1024149.txt
cut
simplex
terminal
calinescu
sparcs
terminals
integrality
cuts
cutting
corner
segment
aligned
ball
sparc
multiway
relaxation
density
embedding
3438
slices
rounding
gap
icut
slice
segments
rays
lp
12n
3n
slicing
cell
geometric
paths
hexagon
endpoints
edge
planar
dual
11n
gn
infinitesimal
mesh
volume
triangle
embedded
edges
planarity
probability
embeddings
concave
coordinates
uniformly
012096
dahlhous
discretized
vertex
optimum
9n
karloff
maximizer
symmetrized
hex
fix
symmetry
659
suffices
analytic
endpoint
discrete
rabani
alignment
disconnected
induces
approximation
ratio
multicommodity
fork
connecting
distances
analytically
lemma
permutation
hyperplanes
schemes
gave
goes
vertices
norm
chooses
contribution
hyperplane
x3
bounds
295
enumerating
provable
bold
duality
gaps
seffi
2161
tationally
undertook
worsened
hanneke
hinting
followingconditions
symmetrize
1539
langberg
bidirected
obliviously
ofk
approximationalgorithm
plification
allk
00009
avidor
generalk
calledterminals
bedding
cells
captured
distance
technically
guided
symmetric
faced
x1
face
flow
capture
closed
closest
diagram
tractable
central
ork
matures
geodesics
infinitesimally
chekuri
snp
adi
multiterminal
transductive
sides
random
boundaries
maximizes
finish
contradiction
devised
restrict
lengths
neu
alignments
ogous
prompted
qf
multicut
cunningham
anupam
straightfor
contributes
understand
derives
infinite
ratios
semidefinite
disconnects
await
thirds
tices
coordinate
removal
simplifies
ward
trian
cplex
mann
gle
557
564
mally
seymour
tabular
discretizations
mapped
ordering
boundary
min
omega
guarantee
located
union
metric
574
amit
naor
way cut
the simplex
cutting scheme
calinescu et
corner cut
3 way
k way
integrality gap
ball cut
cut is
segment e
is cut
12 11
cut by
maximum density
3 terminal
multiway cut
2 aligned
cut of
the corner
the terminals
of calinescu
1 3438
aligned segment
the integrality
the ball
6 11
terminal i
d k
be cut
the 3
geometric relaxation
j aligned
a corner
cut problem
density of
any segment
i j
0 11
the relaxation
linear program
x k
way cuts
planar dual
11 6
a 0
3 x
a cutting
the density
the embedding
e is
of terminals
x 1
rounding scheme
embedded graph
distribution over
x i
the cut
approximation algorithm
a segment
12n 3
connected cut
corner scheme
cutting schemes
ball corner
simplex into
performance ratio
a ball
x 2
lemma 6
the edge
performance guarantee
terminal 1
a rounding
two terminals
cuts of
cut the
et al
gap of
the planar
x 3
with probability
terminal case
our upper
the hexagon
relaxation and
cut in
probability distribution
k p
upper bound
the slices
the probability
at distance
c a
fact 4
point r
the mesh
11 12
j d
than 12n
cut from
cut twice
rounding schemes
corner closest
11n 3
corner cuts
3 cut
terminals that
12 otherwise
discrete sparc
disconnected cut
density contribution
cuts we
three paths
any 3
our sparc
terminals 3
scheme chooses
sparcs we
for 3
between its
a sparc
1 x
bound of
the expected
edge is
the triangle
p i
dual of
expected cost
expected number
the geometric
approximation ratio
simplex is
to terminal
geometric embedding
cut corresponds
is 12
any cutting
k simplex
optimal 3
on segment
simplex the
a disconnected
terminal j
central node
cut thus
terminals i
x j
edge e
that c
the multiway
as half
form expression
the cutting
the cell
cut and
theorem 6
k we
1 k
is chosen
of k
the k
the graph
in 0
cut with
the slice
diagram shows
terminals is
cut a
one zero
for terminal
each terminal
1 3
the endpoints
of times
the segment
improved approximation
with performance
embeddings in
general k
c k
probability that
embedding of
it suffices
segment of
chosen with
terminals in
proof fix
its endpoints
and x
path p
bound for
volume of
approximation algorithms
is at
of 1
closed form
suffices to
the dual
calinescu et al
k way cut
3 way cut
of the simplex
1 2 aligned
a 0 11
p i j
the integrality gap
of calinescu et
way cut of
in the simplex
0 11 6
x 3 x
a cutting scheme
a ball cut
a corner cut
the 3 terminal
e is cut
i j aligned
i j d
a k way
maximum density of
is cut by
the planar dual
the maximum density
cut of the
of the 3
multiway cut problem
be cut by
for a 0
x 1 x
the k way
j aligned segment
the ball corner
ball cut is
the simplex into
ball corner scheme
cut is made
density of any
of any segment
integrality gap of
cut by a
the ball cut
segment e is
2 1 k
that c a
our upper bound
3 x k
x i r
in the planar
cuts of the
of the terminals
path p i
for a a
2 6 11
d a 0
a a 2
lemma 6 4
of the relaxation
1 x 2
0 for a
the l 1
the expected number
of the mesh
c a is
3 terminal case
the corner cut
way cuts of
cut is chosen
than 12n 3
is 12 11
is cut is
between its endpoints
aligned segment e
the 3 way
2 aligned segment
half the l
closest to terminal
corner cut is
e is e
the corner closest
terminal 1 is
x 2 6
less than 12n
planar dual of
only one zero
the simplex the
a rounding scheme
gap of the
of 1 3438
a disconnected cut
any 3 way
as half the
any cutting scheme
the geometric relaxation
k p e
the simplex is
one zero a
3 x 4
d has only
corner closest to
of 12 11
11 12 otherwise
an i j
expected number of
thus the expected
the density of
of the embedding
and d a
a is strictly
with performance ratio
in the corner
the k simplex
the multiway cut
optimal 3 terminal
of the ball
is at most
x i and
the edge is
a 0 for
the probability that
i r i
number of times
3 2 1
1 3 from
chosen with probability
that the edge
a distribution over
form expression for
closed form expression
distance between its
is the best
the volume of
parallel to the
it suffices to
a 1 2
d k is
that x i
for the 3
is chosen with
the best possible
a probability distribution
theorem 6 2
and x j
of the triangle
2 x k
cost of the
show that c
e a a
probability of choosing
of x i
probability distribution over
probability 1 2
arbitrarily close to
aligned segment of
is strictly concave
x k such
fix x 1
relaxation and the
cut from p
linear program and
such x 3
k maximizes d
the planarity of
cost multiway cut
way cut in
12 otherwise the
the three terminal
edge is cut
q k 1
maximizes d k
density contribution of
cutting schemes that
3 from its
like our upper
cutting scheme with
if the endpoints
the optimal 3
the simplex 1
provable upper bounds
terminals in random
way cut is
to vertex i
to be cut
integrality gap is
way cut and
other such x
computational experiments we
most k p
k subsets each
work of calinescu
integrality gap and
0 659 1
density of p
3 terminal problem
with probability e
distribution over sparcs
through the cell
graph calinescu et
1 3438 k

corpus/krapavin2000-test/1024162.txt
frobenius
lattice
lenstra
polytope
aardal
instances
prob20
prob11
cuww1
branch
cuww5
prob10
lc
coefficients
infeasible
prob1
hurkens
hyperplanes
reformulation
sublattice
infeasibility
decompose
homomorphism
cornu
ejols
integer
gamma2d
wolsey
dawande
cplex
jr
asz
lov
2000b
width
determinant
rk
ry
hyperplane
diophantine
px
scarf
cuww2
selmer
gamma1222
louveaux
ofa0
decomposable
1983
isomorphism
vectors
sylvester
2000a
1884
gcd
simplex
branching
million
harder
intersect
quit
coordinate
search
interval
hermite
wi
dimension
feasibility
direction
delta
formulation
dual
1978
a0
gamma3
integral
relaxation
rank
ker
print
projected
coefficient
64
reformulated
short
gamma1
149
thin
euclidean
01243
prob174
verweij
nmakes
knapsacks
gamma3667
fukuda
12223
py
vectorx
ofa1
takea0
cassels
0satisfyinga
prob2
beyer
1948
zgiven
12224
presolver
5411
hungerford
cuww2366794890873365cuww3242693640760683cuww4132125284479268104723595
08061
zturns
thetaq
brauer
grbner
1942
zsuch
bram
0202
presolve
odseth
7797
cuww3
khinchine
cuww1122246111989643481
cuww4
whicha
prob164
8139
002prob113
weismantel
coefficientsa1
numbersa0
baniak
15024
donet
witha1
nhave
7912
2360
prob153
dinate
41165
hnf
prob102
orsa
prob144
08049
feasible
spanned
column
solved
solve
claim
fy
vector
pure
schrijver
j2j
decompo
curran
0059
stern
hendrik
financed
thetam
fmrx
0is
gamma10
ct98
coor
negativity
intersecting
tree
decomposition
axes
directions
a1
nonnegative
matics
erd
lauritzen
505
tl
961
basis
contradicts
gammam
erb
russian
kannan
greenberg
gammaz
exceptionally
sition
integers
hard
1992
frobenius number
the frobenius
the lattice
lattice l
a coefficients
the instances
and bound
branch and
l 0
z n
integer vector
by branch
prob11 prob20
lenstra s
infeasible instances
instances prob11
an integer
the polytope
instances cuww1
lattice lc
by aardal
a lattice
instances that
vectors p
of instances
hurkens and
for branch
cuww1 cuww5
aardal hurkens
prob1 prob10
lattice hyperplanes
vector x
and lenstra
contain an
b 0
full dimensional
polytope q
decompose with
aardal et
search nodes
the reformulation
a basis
integer programming
and r
instances we
for instances
that decompose
cornu ejols
direction e
solve by
search tree
d l
the a
width of
computing time
delta 1
and jr
the determinant
a 0
p and
to solve
r z
jr i
tree search
interval i
and prob1
node limit
lattice hyperplane
large frobenius
n simplex
projected polytope
frobenius numbers
lattice basis
cuww5 and
million nodes
and wolsey
nodes created
1 gamma2d
of lattice
pure sublattice
lattice z
search s
decompose as
gamma2d j
unit direction
short vectors
basis reduction
search algorithm
a homomorphism
lower bound
number for
reported on
these instances
first group
lov asz
search direction
integer point
50 million
polytope s
the integer
determinant of
instances with
the interval
computational study
that instances
computational results
integer multiple
sublattice of
lc is
bound on
x f
r n
n gamma1
the instance
basis for
r are
coefficient a
the search
bounded from
a polytope
to assumption
a vector
the width
and since
instances are
s algorithm
for l
are short
infeasible and
constant depending
instances were
the dimension
f a
not contain
were generated
instance is
large compared
same size
nodes and
l c
good search
column b
ry 2
generated such
on infeasible
first isomorphism
feasibility search
prob20 were
integer branching
solved within
solve using
thin in
dual lattice
louveaux and
dual l
to lenstra
decomposable structure
our tree
comparable sizes
branching algorithm
x a0
jr 1983
verify infeasibility
ker f
infeasibility for
wolsey 2000
2d j
w lenstra
coefficients decompose
and quit
coefficients as
search node
ejols and
lenstra 2000b
lenstra jr
and dawande
unit directions
short p
integer direction
of lenstra
px mod
second computing
of cplex
integer width
linear diophantine
al 2000a
dawande 1999
hermite normal
lattice reformulation
by cornu
of frobenius
prob10 but
2 z
e n
basis vectors
is infeasible
coefficients are
depending only
notice that
l y
the frobenius number
the lattice l
branch and bound
the a coefficients
p and r
on the frobenius
instances prob11 prob20
by branch and
contain an integer
an integer vector
vectors p and
the lattice lc
of the instances
a vector x
for branch and
hurkens and lenstra
instances cuww1 cuww5
aardal hurkens and
lattice l 0
frobenius number for
lenstra s algorithm
of the lattice
not contain an
solve by branch
aardal et al
i and jr
to solve by
be the lattice
the instances we
e n gamma1
basis for l
tree search algorithm
by aardal hurkens
class of instances
and jr i
a basis for
of b 0
and r are
jr i j
determinant of the
lower bound on
d l 0
vector x f
r are linearly
a pure sublattice
short vectors p
the polytope q
frobenius number of
large frobenius numbers
of lattice hyperplanes
group of instances
l 0 c
b 1 gamma2d
and prob1 prob10
the projected polytope
the unit direction
lattice z n
an integer point
cuww5 and prob1
cuww1 cuww5 and
50 million nodes
direction e n
1 gamma2d j
polytope q is
number of lattice
unit direction e
of instances prob11
a 0 a
the interval i
the first group
the determinant of
does not contain
for l 0
easy to solve
lattice l is
compared to p
for the lattice
due to assumption
integer multiple of
an integer multiple
vector x 2
constant depending only
be a lattice
for the instances
of a polytope
bound on the
hard to solve
x f and
x 2 z
instances that are
a lower bound
is a basis
on the dimension
a constant depending
is an integer
that f a
l 0 and
large compared to
that the a
the same size
the image of
number of nodes
l 0 is
in r n
in the unit
our results we
depending only on
p i and
the search tree
to p i
q in the
we demonstrate that
the column b
see that instances
h w lenstra
instances were generated
instances we consider
first isomorphism theorem
l p t
by aardal et
the first isomorphism
to lenstra s
n gamma1 is
integer branching algorithm
the integer width
in appendix 1
nodes created at
computing time in
formulation in x
computing the frobenius
short p and
lenstra jr 1983
lattice basis reduction
before presenting our
of comparable sizes
to solve using
extremely hard to
louveaux and wolsey
0 is integer
integer number t
some known results
with short vectors
pure sublattice of
b b nodes
second computing time
and dawande 1999
generated such that
basis b 0
cornu ejols and
of delta 1
w lenstra jr
p k g
a decomposition a
on infeasible instances
r k p
integer vector 2
the last vector
integer width of
that decompose with
lc is equal
2 z n
w s d
reported on in
the n simplex
in x variables
frobenius number we
a coefficients that
prob11 prob20 were
b b time
infeasible instances with
et al 2000a
the lattice z
kernel of f
by cornu ejols
a tree search
reported on by
ejols and dawande
the node limit
coefficient a 0
frobenius number is
that instances with
a second computing
the computational results
coefficients that decompose
for instances prob11
to verify infeasibility
search nodes and
image of z
of nodes created
lattice lc is
width of q
decompose with short
of lenstra s
and lenstra 2000b
s contains an
a coefficients as
frobenius number can
decompose as follows
our tree search
and wolsey 2000

corpus/krapavin2000-test/1024429.txt
pictorial
appearance
image
iconic
locations
posterior
energy
location
erent
articulated
configuration
parts
matching
images
ij
minimization
training
covariance
di
chamfer
recognition
sampling
connections
joint
configurations
gaussian
likelihood
deformable
foreground
object
grid
faces
joints
deformation
pixels
match
occluded
ml
learned
vision
ciently
foreshortening
fischler
elschlager
parent
rectangle
estimate
learning
body
filters
spring
statistical
pose
cient
human
people
root
mst
mahalanobis
convolution
torso
orientation
vertex
mises
snakes
tracking
estimation
bodies
matches
transformed
ji
seeing
children
distance
prior
transform
viterbi
desktop
arm
mouth
ideal
generic
depth
background
diagonal
angles
visual
corner
erence
occlusion
connection
hausdor
erode
subtraction
nose
sample
eye
costs
distributions
child
indicator
objects
revolute
detections
pupil
limbs
discrete
finding
specifies
connecting
imprecise
arranged
template
formulation
arg
picking
bayesian
geometric
relationships
map
von
noisy
silhouette
articulation
eigenspace
stretching
face
patches
spatial
detect
binary
told
nearby
connected
segmentation
corners
tree
leg
eyes
hypotheses
heuristics
features
convolving
ambiguities
informative
border
equation
position
likelihoods
rigid
leaf
cult
doesn
motion
measuring
learn
flexible
positions
count
measures
samples
decisions
transforms
agree
transformations
modeling
sampled
categorization
matrix
shapes
cylinder
generative
detecting
derivative
restricting
2008
separable
distances
77
coarse
overlap
probability
intuitively
discretization
orientations
quality
peaks
marginal
parameterized
counts
indices
markov
detection
limb
rosales
pinz
coughlan
spherically
jianzhuang
occlude
pictorial structure
each part
of parts
between parts
pictorial structures
an image
the appearance
the pictorial
the iconic
location of
locations for
location for
v j
energy minimization
di erent
possible locations
location l
l i
the posterior
the parts
training examples
v i
the location
the image
match of
the energy
connections between
part v
structure models
best location
matching results
l j
d ij
the object
a location
appearance parameters
object configuration
human body
posterior distribution
p l
appearance of
parts and
parts are
i l
parts can
a pictorial
distance transform
statistical framework
connected parts
iconic representation
the ml
best match
locations of
minimization problem
the joint
e ciently
sampling from
map estimate
in equation
a gaussian
individual parts
transformed space
binary images
two parts
o h
cient algorithms
deformation costs
ml estimate
object configurations
connection parameters
model to
energy function
part based
an object
e cient
binary image
the connections
optimal location
covariance matrix
of part
the root
part models
transformed locations
relative locations
deformable configuration
ideal relative
the chamfer
of connections
a part
part and
the likelihood
matching algorithms
object recognition
the model
minimization algorithm
at location
we model
of seeing
learned model
t ji
diagonal covariance
the best
l r
a tree
from training
maximum likelihood
the prior
part as
depth d
image given
appearance models
joint distribution
finding the
the map
model parameters
parts the
the deformation
image is
fischler and
multiple good
background subtraction
iconic indices
child v
erent modeling
five parts
structure model
map estimation
foreground pixels
structures approach
and elschlager
like connections
of pictorial
statistical formulation
chamfer distance
s functions
sample a
from examples
distribution over
the locations
of finding
the statistical
object is
models from
of possible
pairs of
parts is
prior distribution
we sample
the foreground
and matching
a model
likelihood of
for v
gaussian distribution
spring like
generalized distance
modeling schemes
configurations from
single part
good matches
novel images
articulated objects
the matching
estimate of
to compute
binary decisions
mahalanobis distance
object location
distance transforms
the learned
dynamic programming
b j
distribution for
parameters for
part is
of v
of connected
compute the
computer vision
an articulated
decisions about
a deformable
parts in
the rectangle
these models
quite di
indicator function
vision v
configuration of
the grid
vertex v
each image
between transformed
generic recognition
estimation procedure
desktop computer
parts connected
image rather
border area
ij l
for each part
pairs of parts
to an image
a location for
the location of
pictorial structure models
connections between parts
model to an
from the posterior
the energy minimization
locations for each
possible locations for
energy minimization problem
best match of
of possible locations
the pictorial structure
the appearance of
location for the
the posterior distribution
the best location
a pictorial structure
p l i
the iconic representation
best location for
of each part
match of a
the two parts
of a part
the best match
the map estimate
e cient algorithms
location l i
part v i
sample a location
of the parts
model the appearance
at location l
a model to
of v j
for the root
of a model
from training examples
sampling from the
of connections between
location of each
p i l
of the object
energy minimization algorithm
the s functions
the deformation costs
form a tree
likelihood of seeing
each part and
the pictorial structures
the optimal location
location of part
of part v
the object configuration
the ml estimate
matching results on
the appearance parameters
j l i
of connected parts
v j as
l i l
location of a
o h 2
location for each
the distance transform
the learned model
the transformed space
the human body
of l i
in the image
pair of connected
spring like connections
individual parts and
the connection parameters
the appearance models
child v c
the statistical framework
of a pictorial
a single part
the relative locations
the object location
appearance parameters for
location of v
pictorial structure model
di erent modeling
location for v
fischler and elschlager
b j l
matches of a
appearance models for
object is at
the individual parts
pictorial structures approach
the chamfer distance
appearance of each
erent modeling schemes
the ideal relative
image given that
the likelihood of
the connections between
of the energy
parts and the
location of the
v i is
we model the
the joint distribution
number of possible
the form of
the problem of
parameters for each
problem of finding
l r i
for v j
h 2 n
parts can be
of an object
the maximum likelihood
j as a
finding the best
that the object
we sample a
to compute the
in equation 2
in equation 1
quite di erent
values for t
vertex v i
form of p
shown in equation
to compute each
as a gaussian
more e ciently
the locations of
l i and
for the object
of the image
in the grid
match of the
an image is
a gaussian distribution
of the rectangle
object in an
for each child
in o h
estimation this is
image rather than
parent v i
part v j
possible locations of
von mises distribution
by fischler and
an observed image
an image rather
parts connected by
locations of parts
the possible locations
connected by flexible
models from examples
replacing the min
an object configuration
position of one
collection of parts
relationships between parts
good matches of
the parts are
for t ji
ml estimate of
a mahalanobis distance
ji l j
configurations from the
pictorial structures the
parts arranged in
ij l i
parts are connected
pose space for
b c l
an articulated object
our method works
all the parts
placed at location
the binary image
by background subtraction
an image given
binary decisions about
relative locations of
t ji l
pictorial structure to
compute the s
of d ij
each child v
the iconic index
a deformable configuration
parts are occluded
structure model to
a particular form
distribution of l

corpus/krapavin2000-test/1024484.txt
csp
membership
rules
consistency
constraint
arc
equality
chr
krzysztof
monfroy
apt
rule
unk
domains
adder
waltz
ecl
propagation
labeling
allen
eric
r3
uhwirth
elan
satisfaction
notions
neg
r2
junction
programming
valid
generation
dnot
solvers
xor
af
predefined
r1
ps
scenes
pos
logic
polyhedral
consistent
1983
gh
enot
msign
closed
arity
constraints
gc
var
arrow
ternary
i3
cb
o2
fork
ih
boolean
relaxation
fr
viewed
1998
base
extends
claire
i2
temporal
permutation
ge
f0
overlaps
cons
gamma
seconds
i1
compound
parametrized
o1
jh
ffl
cd
ef
atomic
solver
disequality
hentenryck
ai
lying
ab
confine
fag
coincides
respective
valued
tuples
feasible
fuzzy
query
triples
hc
winston
assignment
bool
clarify
usefulness
1975
brand
hj
imp
inconsistency
notion
2g
language
ed
1992
characterize
computations
retained
cg
validity
cardinality
coincide
mains
shadows
castro
ops5
contradiction
conjunction
subsequence
minimal
x1
hg
enforce
equivalence
weak
participate
equals
weaker
formulas
sebastian
page
room
1g
relations
ba
schedulers
translated
premise
abbreviate
unifies
additionally
virtue
production
eg
truth
implication
rewrite
built
prolog
hi
domain
fe
bc
iff
1988
concerning
and6
rigotti
forgy
beek
feasability
ringeissen
frhwirth
mackworth
borovansky
kirchner
luger
pedrycz
abdennadher
tsang
mohr
laburthe
caseau
schaerf
unavoid
demons
masini
codognet
gomide
action
syntax
shall
automatically
signs
entirely
assignments
suffices
equality rules
membership rules
rule consistency
constraint programming
rules generation
arc consistency
constraint c
a csp
csp s
rule based
membership rule
based programming
rule consistent
the equality
the membership
generation algorithm
krzysztof r
r apt
programming viewed
a constraint
a rule
eric monfroy
csp p
apt and
arc consistent
constraint propagation
and eric
the rule
rule a
the constraint
as rule
of rules
the rules
d x
of constraint
d 2
full adder
closed under
local consistency
rules that
domain of
explicitly given
gamma gamma
minimal valid
equality rule
valid for
rules are
finite domains
f c
rules and
valid equality
built out
and membership
the domain
6 a
constraint satisfaction
a x
i ps
csp base
ecl i
algorithm generated
ps e
the chr
t base
the domains
2 c
variables x
c ffl
x 6
variable x
end end
consistency and
boolean constraints
consistent w
by means
rules we
of variables
fr uhwirth
on base
polyhedral scenes
c is
constraint logic
of arc
o m
is valid
is closed
of rule
this rule
satisfaction problems
to constraint
the csp
domains d
all minimal
consistency for
rules of
ffl we
propagation rules
respective domains
current domain
rule is
rules in
means of
csp is
rules for
x i
base if
r2 r3
y z
arbitrary arity
under r
predefined explicitly
allen 1983
small finite
is arc
chr rules
describing polyhedral
predefined constraints
logic programming
o b
for constraints
these rules
c on
of base
viewed as
the considered
and arc
valued logic
b o
of predefined
tuples d
following table
2 d
some constraint
p based
d o
r1 r2
given constraints
rules r
under all
the variables
c of
and xor
for c
each variable
i 6
domains of
rule r
have d
not closed
constraints of
x y
finite constraint
with arc
not arc
hand x
consistency that
var of
permutation c
such csp
than arc
zero zero
basic constraints
gamma dnot
valid rules
table x
adder constraint
of x
ffl given
notion of
application of
in 0
a repeated
base we
consistency the
the variable
consistency to
1 consider
the form
x we
for e
b m
csp based
given finite
programming can
handling rules
a permutation
where d
do for
notions of
consistency in
to c
m s
repeated application
of local
m b
constraint of
programming language
compute with
constraint handling
element d
the equality rules
the membership rules
rules generation algorithm
rule based programming
krzysztof r apt
equality rules generation
d 2 c
constraint programming viewed
programming viewed as
viewed as rule
as rule based
a constraint c
and eric monfroy
apt and eric
equality rules and
r apt and
membership rules generation
sequence of variables
the rule a
the constraint c
rule a x
domain of x
of local consistency
rule consistency and
i 6 a
a csp p
x 6 a
a x 6
and the membership
constraint c on
the domain of
is valid for
built out of
x i 6
is closed under
6 a to
by means of
ecl i ps
consider a csp
to constraint programming
r t base
and membership rules
c ffl we
rule consistent w
generation algorithm generated
constraint c of
constraint c is
i ps e
membership rule consistent
of arc consistency
all minimal valid
that the rule
rules of the
of variables x
x y z
consistent w r
of the form
of rule consistency
ffl we call
explicitly given constraints
approach to constraint
valid equality rules
the current domain
valid for f
out of predefined
form a x
valid for c
current domain of
arc consistency for
and arc consistency
closed under this
for f c
closed under all
types of rules
a x i
each variable x
type of rules
constraint satisfaction problems
constraint logic programming
gamma gamma gamma
r1 r2 r3
notion of local
c is not
of the variable
the domains of
the form a
c is based
do for each
2 d i
c is closed
is arc consistent
based on base
consistency and arc
respective domains d
small finite domains
domain of y
the full adder
constraints of arbitrary
all tuples d
of arbitrary arity
for describing polyhedral
membership rules for
predefined explicitly given
describing polyhedral scenes
membership rules are
the equality rule
b d o
closed under r
csp p based
rules and membership
d o m
under this rule
p is arc
equality rules are
a 2 d
given a constraint
the following table
p based on
of the equality
application of a
generation algorithm and
that is valid
rule a b
for constraints of
d x i
2 c we
not closed under
from the domain
domain of the
of the rules
i 2 1
variable x j
p is based
c of p
we have d
a to c
some d 2
t base if
a csp base
r for e
of predefined explicitly
on a csp
following table x
csp based on
explicitly given finite
such csp s
minimal valid equality
consider a constraint
constraint programming can
table x y
than arc consistency
not arc consistent
arc consistency to
a permutation c
f c ffl
extends the rule
end end end
var of cardinality
have d x
gamma gamma dnot
full adder constraint
base we have
notions of local
with arc consistency
ffl we say
membership rules we
constraint programming and
a repeated application
to a constraint
tuples d 2
is not arc
the constraint propagation
equality rules for
of constraint propagation
consistency for constraints
m s f
rules that are
1 consider a
on a sequence
for each variable
w r t
is not closed
rules are considered
programming can be
for all tuples
2 1 n
based on e
of rules r
constraint handling rules
of a csp
of a rule
of the domains
such a rule
repeated application of
set of rules
rules and the
c we have
of constraint programming
of all minimal
the programming process

corpus/krapavin2000-test/1024485.txt
subtype
clp
pred
typing
typed
prolog
coquery
fages
subtyping
francois
inequalities
constructors
atom
predicate
pottier
csld
declarations
substitution
emmanuel
predicates
ssi
prescriptive
int
clause
head
denitional
tclp
infered
coercions
logic
simplication
lakshman
loat
resolvent
acyclic
satisability
pl
sicstus
wallace
parametric
frey
genericity
substitutions
query
polymorphism
herbrand
mycroft
jaar
lassez
oat
clauses
constraint
arity
typable
inference
subtypes
reddy
arities
satisable
keefe
polymorphically
suprema
nite
lattice
programs
renaming
typings
hanus
colmerauer
heuristic
checking
float
resp
dened
1992
symbols
declared
renamed
unsatisable
smolka
beierle
2000a
checker
proposition
derivation
func
permissive
constructor
iso
infer
libraries
contravariant
posets
declaration
exibility
denition
topor
djb
sum_list
smaus
decomp
poterms
inferring
atoms
acyclicity
rule
inequality
covariant
glb
ill
prop
les
rules
metaprogramming
lub
unication
1991
rst
functor
tail
polymorphic
hill
library
occurrence
cubic
1989
le
identication
ub
innite
maximal
1987
valuation
poset
1988
00
checked
hagl
setof
varleft
denumerable
tiuryn
pfenning
somogyi
kfoury
varright
yardeni
sum0
sum1
reduction
fd
list
meta
dierent
judgement
height
expresses
raised
subject
arithmetic
kaci
dietrich
ait
2000b
overloading
rejected
queries
1984
inferred
bottom
errors
program
triv
predi
reductions
arguments
compile
detected
inferencing
clash
supertype
constraints
induction
append
mutually
assoc
ground
collected
consistency
decreases
greatest
preserves
derivations
resolution
ith
cates
programming
instantiation
sorted
options
the type
type system
subtype inequalities
of subtype
well typed
constraint logic
logic programs
type constructors
typing constraint
subject reduction
and emmanuel
francois fages
emmanuel coquery
fages and
type constraints
left linear
type inference
type checking
variable typing
a type
type declarations
prescriptive type
typing u
maximal solution
subtype relations
for predicates
of inequalities
type list
the subtype
minimum type
rule atom
the ssi
declared type
the predicate
the satisability
satisability of
example 7
simplication rules
denitional genericity
for type
of type
type is
type structure
declarations for
list bottom
reddy 1991
iso prolog
infered type
f loat
lakshman reddy
clp programs
logic programming
the typing
execution model
the heuristic
a predicate
of types
type checked
k 00
a renaming
a prescriptive
associated to
constructors of
parametric polymorphism
the subtyping
the declared
system of
rule head
acyclic left
dierent arities
nite types
csld resolution
o keefe
the simplication
the solving
with suprema
heuristic type
of clp
herbrand terms
predicate symbols
type variables
type checker
with type
the system
types for
types are
type of
q 0
a lattice
the rule
constraint domains
substitution steps
inequalities is
programming errors
is typable
the denitional
ill typed
a typed
w r
the types
typed in
an inequality
reduction for
is satisable
prop 2
sicstus prolog
between type
and head
list a
type systems
checking the
coercions between
int pred
a csld
in solved
mycroft o
type pred
heuristic infered
ssi problem
solved form
clp x
the func
the wallace
typed with
subtype constraints
pred heuristic
lassez 1987
subtyping order
renamed apart
genericity condition
typed constraint
upper type
in clp
inferring the
csld resolvent
resolvent of
heuristic upper
jaar lassez
clp r
pottier 2000a
argument of
and predicate
function symbols
proposition 2
constraint programming
subtype of
of constraint
the derivation
for function
r t
column indicates
a subtype
cubic time
62 v
prolog the
between constraint
typed program
type schemes
list int
pred pred
type substitution
clp fd
typable in
of subtyping
of sicstus
atom and
parameters in
and queries
variables in
any type
inequalities in
no solution
of subject
inequalities between
basic types
for typing
of constructors
for inferring
u 00
constraint system
program is
the rules
the program
a clause
on variables
of predicates
type error
our type
be typed
substitution such
inference for
predicate is
system is
ssi associated
func rule
constructors k
semi unication
their arity
contravariant type
posets with
constraint logic programs
typing constraint logic
francois fages and
and emmanuel coquery
fages and emmanuel
the type system
of subtype inequalities
variable typing u
the type constraints
is well typed
the satisability of
of the predicate
that the type
system of inequalities
subject reduction for
for type checking
type declarations for
the type declarations
prescriptive type system
type constraints in
type constructors of
the declared type
subtype relations between
a prescriptive type
lakshman reddy 1991
declarations for function
of the type
of a predicate
and predicate symbols
function and predicate
w r t
of dierent arities
types for predicates
constructors of dierent
atom and head
the rule atom
a variable typing
subtype inequalities in
acyclic left linear
the denitional genericity
the simplication rules
of the system
the type checker
a well typed
the type of
of type constructors
type inference for
program is well
type of the
by the type
column indicates the
has no solution
csld resolvent of
a maximal solution
is a csld
heuristic upper type
between constraint domains
coercions between constraint
in solved form
well typed in
of subtype constraints
relations between type
jaar lassez 1987
denitional genericity condition
infered type list
of inequalities is
between type constructors
if k 00
the subtype inequalities
type list bottom
heuristic infered type
typable in the
libraries of sicstus
the maximal solution
a csld resolvent
of subject reduction
for inferring the
checking and type
minimum type list
inference for predicates
pred heuristic infered
mycroft o keefe
system of subtype
checking the satisability
the system of
a subtype of
the type checking
at the left
type of variables
a predicate or
for function and
is typable in
of sicstus prolog
type checking and
our type system
of the form
k k 0
type is a
in the type
s n a
a program is
r t the
substitution such that
a type error
structural induction on
if a program
of a type
the system is
associated to the
with the type
type system is
resolvent of q
iso prolog the
posets with suprema
ssi associated to
type checked to
typed with type
type inference algorithms
rejected at compile
the heuristic type
parametric polymorphism and
some variable typing
abstract execution model
the solving of
subject reduction w
the maximum type
minimum type of
k 0 g
in the clp
polymorphic type system
of type constraints
inequalities between parameters
the rule head
the unknown types
a type substitution
subtype inequalities and
constraints in q
a typed constraint
execution model of
maximal solution of
the abstract execution
the subtyping order
q 0 query
error is raised
not generate false
bottom pred heuristic
the intended type
unknown types for
the ith argument
exists a substitution
the ssi associated
solving of subtype
type checking algorithm
the heuristic upper
contravariant type constructors
simplication rules do
type is computed
the wallace library
is ill typed
clauses and queries
the ssi problem
hill topor 1992
proof by structural
a at type
maximal solution for
an acyclic system
the minimum type
the func rule
systems of subtype
well typed clp
is satisable over
ith argument of
typed constraint system
reduction w r
of a renaming
prescriptive type systems
a renaming of
if the simplication
satisability of subtype
declared type of
parameters to their
list f loat
inequalities is satisable
the derivation of
the parameters in
the predicate is
by structural induction
of the types
we have u
the left of
logic programs in
a substitution such
the second system
by collecting the
to the typing
the acyclicity of
1 the rules
in a typed
the typing of
the predicate the

corpus/krapavin2000-test/1024923.txt
normed
renement
backward
automaton
renements
simulations
nite
lv95
forward
reachable
branching
simulation
automata
prophecy
trace
norm
history
u2
fragment
bisimulation
ib
forest
stuttering
decidable
s0
traces
specication
transition
unfold
innite
denition
preorder
gs95
invariants
soundness
action
inclusion
proposition
predicate
preorders
al91
index
nat
completeness
dene
u0
bisimulations
gw96
sall93
gssl93
nam97
prex
_
specications
transitions
totality
adapted
u3
subautomata
tautology
provers
rst
denitions
nitely
executions
clause
nal
invisible
dened
tau
proving
relations
bisimilarity
gri00
nonnal
conjunct
dashed
lemma
specied
correspondence
matched
nondeterminism
ns95
buffer1
ext
ends
actions
founded
ioa
deterministic
decidability
pvs
relates
trivially
denes
reuse
image
convergent
satises
asserts
primed
execution
formula
safety
reachability
execs
hsv94
weijland
klop
i2ia
ak96
namjoshi
glv97
mue98
dgrv00
onig
technically
suces
constitute
seq
vg
i2i
simulated
buffer2
glabbeek
counterexample
election
veri
turing
routine
formalized
unfolding
superposition
9v
niteness
untimed
verication
leader
reasoning
hol
injective
acts
relation
isabelle
transfer
fifo
ip
mappings
constitutes
sound
dierence
past
characterization
proofs
abadi
fragments
isomorphism
establishing
nondeterministic
halt
exive
carry
inductively
cumbersome
sucient
corollary
strengthen
lamport
assertion
dicult
checking
induction
specifications
equivalence
move
logic
indicated
receive
verification
name
liveness
timed
speci
implication
declare
labeled
technical
equational
incoming
compositional
specification
restricted
correctness
undecidable
send
abstraction
dnv95
bcg88
lv96
owicki
a normed
normed forward
forward simulation
normed backward
simulation from
step renement
backward simulation
forward simulations
backward simulations
renement from
a to
step renements
to b
normed history
execution fragment
index relation
branching forward
norm function
a step
of normed
states a
history relation
history relations
an execution
states b
states of
of b
relation from
a states
start states
from b
b proof
s a
b then
a t
a forest
a branching
trace inclusion
nite execution
a nite
automaton c
unfold a
execution correspondence
image nite
action name
b has
start a
b to
2 start
start b
partial completeness
reachable states
a ib
prophecy relations
adapted normed
reachable a
ib b
normed prophecy
level specication
normed simulations
is decidable
automaton a
the norm
automaton b
if s
condition 2
b is
each action
norm functions
forest and
related via
an adapted
an automaton
trace s
a a
the automaton
after b
traces a
reachable b
and normed
relation indicated
that normed
ends in
a is
simulations and
b 2
b if
b 0
state s
index of
automata a
in u
state variables
a and
from automaton
arbitrary norm
is image
r related
proof method
is deterministic
a h
t b
then b
higher level
that ends
of automata
r b
relation i
tautology checking
branching bisimulation
no normed
to normed
clause reachable
invisible nondeterminism
transfer condition
branching backward
in lv95
b and
lower level
a forward
from states
c to
a there
by lemma
dashed lines
start state
b s
2 if
an index
to automaton
a has
a norm
proposition 5
name a
be simulated
from a
is nite
b u
f s
if b
the dashed
same trace
fragment that
simulation between
completeness result
and b
a state
a transition
to prove
trace of
there exists
a b
branching bisimilarity
reachable subautomata
prophecy relation
f related
v predicate
of lv95
receive v
founded set
global reasoning
gssl93 sall93
simulations if
regular normed
v nat
its reachable
level transition
ext a
send v
a u2
nite invisible
no step
then a
nite then
are reachable
the adapted
decidable whether
u 2
in condition
complete proof
all states
soundness of
b b
simulations are
matched by
theorem provers
prex of
a preorder
a 0
suppose that
each state
state of
1 if
simulations in
s 2
initial condition
u2 u3
last state
is routine
suppose b
normed forward simulation
from a to
is a normed
simulation from a
a to b
a step renement
a normed forward
normed backward simulation
step renement from
forward simulation from
normed forward simulations
backward simulation from
a normed backward
normed backward simulations
renement from a
is a step
b then a
s a t
history relation from
an execution fragment
branching forward simulation
if s a
relation from a
states of a
is a forest
from b to
a states b
is a branching
a branching forward
normed history relation
has an execution
a normed history
s 2 start
an index relation
normed history relations
the norm function
a t b
a forward simulation
states a states
states of b
b to a
n is a
each action name
action name a
a ib b
a forest and
index relation i
renement from b
1 if s
that ends in
is an execution
to b then
a and b
forward simulations and
of step renements
complete proof method
s then b
the relation indicated
relation indicated by
a nite execution
b is deterministic
from b 0
branching forward simulations
is image nite
an adapted normed
exists a normed
a b 2
2 if s
for each action
a is a
from c to
lemma 5 4
b 0 to
state of b
then a b
a r b
b 2 r
2 start a
b is a
the dashed lines
s a a
b and a
b n is
state s and
by the dashed
j b u
checking is decidable
t b then
nite execution of
ends in u
states b and
automata a and
tautology checking is
index of 0
a are reachable
of normed forward
arbitrary norm function
execution fragment that
to b let
a h c
is an adapted
start a then
then b has
b has n
b if there
f n is
execution of a
of a to
if s 2
to a 0
in condition 2
of a and
start states of
are r related
an arbitrary norm
proposition 5 6
for each state
is a nite
in u and
state of a
that starts in
i j b
a has an
that 1 if
the same trace
a there is
0 to a
by lemma 5
of b with
a complete proof
a to c
all states of
a f b
from states a
is b related
reachable a s
backward simulations and
constitutes a normed
unfold a is
simulations and normed
forest and a
higher level specication
start b 6
its reachable states
if is nite
a branching backward
execution that ends
nite invisible nondeterminism
adapted normed backward
completeness of normed
starts in u
no step renement
as we observed
r related via
b related to
to b consists
of a normed
and backward simulations
simulation from b
to b if
to its reachable
states a to
execution fragment with
of normed backward
a to states
branching backward simulation
exists no normed
founded set s
trace s 0
a transition predicate
partial completeness result
norm function is
related to s
proof method for
b is image
well founded set
c to e
and step renements
soundness of normed
simulation from c
a a a
b 2 if
and 0 are
of a are
r is a
the denition of
execution fragment of
some well founded
the totality of
a to itself
function from states
follows by lemma
b consists of
that and 0
method for establishing
s 0 a
nite prex of
a start state
in u such
such that 1

corpus/krapavin2000-test/1027341.txt
yes
mobility
waypoint
border
statistic
mst
uniformity
pstat
eect
tpause
brownian
mobile
deployment
voronoi
hoc
spatial
vmax
ad
delaunay
cells
triangulation
occupancy
pmove
longest
simulations
region
intensity
pause
900
cell
dierent
stationary
statistics
networks
t_p
density
diagram
velocity
vmin
edge
uniform
transmitting
wireless
uniformly
intense
tests
nearest
statistical
node
graphics
motion
center
hypothesis
10000
sample
concentration
neighbor
uence
routing
capacity
simulator
intentional
route
varied
rejected
limit
cellular
outcomes
indistinguishable
resemblance
49
sharp
vacant
longestnearestneighboredge
tmst
uenced
totalmst
edgelength
mobilescenario
passed
analytical
les
deviation
resembles
graphic
torus
calculated
boundary
nodes
network
cdf
001
contrary
distribution
random
sim
displayed
200
theoretical
simu
1000
increment
scenarios
circumvent
moving
signicant
ve
100
cumulative
corner
square
coverage
approximated
conservation
rejecting
accuracy
tend
move
nal
central
histogram
convergence
subsection
critical
01
connectivity
visualize
movement
simulation
resemble
lifetime
routes
borschbach
lator
totaldel
totalvoronoidiagramedgelength
nicant
emptycells
impaired
handos
longestmst
1totalmst
p_s
longestnn
lmst
5261048012
4826100
bounced
600822
totaldelaunaytriangulationsedgelength
totalvor
nonintentional
nnl
tained
027
experimental
lesser
anyway
distributions
inaccurate
concentrate
invalid
localized
handbook
tends
cient
sity
evidences
spanners
spanner
bush
vehicular
exacerbates
656
c2
cross
reported
observations
boundaries
le
su
extreme
arranged
modeled
dsr
perceivable
tribution
geography
conrmed
fect
desti
outweighs
curate
concentrated
c1
dis
accounts
practically
specic
moderate
yes yes
node spatial
spatial distribution
no no
border eect
yes no
no yes
random waypoint
the mobility
deployment region
hoc networks
waypoint model
the deployment
brownian like
the uniformity
limit distribution
the border
mobility parameters
voronoi diagram
ad hoc
edge length
the node
the brownian
delaunay triangulation
mobile ad
longest nearest
mobility model
the random
total edge
mobility steps
transmitting range
neighbor edge
the mst
diagram and
intensity of
the limit
the intensity
n 49
n 900
uniformity test
the longest
and delaunay
the uniform
mobility models
statistical tests
eect is
experimental density
like motion
distribution is
n 100
the occupancy
pause time
the center
of mobility
when tpause
mst edge
edge statistic
empty cell
statistics considered
occupancy graphics
wireless ad
center of
nearest neighbor
the voronoi
random in
uniform distribution
we varied
100 and
the test
uniformity of
the statistical
of mobile
the theoretical
the experimental
mobile network
these statistics
uniformity assumption
theoretical density
critical transmitting
stationary networks
mst voronoi
border rule
way point
distribution generated
node distribution
square cells
total mst
intense the
varied each
limit distributions
tpause 0
pstat 0
random way
of vmax
cell statistic
like model
hypothesis h
distributed uniformly
cells is
statistic the
empty cells
we considered
of simulations
distribution of
uniformly and
graphics for
a mobile
nodes are
at random
with dierent
are distributed
point model
the statistic
hoc network
analytical results
the velocity
the simulator
of nodes
of empty
of uniformly
eect the
the sample
route length
range assignment
two mobility
side 1
1000 steps
001 vmax
like mobility
parameter separately
vmin 0
longest edge
mobile scenarios
vmax 0
deployment area
corner cells
central cells
test accuracy
uniformity tests
triangulation edge
experimental distribution
the hypothesis
mobile networks
the region
simulations we
and independently
indistinguishable from
the statistics
length of
in uence
of side
these simulations
density in
standard deviation
calculated on
uniform mobile
statistic is
that contrary
next position
more uniform
n square
a brownian
distributed nodes
simulations was
distribution resulting
statistical hypothesis
the delaunay
mobility patterns
not passed
mobility pattern
uniformly at
0 01
n nodes
steps of
networks of
sample of
initial node
the ve
the pause
uniformly distributed
that nodes
dierent values
to test
distribution in
nodes in
the boundary
are reported
in 0
region into
of cellular
cellular networks
for stationary
normal distribution
average value
these parameters
value and
0 001
and standard
networks is
parameters as
node spatial distribution
the node spatial
no no no
yes yes yes
yes yes no
no yes yes
the border eect
the deployment region
the random waypoint
ad hoc networks
random waypoint model
the limit distribution
of the deployment
of the mobility
the mobility parameters
yes no no
yes no yes
the brownian like
no no yes
mobile ad hoc
of the border
longest nearest neighbor
the longest nearest
voronoi diagram and
total edge length
nearest neighbor edge
border eect is
and delaunay triangulation
diagram and delaunay
the intensity of
spatial distribution is
the total edge
edge length of
intensity of the
limit distribution of
the uniform distribution
center of the
of the mst
the experimental density
the voronoi diagram
the uniformity test
brownian like motion
in the center
the center of
at random in
wireless ad hoc
on the node
the empty cell
brownian like model
in the brownian
of the longest
in the random
nodes are distributed
are distributed uniformly
n 100 and
uniformity of the
case of the
of the node
the statistical tests
the uniformity of
length of the
of empty cells
networks of size
the occupancy graphics
mst voronoi diagram
the critical transmitting
of mobility steps
way point model
random way point
distribution generated by
empty cell statistic
we varied each
distributed uniformly and
of mobile ad
and n 900
spatial distribution generated
graphics for the
100 and n
critical transmitting range
the random way
set of simulations
steps of mobility
value and standard
of the region
uniformly and independently
hoc networks in
the uniformity assumption
density in the
number of empty
spatial distribution of
of uniformly distributed
to the limit
ad hoc network
random in the
and standard deviation
of the statistical
a mobile ad
of side 1
brownian like mobility
model with dierent
occupancy graphics for
waypoint model the
the longest edge
cells of side
size n 49
if the border
mobility parameters as
the experimental distribution
square cells of
a brownian like
border eect the
the theoretical density
49 n 100
like mobility model
mobility steps the
and independently at
0 001 vmax
of the statistic
deployment region into
vmax 0 01
the mobility model
each parameter separately
triangulation edge length
test the uniformity
neighbor edge statistic
001 vmax 0
n 49 n
sample of uniformly
number of mobility
vmin 0 001
separately and we
varied each parameter
the mst voronoi
of these statistics
expected value and
n square cells
limit distribution is
delaunay triangulation edge
mst edge length
the deployment area
into n square
total mst edge
average value and
experimental density in
waypoint model and
two mobility models
the statistical hypothesis
number of nodes
are reported in
the case of
the normal distribution
of a mobile
uniformly at random
the mobility pattern
of cellular networks
a mobile network
distribution of mobile
the delaunay triangulation
the pause time
large sample of
in the deployment
uniformly distributed nodes
after a large
on the intensity
distribution is very
in the uniform
that contrary to
hypothesis h is
dierent values of
the average value
of nodes in
the hypothesis h
that nodes are
by the uniform
for the total
steps of 0
of these simulations
no yes no
independently at random
with the uniform
on x t
to the theoretical
of the voronoi
in steps of
rate of convergence
the results presented
approximated by the
reported in figure
it is seen
of the random
in wireless ad
well approximated by
contrary to the
results presented in
in ad hoc
to the random
is the normal
from the uniform
in the case
of size n

corpus/krapavin2000-test/1027352.txt
broadcast
uplink
periodic
ahb
requests
items
item
bandwidth
server
tc
deadlines
edf
demanded
channel
workload
deadline
periodically
demand
missed
adaptive
scheduled
overload
broadcasting
cycle
bod
workloads
hybrid
asymmetric
batching
batch
bw
request
saturation
clients
downlink
zipf
scheduling
users
dissemination
client
profiles
transmission
zipftian
capacity
frequency
mode
schedule
static
bidirectional
disks
priority
pull
cooling
environments
frequencies
adaptation
program
pages
pinwheel
population
critical
demands
percentage
receive
received
congested
heavily
period
pfair
threshold
sampling
unsatisfied
unlimited
push
fountain
scalability
fraction
coming
dynamically
bd
bad
requested
adapt
access
allocated
issued
ffl
frequently
uniform
integrates
satisfied
200000
knapsack
broadcasts
cutoff
waste
slot
pseudodeadline
proportionate
aida
600000
index
indexing
fairness
unit
channels
saving
crossover
prioritizes
contending
driver
interleaved
included
slots
policy
becoming
arriving
400000
800000
saturated
requirements
sample
timing
mobile
simulation
air
collisions
minimize
consequently
reserved
page
wasting
incorporating
bulk
popularity
priorities
estimated
effectively
trying
predetermined
calculate
off
accessed
overwhelmed
congestion
communication
listen
tolerant
dynamic
decreased
traffic
offered
suffers
logn
met
decreases
contention
layout
interval
functionality
strong
contents
queue
moderate
pure
potential
multiset
status
worse
grows
overhead
protocols
worst
modes
yes
units
occupies
expects
wasted
worth
situations
devoted
dy
precomputed
dummy
unable
equals
allocation
effective
transmitted
energy
routes
sent
fault
portray
1000g
f200
lacuna
suffering
kee
periodic broadcast
broadcast program
the periodic
uplink channel
tc ahb
the server
the uplink
non adaptive
on demand
of requests
demand broadcast
time unit
edf batch
broadcast periodically
deadlines missed
of deadlines
asymmetric communication
requests scheduled
of bandwidth
access frequency
broadcast cycle
the item
adaptive hybrid
demanded items
the bandwidth
adaptive 1
user access
time critical
the broadcast
adaptive 2
the items
bw threshold
items demanded
access distribution
that item
per time
broadcast mode
critical asymmetric
the workload
requests received
communication environments
items are
channel saturation
hybrid broadcast
actual user
deadline constraints
broadcast disks
overload conditions
the on
workload is
broadcast model
broadcast models
frequency distribution
critical adaptive
demanded time
heavily demanded
client profiles
zipf distribution
an item
to broadcast
be broadcast
bandwidth requirements
length cycle
data broadcast
level uniform
the users
20 items
edf batching
bandwidth assigned
the tc
workload items
limited uplink
communication environment
strong overload
broadcast and
cycle length
hybrid model
missed deadlines
available bandwidth
the index
broadcast length
workload increases
given item
in tc
data dissemination
item i
cycle i
cooling factor
unit edf
adaptive models
low workloads
dynamic uniform
unit workload
demanded per
the bw
frequently demanded
workload range
data items
bandwidth for
broadcast the
each broadcast
deadline requirements
requests that
the requests
item is
requests for
uniform distribution
included in
required i
for periodic
periodic and
program is
bandwidth required
the deadline
and consequently
the edf
information server
being broadcast
periodically and
fixed fraction
relative deadlines
hybrid models
static uniform
potential requests
i pages
scheduled figure
static zipf
batching a
scheduled time
deadlines b
bandwidth is
percentage of
to receive
access frequencies
requests are
needs of
sample size
satisfied by
each item
of users
b requests
a missed
first 20
bandwidth allocated
broadcast period
in asymmetric
broadcast frequency
item with
server should
periodically broadcast
be scheduled
broadcasting the
server has
by broadcasting
items that
the needs
two level
item in
adaptive model
in overload
fraction of
server to
distribution the
the access
low capacity
dynamic time
request per
items periodically
broadcasting periodically
deadline distribution
transmission mode
every item
broadcast frequencies
downlink channel
bandwidth effectively
distribution limited
some bandwidth
dynamic zipf
low overload
worth broadcasting
whole workload
ahb is
item during
dynamic client
capacity uplink
single transmission
periodically in
broadcast on
to satisfy
data item
sampling technique
received for
channel is
total bandwidth
is broadcast
broadcast a
the clients
static and
users to
pull based
the periodic broadcast
periodic broadcast program
the uplink channel
in the periodic
number of requests
on demand broadcast
of deadlines missed
number of deadlines
amount of bandwidth
per time unit
broadcast program is
the on demand
non adaptive 1
non adaptive 2
the non adaptive
of the bandwidth
critical asymmetric communication
time critical asymmetric
to the periodic
asymmetric communication environments
of the periodic
user access distribution
the actual user
when the workload
of the uplink
actual user access
critical adaptive hybrid
access frequency distribution
two level uniform
heavily demanded items
time critical adaptive
for that item
demanded time unit
items demanded time
to the server
of the item
of requests that
broadcast cycle length
limited uplink channel
in tc ahb
the tc ahb
adaptive hybrid broadcast
uplink channel saturation
bandwidth assigned to
workload items demanded
included in the
the available bandwidth
of the items
for the on
a given item
by the periodic
the workload is
at the server
of bandwidth assigned
non adaptive models
time unit workload
via the uplink
time unit edf
of requests received
broadcast program the
broadcast program and
broadcast periodically and
demanded per time
the user access
length cycle i
unit edf batching
the bw threshold
level uniform distribution
asymmetric communication environment
the access frequency
and consequently the
satisfied by the
and on demand
the number of
static zipf distribution
unit workload items
deadlines b requests
b requests scheduled
periodic broadcast and
broadcast on demand
scheduled time unit
for periodic broadcast
edf batching a
the edf batch
fixed fraction of
batching a missed
requests scheduled figure
missed deadlines b
first 20 items
uplink channel is
frequently demanded items
the bandwidth is
requests scheduled time
a missed deadlines
hybrid broadcast model
to be broadcast
the needs of
the first 20
bandwidth allocated to
in asymmetric communication
to be scheduled
needs of the
number of users
the server has
a single transmission
fraction of the
user access pattern
periodic and on
cycle the server
a fixed fraction
being broadcast periodically
be broadcast periodically
broadcast program to
to satisfy as
bw threshold the
adaptive hybrid data
request per time
the whole workload
one request per
should be broadcast
server has to
non adaptive model
deadlines missed and
that the periodic
dynamic client profiles
requests for that
total bandwidth required
dynamic time critical
tc ahb is
demanded items are
the broadcast program
adaptive 2 model
strong overload conditions
satisfy as many
the item in
the workload increases
distribution limited uplink
via a single
tolerant broadcast disks
demand broadcast mode
dynamic zipf distribution
broadcast periodically in
the server needs
deadline constraints associated
whole workload range
of requests scheduled
in strong overload
for the periodic
broadcast length cycle
to on demand
items are not
program is computed
items that are
the total bandwidth
the index is
in order to
the amount of
the server to
assigned to each
fault tolerant broadcast
bandwidth for the
number of unsatisfied
item in the
capacity of the
in the worst
number of items
items should be
in overload conditions
as the workload
of the index
the percentage of
to the needs
of the broadcast
constraints associated with
the users to
minimize the number
all the requests
that the server
change with time
needed to broadcast
use the available
the sampling technique
on demand processing
as the periodic
a low capacity
program is static
requests corresponding to
offered workload is
capacity uplink channel
percentage of deadlines
uplink channel in
item during the
from the periodic
perform effectively in
the relative access
potential requests for
item with the
on demand mode
consequently the server
under low workloads

corpus/krapavin2000-test/1028478.txt
signature
signatures
elliptic
cdh
hellman
security
gdh
curves
bilinear
weil
co
prime
dsa
curve
supersingular
maptogroup
pairing
multiplier
hash
public
hp
eld
subgroup
mov
di
tate
verication
forger
1g
ddh
forgery
oracle
discrete
groups
f0
computable
message
isomorphism
automorphism
aggregate
abort
1024
keygen
gap
degenerate
secure
attack
batch
breaks
queries
log
pairings
private
tuple
genus
rsa
hm
short
secret
bits
challenger
map
koblitz
galbraith
ateniese
balasubramanian
nite
alexandria
logarithms
320
query
adv
bit
issued
je
coppersmith
responds
messages
dlog
signing
party
brie
dened
cryptographic
dene
ciently
abelian
shares
attacks
maps
varieties
cryptosystems
pfdh
cdha
pederson
hqi
baretto
sieve
descent
existentially
characteristic
verifying
trace
insecure
denition
existential
pk
exponentiation
linearly
defeating
undeniable
silverberg
unforgeable
publishes
authority
multipliers
su
giuseppe
multiplication
group
va
sig
generator
cryptography
chaum
aggregated
digital
jacobian
ij
coin
okamoto
families
intractable
generic
logarithm
specically
160
invalid
keys
intractability
resembles
onto
168
succeeds
rst
tosses
subgroups
pick
12th
culty
threshold
accept
probability
2048
discriminant
homomorphism
modulus
dierent
game
sign
veri
pr
divide
divides
failure
verify
approximately
instantiations
wins
valid
users
cient
divisor
elds
3a
veried
random
ci
believed
trusted
reducible
share
206
pm
people
communications
parties
jg
hyperelliptic
miyaji
kuhlman
ecdsa
unforgeability
diffiehellman
moni
renfro
certicates
postcard
patarin
ghs
f q
signature scheme
discrete log
di e
e hellman
e f
the signature
elliptic curve
order p
elliptic curves
g 1
short signatures
co cdh
co di
co gdh
log problem
security multiplier
hp i
a signature
an elliptic
gdh groups
our signature
bilinear map
prime order
g 2
cdh on
algorithm b
signature queries
the weil
public key
nite eld
gap di
weil pairing
h list
tr q
group pair
f0 1g
h 0
a bilinear
random oracle
log in
curve e
maptogroup h
cdh problem
hellman groups
of prime
these curves
q be
m i
signature is
the security
of order
private key
chosen message
n signatures
f 3
message m
hellman problem
hash function
security of
signature length
signature query
supersingular curves
z p
in e
subgroup of
2 f0
not abort
2 e
the curve
1024 bit
non supersingular
curves with
a subgroup
signatures are
in f
q s
a discrete
e p
the public
in hp
signature on
2 g
short signature
bilinear maps
t breaks
the mov
decision co
tate pairing
trace map
gdh group
the tate
message signature
largest prime
computational co
message attack
computable isomorphism
multiplier of
the discrete
non degenerate
in g
with security
the co
a point
h m
m f
signatures with
the h
f 0
eld of
s ij
log algorithm
ciently computable
problem on
on distinct
linearly independent
a curve
distinct messages
is linearly
b does
let e
signature pair
mov reduction
certain elliptic
supersingular elliptic
bit prime
domain hash
dsa signatures
je f
aggregate signatures
hellman group
weil descent
aggregate signature
batch verication
hellman tuple
generic discrete
supersingular curve
hellman on
6 o
signature schemes
map e
of security
s signature
signatures the
on e
q 6
a public
an isomorphism
q with
a s
a co
oracle model
not divide
isomorphism from
tuple hm
full domain
h queries
curves over
pairing is
abort as
the group
q h
key is
over f
secret key
automorphism of
signatures from
a 1024
the trace
time unit
curves the
computational di
a prime
share of
scheme is
the probability
the private
of curves
attack in
approximately 2
from g
a random
exponentiation in
complex multiplication
pick random
320 bits
output invalid
subgroup hp
signatures we
bilinear group
key v
signature verication
against existential
pairing on
dsa using
message recovery
constructing short
co ddh
gdh signatures
abelian varieties
e f q
di e hellman
the signature scheme
co di e
discrete log problem
an elliptic curve
of order p
in e f
our signature scheme
a discrete log
co cdh on
2 e f
log problem in
discrete log in
prime order p
f q be
gap di e
the discrete log
in g 1
of prime order
the h list
a bilinear map
a point of
let e f
the weil pairing
e hellman problem
co gdh groups
maptogroup h 0
does not abort
e hellman groups
curve e f
e f 3
of the signature
2 f0 1g
m 2 f0
the public key
g 1 and
2 g 1
be an elliptic
is linearly independent
the co cdh
co cdh problem
of f q
signature scheme is
on the h
be a point
linearly independent of
point of prime
in hp i
in f q
the random oracle
message m 2
a signature scheme
of e f
elliptic curves with
chosen message attack
signature length is
h m i
computational co di
from g 2
s signature queries
the largest prime
2 to g
tr q 6
decision co di
the trace map
a nite eld
on distinct messages
the tate pairing
q 6 o
security multiplier of
f q with
point of order
q be a
a subgroup of
of a s
e ciently computable
to a discrete
points in e
bilinear map e
independent of p
an e ciently
discrete log algorithm
2 f q
g 2 to
to g 1
b does not
security of the
f q is
f q and
q be an
not abort as
generic discrete log
2 z p
dened by y
computational di e
f 3 6
supersingular elliptic curves
full domain hash
a signature query
message signature pair
f q r
under a chosen
of co cdh
nite eld of
1 q s
problem in f
abort as a
short signatures the
the security multiplier
e hellman on
e hellman tuple
the mov reduction
that is linearly
elliptic curve and
with security multiplier
the signature length
e hellman group
a chosen message
a message m
random oracle model
does not divide
the private key
an isomorphism from
one time unit
theorem 3 2
in one time
a 1024 bit
on g 1
f q has
c g 1
q of order
and g 2
g 1 is
is an isomorphism
of the private
the probability that
in the random
on computer and
independent of a
be a subgroup
the hash function
reduction maps the
f q such
1 or 5
generator of g
signature on m
level of security
breaks computational co
with p points
dsa using a
are a t
the decision co
the real attack
order p with
je f q
supersingular curves over
gdh group pair
for short signatures
time in and
h 0 hash
v 2 g
on e f
curve and let
order p that
a curve e
used for short
of non supersingular
non supersingular curves
against existential forgery
log in a
on e p
ciently computable isomorphism
a s view
a generic discrete
on these curves
to dsa using
the exact security
hellman problem on
public key v
the n signatures
p in e
q f0 1g
signatures on distinct
key is x
subgroup of e
t breaks computational
bilinear group pair
subgroup hp i
adaptive chosen message
of the weil
key is v
mov reduction maps
the tuple hm
reports failure and
non supersingular elliptic
failure and terminates
a short signature
eld of characteristic
log in g

corpus/krapavin2000-test/1029119.txt
route
reply
adversary
routing
ariadne
endaira
corrupted
conf
msg
initiator
identifiers
identifier
request
compromised
mac
protocol
security
secure
ideal
macs
hoc
attack
protocols
routes
discovery
plausibility
signature
ad
plausible
tape
tapes
attacks
ini
tar
verifies
honest
cryptographic
sys
sndr
rcvr
verifications
world
signatures
adversarial
forged
messages
srp
message
neighbor
sig
configuration
intermediate
hop
flag
authentication
hash
puk
pf
req
neighbors
receives
machines
res
target
indistinguishability
dropped
node
ext
demand
keys
vertices
wireless
signing
ban
replay
signed
neighboring
id
radio
statistically
accumulated
hypothetic
overhear
activated
nodes
negligible
aodv
discoveries
public
reactive
requests
informal
initialized
vulnerabilities
send
digital
wormhole
digitally
received
capabilities
faithfully
vertex
ha
flaws
pub
broadcasts
preceding
sign
accepts
eavesdrop
prk
tesla
nessett
sybil
novelties
rejoinder
undef
olsr
hmac
initiate
discovered
flags
simulation
participants
content
published
adversaries
against
provably
broadcast
hungarian
rushing
oracle
transmission
rigorous
timer
round
dsr
appends
assurances
imperfections
strand
securing
initiates
active
exchange
provable
scheduler
verify
false
initialization
existent
defend
indistinguishable
parties
devices
forge
sleep
discover
heard
lossy
statistical
reads
networks
authenticate
flooding
intended
reaches
private
band
material
verification
partitions
marked
activation
intend
tolerable
participant
caught
rounds
mobile
accept
successfully
shares
returned
anymore
belong
authenticated
vulnerable
repeating
unavoidable
nb
subtle
accepted
apart
placed
removes
entity
transmissions
receive
route reply
the route
conf a
route request
corrupted nodes
routing protocol
world model
the initiator
ideal world
non corrupted
route discovery
a route
the adversary
world adversary
the reply
hoc routing
routing protocols
ideal conf
ad hoc
node list
corrupted node
real conf
sys ideal
non plausible
intermediate nodes
m i
the routing
compromised identifiers
plausible route
in sys
plausibility flag
adversarial node
the signature
source routing
demand source
hop hash
real world
the mac
the request
the protocol
a j
hoc networks
intermediate node
the target
per hop
the ideal
negligible probability
the compromised
endaira protocol
non compromised
secure routing
configuration conf
the identifiers
the attack
adversary can
reply and
identifiers in
signature of
the intermediate
security of
sys real
the machines
in msg
neighbor discovery
out real
active 1
verifies if
on demand
adversary a
it verifies
each intermediate
req i
these verifications
msg is
of security
operation of
the identifier
request identifier
its plausibility
basic endaira
of endaira
ext j
compromised identifier
of ariadne
reply in
plausible routes
for ad
a mac
initiator and
of identifiers
digital signatures
request and
of ad
the honest
reply messages
the node
receives the
a configuration
sig j
reply that
sndr rcvr
routing security
the security
identifier of
discovery process
machine m
of routing
random input
hash value
the operation
against ariadne
ariadne with
first adversarial
mac list
mac of
discovery part
rcvr msg
following message
the macs
accumulated route
statistically secure
identifier z
the per
j q
messages that
attacks against
identifiers of
output tape
with negligible
of sys
is dropped
the real
protocol and
reply it
dropped due
the tapes
discovery protocol
node that
protocol is
protocol for
adversary has
initiator of
reply is
the neighbor
protocols in
reply contains
flag set
protocol faithfully
2 attack
verifies correctly
forged the
its identifier
pf to
identifiers by
that corrupted
on ariadne
identifier or
honest nodes
has compromised
second adversarial
ini tar
simulation paradigm
corrupted neighbor
secure on
following identifier
to false
adversary is
authentication and
key exchange
vertices in
our model
in v
an active
attack against
sign the
route in
its neighbors
statistical security
the corrupted
if msg
input tape
each machine
msg are
communication capabilities
reply message
route is
signature scheme
wireless ad
signatures in
a neighbor
content of
security analysis
our definition
never been
identifier is
request when
exchange protocols
secure we
successful then
the network
ad hoc routing
hoc routing protocols
ideal conf a
the ideal world
the route request
the node list
sys ideal conf
ideal world model
the routing protocol
the route reply
a route reply
real conf a
the route discovery
real world model
in the route
the intermediate nodes
non corrupted node
ideal world adversary
of the route
on demand source
per hop hash
demand source routing
ad hoc networks
each intermediate node
real world adversary
in sys ideal
a non corrupted
the real world
sys real conf
the per hop
a non plausible
non corrupted nodes
a route request
non plausible route
that the adversary
routing protocol for
the signature of
the non corrupted
route reply messages
in the reply
out real conf
the operation of
route discovery process
for ad hoc
of the target
in the node
basic endaira protocol
world model which
j q 1
route reply that
the basic endaira
its plausibility flag
machine m i
on the route
the neighbor discovery
with negligible probability
the compromised identifiers
identifier of the
definition of security
of the initiator
the initiator and
of ad hoc
the adversary can
initiator and the
a route discovery
the identifiers of
protocol for ad
source routing protocols
in the request
routing protocols in
the first adversarial
the following message
by the initiator
to its plausibility
generates a route
secure routing protocol
active 1 2
route discovery part
hop hash value
following message to
world adversary a
the accumulated route
only with negligible
an active 1
discovery part of
identifiers of the
route reply and
the mac of
non compromised identifier
conf a is
sndr rcvr msg
of routing security
is a route
corrupted nodes are
first adversarial node
conf a r
route reply message
is dropped due
source routing protocol
m i and
the identifier of
an ideal world
initiator of the
all a j
dropped due to
in the real
the adversary has
vertices in v
the initiator of
of the honest
identifiers in the
the signature scheme
in our model
set to false
contains a non
in the ideal
if msg is
secure on demand
verifies if the
send the following
of on demand
contains the identifiers
receives a route
conf a and
attack on ariadne
second adversarial node
that corrupted nodes
flag set to
route reply contains
node list and
for any configuration
corrupted nodes in
attack against ariadne
a plausible route
compromised identifiers in
simulation based approach
any configuration conf
neighbor discovery protocol
1 2 attack
intermediate node that
by the reply
operation of m
each a j
it verifies if
the second adversarial
plausibility flag set
the request and
the security of
of the protocol
wireless ad hoc
and the target
of the routing
of sys ideal
any real world
msg is a
the content of
our definition of
key exchange protocols
by the routing
to the route
by the intermediate
a real world
operation of the
a routing protocol
which means that
1 2 n
m i is
the vertices in
precise definition of
a precise definition
a hypothetic scheduler
tape in i
routing protocol and
reply message in
must have forged
request c i
mac of the
protocol under investigation
on ext j
c i tar
some random input
a single corrupted
the reply in
routing security is
conf a conf
the machines in
a plausibility flag
corrupted node that
adversary has compromised
the macs computed
macs computed by
it shares with
a secure on
a conf a
initiates a route
node list in
adversary must have
a j may
route carried by
a new on

corpus/krapavin2000-test/1029199.txt
mix
ases
mixmaster
tor
anonymity
exit
alice
routing
attacks
route
bgp
internet
independence
paths
onion
routes
adversary
isp
sender
traffic
entry
provider
topologies
traverse
router
replacement
destination
3356
senders
customer
tier
isps
network
hop
hops
dsl
topology
ip
prefix
she
receiver
mixes
peer
path
remailer
peers
networks
traceroute
providers
diversity
links
latency
location
receivers
bob
node
her
5662
tarzan
2914
morphmix
23504
prefixes
initiator
cable
modem
located
advertise
hosts
nodes
packets
peering
routers
tables
traceroutes
routeviews
speakeasy
verio
aol
abovenet
mixminion
readvertise
22489
learned
bilateral
newborn
akamai
sprint
likelihood
passive
inc
recipient
endpoint
responder
reverse
autonomous
inferring
deployed
vulnerability
net
passively
disclosure
administrative
against
seeing
customers
relationships
12076
uunet
jurisdictions
15130
7132
4355
11643
7224
4323
comscore
1764
15169
3269
indymedia
6461
llc
comcast
trickle
pinger
17110
10593
12182
26101
anonymizer
babel
metrix
7784
mao
owns
selection
threat
gateway
intra
enforcement
pays
observes
vulnerable
discover
freedom
0010
ebgp
inbound
ibgp
eavesdropping
engender
curious
attack
operated
locations
tination
1668
dispersal
collude
961
prevalence
untraceable
suspicion
outbound
cnn
security
server
who
advertises
relaying
countries
feeds
communications
oregon
selects
directory
placement
servers
websites
web
observe
host
learns
flood
upstream
notoriously
mature
forward
fraction
link
hosting
herself
recipients
reasonably
border
messages
likely
disjoint
export
as level
the as
mix network
location independence
and exit
single as
the mix
level path
entry and
mix networks
mix nodes
routing table
exit node
level paths
of mix
anonymity networks
the tor
mixmaster nodes
network path
node selection
mix node
mixmaster and
as path
and mixmaster
and tor
tor nodes
an as
the mixmaster
observe all
node pairs
onion routing
the internet
a mix
level topology
exit paths
tor and
replacement mixmaster
exit nodes
both entry
tier 1
can observe
ip address
with replacement
the path
route to
the entry
ases that
the ases
bgp routing
nodes without
of ases
tor network
as 3356
without replacement
routing tables
adversary who
senders and
existing mix
observe both
an adversary
independence of
one as
nodes in
traffic analysis
1 isp
each as
traverse the
sender to
path between
the route
low latency
and receivers
links in
networks should
anonymity network
cable modem
customer provider
reverse paths
will traverse
path from
independence in
a router
located in
latency networks
entry node
s routing
as disjoint
hop path
routes learned
all links
paths that
the destination
traffic to
learned from
paths between
nodes with
as on
as can
the exit
likelihood that
are located
replacement tor
mix hops
node replacement
four hop
network paths
two ases
ases for
hops tor
mix paths
replacement figure
endpoint attacks
in anonymity
route server
ases where
edge networks
intra network
as seeing
high latency
alice to
the likelihood
attacks on
of location
nodes from
net work
the routing
she selects
seeing all
other ases
mix net
internet s
a bgp
1 isps
paths through
selection algorithms
a route
the initiator
internet routing
likely to
same as
of paths
two arbitrary
on both
the sender
this route
paths where
node placement
best route
the network
networks we
node to
next hop
18 0
independence for
and reverse
as will
but one
the ip
observed by
the location
to observe
the us
of senders
via one
paths in
of mixmaster
route traffic
her chosen
of tor
web mixes
latency systems
mix path
alice must
tor s
dsl and
path estimation
location diversity
chosen exit
prefix 18
ases and
independence metric
provider customer
peer 1
and morphmix
underlying as
peer 2
the remailer
in ases
path properties
of onion
ases by
internet topology
entry exit
in mixmaster
path 0
directory servers
a destination
are likely
towards an
network and
the as level
entry and exit
a single as
as level path
the mix network
mix network path
as level paths
mixmaster and tor
level path between
as can observe
single as can
traverse the same
a mix network
both entry and
nodes without replacement
and exit paths
replacement mixmaster nodes
nodes with replacement
as level topology
tor and mixmaster
to the entry
links in the
location independence in
location independence of
and exit nodes
determine the as
through the mix
of the as
in the mix
senders and receivers
an adversary who
path from the
the path from
the entry and
tier 1 isp
the as path
able to observe
the location independence
mix node pairs
can observe all
mix networks should
the tor network
same as on
the mixmaster and
tor nodes without
the tor and
that a single
the same as
number of mix
the exit node
bgp routing table
routes learned from
the entry node
the likelihood that
independence of the
the routing table
between two arbitrary
all but one
replacement tor nodes
that the as
location independence for
0 0 8
a four hop
probability of one
mixmaster nodes without
18 0 0
of location independence
one as seeing
mix hops tor
fraction of paths
on both entry
exit node to
of existing mix
observe all but
as on both
paths where a
entry node and
single as will
without replacement mixmaster
four hop path
mix network paths
of senders and
of paths where
as seeing all
existing mix networks
with replacement mixmaster
mix net work
observe both the
node selection algorithms
s routing table
tor nodes with
mixmaster nodes with
of a mix
of mix hops
without replacement figure
hops tor nodes
from the exit
with replacement tor
of mix nodes
from the sender
paths through the
and the path
the internet s
be observed by
observed by a
tier 1 isps
of one as
low latency networks
of the internet
the sender to
are located in
in the path
to a destination
best route to
sender to the
where a single
route to the
all links in
nodes in the
on the internet
in the internet
are likely to
0 12 0
the probability that
nodes to avoid
sequence of ases
mix networks we
and exit node
exit paths that
node selection in
of onion routing
on low latency
hosts on the
level paths between
a customer provider
can observe both
to the as
the underlying as
to observe all
the mix net
both the tor
that traverse the
of its peers
level path from
routing table is
prefix 18 0
from the destination
analysis of onion
but one link
reverse paths through
as level internet
chosen exit node
anonymity networks we
achieve location independence
the mix nodes
mix networks to
selecting nodes from
random entry and
two arbitrary hosts
entry exit node
attacks on low
the ases where
underlying as level
arbitrary hosts on
mix network we
as level graph
observe all links
discover the as
her chosen exit
in the us
network path 0
path between two
of the links
probability that a
sender and receiver
in the as
in node placement
a bgp routing
forward and reverse
paths that traverse
an as path
at the as
to achieve location
the route to
adversary who can
a tier 1
as path in
learned from one
border gateway protocol
the as in
node to the
routing table entry
the entry point
path between the
of the mix
likely to be
route to a
we must first
0 0 0
that are located

corpus/krapavin2000-test/1029351.txt
eal
lamping
elementary
mairson
am98
typed
asperti
bookkeeping
fan
duplication
statman
fans
dk
levy
boxes
memberk
lambda
beta
logic
encoding
lc
ell
mai92
reduction
sharing
quantiers
reductions
contraction
redexes
decoration
powerset
calculus
io
ag98
croissants
gir98
asp98
box
redex
ill
la
intuitionistic
ne
translation
derivation
xed
oracle
nesting
le
normalization
abstract
gnal92a
lm97
annihilate
universes
lal
decorating
decorations
rst
typing
formulas
rening
sta79
reducer
shared
normalize
turing
light
jxj
dene
unfeasible
contractions
bracket
typeable
prime
inference
depth
bold
skeleton
cut
quanties
kmax
mula
connectives
formula
encoded
girard
rewriting
families
brackets
optimality
paradox
affine
quantied
nets
quantier
dynamics
subterm
elimination
abstraction
rules
wire
coded
en
untyped
proofs
inside
weakening
double
fragment
coding
wrong
labelling
machinery
bool
greatest
dened
oj
vindicates
kat90
lev78
0244
reducers
intuitionist
croissant
contr
2kmax
lam90
piling
perfomed
culprit
devolved
member3
asp95
gonthier
asp96
member2
al97
maxf4k
gnal92b
8nk
cofin
curry
contractible
mality
implicational
breakthrough
4061
lm96
boxing
mey74
lx3
ly3
syntax
dierent
false
grammar
discipline
rithm
sketched
nally
creasing
rewritings
kalmar
kathail
8z
eta
discriminated
duplications
gir87
eraser
ference
propositional
rule
grows
principal
variants
crucial
technical
functional
hinted
lawall
9z
inductively
normal
understand
labelled
reach
admitted
culminated
erb
lacked
pretty
contracted
nique
lvy
jacques
prescribes
algo
labels
in eal
i i
lamping s
l l
abstract algorithm
eal type
sharing graph
d d
optimal reduction
linear logic
simply typed
shared reductions
and mairson
typed term
of lamping
eal is
asperti and
term encoding
term m
l c
a term
in am98
mairson s
fan fan
of statman
elementary a
beta reduction
ne logic
levy s
typed terms
the abstract
the bookkeeping
c l
b a
the type
eal typed
optimal sharing
not elementary
that memberk
restricted system
la a
graph reduction
fan rules
c lc
any elementary
le c
encoding an
two fan
lc c
l la
a ne
type inference
s abstract
elementary function
n le
elementary time
the simply
has type
of shared
normal form
of duplication
non elementary
the term
type in
a lc
i io
elementary recursive
of powerset
two fans
of am98
false c
prime formulas
inside eal
optimal lambda
bookkeeping part
of eal
c false
greatest k
for eal
parallel beta
nesting depth
memberk appears
an eal
duplication is
affine logic
lc true
the translation
translation of
higher order
z z
elementary functions
consecutive s
is elementary
arbitrary formula
s graph
true c
sharing graphs
inference in
the sharing
x x
a box
the oracle
of type
proof nets
lambda term
a type
encoded by
the box
the reduction
for optimal
lambda calculus
of optimal
c x
be typed
a variable
the abstraction
the encoding
8 d
graph rewriting
syntax tree
the rst
z y
turing machine
s algorithm
term as
order logic
terms for
the terms
reduction is
of sharing
a b
a a
or m
dynamics of
encoding of
e l
of terms
terms in
am98 is
eal i
untyped terms
normalize en
ill proof
oracle of
in gir98
shared beta
of asperti
bookkeeping work
for contractions
elimination procedure
in asp98
box nesting
reductions it
global dynamics
using lamping
cannot any
eal a
over universes
reductions is
fans have
corresponding ill
redex families
of redex
free terms
the redexes
normalize in
bookkeeping technique
mula then
optimal reducer
light affine
any simply
no eal
ag98 for
optimal duplication
and croissants
eal we
arbitrary for
type free
to duplication
optimal implementation
eal as
reduction optimality
box stands
any typed
normalization procedure
preliminary redexes
1 boxes
rules annihilate
typeable in
beta steps
dierent encoding
of ell
quantier elimination
new preliminary
en using
the fans
eal proofs
where kmax
only quanties
statman the
i i i
d d d
l l c
l l l
the abstract algorithm
a b a
c l l
of lamping s
asperti and mairson
b a b
lamping s algorithm
elementary a ne
a ne logic
number of shared
encoding an arbitrary
c e l
of shared reductions
is not elementary
lc c x
fan fan rules
the two fan
l la a
l c n
simply typed term
c lc c
s abstract algorithm
term encoding an
reach the normal
c n le
n le c
type in eal
two fan fan
x c e
lamping s abstract
optimal sharing graph
le c l
eal typed terms
l l la
in eal is
inference in eal
of the term
the normal form
the simply typed
type inference in
z y y
z z y
e l l
a type in
c x c
higher order logic
a term m
l c l
x x i
n the type
parallel beta reduction
not elementary recursive
lamping s graph
memberk appears in
an eal type
theorem of statman
a term encoding
greatest k such
and mairson s
figure 8 d
eal type of
any elementary function
syntax tree of
that memberk appears
such that memberk
the sharing graph
true c false
the greatest k
for eal typed
la a lc
a lc true
lc true c
we may give
the two fans
c false c
y y x
y x x
a a a
the translation of
x i i
in the type
the size of
of sharing graphs
is the greatest
an arbitrary formula
l c c
i i o
the syntax tree
to reach the
x x x
a d d
the number of
depth of the
in the translation
the type of
of a variable
the abstraction of
functional programming languages
the rules and
in the size
normal form of
where kmax is
interactions that are
for mula then
from the syntax
am98 is obtained
all the redexes
beta reduction is
xed integer 0
derivation of m
that optimal reduction
elementary linear logic
in and n
box nesting depth
grows as any
notation for proofs
optimal implementation of
for optimal reduction
the type free
s graph reduction
need to open
the bookkeeping work
terms for which
box stands for
brackets and croissants
the shared rule
required to normalize
of asperti and
the type n
two fans have
elementary function in
representing a variable
fan rules annihilate
as any xed
to normalize en
a sharing graph
optimal reduction of
fans have the
higher order formula
shared beta steps
size of m
arbitrary for mula
duplication is not
algorithm grows as
abstract algorithm by
the restricted system
on global dynamics
ag98 for a
type free terms
typeable in eal
for optimal lambda
abstract algorithm is
oracle of lamping
bold box stands
of beta reduction
implementation of functional
dynamics of optimal
once the depth
the optimal implementation
quantier elimination procedure
the oracle of
of statman the
the box nesting
dynamics of sharing
any typed term
maintain the families
eal is not
in eal we
normalize en using
of elementary linear
the term encoding
simple labelling of
number of quantiers
light affine logic
an arbitrary for
new preliminary redexes
type of powerset
type i io
this restricted system
of shared beta
global dynamics of
of quantiers in
n shared reductions
the normalization procedure
in eal i
complexity of beta
lambda calculus reduction
optimal reduction as
of eal that
levy s theory
optimal lambda calculus
of redex families
list iteration as
optimal graph reduction
the simple type
appears in and

corpus/krapavin2000-test/1029352.txt
dnf
monotone
learning
fourier
learnmonotone
circuits
i2a
learns
mansour
linial
boolean
proc
coefficients
jaj
ann
findvariables
learnmonotone2
log
f0
1g
poly
polynomial
learnable
oe
depth
ffi
pac
comp
fdae
32kn
ac
valiant
ffl
gave
spectrum
chernoff
membership
supscrpt
parseval
corollary
uniform
bshouty
verbeurgt
fanin
tamon
symp
distributions
formulae
sharpened
product
lemma
coefficient
learner
gates
analogue
orthonormality
ff
norm
a6
furst
findvariables2
20d
orthonormalization
pr
italic
negations
learn
js
formulas
subsets
conf
hx
sat
sup
valued
hancock
tour
orthonormal
literals
circuit
transform
hf
fi
ex
analogues
schmidt
query
ae
learnability
drawn
subclasses
blum
sci
basis
hypothesis
probability
labeled
sampling
gram
kn
conjunctions
sakai
16fid
factorable
kucera
fik
khardon
5fipd
4fipd
kahn
okol
bitstrings
4oe
dichotomous
nishnikova
enouragement
maruoka
spanned
suffices
unbounded
guided
queries
workshop
identity
outputs
distribution
sign
hoe
rudich
jff
barred
lambdag
bahadur
fix
estimating
succeed
fifteen
32k
armed
astad
read
jackson
capital
ajtai
celebrated
40th
primer
sharpen
gurevich
nontrivial
disjoint
8n
jrj
kearns
pitt
approximates
flipped
influential
sharper
29th
hypotheses
identifying
boosting
ku
sigma1
restricted
estimates
approximating
lowercase
polylogarithmic
bellare
implicit
switching
identifies
bounded
estimated
les
gamman
strengthened
inequalities
26th
distribu
19th
minor
arguments
subsequently
random
letters
differs
bounding
negated
recalling
9th
1984
seminal
estimate
uniquely
seventh
advice
ingredient
dnf under
product distribution
term dnf
oe basis
fourier coefficients
the uniform
uniform distribution
learning monotone
product distributions
monotone dnf
1g n
the oe
monotone functions
dnf with
a dnf
a i2a
constant bounded
s f
log n
the fourier
ac 0
linial et
polynomial time
o log
boolean function
for learning
any constant
circuits which
bounded product
n term
1 ffi
low fourier
size dnf
compute monotone
polynomial size
f0 1g
depth circuits
distribution d
constant depth
learning theory
dnf in
comp learning
ffi time
on comp
algorithm learnmonotone
2 o
on f0
poly n
depth d
functions on
log 1
membership query
coefficients which
k term
d size
gave a
in poly
learning algorithm
monotone o
learnmonotone learns
dnf formulae
the dnf
learning under
dnf is
k dnf
mansour s
which compute
spectrum of
time algorithm
corollary 11
query algorithm
ffl ffi
ex f
random examples
ffi 0
of depth
over f0
power spectrum
under the
a polynomial
fourier transform
algorithm learnmonotone2
time membership
ann workshop
fourier spectrum
basis fourier
important variables
0 algorithm
monotone boolean
dnf learning
fourier coefficient
0 circuits
term monotone
boolean functions
ae p
with probability
under any
c be
chernoff bounds
under product
term size
monotone 2
learning dnf
learns class
subsets of
a product
real valued
ff a
our learning
all ffl
size bound
constant ffl
any ffl
to subsets
from 10
which correspond
valued functions
labeled examples
symp on
let c
on learning
probability at
a monotone
d 1
circuits on
small subsets
u f
s lemma
m circuits
jaj c
bshouty and
mansour 23
dnf for
unbounded fanin
ann symp
and tamon
of mansour
js f
fanin and
log 32kn
4 learning
a6 r
of dnf
r out
d norm
learnmonotone2 learns
i2a a
dnf formulas
monotone k
algorithm which
class c
distribution in
from random
learning model
al 22
a boolean
ff 0
of monotone
f 1
let f
1 d
log log
that almost
the learner
few variables
are pac
fact 9
or gates
arbitrary polynomial
fix d
under constant
read k
read once
learning boolean
1 circuits
set ff
least outputs
size m
f be
of boolean
lemma 10
n log
algorithm for
the learning
every a
time polynomial
f 2
pac learnable
membership queries
of chernoff
distributions a
0 functions
parseval s
on few
conf on
small constant
p d
f by
et al
oe a
under the uniform
the uniform distribution
dnf under the
the oe basis
2 o log
f0 1g n
log 1 ffi
algorithm for learning
linial et al
gave a polynomial
constant bounded product
o log n
log n term
product distribution d
compute monotone functions
circuits which compute
a product distribution
which compute monotone
n term dnf
polynomial size dnf
of depth d
low fourier coefficients
set s f
comp learning theory
ffl ffi 0
membership query algorithm
depth d size
term dnf under
class of depth
monotone functions on
coefficients which correspond
on comp learning
in poly n
1 ffi time
polynomial time algorithm
a polynomial time
on f0 1g
n 1 d
mansour s lemma
monotone o log
query algorithm for
any constant bounded
bounded product distribution
fourier coefficients which
ae p d
algorithm learnmonotone learns
a boolean function
for any constant
log n 1
1 d 1
constant depth circuits
time algorithm for
power spectrum of
over f0 1g
be the class
uniform distribution in
let c be
functions on f0
workshop on comp
n log 1
from random examples
spectrum of f
valued functions on
poly n log
correspond to small
k term dnf
term monotone dnf
fourier spectrum of
any constant ffl
learns class c
for learning monotone
ac 0 circuits
small constant depth
any ffl ffi
monotone dnf in
time membership query
under product distributions
ann workshop on
ffi 0 algorithm
a dnf with
size dnf under
real valued functions
which correspond to
to small subsets
for any ffl
ff 0 a
using the fourier
probability at least
the fourier transform
with probability at
almost all of
for all ffl
the power spectrum
to subsets of
f is in
class c in
small subsets of
log log n
and let c
et al 22
that almost all
i2a a i2a
the d norm
on r out
size 2 o
on learning monotone
d size 2
arbitrary polynomial size
the fourier spectrum
ex f u
d size m
a 6 s
on 2 o
under any constant
read k dnf
and or gates
learning monotone 2
monotone k term
the dnf learning
function on f0
ann symp on
m circuits which
r out of
monotone boolean function
is a dnf
bounded product distributions
f of important
6 s f
unbounded fanin and
bshouty and tamon
be a monotone
a monotone boolean
of important variables
any product distribution
the fourier coefficients
obtained from f
of chernoff bounds
dnf under constant
e u f
monotone 2 o
oe basis fourier
dnf is a
fix d 1
a i2a a
under constant bounded
dnf learning problem
term size bound
algorithm learnmonotone2 learns
of mansour s
polynomial time membership
ac 0 functions
parseval s identity
space of real
size m circuits
algorithm which learns
on few variables
i d i
f be a
c be the
in time polynomial
s f of
at least outputs
are pac learnable
d 1 variables
least outputs a
d 1 circuits
distribution over f0
our learning algorithm
uniform distribution for
and log 1
a set s
of the power
for every a
with high probability
time polynomial in
the class of
polynomial in n
time algorithm which
functions on r
1g n we
u f i
at most d
time under the
vector space of
subsets of s
from f by
in polynomial time
and with probability
form an orthonormal
of s f
a a x
is a boolean
i u i
of real valued
f 2 c
of f is
that with high
the vector space
an orthonormal basis
refer to this

corpus/krapavin2000-test/1029901.txt
invariants
invariant
daikon
flex
incremental
optimizations
utilities
falsified
suppression
trace
samples
antecedent
suppressed
hierarchy
detector
program
sample
pass
detection
instantiated
bottom
exit
checked
leader
runtime
processed
suppressions
java
antecedents
missing
grammar
instantiate
falsifying
instantiating
specifications
upgrades
refactoring
leaders
public
falsification
interning
mbytes
discovering
passes
arg
suites
gigabytes
traces
equivalence
usage
top
batch
child
anomaly
down
parent
opportunities
unary
equality
bug
fields
instrumented
postprocessing
constants
operational
redundant
ternary
merging
suppressee
diduce
down2006001000
lasti
nadya
ruben
gamboa
kuzmina
multi
instantiates
file
target
odd
dynamically
pag
csail
stands
client
tool
executions
checking
aims
optimization
stateless
ples
dereference
implementations
isolation
portland
leaf
redundancy
null
incompatibilities
copying
reflexive
online
checks
object
permits
abstraction
relate
enter
enabled
likely
watch
maine
steering
automatic
learning
adaptability
modest
field
created
runs
invalidated
mentation
instrumentation
imple
contracts
verifying
evaluates
children
spin
candidate
summand
old
million
undo
experimentally
memory
diagram
positives
discards
publicly
discovers
polymorphic
lexical
preconditions
relied
152
exits
750
predicting
storing
latent
sam
library
post
extracting
inductive
bugs
entry
fewer
aggregate
inference
remote
algebraic
dynamic
quickly
analyzer
precondition
fee
localization
eliminating
printed
storage
01000020000
toh
weakenings
down50001500025000
010000200000k
exempted
3672
newsets
2006001000
accomplishment
mylist
populating
sofien
250k
khemakhem
ntt
jmaiel
unsuppressed
timizations
nimmer
dupli
myvar
pressiveness
arnout
mccamant
henkel
program points
program point
multi pass
incremental algorithm
invariant detection
simple incremental
incremental algorithms
the invariant
top down
bottom up
the optimizations
an invariant
invariant detector
invariant is
of invariants
pass algorithm
the daikon
up algorithm
pass bottom
invariants are
the multi
invariants at
variable hierarchy
target program
dynamic invariant
down algorithm
up top
the incremental
daikon utilities
invariants over
equal variables
each sample
the hierarchy
invariants that
derived variables
constant variables
down incremental
equivalence set
program size
each invariant
likely invariants
space usage
the trace
the bottom
invariant that
the invariants
equivalence sets
invariants and
the top
dynamic detection
trace file
up incremental
sample dependent
flex multi
batch algorithm
variables at
a program
trace data
grammar of
program invariants
all invariants
of likely
this this
operational abstraction
of program
of variables
checked at
and optimizations
sample is
the simple
this b
are checked
utilities multi
falsifying sample
case runtime
the flex
falsified at
old leader
different program
component upgrades
dependent invariants
leaf program
pass batch
any invariant
hierarchy optimization
invariant must
memory mbytes
non constant
properties are
true at
memory before
at multiple
of properties
variable is
partial order
each program
is falsified
multiple program
algebraic specifications
suppression of
of memory
is processed
properties that
discovering likely
exit point
dynamically discovering
the antecedents
for invariant
detection of
the program
samples the
of samples
optimizations are
the grammar
algorithms and
variables for
anomaly detection
optimizations the
and invariants
processing all
other implementations
variables are
the samples
test suites
before processing
the target
a sample
be checked
variables optimization
weaker invariants
candidate invariant
without optimizations
of weaker
equality sets
optimization opportunities
antecedent properties
redundant properties
remote program
program sampling
extracting implicit
invariant x
an antecedent
for flex
down algorithms
object client
detector may
any suppression
maximum memory
reflexive invariants
procedure exit
over program
the partial
the parent
algorithm section
at each
points are
and space
appear at
invariants for
checking invariants
trace size
invariant over
antecedent is
candidate invariants
is suppressed
flex and
the suppression
observed values
point object
with optimizations
at entry
test cases
variables and
the sample
processed the
points the
missing the
program specifications
likely program
this x
invariants is
all optimizations
invariants which
section 8
variables or
detection is
section 10
the variables
g v
an incremental
algorithm does
all samples
the antecedent
in scope
diagram shows
and exit
program executions
memory usage
two variables
the variable
the multi pass
simple incremental algorithm
the simple incremental
the bottom up
the incremental algorithms
multi pass algorithm
a program point
the top down
bottom up algorithm
pass bottom up
multi pass bottom
bottom up top
top down algorithm
number of invariants
dynamic invariant detection
the target program
at a program
program points the
each program point
down incremental algorithm
algorithms and optimizations
the daikon utilities
top down incremental
the variable hierarchy
an invariant is
out of memory
of likely invariants
dynamic detection of
of program points
flex multi pass
up incremental algorithm
bottom up incremental
the invariant is
the invariant detector
of memory before
of the multi
detection of likely
number of program
the partial order
the old leader
multiple program points
utilities multi pass
at multiple program
sample is processed
pass batch algorithm
incremental algorithm and
the trace file
memory before processing
the trace data
at the parent
sample dependent invariants
an invariant detector
incremental algorithms and
for invariant detection
program points are
multi pass batch
of the hierarchy
up top down
of the optimizations
invariant detection is
properties are checked
dynamically discovering likely
the grammar of
number of samples
variables for example
invariant detector may
at each child
that program point
leaf program point
example x y
the equivalence set
at each program
points are d
top down algorithms
in the daikon
d the corresponding
suppression of weaker
antecedent is falsified
the program points
the optimizations the
program point is
of weaker invariants
processing a sample
of program specifications
processing the full
invariant detection and
each sample is
incremental algorithms are
invariant must be
the invariant x
this b x
incremental algorithm section
remote program sampling
grammar of properties
this this b
incremental algorithm the
the properties are
the invariants that
true at a
are d the
an operational abstraction
time and space
discovering likely program
for each sample
likely program invariants
properties that are
and top down
be checked at
for example x
number of variables
an incremental algorithm
in the hierarchy
the top of
runs out of
run out of
of the invariant
in the multi
the algorithms and
top of the
before processing all
support for program
then any invariant
created by running
daikon utilities with
run the target
automatic anomaly detection
algorithms run out
program construction and
properties hold other
discovering models of
of samples processed
without the optimizations
then the invariant
down algorithm is
software bugs using
processed independently the
hierarchy after a
variables are equal
on object points
of the suppression
equivalence sets of
not be created
quickly detecting relevant
invariant detection dynamic
the invariant for
each invariant that
after a falsifying
errors via machine
object oriented component
at uses of
algorithm the bottom
be an antecedent
space usage at
invariant is suppressed
not complete even
because different variables
the other implementations
four optimizations and
this this x
algorithms for invariant
processing all of
invariants at a
be falsified at
automated support for
relevant program invariants
of an invariant
invariants over the
processed the samples
by generalizing over
the solution that
can involve up
pass and top
comparison of algorithms
non leaf program
hold other properties
incremental algorithm can
test suites via
via operational abstraction
and checking invariants
a leader variable
top down figure
object points are
program points at
debugging algebraic specifications
of type integer
from event based
summand is for
simple java classes
algorithms section 8
falsification of the
the constant set
pass also runs
see section 10
g v v
must be instantiated
against target program
known errors and
program point then
case runtime is
suites via operational

corpus/krapavin2000-test/1030096.txt
fuzzy
fsk
extractor
secret
adversary
challenger
outsider
perturbation
alice
extractors
sketch
public
perturbations
security
insider
attacks
private
gen
reg
drs04
secure
string
attack
fuz
entropy
randomness
bob
cpa
permutation
cor
biometric
her
isometric
biometrics
hamming
sketches
queries
pbk
strings
permutations
drs
dodis
unconditionally
privacy
secrets
leak
constructions
randomization
nonce
codeword
oracle
codes
authentication
randomized
decisional
trent
subcode
generic
password
jw
codewords
word
game
challenge
correction
displacement
ciently
attacker
regeneration
family
ext
query
noisy
oracles
amplification
sketching
metric
symmetry
pivot
bobs
wattenberg
bbr88
jw99
unconditional
leaks
claims
adaptively
computable
transitive
subgroup
juels
imperfectly
codebook
ind
reusable
signature
decoding
against
certificate
distance
responds
honestly
commitment
certification
random
biased
char
admissible
anything
signatures
keys
extraction
pos
adaptive
she
outputs
correcting
certificates
script
authenticate
break
bits
js02
superconcentrators
rts97
adva
cma
bbcm95
subcodes
assigmnents
hardening
vote
insecure
character
ow
edit
stringent
whom
unforgeable
authenticates
keystroke
dishonest
counterexample
protocol
cryptographic
uf
text
authentic
cryptographically
extracted
notions
fresh
code
computationally
deterministically
reuse
extractions
flawed
vulnerability
reminds
winning
withstand
equipped
maps
bit
cient
compliant
protecting
existentially
notion
min
su
appendix
reveal
preparation
sends
legitimate
manageable
erent
thereof
mirror
hash
di
vicinity
uniformly
machinery
imperfect
recover
edition
radius
remote
theoretic
hidden
spaces
indistinguishable
inputs
harden
colludes
dfm98
namics
fuzzy sketch
fuzzy extractor
the adversary
the challenger
chosen perturbation
fsk w
t fuzzy
m m
private string
public string
fuzzy extractors
w m
fsk cor
the secret
string q
secret w
fuzzy secret
perturbation attacks
a fuzzy
fuz cpa
fuzzy sketches
a m
m t
min entropy
gen reg
word w
public strings
of fsk
secure fuzzy
randomness extractor
the fuzzy
generic fuzzy
against adaptive
sketches and
private queries
of fuzzy
w w
permutation based
secure against
code c
jw drs
gen w
pbk s
perturbation attack
challenger the
outsider security
function fsk
outsider chosen
cpa adversary
the private
input w
error correction
unconditionally secure
an outsider
of perturbations
permutation group
space m
attacks in
d w
and extractors
outsider secure
q pivot
against outsider
insider chosen
extractor gen
by fsk
dodis et
al drs04
isometric permutations
sketch or
an insider
perturbations are
bits r
alice s
variable w
a code
cor is
outsider attacks
the jw
t code
attack we
ciently computable
a perturbation
random oracle
on input
private key
random variable
of her
the hamming
of w
string s
private strings
chosen perturbations
her fuzzy
sketch with
extractor as
fsk on
q public
to gen
secret word
fuzzy commitment
outsider attack
hamming metric
fsk and
perturbation security
strings q
sketch and
insider security
of isometric
extractor is
private query
ow fuz
decisional version
adaptive outsider
ind fuz
sketch fsk
privacy amplification
minimum displacement
public queries
linear codes
adaptive chosen
w r
the public
e ciently
the generic
adversary is
w it
a transitive
input word
random bits
to bob
metric space
notion of
m k
log 2
random oracles
permutations in
element w
generic construction
authentication protocol
0 1
s q
w and
of section
the permutation
queries to
q q
the challenge
adversary a
is unconditionally
maps any
security against
over m
challenger runs
given b
linear code
p w
entropy of
any element
a random
commitment scheme
average min
fuzzy secrets
extracted private
isometric permutation
on chosen
a randomness
admissible perturbations
sketching function
randomization strings
codeword w
that fsk
theoretic security
pivot 0
q gen
extractor and
sketch as
d code
perturbation d
any secret
challenge public
public query
made adaptively
fresh random
adaptive insider
w fsk
about w
juels wattenberg
fuzzy extraction
statistical distance
entropy m
transitive isometric
fsk is
drs construction
reg where
sketch construction
zero storage
n k
a private
metric d
m t fuzzy
m m t
a m m
chosen perturbation attacks
m m m
t fuzzy extractor
t fuzzy sketch
public string q
to the adversary
to the challenger
unconditionally secure against
fuzzy sketches and
sketches and extractors
perturbation attacks in
d w w
generic fuzzy sketch
outsider chosen perturbation
private string s
fuz cpa adversary
the challenger the
a fuzzy extractor
random variable w
of the secret
adaptive chosen perturbation
n k d
a q pivot
fsk cor is
the jw drs
extractor gen reg
a m k
et al drs04
outsider secure fuzzy
metric space m
insider chosen perturbation
a fuzzy sketch
fuzzy extractor gen
the secret w
of fsk w
dodis et al
input word w
that the fuzzy
word w m
chosen perturbation attack
the private string
m k t
k t code
the code c
e ciently computable
0 1 n
the adversary is
secure fuzzy extractor
on input word
element w m
ow fuz cpa
secret word w
queries the adversary
the fuzzy extractor
her fuzzy secret
public strings q
adaptive outsider chosen
secure against outsider
ind fuz cpa
fuzzy sketch with
fsk w r
random bits r
strings q 1
family of perturbations
a given b
cor is a
against outsider attacks
of isometric permutations
fuzzy sketch fsk
the fuzzy sketch
be a m
the function fsk
fuzzy extractor is
by the challenger
1 q q
is unconditionally secure
entropy of a
perturbations of the
on input w
the challenger runs
construction of section
log 2 p
secure against adaptive
a word w
against adaptive chosen
is a m
q 1 q
against adaptive outsider
her public string
the hamming metric
a public string
function fsk w
d m m
for all random
chosen perturbation security
gen reg where
fuzzy sketch construction
jw drs construction
fsk w fsk
the decisional version
that fsk cor
notion of symmetry
the generic construction
fuzzy commitment scheme
fuzzy sketch and
variable w m
average min entropy
fuzzy sketch as
chooses a perturbation
all random variable
variable w over
w fsk w
chosen perturbations of
adversary chooses a
a perturbation d
value of fsk
used multiple times
w m to
of security against
of fuzzy extractors
information about w
fuzzy extractor as
transitive isometric permutation
the extracted private
space m let
the attack is
challenge public string
the following 9
the challenge public
any element w
if used multiple
a private string
q gen w
sketch fsk cor
secure fuzzy sketch
on chosen perturbations
permutations in m
fuzzy sketch or
adaptive insider chosen
a randomness extractor
gen w it
min entropy of
an outsider attack
space m as
isometric permutation group
the permutation based
maps any element
k d code
s q gen
q pivot 0
information theoretic security
are made adaptively
challenger the challenger
min entropy m
it holds that
we define the
section 3 3
of section 4
queries to the
that maps any
holds that d
follows the adversary
a code is
w r r
of theorem 9
w c r
a linear code
refer to appendix
the same secret
the generic fuzzy
of the fuzzy
a transitive group
a random oracle
in some finite
the random bits
queries are made
of the attack
the notion of
k to the
and a public
responds to the
be a family
the adversary chooses
the queries are
that for any
the adversary may
the adversary to
the public key
such that for
security of the
of a random
in lemma 4
as in lemma
by the adversary
fsk w captures
w m there
of fuzzy extraction

corpus/krapavin2000-test/1030130.txt
hibe
fs
sk
encryption
id
secret
mhibe
keys
secure
hospital
public
pkg
pke
security
adversary
decryption
tuple
ciphertext
challenger
bdh
doctor
decrypt
broadcast
forward
bob
period
ibe
setup
identities
private
identity
encrypted
keygen
encrypt
collusion
canetti
hierarchy
msk
parse
usk
secrecy
periods
qw
entity
joining
katz
week
oblivious
silverberg
w0
joins
halevi
gentry
resistant
bilinear
hellman
pk
er
params
child
obliviousness
root
reg
ancestors
hierarchical
pkgs
message
oracles
school
users
roles
provider
enc
boneh
communications
protokey
ig
sw
eve
ancestor
w1
key
revoked
oracle
master
revocation
gs
parent
scheme
schemes
corrupt
joined
autonomously
encrypting
fujisaki
rbac
protokeys
sender
queries
secrets
cryptographic
tuples
upd
decrypted
hash
exposure
query
di
children
alice
scalable
responds
manager
recipient
challenged
plaintext
franklin
his
prefix
generator
adaptively
bf
okamoto
protects
content
compromise
center
targets
cryptography
her
outputs
erase
subtree
paring
fazio
halevy
dec
erased
update
role
signature
erases
plaintexts
lsd
cca2
lesson
dodis
credentials
attack
axis
pairing
appendix
guess
stateless
collude
evolves
challenge
runs
authentication
game
hierarchies
erent
node
individuals
nonadaptive
helper
lends
join
complexities
evolve
members
pairings
refresh
labeled
organizations
shamir
attacking
admissible
he
who
subsets
past
recipients
bp
authorized
wishes
entities
bellare
knows
log
leaf
tracing
compromised
cp
newly
grid
she
sends
receiver
evolved
fs hibe
hibe scheme
id tuple
forward secure
based encryption
1 id
public key
time period
fs be
id 1
sk i
id h
broadcast encryption
secret key
mhibe scheme
be scheme
our fs
identity based
fs pke
level setup
an fs
encryption scheme
secret keys
sk w
key sk
an id
tuple id
hierarchical identity
forward security
the adversary
time periods
the fs
the challenger
of fs
secure public
root pkg
joining time
tuple i
id based
w h
identity set
sk t
pke scheme
hospital er
a forward
the public
private key
lower level
the id
i id
multiple hierarchical
secure hibe
keys for
period i
o h
encryption fs
key broadcast
hierarchical id
er doctor
collusion resistant
i h
hibe 22
time oblivious
qw h
period t
current time
security in
the hierarchy
the root
chosen ciphertext
di e
as sk
private keys
usk t
id tuples
week 1
hospital school
h 1
a user
key of
forward secrecy
r max
e hellman
secure communications
the private
scheme and
halevi and
secure hierarchical
by canetti
root setup
msk t
22 scheme
dynamic joins
january week
bilinear di
the bdh
phase 1
scheme is
random oracle
oracle model
of identities
in fs
key generation
sk 0
key be
multiple roles
s secret
h log
key update
at time
scheme are
node w
a secret
the secret
random oracles
time t
key pk
generation time
bob s
setup algorithm
our mhibe
to decrypt
multiple identities
canetti halevi
public parameters
sw h
pke 13
in hibe
compute next
boneh and
the hibe
ciphertext security
h associated
master secret
school manager
scalable forward
in mhibe
periods n
content provider
key msk
encryption mhibe
g 1
binary tree
z q
the security
security of
key encryption
encrypted under
of id
the encryption
access control
a message
key is
keys from
role based
of time
for id
responds as
scheme ii
and silverberg
and katz
time hierarchy
1 parse
runs the
the identity
joins the
an entity
1 h
with time
scheme can
scheme by
with id
of sk
scheme the
level h
key usk
hibe to
13 scheme
and sk
gentry and
adversary issues
parameter generator
setup queries
2 decryption
bdh parameter
a hibe
silverberg 22
advantage against
hibe in
pkg or
doctor hospital
secure broadcast
in ibe
newly joined
bdh problem
parse i
way security
hibe schemes
its targets
value sk
fs hibe scheme
id 1 id
1 id h
our fs hibe
identity based encryption
a forward secure
lower level setup
fs be scheme
an id tuple
sk i h
tuple id 1
hierarchical identity based
id tuple i
secure public key
forward secure public
the public key
id tuple id
fs pke scheme
sk w h
an fs hibe
time period i
i id tuple
time period t
t i id
the root pkg
the id tuple
forward secure hibe
id based encryption
key broadcast encryption
of time periods
based encryption scheme
hospital er doctor
of fs hibe
hierarchical id based
the current time
joining time oblivious
hibe scheme can
key sk i
public key broadcast
the fs pke
secure hibe scheme
of our fs
broadcast encryption scheme
di e hellman
random oracle model
the random oracle
key be scheme
h log n
o h log
key generation time
hibe 22 scheme
bilinear di e
usk t u
forward secure hierarchical
a time period
the private key
current time period
and the id
s k j
number of time
in the hierarchy
scheme can be
public key pk
secret key sk
broadcast encryption fs
an fs be
s secret key
hibe scheme the
scalable forward secure
a scalable forward
time o h
secure communications with
chosen ciphertext security
multiple hierarchical identity
id tuple and
fs pke 13
be scheme is
encryption fs be
as in phase
hibe scheme is
time periods n
responds as in
canetti halevi and
hibe scheme and
key sk t
based encryption mhibe
e h s
encryption mhibe scheme
hospital school manager
for id tuple
halevi and katz
i h 1
key update time
h associated with
of fs be
private keys for
the time period
public key encryption
in the random
public key be
role based access
time period and
the secret key
to the adversary
associated with time
based access control
public key of
in phase 1
fs hibe to
generation time of
pke scheme 13
1 parse i
o h m
next time period
bdh parameter generator
in role based
secure broadcast encryption
the bilinear di
er doctor hospital
n o h
algorithm of fs
how our fs
at level h
in the fs
a collusion resistant
secret key of
the adversary issues
january week 1
where q i
sk t h
algorithm run by
one way security
doctor hospital school
and silverberg 22
message is encrypted
w h 1
secret keys from
input the public
level setup queries
sk 0 1
multiple hierarchical id
secret key msk
by canetti et
parse i as
with id tuple
as i 1
canetti et al
query u t
scheme by canetti
forward security in
and id tuple
advantage against the
forward secure broadcast
master secret key
gentry and silverberg
beginning of time
joining time obliviousness
of an fs
the identity set
the fs hibe
query t i
period t n
key usk t
2 decryption query
and an id
a secret key
on the binary
the binary tree
at time t
a public key
key corresponding to
user s secret
key associated with
i as i
hierarchy e g
time of fs
key of a
current time and
of a user
takes as input
as input the
security in the
a security parameter
security parameter k
a node w
1 i l
the lower level
by the root
b 0 1
cannot be achieved
the security of
i is one
g 1 and
time t and
h for the
to be challenged
having multiple roles
communications with entities
time hierarchy e
identity set is

corpus/krapavin2000-test/1031806.txt
mhd
magnetic
curl
dir
sing
incompressible
regularization
div
stokes
hood
inf
hydrodynamic
singularities
convergence
continuity
sup
weight
weighted
norm
dofs
magneto
solenoidal
coercivity
hydrodynamics
field
boundary
smooth
fem
am
velocity
discretization
mixed
navier
nodal
taylor
domains
spaces
rates
posedness
maxwell
convex
stationary
exponents
proposition
singular
corner
polyhedral
corners
opening
regularity
assertion
remark
inhomogeneous
subregion
embedding
pressure
quasi
oseen
smallness
insulating
therein
stability
mesh
qs
dirichlet
shaped
singularity
formulation
sobolev
uniqueness
exponent
ker
laplacian
weak
bilinear
numerical
corollary
discretizations
unknowns
strongest
indispensable
endow
convection
galerkin
denoting
norms
cb
linearized
polygonal
rellich
poincar
divergence
conducting
fields
angle
equipped
lipschitz
solely
inequality
picard
interpolant
reg
endowed
approximation
meshes
equations
analogue
convergent
elliptic
linearizations
integrable
hopf
subspace
dimensional
references
fluid
forms
liftings
chapter
lemma
di
errors
element
confirmed
iv
stabilization
reynolds
cited
error
coupling
governing
neumann
analogues
operator
polyhedron
restrictions
posed
dimensions
conforming
loc
polar
laplace
spherical
older
cycle
finite
erent
polyhedra
thereof
satisfying
radial
vector
36
freedom
skew
cone
decompositions
x2013
canbedecomposedas
cous
electrolysis
magnetostatic
forwardly
magnetomyampersand
beltrami
approximition
ellipitc
79260428
54448373678246
magnetohydrodynamics
2sup
dauge
gous
givenby
magnetohydrodynamic
1fig
electrostatic
costabel
dimensionalize
electromagnetics
eomorphic
hp
ball
stable
demonstrating
isomorphism
cient
nely
numer
permeability
conductivity
slip
metals
pumps
hereby
analo
fluids
aluminum
regulariza
ca
the magnetic
finite element
weighted regularization
weight vector
v c
magnetic field
mhd problems
c w
mhd problem
inf sup
constant c
convergence rates
2 19
only depending
incompressible mhd
convex domains
2 36
element approximation
u b
smooth solution
non convex
mixed finite
q l
on and
c c
hood taylor
the hydrodynamic
the continuity
2 28
the forms
v h
h 1
elements for
vector satisfying
a weight
mesh size
in 2
two dimensional
sup condition
there holds
error in
the weighted
satisfying 2
2 17
remark 2
polyhedral domains
stationary incompressible
curl b
sing sing
boundary conditions
field b
l 2
w h
lemma 2
corollary 3
u h
2 error
c 0
2 16
the weight
in non
b h
l h
h s
the velocity
weak formulation
solely depending
regularization technique
incompressible magneto
magneto hydrodynamics
taylor elements
continuous embedding
for incompressible
with dir
opening angle
shaped domain
b sing
7 section
boundary data
a constant
proposition 2
the norm
0 only
r c
in u
c 1
depending on
the mesh
continuity properties
size h
l shaped
quasi optimal
corner c
solution components
regularization term
v 0
element methods
r e
navier stokes
b p
u p
b x
optimal error
c 2
rates in
and uniqueness
the discretization
b v
singular solution
0 solely
dofs in
regularization approach
the mhd
dir 1
proposed finite
linear mhd
magnetic fields
discrete inf
div in
cycle dofs
magnetic singularities
have div
existence and
element method
theorem 2
point out
velocity field
we point
solution u
error bounds
0 depending
solution errors
forms c
well posedness
the incompressible
am b
ker b
in b
s d
see 7
the references
w d
e e
formulation 2
element spaces
the coercivity
denoting the
a s
p h
the stability
2 21
discretization of
spaces v
non smooth
small data
2 15
h v
bilinear form
curl curl
and endow
oseen type
smallness assumption
qs c
magnetic bilinear
regularity below
ca cb
dir given
cited therein
below h
sup stable
dimensional analogue
on nodal
inhomogeneous boundary
that curl
the smallness
weighted spaces
the curl
standard inf
x error
mhd equations
to convergent
curl operator
nodal elements
derive quasi
dimensional mhd
references cited
type mhd
unknowns u
error equation
stability bounds
in polygonal
approximation of
c v
domains the
the laplacian
two dimensions
bounds in
q v
the continuous
2 6
v c w
the magnetic field
a constant c
depending on and
a weight vector
the weighted regularization
constant c 0
finite element approximation
in non convex
only depending on
non convex domains
elements for the
weight vector satisfying
vector satisfying 2
theorem 2 17
be a weight
of the magnetic
satisfying 2 19
h s d
u b p
0 only depending
c w h
2 error in
the weight vector
with the norm
the mesh size
mixed finite element
inf sup condition
1 4 4
with a constant
the two dimensional
magnetic field b
proposition 2 16
incompressible mhd problems
l 2 error
of the forms
convergence rates in
element approximation of
l shaped domain
quasi optimal error
hood taylor elements
incompressible magneto hydrodynamics
error in u
solely depending on
error in b
q l h
weighted regularization technique
the continuous embedding
point out that
finite element methods
and the references
mesh size h
and q l
existence and uniqueness
the finite element
0 depending on
the velocity field
finite element method
a s u
we point out
mhd problem in
h v c
c 0 solely
forms a s
0 solely depending
weighted regularization approach
cycle dofs in
the proposed finite
optimal error bounds
discrete inf sup
in 2 21
w v c
c 0 only
for the discretization
2 19 and
formulation 2 28
solution u b
solution errors and
forms c 1
and 2 36
the magnetic fields
smooth solution errors
w h v
for the magnetic
errors and convergence
finite element spaces
proposed finite element
c and e
let be a
c c and
discretization of the
in two dimensions
the discretization of
on and such
and convergence rates
h 1 0
for a constant
in lemma 2
lemma 2 10
using the weighted
in u p
l 2 0
that the weighted
two dimensions the
theorem 3 3
of the mesh
in proposition 2
for small data
the mhd problem
technique recently developed
mhd problems in
sup condition in
bound c 1
non smooth solution
two dimensional mhd
references cited therein
depending on such
derive quasi optimal
w d u
obtain with a
the magnetic bilinear
continuity properties in
lemma 2 12
weighted regularization is
stationary incompressible magneto
for a weight
for incompressible mhd
the references cited
linear mhd problems
oseen type mhd
corner c c
error bounds in
h into l
o w d
inf sup stable
v c v
remark 2 11
lemma 2 15
to correctly capture
incompressible mhd equations
find the velocity
numerical experiments for
series of numerical
the forms c
dimensional analogue of
1 error in
of stationary incompressible
the continuity properties
the stability bounds
the discrete inf
standard inf sup
q l 2
problem 4 1
c w v
solutions in non
ker b h
regularity below h
small data we
the regularization term
we have div
x error in
the smallness assumption
curl b 2
embedding of h
the norm x
u h b
in b l
nodal elements for
for the form
h 1 error
the error equation
the forms a
continuous embedding of
regularization technique recently
magnetic bilinear form
b q v
the corner c
in 7 section
the coercivity of
of h into
to r e
type mhd problem
unknowns u and
2 16 and
any v c
spaces v h
two dimensional analogue
4 1 4
to this end
1 2 6
equipped with the
the continuity of
and c 2
and such that
1 and c
convergence of the
the l 2
the well posedness
s d for
19 and 2

corpus/krapavin2000-test/1031858.txt
os
segments
slab
segment
green
shooting
multislab
log
subdivisions
ray
blue
deletions
vertical
planar
red
external
arge
answered
rst
query
subdivision
amortized
agarwal
subsegment
insertions
cascading
sorted
eciently
endpoints
kq
decomposable
ecient
hit
fractional
insertion
slabs
stored
disk
secondary
logarithmic
redundant
monotone
delete
deletion
crossing
dynamization
rmca
queries
rw
blocks
rebuilding
answering
sampled
leaf
inf
location
nd
ij
batched
deletes
union
sorting
lowest
static
rebuild
internal
searching
structures
plane
storing
lars
tree
disjoint
pointer
consecutive
store
endpoint
emanating
root
interval
intersects
sample
haverkort
rebalance
2b
dynamic
modied
answers
vitter
subsegments
bentley
berg
consecutively
sup
pankaj
herman
charging
updates
height
eia
duke
aggarwal
sixteenth
lemma
scanning
crossed
partition
jr
intersecting
ke
memory
objects
vertices
trees
ubiquitous
answer
node
lie
geographic
xm
boundaries
leaves
middle
querying
denition
interior
deleting
ancestor
supports
successor
counters
discarding
jv
incomparable
cutting
00
goodrich
bmca
jarnadan
janardan
9972879
originalp
9984099
themv
baumgarten
muenster
socg
semidynamic
9870734
cheng
massive
charge
deleted
email
persistent
children
visiting
specically
build
face
handled
adds
mca
aord
stabbing
edelsbrunner
bv
hinrichs
inspiring
vahrenhold
worst
polygon
insert
constructed
mark
000
encountered
dene
oset
ess
nding
preprocessing
visited
copy
inecient
sampling
subsets
pointers
multidimensional
yi
dened
annual
maintain
tting
digraphs
collect
iteratively
asymptotically
seek
pisa
i os
log b
b n
o log
in o
segments in
n b
b log
green segments
point location
slab s
b i
n i
ray shooting
external memory
o n
s j
vertical ray
d i
green segment
log 2
structure d
logarithmic method
multislab structure
the segments
os in
hit by
answered in
using o
shooting query
m b
of segments
be answered
data structure
a segment
log m
g i
blue segment
red segments
fractional cascading
rst segment
secondary structures
i o
non redundant
disk blocks
sorted sequence
the green
i 1
segment s
the rst
b tree
planar point
agarwal et
structure m
stored in
external version
each slab
the multislab
b disk
n disjoint
o ecient
red segment
os amortized
disjoint segments
a vertical
r i
and deletions
i b
node v
the logarithmic
os and
the sorted
planar subdivision
segment in
lowest non
structures d
general subdivisions
nd the
dynamic data
structure using
deletions can
linear space
in s
segment of
interval union
arge et
internal memory
log kq
of green
base tree
an external
memory data
performed in
constructed in
be constructed
segments are
deletions in
segments r
a query
in r
al 1
insertions and
find structure
union find
crossing s
redundant segment
find x
vertical slab
dynamic point
blue segments
dynamic structure
in slab
segments g
b blocks
external decomposable
location in
k b
in total
be stored
u ij
answering a
of s
structure for
o 1
query can
data structures
segment g
endpoints on
static structure
structure can
s v
queries in
union operations
in internal
segment t
os the
the blue
o b
internal node
the structure
segment hit
segments b
support deletions
monotone subdivisions
amortized respectively
global rebuilding
dynamic fractional
new external
shooting queries
the slab
leaf z
insertion bound
searching problems
planar subdivisions
os as
consecutive green
rmca g
right structures
o efficient
sampled segments
ecient dynamic
o eciently
kq i
static external
r v
segments can
all segments
b k
are stored
v of
and such
answers queries
os by
our structure
segments stored
in external
n log
d j
be performed
segments to
an insertion
at v
k i
we rst
o k
in g
blocks so
segment r
interval tree
a find
inf i
et al
the plane
the red
the lowest
tree t
queries can
segments from
os to
g s
log b n
o log b
b n i
n i os
in o log
o n b
n b log
b i os
b log b
log m b
o log 2
vertical ray shooting
performed in o
be answered in
i os in
structure d i
segments in r
answered in o
g i 1
can be answered
in s j
b log m
a vertical ray
m b n
ray shooting query
the segments in
the logarithmic method
the rst segment
b n b
constructed in o
in o n
point location in
n b i
planar point location
slab s j
using o n
i os and
the sorted sequence
agarwal et al
1 i os
i os amortized
b disk blocks
green segments in
k i os
nd the rst
the multislab structure
external version of
queries in o
i o ecient
sorted sequence of
of segments in
be constructed in
a segment s
segments in s
n i b
lowest non redundant
external memory data
sequence of segments
log b k
structure using o
b k i
the lowest non
deletions in o
be performed in
can be constructed
in r i
o n i
r i 1
shooting query can
segments in g
interval union find
n b disk
arge et al
the green segments
of green segments
that a vertical
o log kq
the base tree
log 2 n
insertions and deletions
d i 1
et al 1
i b i
union find structure
dynamic data structure
a b tree
o 1 i
o k b
query can be
rst segment of
an interval union
and deletions in
in internal memory
green segment in
structures d j
k b log
of n disjoint
i i os
green segment g
multislab structure m
base tree t
os in total
os and such
data structure using
and deletions can
data structure d
a planar subdivision
in slab s
dynamic point location
n disjoint segments
segment s in
data structure for
be stored in
structure can be
in d i
can be performed
b i 1
a data structure
in o 1
and o log
j j i
each node v
i os the
deletions can be
memory data structures
and such that
segments in the
in g i
stored in a
d i and
segments can be
dynamic fractional cascading
the structure can
m b i
consecutive green segments
a new external
static external memory
external memory algorithms
the vertical slab
internal node v
of segments stored
segment hit by
log kq i
d j j
of consecutive green
2 i os
log k d
of dynamic fractional
logarithmic method we
crossing s j
segment of s
version of dynamic
kq i os
b n log
an external version
with endpoints on
ray shooting queries
g s j
the structure d
log 2 i
in each slab
answers queries in
i o efficient
i o eciently
and right structures
new external version
structure for point
i os as
non redundant segment
to nd the
of the segments
b i and
can be stored
and b i
v and b
blocks so that
i os by
i os to
in external memory
and b v
for point location
n log m
queries can be
n i i
in a data
a linear space
in the plane
location in a
r v and
we nd the
the o log
2 n time
i and b
node v of
deletion of a
of a segment
o log k
s j in
worst case and
s j and

corpus/krapavin2000-test/1032082.txt
cc
modmp
inf
zz
rank
mod
sigma
mzz
modm
acceptance
prime
nondeterministic
theta
protocol
submatrix
ort
semiring
seq
pp
circuits
counting
proposition
incomparable
accepting
sigmaj
modes
sup
mode
protocols
rejecting
acc
player
matrix
np
co
communication
ranks
rej
6j
prob
sdt
rankr
ir
binomial
ib
subspace
fermat
semirings
vlsi
inclusion
kth
modular
players
var
lemma
nondeterministically
homomorphism
arguments
orthogonal
classes
depth
announces
ip
branching
nonnegative
matrices
determinism
entries
primes
deterministic
damm
homeister
multilective
focs
canonic
w2f0
brosenne
coefficient
probabilistic
1g
tradeoffs
inner
bip
blackboard
waack
turing
orthogonality
oblivious
delta
gates
0n
1r
babai
speak
rg
rows
integers
ae
regard
claim
pairwise
modularity
computations
variation
sequences
dn
factorization
vectors
spectral
bounds
henrik
stephan
infinitely
f0
pseudorandom
vegas
dlog
reductions
diagonal
norm
monotone
matthias
las
communicated
rectangular
log
characteristic
modulo
nondeterminism
reals
root
integer
reducible
2n
languages
cos
indices
00
corollary
reischuk
halstenberg
stacs
coprime
ff0g
meanders
basel
idempotents
pzz
qjm
gamma2
party
complement
ff
commutative
chooses
indexed
2m
homogeneous
columns
bit
transposes
monoids
hing
1gg
history
string
gammaf
analogies
enumerations
relativized
discriminator
relations
product
versus
divides
comparability
f1g
obvi
announce
carsten
properly
stops
sequel
maximal
polynomial
analytic
notions
algebra
tree
logspace
402
obdds
fz
divisibility
36th
rigidity
identity
connect
nonzero
obviously
communication complexity
p cc
sigma n
complexity classes
np cc
inf i
modmp cc
n theta
acceptance modes
counting communication
zz mzz
protocol p
theta sigma
mod m
i inf
mod p
pp cc
cc and
theta n
c prob
order equivalent
acceptance mode
prime number
communication protocol
are incomparable
rank zz
ort p
counting acceptance
sup cc
seq n
var rank
sigmaj n
cc sup
prob f
to inclusion
n matrix
a prime
x y
cc are
g n
a ii
incomparable with
j sigmaj
cc is
lower bounds
co n
binomial coefficient
mod inf
co np
i p
input x
and mod
0 mod
b v
0 theta
n 0
acc p
6j 0
and rejecting
branching programs
m 0
is order
submatrix of
ii 6j
rejecting computations
is modm
variation ranks
rej p
kth binomial
modm equivalent
protocol on
p be
n p
a protocol
let p
i sup
number then
of p
p on
p i
integer matrix
c co
on sigma
mod q
accepting and
m i
complete for
probabilistic communication
theta y
vlsi circuits
p p
of communication
matrix with
the modular
communication protocols
rank 1
i m
rank arguments
r inf
orthogonality test
fermat s
rank ib
s little
cc as
nondeterministic communication
prime factorization
rejecting otherwise
cc 6
many n
chooses nondeterministically
inf r
dn re
n seq
semiring homomorphism
nondeterministic mode
m ort
real variation
co nondeterministic
and modmp
little theorem
homogeneous submatrix
variation rank
nondeterministic protocols
player x
0 submatrix
m acc
relations between
2 sigma
on x
of m
with regard
theta j
ir n
claim follows
tradeoffs for
zz m
communication history
modulo m
1 homogeneous
prime then
are accepting
proposition 20
inclusion 2
accepting computations
rows and
x theta
in vlsi
entries are
p l
the prime
the protocol
by proposition
over r
1 inf
for counting
c mod
the player
l 00
monotone circuits
inf 1
of complexity
regard to
the communication
r be
computations on
natural number
the orthogonality
corollary 7
properly contained
sup and
inner nodes
that rank
the players
y 2
a 0
a communication
equivalent to
is complete
all indices
maximal set
2 g
the tree
a computation
p and
if n
l k
linear subspace
and product
v x
on input
let a
sequences of
bounds for
the deterministic
rank of
an n
f log
lemma 14
nonnegative integer
with entries
communication complexity classes
theta sigma n
sigma n theta
counting communication complexity
n theta sigma
inf i p
a prime number
input x y
i p i
theta n matrix
order equivalent to
sup cc sup
co np cc
j sigmaj n
mod p p
cc are incomparable
c prob f
are incomparable with
be a prime
i m i
counting acceptance modes
n 0 theta
mod inf i
p p cc
is order equivalent
rank zz mzz
0 theta n
incomparable with regard
theta n 0
regard to inclusion
np cc and
i sup cc
p be a
n theta n
p i inf
p i sup
g n p
6j 0 mod
i inf i
2 g n
on x y
ii 6j 0
c co n
y 2 sigma
communication protocol on
kth binomial coefficient
on sigma n
accepting and rejecting
b v x
a ii 6j
prime number then
cc is closed
computation of p
z 2 g
let p be
is complete for
p l k
of p on
x theta y
x y 2
p cc as
acceptance mode the
m acc p
0 mod p
modmp cc are
is modm equivalent
the n 0
n seq n
n 0 submatrix
infinitely many n
m i inf
protocol p of
2 p cc
1 homogeneous submatrix
var rank zz
acceptance modes for
mod p l
sigma n with
the orthogonality test
homogeneous submatrix of
sigma n and
s little theorem
i inf r
theta j sigmaj
cc and mod
inf r inf
2 sigma n
fermat s little
for all indices
of if n
and modmp cc
and mod inf
sigmaj n theta
all indices i
submatrix of m
cc sup and
modm equivalent to
sup and mod
to inclusion 2
p cc is
cc and modmp
protocol on sigma
inf i m
and rejecting computations
on input x
with regard to
of m 0
communication complexity of
lower bounds on
an n theta
a protocol p
a maximal set
p on input
f z 2
p on x
set of pairwise
the communication history
bit to be
1 inf i
be a positive
probabilistic communication complexity
inf 1 inf
with entries in
matrix with entries
i inf 1
l k k
of the tree
maximal set of
sum and product
properly contained in
of rows and
a communication protocol
is closed under
a 0 be
computations on the
x and y
a computation of
bounds on the
the claim follows
sufficient to show
n matrix with
let a 0
and lower bounds
rows and columns
will consider the
is a matrix
rg let a
consider the ordered
binomial coefficient consider
homeister stephan waack
inner nodes v
1g l w
that dn re
circuits for matching
j gamma 2m
nondeterministic communication protocols
an orthogonal matrix
by proposition 20
function we will
entries in f
that a ii
if n p
yield better bounds
on oblivious branching
zz mzz rank
provide lower bounds
to p cc
nondeterministic vlsi circuits
two processors in
stops rejecting otherwise
for modmp cc
of pairwise linear
q p cc
equivalent to j
lower bound arguments
computation stops rejecting
modes except for
show that rank
the r rank
and mod q
pp cc and
by the player
the probabilistic mode
x chooses nondeterministically
of information transfer
entries are equal
chooses nondeterministically some
that 2 it
let f and
2 co np
to each accepting
for counting acceptance
mod m and
cc as well
this extends the
sigma n holds
for inner nodes
m ort p
acceptance modes except
r rank of

corpus/krapavin2000-test/1032163.txt
ra
registration
cell
mss
mh
vlr
intra
gammanoncore
lr
ras
cells
gammacore
handoffs
hlr
inter
signaling
bs
mobile
mhs
gammacall
gammamove
mobility
lrs
moves
core
registered
deliveries
handoff
overlapping
calls
cv
delivery
2ffi
location
reconfiguration
mt
load
registrar
msss
gammaoutgoing
notif
offs
gammaincoming
exclusion
pcs
vv
inclusion
station
req
ex
updates
configuration
gsm
areas
management
bss
noncore
hlrs
messaging
exclude
users
servicing
searches
terminal
costs
highway
4ffi
candidate
yes
home
id
rates
external_cell_1
cmr
visitor
traffic
neighboring
area
boundary
calling
db
sends
period
overlapped
css
subscription
mobiles
update
terminals
cellular
adapting
excluded
move
attraction
ffi
dynamically
geographical
external
contacted
old
stations
movement
contraction
pole
kryukova
akyildiz
callee
inc_notif
das
decrease
expansion
excludes
aggregate
bejerano
2fl
prakash
exclusions
asks
hierarchy
decides
rajagopalan
aggressiveness
personal
performing
default
message
notifications
register
service
database
reconfigure
profitable
decide
locality
communication
off
standards
hexagonal
urban
ip
sandeep
patterns
adapt
shrinking
simulation
expanding
contacts
serviced
notifies
hops
holes
belong
replication
gamma
pattern
wireless
informs
caller
reg
servers
caching
ff
services
initiating
41
overhead
subtract
expanded
requests
handles
periodically
networks
stabilize
additions
happens
network
tries
ffl
radius
balancing
tracking
simulations
equilibrium
fl
incoming
multiplicity
sent
direcytedhand
outgo
mssk
varsamopoulos
vmr
badrinath
registrars
lizes
core_cell_3
perfoms
massingill
mscs
overlaping
inter ra
intra ra
ra k
moves k
registration area
ra calls
call delivery
registration areas
location management
c intra
ra handoffs
cost ex
the ra
ra moves
cell i
the registration
call deliveries
calls k
the mh
k a
registered with
hand offs
c inter
k moves
the mobile
cv c
with ra
and call
the bs
core cell
core cells
an ra
of ra
gammamove gammanoncore
the vlr
non core
ra call
gamma cost
cost in
ra the
reconfiguration period
2ffi cv
gammacall gammanoncore
intra gammacall
ra hand
ra handoff
intra gammamove
ex k
the lr
n calls
the ras
candidate cell
gammacall gammacore
inter gammaoutgoing
vlr of
the hlr
an mh
location registrar
mss k
the signaling
cells in
a increase
mobile terminal
of inter
hand off
mh s
cost inter
inter gammaincoming
cost intra
each lr
in cell
mobility pattern
pcs networks
in ra
candidate cells
mobility and
the cells
ra and
the load
gammanoncore gammanoncore
lr db
same ra
an mss
gammacore c
gammamove gammacore
k cost
load k
signaling load
gammanoncore gammacore
each mss
increase inter
no no
ras in
of overlapping
base station
the call
increase intra
signaling cost
req to
call patterns
mh is
ra is
in k
of location
in gamma
is 41
a mobile
another cell
gammacore 2ffi
of registration
boundary k
home location
decrease inter
deliveries and
new vlr
external cell
k signaling
ffi vv
n moves
cell c
cell a
for performing
the mobility
mobile users
cell to
a cell
a core
and searches
k i
the mt
mobile service
a ra
ra of
ra a
performing inter
2 ra
in pcs
the mss
is registered
that cell
cells of
the scheme
ff v
cell d
proposed scheme
updates and
the calls
5 cost
and gsm
between cell
gammaoutgoing gammacall
as core
cost updates
a registration
dynamically adapting
gammanoncore 2ffi
users registered
the handoffs
gammaincoming gammacall
location register
called mt
the lrs
old vlr
4ffi cv
management strategy
its ra
updates searches
handoffs and
mhs registered
two msss
hlr of
exclusion notif
call pattern
ra such
inclusion notif
gammaoutgoing gammamove
ra m
and hand
moves from
load of
the location
cost of
inclusion and
of intra
the cost
part shows
mh which
ras is
current load
cell cost
each ra
i cost
cell j
new ra
mobility patterns
management schemes
new cell
an inter
of cells
cost between
inter ra calls
ra moves k
inter ra handoffs
registered with ra
intra ra calls
ra calls k
moves k moves
with ra k
moves k a
k moves k
of inter ra
inter ra moves
c intra gammamove
gamma cost ex
ra k and
cost ex k
c intra gammacall
inter ra call
cost in k
cost in gamma
in gamma cost
mobility and call
2ffi cv c
c inter gammaoutgoing
c inter gammaincoming
intra ra moves
in ra k
k a increase
the registration area
cv c intra
cost intra ra
calls k a
intra gammamove gammanoncore
cost inter ra
the n calls
of the mobile
to the ra
increase inter ra
of the mh
ra hand offs
updates and searches
and call patterns
increase intra ra
the same ra
the registration areas
of ra k
of the ra
in the ra
the mobile terminal
an inter ra
for performing inter
gammacore 2ffi cv
call deliveries and
i c intra
the mh is
degree of overlapping
registration area to
intra ra handoffs
performing inter ra
inter ra handoff
the vlr of
non core cell
the inter ra
intra gammacall gammanoncore
k i c
in k a
cv c inter
of intra ra
the ra k
ra call deliveries
decrease inter ra
ex k a
inter ra hand
ra call delivery
k in cell
all the cells
the load of
moves from a
cell i is
location management in
in pcs networks
cost for performing
the cells in
a k i
deliveries and hand
intra ra handoff
update and search
vlr of the
of the mt
load for performing
the called mt
the call delivery
a increase inter
ra such that
by each lr
inter gammaoutgoing gammamove
a core cell
the candidate cells
intra ra hand
a non core
signaling load for
core cells of
gammanoncore 2ffi cv
cost updates searches
cell to another
cells of ra
users registered with
req to the
ra handoffs and
hand offs between
hand offs for
and call deliveries
call delivery and
and call pattern
inter gammaoutgoing gammacall
intra gammacall gammacore
to another cell
home location registrar
gammamove gammanoncore gammacore
cost of intra
inter gammaincoming gammacall
values of call
k a gamma
4ffi cv c
the new vlr
cell i and
and hand offs
mhs registered with
between cell i
of call and
such that cell
communication cost between
cost of inter
k signaling load
ra k in
have different cost
is registered with
location management schemes
the hlr of
management strategy for
of k in
the proposed scheme
mh which is
c k a
inclusion and exclusion
number of inter
in cell i
k a k
of an ra
lines show the
to the mobile
cells in the
the cost in
pattern m and
different cost depending
gammacall gammanoncore gammanoncore
the default ra
exclude a candidate
on whether they
m and call
a gamma cost
in cost ex
cost in cost
search lr db
candidate cells for
core cell to
handoff takes place
they are incoming
registration areas the
gammacore c inter
users of k
n calls and
dynamically adapting registration
gammaincoming gammamove gammacore
hlr updates and
is in ra
reconfiguration period the
an mh which
an intra ra
mh moves from
i cost ex
ras is that
of registration area
of mss k
inter gammaincoming gammamove
call delivery inter
mobility pattern m
period the lr
gammamove gammanoncore gammanoncore
of core cells
in a ra
or exclude a
cells in i
ra calls have
for performing intra
when the mobility
its registration area
call and move
default ra of
ra handoffs for

corpus/krapavin2000-test/1032502.txt
stc
cache
htc
fetch
instructions
instruction
trace
branch
cfa
miss
16kb
branches
xblast
codes
traces
blocks
postgres
fipa
misprediction
32kb
btb
subroutine
apsi
hydro2d
reordering
sequentiality
ijpeg
layout
core
fetched
josep
torrellas
vortex
workloads
exec
reordered
fipc
postgresql
mgrid
breaks
block
profile
popular
gcc
seed
predictor
reorder
bb
64kb
su2cor
pettis
branchrep
execrep
unconditional
locality
indirect
misses
code
benchmark
caches
threshold
loops
rate
turb3d
sequences
hardware
conditional
alone
arcade
cpa
benchmarks
seeds
cycle
buffer
contiguous
executed
inlining
percentage
consecutive
ras
perl
transitions
prediction
optimizations
aggressive
loop
fpppp
applu
pey
2362
larriba
superscalars
irez
gag
m88ksim
compile
pc
90
thresholds
target
hansen
base
training
secondary
compress
fp
pq
predicted
break
fill
unused
a3
fetching
proportion
breaking
mispredictions
bench
spec
unit
width
replication
discarded
references
coloring
targets
replicated
4kb
workload
crossing
147
reserved
processor
wasting
pen
len
calls
jumps
cycles
a7
unrolling
floating
penalty
bp
a5
barely
jump
58
interleaved
fall
transfers
offered
meanwhile
46
chains
conflicts
outgoing
layouts
seq
raising
speculative
collapsing
hit
75
reductions
optimize
penalties
decode
offer
behave
trying
stops
temporal
double
mapping
address
software
frequently
weight
throughput
optimizes
59
simulation
frequent
76
determinism
outcomes
stream
passes
alex
125946
1486
mispr
traces000000000000000000000000000000000000111111111111111111111111111111111111111111111
ecuted
2716
aptind
11748
172690
xavi
1998fi
the stc
basic blocks
i cache
t cache
fetch unit
trace cache
basic block
cache miss
instruction cache
miss rate
the htc
core fetch
stc and
the instruction
the branch
base 7
base 6
the fetch
16kb base
a htc
sequence breaks
branch misprediction
software trace
instruction fetch
conditional branches
instructions per
per access
branch threshold
code reordering
the code
subroutine calls
most popular
the t
the fipa
branch prediction
code layout
integer codes
branch predictor
htc alone
popular traces
useful instructions
hardware trace
a 32kb
4 base
pc relative
cfa size
per cycle
5 0
of basic
7 4
better results
the core
of sequence
results than
cache lines
taken branches
code sequences
13 5
15 5
the trace
7 0
branches and
9 7
of instructions
execution path
6 8
blocks in
the reordered
large codes
of fetched
cache t
stc is
misprediction rate
exec threshold
codes like
code sequentiality
fill buffer
5 base
htc of
fetch mechanism
fall through
the btb
double size
fetched instructions
performance limit
loop basic
11 7
instructions from
7 7
codes with
prediction accuracy
and branch
similar or
13 7
8 5
3 0
4 9
9 4
13 8
reorder the
cache line
9 6
some codes
code replication
few loops
unconditional branches
consecutive instructions
the basic
the hardware
cache the
profile information
the fp
percentage of
or better
the percentage
10 0
11 4
5 9
2 base
11 6
execution sequences
of double
instructions executed
0 5
8 8
cache is
break the
the cfa
memory positions
reordering technique
pettis hansen
fetched ffl
loop branches
sequential fetch
subroutine call
cache htc
the postgresql
cache i
size alone
stc can
predictor throughput
reordered code
32kb instruction
unused basic
fixed way
small htc
popular sequences
trace building
torrellas and
indirect jumps
dynamic references
base 11
and xblast
block transitions
address cache
execution core
stc with
fixed behavior
base 13
branch address
consecutive basic
blocks executed
cache stc
of loops
7 11
each pass
4 12
3 9
1 7
execution paths
12 4
each benchmark
8 11
4 4
0 4
4 0
to fetch
6 5
traces in
a profile
75 90
fetch address
high instruction
rate reduction
and subroutine
josep torrellas
fetch performance
the exec
8 6
13 6
the execution
0 3
the processor
5 7
6 9
cache misses
the fill
44 4
of workloads
sequentially executed
cache miss rate
i cache miss
core fetch unit
the t cache
the core fetch
of the stc
the i cache
the basic block
the instruction cache
the basic blocks
software trace cache
basic blocks in
the stc and
instruction cache miss
the fetch unit
the trace cache
better results than
the most popular
hardware trace cache
most popular traces
or better results
similar or better
results than a
of sequence breaks
of basic blocks
branch prediction accuracy
of the code
blocks in a
fetched instructions per
cache t cache
of double size
and the htc
of fetched instructions
a htc of
instructions per access
loop basic blocks
the hardware trace
stc and the
t cache miss
fetch unit and
the branch misprediction
branch misprediction rate
number of fetched
the percentage of
codes with few
and the branch
4 9 4
4 7 4
the instruction fetch
instructions per cycle
of the dynamic
number of instructions
with few loops
stc and a
consecutive basic blocks
execution core of
josep torrellas and
i cache lines
with the stc
16kb base 7
the branch predictor
branch address cache
a 32kb instruction
the stc is
cache i cache
trace cache the
t cache is
the execution core
9 7 9
instruction cache i
double size alone
miss rate reduction
a fixed way
a fixed behavior
percentage of sequence
the code layout
break the execution
of the fetch
basic blocks executed
basic blocks to
branch predictor throughput
the stc can
32kb instruction cache
large codes with
running the training
unused basic blocks
of loop basic
htc of double
of useful instructions
subroutine calls the
basic block transitions
code reordering technique
percentage of basic
13 7 11
trace cache htc
i cache t
of basic block
consecutive instructions executed
the reordered code
for large codes
a small htc
than a htc
and subroutine calls
the fill buffer
sequential fetch unit
trace cache stc
of the instruction
the most frequently
in a program
sequences of basic
the execution sequence
10 0 3
basic block size
of consecutive instructions
instruction cache misses
branches with a
a basic block
fetch unit is
the branch prediction
a combination of
with a combination
3 0 4
9 4 2
of the processor
the number of
number of useful
number of consecutive
4 1 3
average number of
the original code
behave in a
in a fixed
combination of both
with a large
obtained with a
that for large
4 4 4
and a small
4 2 4
executed for the
basic block reordering
6 8 5
6 5 9
16kb t cache
of a htc
basic blocks with
fetch performance the
5 7 base
7 5 7
the fetch mechanism
breaks seq len
t cache to
htc alone and
miss rate for
7 7 4
a secondary trace
start a secondary
few loops and
sequence breaking bb
offer similar or
9 13 6
10 3 instructions
per cycle obtained
pc relative unconditional
7 11 7
base 11 7
sequentially executed basic
than the exec
instruction cache hit
the code sequentiality
i cache and
in consecutive memory
75 90 and
the branch threshold
decreasing frequency of
cache line coloring
15 5 14
torrellas et al
a weight lower
reduction offered by
floating point codes
2 trace building
s subroutine call
popular traces in
a 256 entry
main execution path
through basic blocks
of static instructions
a software trace
13 5 13
for each workload
number of sequence
most frequently referenced
reorder the basic
the main execution
15 9 15
our code sequences
access we also
stc with a
which behave in

corpus/krapavin2000-test/1035549.txt
ow
balanced
permutation
knapsack
mixing
walk
permutations
weights
fw
items
uniform
hyperplanes
uniformity
unif
sm
fpras
0x
balance
multicommodity
pr
poly
rst
weight
hyperplane
prw
plainly
dene
denition
p2
jw
wy
hypercube
cm
xed
i2x
wx
stage
ja
strongly
ik
fake
mix
vertices
paths
1g
cube
interleave
intervals
exp
padded
almost
polynomial
sums
su
random
jlj
berkeley
f0
item
satises
counting
ows
carrying
lie
sampling
markov
sevast
1jd
i2s
94720
hoeding
yanov
grinberg
truncated
exponent
remark
ciently
symmetric
indices
event
uctuations
dened
route
walks
fix
chains
cq
16d
specied
ju
combinatorial
projections
geodesic
aggregated
z
quoted
technical
ces
stages
dimensions
path
lemma
cardinality
rapidly
specically
probability
shall
contribution
rapid
feasible
vertex
quantity
claim
2d
coordinate
move
ng
edge
ratio
conditioning
complications
periodicity
dimension
vectors
rearranging
symmetrically
jsj
enumeration
sign
truncation
bounded
geometric
bg
spread
delete
onto
segment
kg
encoding
bottlenecks
plugging
uniformly
holding
converges
solutions
monte
bn
capacity
sketch
trick
hall
ingredient
intermediate
k1
jv
nothing
dierence
dimensional
variation
nonetheless
polynomially
probabilities
goodness
stay
i2y
diaconis
i2is
xand
jxy
xwith
9505448
2cm
9820951
i2xy
uctuate
ysimultaneously
truncations
contruct
6dc
1do
1776
permution
deceptively
9873086
3dc
esh
permanents
34d
persi
i2l
steinitz
xy
index
likelihood
email
geometrically
cubes
signs
interval
carlo
almost uniform
balanced almost
uniform permutation
random walk
mixing time
uniform permutations
the ow
the mixing
walk on
ow f
from x
knapsack problem
permutation on
the knapsack
a balanced
p2 z
the weights
a permutation
is balanced
a ow
weights fw
to y
balanced permutation
pr unif
i g
stage 2
balanced with
permutation 2
z 0x
fw be
let fw
poly n
fw i
ow along
1 knapsack
z 0
multicommodity ow
z w
z k
good ow
through z
d balanced
almost uniformity
balance property
balance condition
fpras for
ratio case
bounded ratio
ow from
the balance
random permutation
x to
p d
1 balanced
2 sm
e p2
every k
x y
strongly balanced
ow carrying
ik ik
symmetric random
an fpras
rapidly mixing
index order
f z
pair x
of items
y 1
of ow
1g n
uniform distribution
our earlier
q 1
2 uniform
ow we
cm 1
uniformity property
the uniform
weights of
walk is
permutations we
of weights
feasible solutions
bound the
the bounded
i lie
our ow
encoding z
rapid mixing
wx wy
i2x a
computing j
edge z
stage 1
partial sums
balanced for
of hyperplanes
g q
the hypercube
x 1
o n
the path
u a
not full
xed number
this immediately
j k
the random
in index
weights with
in sm
unit ow
cube f0
k 1
path from
move to
on g
bounded above
variation distance
balanced if
arbitrary weights
permutation in
almost uniformly
a r
f0 1g
1 m
permutation the
ow is
pairs x
in stage
range 1
solutions to
the proof
elements of
r d
k m
element from
a j
c 0
the items
weights a
of vertices
multiple hyperplanes
0x m
true element
permutation if
processing random
knapsack solutions
fig if
m wx
the prw
knapsack capacity
though see
m uniform
onto v
balanced permutations
rst q
symmetric dierence
satisfy 25
as subsets
prw for
interleave 1
arbitrary vertices
carrying path
padded sequence
wy k
strongly cm
given edge
hypercube f0
1 vectors
2 balanced
0 1
items in
dimension d
the event
good if
x fig
the remark
vertices x
weights in
l f
the sequence
constant c
a uniform
let 1
bound of
constant b
the hyperplane
of balanced
permutation is
y will
for su
let be
su ciently
r from
the strong
1 j
at most
d m
balanced almost uniform
almost uniform permutation
almost uniform permutations
the mixing time
random walk on
a balanced almost
x to y
from x to
u a r
balanced with respect
mixing time of
ow from x
uniform permutation on
let fw be
0 1 knapsack
fw i g
path from x
bounded ratio case
i g q
e p2 z
the bounded ratio
weights fw i
a good ow
the random walk
the uniform distribution
for every k
walk on the
walk on g
the weights fw
a r from
fw be a
range 1 b
cm 1 2
an fpras for
permutation 2 sm
the balance property
symmetric random walk
f0 1g n
1 knapsack problem
f i g
set of weights
a permutation on
1 2 uniform
g q 1
in r d
of the weights
of the items
i lie in
the ow f
fpras for computing
encoding z 0
in index order
element from h
knapsack problem the
j k 1
edge z w
to x fig
move to x
bound the ow
for computing j
of vertices x
ik ik ik
a i lie
with 1 k
such a permutation
theorem 2 1
the weights of
the 0 1
is bounded above
the range 1
the partial sums
1 to y
the pre processing
weights a i
cube f0 1g
c 0 d
of the hypercube
of the random
lie in the
pair of vertices
number of items
permutation on the
z k 1
of solutions to
an almost uniform
of o n
an element from
pair x y
the one dimensional
along the path
of feasible solutions
feasible solutions to
theorem 5 2
theorem 3 3
the general case
let 1 be
theorem 6 3
let x y
xed number of
the initial segment
to y in
wy k 2
which is c
number of hyperplanes
construction of balanced
z 0x m
permutation in sm
uniform permutation of
sm is balanced
ow along any
the knapsack capacity
chosen u a
2 sm is
wx wy k
poly n j
to the knapsack
the rst q
pre processing random
stage 2 paths
unit ow along
multicommodity ow f
k 2 z
is rapidly mixing
balance property of
unit of ow
0x m wx
contribution to f
the ow along
m wx wy
appear with a
strongly cm 1
arbitrary vertices of
items in s
every k with
not satisfy 25
interleave 1 and
from e p2
permutation on which
0 d balanced
of items from
k with 1
the prw for
ciently large m
1 let fw
almost uniformity of
f z from
of ow from
c d balanced
items from x
uniformity condition 2
2 uniform permutation
a permutation 2
all the ow
to y will
n items have
the encoding z
rst q 1
of balanced almost
the hypercube f0
the almost uniformity
0 1 vectors
computing j in
completely specied by
the knapsack problem
balanced if for
stages 1 and
of an fpras
random permutation in
q 1 intervals
the pair x
strongly balanced permutation
mixing time is
sequence in 19
ow carrying path
hypercube f0 1g
processing random walk
on the mixing
some constant b
and l f
the stage 2
uniform permutation if
along any edge
where in the
uniform distribution over
a random permutation
for su ciently
bounded above by
to the uniform
the items in
2 1 to
weight of x
to the weights
z k z
see the remark
is balanced with
the variation distance
is balanced if
exp 2 2
uniform random permutation
a multicommodity ow

corpus/krapavin2000-test/1035752.txt
cgss
cgs
poss
db
pb
phi
hcgs
inst
hb
minstate
happened
monitor
possconjalg
clocks
initstates
lattice
detection
detecting
events
predicates
timestamps
clock
sublattice
modalities
fromentin
makesc
event
occurred
endif
synchronization
cohrnt
alagar
scgss
raynal
marzullo
waldecker
venkatesan
predicate
queues
pr
jcgs
ts1
head2
scgs
conjunctive
satellite
ideals
definitely
lock
advancing
leases
orderings
timers
garg
records
timestamp
ts2
hev
d4
coherence
heads
iff
concurrent
ordering
cooper
record
priority
timestamped
hs
worst
invariants
held
properly
modality
j2
queue
head
ev
causal
cached
succ
idx
stoller
j1
unstable
satisfying
piggybacking
indiana
synchronized
endwhile
asynchronous
violations
informally
overlapped
1e
depth
monitoring
ideal
ptri
lambdaptr
dce
extractmin
rof
1pb
depthfirstsearch
ts3
getmin
truthify
en
consistent
ne
hk
maximal
interval
message
detect
underlies
2s
immediate
ntp
consis
oei
osf
expires
receive
i2
predecessors
waits
pred
sublattices
gs
i1
wise
detected
uncertainty
ptr
lifetime
meanings
removes
loop
protocol
minimal
atomic
file
computations
tm
satisfies
strongly
received
successor
nfs
falsify
debugging
executions
observers
tolerant
transaction
overlap
maintain
interprocess
oe
server
channel
suffices
expanding
returns
1s
processes
global
disjunct
irreflexive
epsilon
sends
advance
send
exploration
started
lamport
constituent
messages
mu
inevitable
adapted
synchronizing
log
fragment
pairwise
barrier
commits
calls
receiving
asymptotic
2e
hi
timeout
tackle
optimizations
reflexive
tens
inform
local states
of cgss
local state
global state
happened before
the monitor
poss db
process i
computation c
satisfying phi
poss hb
state g
the lattice
a computation
for detecting
initial cgs
case time
global states
cgs db
detecting poss
a cgs
clock synchronization
detection algorithms
each process
time complexity
pr s
on happened
of cgs
occurred before
predicates in
in distributed
computation satisfies
hcgs pb
cgs pb
detection of
of global
lattice of
global predicates
fromentin and
inst phi
between clocks
satisfies poss
possconjalg true
db c
a global
satellite data
q i
and raynal
partial ordering
distributed systems
head q
and venkatesan
and waldecker
hcgs c
garg and
and satellite
alagar and
the cgs
worst case
line detection
of events
o n
event e
is o
detecting global
record with
db and
distributed computations
detection based
g i
the worst
depth first
from process
of process
before relation
of poss
hb and
interval timestamp
wise total
properly hb
raynal s
the happened
maintain invariants
o d4
add records
d4 e
detecting inst
to minstate
db phi
head2 q
cgs g
empty p
process wise
jcgs db
state satisfying
the heads
heads of
first search
time clocks
a local
g 0
non empty
and marzullo
key c
predicate detection
o ne
c 1
n e
records for
log n
a process
events that
on events
other records
one event
priority queues
the timestamps
o 3
with key
error between
initstates g
minimal increase
cgs satisfying
modalities based
hev c
cgss that
cgss in
pb is
overlapped in
immediate successor
fixed bound
predicate phi
timestamped local
invariants j1
lattice hcgs
of hcgs
total partial
interval timestamps
receive events
ne local
cgss vs
inst is
possibly occurred
strongly concurrent
minstate is
ev c
last local
the cgss
e cgss
hcgs db
of hev
minstate s
phi iff
e occurred
process names
monitor waits
cooper and
before s
one process
w c
ordering on
e 2
queues are
e 1
local computation
unique minimal
db is
events and
takes o
p 2
every event
g is
c i
real time
a record
the local
pb c
monitor can
every maximal
conjunctive predicates
maximal path
advancing one
lock by
0 pr
phi then
concurrent with
state s
p 1
7 s
state of
are o
complexity analysis
the detection
process j
coherence protocol
c satisfies
unstable predicates
g 2
phi and
a lock
global state g
a global state
case time complexity
worst case time
predicates in distributed
the initial cgs
number of cgss
lattice of cgss
each process i
a computation c
on happened before
for detecting poss
local state of
the lattice of
algorithms for detecting
based on happened
algorithm for detecting
for each process
a local state
to the monitor
a computation satisfies
fromentin and raynal
state satisfying phi
global state satisfying
state g is
time complexity of
detection of global
the worst case
of global states
of the lattice
local state s
hcgs c i
alagar and venkatesan
poss db and
and satellite data
error between clocks
o 3 n
on line detection
detecting poss db
garg and waldecker
of process i
detection based on
in distributed systems
depth first search
heads of the
so the worst
p 1 and
of local states
and p 2
the heads of
o d4 e
with key c
computation satisfies poss
2 to maintain
poss db phi
for detecting inst
real time clocks
state of process
non empty p
each local state
no other records
head q i
process i such
process wise total
contains a record
of cgs pb
from process i
record with key
and raynal s
log n e
to maintain invariants
the happened before
cgs db c
satellite data i
add records for
definition of cgs
contains no other
1 and p
p 2 to
i is non
cooper and marzullo
the global state
the local state
happened before relation
the local states
contained in every
the error between
local state is
there are o
a record with
of events that
in distributed computations
cgs pb c
i and satellite
wise total partial
path of hcgs
head2 q j
local states in
pr s 7
process by one
quality of clock
satisfying phi and
cgs satisfying phi
o ne local
the monitor can
every maximal path
a fixed bound
a minimal increase
overlapped in time
the last local
modalities based on
in every maximal
of cgs db
of hev c
0 pr s
s 7 s
ne local states
advancing one process
of cgss vs
the monitor waits
the lattice hcgs
non empty queues
and receive events
for every event
satisfies poss db
computation c 1
poss hb and
collection of local
maximal path of
yields a cgs
g 0 pr
empty queues are
records for i
consistent global states
total partial ordering
by one event
last local state
possibly occurred before
an immediate successor
q i is
that q i
q i and
algorithm in figure
to p 1
partial ordering on
for i to
of clock synchronization
one process by
global predicates in
every event e
while loop in
c 1 s
cost of all
the while loop
total cost of
unstable predicates in
in the lattice
of global predicates
in distributed programs
the total cost
local states and
the non empty
is non empty
s algorithm for
loop in figure
time complexity is
such that q
ideals of hev
is o 3
the cgs returned
and waldecker 13
is o en
a cgs satisfying
linear in e
the detection algorithms
ordering on events
ts1 and ts2
on ev c
cgss vs and
invariants j1 and
a local computation
detecting poss hb
is o jcgs
p 1 contains
poss hb phi
predicate of interest
data i p
by possconjalg true
then the monitor
for detecting properly
definitely occurred before
local state it
inter event times
states in g
and w c
error in clock
to detect phi
a cgs g
is o d4
priority queue p

corpus/krapavin2000-test/1035755.txt
token
processor
superstabilizing
superstabilization
legitimate
registers
fault
protocol
passage
circulation
stabilizing
stabilization
register
latent
mutex
transient
exclusion
faults
ring
predicate
mutual
unidirectional
rounds
lc
masking
round
legitimacy
processors
holders
minor
protocols
oe
faulty
bidirectional
critical
illegitimate
holder
1w1r
writes
counter
nonmasking
convergence
corrupt
circulate
s4
segment
counters
circulates
tokens
tolerance
waiting
dijkstra
correcting
cycle
ag93
dh95
inflicted
spliced
fifi
s8
s6
unidirectionally
t7
latency
passing
handshake
ij
reconfigurations
gp93
gghp96
trval
detectably
7n
corrective
ffff
d74
ukmf97
mask
recovery
impossibility
3n
s5
2n
reads
interrupts
reading
ffi
splicing
writer
correction
lw
exceptional
fffi
read
infinitely
fields
containment
severe
self
atomic
tolerant
fiff
hive
s12
s3
holding
t13
corrupts
toggles
s9
t11
multireader
spurious
fl
safety
subsegment
supervisor
fi
internal
major
sequel
program
refinement
simultaneous
strategy
appendix
executes
specifies
optimum
history
s7
multivalued
contradiction
corruption
regular
segments
safe
execute
concatenation
tolerances
reactive
waits
lemma
layered
subsequent
detectable
reconfiguration
worst
injected
lg
observes
gamma
located
closure
contradicts
pr
ff
differs
encryption
stabilize
passed
asynchronously
liveness
subsection
understood
statements
gamma1
voting
quantification
dummy
propagate
specification
unidirec
eiichiro
failstop
toshimitsu
v94
enabledness
stabiliz
masuzawa
s19
invalidly
t17
dim93
kps97
crd
s14
s6a
illegitimacy
dummies
s15
affair
n90
superstabiliza
bilizing
cw97
colocated
1w2r
underscored
t16
processor i
processor local
local fault
legitimate state
passage predicate
critical section
token circulation
1 latent
mutual exclusion
minor token
a token
the protocol
a processor
major token
a legitimate
protocol is
transient fault
1 faulty
superstabilization time
local faults
state oe
protocol of
latent protocol
the mutex
exclusion protocol
a protocol
program counter
faulty state
is superstabilizing
processor zero
the token
transient faults
token passing
superstabilizing protocol
token holders
token holder
mutex passage
of processor
a fault
each processor
is stabilizing
perform critical
linear round
output registers
the ring
a transient
a computation
stabilization time
waiting strategy
input registers
superstabilizing with
fault can
processor j
program counters
internal variables
stabilizing mutual
for token
n latent
for processor
computation starting
r ij
fault and
stabilizing with
the passage
reading model
state reading
of registers
i 1
the critical
c variable
computation segment
a superstabilizing
token value
minor tokens
superstabilizing mutual
register protocol
of stabilization
superstabilizing protocols
1 superstabilization
legitimate states
the fault
by processor
protocol for
o 1
processor p
processor step
of token
the processor
token is
registers are
s program
of figure
1 rounds
exclusion in
two registers
token values
a passage
circulation is
during convergence
mutex protocol
of superstabilizing
bidirectional protocol
dijkstra s
a register
ring of
fault masking
fault is
the major
i i
local state
one processor
register r
i writes
and registers
two processors
the state
r i
appendix for
that processor
state in
self stabilizing
fault tolerance
s protocol
this protocol
following a
has o
some state
r p
steps of
of superstabilization
1w1r registers
correcting strategy
2n register
latent unidirectional
n register
one register
round zero
spliced corrupt
a spliced
corrupt state
severe transient
are token
latent and
q ffi
fault of
an illegitimate
a stabilizing
of mutual
cycle of
a ring
a 1
registers of
gamma 1
fault the
for proof
a cycle
oe 0
masking or
k state
masking fault
registers that
handshake mechanism
token of
token circulates
fault at
its critical
some processor
from processor
register is
round is
counter is
starting from
i s
a bidirectional
token and
unidirectional ring
each register
the minor
stabilizing protocols
lc is
the protocols
a waiting
see appendix
its input
with o
6 0
of processors
state the
history variables
of lc
self stabilization
i 6
by contradiction
global state
o n
state is
a state
specifies that
s output
protocol in
processor local fault
a processor local
a legitimate state
of processor i
processor local faults
protocol of figure
the major token
mutual exclusion protocol
1 faulty state
the protocol of
a 1 faulty
the mutex passage
mutex passage predicate
i i 1
the critical section
a transient fault
perform critical section
1 latent protocol
r i i
a 1 latent
is superstabilizing with
the passage predicate
each processor i
its input registers
a token holder
stabilizing mutual exclusion
processor i 1
is stabilizing with
the state reading
computation starting from
state reading model
the program counter
superstabilizing mutual exclusion
local fault can
1 superstabilization time
see appendix for
superstabilizing with respect
s program counter
o 1 superstabilization
appendix for proof
a protocol is
mutual exclusion in
a passage predicate
token circulation is
for processor i
writes to r
processor i is
legitimate state the
s output registers
protocol is superstabilizing
i s program
a critical section
of mutual exclusion
the protocol is
stabilizing with respect
in a ring
a waiting strategy
problem of mutual
ring of processors
i 6 0
of a protocol
number of registers
computation in which
a superstabilizing protocol
by processor i
2n register protocol
are token holders
a computation segment
register r ij
program counter is
the output registers
exclusion in a
protocol is optimal
the waiting strategy
local fault and
fault of type
a spliced corrupt
legitimate state is
state of processor
output registers of
for processor zero
a fault of
protocol of section
in a legitimate
from processor i
for token circulation
at state oe
processor i to
spliced corrupt state
legitimate state oe
1 latent unidirectional
to the mutex
following a processor
a linear round
of transient faults
state in l
has o n
for the protocol
of figure 1
from a 1
for a processor
proof by contradiction
from a legitimate
is a token
of a token
fault is not
its critical section
after a fault
o 1 rounds
by a fault
in the ring
local state of
i gamma 1
with respect to
state so that
for each processor
segment is a
at some state
for this protocol
in a computation
respect to p
a cycle of
of i s
the superstabilizing protocol
and program counters
the n register
a bidirectional protocol
for legitimacy of
fields r ij
for proof theorem
processor i has
cycle of processor
an illegitimate state
and minor token
any legitimate state
stronger passage predicate
regular 1 latent
processors are token
set the program
and internal variables
token passing registers
minor tokens and
the processor register
impossible to prevent
legitimate state in
after a processor
no two processors
protocol for processor
that processor i
self stabilizing mutual
exclusion protocol is
program counters and
passing of a
n latent protocol
minor token circulation
a complete round
the processor inflicted
passage predicate for
dijkstra s protocol
critical section is
within o 1
at a critical
consists of processor
that a transient
the register it
of token passing
j its input
transient fault and
registers of processor
a stronger passage
output registers are
and read by
local fault is
protocol is stabilizing
a minimal round
uses a waiting
token from processor
its minor token
passed from i
token holder the
complete token circulation
a minor token
the correcting strategy
detectably corrupt at
the linear round
passage predicate is
token circulation to
the protocol for
the local state
to r i
major and minor
steps of p
a complete token
arbitrary initial state
which the token
a fault we
token circulation in
fault masking or
some state in
a unidirectional ring

corpus/krapavin2000-test/1035756.txt
honest
witness
3t
corrupt
wan
deliver
protocol
message
sender
peers
conflicting
processes
regime
signatures
messages
byzantine
witnesses
faultless
multicast
seq
signed
delivered
echo
av
2t
exchanges
failures
quorum
agreement
participating
sends
regimes
recovery
active
authenticated
secure
quorums
cryptographic
rampart
members
faulty
timeout
resiliency
reliable
broadcast
delivery
acknowledgments
keys
intersect
mes
3c
member
protocols
adversary
signature
malicious
acknowledgment
dissemination
delivers
availability
contents
intruder
md5
reiter
digital
participants
consistency
failure
behalf
integrity
receives
resorted
sages
executes
infinity
overhead
reliability
cnt
collude
generals
validations
probabilistic
asynchronous
payload
malkhi
deliveries
intolerable
public
incurs
consensus
sign
borrows
relaxing
probe
sage
acknowledges
send
cryptosystems
private
scenarios
guarantee
attack
deviate
incurring
period
sent
replies
probes
probability
impossibility
bringing
tolerated
likewise
received
ack
destination
reply
peer
safety
albeit
cooperation
hashes
deliv
crypt
deliverable
haber
png
reprint
toueg
originators
resale
randomizes
copyrighted
inition
icdcs
negligable
ascertains
idirectly
yourself
mr97
fraction
forming
goes
despite
prohibitive
opportunity
eventually
promotional
inconsistently
myampersandohgr
sult
copyright
rupt
designating
authenticity
authenticates
material
acknowledge
exchanged
randomly
effectively
reverts
dahlia
disclose
acknowledging
wool
transis
avishai
impersonate
vanishingly
signing
behaving
digest
passed
valid
communicating
agree
collaborating
attributable
unsolvable
weakened
authentic
cryptographically
stamping
secondly
sending
incurred
generations
corrupting
wright
forge
avail
998
signa
rebecca
parame
threshold
distribute
concurrently
attempts
witness m
deliver m
honest processes
active t
p i
sender m
wan deliver
the 3t
t protocol
witness set
3t protocol
honest process
an honest
conflicting messages
seq m
p j
message exchanges
corrupt processes
a message
message m
performs wan
the active
the honest
multicast m
in witness
wan multicast
conflicting message
honest member
if sender
two honest
the protocol
in faultless
recovery regime
executes wan
failure regime
witness sets
digital signatures
participating in
a signed
signed acknowledgment
e protocol
acknowledgments for
3t 1
regime and
no failure
i receives
m p
process p
of processes
the witness
i performs
reliable broadcast
previously received
signatures and
a witness
when p
is honest
a corrupt
timeout period
to p
let p
process participating
agreement on
from 2t
peers h
witnesses and
honest members
1 3c
signed acknowledgments
2t 1
faultless scenarios
authenticated message
valid acknowledgments
processes may
no conflicting
the no
m a
the recovery
witnesses of
processes participating
the witnesses
message was
m to
m 0
reliable multicast
protocol if
of corrupt
acknowledgments from
exchanges with
quorum systems
m goes
was previously
every message
i sends
d n
i executes
secure reliable
consistency requirement
m and
m executed
sends av
integrity self
executed wan
eventually p
peers i
t processes
previously delivered
i deliver
their peers
message av
probabilistic agreement
3t deliver
delivered p
delivered the
member p
k authenticated
as seq
two regimes
obtain signed
av deliver
to wan
self delivery
corrupt process
period has
corrupt witness
echo protocol
receives a
and availability
multicast protocol
requirement to
j be
if p
process to
the overhead
then p
the echo
for conflicting
overhead in
m from
be delivered
p h
m at
processes are
of valid
a timeout
then sends
honest then
the rampart
by honest
limit as
the byzantine
a contains
the consistency
of sender
contents in
of peers
passed and
different messages
have obtained
be two
processes is
a process
and message
to infinity
must have
message complexity
theta k
a recovery
same message
m then
to deliver
obtained a
the adversary
the message
relaxing the
and signature
goes to
for m
of failures
which processes
case scenario
the probability
m the
every process
the system
theorem 4
protocol in
the e
message it
has passed
failures are
choice of
additionally theta
of 3t
systems total
set witness
forming agreement
message 3t
protocol execution
sends 3t
active t protocol
the active t
the 3t protocol
an honest process
wan deliver m
let p i
performs wan deliver
a message m
in witness m
two honest processes
wan multicast m
if sender m
participating in the
p i receives
when p i
the no failure
deliver m a
be an honest
j be two
no failure regime
be two honest
i receives a
a witness set
m p i
p j be
was previously received
in the 3t
the e protocol
i performs wan
message was previously
protocol if p
no conflicting message
the honest processes
a signed acknowledgment
the recovery regime
conflicting message was
receives a message
if p i
p i performs
p i sends
and p j
of the honest
i and p
for a process
m is honest
sends a signed
of valid acknowledgments
of corrupt processes
i executes wan
at an honest
authenticated message exchanges
and message exchanges
sender m is
to deliver m
consistency requirement to
seq m goes
process participating in
honest process participating
acknowledgments for m
must have obtained
message exchanges with
honest processes participating
obtained a set
for m from
process p i
p i to
to p j
p i executes
have obtained a
of d n
the consistency requirement
processes participating in
in the active
goes to infinity
m a to
a timeout period
at the limit
m goes to
for p i
p i and
deliver m p
that a contains
signatures and message
p 2 when
corrupt witness set
to obtain signed
m a such
the honest members
deliver m then
limit as seq
from 2t 1
in faultless scenarios
case of failures
the echo protocol
then only if
executes wan deliver
m at most
relaxing the consistency
and if sender
deliver m at
delivered the same
executed wan multicast
i to deliver
of peers h
of sender m
has passed and
honest members of
3t deliver m
a message av
p i deliver
integrity self delivery
3t protocol if
a corrupt process
av deliver m
previously delivered p
gamma 1 3c
theta k authenticated
only if sender
obtain signed acknowledgments
i deliver a
as seq m
k authenticated message
honest member p
witness m and
that no conflicting
recovery regime and
period has passed
member p h
requirement to a
once and if
sender m executed
if a timeout
a of valid
honest processes are
honest then only
2 when p
not previously delivered
m executed wan
timeout period has
valid acknowledgments for
delivered p i
a process p
set of d
p i be
p to obtain
i must have
of a witness
a to p
was not previously
b n gamma
is honest then
secure reliable multicast
3 when p
i be an
of the messages
the witness set
p i does
to p to
for every message
deliver a message
the limit as
a set a
most once and
taken at the
p i must
from p j
reliable multicast protocol
to be delivered
the overhead in
then p i
the same message
known to have
to p 2
m to the
set a of
obtain a set
worst case scenario
set of processes
of the active
the system may
the choice of
agreement on message
how relaxing the
a resiliency threshold
witness m witness
p executes wan
of tolerated failures
same message i
regime and additionally
deliver m 0
and additionally theta
n signatures and
of a corrupt
p j such
is taken assuming
j deliver m
algorithms for asynchronous
least one honest
witnesses of both
of the witnesses

corpus/krapavin2000-test/1035757.txt
checkpoint
checkpoints
clock
checkpointing
forced
causal
protocol
useless
lc
cl
lamport
ckpt
netzer
sent
mostefaoui
ck
raynal
rollback
irisa
elary
message
prevention
timestamp
domino
protocols
array
enddo
manivannan
mcj
induced
delivery
8k
pk
timestamps
recovery
s2
reception
consistent
iff
s1
determination
clocks
orphan
receives
unstable
detection
p4
p6
sending
send
cycle
snapshots
deliver
messages
manages
event
singhal
breakpoints
predicates
communication
predicate
p5
managed
quasi
processes
hlary
trackability
mck
docase
ik
contradicts
sends
computations
ffl
min
initialization
booleans
piggyback
piggybacks
oe
false
boolean
synchronous
path
events
received
paths
z
piggybacking
p8
timestamped
timestamping
breakpoint
prevent
precedes
brought
depicted
tocol
russell
directs
coordination
remind
safe
pattern
mobile
family
xu
arrays
sender
save
michel
coordinated
endif
stable
arrives
25th
p3
max
belongs
delta
happened
synchronize
appended
inconsistent
delivering
conjunctions
enddocase
manitoba
emmanuelle
jichiang
leen
zcf
piggybacked
anceaume
vitenberg
coasting
netxer
agbaria
erlier
redrawn
rdt
gyung
winnipeg
cycles
interval
invariant
asynchronous
fc
indicated
previuosly
incrementation
russel
subcondition
attiya
intial
764
executes
formation
reset
updates
snapshot
tradeoff
statements
concatenation
propagation
arriving
meaning
pointing
classical
p1
adnan
occurences
youn
tsai
withdrawn
appends
sharpening
hagit
characterizes
proves
simplications
genericity
hee
fourteenth
s0
examine
logical
arrival
plications
directing
p7
hypothesis
channels
roy
encompasses
consequently
past
passing
755
luo
z path
local checkpoint
local checkpoints
checkpoint is
clock i
p i
causal z
forced checkpoints
i x
communication induced
global checkpoint
forced checkpoint
a checkpoint
to i
i k
c i
induced checkpointing
take checkpoint
checkpoint c
consistent global
k z
useless checkpoints
cl i
c k
checkpoints in
z cycle
m clock
sent to
distributed computations
the protocol
a z
global checkpoints
checkpointing protocols
min to
a forced
z pattern
process p
message m
prevention of
based prevention
communication based
z paths
taken i
m raynal
a mostefaoui
lc i
each process
a causal
in distributed
clock j
r netzer
irisa communication
h elary
mostefaoui r
netzer m
checkpoints and
elary a
ck z
of useless
by p
m 1
a message
local state
condition c
checkpointing protocol
array clock
ckpt i
checkpoints are
basic checkpoints
p k
j m
proposed protocol
c j
j y
lamport clock
procedure take
last checkpoint
checkpoint the
p j
i i
m h
detection of
the z
of forced
of local
control information
send m
boolean array
is useless
taken by
checkpoints is
checkpoints to
quasi synchronous
checkpoint when
to pk
8k do
sent i
to c
x 1
take a
receives m
of lc
rollback recovery
to p
a consistent
checkpoint of
non causal
a local
z t
protocol is
from c
between c
state oe
local clock
no local
this protocol
oe i
have c
determination of
1 n
array sent
checkpoint taken
lamport clocks
checkpoints the
checkpoint to
path m
as sent
z cycles
checkpoint forced
checkpoints c
m sent
max ck
checkpoint sends
clock lc
greater i
of checkpoints
after s1
c 1
is received
from p
a process
holds after
to take
m 2
unstable properties
clock k
2 sent
m lc
i 1
the array
it follows
sent by
i to
after c
useless the
current local
sends a
the delivery
pattern m
before c
when m
follows that
path from
of stable
distributed computation
m 0
checkpoints taken
if sent
checkpoint interval
checkpoint between
domino free
case clock
lamport timestamp
false enddo
basic checkpoint
do sent
free communication
array greater
no checkpoint
control variables
useless checkpoint
safe strategy
the lamport
or forced
first checkpoint
hypothesis ffl
no z
checkpoints that
rollback propagation
prevent useless
get max
basic or
i has
k has
at p
i false
data structures
lamport s
protocol the
of m
c i x
sent to i
to i k
c k z
communication induced checkpointing
causal z path
i x 1
min to i
a forced checkpoint
a local checkpoint
consistent global checkpoint
cl i k
c j y
local checkpoint c
process p i
induced checkpointing protocols
clock i i
of useless checkpoints
of local checkpoints
useless checkpoints in
a causal z
i 1 n
in distributed computations
by p i
checkpoint c i
checkpoints in distributed
prevention of useless
a z path
communication based prevention
based prevention of
take a forced
h elary a
m h elary
z path from
a mostefaoui r
m clock j
netzer m raynal
mostefaoui r netzer
irisa communication based
r netzer m
elary a mostefaoui
j m h
a consistent global
p i to
consistent global checkpoints
array clock i
the proposed protocol
a z cycle
number of forced
k z t
of the protocol
i x and
of forced checkpoints
induced checkpointing protocol
local checkpoint is
procedure take checkpoint
a z pattern
to p k
to take a
to i 1
p i has
when m 1
checkpoint is a
each process p
to c i
detection of stable
sent by p
state oe i
no local checkpoint
the z path
forced checkpoints to
take checkpoint is
path from c
checkpoint is useless
checkpoint is taken
i k has
between c i
forced checkpoint when
set of local
from p j
i k is
to p i
a message m
taken by p
sends a message
x and c
is a z
by p j
at p i
and c i
when it receives
message m sent
take a checkpoint
as sent to
a global checkpoint
oe i s
i to take
save the current
take checkpoint sends
checkpoint forced checkpoint
the z pattern
checkpoint of p
clock i k
message to pk
non causal z
z path m
m clock k
z pattern m
z path is
checkpoints to ensure
causal z paths
checkpoint taken by
checkpoints are taken
is a causal
checkpoint sends a
j m clock
then take checkpoint
take checkpoint forced
a boolean array
global checkpoint is
array sent to
m sent by
local state oe
it follows that
we have c
of p k
condition c 1
current local state
clock i is
1 is received
the current local
has to take
a distributed computation
contradicts the hypothesis
of a consistent
described in figure
m 1 is
receives a message
i i x
c i 2
is received by
the delivery of
c k 2
when p i
checkpoint between c
have cl i
a basic checkpoint
after c i
global checkpoint to
the last checkpoint
oe i 0
determination of consistent
checkpointing protocol that
a checkpoint between
i i false
when it sends
p i between
ffl when it
clock j m
taken a checkpoint
m 1 t
taken i i
local state with
m 2 sent
local checkpoints are
forced checkpoints are
we get max
z path that
condition c 0
z ck z
a communication induced
b h is
ffl case clock
for consistent global
local checkpoints is
known by p
the first checkpoint
to prevent useless
prevent useless checkpoints
domino free communication
i between c
free communication induced
distributed computations a
clock lc i
of communication induced
checkpoint to which
takes a basic
checkpoint when it
checkpoints c i
value of lc
array greater i
from c j
brought to p
boolean array greater
the local checkpoint
t cl i
the array clock
a useless checkpoint
of basic checkpoints
the hypothesis ffl

corpus/krapavin2000-test/1035761.txt
mut
protocols
protocol
synch
synchronizing
inhibiting
multifunction
composite
initiate
action
ff
inhibit
receptions
leader
token
en
fi
initiation
recd
actions
composition
ext
traverse
invariant
infer
initiator
unspecified
connect
superimposition
ch
liveness
enter
invariants
priority
exclusion
inhibited
site
para
initiated
message
ef
concurrently
channel
election
inhibits
mutual
establishment
initiators
multiphase
constraint
init
connection
sdata
item
disconnection
matching
receiving
credit
interleaved
sent
gamma
inferred
sites
req
sender
sends
rec
enable
ready
traversal
constraints
structuring
subproblems
avail
channels
bool
receivers
compositional
deadlock
receiver
processes
falserequest
fffg
raverse
fenter
rdata
rtoken
conflict
lemma
spend
guards
restrictions
initialization
inference
invalidate
enabled
ffig
subfunctions
terminates
messages
decomposed
specifying
safety
designing
pn
var
fff
combine
shared
active
superimposed
guard
false
inhibition
b2
formalisms
executing
terminating
informally
incremented
phased
send
corollary
rules
combining
subtask
synchronized
component
head
statement
s3
sequential
reachable
fusing
belongs
ri
transfer
dominates
imposing
event
incrementing
elect
communicating
executed
ab
wherein
formalism
arg
request
execution
flow
reflects
belonging
critical
win
snapshots
formulas
sending
l1
mess
synchronzing
recr
truertoken
trueenter
folowing
fexit
falsestoken
reinitiate
trueelect
contentsm
lict
invaraint
interactions
involve
specify
discipline
modular
propositions
check
contents
permission
nized
subfunction
frequest
intial
interacting
imposed
snapshot
grant
items
id
projection
iterative
s1
loop
structured
circulated
spective
disciplined
delivery
component protocols
composite protocol
mut 1
invariant of
synch p
an invariant
p q
p i
en a
and q
the composite
initiate p
ff fi
synchronizing constraint
p and
q i
from unspecified
multifunction protocols
connect 1
unspecified receptions
f low
has priority
the component
initiation of
the synchronizing
of p
fi in
check 1
ch i
inhibiting constraint
synchronizing constraints
sent 1
enter 1
a protocol
priority over
process mutual
traverse 1
inhibit p
i j
hold 1
in p
the constraints
lemma 4
then ff
ef p
state g
liveness properties
the inhibiting
three process
check i
inhibiting constraints
enable p
are matching
of mut
and mut
if p
protocols we
free from
execution of
to infer
if ff
mutual exclusion
the initiation
q then
over q
1 3
the protocol
data item
site i
composition using
to synch
para list
traverse 2
leader 1
active p
connection establishment
of multifunction
2 ef
terminates q
in mut
ext i
protocol can
1 2
q or
action a
of protocols
of r
protocols can
exclusion protocol
protocols which
sequential composition
action in
inference rules
of constraints
by combining
in r
action of
loop statement
an interleaved
parallel composition
fi via
p terminates
var p
mut i
used used
functions concurrently
q conflict
then initiate
ext 1
2 synch
rec l
protocol m
composite protocols
en b
bool l
initialization action
connect 2
conflict then
true in
the token
critical section
the channel
or p
rules to
is true
and connect
election protocol
is inhibited
is free
flow control
a l
a message
and inhibiting
interleaved execution
to true
q and
p then
hold i
in i
protocol is
an action
r i
becomes true
leader election
protocol r
can infer
corollary 4
composition of
p has
and liveness
initial state
this protocol
p is
protocols a
true after
to inhibit
performs the
the initialization
by specifying
from p
using synchronizing
multifunction protocol
computation associated
gamma hold
a synchronizing
m para
of traverse
recd 1
disconnection protocol
component functions
infer safety
protocols several
n process
a multifunction
combining connect
protocol mut
constructing multiphase
matching action
i inhibits
basic computation
true active
and synch
combining mut
multiple functions
synchronizing and
ff unless
receptions then
invalidate ff
if ext
token check
token gamma
data f
active q
capture id
protocol obtained
component protocol
unless fi
true if
at site
properties of
an invariant of
the composite protocol
the component protocols
is an invariant
synch p q
mut 1 2
p and q
invariant of r
ch i j
free from unspecified
from unspecified receptions
has priority over
of the component
of p i
p i and
of the composite
ff fi in
and q i
i and q
1 2 and
process mutual exclusion
inhibit p q
p has priority
connect 1 2
priority over q
q or p
the synchronizing constraint
fi in r
invariant of p
check i j
the initiation of
is free from
hold 1 2
liveness properties of
multifunction protocols which
2 and connect
check 1 3
a composite protocol
2 ef p
invariant of mut
of mut 1
and mut 1
to synch p
rules to infer
of multifunction protocols
hold 1 3
properties of the
protocol can be
mutual exclusion protocol
execution of p
r is free
the critical section
if p and
i is an
set of constraints
of p and
protocols can be
the execution of
leader election protocol
p q and
obtained by combining
on the initiation
1 2 gamma
p q then
b 2 synch
in mut 1
enable p i
over q or
and q conflict
the inhibiting constraint
connect 2 1
p terminates q
2 synch p
1 3 g
initiate p i
q conflict then
fi in p
fi via a
of component protocols
ff fi via
then initiate p
composite protocol r
check 1 2
the synchronizing constraints
via a in
then ff fi
initiate p is
ff is true
enter 1 2
hold i j
en a l
the initialization action
2 and mut
enter 1 3
from those of
p i is
the initial state
p is an
we can infer
an interleaved execution
or p and
interleaved execution of
the loop statement
initiation of the
true in g
in the composite
1 2 3
at the head
p q is
is true in
safety and liveness
lemma lemma 4
and liveness properties
parallel composition of
is local to
synchronizing and inhibiting
mut 1 3
initialization action of
data f low
holds the token
of type m
next data item
id 1 sent
and inhibiting constraints
the disconnection protocol
set of component
mut i j
in var p
infer safety and
for constructing multiphase
two process mutual
inhibiting constraint is
and connect 2
1 sent 1
the computation associated
component protocols can
computation associated with
of ch i
two component protocols
and active p
a synchronizing constraint
unspecified receptions then
of traverse 1
variables in var
in r this
at site i
state g l
protocol obtained by
a in p
by combining connect
protocol by combining
combining mut 1
token gamma hold
a en a
terminates q or
i holds the
sent 1 2
m para list
constraint is useful
a multifunction protocol
the three process
if p terminates
and synch p
in 1 gamma
p then ff
loop statement of
or p has
initiation of p
by specifying that
fi 2 ef
combining connect 1
then in 1
en a gamma
to infer safety
ff unless fi
p i inhibits
belongs to synch
sent 1 3
capture id 1
true if ext
protocols which perform
only one of
a protocol is
from p i
one of them
1 2 true
to true after
refer to variables
composition of protocols
q is non
in state g
can be structured
message of type
performs the function
and ff fi
a data item
the head of
a l is
a compositional approach
can infer that

corpus/krapavin2000-test/1035782.txt
quorum
deliverupdate
masking
quorums
servers
client
byzantine
faulty
server
timestamp
clients
opaque
initiateupdate
load
replicated
echo
dissemination
prone
universe
executes
lam86
read
protocol
dahlia
op
serialization
o1
constructions
grid
secure
malkhi
member
nw94
failures
fail
signatures
u2q
dominated
preceding
tolerant
writer
availability
secret
fault
services
m1
public
concurrent
iff
mema
undetectably
correct
2f
intersect
exclusion
service
alvisi
m2
consensus
o2
update
reiter
failure
schneider
writes
ready
atomic
timestamps
agreement
threshold
i2i
repositories
maniatis
lidong
bazzi
giuli
benignly
rida
precede
scenarios
protocols
roussopoulos
sends
verifying
induces
receives
authority
o3
benign
hadamard
petros
busiest
rosenthal
lorenzo
fred
security
peer
reply
write
wool
dispersal
coterie
assigns
corollary
precedes
tocs
digitally
eventually
michael
consistency
digital
voting
members
certificates
authenticate
message
ltv96
ittai
mr96
bt85
echoed
cheuk
2fe
gb85
robbert
ccit88
ht88
ncommon
pw95
odlyzko
rsa78
5f
caa90
evelyn
is92
accessing
certificate
tolerate
self
baker
confidentiality
intersects
certification
validity
integrity
pierce
merritt
coteries
domination
neves
survivable
dahlin
u2u
renesse
era
bg
reader
lemma
chooses
rcd
liskov
rampart
signed
replication
authentication
rows
satisfied
nineteenth
denver
lemmata
lau
zhou
annual
mask
votes
wright
bolton
fortiori
disable
rebecca
sharing
mary
fg
date
databases
d1
variations
received
executed
propagation
naor
strategy
multicast
registers
preservation
propagating
constructible
landing
3k
rad
quorum system
quorum systems
masking quorum
v t
correct server
deliverupdate c
c v
a quorum
fail prone
prone system
write operation
a masking
faulty servers
executes deliverupdate
load of
quorum q
server executes
dissemination quorum
the quorum
echo q
q v
a correct
opaque quorum
the client
q c
initiateupdate q
preceding write
servers in
read operation
for b
server in
replicated data
write operations
of servers
correct servers
the load
some quorum
a client
a load
update q
a universe
each quorum
byzantine quorum
in q
self verifying
assigns equal
opaque masking
non dominated
a dissemination
a faulty
each server
system b
a fail
serialization of
system for
op 1
value timestamp
our quorum
update protocol
failure scenarios
quorum induces
an opaque
system q
value written
client c
the read
client to
is concurrent
op 2
concurrent with
of q
masking quorums
some serialization
highest timestamp
ready q
universe u
public key
any q
of masking
equal probability
execute deliverupdate
satisfied because
grid construction
faulty client
executes initiateupdate
correct client
last preceding
timestamp pairs
q is
dahlia malkhi
b iff
that assigns
q 2
member of
the write
correct then
it queries
operation in
fault tolerant
lemma 6
servers that
all servers
all preceding
probability to
the grid
c executed
correct member
f echo
faulty server
higher timestamp
server u
g u2q
sends echo
operations returns
faulty clients
arbitrarily faulty
intersect in
q 1
t from
the service
each member
then eventually
queries each
a strategy
strategy that
2 q
are correct
byzantine fault
k reiter
two quorums
michael k
quorum of
every correct
universe of
threshold of
corollary 4
c q
holds since
a threshold
t u
in w
of quorum
single reader
q to
client can
the system
fred b
no write
executed initiateupdate
m2 holds
mema roussopoulos
correct clients
propagation if
regular masking
load induced
q similarly
b schneider
given fail
l exclusion
validity if
quorums intersect
system over
induces a
a read
of correct
and secure
the arbitrary
t only
secret sharing
the servers
servers is
if op
correct process
byzantine failures
lorenzo alvisi
quorums q
that clients
digital signatures
the universe
a server
system 2
example 5
services that
w on
the protocol
distributed computing
an update
servers to
multi reader
is satisfied
suppose that
u g
in some
the members
operation that
variable x
the replicated
server receives
servers such
read for
c v t
quorum system for
deliverupdate c v
system for b
fail prone system
a correct server
a masking quorum
masking quorum system
q v t
masking quorum systems
a quorum system
q c v
executes deliverupdate c
correct server executes
server executes deliverupdate
prone system b
a load of
member of q
initiateupdate q v
write operation in
echo q c
a fail prone
if a correct
is a masking
dissemination quorum system
quorum system q
some quorum q
the quorum system
opaque quorum system
the read operation
byzantine quorum systems
the load of
a dissemination quorum
v t u
in some quorum
to each quorum
servers in q
strategy that assigns
that assigns equal
assigns equal probability
quorum system is
each server in
equal probability to
probability to each
quorum induces a
v t from
induces a load
update q v
opaque masking quorum
an opaque quorum
each quorum induces
server in some
is concurrent with
of a quorum
in some serialization
is non dominated
ready q c
the highest timestamp
some serialization of
for b iff
of masking quorum
the write operation
a client to
v t and
a universe u
load of the
the value written
that is concurrent
value timestamp pairs
server in q
execute deliverupdate c
operation in some
all preceding write
is a dissemination
a faulty client
last preceding write
serialization of all
is satisfied because
the last preceding
preceding write operations
quorum q to
operation in w
preceding write operation
it queries each
of all preceding
quorum systems and
executes initiateupdate q
queries each server
each member of
all servers in
intersect in at
v t to
corollary 4 2
obtain a set
the system 2
for a client
to each member
q to obtain
the failure scenarios
quorum systems that
client to obtain
concurrent with no
system over a
for a universe
then it sends
value written in
is an opaque
a faulty server
u g u2q
a correct client
members of q
write operations returns
quorum system over
v t only
our quorum systems
t u g
update protocol that
v t then
of value timestamp
system q is
set of value
f echo q
q are correct
if c executed
a strategy that
system for a
a universe of
if a server
over a universe
michael k reiter
dissemination quorum systems
value written by
in at least
read operation that
load of 1
a client c
t only if
on the system
written by the
correct servers in
x it queries
read for a
1 let b
no write operations
given fail prone
an update protocol
client to read
quorum q 2
by w on
the fail prone
t from a
with no write
pair v t
induced by w
c executed initiateupdate
quorums intersect in
of data repositories
to execute deliverupdate
of servers such
load induced by
be a fail
validity if a
then the quorum
a higher timestamp
fred b schneider
prone system for
operations returns the
executed initiateupdate q
u 2 q
byzantine fault tolerant
every correct server
correct server in
quorum systems for
arbitrarily faulty servers
v t proof
2 t c
universe u then
the grid construction
quorum systems with
sent by all
set of correct
t to each
q is a
2 lemma 6
is the load
a threshold of
by the last
a read operation
operation that is
only if c
at each server
quorum systems the
q 2 if
v t for
a server receives
q is non
v t 2
a quorum of
been sent by
u then there

corpus/krapavin2000-test/1035802.txt
latest
secondary
gossip
tertiary
automaton
stamps
automata
primary
asynchronous
events
event
stamp
sentry
prim
processes
ter
frontier
buchi
sigma
ideals
ij
labels
zielonka
ideal
synchronizations
cellular
stamping
agents
determinizing
trace
sec
synchronize
label
locally
flatest
determinization
ha
upto
word
ua
pq
concurrent
transition
inf
track
alphabet
traces
complementation
synchronization
jointly
q2p
p2a
computable
ary
frontiers
synchronizes
update
sp
recognizable
synchronous
hp
p2p
gossiping
timestamping
totally
indexed
reading
agent
heard
qp
bits
asychronous
mazurkiewicz
bmyampersanduuml
thiagarajan
infinite
meets
participating
suffices
disappears
arrays
consistently
shall
ae
fp
assign
synchronizing
knows
labelling
maintain
strings
assigned
communicating
counters
tackle
amongst
views
pairwise
decide
crucial
letter
mappings
proposition
action
counter
sg
passing
participated
constructible
combinatorics
comprehensible
reused
exchange
quadruple
theoretic
f0
causality
logic
lemma
max
bounded
sacrificing
deterministic
abbreviate
unambiguously
remarked
across
communication
induction
convenience
fix
progresses
unused
theta
correctly
belongs
val
involving
keeping
participates
languages
transitive
crash
behaved
communications
incomparable
00
fprim
p2c
gastin
mythical
describable
wolper
asnchronous
dexed
valg
trptl
fsec
sohoni
surpisingly
recedes
dispensed
madhavan
lodaya
varaibles
assimilate
milind
bacabba
fter
israeli
cbadecc
stored
feel
confusion
chi
assertions
themselves
fly
message
exchanging
optimizing
entries
hypothesis
temporal
coordination
keep
suffice
klarlund
cybernetica
chronously
reappear
narayan
safra
rq
concurrrent
mukund
synchroniza
parallels
quintuple
closure
latest p
the gossip
secondary information
latest q
gossip automaton
primary information
q r
p q
secondary p
asynchronous automata
time stamps
primary p
tertiary information
information of
the processes
sec p
prim p
p i
time stamp
events in
ter p
event latest
latest information
processes in
e u
event in
the latest
asynchronous automaton
and secondary
each process
primary and
ij p
secondary q
r sentry
q i
q e
of processes
sentry for
tertiary p
asynchronous cellular
p sec
event e
process p
e 2
primary secondary
in prim
secondary events
gossip problem
and ter
and tertiary
cellular automata
q 2
p r
r e
p event
q latest
2 secondary
an ideal
the primary
of events
processes which
secondary and
p p
an event
each event
2 sigma
e latest
locally computable
in e
the events
r i
p after
ij q
ha i
max p
all q
after reading
each q
in ter
which synchronize
latest gossip
2 ij
new event
time stamping
word u
automaton can
in primary
an r
all processes
bounded time
track of
p and
of labels
in secondary
sigma is
the tertiary
frontier pq
latest r
buchi asynchronous
reading w
trace languages
that latest
so latest
v maximum
i secondary
trace theory
maximum p
the secondary
p 2
of asynchronous
2 p
the automaton
the event
r 0
q s
p e
initial event
about q
bounded concurrent
e is
information about
about r
local transition
n bits
in p
p we
i p
automata asynchronous
secondary event
q events
r latest
s latest
p primary
zielonka s
update primary
compare primary
q event
primary q
f0 e
stamps of
pq i
p secondary
deterministic asynchronous
indexed set
arrays prim
in ij
communication sequence
recognizable trace
determinization construction
asynchronous mappings
event 0
primary events
these automata
s e
totally ordered
in i
a process
ideal i
an asynchronous
each p
the system
r 2
ideal and
synchronous communication
of p
r s
keep track
infinite traces
and latest
a event
in tertiary
p theta
on infinite
local states
our algorithm
labels are
compare and
transition relation
0 r
their primary
to primary
after u
in use
local state
for p
theta p
part in
finite set
every q
process q
take part
knows about
u is
e to
if e
using o
p can
e 0
e 1
the v
latest p q
the gossip automaton
latest q r
secondary p i
the processes in
secondary information of
latest p r
primary p i
p q i
the latest information
event latest p
p q r
primary and secondary
q 2 p
p q e
tertiary p i
processes in p
tertiary information of
and ter p
and secondary information
p sec p
an r sentry
asynchronous cellular automata
q r i
the gossip problem
prim p sec
and tertiary information
sec p and
p and ter
secondary and tertiary
primary secondary and
r e u
the secondary information
in prim p
secondary q i
information of p
for each q
q latest p
r sentry for
in primary p
e 2 secondary
primary information of
the primary information
q r e
q r s
an event e
r 2 p
the time stamps
be an ideal
processes in a
q r 2
totally ordered by
an asynchronous automaton
gossip automaton can
2 secondary p
the latest gossip
p event in
the tertiary information
events in e
set of processes
p 2 p
for all q
set of events
events in the
bounded time stamps
the time stamp
across the system
automaton can be
a 2 sigma
p i is
each process p
of the latest
p 2 a
processes which synchronize
in secondary p
e latest p
latest p p
after reading w
stored in prim
q e u
if e 2
maximum p event
the v maximum
compare and update
each q 2
is the latest
sentry for p
latest information that
of p after
of asynchronous automata
the event latest
p r i
track of the
i p i
i be an
p theta p
an ideal and
whenever a set
of the gossip
the processes which
in the system
is an r
for each p
is also present
also present in
the primary and
2 p we
of processes in
each p 2
latest information about
events are totally
the primary secondary
event in i
of time stamps
p q latest
latest q p
ideal and p
information of processes
q r 0
sec p q
stamps of the
meets the processes
v maximum p
i secondary p
frontier pq i
processes in c
has the latest
max p i
a word u
in the primary
p after reading
recognizable trace languages
p after i
primary information about
in ter p
same time stamp
secondary event latest
set p p
buchi asynchronous automata
arrays prim p
information about r
the new event
time stamps of
q event in
r 0 r
p i as
keep track of
log n bits
respect to q
a time stamp
q i in
every q 2
each event in
sets of events
the initial event
for p with
of processes which
all the processes
q 2 a
information that p
to keep track
p with respect
of each process
2 p the
automata on infinite
event in e
are totally ordered
p and q
by the induction
for every q
crucial role in
that p has
all q 2
take part in
which of them
in other words
a crucial role
with respect to
r i and
of the form
p i then
decide amongst themselves
about the primary
of recognizable trace
themselves which of
amongst themselves which
in tertiary p
p has in
q r p
processes which take
gossip problem is
event in ij
the arrays prim
stamps assigned to
corresponding events in
i about the
s primary information
to max p
a event e
deterministic asynchronous automaton

corpus/krapavin2000-test/1035804.txt
subring
subrings
leader
captured
message
capture
candidate
owner
election
candidates
messages
cap
elected
protocol
enter
capturing
sends
contest
phase
accept
node
chordal
send
spontaneously
entering
inform
blocked
waking
elect
id
announce
responded
wakes
flocchini
sent
nodes
3k
received
ack
santoro
ring
passive
paola
direction
leaders
slots
log
electing
identity
increment
declare
rings
entered
hamiltonion
roncato
nicola
transit
reach
receiving
chords
elects
captures
response
lemma
wake
identities
compete
protocols
ignores
units
receives
receive
gamma1
logically
incident
majority
alessandro
cycle
representative
networks
informs
proceeds
enters
inherits
network
edge
destination
synchronous
bits
responds
multiples
9502506
9211621
mans
moneta
synnve
sepa
kekkonen
conquest
successful
knows
distance
disjoint
asynchronous
fi
increments
negligible
arranged
rately
processors
tries
impacted
ffl
phases
behaves
largest
cept
elections
ccr
dividing
informally
attempts
announces
unaware
links
355
tolerant
ensures
reaches
awareness
multistage
leading
lemmas
simultaneously
189
eighteenth
false
379
js
declares
4g
301
atlanta
198
bernard
link
possibilities
torus
induction
wins
inherited
contradiction
else
additions
omitting
eg
asynchronously
receipt
291
ignored
distances
accomplished
arrangement
bidirectional
georgia
informed
jv
sending
carry
complexities
dist
fault
initiate
unpredictable
distinguishing
spanning
acknowledge
interleaved
power
48
labeled
sender
delivered
numbered
initially
gamma
resulted
delay
clustered
edges
execution
carries
bounds
orientation
1992
wants
reaching
principles
hypothesis
sense
capture message
of direction
second phase
a capture
candidate in
r i
cap level
enter step
election in
to capture
the leader
first phase
the protocol
sense of
message to
a candidate
in r
in cap
level i
step i
accept message
an accept
candidate and
n k
node will
complete networks
step m
the candidate
each subring
its subring
owner j
complete network
i sends
a node
node i
first node
i x
o n
contest with
state candidate
captured nodes
capture nodes
nodes in
a message
step l
captured by
all nodes
candidates in
r j
time t
sends a
at time
message complexity
message is
leader election
changes state
step variable
directly captured
if level
of subrings
node j
lemma 3
constant amount
if i
k 2
if state
the capture
log n
and phase
messages to
at most
to i
j e
most one
of nodes
the message
n messages
i m
will capture
leader in
capture j
to captured
candidate node
has captured
a sense
send messages
captured at
on receiving
over j
j will
i k
then j
capturing of
leader the
one node
level number
phase 2
will reach
will enter
log k
this message
a protocol
i will
some node
already captured
declare itself
with sense
owner message
to contest
the subrings
waking up
edge j
up spontaneously
its step
step log
3k 4
two candidates
other subrings
state captured
id pair
node entering
while state
candidate i
to elect
to j
from i
then i
2 l
message from
itself the
i 3k
nodes j
accept 1
sends messages
for election
message over
for leader
step sends
single leader
of captured
each node
l gamma1
node in
messages and
phase i
entering the
will send
protocol is
o log
j has
is captured
capture all
leader we
candidates i
entered the
i has
networks with
phase 1
is o
since i
time unit
the candidates
level j
received an
its identity
in complete
all candidates
j to
i is
phase is
step j
a complete
that i
a power
let i
subrings captured
asynchronous complete
direction sense
6 candidate
owner messages
k subrings
then state
receive m
increment its
larger level
nicola santoro
level x
j level
other candidates
captured node
wakes up
chordal rings
entering step
a captured
is responded
candidate say
their step
capture messages
which enter
paola flocchini
sense of direction
the second phase
a capture message
in r i
the first phase
candidate in r
in cap level
the candidate in
o n k
message to i
itself the leader
messages to capture
r i m
a complete network
the first node
of the protocol
a sense of
r i k
the capture message
capture message to
k 2 l
candidates in r
at time t
in r j
i sends a
message to capture
in each subring
some node will
candidate and phase
an accept message
enter step m
with a sense
one node will
to capture nodes
r i x
a constant amount
the message complexity
at most one
message complexity of
constant amount of
a message to
in the first
sends a message
message to j
capture nodes in
2 l gamma1
complete networks with
sends a capture
captured at most
capture message is
entering the second
state candidate and
over j e
node will enter
of k 2
message is sent
within a constant
in the second
nodes in r
enter the second
complete network with
i k 2
send messages to
this message is
case i will
all nodes j
set of subrings
step log k
a candidate node
r i 3k
with sense of
in complete networks
entered the second
to contest with
of its subring
in its subring
successful in capturing
first node entering
protocol is o
for election in
protocol for leader
step variable to
enter step l
captured by j
ffl if state
its step variable
while state candidate
edge j e
capture all nodes
is directly captured
state to captured
election in complete
message from i
leader election in
candidate in cap
i 3k 4
phase is o
power of 2
and r i
from lemma 3
time t 0
one time unit
of the first
nodes in the
to all nodes
a power of
a single leader
i k 4
if i has
3 time units
the leader we
s i m
step i is
and j will
distributed algorithms for
in i 1
for leader election
is successful in
set i 1
most one time
most k 2
a node in
with one another
the protocol is
o n messages
will enter the
multiple of k
most one node
o log n
i and j
amount of time
message of the
j at time
at most k
complexity of the
all nodes in
node with the
i 1 k
the node with
the set i
may not know
the time complexity
log n bits
second phase is
the leader in
j 6 candidate
i is able
node i uses
case m of
of captured nodes
exists a candidate
k time of
no other candidate
6 candidate and
i is successful
which nodes in
subrings captured by
direction sense of
contest with one
responded to by
lines 10 11
owner j to
to capture i
still a candidate
k 2 y
a larger level
set of captured
and phase 1
n k such
changes state to
a captured node
a candidate i
is responded to
increment its step
l gamma1 candidates
node entering the
to enter step
of direction sense
nodes captured by
majority of nodes
which enter step
the largest id
no candidate in
state j 6
received an accept
two candidates i
i has captured
ignores the message
in step l
has entered the
1 k gamma
of direction in
other candidate in
level i to
not send a
level n k
the leader the
captured nodes in
declare itself the
capture message from

corpus/krapavin2000-test/1035806.txt
adversary
setonce
processes
writer
winner
wait
naming
lucky
registers
row
segment
randomized
register
shared
ff
tasonce
atomic
coin
protocol
keys
bits
game
owned
flip
log
writes
read
probability
crash
crashes
invoking
bit
corrupt
claiming
invoked
competing
reader
faulty
renaming
consensus
asynchronous
param
object
executions
adversaries
succeeds
resilient
rows
flips
off
intercommunication
mobd
freeness
executing
enabled
composite
wins
adaptive
invocation
coins
fnumber
ffln
primitives
adversarial
dirty
interprocess
expectation
selects
name
ns
running
pr
schedules
numbering
safe
segments
snapshot
randomization
strongest
win
var
outcomes
claimant
multivalue
unfrozen
processesg
fphase
spoiling
int
objects
contents
concurrent
anonymous
crashing
forward
key
2n
od
oblivious
doesn
private
reads
captured
claimed
fair
free
je
infinite
snapshots
ends
freezes
gammac
success
gets
memory
l2
idle
symmetric
indivisible
backed
array
asymmetric
elusive
names
scanning
events
tails
balls
deterministic
arbitrarily
competition
chernoff
sooner
stepping
immaterial
clean
executed
infinitely
lived
appendix
rounds
fluctuations
shot
tentative
succeed
invoke
rank
2s
summation
event
executes
communicating
failures
failure
recalling
outcome
protocols
impossibility
sc
goto
atomicity
eventually
reaches
bins
computability
round
try
repeatedly
mg
gamma1
broadcast
legal
agreement
write
synchronous
fspecifies
reinitialize
fshared
processg
fined
standardize
fffflkn
invokation
multiwriter
competitition
rowg
gameg
fspecify
searchg
segmentg
contenders
simp
ncg
claimants
worthless
adaversary
rangeg
prisingly
bstart
aloneg
wait free
test setonce
ff test
the adversary
setonce object
1 writer
n reader
writer n
a winner
shared memory
back off
read writes
log q
row r
one process
process p
n log
running time
with probability
key range
n processes
adaptive adversary
lucky at
free atomic
log n
a key
the protocol
at row
the game
naming protocol
log log
a process
o n
shared bits
ff tasonce
n bit
read write
coin flip
be lucky
each process
the probability
composite register
naming problem
is wait
processes is
every process
the processes
system execution
all processes
name space
high probability
state c
owned by
probability ff
atomic read
competing processes
system executions
crashes occur
reader shared
write registers
randomized wait
bit operations
the naming
o log
l s
probability that
other processes
q read
row row
single writer
non faulty
the ff
of processes
key space
bits proof
random key
reader 1
q out
reaches row
no crashes
setonce objects
adversary schedules
some process
a wait
step s
writes to
shared variables
with high
a name
by process
expected running
adversary is
row p
r rows
is o
object is
a randomized
probability at
c i
ns r
wait freeness
game ends
is owned
symmetric shared
corrupt objects
whole key
not back
naming algorithm
free naming
invoking processes
process wins
steps forward
claimed by
is lucky
row k
faulty process
protocol is
process can
process has
a naming
processes will
gets a
line 9
randomized consensus
free solution
the invoking
crash failures
write b
bit registers
invoked by
the object
memory model
multi reader
writer multi
key the
at most
the running
k p
coin flips
read all
to row
average running
b k
the expected
succeeds with
writes on
using shared
key k
an ff
probability of
key within
protocol segment
writer per
bit components
anonymous communication
reach row
shared atomic
lucky processes
fnumber of
enabled steps
probability s
reader wait
per component
least ff
process steps
using ff
private register
reader o
intercommunication primitives
b key
atomic bits
int fnumber
free test
shared registers
winner within
component composite
range size
initial execution
execution segment
2n r
n writer
k out
processes back
first random
from row
or crash
of adversaries
in state
test and
9 19
s gamma
a row
key is
probability 1
of shared
object that
the asynchronous
p 0
by exactly
possibly different
ff test setonce
test setonce object
writer n reader
o n log
1 writer n
wait free atomic
log n bit
lucky at row
log log n
is wait free
atomic read write
a wait free
with probability ff
the ff test
read writes to
free atomic read
with high probability
the probability that
n log q
q read writes
n bit operations
state c i
randomized wait free
in state c
read write registers
log q read
the naming problem
be lucky at
of n processes
n log log
test and set
the adversary schedules
a key the
a row p
n reader 1
test setonce objects
no crashes occur
to 1 writer
q out of
setonce object that
o log q
owned by process
b k p
running time is
expected running time
is o n
with probability at
o log log
processes is at
most one process
that the adversary
i n i
time is o
out of n
an adaptive adversary
n log n
probability at least
of an ff
symmetric shared memory
at row row
wait free naming
write a row
not back off
object is invoked
at row r
is owned by
reader shared bits
wait free solution
writes to 1
c i gamma1
n reader shared
name space of
the game ends
the whole key
gets a key
an ff test
read writes on
8 9 19
non faulty process
wait free if
a naming protocol
get a key
a name space
the running time
number of processes
n log 2
is a winner
single writer multi
to be lucky
than one process
the system execution
space of size
the adversary is
the protocol is
log n log
the average running
writer multi reader
average running time
succeeds with probability
the expected running
using shared memory
initial segment of
of the protocol
probability that the
n bit components
s in state
wait free test
private register and
reaches row r
k out of
multi reader wait
reach row r
processes back off
int fnumber of
n reader o
n writer n
process steps forward
hard to analyze
for process p
writer per component
register and can
find a key
that no crashes
whole key space
do not back
at least ff
shared bits proof
back off and
bit operations with
log q bit
reader o log
adaptive adversary the
most 2n r
be a winner
way not known
a system execution
n i log
s gamma a
of read writes
against a fair
1 writer per
of 1 writer
a winner within
by q out
uses a name
per component n
invoked by q
executing at most
row p 1
with probability s
is a wait
initial execution segment
and can read
with log log
writes to shared
exactly one process
n component composite
a randomized wait
selects a winner
non faulty processes
with a winner
free test and
using ff test
doesn t work
reads the other
every non faulty
known to each
and key range
l s gamma
read by all
own private register
p is owned
reader 1 writer
key range size
n processes it
proof a process
reader wait free
component n component
processes it uses
bit b k
log 2 n
the probability of
in an asynchronous
the adversary to
the object is
probability of having
high probability the
at most one
state resulting from
is proven 2
the other bits
n processes is
the name space
its own private
the state resulting
at row k
one process can
log log q
is at most
with probability 1

corpus/krapavin2000-test/1036015.txt
multiplication
processor
multiplications
matrices
sup
elementary
matrix
cache
replication
tradeo
ik
communication
nb
kung
2d
3d
na
jk
lpram
cannon
strassen
bounds
bisection
toledo
conventional
snir
tiskin
univac
transferred
wp
asymptotically
sivan
memory
processors
misses
asymptotic
nc
loomis
berntsen
nanbnc
aggarwal
rows
2m
ij
hong
irony
live
chandra
lemma
cut
whitney
unied
memories
dror
degenerates
dag
algebra
multipli
begins
phase
tradeoff
cations
reside
geijn
multiplicands
dekel
phipac
nassimi
lblas
resides
row
constants
cuts
underlies
send
sent
blocked
mnr
ncn
power2
compulsory
watts
mul
rst
2p
replicate
slow
subroutines
summa
prams
prefetch
sa
received
specic
broadcasts
inequality
pebble
receive
phases
bulk
mn
alexander
subroutine
nan
sahni
caches
sb
multiply
private
across
kalman
regime
cross
evenly
analyzes
fa
contributes
mc
blue
israel
columns
cm
sc
dense
ma
cient
hypercubes
dene
unlikely
involving
ibm
provable
fb
acyclic
synchronous
sgi
sp
cellular
arithmetic
accesses
1988
hey
mccoll
humanities
compres
matri
tflops
rutledge
2pd
paterson
mckeller
organiza
9060
bining
gustavson
3w
zubair
nbn
tiplicands
coman
jerrell
feel
amount
perhaps
product
column
dierent
saves
specically
factorization
store
fc
subsets
red
products
contributions
workstations
tiplications
claries
partnership
worksta
johnsson
forbid
tiprocessors
computers
square
clusters
concrete
decompose
statement
mb
rigorous
academy
herbert
1952
vb
rubinstein
isoperimetric
capacity
storage
matrix multiplication
communication lower
elementary multiplications
lower bounds
c ik
3d algorithms
for matrix
2d algorithms
multiplication algorithms
distributed memory
the processor
processor must
per processor
b jk
of communication
memory parallel
ij b
m words
elements of
the amount
local memory
i sup
conventional matrix
and kung
hong and
parallel computer
the phase
memory per
must send
communication that
of elementary
amount of
memory communication
multiplications involving
of words
words of
a ij
words that
2 elements
bounds for
must perform
the cache
parallel matrix
of c
of memory
send or
slow memory
processor distributed
least words
asymptotic notation
involving rows
conventional multiplication
strassen s
or receive
the conventional
sup 2
p processor
the matrices
a phase
exactly m
the communication
receive at
matrices on
must cross
communication across
of b
that must
cache misses
2 sup
linear algebra
g n
our bounds
at most
asymptotically optimal
lemma 2
multiplication algorithm
and snir
words must
sup words
the lpram
aggarwal chandra
chandra and
3 sup
communication tradeo
the univac
input replication
algorithms are
phase or
n matrices
lower bound
most n
two n
i o
that 3d
sivan toledo
input matrices
theorem statement
multiplication of
row of
memory and
bounds also
phase begins
2m since
rows in
are asymptotically
the memory
since each
local memories
extra memory
computation begins
s algorithm
a processor
and nb
one processor
the constants
during a
multiplication and
least n
processor s
reside in
irony sivan
p words
multipli cations
loomis whitney
cannon s
least wp
whitney inequality
words per
output combining
lpram model
most nanbnc
kung 17
discrete loomis
communication per
alexander tiskin
and alexander
toledo and
2 2p
communication necessary
dror irony
that nb
nanbnc 1
concrete constants
fast cache
words proof
our processor
the machine
bounds the
is at
of cache
algorithms must
processor at
multiplication on
at least
and received
i n
of local
processor that
than n
most 2m
perform at
2p 2
capacity cache
computer where
ik of
that 2d
transferred is
be transferred
n i
phase is
sup i
the computation
of elements
in matrix
argument shows
asymptotically the
n n
communication in
rows of
our lower
statement holds
the input
synchronous parallel
basic lemma
na and
computer we
bulk synchronous
least proof
element c
bisection of
f n
a product
communication network
column of
sent and
n elements
m r
cross the
replication of
another processor
amount of communication
communication lower bounds
for matrix multiplication
matrix multiplication algorithms
bounds for matrix
the amount of
consider the conventional
ij b jk
number of words
distributed memory parallel
elements of c
a ij b
of communication that
number of elementary
memory parallel computer
lower bounds for
conventional matrix multiplication
of elementary multiplications
processor must send
hong and kung
must send or
during a phase
of words that
memory per processor
2 elements of
i sup 2
n i sup
processor distributed memory
on a p
3d algorithms are
p processor distributed
phase is at
during the phase
elementary multiplications involving
lemma 2 2
of a and
that the processor
elements of a
the lower bounds
of local memory
of memory per
a phase is
send or receive
on the amount
n matrices on
words of local
at least words
the processor must
matrices on a
words of memory
multiplications involving rows
two n n
the conventional multiplication
words that must
conventional multiplication of
receive at least
or receive at
parallel matrix multiplication
i n i
a p processor
n n matrices
n 2 elements
a distributed memory
elements of b
1 2 a
of two n
multiplication of two
at most n
least one processor
column of b
sup i p
exactly m words
the phase or
is m r
aggarwal chandra and
algorithms are asymptotically
are asymptotically optimal
one processor must
that 3d algorithms
chandra and snir
the input matrices
the conventional matrix
c is m
matrix multiplication algorithm
involving rows in
memory communication tradeo
the phase the
theorem statement holds
n 1 2
must be transferred
sup 2 sup
that must be
amount of memory
n elements of
2m since each
matrix multiplication and
the theorem statement
matrix multiplication on
row of c
bounds the number
of the machine
on a distributed
is a product
row of a
p 2 3
we state and
when the computation
of cache misses
state and prove
lower bounds on
words that are
the cache the
on its own
can be at
is at least
at least n
2 sup i
in the processor
of elements of
a product of
lower bounds in
sent and received
the number of
the basic lemma
communication e cient
2 p words
the communication necessary
the memory communication
2d algorithms are
strassen s algorithm
multiplication algorithms must
the communication across
is n r
perform at most
nanbnc 1 2
most nanbnc 1
2p 2 3
element c ik
and kung 17
dror irony sivan
loomis whitney inequality
algorithms must perform
m words are
irony sivan toledo
at most nanbnc
computer where each
sivan toledo and
in matrix multiplication
processor at least
2 2p 2
most n elements
asymptotically optimal for
phase or is
the discrete loomis
communication lower bound
words per processor
communication that must
communication per processor
slow memory and
b is n
most 2m since
cannon s algorithm
of b there
at least wp
toledo and alexander
must cross the
discrete loomis whitney
data that must
of communication per
c ik of
c on its
capacity cache misses
n 2 2p
b there can
and alexander tiskin
transferred is at
lemma 3 1
of c is
i p i
a processor that
of the phase
be at most
reside in the
the processor s
and c is
end of the
required to store
of the matrices
argument shows that
c 2 g
parallel computer where
can compute at
cache the number
matrix multiplication is
p i sup
compute at most
at most 2m
bulk synchronous parallel
n c 2
one word of

corpus/krapavin2000-test/1036164.txt
cover
covering
vertex
strip
opt
lp
outerplanar
ld
strips
coverage
dual
width
disks
covered
shifting
vertices
uncovered
approximation
covers
primal
graphs
planar
ptas
hochbaum
pr
rounding
relaxation
edges
greedy
expanders
delta
expander
chebyshev
sa
cantelli
optimally
packing
x4
2y
outliers
dfs
geometric
partial
multicuts
massaging
slav
maass
duh
bodlaender
rer
approximating
round
1g
baker
asz
lov
1for
segev
feasible
sc
rounds
partition
asaf
randomized
pick
diameter
semidefinite
decompositions
degree
cov
danny
369
ffi
jh
polynomial
obstacle
inequality
decomposable
chernoff
4d
levin
395
guessing
ver
np
384
letting
facility
squares
tail
semi
forest
fractional
pos
gamma
expectation
2e
highest
tree
criteria
sion
formulation
square
decomposition
ratio
coloring
strategy
wish
fx
2c
jopt
costliest
4opt
1bound
equaled
individu
gavril
2205
qilian
golovin
setcover
pactly
qingchun
cjx
2188
nagarajan
mohit
lovmyampersand
4bound
thetald
ik
hardness
italic
jx
variance
costs
raise
collection
integral
matching
star
bounded
equality
weighted
ponent
chv
mulation
maxfk
atal
3l
viswanath
621
suitably
facilities
ffl
implying
appendix
incident
guess
relax
serial
erage
als
sz
asc
multicut
homogenous
isoperimetric
disk
sup
exhaustive
partitions
approximate
collec
judiciously
yehuda
permissible
timization
pairwise
complementary
vlsi
unweighted
ering
fz
integrality
sible
recourse
itively
families
belongs
union
cardinality
recipe
coverings
afford
generalization
modified
ip
edge
fl
vertex cover
k vertex
set cover
cover problem
partial covering
each strip
cover for
full coverage
covering problem
l outerplanar
the shifting
approximation algorithms
optimal solution
1 sets
tree width
shifting strategy
geometric covering
cover at
covering case
to cover
k set
cover and
partial vertex
width ld
planar graphs
the lp
the partial
covering problems
average degree
of width
2 approximation
strip of
cover we
outerplanar graph
least k
cover on
the dual
i j
primal dual
u i
strips of
partial set
coverage version
of disks
at most
lp relaxation
ffl k
i partial
uncovered elements
an optimal
the cover
property p
solution for
2 sets
covers at
semi local
dual feasible
graphs of
highest cost
approximation scheme
that covers
approximation algorithm
cover the
in strip
partial coverage
partial cover
chosen sets
full covering
cover full
performance ratio
covering and
points in
approximate solution
h delta
time approximation
feasible solution
k elements
the vertex
constant average
multi criteria
a primal
points covered
f sets
set covering
n opt
covered by
for k
randomized rounding
partition s
and packing
for covering
a ptas
bounded tree
most f
polynomial time
vertices in
for planar
given points
packing problems
cost set
3 sets
opt in
i h
maximum degree
degree graphs
of bounded
algorithms for
linear time
a minimum
the full
cover problems
maximum matching
delta gamma
l partitions
on planar
strip j
tail bounds
modified instance
cantelli inequality
bounded average
problems approximation
strips in
chebyshev cantelli
disks of
on expanders
the strip
cover in
be covered
for np
r a
bounded degree
disks in
of points
graphs approximation
rounding the
approximation technique
expander graphs
k i
the solution
approximation for
z i
of sets
a solution
relaxation of
that pr
e c
for graphs
sets chosen
outerplanar graphs
into strips
location problems
i k
the vertices
of edges
graph has
end point
the optimal
cost function
minimum cost
all sets
the instance
a graph
each element
ptas for
tree decomposition
pr u
on bounded
of diameter
diameter d
1g let
is at
the edges
graphs and
solution to
improved approximation
k points
dual variables
facility location
solved optimally
the chebyshev
k edges
let opt
for vertex
the sets
greedy algorithm
of elements
a polynomial
x j
lower bound
graph g
by opt
dynamic programming
approximating the
above algorithm
for i
the points
covering the
local optimization
greedy heuristic
the l
k vertex cover
vertex cover problem
for k vertex
approximation algorithms for
for the partial
vertex cover for
cover at least
k set cover
the vertex cover
an optimal solution
the full coverage
the shifting strategy
vertex cover on
the partial covering
of width ld
partial vertex cover
u i j
at least k
partial set cover
strips of width
k i partial
of 1 sets
l outerplanar graph
i k i
is at most
solution for each
covers at least
least k elements
the highest cost
a 2 approximation
for planar graphs
each strip of
2 approximation for
solution to cover
the set covering
cover for planar
a primal dual
partial covering case
partial covering problem
that covers at
in each strip
most f sets
of constant average
the partial coverage
to each strip
covering and packing
constant average degree
partition s i
for the full
dual feasible solution
the dual feasible
points covered by
of points covered
algorithms for np
and packing problems
set cover problem
number of 1
find a minimum
at most f
for i k
bounded tree width
that e c
graphs of bounded
polynomial time approximation
z i j
bounded degree graphs
number of elements
the number of
cover the points
cover problem on
1 sets and
cover problem the
expander graphs of
bounded average degree
disks of diameter
for set cover
vertex cover problems
chebyshev cantelli inequality
semi local optimization
least k edges
ffl k vertex
vertex cover and
partial coverage version
the sets chosen
vertex cover full
to cover at
partial cover problem
the chebyshev cantelli
set cover and
on planar graphs
for each strip
graphs of constant
strip of width
r a l
the partial vertex
highest cost set
the full covering
h delta gamma
l outerplanar graphs
full coverage version
u i 0
points in strip
for vertex cover
set cover for
the l partitions
geometric covering problem
in strip j
the geometric covering
l r a
i partial vertex
full covering case
pr u i
the partial cover
the chosen sets
a solution for
number of points
the lp relaxation
facility location problems
of 4 3
into strips of
for the vertex
for graphs of
the performance ratio
0 j 0
on bounded degree
graphs approximation algorithms
greedy heuristic for
i 0 j
set covering problem
better than 2
element is in
performance ratio of
of diameter d
optimal solution we
number of edges
of the solution
approximation algorithm for
suppose x is
of disks in
set of disks
a tree decomposition
improved approximation algorithms
time approximation scheme
number of disks
for the instance
a minimum number
of the greedy
the approximate solution
number of sets
a minimum cost
heuristic for the
can be covered
of the lp
the above algorithm
the solution to
in an optimal
greedy algorithm for
a linear programming
in the optimal
x j and
the optimal solution
a polynomial time
for the set
optimal solution in
for approximating the
given a graph
do not know
the greedy algorithm
i j and
the parallel algorithm
and 1 sets
needed to cover
and 2 sets
shifting strategy for
semi local 2
multicuts in trees
of bounded maximum
solution we will
of bounded average
linear time algorithms
f approximate solution
approximating the partial
decomposable graphs approximation
optimally using 2
of shifting strategy
369 n 1
the optimal ip
each strip this
the lp and
modified greedy heuristic
i j 2e
set cover we
the cover and
side length ld
hard problems approximation
strip of a
and a semidefinite
parallel algorithm runs
cover we wish
minimum cost solution

corpus/krapavin2000-test/1036205.txt
mus
unsatis
satis
cnf
horn
formulae
minimally
clauses
subformulae
clausal
inequalities
infeasible
iis
sat
ci
propositional
chandru
hooker
chinneck
integral
subformula
cj
clause
tex
arborescence
bruni
yt
ned
1990
gleeson
renamable
iis1
ci1
polyhedron
balanced
feasible
sect
ic1
farkas
formula
selection
ryan
unsatisfiable
vertex
truemper
kleine
conforti
veri
ip
ow
subtractive
relaxation
bc1
1991
nding
inconsistencies
ning
approached
ed
ows
inconsistency
04
matrix
sassano
tsitsiklis
chandrasekaran
nonzeroes
drown
guieu
aspvall
opportune
bertsimas
dravnieks
gallier
imposing
f2
digraph
contradiction
de
2003
bu
ability
yes
feasibility
kullmann
dowling
ejols
cornu
balancedness
locating
rst
mu
nition
simplex
ir
nes
franco
solvable
xi
infeasibility
icting
arcs
additive
literals
cplex
polynomial
subsystem
exact
star
gelder
ciency
satisfiable
polytope
box
ak
rules
contrary
polyhedra
submatrix
classes
rooted
demanding
irreducible
rounding
incidence
polyhedral
1986
solving
heuristics
literal
truth
composed
zhao
2n
matrices
v1
ax
f1
jointly
removing
fleischner
witha
orcontradiction
arcsof
particularized
postinfeasibility
amatrixa
boros
themus
fellegi
grgoire
piette
lettman
cdric
1894
whish
amaldi
nmnmtime
scutell
litera
slur
reckoned
infea
expecially
1tx
maaren
isfeasible
protasi
autarkies
muses
isgivenby
tamiz
swaminathan
fractionary
isinfeasible
mannino
mazure
deciding
verifying
1999
row
1995
2002
van
computationally
compendium
schrijver
ric
matroid
disguised
characterizable
cation
realization
arrows
recognition
a1
detection
strict
solved
integer
unsatis able
a mus
mus selection
minimally unsatis
satis able
satis ability
clausal inequalities
ci 1
extended horn
able subformulae
integral point
exact selection
mus is
of minimally
the mus
linear inequalities
cnf formula
a cnf
the satis
ip property
of clauses
is infeasible
is feasible
04 2003
40 p
14 40
2003 14
exact tex
tex 1
to clausal
be satis
and hooker
ability problem
mus in
linear relaxation
chandru and
1 04
selection of
selection problem
box constraints
is unsatis
cnf formulae
if 8
de ned
p exact
h vector
propositional formulae
of linear
a minimally
point property
hooker 1991
farkas lemma
all mus
and ryan
renamable horn
gleeson and
mus that
horn and
mus of
ryan 1990
veri ed
underlying system
of propositional
the ip
polynomial time
the cnf
the support
support of
integer constraints
8 is
formula f
nding a
a vertex
classes of
in bruni
one integral
approached by
truemper 1998
of mus
bruni 2002
easy classes
of clausal
selected mus
kleine bu
ir h
able subformula
infeasible 7
into clauses
horn formulae
the arborescence
bu ning
an iis
to clauses
of cnf
able therefore
extended star
yt b
strict integer
de ciency
inequalities ci
systems of
formulae are
of formulae
the linear
one 1
vector b
inequalities in
form 10
sat problem
property either
clauses corresponding
to ci
propositional formula
the integral
t 1
of inequalities
composed by
the clauses
programming problem
propositional variables
ning and
original formula
2002 the
max sat
vertex of
7 is
linear programming
more strict
the polyhedron
by locating
contrary if
solving the
an integral
linear case
inequalities of
linear programs
restriction of
of systems
of rules
for 7
methods would
f is
property holds
0 1
in polynomial
imposing the
de nition
solving a
rules should
1 matrix
8 to
propositional cnf
dravnieks 1991
analogous of
formulae verify
been approached
and dravnieks
world contradiction
positive 1
point having
dowling and
proposed procedure
drown over
ones imposing
able so
rooted arborescence
clause subset
ic1 not
no extended
or subtractive
polyhedron 8
subformula mus
help deleting
arrows drown
minimal unsatis
conforti and
computational experience
iis in
relaxation 7
chinneck 2001
minimally unsatisfiable
hooker 1999
mus are
irreducible infeasible
inequalities an
inconsistencies produces
real h
such digraph
formulae which
this because
on decomposition
arborescence realization
zhao 2002
chinneck and
denote also
clauses jointly
re design
alternative system
inequalities having
its inequalities
minimally unsatis able
exact selection of
of linear inequalities
selection of minimally
unsatis able subformulae
of minimally unsatis
a mus is
04 2003 14
1 04 2003
2003 14 40
tex 1 04
to clausal inequalities
of a mus
14 40 p
exact tex 1
chandru and hooker
the mus selection
the ip property
a cnf formula
the satis ability
satis ability problem
mus selection problem
systems of linear
f is unsatis
be satis able
p exact selection
40 p exact
contains a mus
the integral point
integral point property
is unsatis able
if 8 is
the linear relaxation
case of systems
the support of
the underlying system
8 to clausal
and ryan 1990
and hooker 1991
a minimally unsatis
of propositional formulae
gleeson and ryan
classes of formulae
set of clauses
of systems of
of the support
solving a linear
in the form
restriction of the
linear programming problem
a linear programming
inequalities ci 1
more strict integer
mus is a
corresponding to ci
imposing the more
a mus in
unsatis able subformula
least one integral
bu ning and
the box constraints
of mus selection
easy classes for
infeasible 7 is
in bruni 2002
linear relaxation of
to be satis
of a cnf
8 is feasible
6 is feasible
subset of clauses
8 is infeasible
extended horn formulae
of cnf formulae
strict integer constraints
one integral point
0 1 m
property either to
of clausal inequalities
yt b 0
ip property holds
is infeasible 7
for the satis
classes of propositional
kleine bu ning
to ci 1
7 is feasible
mus that is
the more strict
of a vertex
system of linear
either to be
of each vertex
selection problem is
clauses corresponding to
the restriction of
support of a
support of each
or to be
the linear case
inequalities in the
the contrary if
number of clauses
have a well
in polynomial time
selection of a
in the case
set of rules
deciding whether a
the 0 1
rules should be
of deciding whether
each vertex of
for the variables
given by the
conditions of theorem
problem of deciding
1 is infeasible
the arcs a
in chandru and
has been approached
in form 10
only the small
is negative 0
whose rows correspond
nding a vertex
all its inequalities
farkas lemma and
positive 1 if
dowling and gallier
able subset of
real world contradiction
the analogous of
when this can
by locating a
checking the rules
correspond to clauses
jointly unsatis able
satis able or
not help deleting
cnf formula contains
the alternative system
most one 1
world contradiction detection
consists in nding
real h vector
linear case in
linear inequalities having
a well de
is veri ed
unsatis able when
if 3 is
conforti and cornu
whether a cnf
well de ned
verifying all its
t 1 matrix
the arborescence realization
time than just
for mus selection
bruni and sassano
guieu and chinneck
mus in the
by the shorter
clausal inequalities contains
and dravnieks 1991
of clauses jointly
indices of its
while selection of
be extended horn
non zero components
locating a mus
general we show
xi 0 1
nd a mus
rules into clauses
additive or subtractive
is feasible i
components will correspond
con icting rules
each new clause
rules for inconsistencies
of farkas lemma
ci1 corresponds to
has the integral
located and it
column sums to
is feasible by
an irreducible infeasible
negative 0 otherwise
solved by locating
property is veri
system causing the
requires much more
is positive 1
formula contains a
and tsitsiklis 1997
of its non
for inconsistencies produces
all the con

corpus/krapavin2000-test/1036463.txt
crossing
pcr
drawing
vertices
ow
crossings
nonplanar
bisection
arching
cr
subgraph
ssqd
vertex
leighton
ows
multicommodity
pach
arc
deg
tangled
edge
log
edges
bhatt
terminal
toth
shahrokhi
planar
paths
rounding
expansion
charged
width
cut
hb
vg
commodity
subgraphs
dilation
sup
recursive
circle
cross
ja
fu
witnessing
expander
embedding
unsplittable
valtr
sixtuple
rao
graphs
vlsi
congestion
draw
rst
bounding
induced
degree
ciently
partitioning
arcs
su
partition
plane
uv
randomized
split
nish
drawings
disjoint
degrees
unordered
pairs
lemma
ancestor
subdivision
partitions
embeddings
connecting
drawn
proved
ln00a056
kratochvl
chvatal
commodities
vrt
sykora
least3
2je
babilon
bisections
hereditary
theoremwe
helena
sixtuples
kolman
nyklova
scheideler
fahrad
miserably
crosses
feasible
mn
children
raised
cuts
integral
straight
provably
spencer
cle
matousek
newborn
tth
subarcs
szegedy
schieber
rescale
szemeredi
mohar
maxfd
prague
demand
detour
girth
layout
proofs
weaker
779
ajtai
seminar
forthcoming
republic
guha
pavel
analogy
maximal
induction
raghavan
czech
nf
transfered
integrality
remark
nished
balancing
path
balanced
passing
ministry
constituting
rescaling
absolute
mesh
separator
segments
algorithmic
improvement
odd
simplies
thompson
nm
layouts
uninteresting
4n
tree
overlooked
nondecreasing
recursively
3g
insist
recalling
bipartite
internal
contradiction
estimating
denition
culties
places
capacity
weight
quadratic
bounds
education
simplied
bounded
nd
leaf
approximations
concurrent
prescribed
injective
improved
removing
charge
participants
ces
theorems
crossing number
pair crossing
pcr g
drawing of
of g
the crossing
a drawing
log n
cr g
g i
edge expansion
bisection width
crossings in
ssqd g
a nonplanar
graph g
nonplanar subgraph
arching pairs
crossing pairs
of pcr
of crossing
i g
of vertices
in g
of crossings
of edges
n vertices
maximum degree
tree vertex
every graph
g 0
multicommodity ow
1 log
deg v
bhatt and
most o
the pair
k v
vertices of
the drawing
of paths
circle arc
even et
and leighton
a bisection
o 1
ow problem
a graph
hb g
pach and
and toth
recursive drawing
terminal vertex
the ow
of k
the recursive
crossings of
leighton and
was split
fu vg
cr i
vertex t
g and
in f
the subgraph
an edge
at most
k 3
ow through
terminal vertices
randomized rounding
a subgraph
lemma 6
vertices in
vertices with
cross in
graph on
graphs with
with edge
of theorem
by v
o log
nonplanar subgraphs
common terminal
leighton 2
the ows
small nonplanar
subgraph on
drawn along
by even
maximal ow
on cr
ow number
tangled pairs
edge fu
pcr i
optimal drawing
g 2
size o
theorem 4
g t
the vertices
vertices and
let g
induced by
partition of
the bisection
that cross
subgraph in
expected number
log 2
b g
a vertex
subgraph of
given graph
bounded degree
size log
charged for
i vertices
ja 1
pairs in
on n
2 log
of pairs
2 n
the edge
number and
al 3
feasible solution
for graphs
proof of
degree bounded
this drawing
vertex disjoint
subgraph g
subgraph induced
bisection of
graph with
each edge
lower bound
g in
g on
of size
the paths
a crossing
absolute constant
g induced
uniform multicommodity
edges in
su ciently
the plane
edges that
g is
edge is
a path
an arc
the dilation
arc and
and rao
degree graphs
is planar
v and
theorem 8
min cut
2 sup
have log
vertices we
n log
number the
theorem 1
bounding the
a partition
new graph
planar graph
the graph
edge e
possible number
log 3
for bounding
q have
sup 2
number i
ow of
graph into
vertex in
procedure of
vertex of
paths from
all subgraphs
unit capacity
shahrokhi et
rao 8
the unsplittable
recursive partitioning
concurrent multicommodity
witnessing pcr
as straight
c deg
of arching
multicommodity max
pair crossing number
the crossing number
the pair crossing
i g i
drawing of g
a drawing of
crossing number of
number of crossing
of pcr g
a nonplanar subgraph
of k v
1 log n
crossing number and
at most o
of k 3
o 1 log
induced by v
with edge expansion
drawing of k
bhatt and leighton
of crossing pairs
k 3 3
number of crossings
even et al
in a drawing
number of edges
for every graph
pair of vertices
partition of g
cr i g
the recursive drawing
multicommodity ow problem
terms of pcr
crossing number the
tree vertex t
pairs in f
1 n log
pairs of edges
number of vertices
g i is
of crossings in
the bisection width
log 2 n
vertices of g
the maximum degree
o 1 n
every graph g
is the maximum
of size o
on n vertices
edges in g
through an edge
of g and
for the pair
the expected number
most o log
by even et
pach and toth
pcr g and
on the circle
minimum possible number
and leighton 2
uniform multicommodity ow
arching pairs in
a common terminal
subgraph on at
edge fu vg
the circle arc
small nonplanar subgraphs
charged for at
new graph g
on cr g
a tree vertex
in the drawing
pcr i g
vertices with edge
is drawn along
common terminal vertex
edges that cross
of the crossing
paths from p
expected number of
if p and
of pairs of
bounded by a
vertices in g
in the plane
in theorem 4
g of size
of i g
a bisection of
maximum degree bounded
ja 1 j
vertex in which
graph into two
the drawing of
a subgraph g
leighton and rao
g is the
et al 3
by a constant
proof of theorem
the vertices of
n log n
of g the
on an arc
degree bounded by
g in terms
subgraph induced by
the subgraph induced
log n and
the number of
a graph g
of vertices in
n vertices with
degree of g
the graph into
for graphs with
and q have
of g induced
by v i
g induced by
of edges in
p and q
n vertices and
bounded degree graphs
2 log 2
2 sup i
sup 2 sup
is at most
in f is
of edges that
graph g we
n 2 log
be a graph
graph g 0
the subgraph of
g i in
every pair of
into two parts
of a graph
possible number of
in g 0
subgraph of g
log n where
the minimum possible
number of paths
smallest number of
a given graph
a feasible solution
is o 1
number of a
a partition of
by lemma 6
for at most
of crossing and
technique for provably
drawing of i
paths of p
passing through an
a graph i
vertex disjoint edges
nonplanar subgraph on
of g pach
circle arc that
approximations of crossings
bounding the crossing
and pair crossing
by recursive bisection
a circle arc
constant degree expander
unit capacity ows
exponential decrease of
ow through an
in g t
that cross in
total ow through
of bhatt and
log n t
v is drawn
path p uv
other terminal vertex
crossings of pairs
the arc and
crossing number is
through each edge
tree vertex in
hb g log
drawing d 0
deg v and
g pach and
in graph drawings
algorithms and algorithmic
crossing number cr
fu vg of
maximal ow through
for drawing g
probability o n
terminal vertex of
the recursive partitioning

corpus/krapavin2000-test/1037116.txt
dst
pkt
dsr
routing
packets
packet
destination
route
hop
destinations
ood
hops
routes
query
nbr
buer
pause
rd
timeout
tag
update
src
protocol
neighbor
attachment
protocols
predecessor
reply
mac
tracing
broadcast
hoc
driven
updates
innity
send
link
ns
sent
demand
distance
ad
wireless
routers
bdcast
lh
dropped
router
node
rt
successor
neighbors
fig
newpath
forwarding
seconds
layer
nite
else
source
addr
ows
tables
overhead
percentage
sender
scenarios
permanent
forwarded
tora
wrp
msecs
promiscuous
entries
identier
entry
tra
internet
aodv
infty
simulations
900
peer
satised
received
delays
jk
loop
topology
discovery
queries
count
suers
t3
sends
receive
delay
dierent
scenario
innite
loops
header
radio
stale
unicast
kbps
stack
zqs
dsdv
unreliably
rebroadcast
buered
rmv
delivery
looping
attenuation
unreliable
congestion
ow
headers
networks
cient
suered
listening
regular
movement
network
cumulative
bandwidth
prevent
t1
sequenced
sce
parenthesis
paths
mobile
broadcasts
implied
cpt
ection
mimics
rst
static
incurs
started
stamps
miles
bellman
mobility
community
_
connectivity
throughput
learns
picks
ssa
ford
dt
path
caches
searches
links
ciency
emergency
simulation
qr
mimic
km
resets
picking
receiver
whom
loses
secs
metric
maintaining
updating
eect
helps
receives
false
specication
routed
distances
host
pending
ip
elapsed
aect
dierences
collisions
plot
300
zrp
ilmj
bys
received2000600010000140001
timeline
thatthe
bat
pkt dst
data packets
table driven
data packet
source tracing
in dst
routing table
pkt src
driven routing
control packets
the routing
tag i
routing protocols
packet is
node d
routing protocol
on demand
demand routing
distance table
regular update
dst and
query receive
receive timeout
reply update
of dsr
ood search
control overhead
hoc networks
neighbor k
hop query
packet overhead
pkt hops
control packet
of attachment
ad hoc
the destination
to destinations
rt update
pause times
routing information
to innity
hop count
distance to
in best
pause time
route discovery
route to
in dsr
0 lh
if rd
query send
zero hop
distance vector
predecessor to
limited broadcast
send timeout
broadcast address
all destinations
dsr and
routing tables
packets received
in fig
the packet
a route
node e
path to
the mac
node c
set to
a node
and pkt
send update
vector routing
pkt nbr
for destination
if pkt
the buer
i pkt
bdcast addr
its distance
of control
percentage of
and best
update from
a destination
and destination
of hops
the route
last hop
of routing
the path
the query
update is
a neighbor
the link
is dropped
else if
packets run
data buer
max hops
to pkt
rd add
destination bdcast
src set
than query
dst set
of dst
than dsr
maximum hop
destination j
known neighbors
dsr percentage
j rd
than dst
900 seconds
and dst
run number
packets sent
for ad
an update
paths to
the distance
d i
to j
a reply
each entry
the sender
a link
packet delivery
to last
of source
the source
dst is
query table
update send
add else
dst a
dynamic source
delivery ratio
routes to
a distance
a regular
that best
destination and
table entry
with source
source routing
source i
destination a
the limited
e cient
node i
overhead than
update with
which routers
scenario 2
packet from
and predecessor
packets in
tra c
conditions are
is set
second to
when node
other on
a query
the control
in ad
link connectivity
community networks
dsr which
distance predecessor
timeout seconds
update routing
regular updates
permanent loops
dst or
counting to
infty _
forwarding layer
ood searches
distance tables
update source
unreliable updates
dsr dst
required destination
else procedure
packet pkt
routers maintain
procedure dt
dst correct
destination pkt
addr else
constants used
routing message
send false
buer is
timeout the
dt update
known destinations
table driven routing
of data packets
percentage of data
of control packets
on demand routing
query receive timeout
a regular update
the data packet
ad hoc networks
control packet overhead
the routing table
point of attachment
number of control
a data packet
data packet is
to the destination
the limited broadcast
a 0 lh
data packets received
a table driven
query send timeout
dst and best
demand routing protocols
a reply update
limited broadcast address
to last hop
zero hop query
driven routing protocol
distance vector routing
the control packet
the packet is
number of hops
second to last
to the limited
for ad hoc
driven routing protocols
update is sent
for destination a
source i and
destination bdcast addr
routing table entries
rt update send
i pkt dst
packets run number
regular update is
the distance table
overhead of dsr
if rd add
rd add else
and pkt src
else if rd
pkt src set
tag i pkt
distance table entry
other on demand
pkt dst set
routing information for
src set to
of source tracing
and destination bdcast
dst set to
dsr percentage of
is set to
packet delivery ratio
routing protocol that
its distance to
in ad hoc
to a destination
when node i
a route to
in which routers
the point of
broadcast to the
each entry j
dropped and a
entry j rd
maintain routing information
procedure rt update
used in best
pkt hops 1
broadcast address and
than query receive
a zero hop
control packets sent
routers maintain routing
performance of dsr
longer be sent
dsr and dst
source tracing algorithm
node d is
a neighbor the
data packet from
sent percentage of
path to j
and and destination
packet overhead of
send update with
bdcast addr else
procedure dt update
for all destinations
of the delays
see that best
send false rt
pkt dst correct
information for all
last time a
update source i
control overhead than
0 lh a
to all destinations
counting to innity
to pkt dst
a nite and
paths to destinations
to update routing
update pkt nbr
update with source
constants used in
which routers maintain
overhead than dst
the reply update
packets sent percentage
of dsr and
is a table
false rt update
path to the
set to the
e cient routing
the mac layer
then the packet
begin for all
else end for
conditions a and
control overhead of
the route discovery
the entries are
end for all
the path to
in fig 2
is dropped and
i and and
to a neighbor
to that destination
the control overhead
the last query
to the internet
route to the
the routing protocol
in fig 4
if d i
all j 2
route to a
destination of the
routing in ad
routing protocols for
is kept constant
the data packets
ad hoc network
packet is dropped
the destination of
in the routing
the second to
the two conditions
j 2 n
the path from
distance to a
is called to
e f and
shown in fig
two conditions are
it is set
the last time
the link between
can no longer
source of the
times more control
4 maintaining routes
update routing tables
identier j the
either on demand
nodes e f
with dsr which
dst is a
count which are
overhead of dst
n if rd
continue else if
of update packets
if pkt dst
star 9 which
called for processing
number of pending
and the predecessor
nbr k called
the rst protocol
maximum hop count
due to unreliable
simulations for two
the counting to
all known destinations

corpus/krapavin2000-test/1037287.txt
documents
slovenian
odds
tagalog
query
croatian
retrieved
queries
document
learning
web
ptf
ltmii
czech
minority
frequency
target
issued
words3
words1
scores
neg
doc
1000
ratio
rtfidf
words2
3000
exclusion
lengths
probabilistic
pages
filter
ghani
speaker
corpus
inclusion
tf
languages
2500
language
precision
1500
exclude
fmii
morelikethislist
mlii
corpusbuilder
retrieving
5000
altavista
corpora
fading
ltaii
50015002500
jones
english
4000
issuing
score
engine
500
selection
handful
scoring
collecting
un3
lta
1003005007000
multinomial
native
docs
600
fm
keywords
vocabulary
generation
200600100014001800
classifier
2000
relevant
hit
za
si
url
websail
cavnar
trenkle
splet
janez
miza
2006001000140018000
speakers
po
unseen
outperforms
informal
700
15000
3500
probabilistically
crawler
winnow
7000
text
fetch
news
querying
20000
supplied
word
hits
preferred
multiplicative
coverage
asked
classified
lt
ml
probabilities
000
len
normalize
update
selecting
experiments
engines
frequent
1400
ideal
portuguese
resnik
sola
distractor
60000
morelikethis
cvetje
rennie
karkoli
length8
length4
posdocs
por3
words250015002500
length3
incterm
boley
350000
length2
nonrelwordfrequencies
izmenjava
serbian
stran
ltm
450000
500150025000
length0
grobelnik
length7
vsebina
zoprno
length6
rtf
tf31003005007000
delo
length5
gostilne
kazalo
posqueries
relwordfrequencies
noord
hisa
independence
urls
100000
800
50000
examined
past
finds
ker
select
success
getting
decaying
multilingual
spider
ang
mccallum
dwarfed
diligenti
300000
brazilian
1200
categorization
concept
400
uniform
proportion
250000
odds ratio
found total
term frequency
documents found
term selection
slovenian documents
documents retrieved
query generation
total documents
target language
probabilistic term
query length
queries issued
target documents
length 3
language filter
total queries
probabilistic odds
of documents
retrieved doc
documents in
the target
term memory
the web
in slovenian
learning methods
non relevant
selection method
initial documents
exclusion terms
language documents
generation method
different initial
selection methods
relevant documents
query lengths
target concept
generation methods
documents and
long term
query parameters
1500 2000
2000 2500
1000 1500
croatian and
initial document
tagalog documents
relevant and
web pages
initial conditions
500 1000
and probabilistic
length 5
fading memory
1000 queries
inclusion terms
4 neg
of slovenian
with length
frequency and
the query
inclusion and
after retrieving
retrieved query
conditions using
learning query
using length
and tagalog
issued query
search engine
documents while
of queries
other languages
include terms
a query
exclude terms
slovenian and
issuing 1000
4 terms
minority language
minority languages
ltmii fmii
documents after
for slovenian
memory learning
word queries
memory less
mlii ltmii
by odds
ratio or
query terms
of target
d m
update rule
positive documents
fixed query
different learning
documents examined
a minority
for length
croatian czech
slovenian croatian
more documents
related pages
si domain
the morelikethislist
1000 retrieved
tagalog and
different term
exclusion term
jones 2000
retrieving around
longer queries
5000 queries
ptf 3
50015002500 slovenian
czech and
after issuing
natural languages
3000 retrieved
and czech
documents a
2500 3000
a handful
and exclusion
the language
documents using
single word
web search
function words
normalize scores
000 queries
include and
queries for
handful of
words as
method m
web and
the si
and lengths
new documents
our learning
1000 documents
best performance
and jones
unique words2
while probabilistic
queries odds
common words2
common words3
neg informal
fmii ltaii
initial negative
words2 unique
positive document
words2 useful
useful words3
memory method
and odds
on slovenian
words3 unique
useful words1
words3 useful
ghani jones
find documents
corpora for
over methods
news 4
initial positive
unique words3
the minority
in tagalog
ratio query
common words1
additive update
retrieved different
achieved precision
to odds
slovenian words
unique words1
as slovenian
5000 retrieved
no documents
tf 3
using ltmii
informal 4
ghani and
neg news
ratio found
words1 unique
collecting documents
words3 common
words1 useful
3 slovenian
words1 common
croatian documents
we asked
ratio to
documents were
document in
documents found total
probabilistic term frequency
found total documents
slovenian documents found
total documents retrieved
the target language
found total queries
probabilistic odds ratio
total queries issued
term selection method
term selection methods
long term memory
in the target
query generation method
query generation methods
term frequency and
target language documents
number of documents
query length 3
500 1000 1500
1000 1500 2000
1500 2000 2500
the target concept
different initial conditions
of documents retrieved
non relevant documents
the language filter
relevant and non
and non relevant
number of queries
documents in the
and probabilistic term
initial conditions using
retrieved query length
with length 3
documents retrieved query
on the web
frequency and probabilistic
the term selection
issued query length
queries issued query
target documents found
the query generation
by odds ratio
number of target
odds ratio or
of target documents
a language filter
different learning methods
generation method m
odds ratio and
mlii ltmii fmii
4 terms are
from the web
2000 2500 3000
after retrieving around
documents were found
odds ratio to
total documents examined
method and length
issuing 1000 queries
3000 retrieved doc
ratio to select
50015002500 slovenian documents
different term selection
documents using length
and probabilistic odds
methods and lengths
of queries issued
the si domain
learning query parameters
tagalog documents found
language documents while
1000 retrieved doc
fixed query parameters
a handful of
the number of
the search engine
the web and
by the language
in d m
performance is achieved
the best performance
best performance is
odds ratio achieved
conditions using ltmii
unique words2 useful
documents retrieved different
croatian czech and
generate a query
of being chosen
scores to give
odds ratio is
different initial documents
the initial document
queries odds ratio
odds ratio found
term frequency 0
and exclusion terms
ghani and jones
words1 unique words1
include terms and
odds ratio query
single word queries
or with length
and odds ratio
useful words3 common
common words3 unique
odds ratio 5
slovenian croatian czech
4 neg informal
100 000 queries
term frequency for
of different term
odds ratio with
query length 5
the learning methods
neg informal 4
words3 unique words3
to odds ratio
ghani jones 2000
unique words1 useful
news 4 neg
no new documents
1000 queries odds
a query generation
words3 useful words3
neg neg news
ltmii fmii ltaii
retrieved different initial
czech and tagalog
informal 4 neg
normalize scores to
neg news 4
words1 useful words1
common words2 unique
conditions using or
5000 retrieved doc
unique words3 useful
common words1 unique
useful words1 common
tagalog documents and
words2 unique words2
words3 common words1
being chosen number
documents in tagalog
while probabilistic odds
words1 common words2
croatian documents found
using or with
after issuing 1000
the long term
in the number
probability of being
chosen number of
selection methods for
inclusion and exclusion
the relevant documents
to the target
document in the
same number of
for the same
the same number
of documents in
the web for
3000 3500 4000
from the relevant
web pages in
2500 3000 3500
was achieved by
the target class
comparison of different
according to their
search engine and
number of total
the other methods
on line learning
documents in a
store scores in
while term frequency
methods store in
achieved by odds
to give probability
of total documents
terms are included
initial documents and
frequency probabilistic term
odds ratio 0
to d m
are included and
such as slovenian
exclusion term selection
m i according
generation methods and
ratio gets over
term frequency with
of words led
distribution over methods
for slovenian and
ratio with length

corpus/krapavin2000-test/1038132.txt
researchindex
recommenders
document
entropy
documents
maxent
recommendations
recommender
bigrams
mixture
markov
predictions
similarity
multinomial
recommendation
clustering
prev
clusters
cluster
recommending
web
lawrence
correlation
requests
collaborative
giles
bins
height
training
nec
triggers
topically
citation
hits
predictors
multinomials
filtering
engines
navigation
session
bigram
requested
goodman
history
cited
merge
lawrence98searching
citeseer
bibliography
mixtures
unassigned
greedy
em
sessions
cites
learned
nc
users
citations
months
prediction
bin
470
browsing
hit
ps
uid
comp
homepages
researchin
multmix
4bytes
pagegather
probabilistic
mix
sentence
000
online
site
learning
gz
broke
sequences
heights
offline
dex
kt
pennock
content
sparse
coverage
co
text
ratios
recency
employing
accesses
wealth
docs
expectation
searching
accurate
steve
engine
items
statistics
competing
docu
reasonably
counts
fitting
interactions
recommends
458
traffic
you
download
displays
shot
attractive
preprocessing
visited
scoring
dimensionality
statistic
accessed
features
logs
interests
nj
solely
article
frequency
megabytes
assessing
trigger
days
discarding
occurred
currently
com
screen
normalization
iii
predictor
expectations
mobasher
116gigabytes
visitation
rdf
lawren
yanzan
0977
0703
nomials
manavoglu
uwaterloo
rsearchindex
darya
bamshad
claclark
contaminate
plg
ponder
0056
0144
lg98
indexable
6785
balabanovic
0080
6281
djvu
pubdl
1hour
0072
researchiindex
wwwmetrics
6megabytes
attractively
changedriven
eberhart
menders
subsession
969
6857
320m
chscience98
4486
hpsearch
0078
wysiwyg
1250
subsessions
than100
0068
aposteriori
pavlov
9832
unclustered
maximum entropy
d next
similarity based
based recommenders
in researchindex
next h
document requests
entropy model
mixture of
researchindex merge
the researchindex
entropy models
multinomial models
d prev
collaborative filtering
the mixture
of document
the documents
of markov
of predictions
entropy approach
of documents
average height
a mixture
cited by
co citation
current document
documents that
the history
history h
active bibliography
topically related
recommenders with
user navigation
markov model
next d
of recommendations
order markov
individual similarity
a document
p d
users who
per user
markov models
training data
of hits
researchindex a
researchindex data
maxent approach
ordered sequences
of multinomial
based predictors
markov and
recommenders currently
bigrams and
and multinomial
goodman 3
of multinomials
sentence similarity
nec com
top features
document in
each document
test data
the web
the document
documents in
document number
next document
lawrence giles
each cluster
em algorithm
document d
correlation and
a maximum
probabilistic models
the height
the bins
requests per
correlation maxent
related clusters
who viewed
and dependencies
more all
markov terms
merge fig
term interactions
470 000
of researchindex
for researchindex
all recommenders
document accesses
model long
on same
bins 1
the maxent
2000 correct
greedy clustering
all bigrams
s nc
over 470
researchindex we
recommenders and
merge recommender
in h
the training
of clusters
searching the
documents and
different clusters
interactions and
the maximum
candidate set
model p
the em
search engines
data sequences
recommendations for
hit ratios
currently available
the user
height of
steve lawrence
as correlation
recommendations in
wide web
world wide
predictions of
our models
on user
models in
the top
worth of
single component
section iii
the clusters
of ordered
related documents
high dimensional
of similarity
make predictions
same site
model based
the clustering
clustering based
using maximum
document we
the similarity
all documents
the coverage
for clustering
the cluster
models we
long term
the test
mixtures of
data set
the bigrams
all similarity
maxent learning
document details
recommending system
ps gz
ratios the
and reasonably
all docs
months worth
visited document
multmix 60
average heights
60 comp
maxent model
from researchindex
http citeseer
our expectation
citeseer nj
models correlation
lawrence98searching html
researchin dex
entropy maxent
multinomial mixture
bigram counts
l giles
were users
markov 1
user accesses
based recommendation
generating online
s lawrence
models learned
researchindex recommenders
user document
recommender in
combining predictions
is correlation
recommenders in
nj nec
of maxent
is unassigned
lawrence and
similarity based recommenders
the maximum entropy
d next h
maximum entropy model
of document requests
maximum entropy models
mixture of markov
p d next
a maximum entropy
the mixture of
maximum entropy approach
d next d
next d next
of markov models
a mixture of
sequences of document
individual similarity based
first order markov
the current document
the similarity based
mixture of multinomials
based recommenders currently
mixture of multinomial
of multinomial models
and the researchindex
of ordered sequences
requests per user
the researchindex merge
the average height
similarity based predictors
markov and multinomial
the test data
correlation and the
the history h
searching the world
in the history
order markov terms
recommenders with respect
researchindex merge fig
and dependencies in
interactions and dependencies
long term interactions
collection of ordered
multinomial models in
the researchindex data
model long term
the data sequences
the top features
average height of
on user navigation
c d next
document requests for
term interactions and
recommenders currently available
researchindex merge recommender
using maximum entropy
available in researchindex
the bins 1
on same site
bins 1 5
in researchindex a
users who viewed
documents in h
over 470 000
and multinomial models
for the bins
all d next
ordered sequences of
topically related clusters
height of predictions
the training data
the em algorithm
based on user
document in the
number of documents
1 5 10
the next document
a single component
dependencies in the
world wide web
of the best
number of clusters
the documents that
5 10 and
the candidate set
as a collection
on the web
for each document
using the em
the world wide
clustering based on
requests for the
the documents in
for all d
predictions of the
the same cluster
is the best
the number of
features for some
maximum entropy the
observed document in
the requested document
recommenders with similar
researchindex merge the
http citeseer nj
document number h
d next is
history h we
c l giles
documents that occurred
greedy clustering algorithm
ratio of hits
entropy model to
entropy approach with
contains over 470
maxent multmix 60
last observed document
distribution p d
document number t
for all recommenders
months worth of
sequence of document
model p d
low order statistics
the last observed
lawrence and c
document details page
computer science papers
models learned in
user navigation patterns
volume web servers
to model long
entropy approach to
were users who
next h can
component markov model
or first order
our expectations the
for maximum entropy
collaborative filtering and
markov 1 comp
h p c
60 comp researchindex
entropy maxent approach
correlation maxent multmix
with our expectations
be a maximum
nj nec com
all recommenders and
there were users
single component markov
generating online recommendations
currently available in
results and comparisons
model based collaborative
a novel maximum
learned in different
conditional maximum entropy
mix of markov
comp researchindex merge
d next c
giles searching the
by assessing the
history h as
citeseer nj nec
p cluster h
a document details
maximum entropy maxent
with maximum entropy
approach for generating
number of document
typical screen shot
bigrams or first
and reasonably fast
used in researchindex
regular markov model
d prev d
recommendations in researchindex
of similarity based
our maxent model
predictions for all
all similarity based
for the mixture
of hits to
probabilistic model p
for generating online
high volume web
the document number
the bigram counts
the markov and
within the bin
prev d next
models correlation and
document in h
our maximum entropy
nec com lawrence98searching
com lawrence98searching html
the six engines
page in researchindex
offline experiments on

corpus/krapavin2000-test/1038162.txt
privacy
byclass
salary
perturbed
reconstruction
attribute
randomized
training
classifier
accuracy
split
records
mining
reconstructed
randomization
gaussian
gini
width
intervals
bfos84
interval
reconstruct
perturbation
reconstructing
discretization
security
disclosure
distributions
statistical
age
50k
confidence
cs76
wes99
respondents
qui93
aw89
unperturbed
mid
distortion
willing
classification
95
randomizing
posterior
protection
2ff
concerns
confidential
plateau
ffl
growth
databases
classifiers
users
correcting
preserving
ipn
75k
off98
war65
fis63
mar96
hyears
elevel
digitalme
triangles2006001000
passport
ecb99
zipcode
attributes
density
theta
decision
hvalue
150k
divulge
web
fx
estimated
uniform
10k
uniformly
credit
swapping
categorical
risk
secure
tributes
iid
estimate
partition
tree
denominator
statistics
fy
suppression
queries
partitioning
induce
marginally
inducing
cumulative
999
distribu
realizations
splits
surface
perturbations
quantifying
pr
noise
axis
person
query
bias
mutually
sensitive
estimates
100
belonging
record
ip
lies
database
stopping
successive
goodness
sanen
tim97
mst94
impetus
hesitation
sam96
hs99
cm96
wor
cranor
bs97
den80
tomasz
lst83
resounding
hallway
fundamentalists
protective
uniform8090100
omniscience
sho82
yc77
freebies
diligently
tyw84
cox80
65k
uniform6080100
imielin
buried
djl79
gwb97
trainingdata
doxes
zipcodes
ehn96
jorma
economist
lcl85
eu998
truste
dds79
56080100
fel72
infrence
classifi
missioner
agr99
dominantly
randomize
rei84
bec80
ldv
cra46
26080100
aggregations
cra99a
dissociation
ben99
the98
seal
co82
eco99
snoopers
discretized
cubes
preventing
empirically
estimator
precision
closer
bayes
original distribution
decision tree
i p
split point
privacy level
statistical databases
of privacy
interval i
split points
the classifier
data mining
distributed from
100 privacy
perturbed training
byclass and
training data
the interval
original data
privacy preserving
records attribute
randomized data
value original
original byclass
byclass global
value distortion
accuracy privacy
growth phase
classification model
original randomized
accuracy original
level original
original accuracy
estimated with
an attribute
the reconstructed
reconstructing the
the original
and privacy
tree classifiers
privacy at
density function
the training
95 confidence
with 95
attribute value
willing to
a split
interval width
theta 2ff
induce decision
individual records
of respondents
reconstruction procedure
on salary
privacy protection
any closer
50 privacy
reconstruct distributions
for randomization
ffl may
theta oe
credit risk
bfos84 qui93
candidate split
local algorithms
random variable
the accuracy
of records
true value
value x
statistical database
the mid
the privacy
certain fields
at 25
perturbed data
mid point
the tree
be estimated
of interval
the classification
distribution we
each attribute
correcting for
privacy concerns
uniformly chosen
theta w
in accuracy
to original
uniformly distributed
width of
the posterior
accuracy of
x lies
by class
into intervals
true values
stop when
and local
the width
reconstruct the
an interval
functions 2
at 100
classification accuracy
reconstruction is
distribution function
data value
of width
should we
closer than
the randomized
f 0
the perturbation
distribution from
entire range
distribution as
data swapping
triangles2006001000 number
over randomized
privacy levels
95 theta
iid random
perturbed value
ffl byclass
theta salary
disclosure occurs
reconstructing original
accuracy numbers
successive estimates
gini index
adding noise
distortion return
five split
privacy offered
disjoint mutually
protection measures
global accuracy
gini split
do reconstruction
more privacy
than byclass
z ipn
reconstructed distribution
age 25
preserving methods
ffl should
67 theta
original distributions
query restriction
using perturbed
tree classification
preserving data
fields ffl
tree growth
data records
value drawn
privacy gaussian
users privacy
if privacy
value class
find five
decision surface
the byclass
randomized number
randomized reconstructed
in byclass
global randomized
000 records
gaussian provides
distributions separately
2ff 0
byclass for
fy for
being mapped
inducing the
we reconstruct
preserving privacy
family includes
net users
splits on
records belonging
partial disclosure
absolute of
salary 50k
reconstructed data
999 theta
online privacy
confidence any
randomizing function
quantifying privacy
successive queries
c confidence
tree classifier
uniform perturbation
look easy
perturbation of
a value
the distribution
the reconstruction
the original distribution
interval i p
uniformly distributed from
amount of privacy
byclass and local
value original randomized
records attribute value
classification model is
perturbed training data
accuracy privacy level
i p be
original byclass global
attribute value original
accuracy original byclass
privacy level original
reconstructing the original
of records attribute
number of records
decision tree classifiers
of interval i
be estimated with
a value x
cannot be estimated
with 95 confidence
the original data
of certain fields
any closer than
density function f
closer than an
density function over
the reconstruction procedure
than an interval
uniformly chosen from
the interval width
and local algorithms
willing to provide
entire range for
interval of width
at 100 privacy
estimated with 95
data by class
functions 2 and
close to original
values of an
of an attribute
for each attribute
of the original
2 i p
i p we
values of certain
the density function
partitioning the data
the width of
x 2 i
function over the
number of intervals
the training data
the true value
over the interval
function f 0
the random variable
interval in which
the interval in
the entire range
the accuracy of
separately for each
in data mining
triangles2006001000 number of
the privacy level
level original accuracy
original randomized number
original distribution from
induce decision tree
by a method
of statistical databases
distribution we consider
95 confidence any
confidence that a
original distribution and
theta w 0
certain fields ffl
the classification model
query e g
0 67 theta
go to s
a classification model
original randomized reconstructed
advantage of reconstruction
privacy at higher
value distortion return
reconstructing original distribution
that we reconstruct
result of inducing
original data even
point of interval
tree growth phase
quite difficult the
the reconstructed data
data even at
privacy the algorithms
more privacy at
decision tree classifier
realizations of n
randomized number of
should we do
of disjoint mutually
privacy preserving data
some distribution we
provide data to
shows the privacy
random variable has
original accuracy privacy
of decision tree
five split points
are quite difficult
67 theta salary
confidence any closer
ffl may not
points on salary
develop accurate models
byclass global randomized
in interval i
privacy preserving methods
using the reconstructed
these two distributions
are shown by
reconstruct distributions not
adding noise to
decision tree using
original distribution we
privacy offered by
decision tree classification
posterior distribution function
estimate the posterior
byclass for each
the points associated
ffl should we
records belonging to
of being mapped
true value cannot
building decision tree
split points on
reconstructed data ffl
split point that
theta 2ff 0
byclass global accuracy
0 999 theta
disclosure occurs if
until each partition
of inducing the
global accuracy original
value class membership
axis the accuracy
0 x 2
classifier has to
distributions separately for
an attribute are
stop when the
absolute of the
to interval i
privacy protection measures
distortion return a
ffl we approximate
being mapped to
preserving data mining
functions 4 and
and 50 privacy
0 5 theta
we reconstruct distributions
a split point
inducing the classifier
pr 0 x
the reconstructed distribution
distribution and stop
the tree growth
at 25 and
class and reconstruct
value x lies
by class and
the original accuracy
using randomized data
random value drawn
split the training
at higher confidence
0 95 theta
correcting for randomization
find five split
fields ffl may
a query e
of privacy at
candidate split point
value drawn from
100 privacy the
number of points
p be the
an interval of
estimate of the
p i e
the same class
the same distribution

corpus/krapavin2000-test/1038204.txt
views
greedy
benefit
warehouse
indexes
ao
materialized
query
dag
monotonicity
quantity
interchange
arc
occupied
selection
sinks
oe
maintenance
cubes
queries
inner
absolute
graphs
units
wrapper
updates
63
achievable
2s
olap
ig
stage
costs
binds
outgoing
vh
dags
heuristics
materialization
cfn77
update
minimizes
viz
sales
hru96
ff
answering
occupies
occupying
cube
edges
interchanging
467
competitive
stages
constraint
index
fi
warehousing
ary
heuristic
frequency
select
monitor
subgraph
selected
ancestors
md
descendants
expression
incurred
optimizer
cover
my
edge
till
benefits
unit
zgmhw95
ghru96
ik93
quency
cm82
sel88
interatively
nonsink
rdb
wid95
cornuejols
rss96
algrorithm
x2ma
rou82
x2md
fei96
multiobjective
gm95
harinarayan
semicircle
subgraphs
distributing
genetic
occupy
children
response
node
optimize
selecting
specifier
unanswered
integrator
fre
feige
automobiles
vms
contructing
incremental
generalize
label
deliver
manager
plan
om
materialize
subsection
facility
binding
gamma
cheapest
ic
arcs
disjoint
polynomial
depicts
behaves
roussopoulos
multiplying
aggregate
maintaining
advisor
approximability
warehouses
maintained
sources
acyclic
ka
competitiveness
powerset
ullman
merging
iff
produces
satisfies
thought
metadata
accessing
dimen
float
skipping
administrator
structures
encouragement
2r
descendant
intersection
noteworthy
approximated
guarantee
subexpressions
jeff
halts
surely
bipartite
operator
exceeds
trading
contradiction
omit
ignore
prof
augmenting
ancestor
delivers
lawrence
bank
evolutionary
insightful
associate
simplied
sions
breakdown
spaces
looked
kn
lems
motivation
np
repository
incurs
sql
view graph
or view
view selection
of views
greedy algorithm
view graphs
an and
and view
query view
selection problem
benefit per
level greedy
unit space
the benefit
absolute benefit
the view
with indexes
the greedy
benefit of
an or
view v
benefit function
quantity s
a view
data warehouse
per unit
monotonicity property
inner level
update costs
graph g
its indexes
views in
and or
without updates
optimal benefit
space occupied
the monotonicity
and arc
greedy interchange
expression ao
achievable using
ao greedy
benefit achievable
interchange algorithm
views m
of space
of structures
algorithm 3
units of
materialized views
much space
s units
solution m
a quantity
ao dag
whose benefit
total query
the absolute
occupied by
the views
data cubes
g l
m that
a query
most s
of materialized
selected views
space constraint
total space
function b
b satisfies
view has
maximum benefit
a dag
using as
uses at
outgoing edges
is at
quantity g
warehouse is
the warehouse
maintenance cost
dag for
warehouse we
2s units
ig i
indexes in
by m
o i
the optimal
algorithm algorithm
property for
m is
expression a
that used
f i
most 2s
v oe
c selected
0 63
query response
the inner
selection in
view and
node u
each stage
b v
views to
space as
set cover
the ao
view maintenance
any view
graph with
selection of
that minimizes
constraint that
any m
algorithm produces
the cost
already selected
m under
space also
each view
a solution
a data
select a
label i
no updates
indexes for
base relations
indexes and
space with
m with
node view
arc binds
structures selected
greedy manner
incremental benefits
given quantity
views u
materialized view
total maintenance
view u
r level
occupies more
v ff
time heuristics
each o
in g
each and
performance guarantee
set o
i consists
a node
the queries
the constraint
computed from
an expression
cost associated
greedy heuristic
g m
the and
to m
problem given
in m
than s
least 1
query q
an index
supported at
views that
m assuming
arc has
computing u
1 gamma
graph for
view in
u from
graph in
of v
problem in
heuristics for
63 of
multiple query
arbitrary sets
o such
intersection graph
as much
minimizes the
selected in
and and
the set
see algorithm
e times
graph without
data cube
minimum set
g without
running time
or view graph
and or view
set of views
view selection problem
and view graph
the view selection
view graph g
per unit space
an and view
benefit per unit
level greedy algorithm
units of space
absolute benefit of
the absolute benefit
an or view
an and or
the benefit function
or view graphs
query view graph
inner level greedy
the monotonicity property
in an and
the greedy algorithm
selection problem in
m is at
the inner level
a quantity s
a data warehouse
space occupied by
monotonicity property for
benefit of m
a query view
the optimal benefit
greedy interchange algorithm
as much space
graph with indexes
benefit achievable using
view graph with
used by m
optimal benefit achievable
much space as
using as much
achievable using as
space as that
selection of views
s units of
of its indexes
a solution m
ao greedy algorithm
as that used
total space occupied
unit space of
view graph for
solution m that
m that uses
of views in
greedy algorithm algorithm
expression ao dag
the benefit per
and a quantity
satisfies the monotonicity
algorithm algorithm 3
benefit function b
under the constraint
the benefit of
that uses at
of materialized views
algorithm 3 3
at most s
is at least
that used by
select a set
greedy algorithm produces
and view graphs
quantity s the
a view and
also the absolute
view selection in
each and arc
expression a dag
of views m
maximum benefit per
function b satisfies
the views in
any m with
total query response
b satisfies the
occupied by the
constraint that the
the total space
produces a solution
uses at most
m with respect
the maximum benefit
gamma 1 e
respect to m
of a view
1 gamma 1
of the view
query response time
benefit of the
g l is
be computed from
the ao greedy
view and some
updates the benefit
at the warehouse
minimizes the quantity
benefit of c
and and and
in an or
m under the
view graphs in
with indexes and
without updates and
a label i
updates and a
whose benefit per
problem in and
set of structures
g m under
unit space with
a view v
without updates the
view graph in
quantity g m
m that minimizes
an expression ao
view graphs we
2s units of
by the views
most 2s units
the quantity g
o g l
of space also
query view graphs
the constraint that
algorithm produces a
algorithm 3 1
of the optimal
in m is
property for any
graph g and
for any m
satisfy the monotonicity
at most 2s
times the optimal
the greedy interchange
set c selected
space also the
space with respect
of m is
is the cost
set of queries
least 1 gamma
in a data
at each stage
the set o
l is at
by the greedy
of the set
the set of
graph in this
that minimizes the
associated with it
that the total
some of its
g and a
a node u
i consists of
in or view
the selected views
unit space is
has an operator
data warehouse we
b v m
o i consists
minimum set cover
view graphs with
time heuristics for
of computing u
given a quantity
cost function associated
each o i
in a greedy
given quantity s
by m assuming
the space constraint
see algorithm 3
of structures selected
computing u from
the r level
and arc has
view graph and
g without updates
of views that
respect to arbitrary
in query view
of views u
algorithm given g

corpus/krapavin2000-test/1039213.txt
ele
game
player
games
agent
payo
equilibrium
learning
payos
agents
nash
players
pareto
reward
prole
monitoring
adversary
policy
reinforcement
payments
irrational
imperfect
maximin
rewards
economically
stochastic
action
normative
punishment
cient
actions
rationality
joint
played
play
g2
g1
deviate
perfect
attain
repeated
rational
folk
multiagent
deviates
mix
ai
equilibria
mixing
denition
punish
theorists
bowling
cooperative
converge
descriptive
convergence
defect
histories
plays
rg
veloso
economics
bayesian
stick
cooperate
policies
deviation
resp
prescribed
shneidman
parkes
xed
polynomial
ciently
whom
ciency
probabilistic
social
stipulates
monetary
settings
spirit
surplus
playing
payoff
history
strategies
payment
adopt
articial
rst
knows
adopted
modied
maximizes
dened
shot
justied
strategic
quickly
dierent
stationary
behave
economic
online
outcome
response
matrix
individually
initially
max
jeffrey
mixed
dierences
people
motivation
attained
unknown
covergent
deviators
conitzer
rby
thuc
unplayed
irrationality
deviator
enforceable
knowng
noncooperative
vorobeychik
fassumed
awesome
deviating
tuomas
polynominal
satinder
punishing
ramications
osprings
groves
undiscounted
iterations
paid
complements
interactions
technically
67
dynamics
themselves
associates
learns
visit
learn
adopting
existence
appealing
yevgeniy
boella
conver
vickrey
devoid
leendert
torre
pretend
prisoner
decreased
setting
termed
rigorous
strict
dene
designer
equated
opponents
wellman
shoham
faithfulness
psychology
instructed
sandholm
nv
nding
exploration
average
accomplish
autonomous
uncertainty
yoav
paramount
foe
ages
outset
vu
pv
gence
recommending
guido
incentive
utility
the game
stochastic games
repeated games
player 1
the agents
imperfect monitoring
policy prole
average reward
player 2
pareto ele
an ele
perfect monitoring
nash equilibrium
for player
learning in
learning equilibrium
e cient
the players
joint action
reinforcement learning
the agent
a nash
a game
learning algorithms
a policy
game is
economically e
the adversary
cient learning
probabilistic maximin
learning algorithm
in games
of repeated
equilibrium of
a pareto
both players
repeated game
game g
monitoring setting
side payments
the learning
games with
r max
equilibrium in
multi agent
t mix
game matrix
adversary s
game in
an agent
each agent
other player
other agent
game theory
a learning
a deviation
ele in
payos in
of rewards
games is
the payo
s payo
ele for
normative approach
in equilibrium
reward of
of games
return mixing
best response
agent i
agents will
all agents
average sum
to deviate
mixing time
the player
possible histories
in stochastic
of learning
of actions
common interest
expected payo
maximin value
its payo
monitoring we
algorithms themselves
payo obtained
the ele
ele algorithm
agent initially
xed sum
ele does
initially plays
of ele
game m
the payos
always play
converge to
agent s
sum game
in repeated
agent 1
the rewards
agent reinforcement
equilibrium and
of pareto
this policy
player s
non cooperative
the denition
to learning
games in
on learning
machine learning
the policy
desired value
a repeated
of possible
rg m
sum stochastic
payos obtained
individually rational
and player
payo it
game theorists
players play
strict imperfect
ele where
equilibrium a
nash ele
prole that
self play
equilibrium ele
a normative
folk theorems
both agents
in economics
game associated
ele is
monitoring case
bowling and
ele exists
equilibrium had
and veloso
its agent
deviate from
adversary will
is played
in ai
known the
games and
agent to
player can
an economically
if player
general sum
the imperfect
games the
stick to
by agent
initially unknown
in game
adopted by
of convergence
t 0
g1 and
a player
the perfect
polynomial in
e ciently
the return
no agent
ai and
s actions
of equilibrium
deviates from
behave according
the probabilistic
the spirit
policy for
spirit of
times if
always exist
the expected
actions and
the action
its action
e ciency
work on
1 resp
bayesian approach
in machine
for agent
for learning
denition in
polynomial number
with perfect
agent will
learning v
agent can
a nash equilibrium
of repeated games
economically e cient
e cient learning
the learning algorithms
cient learning equilibrium
learning in games
for player 2
a pareto ele
the other agent
a policy prole
in the game
the game is
the other player
return mixing time
normative approach to
the probabilistic maximin
sum of rewards
average reward of
of possible histories
in stochastic games
perfect monitoring setting
reinforcement learning in
in a nash
average sum of
on learning in
equilibrium of the
approach to learning
the agents will
in repeated games
of an ele
the average reward
ele does not
learning algorithms themselves
adversary will always
of the players
probabilistic maximin value
the ele algorithm
the policy prole
a repeated game
the agent initially
the return mixing
agent initially plays
agent reinforcement learning
in a game
will always play
for player 1
the expected payo
be in equilibrium
repeated games with
nash equilibrium of
the adversary s
to learning in
if the agent
work on learning
a learning algorithm
case of repeated
on its own
the adversary will
learning equilibrium ele
games with perfect
ele in the
stochastic games is
player can observe
which an ele
a game in
bowling and veloso
to deviate from
the game matrix
not always exist
known the game
always exist in
xed sum game
the perfect monitoring
nash equilibrium had
if player 1
an ele does
sum stochastic games
learning v 67
adversary s payo
stick to their
game associated with
in non cooperative
strict imperfect monitoring
learning research in
perfect monitoring we
the joint action
the game g
payo obtained by
a normative approach
an ele exists
an economically e
if the game
repeated game m
have obtained in
the imperfect monitoring
with perfect monitoring
of pareto ele
converge to a
of a policy
in the imperfect
a policy for
that the game
a deviation from
mixing time of
multi agent reinforcement
in game theory
game in which
the learning algorithm
in machine learning
that the agents
the agent will
set of possible
the spirit of
behave according to
of the game
of multi agent
67 n 1
an e cient
existence of an
of actions a
of a learning
t t and
in multi agent
obtained in a
a polynomial number
deviation from the
polynomial number of
machine learning v
number of steps
of the adversary
to the value
multi agent systems
the agent s
v 67 n
the case of
all joint actions
with k actions
be economically e
both players play
only equilibrium of
player 2 is
pareto ele is
to their algorithms
the second action
its aim is
near optimal reinforcement
game theory literature
an ele in
player 1 plays
agents stick to
multi agent interaction
to r max
rewards are based
of games in
of strict imperfect
in an imperfect
parallel to that
every t t
learning in general
the actual game
discuss the extension
stochastic games stochastic
agent i in
imperfect monitoring settings
to general sum
algorithms in computer
each agent can
called folk theorems
1 deviates from
learning in cooperative
of reinforcement learning
joint actions have
had they known
theorems in economics
other player the
any perfect monitoring
equilibrium if for
will attain a
a perfect monitoring
game is g2
a game we
corresponding rg m
player 1 deviates
imperfect monitoring the
s average reward
by the players
t and game
1 denoted cooperate
long term average
failure of at
denition for player
in that equilibrium
and its payo
action leading to
folk theorems in
punishment can be
general sum stochastic
and player 2
speed of convergence

corpus/krapavin2000-test/1039285.txt
ground
stabilization
stabilizing
self
chains
inactive
chain
oe
rewrite
br
dershowitz
fw
word
derivations
infinite
substitution
hoepman
derivation
transducer
soe
fidg
debas
string
1st
configurations
sigma
beauquier
top
rewriting
substitutions
legitimate
reducible
unification
ring
inact
convergence
cyclic
ghosh
termination
ds
gamma
wn
rules
resp
reductions
iff
dr
xry
w0g
rule
quasi
successors
minimally
middle
active
configuration
successor
unifiers
lefthand
labelled
xr
righthand
terminating
reduction
act
letter
proving
substring
compositionality
delta
infinitely
0m1
pqr
nonvariable
overapproximation
w20
t4
minimal
preserving
instantiations
schemes
uw
rings
rightmost
tops
old
dijkstra
m1
vn
strictly
regular
id
generalized
ug
languages
bottom
x10y
x11y
0121
2wg
x01y
0wg
lwm
belated
simplifiers
xpqry
commutation
uwv
tribulation
tm1
neighbouring
generalization
exercise
strings
orientation
fairness
transitions
norm
subareas
toe
triumph
1022
election
breaks
spite
xn
adapts
nonnull
generation
wa
proves
herman
demon
1012
delimited
appearing
leftmost
narrowing
subword
transducers
sequences
disregard
henceforth
ending
replacing
decreases
associativity
upwards
cycle
counterpart
discarded
remark
3g
manipulates
terminate
proposition
letters
accepted
upward
od
hs
passing
perspectives
pq
focusing
reaching
exhibiting
iteratively
replaces
3a
modulo
lifting
leader
suffix
norms
disappear
deadlock
2g
0g
l1
lemma
positions
instanciated
2021
legitimitate
22w
2012
1693
ssertional
orities
x01ay
fwg
0act
0100
pathes
unwvn
withfwg
1x2
w12
1003
via s
self stabilization
self stabilizing
top chain
ground word
ground derivation
1st order
gamma gamma
a ground
minimal reduction
top rule
infinite ground
rewrite systems
derivation via
w 0
string rewrite
top chains
quasi cyclic
of self
stabilizing systems
no infinite
reducible via
first order
regular languages
is self
rule r
top s
over words
act gamma
a top
dr fidg
order scheme
chain generation
infinite derivation
inactive steps
2 dr
using fw
or oe
beauquier debas
s 0
a substitution
word w
a rule
scheme s
r oe
via r
using oe
system s
via m
proving convergence
stabilizing w
cyclic top
minimal reductions
over schemes
a 1st
gamma top
soe r
generalized successor
infinite derivations
6 id
ground scheme
state algorithm
substitution oe
edge labelled
s gamma
s is
s old
a rewrite
the form
rewrite system
oe 6
any infinite
strictly decreases
of s
an infinite
for rule
i new
oe 2
middle rules
minimal top
ghosh s
ring orientation
legitimate configurations
reduction chains
no quasi
chain over
derivation delta
substitutions oe
prove self
inact gamma
word t
r t
rewriting systems
of legitimate
dershowitz s
norm function
r using
word is
of words
active area
rule t
infinitely often
l 2
a finite
termination of
order word
string rewriting
br preserving
ground substitution
reduction chain
fw w0g
by dershowitz
fw w
inactive area
of inactive
middle rule
variable words
bottom rule
top rules
generalization process
closed via
br is
y xry
generalized as
hoepman s
active ground
derivations over
the transducer
chain via
top letter
cycle property
successor via
minimally reducible
reduced form
order variables
generation procedure
w r
finite number
the convergence
graph construction
same length
rule of
starting from
is reducible
the string
non increasing
oe 0
some ground
regular sets
labelled r
62 l
rule at
is terminating
l iff
form u
of rules
an instance
iff there
rules of
of sigma
0 r
that strictly
3 state
of configurations
for proving
of top
a measure
the graph
of chains
t r
a scheme
m 4
form w
rule e
graph rewriting
no cycle
s 2
the word
of minimal
dershowitz for
s infinitely
infinite path
each ground
stabilizing iff
unification problem
for beauquier
of breaks
own generalized
new s
reaching l
infinite chains
from words
of ghosh
debas system
stabilizing ring
over regular
gives generalized
stabilization an
old s
chains over
a ground word
is self stabilizing
of the form
of self stabilization
is no infinite
s is self
self stabilizing systems
infinite ground derivation
ground word w
derivation via s
string rewrite systems
act gamma gamma
t r oe
oe 2 dr
stabilizing w r
quasi cyclic top
2 dr fidg
oe 6 id
via s 0
s gamma top
ground word is
a top rule
self stabilizing w
r using oe
via r using
a 1st order
r t l
system s 0
of self stabilizing
of a ground
cyclic top chain
an edge labelled
prove self stabilization
an infinite ground
no quasi cyclic
of legitimate configurations
inact gamma gamma
rewrite system s
is reducible via
gamma top s
a top chain
a ground scheme
to prove self
rule of s
ground derivation via
top rule t
there is no
w r t
gamma gamma gamma
to l 2
a rewrite system
a finite number
finite number of
top chain via
active ground derivation
one variable words
ground derivation delta
a substitution oe
is closed via
x y xry
edge labelled r
is no quasi
exercise in proving
soe r t
no cycle property
s is terminating
s i new
via m 4
1 using fw
1st order scheme
3 state algorithm
closed via s
chain via s
the reduced form
substitution oe 2
that s gamma
a middle rule
top s is
the form u
a norm function
l is closed
a first order
an instance of
a rule of
is an instance
iff there is
a self stabilizing
an exercise in
the same length
after a finite
words of the
all the possible
is made of
for proving convergence
infinitely often except
of minimal reduction
convergence of self
any infinite derivation
stabilizing ring orientation
accepted by t
0 or oe
gives generalized as
is its own
minimally reducible via
generalized successor of
self stabilizing ring
scheme s and
rule r x
gamma gamma t4
self stabilization in
the convergence proof
regular languages is
for self stabilization
rule r and
system is self
old s old
on self stabilization
self stabilizing iff
measure that strictly
l iff there
configuration of l
made of rules
of reduction chains
via a rule
number of inactive
that strictly decreases
s are applied
middle rule r
beauquier debas system
its own generalized
a rule at
for beauquier debas
new s old
t l iff
fw w 0
ground cyclic derivation
first order rewriting
is no ground
word is an
each ground word
w 0 r
first order scheme
to a ground
a generalization process
gamma gamma w
oe 0m1 oe
l 2 this
no infinite path
generalized successor via
generalized minimal top
set of substitutions
rule at an
the form fw
or oe 0m1
of inactive steps
number of breaks
example for rule
the generation procedure
top s infinitely
s 4 state
proof of self
own generalized successor
no ground cyclic
s infinitely often
sigma and w
n old s
1st order variables
which gives generalized
i new s
or oe 0
the no cycle
no infinite loop
to 3 rules
reducible via s
chain over words
element of sigma
oe 0 or
rule t as
of ghosh s
the form x
f f f
as an input
s to n
by t r
n s to
is a generalized
self stabilization of
obtained from t
at the scheme
applying a rule
reduced form of
set of legitimate
is a top
from n s
self stabilizing algorithm
from t by
of a top
the scheme level
scheme s is
a substitution is

corpus/krapavin2000-test/1039329.txt
quantum
pir
ldcs
decodable
decoder
ldc
server
trevisan
query
codes
classical
codeword
queries
lqdc
pirs
qubit
bit
katz
lqdcs
smooth
xor
cj
ja
answers
locally
ju
beimel
recovery
decoding
randomness
corrupted
private
bits
recover
ji
retrieval
ldec
goldreich
qubits
j0i
1g
servers
codewords
probability
positions
bounds
measurement
f0
outputs
hadamard
outcome
j1i
entanglement
rst
nayak
ldecs
obata
qpir
gasarch
extractors
alphabets
exponential
code
unitary
pcps
semidenite
jji
jbi
hyer
correcting
workspace
schemes
string
2q
0j
subexponential
log
pr
answer
strings
recovered
superposition
ib
pure
queried
amplitudes
ist
correctors
ashwin
publishable
j0ij1i
beigel
chor
multioracle
bitvectors
jcijji
gisin
orthonormal
don
communication
denition
polynomials
j1
alphabet
klauck
fortnow
interrogation
oracle
sends
amplitude
adaptively
tuple
buhrman
j0
copies
bpp
hj
jbj
erasure
success
signicantly
2g
smoothness
tuples
mann
exptime
parity
ln
disjointness
y2
mixed
j2
random
lemma
reduction
polylogarithmic
bx
adaptive
inner
alice
pseudorandom
sen
guess
averaging
privacy
n1
gf
extract
density
y1
bob
luca
fraction
operators
binary
hamming
ce
secret
averaged
xed
querying
round
membership
evolves
straightforwardly
certainty
tensor
getting
resilient
reals
appendix
somewhat
subsystems
cryptography
agreement
uniform
hiding
indices
uncorrupted
bitpositions
jjihjj
renner
resq
fet
jcss
wehner
jcijjij0i
jri
superpolynomial
cj2a
37559
ijbi
sasson
hji
pranab
gkst
queryp
0524
tradeos
postdoc
server pir
locally decodable
2 server
a quantum
recovery probability
pir scheme
decodable codes
smooth code
private information
bit answers
pir schemes
access code
lower bounds
2 query
x i
ju x
the quantum
the decoder
decodable code
random access
quantum random
ja x
bounds for
best known
lower bound
and trevisan
classical 2
query ldcs
the xor
1 bit
exponential lower
ldcs with
quantum pir
recover x
katz and
quantum query
communication complexity
information retrieval
xor of
the codeword
a q
1 query
t bit
query locally
with probability
a classical
c x
a ja
bit queries
q tuple
classical queries
scheme with
bound for
2 classical
m qubit
f0 1g
known classical
beimel et
smooth codes
server pirs
goldreich et
trevisan 21
quantum decodable
query ldc
ldc is
1 quantum
query lqdc
a 2
q queries
one quantum
2 servers
log m
11 14
of ldcs
classical pir
quantum decoder
quantum queries
c smooth
density matrix
state ju
answer length
control bit
locally quantum
pirs with
decoder s
probability 1
log n
the server
for 2
q 1
q 2
state ji
one query
basis states
quantum computing
and quantum
qubit state
to recover
n bit
answers and
success probability
the user
outputs 1
decoding algorithm
y m
bit strings
the classical
q tuples
quantum argument
s randomness
a pir
query lqdcs
with recovery
hadamard code
corrupted in
corrupted codeword
adaptive queries
any bit
pir with
queried bits
2 ldc
classical proof
bit x
known ldcs
quantum server
code then
the hadamard
of queries
queries to
et al
bits of
our lower
o n
for classical
i with
server s
code is
the best
quantum state
quantum computer
recovered with
ji is
q locally
for quantum
of katz
known upper
m bit
bit string
the rst
the bits
a bit
is corrupted
of quantum
user sends
our 2
1g m
bounds in
with 1
f a
positions of
our proof
for x
better lower
two queries
the measurement
can recover
improved the
the probability
upper bounds
extend our
schemes with
2 f0
2 queries
optimal lower
bound on
the 2
probability 11
good q
same randomness
an ldc
and j1i
pure states
larger answers
classical decoder
binary 2
from ju
bit answer
ja ib
pure state
strings x
quantum 2
perfect recovery
about i
j0i and
non adaptively
decoder just
polynomial lower
ldcs over
exactly 11
katz trevisan
2 server pir
private information retrieval
random access code
locally decodable codes
ju x i
server pir scheme
pir scheme with
quantum random access
1 bit answers
lower bounds for
the best known
classical 2 server
ja x i
katz and trevisan
the xor of
a quantum random
exponential lower bound
locally decodable code
recover x i
for 2 query
lower bound for
1 a ja
2 query ldcs
a ja x
query locally decodable
with 1 bit
t bit queries
x i with
of the codeword
is a q
bit answers and
goldreich et al
one quantum query
bounds for 2
beimel et al
to recover x
with t bit
2 query locally
best known classical
server pir schemes
xor of the
communication complexity of
o n 1
ldc is a
where the decoder
scheme with t
locally quantum decodable
c smooth code
a q c
and trevisan 21
the decoder s
to 1 quantum
pir schemes with
state ju x
bound for 2
the communication complexity
number of queries
that the decoder
best known ldcs
2 server pirs
a classical proof
decodable code then
a 2 query
is the xor
code for x
with recovery probability
ldcs with q
q c smooth
bit x i
a classical 2
server pir with
a s y
and recovery probability
1 query lqdc
the recovery probability
a bit answers
access code for
a pir scheme
a quantum argument
known upper bounds
the control bit
2 classical queries
k 2 servers
n 3 10
2 query ldc
lower bound on
is a 2
code is a
of katz and
n bit strings
bound for 1
a 1 query
the user sends
be recovered with
an exponential lower
better lower bounds
than the best
i with probability
2 f0 1g
the bits of
m y m
complexity of set
f0 1g m
1 a 2
positions of the
best known upper
optimal lower bounds
output is the
all x and
upper bounds for
with probability 1
we can reduce
for x i
of the bits
n lower bound
least 1 2
lower bounds in
is a classical
bit strings x
1 quantum query
codes and private
extend our lower
recently improved the
server pirs with
i with good
for 1 query
the polynomial lower
to 1 reduction
smoothness of c
a smooth code
then for proof
decodable codes via
hadamard code is
code c 0
quantum 2 server
1 bit answer
1 query lqdcs
exactly 11 14
codewords c x
recovery probability is
information retrieval in
c x j
communication complexity o
same randomness as
a corrupted codeword
improve the polynomial
code then for
the log m
codes via a
recovered with probability
over the user
of 2 server
answers and recovery
classical lower bounds
classical and quantum
known classical 2
bits of x
a 2 ldc
probability of output
a good q
for locally decodable
a quantum 2
the same randomness
and private information
from ju x
the exponential lower
the hadamard code
q locally decodable
quantum decodable codes
some constant depending
j0i and j1i
our 2 to
a 2 locally
information retrieval pir
a locally decodable
quantum decodable code
decodable codes and
best known bounds
schemes with 1
via a quantum
polynomial lower bounds
good q tuple
user s randomness
randomness as the
is corrupted in
can recover x
probability 11 14
than 2 queries
depend on i
bit queries and
qubit state ju
a q locally
2 locally decodable
for all x
complexity o n
et al 8
et al 20
probability 1 2
more than 2
we extend our

corpus/krapavin2000-test/1039333.txt
distortion
bartal
metric
metrics
ws
steiner
metrical
log
cut
hsts
embeddings
approximating
embedding
laminar
approximation
cuts
competitive
trees
separates
center
spaces
stretch
outerplanar
settles
mendel
charikar
hk
vertices
spanning
labeling
0105533
wuv
tree
cluster
planar
polylog
probabilistically
edge
hst
polylogarithmic
settle
permutation
graphs
buy
rabinovich
minors
expectation
vertex
shall
hierarchically
gave
unassigned
decomposition
centers
konjevod
bourgain
talwar
ckr
separator
rao
probabilistic
italic
bulk
online
placement
chekuri
earthmover
radius
conquer
separated
alon
erent
clustering
pr
server
d0
yair
linial
tardos
packing
seymour
rabani
ccr
min
family
karp
unfair
multicommodity
dia
euclidean
deterministic
aggregation
improves
dominating
lectures
algorithmic
hierarchical
w2
flow
dual
adversaries
w1
routing
diameter
vn
matthias
ratios
oblivious
ravi
arrange
v2
volume
clusters
arc
london
rounding
covering
vehicle
inf
came
concurrent
v1
fee
decompositions
doublings
englert
derandomized
58113
0006
derandomization
myampersandell
manor
ramsey
expec
aumann
derandomize
mour
burch
heirarchically
fractionally
sey
bollobs
manthey
9820897
harrelson
rcke
karlo
mimimum
multiembedding
dpst
metrices
thicknesses
logarithmic
showed
pick
rectangle
dominate
children
feedback
mobile
conditional
nsf
queueing
di
gupta
permission
tomkins
fakcharoenphol
pute
matousek
harald
roughgarden
archer
newman
salman
bla
telescope
distance
gap
singleton
excluded
geometry
shaded
cooperative
azar
diameters
wk
stoc
mat
calinescu
conducive
metic
anupam
scholarship
921
probability
distances
assigned
game
prefix
u v
log n
o log
tree metrics
level i
at level
d u
v d
approximation algorithms
metrical task
separates u
log log
approximation algorithm
metric spaces
cut decomposition
n log
d t
d i
metric labeling
the distortion
an o
v is
k u
n approximation
k server
2 i
edge u
hk u
laminar family
distortion of
with distortion
distortion o
group steiner
steiner tree
i separates
spanning trees
v at
t u
d v
bartal s
stretch of
finite metric
distribution over
a tree
by tree
log k
the expected
metrics by
our result
metric v
w cuts
center w
tree metric
buy at
hierarchical cut
at bulk
cuts u
server problem
expected stretch
graphs into
min sum
in d
task system
bulk network
result improves
charikar et
n competitive
network design
k log
i 1
embeddings of
expected cost
of vertices
outerplanar graphs
0 extension
approximating arbitrary
we shall
well separated
and v
u and
log 2
algorithms for
pr u
task systems
competitive ratio
approximation for
is at
on approximating
dual problem
a distribution
can settle
ccr 0105533
settle u
cut u
topology aggregation
v ws
that center
covering steiner
17 showed
ws d
u out
u ws
center v
planar metrics
and mendel
communication spanning
center l
max flow
probability that
factor approximation
deterministic algorithms
and rabinovich
metric by
algorithmic applications
over tree
probabilistic approximation
particular level
a laminar
steiner points
the metric
the probability
the edge
assigned to
metrics a
arbitrary metrics
hierarchically well
conditional expectation
labeling problem
extension problem
edge at
arc set
the permutation
most d
v u
time approximation
approximating a
improved approximation
flow min
to o
min cut
its algorithmic
al 17
this level
each edge
that d
of u
random permutation
closer than
the approximation
expected value
to w
constant factor
of embedding
gave an
of graphs
distortion and
approximating min
cuts trees
competitive concurrent
online tracking
approximating packing
rabinovich 37
v closer
chekuri et
as metrical
w1 w2
wuv d
steiner problem
settles e
a polylog
for unfair
bartal 7
hsts bartal
of bartal
via trees
factor came
distortion embedding
hsts a
on hsts
distributed queueing
probabilistic embedding
n distortion
probabilistically approximates
k outerplanar
cost spanning
linial london
k clustering
bartal and
over dominating
ws is
excluded minors
each shaded
k hsts
london and
v gets
polylogarithmic competitive
for metrical
dominating tree
being cut
theoretic game
at level i
o log n
d u v
an o log
u v is
log n log
d t u
v is at
separates u v
t u v
is at level
approximation algorithms for
n log log
u v at
log log n
v at level
d i 1
edge u v
in d i
by tree metrics
a distribution over
i separates u
with distortion o
on the distortion
log n approximation
2 i 1
u and v
o log 2
level i if
log 2 n
most d u
metrical task system
buy at bulk
the expected stretch
d i separates
metrical task systems
group steiner tree
bulk network design
the distortion of
at bulk network
metric v d
assigned to w
hierarchical cut decomposition
k server problem
expected stretch of
approximation algorithm for
of each edge
charikar et al
v 2 i
pr u v
that the expected
metrics by tree
u v d
u v for
of d t
value of d
the probability that
stretch of each
let k u
distortion o k
over tree metrics
ws d v
decomposition of v
communication spanning trees
settle u v
distortion of embedding
a hierarchical cut
graphs into 1
say that center
log n d
our result improves
cut decomposition of
w cuts u
out of u
metric by a
outerplanar graphs into
of v d
the k server
d v ws
gave an o
a laminar family
u out of
2 i 2
log n competitive
n d u
d u ws
the expected cost
k log n
at this level
u v 2
0 extension problem
metric labeling problem
the metric labeling
n approximation algorithm
v we shall
u is assigned
n log k
log k log
v d u
the 0 extension
by a distribution
its algorithmic applications
distribution over tree
that the trees
v d is
s in d
of metric spaces
hierarchically well separated
the dual problem
factor approximation for
on approximating arbitrary
expected value of
is o log
at most d
polynomial time approximation
into a tree
the edge u
u v we
the expected value
max flow min
one of u
for the 0
is at most
set of vertices
of u v
constant factor approximation
et al 17
u v v
by o log
a constant factor
a random permutation
to o log
expected cost of
the case that
that the probability
each edge is
log n we
o k log
n point metric
vehicle routing 16
online tracking of
k outerplanar graphs
log n distortion
distribution over dominating
gets assigned to
metrics such that
approximating a finite
improves this to
for group steiner
planar metrics into
routing cost spanning
approximating the bandwidth
as metrical task
over dominating tree
that center l
al 17 showed
n approximation algorithms
algorithms for unfair
labeling problem via
a metric v
method of conditional
task system 10
distributed k server
deterministic polylog approximation
result improves this
a tree metric
grant ccr 0105533
metrics into euclidean
via a new
linial london and
chekuri et al
task systems and
minimum communication spanning
result of bartal
the group steiner
topology aggregation for
finite metric by
edge at a
approximating packing integer
of tree metrics
center w cuts
log n by
polylog approximation for
small distortion and
factor came from
than i to
v for any
that separates u
level i let
aggregation for directed
embedding planar metrics
steiner tree problem
v closer than
distortion and volume
tree metrics a
cluster in d
since the radius
new linear programming
algorithms approximating packing
competitive algorithm for

corpus/krapavin2000-test/1039411.txt
leda
processors
processor
tcomm
seismic
scatter
merlin
mpich
rational
mpi
dinadan
load
sekhmet
mpi_scatter
balancing
comp
items
root
pellinore
caseb
bandwidth
opt
heterogeneous
ray
date
1ip
mpi_scatterv
wave
duration
grids
captor
raydata
globus
piii
seven
rounding
grid
ordering
g2
earth
balance
policy
divisible
collective
rat
balanced
descending
affine
tomography
slave
rbuff
cines
xp1800
hypocenter
1003005007009001000030000500007000090000110000
rating
comm
share
velocity
sign
receives
magpie
metacomputing
earthquake
experiment
bandwidths
finish
cons
master
communication
933
3800
endings
ranks
floor
tasking
stair
receive
ascending
int
performances
proces
scheduling
earliest
execution
cessors
waves
send
resp
library
ceiling
geographically
jej
latest
strictly
speeds
tracing
heuristic
heterogeneity
pcs
8i
homogeneous
mips
weather
libraries
static
velocities
network
whole
passing
receiving
begins
round
bn
nil
hypotheses
sorted
integer
clever
destination
sgi
platforms
parameterized
apples
geophysical
rior
heteroge
neous
r14k
payed
celeron
piplib
009677
intrusive
increas
reworking
pipmp
004885
communicator
r12k
excepted
geophysics
heuris
mated
overesti
seismograms
016156
blueprint
nearest
mesh
instantaneous
year
scientific
outlines
whatever
decreasing
served
hypothesis
links
travel
origin
athlon
personnal
tributions
scatters
pip
mer
plus
ending
shares
indication
consequences
shipped
ecution
amd
contentions
aci
equation
message
infrastructure
sol
throughputs
sor
disseminate
rock
mbit
xp
reconstructs
hub
spawn
817
delimited
distributions
characteristics
idle
algebra
simultaneous
wavefront
sors
spmd
root processor
leda leda
rational solution
the processors
same date
the root
tcomm i
t comp
data items
comp i
processors end
load balancing
optimal rational
execution time
share of
scatter operation
scatter operations
functions tcomm
end their
empty share
n data
all processors
i n
the processor
solution where
p p
ordering policy
mpich g2
processor ordering
load balance
p 1
processor p
execution duration
a rational
integer solution
processors in
to p
velocity model
our load
end date
the wave
processor receives
algorithm 1
on heterogeneous
processors p
a scatter
rounding scheme
we round
root process
the whole
each processor
n 0
their computation
computation at
of data
static load
an optimal
an integer
to process
load balanced
on figure
whole set
data to
the scatter
network links
heterogeneous processors
dinadan total
ray paths
rat opt
comm time
whole execution
of seismic
in scatter
caseb pellinore
communication after
descending bandwidth
whole work
merlin merlin
tcomm j
pellinore sekhmet
int opt
sekhmet seven
seven seven
t int
end at
the execution
parallel computer
of processors
are linear
p processors
p i
computation and
time amount
solution d
solution n
balanced execution
bandwidth they
t rat
an homogeneous
time comm
d p
a policy
to load
items to
connected to
and t
processors have
and communication
processor with
receives a
policy on
a same
as root
algebra algorithms
master slave
sends data
non empty
the sign
processors are
in decreasing
distribution n
all end
on processors
processor sends
bandwidth from
source code
cost d
begins its
the distribution
p k
message passing
opt the
presented on
t 0
processor to
decreasing order
processing at
the time
any i
its communication
dynamic load
the bandwidth
sign of
ray tracing
execution with
the grid
y y
n i
communication functions
constrained parallel
p cons
merlin dinadan
mpi_scatterv calls
origin 3800
for master
original application
exploiting hierarchy
whole end
wave type
seismic events
clever distributions
the mpich
seismic waves
mpi a
seismic tomography
ends its
weather service
grid characteristics
integer distribution
seismic wave
of scatter
received their
total duration
simultaneous endings
replacing mpi_scatter
0 equation
comp j
linear communication
the earthquake
year 1999
operations follows
code rewriting
rational distribution
processor connected
best rational
initial velocity
data caseb
by mpi_scatterv
the mpi_scatter
ordered last
communication constrained
leda merlin
optimal distribution
processor grids
heterogeneous cluster
in rational
destination processors
globus 9
applications designed
mpi start
the root processor
leda leda leda
the same date
t comp i
and t comp
all processors end
optimal rational solution
an optimal rational
comp i n
tcomm i n
share of the
non empty share
processors end their
functions tcomm i
n data items
receives a non
solution where each
their computation at
in 1 p
empty share of
i in 1
rational solution where
and all processors
end their computation
a rational solution
data and all
each processor receives
computation and communication
of the whole
an integer solution
to the root
processor receives a
root processor with
for a rational
our load balancing
the functions tcomm
n and t
to load balance
when the processors
the scatter operation
2 to p
processor p i
a non empty
i d p
p p 1
static load balancing
to p p
the whole set
i n and
whole set of
where each processor
of data and
the computation and
i n are
computation at the
execution time is
true for p
its communication after
in scatter operations
a scatter operation
processors in turn
comm time amount
any i in
begins its communication
caseb pellinore sekhmet
a policy on
t rat opt
n 1 data
the whole work
all end at
processor ordering policy
pellinore sekhmet seven
root processor sends
obtain an integer
the n data
the processor ordering
dinadan total time
cost d i
presented on figure
set of seismic
time comm time
n are linear
t int opt
connected to the
at the same
processor sends data
1 n p
total time comm
the root process
then t 1
data to processors
time amount of
p 1 i
sends data to
1 k then
decreasing order of
processors p 2
policy on the
of data figure
of n data
linear algebra algorithms
end at the
in decreasing order
of the processors
are linear in
to processors in
we consider any
the execution time
set of data
all the functions
linear in n
the sign of
exists an optimal
to p 1
the general case
amount of data
1 p 1
a parallel computer
the first experiment
set of processors
for the root
1 the time
the processors in
order of the
we make the
from the root
as the root
communication and computation
parallel computer networks
2 simultaneous endings
integer distribution of
heterogeneous processor grids
communication constrained parallel
seven leda leda
communication after all
algorithms for communication
for communication constrained
is ordered last
initial velocity model
bandwidth from the
rational solution and
a maximum difference
bandwidth they are
rounding scheme described
the column indicates
1003005007009001000030000500007000090000110000 time data
all the computation
root process we
execution with nodes
the destination processors
root processor is
by descending bandwidth
have an optimal
to process n
the processors ranks
same date t
end date is
events of year
strategies for master
ordered in decreasing
for heterogeneous processors
velocity model the
distribution n 1
an optimal distribution
follows the processors
only if 8i
processors 1 to
the best rational
in parallel computer
the bandwidth they
a rational distribution
up to obtain
optimal distribution of
we derive from
are a bit
same date if
to its ceiling
optimize collective operation
items to p
items over the
study the sign
root processor to
the total duration
over the p
at a same
processor with except
mpi a message
t comp j
applications designed for
leda leda merlin
computer networks to
our target application
the whole execution
p 1 all
in the mpich
date if and
scatter operation as
if 8i 2
maximum difference in
data items over

corpus/krapavin2000-test/1039491.txt
ld
gossip
xr
respecting
resource
disc
closest
alarm
hr
ball
astrolabe
holder
protocol
propagation
fa
temporal
message
strictly
messages
eh
monotone
node
distance
flooding
probability
discs
spreading
resources
believes
balls
disappearance
diameter
protocols
poly
learn
network
spread
pep
demers
interval
path
exponent
induction
guarantee
nodes
location
radius
completing
erent
pr
logarithmic
holders
voronoi
copy
rumor
propagated
rapidly
knows
inverse
round
polynomial
axioms
ciently
mechanisms
renesse
regimented
epidemic
paths
density
appearance
sensor
positioned
hypothesis
outdated
communicate
away
event
leaf
uniform
disappear
edge
su
scalability
partner
gossiping
transmits
nearby
quickly
held
mass
learns
metric
heard
sent
originating
events
reliability
guarantees
randomized
di
calls
region
spatial
labels
dimensions
underlying
concatenated
strengthening
claimed
subtree
closer
delay
infinite
deterministic
stamp
ancestors
plane
neighbor
piece
enter
identity
inductive
lemma
smallest
histories
communicates
dissemination
randomization
liveness
departure
labeled
filling
destination
log
propagate
communication
inform
safety
scalable
2g
subpaths
disappearing
1262
detours
alerted
nearest
sensors
acquire
broadcasting
vertices
logarithm
monotonically
forwards
disjoint
leaves
recurrence
64
choices
normalizing
exchanging
lie
hosts
origin
received
log1
chlebus
originator
dariusz
subpath
2k
label
bounding
service
fix
crucial
collections
qualitative
rmative
stamped
wish
send
approximation
calling
edges
reach
replicated
abnormal
kowalski
concatenate
alert
outset
traveled
transitional
lattice
rooted
bounds
passes
conjecture
phrased
bimodal
ld ld
time respecting
ld d
time out
closest resource
1 ld
resource location
temporal network
out free
strictly time
gossip algorithm
x path
a resource
respecting path
resource holder
time t
node x
out function
x x
at time
high probability
at distance
v i
gossip algorithms
fa d
distance d
hr b
inverse polynomial
a disc
the gossip
probability at
to x
node u
least 1
a gossip
xr at
d ld
respecting x
a strictly
with high
the alarm
resource to
with probability
the temporal
propagation time
xr and
x t
polynomial gossip
uniform gossip
uniform density
in xr
network hr
a node
f h
resource at
t t
the closest
d 1
the resource
a time
to v
i 1
obtain that
any node
poly logarithmic
and xr
disc d
path p
h k
from x
and x
of diameter
x and
containing both
that ld
delay that
its closest
point sets
the protocol
believes in
alarm state
nodes communicate
free x
xr is
x believes
d d
x with
d x
h d
r d
r x
nodes x
a propagation
b t
1 d
a ball
time interval
d o
that nodes
of radius
let x
the propagation
containing x
contains a
copy of
function h
ball b
approximation guarantee
non monotone
each node
new information
d with
x be
induction hypothesis
r ld
neighbor flooding
xr x
events f
ld 1
monotone resource
xr to
k containing
radius k
rapidly learn
from xr
underlying gossip
spatial gossip
u close
resource within
message x
log d
diameter d
distance at
g k
in log
probability in
that information
in r
x r
c x
point communication
k e
higher dimensions
e e
point x
the message
ball of
which information
hold a
the distance
o d
two nodes
network g
an alarm
path distance
learn of
disjoint for
x throughout
the proof
x will
m t
node v
n x
all nodes
with uniform
time step
their distance
which nodes
x to
density in
y 3
hypothesis to
h e
the event
network h
location problem
in h
message m
x at
in higher
from u
the interval
interval t
free path
x b
identity of
the induction
point set
t then
d for
this protocol
a network
simple protocol
round t
the monotone
s x
the network
theorem 2
lemma 2
an underlying
ld ld ld
time out free
strictly time respecting
v i 1
the temporal network
time respecting path
a strictly time
at time t
time out function
1 ld d
x x path
with high probability
least 1 ld
the closest resource
a time out
ld d 1
probability at least
with probability at
at distance d
ld ld d
at least 1
time respecting x
a time respecting
hr b t
respecting x x
a resource holder
out function h
to v i
x and x
closest resource to
temporal network hr
xr at time
contains a strictly
inverse polynomial gossip
ld d ld
d x x
in r d
a gossip algorithm
the inverse polynomial
a disc d
contains a time
in xr at
its closest resource
b of diameter
h k e
b t t
r x t
f h k
i 1 at
of the resource
a node x
is a time
polynomial in log
theorem 2 1
that ld ld
respecting path from
containing both x
k e e
polynomial gossip algorithms
a resource at
f h e
uniform density in
d ld d
the alarm state
a propagation time
d d x
a delay that
is a disc
resource to x
x believes in
respecting path p
nodes x x
believes in xr
network hr b
distance d d
out free x
of a resource
theorem 1 1
1 at time
time t i
from x to
k x x
s x t
in higher dimensions
each node u
induction hypothesis to
high probability in
with a delay
x x b
the time out
x x r
interval t t
nodes at distance
close to x
with uniform density
out free path
to obtain that
propagation time that
resource at distance
density in r
u u i
d o d
u close to
gossip algorithms a
free x x
resource at time
resource location problem
xr x path
node u close
of radius k
the gossip algorithm
k containing x
d with high
fa d and
n x t
ball b of
with a propagation
temporal network h
monotone resource location
step from i
node x at
events f h
to x throughout
x path with
temporal network g
in log d
probability in time
lemma 2 3
the induction hypothesis
we obtain that
to point communication
in each time
x to x
let b be
and x and
o log 1
which information is
of diameter d
are disjoint for
delay that is
x with high
log 1 d
copy of the
completing the proof
the identity of
a ball of
distance at most
at distance at
v i to
the propagation time
t t f
t f a
d contains a
in which information
two nodes x
let x be
from u to
both x and
x at time
ball of radius
of theorem 2
each time step
x is at
path p from
a node u
let t fa
non monotone resource
information originating at
disc d d
r let t
xr and x
y c x
any ball b
closest resource holder
in each communication
ball containing both
e u u
gossip algorithm a
t fa d
it knows about
find out about
the message x
which nodes communicate
any node and
x be any
xr to x
diameter d any
d 1 ld
xr a resource
information is spread
node learns of
x r let
from v i
node u chooses
closest resource within
interval s t
f a d
about the disappearance
radius k containing
obtain that ld

corpus/krapavin2000-test/1039494.txt
rank
frieze
drineas
svd
singular
rows
matrix
subspace
az
kannan
vectors
sampling
2004a
szemer
ss
sample
frobenius
document
alan
spanned
approximation
edi
pick
documents
norm
regularity
row
bin
sd
jth
ith
approximations
columns
latent
lemma
monte
entries
sariel
achlioptas
peled
verbar
orthonormal
ay
carlo
matrices
vempala
mcsherry
szemeredi
submatrix
santosh
alon
har
ww
probability
dumais
kleinberg
mn
picked
seventeenth
su
cp
papadimitriou
span
entry
column
decomposition
miami
sparsity
retrieval
squares
eigenvector
cient
siam
expectation
expectations
semantic
annual
2004b
simonovits
rademacher
mnk
1117
kmn
fernandez
odl
proximations
sparsify
yuster
koml
buzz
mahoney
bxx
karpinski
eckart
lefmann
shortly
pass
topics
ces
indexing
developments
florida
poly
ij
vega
yossef
1126
rationals
chebychev
1127
cursory
9k
deerwester
boosted
parti
muthukrishnan
petros
median
squared
a1
epsi
1999a
multiplica
1136
hypothesizes
crudely
1999b
sedona
claims
frequencies
scaling
berry
deshpande
onwards
hyperlinked
golub
loan
polynomial
dense
partition
algebra
500k
duke
authoritative
multiplying
approximates
sized
web
dimitris
creator
amit
precompute
fast
lth
marek
approximating
hypertext
luis
randomized
scaled
approximate
ory
8k
consult
nm
symposium
random
jacm
unbiased
av
projective
1978
rearranging
cur
arizona
assumptions
asserted
baltimore
eigenvectors
et
multiset
defer
magnitudes
orthogonal
satisfying
proportional
sublinear
ravi
unreasonable
sight
ce
md
attributes
geometry
2003
bins
minimizes
1989
tensor
mr
low rank
rank approximation
singular vectors
frieze et
f f
ss t
alan frieze
t t
fast low
with probability
rank approximations
drineas et
az i
assumption 1
a f
rows of
the svd
k singular
matrix a
and kannan
regularity lemma
t az
good low
w t
of s
that f
z i
sd of
subspace spanned
svd of
frobenius norm
the matrix
probability at
approximation to
sample the
assumption 2
v t
szemer edi
in drineas
fast monte
carlo algorithms
edi s
al 2004a
satisfying assumption
least 9
sampling assumptions
row space
matrix d
unit vectors
the subspace
spanned by
the vectors
rank k
n matrix
et al
we pick
column space
distribution satisfying
rank at
p matrix
the singular
u t
a t
of rank
i t
can sample
vectors z
vectors y
pick a
a matrix
t k
latent semantic
the sd
value decomposition
i z
the frobenius
matrix s
the ith
sample of
singular value
s rows
most k
t a
s t
singular values
d k
vectors x
m n
the sampling
vectors of
any matrix
frieze and
space of
the row
time polynomial
pass we
f applying
the documents
probability distribution
of rows
k in
probability proportional
the pass
ith row
10 there
2 norm
monte carlo
a document
the entries
top k
span of
k approximation
y t
columns of
matrix m
the span
t now
vectors u
approximation with
lemma 3
1 y
t f
polynomial in
the rows
2 f
matrix of
the lemma
a distribution
a from
first part
p columns
svd can
jth term
peled how
natural probability
and jth
error parameter
median shape
ww t
har peled
s regularity
papadimitriou et
orthonormal set
in frieze
a picked
drineas and
that subspace
constant sized
sariel har
finding low
d rank
b matrix
ith document
regular partitions
for assumption
p rows
rows chosen
an m
the regularity
an algorithm
y 1
in k
lemma and
holds with
second part
a good
x i
in graph
a ij
words that
an orthonormal
the algorithm
row i
set up
get close
p independent
independently choose
assumption a1
explicit approximation
pick p
show is
sparsity structure
corresponding rows
are unit
in assumption
first pick
santosh vempala
taking expectations
up data
n terms
a has
the column
takes time
n t
f the
f proof
y k
a sample
random variable
of vectors
low rank approximation
frieze et al
rows of a
alan frieze et
fast low rank
z i t
approximation to a
low rank approximations
drineas et al
t t k
singular vectors of
good low rank
a t az
az i z
a good low
t az i
f f f
probability at least
with probability at
the svd of
subspace spanned by
the subspace spanned
i z i
the row space
d of rank
k singular vectors
sample the entries
an m n
et al 2004a
rank approximation to
monte carlo algorithms
row space of
carlo algorithms for
fast monte carlo
of rank at
rank at most
p p matrix
distribution satisfying assumption
least 9 10
at least 9
szemer edi s
m n matrix
the frobenius norm
the column space
column space of
u t t
the sd of
i t a
we can sample
polynomial in k
space of s
we pick a
in the row
y 1 y
of a from
singular value decomposition
at most k
s t s
n matrix a
the matrix a
the 2 norm
most k so
takes time polynomial
of s rows
in the subspace
vectors y 1
top k singular
of low rank
can sample the
matrix d of
in drineas et
be the p
from a distribution
independent of m
unit vectors z
x t t
the regularity lemma
frieze and kannan
that f f
k in the
the singular value
in the column
svd of a
to s t
the pass we
k and 1
a matrix d
holds with probability
a p p
rank k approximation
y t t
q j i
of a f
e n t
spanned by the
time polynomial in
words that occur
f for some
and the vectors
9 10 there
the ith row
part of lemma
t a t
a t a
with probability proportional
the matrix d
probability proportional to
a a f
for t t
f a f
first part of
a probability distribution
the top k
t k in
see that f
the span of
set of vectors
vectors of a
a from a
a f a
how to get
that with probability
of s to
the first part
such that f
columns of a
in the ith
problem of finding
algorithm to find
give an algorithm
k so that
the second part
of a t
probability distribution satisfying
orthonormal set of
finding low rank
from the sd
of ss t
a constant sized
har peled how
columns of s
decomposition svd can
vectors z t
a natural probability
p matrix w
and approximation schemes
satisfying assumption 1
f f using
then we we
that f applying
a d f
d k f
matrix a k
sample of rows
ss t u
sariel har peled
in frieze and
of p independent
a matrix s
d rank d
norm see section
p rows of
frobenius norm the
vectors x i
2 norm see
matrix of s
log 1 only
computation of low
assumptions of our
vectors u t
svd can be
a distribution satisfying
sample of s
algorithm whose running
matrix d can
for low rank
the vectors u
during the pass
of unit vectors
assumption 1 we
rank d k
set up data
rank approximation with
sd of s
the ith document
the corresponding rows
a f proof
natural probability distribution
the median shape
more explicit approximation
that d rank
s rows of
for any matrix
the jth term
f e n
the sampling assumptions
2 that with
vector valued random
an orthonormal set
up data structures

corpus/krapavin2000-test/1039903.txt
eu
ln
multiplicity
dn
oscillation
compositions
kn
composition
wilf
pittel
erd
fristedt
partitions
asymptotics
savage
corteel
a_n
asymptotic
letting
lehner
os
unconditional
k0
expectation
oscillations
tildas
gammaffi2
edn
dx
bernoulli
rice
rhs
sizes
equidistributed
infty
sinh
amplitude
randomly
approximating
probability
1g
conjectures
oscillates
lim
expectations
partition
trials
integer
mt
random
sums
alternating
sn
concentrated
opened
fourier
m2
substitution
dotted
parts
binomial
successes
asymptotically
positions
02757203860
hitczenko
02098570878
rightarrow
mx02
schmutz
02671657484
02722066115
goverened
devoting
eisenberg
stengle
lehigh
1602994490
esz
thatx
kirschenhofer
004904708738
unrepeated
substantiating
f3g
givesx
reasonble
kng
tossings
thanm
varialble
007213475205
teel
dms9622772
j2u
02757781675
coefficients
gamma2
dt
integral
equipped
uniformly
limiting
lambda
ffiu
legality
semester
oscillatory
uncovers
pawe
oscillate
gratitude
winners
nonnegligible
enyi
goh
unexpected
stirling
herbert
approxima
mellin
walsh
gamma
head
sup
event
sequences
log
culminated
purposely
sigma
integers
probabilities
gilbert
equip
investment
bennett
goes
exhibits
summing
recurrences
nonsymmetric
andrews
heavily
estimate
around
multiplicities
hadamard
phenomenon
dominating
ev
hospitality
integrals
summands
story
suffices
argument
f0
confirming
desires
questionable
jen
260
rate
fluctuations
352
gamman
waiting
merely
knuth
jeremy
probabilistic
exceeding
reproduce
multiset
hung
tight
negligible
conquer
repetitive
artifact
tricky
losing
nth
coarser
xn
tie
unordered
280
theta
convergence
bringing
inf
ignored
runs
cor
contrasts
author
du
ninth
u m
part sizes
has multiplicity
part size
multiplicity m
m dn
of eu
m ln
the oscillation
ln 2
a composition
of parts
1 m
dn i
chosen part
eu n
random composition
distinct part
over j
integer n
ln n
sum 10
different part
1 ln
eu m
randomly chosen
a randomly
about 1
erd os
as n
integer partitions
i dn
savage and
pittel savage
composition of
os and
oscillation of
unconditional probability
compositions of
a random
sizes in
z k0
then out
dotted the
fristedt s
dn kn
approximating sum
corteel pittel
upon substitution
multiplicity three
dn u
a_n m
t kn
n dotted
alternating sums
p a_n
and lehner
of part
parts is
x dx
at random
probability in
log 2
k0 1
that ln
uniformly at
probability that
parts in
an integer
bernoulli trials
limit but
k n
composition is
sum over
m n
size in
of distinct
of multiplicity
random partition
the probability
the approximating
uniform probability
n n
paper of
last part
rhs of
the sum
q gamma
the unconditional
m increases
the amplitude
we will
probability measure
size has
the asymptotic
head runs
to eu
and wilf
all compositions
e gamma2
random compositions
m more
bound 11
concentrated around
heavily concentrated
between compositions
equidistributed with
the asymptotics
mt dt
two expectations
on eu
latter expression
polynomial rate
called parts
but exhibits
eu 1
is equidistributed
ratio u
approximate eu
have multiplicity
eu 5
kn log
limiting distribution
exhibits oscillations
which upon
eu about
lehner 5
second probability
the multiplicity
n p
of partitions
the argument
multiplicity of
theta 1
random variables
is asymptotic
asymptotic to
kn t
independent bernoulli
letting t
first probability
number 10
a limit
distribution of
partitions of
have p
c n
n and
with gamma
fourier coefficients
gamma2 i
dn is
random partitions
geometric random
that dn
fixed integer
m we
of n
n has
goes to
m and
to 0
i u
term in
n since
p f
will denote
j of
is heavily
lim sup
around its
fixed m
will approximate
sizes 1
selected uniformly
positive integers
n we
expected value
first term
as m
its expectation
waiting times
approaches 1
size j
argument is
bound the
sizes is
all partitions
actual value
namely 1
of ln
amplitude of
around 1
value 1
the rhs
this expectation
choose k
gamma s
the expected
2 u
u m dn
1 m ln
m ln 2
randomly chosen part
has multiplicity m
chosen part size
m dn i
in a random
number of parts
a random composition
distinct part sizes
part size in
an integer n
a randomly chosen
different part sizes
of distinct part
part sizes in
random composition of
u m n
of an integer
size in a
erd os and
as n 1
that a randomly
over j of
oscillation of eu
sum over j
about 1 m
of part sizes
pittel savage and
the oscillation of
composition of an
c 1 m
number of distinct
uniform probability measure
i dn kn
the uniform probability
z k0 1
on the oscillation
approximating sum 10
os and lehner
parts in a
i u m
sum 10 and
the approximating sum
a limit but
of different part
part size has
have a limit
u m the
dn u m
comparison of eu
then out of
m dn u
2 u m
p a_n m
multiplicity m we
compositions of n
n dotted the
dn i u
value 1 m
corteel pittel savage
dotted the approximating
n has multiplicity
log 2 n
uniformly at random
the sum over
of parts in
of parts is
unconditional probability that
a composition is
of n and
the unconditional probability
goes to 0
j 2 u
c 2 m
a composition of
with the uniform
a random partition
as m increases
n n n
1 m and
the last part
denote the number
the multiplicity of
the number of
m as n
between compositions of
k n so
that a composition
on the alternating
kn log 2
have multiplicity m
which upon substitution
e gamma2 i
set of part
part sizes is
choose k n
savage and wilf
dn i dn
the second probability
independent bernoulli trials
around 1 m
of multiplicity m
1 ln n
size has multiplicity
is selected uniformly
the number 10
ln n p
around the value
part sizes 1
fristedt s result
ratio u m
of random partitions
the sum 10
integer n is
f x dx
order to bound
part sizes and
is equidistributed with
is asymptotic to
that have multiplicity
dn is heavily
has multiplicity three
t kn t
that dn is
1 m as
limiting distribution of
the alternating sums
sizes in a
for a composition
correspondence between compositions
fourier coefficients are
limit but exhibits
but exhibits oscillations
multiplicity m and
with gamma s
of the oscillation
that this part
so that since
the bound 11
on eu n
gamma2 i x
this part size
of eu 5
have u m
part sizes of
the latter expression
on the multiplicity
all compositions of
of all compositions
integer n has
parts of multiplicity
of eu about
is heavily concentrated
the ratio u
to 0 at
i x dx
of eu 1
multiplicity of parts
structure of random
and lehner 5
behavior of eu
multiplicity m more
concentrated around its
of a composition
os and r
choosing a part
behavior of ln
eu about 1
first probability in
kn t kn
composition is chosen
case of partitions
rhs of 3
that u m
j has multiplicity
ln 2 this
distribution of the
probability that a
expected value of
we have p
the probability that
section we will
out of all
and k n
for x x
go to 0
is the asymptotic
sizes 1 2
are asymptotically the
since as we
10 and 1
waiting times for
of u m
the first probability
of parts of
the expected value
p j 2
term in 5

corpus/krapavin2000-test/1039913.txt
terminals
rounding
terminal
semimetric
uv2
multiway
relaxation
lg
uv
tardos
integrality
cut
planar
vazirani
metric
nonterminals
jt
kleinberg
inequality
multicut
expander
dahlhaus
rao
klein
met
endfor
4h
kpr
minfr
triangle
pixel
nonterminal
garg
minor
vertices
infinitely
approximation
nonnegative
calinescu
graphs
weight
expanders
arcs
weighted
metrics
flow
extension
yannakakis
plotkin
edge
arc
2m
cluster
integrands
karzanov
karloff
hst
maxfa
labels
labeling
pp
claim
edges
ratio
capacity
reals
min
jv
log
flux
relaxations
disconnects
penalizes
2g
rabani
leighton
distance
separated
unassigned
cuts
lengths
minimize
feasible
multicommodity
lemma
intensity
hl
assignment
randomized
polynomial
max
integral
jsj
pr
comput
restoration
removal
siam
vertex
distances
assigned
je
notice
jc
growing
vision
chuzhoy
uv2e
sarnak
antiparallel
khot
aranyak
e2eh
16g
lubotzky
subhash
4r
kjv
uv2cr
pick
permutation
shortest
gupta
closest
jr
multiterminal
dlg
apx
karger
eh
11d
fsg
combin
earthmover
tight
label
clusters
fix
pixels
subgraph
62
nee
thorup
cunningham
phillips
894
yuval
ramanujan
penultimate
diameter
endpoints
sequences
expansion
supposedly
2z
dk
mehta
40th
maxfn
disjoint
assign
stein
bartal
raster
seymour
jcj
connect
asymptotically
optimum
uniformly
exhibit
intensities
combinatorially
864
howard
nonpositive
2l
congruent
hr
iff
nodes
approximating
tg
jej
sqrt
papadimitriou
weights
flavor
2r
bounds
excludes
nondecreasing
agarwal
visual
fractions
exceeding
235
cn
ravi
distortion
0 extension
rounding procedure
u v
a u
multiway cut
integrality ratio
the rounding
approximation algorithm
f u
planar graphs
of terminals
a semimetric
c u
a terminal
lg n
semimetric on
metric relaxation
r minor
the integrality
of met
and tardos
met of
a v
jt j
kleinberg and
l t
d f
v u
the 0
extension problem
log jt
c uv
lg k
the multicut
log k
is at
u f
triangle inequality
k r
on t
f v
multicut problem
minor free
the triangle
the relaxation
h i
approximation algorithms
s u
assignment cost
tardos and
uv2 uv2
programming relaxation
at most
of weight
flow min
and rao
feasible solution
u 6
in g
u a
the metric
polynomial time
max flow
3 z
to terminal
o z
metric labeling
minimize c
z 2m
uv 2
terminal j
least k
v d
linear programming
the multiway
cut problem
an expander
cut theorem
relaxation for
infinitely many
o r
for every
for planar
the terminals
graph e
edge lengths
terminal closest
nonnegative edge
weight o
inequality 3
of multiway
least lg
of dahlhaus
uniform metric
dahlhaus et
j approximation
t 2g
weighted planar
minfr t
4h k
l j
notice that
min cut
2 min
r r
assigned to
improved bounds
1 approximation
edges uv
arc disjoint
plotkin and
z log
klein plotkin
for multiway
claim 5
for infinitely
whose removal
o log
r 3
6 v
inequality follows
u and
v and
most 1
l v
j 2
terminal i
u therefore
every nonterminal
g between
for weighted
at distance
between u
time algorithm
positive integer
k 2
so as
to minimize
an o
extension in
region growing
terminal in
and yannakakis
are at
vertices in
r j
a 0
d max
t cut
extension is
optimal solution
v 0
input graph
k approximation
metric on
s t
t v
v c
at least
u 4
r so
of capacity
the distance
v are
o 1
g 0
be assigned
to v
and v
cluster c
nodes u
v we
of edges
d to
algorithm for
met on
endfor we
vazirani 17
growing technique
add arcs
rao 13
instance defined
fix u
extension instance
penalizes for
terminals we
al relaxation
semimetric d
weight z
the integrands
cost penalizes
pick uniformly
natural linear
uv c
minimum flux
garg vazirani
labels model
are nonterminals
and vazirani
by inequality
the rounding procedure
the integrality ratio
d f u
the 0 extension
c u v
r r minor
a 0 extension
k r r
approximation algorithm for
f u f
u f v
a semimetric on
the metric relaxation
a u a
0 extension problem
least k 2
0 extension of
kleinberg and tardos
to a terminal
the triangle inequality
the multicut problem
o r 3
is at least
by the triangle
v d f
is at most
linear programming relaxation
s u v
is a terminal
for planar graphs
as to minimize
log jt j
r 3 z
is a semimetric
of 0 extension
integrality ratio of
minimize c u
v a u
of met of
solution of met
r minor free
u v d
max flow min
at least k
multiway cut problem
that the integrality
a k r
the multiway cut
u and v
min cut theorem
o 1 approximation
most 1 2
u 6 v
flow min cut
u v u
u a u
of the rounding
the max flow
to minimize c
dahlhaus et al
integrality ratio for
0 extension is
polynomial time o
for weighted planar
0 extension in
semimetric on t
z log k
semimetric on the
for the multicut
graph e with
d to v
weighted planar graphs
a u 4
j approximation algorithm
j a u
of weight o
extension of weight
metric on t
d on t
terminal closest to
a terminal closest
o z log
1 2 min
rounding procedure that
at least lg
4h k a
jt j approximation
rounding procedure is
minfr t 2g
a terminal j
the uniform metric
o log jt
the improved bounds
polynomial time algorithm
so as to
between u and
be assigned to
extension of d
u v are
log k approximation
feasible solution to
is an expander
v c u
for the relaxation
for multiway cut
shortest path in
1 approximation algorithm
u a v
in g between
plotkin and rao
each of capacity
klein plotkin and
from h i
for infinitely many
l j 2
l v r
at most 1
a polynomial time
distance in g
planar graphs and
feasible solution of
approximation algorithms for
are at least
u v c
s t cut
a v a
is o r
v u v
k approximation algorithm
u v we
there are at
there is a
of d to
t r t
of the integral
x 2 c
a graph e
for the 0
e u v
o log k
the linear programming
of edges of
given a graph
in g 0
i i 0
inequality follows from
an o log
a feasible solution
assigned to a
at most r
the minimum flux
and vazirani 17
path metric on
are nonterminals and
and a semimetric
and tardos and
for every then
finite capacity s
r so d
assignment cost penalizes
k pairs of
edge weights c
a v therefore
et al relaxation
every nonterminal u
the labels model
problem of dahlhaus
edges of minimum
if i r
produces a 0
amounts to determining
lg n since
e with nonnegative
gupta and tardos
penalizes for the
with nonnegative edge
met on the
and rao 13
extension instance defined
v are nonterminals
v r so
observed and assigned
jc r j
of multiway cut
j therefore for
cut theorem to
3 s u
e v u
assigning a label
the observed and
a pixel amounts
a v 4
nodes to terminal
in m s
most a from
a terminal in
g path metric
a u we
mapping so as
triangle inequality a

corpus/krapavin2000-test/1039958.txt
irreducible
witness
homotopy
homotopies
cascade
deg
algebraic
continuation
isolated
multiplicity
polynomials
varieties
numerical
intersection
hypersurface
dimension
diagonal
polynomial
decomposition
ne
nonsingular
supersets
equations
dim
solutions
zariski
sommese
phcpack
verschelde
numerically
leg
tracking
paths
randomization
pure
notre
dame
intersecting
milliseconds
curve
legs
subspace
ln
cpu
dimensional
cylinder
sphere
smooth
embedding
gough
wenyuan
en
union
eq
generic
dn
platform
membership
jan
uic
wampler
abuse
lm
intersected
identically
seventh
superset
reid
tracker
restrictions
email
triangle
article
geometry
edu
red
cient
2k
di
stewart
generically
coordinates
decompose
projective
greg
slack
erent
remark
intersect
vanish
singular
zeroes
math
164
decomposes
component
fb
chicago
url
euclidean
hypersurfaces
erentiable
48090
ornl
4618
bertini
unramified
7045
9055
0105739
mound
wittkopf
surjects
pretending
oberwolfach
monodromy
0105653
numerics
30500
randomizations
0134611
husty
offshoot
gri
ometry
stiftung
algebra
generalization
trace
slice
item
charles
contained
xw
postures
gov
60607
volkswagen
blackbox
codify
46556
karger
duplications
intertwine
genoa
adjunction
material
stages
plane
symbolic
wu
z
fa
solver
rip
kinematic
equilateral
adjoined
diverged
letting
wish
realize
abstract
restricted
nonempty
duncan
851
chair
motors
equates
pullback
constructing
defining
lemma
dense
thrust
gm
monomial
pde
795
app
xz
perturbing
papers
identified
nonzero
limits
submatrices
appendices
359
beijing
degree
emphasize
mixed
naively
constructible
diverge
warren
608
assembling
algebraic set
irreducible decomposition
the cascade
irreducible components
witness set
irreducible component
isolated solutions
c n
witness points
on c
the irreducible
c m
polynomial systems
a witness
witness sets
z i
the witness
system of
system f
solution set
solution components
diagonal homotopy
ne algebraic
deg x
numerical irreducible
of dimension
an irreducible
v f
polynomial system
dimensional a
x c
of polynomial
polynomial equations
polynomials on
f x
a ne
solutions of
intersection of
the homotopy
i dimensional
decomposition of
the diagonal
the intersection
of polynomials
numerical continuation
component of
u v
the deg
of homotopies
pure n
homotopy continuation
dimensional algebraic
i j
components of
solutions f
the isolated
e i
z 1
set x
algebraic geometry
the solutions
witness point
by homotopy
numerical algebraic
n polynomials
algebraic subset
the solution
probability one
ln i
the multiplicity
dimension n
cpu time
a pure
a union
an algebraic
a system
linear subspace
on x
f i
solution sets
dimension i
of f
n dimensional
restrictions of
v r
the system
embedding theorem
equations in
of v
1 b
r f
multiplicity of
a b
zariski open
abstract embedding
w red
positive dimensional
seventh leg
dimensional components
of deg
jan verschelde
equations restricted
into irreducible
multiplicity one
any irreducible
algebraic sets
cascade we
paths defined
generic points
c dim
milliseconds cpu
homotopies to
hypersurface is
i f
1 u
general linear
cascade of
find the
points on
z b
f 1
two components
start the
x is
set for
is irreducible
total degree
polynomial on
dim x
membership tests
general n
deg a
for intersecting
cascade and
user cpu
dimensional system
lm n
deg b
notre dame
of 12
of solutions
union of
the start
any component
triangle and
1 dn
component z
of paths
the curve
f on
of equations
x z
b are
v b
to start
of multiplicity
of witness
identically zero
restricted to
d 1
1 0
to x
r 1
x k
a polynomial
f of
b a
a sphere
of restrictions
number d
b r
systems by
in x
a finite
f a
to compute
a 1
n k
f b
a generic
a cylinder
of components
points of
contained in
dimension at
lemma a
start of
to find
once and
y y
finite set
by witness
choosing linear
seconds user
papers 12
compute witness
two polynomial
start solutions
numerically represented
nonsingular isolated
z i j
irreducible decomposition of
a witness set
on c m
solution set of
on c n
irreducible component of
the irreducible decomposition
the solution set
of the cascade
a ne algebraic
numerical irreducible decomposition
a system of
the diagonal homotopy
ne algebraic set
polynomials on c
an irreducible component
dimensional a ne
witness set for
f 1 0
algebraic set x
x c n
system of polynomials
r f x
r 1 u
e i f
is an irreducible
system of polynomial
1 u v
of polynomial equations
the intersection of
x c m
n dimensional a
of polynomial systems
isolated solutions of
pure n dimensional
the isolated solutions
an algebraic set
system f x
of the solution
the system f
a union of
f x k
dimensional algebraic set
restricted to an
by homotopy continuation
v r f
start the cascade
the numerical irreducible
solution components of
solutions of f
a pure n
intersection of components
of polynomials on
solution sets of
set x c
polynomial system f
decomposition of the
to start the
f x y
b a 1
u v b
for the irreducible
of v f
a polynomial system
z 1 b
components of v
1 b r
of a polynomial
the multiplicity of
of a b
z b a
b r 1
of a system
of f x
of the system
component of v
of solutions of
once and for
u v a
a 1 b
find the intersection
algebraic set and
the witness points
abstract embedding theorem
cascade of homotopies
the cascade we
of n polynomials
numerical algebraic geometry
dim x 1
general n i
polynomial on c
total degree of
system of restrictions
c m to
paths defined by
the cascade and
the witness point
systems by homotopy
sets of polynomial
c dim x
equations restricted to
a z b
witness points on
witness points for
n i dimensional
algebraic set the
the total degree
n polynomials on
a general n
user cpu time
irreducible components of
irreducible component z
to an algebraic
any irreducible component
of f 1
b is an
theorem 5 1
number of paths
the two components
intersection of two
system of n
to u v
x v f
for i from
component z i
curve of degree
to a pure
any component of
c n to
but a finite
i from 1
an a ne
set for the
component of the
decomposition of a
of v r
v f is
of dimension at
of v g
a general linear
with probability one
and f b
lemma a 1
a and f
the witness set
d 1 dn
start of the
assume that we
show how to
to find the
a and b
set of a
component of x
number of variables
at the start
system in the
system of equations
f on x
x as a
f a and
all components of
that x is
of the diagonal
the start of
intersection of a
the restrictions of
contained in a
equations in the
c n is
13 14 15
i j is
the solutions of
the top dimensional
polynomial equations on
start solutions for
of multiplicity one
irreducible components are
by witness sets
restricted to u
distinct irreducible components
pure dimensional algebraic
f of solutions
find the irreducible
dimension n irreducible
a solution component
of polynomial system
continuation to compute
y are contained
the solution sets
restrictions of polynomials
follows by considering
irreducible of dimension
dimension of any
identically zero equations
whose irreducible components
and equations in
algebraic curve b
stewart gough platform
a generic choice

corpus/krapavin2000-test/1040296.txt
typecase
coercions
int
labels
label
polymorphism
coercion
eq
polymorphic
polytypic
bool
branches
ls
constructor
haskell
setcase
tostring
branch
l0
hoc
polykinded
generativity
coerce
l1
coercing
directed
head
generative
ad
subcomponents
nominal
constructors
fst
extensible
core
calculus
map
language
judgment
lindex
datatypes
jones
maps
intensional
names
kind
programmer
marshalling
statically
structural
isomorphisms
semantics
harper
reflexivity
l2
rossberg
unanalyzable
all2
generic
equality
programmers
kinds
di
ml
boilerplate
abstractions
primitive
e1
annotated
hinze
operationally
equivalences
forms
syntactic
arguments
distinctions
peyton
e2
coerced
snd
abstracts
expressiveness
operational
erently
argument
abstraction
newtypes
trifonov
functorial
typed
erased
compile
record
integers
expressions
universe
judgments
booleans
sugar
weirich
analyzable
charity
scrap
distinguished
singleton
fix
inr
instantiated
erent
weak
treat
annotation
wished
morrisett
destroys
reflexive
isomorphic
closed
quantified
syntax
records
tos
fish
folds
vars
analyzed
constants
dynamically
pressions
poly
loading
matched
annotate
parametrically
checks
operator
lists
ect
phone
formed
list
traversals
stuck
languages
your
conservatively
compilation
universal
rule
normal
overloading
xml
er
scope
parametric
calculi
determines
extensions
expressible
ex
instantiate
portland
open
sound
fee
hide
oregon
interpretation
definer
extensionality
idioms
destructs
cata
deconstructing
rializer
tycon
polyp
sider
hindering
eqint
gleton
existen
tensible
billings
elides
glew
saha
tials
settostring
dered
rok
washburn
uncoercions
leifer
rebuilds
strnia
shinwell
polytypism
stylized
mapcase
type directed
type analysis
label set
the type
order coercions
directed operations
a type
new types
higher order
hoc polymorphism
order coercion
of kind
new label
defined types
generative types
labels that
of labels
l language
s ls
label sets
new labels
ad hoc
of types
core l
type constructor
directed operation
directed programming
of typecase
of type
branches for
the label
new names
weak head
class maps
user defined
labels l
type argument
type level
run time
types the
first class
in l
l e
the core
branch for
the coercion
head normal
int bool
polykinded types
coercions are
in typecase
typecase is
int int
int and
type of
l1 l2
eq a
in types
types are
forms of
type information
the map
the head
order analysis
generic haskell
this calculus
list int
normal form
type variables
labels in
the judgment
intensional type
finite maps
those types
semantics of
from labels
type isomorphisms
type names
the coercions
fst x
l label
eq to
matching branch
int or
y list
instance eq
polymorphic equality
primitive coercions
polymorphic operations
type constants
coercions to
full reflexivity
l l1
by typecase
typecase int
a polymorphic
map e
all type
the kind
new in
branch to
their underlying
time type
types to
labels to
of ad
domain of
type is
types such
for label
the analyzed
as int
polytypic operations
core language
e l
the types
the primitive
new type
its argument
a label
the programmer
to coerce
structural analysis
type constructors
dynamic type
these types
operations are
type classes
constructor in
a branch
determines the
of l
these new
with type
e1 e2
type variable
and variant
fully reflexive
analysis operator
type generativity
distinctions that
s l0
x list
set polymorphism
poly terms
tostring s
label therefore
kind polymorphic
to extension
typecase the
analyzed type
of polytypic
for typecase
the typecase
order type
type functions
coercions have
bool int
all2 eq
nominal analysis
both forms
distinguished labels
matched label
erently from
finite map
l includes
variant types
l l
e e
the labels
to types
this language
the domain
map for
type check
instances for
source language
types and
and label
names for
that may
form of
at compile
first order
be extensible
where instance
harper and
quantified type
type arguments
for labels
as haskell
types because
full language
polymorphic function
for coercing
if int
labels at
argument to
for new
rule for
type directed operations
higher order coercions
ad hoc polymorphism
user defined types
set of labels
the type of
type directed programming
type directed operation
of the type
first class maps
higher order coercion
in the type
of labels that
of the map
a new label
kind of the
labels that may
weak head normal
forms of ad
head normal form
the core l
time type analysis
a type constructor
a type directed
intensional type analysis
run time type
operations are defined
the domain of
the new label
the l language
the type argument
appear in types
higher order analysis
new in e
a map for
run time analysis
first order coercion
from labels to
of ad hoc
types such as
the label set
such as int
normal form of
of type directed
that may appear
the kind of
the types of
labels in the
of the label
hoc polymorphism is
l may be
the structural analysis
define a language
of typecase is
where instance eq
and label set
label set polymorphism
types of expressions
these types are
closed to extension
the analyzed type
of generative types
type level analysis
di erently from
record and variant
and variant types
branch for the
order coercions to
the matched label
the weak head
e e l
the primitive coercions
higher order type
new names for
core l language
at compile time
the rule for
the core language
the full language
of labels l
such as haskell
the type level
types cannot be
by the kind
if a type
the kinds of
of an ad
structure of types
l e e
be extended with
in l we
to the type
of a type
of higher order
a language that
with a type
the argument to
semantics of this
of its argument
type of the
e with a
domain of the
two forms of
the expressiveness of
at run time
of the core
may appear in
a higher order
it is impossible
the interpretation of
source language for
the judgment l
finite type maps
the function eq
be of kind
types are equivalent
type directed function
l language is
fst x fst
e l label
eq a eq
the finite map
as the restriction
x int bool
ad hoc operation
analyzed by typecase
types are designed
the term language
label set analysis
y list all2
defined types such
an additional argument
typecase int bool
dynamic type analysis
the restriction for
all2 eq x
label and label
first class map
l type of
bool s l0
for function types
the label variable
with instances for
l l1 l2
y else not
not all type
is closed to
ad hoc polymorphic
all type constants
rewrite eq to
directed operations in
language the generic
not type check
type of typecase
to types of
jones scrap your
and its definition
version of eq
matter what type
judgment states that
of polytypic operations
extensible generic functions
list all2 eq
it is and
of new types
of type arguments
in l may
types we use
int bool int
order coercion is
is no branch
new labels there
for new types
rightmost matching branch
appropriate source language
s ls e
all type directed
semantics of typecase
then tostring s
be fully reflexive
matched label therefore
type analysis the
of core l
typecase the full
abstractions in the
universal types and
for label set
we annotate a
kinds of the
the rightmost matching
call functions that
new types without
of types to
kinds for label
that could appear
first order coercions
x else in
can rewrite eq
labels of higher
operation to those

corpus/krapavin2000-test/1040306.txt
mapkey
haskell
arrayelem
declarations
declaration
translation
judgement
dictionary
arrayrep
constructor
arr
cmapkey
int
array
lookup
indexed
mk
functional
dependencies
generic
siek
typing
garcia
traits
overloading
inst
ml
mapint
mappair
lumsdaine
target
hinze
optimising
akin
superclasses
jones
library
libraries
indexint
erent
peyton
parametric
sigplan
map
td
jeremy
overloaded
classes
jaakko
cls
intensional
dictionaries
notices
datatype
judgements
chakravarty
simon
evidence
witness
pairarray
duck
newtype
sulzmann
lookupdict
refm
jeremiah
jrvi
unboxed
adata
willcock
formedness
forall
parameterised
arrays
di
typed
signatures
translated
keller
fm1
pgm
brr
gabriele
qualified
translating
polymorphism
patricia
declara
rules
vanilla
harper
erasure
optimisation
instantiation
andrew
ref
manuel
vertex
val
container
synonyms
template
mb
constructors
modules
maps
fresh
reis
duggan
prj
stroustrup
cheney
dmappair
defaultarray
bjarne
curried
vertexes
uintarr
newref
syntax
dependency
mp
instances
indexing
io
self
mentions
signature
generalisation
neubauer
scrap
overbar
decl
stuckey
polymorphic
instantiations
mi
ma
g1
gregor
specialised
generics
parametrised
bool
interfaces
environment
arguments
comparative
source
subtlety
dos
translates
extra
translate
monad
templates
runtime
index
keys
notational
construc
language
constraint
soundness
ar
nice
selector
oh
gabriel
boost
formalise
dependence
default
java
checking
douglas
abstraction
clutter
roman
omitted
style
martin
abstract
elaborated
your
generalised
proposal
kind
hm
mu
tiny
tricky
er
guarded
compiler
programmer
motivating
saturated
validity
tor
associated type
associated types
type classes
data type
type indexed
associated data
functional dependencies
where data
instance declarations
data types
a type
the type
of associated
generic programming
evidence translation
indexed types
the class
type environment
mapkey a
type translation
instance declaration
the instance
the associated
type class
class parameters
array e
system f
garcia et
map k
type system
type parameters
class declaration
data map
class mapkey
arrayelem e
the dictionary
type variable
type declarations
an associated
haskell s
the translation
top level
type parameter
data array
dictionary environment
type map
type array
element type
instance mapkey
value declarations
self optimising
finite maps
types in
classes with
type variables
type constructor
types by
type analysis
generic haskell
in haskell
of functional
translation of
target language
type must
indexed data
data constructor
class arrayelem
lookup a
ml modules
andrew lumsdaine
e arr
for mapkey
target term
jeremy siek
source types
optimising libraries
key type
map int
of haskell
typing rules
di erent
for generic
class d
a dictionary
akin to
int e
simon peyton
graph library
acm sigplan
declaration for
each associated
translation for
types are
declarations are
level data
intensional type
peyton jones
notices v
translation judgement
type indexing
associated top
template library
mapkey b
language akin
the arrayelem
generic finite
explicitly typed
b lookup
abstract interfaces
the mapkey
mapkey int
sigplan notices
the typing
a context
type declaration
for type
functional dependency
the target
translation is
target types
array example
abstract over
parametric type
programming in
type checking
new type
haskell a
manuel m
t chakravarty
standard type
types and
types to
haskell type
value type
and value
et al
translated to
type to
well formedness
declarations in
type directed
the witness
the array
k v
instance environment
type synonyms
mi d
data vertex
cmapkey a
typed target
multi parameter
arr int
type cmapkey
v lookup
data edge
jeremiah willcock
jaakko jrvi
array type
dictionary function
k mi
d patricia
e array
extra type
hoc overloading
martin sulzmann
of garcia
new datatype
default definition
lookupdict k
b mapkey
and mapkey
representation type
parameterised over
b mp
lookup k
ma mb
by haskell
type erasure
by hinze
target declarations
checking rules
a mapkey
arrayelem class
target terms
formedness judgement
refinement kinds
patricia lookupdict
gabriele keller
be parameterised
the rules
class and
types the
support for
of type
type of
a b
type that
in dependence
type this
for class
the associated type
associated data types
type indexed types
associated data type
of associated types
an associated type
associated type of
garcia et al
where data map
the instance declaration
associated types in
associated type environment
of functional dependencies
generic programming in
type indexed data
data type declarations
the associated types
indexed data types
support for generic
for generic programming
a type class
type classes with
of the class
b where data
the type translation
top level data
the target term
the key type
self optimising libraries
the class declaration
map k v
the data type
intensional type analysis
data type declaration
simon peyton jones
that the type
sigplan notices v
acm sigplan notices
translation is a
associated type to
the instance declarations
each associated type
the evidence translation
an associated data
the element type
generic finite maps
for each associated
haskell s type
associated types of
data type must
parametric type classes
is an associated
associated top level
type translation judgement
target language akin
language akin to
where data array
type system and
haskell type classes
type classes and
rules i and
type must be
the type constructor
i and e
the translation of
manuel m t
m t chakravarty
data types are
is translated to
a b where
a type system
the typing rules
a mapkey b
explicitly typed target
well formedness judgement
d patricia lookupdict
and value declarations
lookup k mi
a class declaration
the class arrayelem
e array e
patricia lookupdict k
for mapkey a
the class parameters
its translation is
type of d
akin to system
lookupdict k d
of type indexed
mapkey b mapkey
type map k
instance declaration for
be parameterised over
of garcia et
a target type
k mi d
associated types for
lookup a b
element type e
associated types are
type checking rules
data types to
associated type array
associated types by
mi d patricia
a b mp
type indexed type
associated type synonyms
of haskell s
applications of associated
of associated data
data types by
instance declarations are
array e int
by garcia et
k where data
int where data
mapkey a b
e int e
into an explicitly
a context to
this data type
an explicitly typed
to system f
class declaration for
between type classes
mapkey a mapkey
s associated type
type environment and
the array type
typed target language
ad hoc overloading
instance mapkey a
the dictionary environment
must be parameterised
the type map
the associated data
b lookup a
notices v 40
a data type
given in figure
in a type
the type variables
of an associated
the functional dependency
the translation for
the array example
the well formedness
for functional dependencies
its parent class
a type indexed
with functional dependencies
translation of type
programming in c
the instance for
a new type
to the type
the rules for
a type directed
in dependence on
system is that
the target language
with the class
to the associated
notices v 41
type of the
in a class
from the instance
we would expect
the declaration of
the class and
the source language
v 40 n
we shall discuss
feature of our
the support for
the syntax of
v 41 n
types of the
our system is
in addition to
mappair ma mb
type indexing is
2 associated types
key type k
the kind checking
associated type at
used in rules
the type parameters
mapkey int where
we abstract over
invalid because the
by haskell s
the matrix template
introduce type indexed
associated types the
type declaration t
class mapkey k
in generic haskell
source term e

corpus/krapavin2000-test/606523.txt
covering
equivariant
cayley
automorphism
automorphisms
action
aut
act
lifts
voltage
coverings
stabilizer
dart
bre
cay
actions
faithful
transitive
walks
schreier
conjugacy
homomorphism
projection
generators
darts
coset
regular
beg
lift
autm
subgroup
group
cov
lifting
ker
eq
isomorphism
digraphs
graphs
vertex
ct
morphisms
morphism
involution
isomorphic
projects
projections
stabilizers
voltages
subgroups
acts
homomorphisms
mnp
arising
orbits
maps
map
epimorphism
loc
walk
orbit
presentations
hjg
sch
cosets
quotient
gz
adm
inv
lifted
id
acting
vertices
digraph
surfaces
reconstructed
preserving
isomorphisms
dened
bijective
invariant
singerman
monopole
cotree
onto
di
groups
proposition
hr
closed
nite
projecting
z
bijectively
bijection
conjugate
respective
regularly
incidence
transversal
conversely
oriented
generating
multiplication
epimorphisms
equivariantly
semiedges
macbeath
hypermaps
reidemeister
permutation
combinatorial
ng
denes
vega
homotopic
relators
pointwise
spanning
word
extends
permutations
fr
cw
disguise
orientable
denition
nonempty
branched
topological
arc
ser
induced
connected
combinatorially
lar
nu
mappings
admissible
intersects
fold
centres
switching
saying
transitively
jones
mapping
rise
lg
projected
multiset
inline
transformations
36
covers
rooted
cient
faithfully
trivial
induces
associate
su
fw
restrictions
45
correspondence
jg
znanost
aleksander
subgoups
variuos
siran
admz
slovenije
rewr
burnside
semiregularly
tomaz
spit
monopoles
semiedge
uniformes
graphes
hurwitz
sommet
valency
antly
addtional
cyclicaly
bq
homological
cellularly
automomorphisms
malni
znfb
ministrstvo
koviera
lins
kjg
0496
z g
g s
covering projection
act z
the equivariant
a covering
equivariant group
action graph
action graphs
the action
g g
g b
the covering
of act
voltage space
cay g
covering of
automorphism of
an action
action automorphism
action automorphisms
aut z
cayley graph
act g
of actions
covering projections
regular covering
cayley multi
the group
of g
of action
example 8
automorphisms of
the cayley
closed walks
oriented maps
eq z
regular map
is regular
action of
a cayley
of covering
if and
group eq
di graph
coverings of
of automorphisms
a regular
lift of
of oriented
homomorphism of
graph act
eq g
an automorphism
and only
a homomorphism
g is
structure preserving
along g
is transitive
group of
ct p
trivial voltage
generating cayley
g projects
ker q
an equivariant
schreier coset
the dart
aut s
on z
covering is
a generating
arising from
multi set
transitive and
only if
automorphism group
subgroup of
generators of
z s
regular if
set z
stabilizer of
g lifts
a voltage
ng g
faithful then
covering graph
graph cay
base graph
a schreier
dart set
lifting condition
from actions
conjugacy class
g be
is isomorphic
the generators
morphism of
2 z
isomorphic to
z 2
map d
group actions
b b
a morphism
projection of
and faithful
generating set
action digraphs
projects if
covering transformations
group presentations
is equivariant
right multiplication
group aut
lifts along
of darts
of cay
sch g
projection g
action z
equivariant covering
transitive actions
transitive graphs
vertex bre
projects along
action digraph
g z
an invariant
group g
graph is
is faithful
s is
a subgroup
graphs and
maps on
z and
the vertex
of cayley
the stabilizer
cayley graphs
a lift
in act
extends to
s z
of maps
b g
g and
the respective
be reconstructed
the lifting
vertex set
a group
acting on
g acts
generators and
multi sets
s if
q 1
theorem 9
relative to
autm lifts
lifted group
maps where
graph x
the bre
adm s
lifts of
a stabilizer
regular homomorphism
split extension
general topological
closed walk
invariant covering
then aut
loc b
conjugacy classes
coset di
dart x
natural projection
cov f
switching involution
action di
normal stabilizer
hr li
cayley voltage
from coverings
derived covering
q n
g q
example 5
theorem 8
if g
s g
h 0
then act
automorphism is
of stabilizers
act z g
the equivariant group
g g s
z g s
the action graph
g s is
a covering projection
if and only
a covering of
cay g s
aut z g
an action automorphism
covering of actions
and only if
of act z
of action graphs
the covering projection
eq z g
g s if
of oriented maps
a regular map
covering projection of
automorphism of act
the action of
a regular covering
act g s
homomorphism of oriented
action graph act
action automorphism of
cayley multi set
z 2 z
z g is
a homomorphism of
s if and
is isomorphic to
equivariant group eq
graph cay g
g is faithful
generating cayley multi
of action automorphisms
ng g b
the cayley graph
transitive and faithful
equivariant group of
be a covering
along g g
the dart set
cayley graph cay
theorem 5 6
the covering is
action z g
an action graph
of the equivariant
projects if and
a schreier coset
a lift of
g g r
g s be
a voltage space
the lifting condition
map d r
coverings of actions
of act g
regular if and
group eq g
arising from actions
z g lifts
of covering transformations
projects along g
a generating cayley
q 1 g
if the covering
g is transitive
a morphism of
action of g
1 g b
a cayley graph
d r l
s is isomorphic
is a regular
z and the
of automorphisms of
c b b
an automorphism of
group of automorphisms
if g is
is regular if
in theorem 5
cayley voltage space
maps where m
of covering projections
the derived covering
conjugacy class of
projection of action
the base graph
group eq z
covering is regular
eq g projects
along a regular
sch g h
g projects along
the action digraph
a normal stabilizer
s z g
an invariant covering
automorphism of g
from coverings of
schreier coset di
isomorphism classes of
cayley multi sets
by right multiplication
the switching involution
from a covering
of a voltage
action graph structure
theory of maps
the covering graph
action di graph
group of covering
oriented maps where
a regular homomorphism
is faithful then
class of stabilizers
of cay g
automorphisms of act
regular covering projection
to the cayley
g be a
the vertex set
of the respective
m is a
is a morphism
the group of
h h 0
b g b
and the switching
the generators of
theorem 9 1
that the covering
with a normal
z g we
q n g
as in theorem
of the action
m be a
means of a
only if there
be reconstructed by
g s and
is transitive and
a connected graph
if there exists
of g and
proposition 7 1
can be reconstructed
only if q
be a regular
is an action
a group g
of z g
the required generators
2 g b
be a generating
a covering arising
action graphs and
theorem 8 3
covering of transitive
at z 2
let s g
as the vertex
is transitive on
is an equivariant
of connected graphs
covering arising from
all closed walks
an equivariant covering
a cayley voltage
s g g
exists an action
g h s
group hr li
x the covering
s g be
set z and
action digraph act
let h h
lifting and projecting
maps on surfaces
extension of ct
projection arising from
aut s g
as the dart
m is also
same conjugacy class
the fundamental group
the group aut
of closed walks
covering projection p
left regular representation
group of cay

corpus/krapavin2000-test/606529.txt
letter
lettericity
sigma
quasi
vertices
graphs
subgraphs
subgraph
induced
adjg
3k
obs
vertex
clique
alphabet
unbounded
letters
precedes
forbidden
subword
labelled
gamma2
nonisomorphic
cochromatic
obstructions
superscripts
threshold
adjacent
word
4c
halflines
halfplanes
toma
cobipartite
707
symbols
rise
ordered
interval
labels
bipartite
bojan
dm
reflexive
complements
tight
corollary
proposition
cyclically
ding
adjacencies
recognizable
intersection
cycle
minor
cycles
extremal
nonempty
ordering
neighbors
occurrences
label
permitting
finitely
distinguish
transitive
iii
polynomial
ababa
antichains
xly
abcabc
rlg
nonisolated
embeddabil
nonconstructive
matroidal
recognized
assertions
ag
paths
intervals
contiguous
fc
impossible
isomorphism
antichain
pendant
chv
atal
csg
robertson
higman
dichromatic
pisanski
labellings
mohar
arranged
nonnegative
damaschke
gers
kruskal
endpoints
infinite
monoid
bordering
thm
3e
homeomorphic
ab
indices
coincides
isomorphic
gamma4
seymour
jrj
census
matchings
divisibility
inte
hammer
family
rewrite
cardinality
forces
gammai
ideals
triangulated
resp
characterization
1c
equivalence
iff
lemma
complement
gamma1
ng
finiteness
ba
restate
neighborhoods
423
gamma3
counting
topological
bijection
4g
intervening
rr
homomorphism
reversing
proved
conversely
aa
famous
closure
ff
logarithms
listing
indebted
disjoint
ideal
mod
exceeds
recognition
minimal
algebras
perfect
labelling
helping
2e
union
swapping
rg
fig
arrangement
discarding
reducible
jv
versus
leftmost
characterize
ity
rightmost
block
fg
decidable
relation
adjacency
stable
dn
enumerate
wishes
partition
closed
suffice
linearly
aggregation
undirected
classes
letter graphs
well quasi
k letter
lettericity of
g sigma
letter graph
quasi ordered
2 letter
induced subgraphs
unbounded interval
induced subgraph
sigma p
the lettericity
n vertex
threshold graphs
independent set
p w
in w
subgraph relation
g p
k a
interval graphs
ordered by
vertex graphs
n vertices
forbidden induced
an independent
a clique
3 k
quasi order
a 3
vertices of
v g
a 1
c n
subgraphs and
precedes a
obs g
g k
all graphs
quasi ordering
on n
graph g
1 precedes
l g
a graph
adjacent to
the induced
where superscripts
size three
length 3k
minimal forbidden
clique or
graphs is
g is
g y
a i
of g
different letters
graphs on
of graphs
and well
k gamma2
of unbounded
y if
a 2
w is
of letters
each letter
x g
of w
c 3k
707 n
nonisomorphic n
of obstructions
vertex graph
i gamma2
three occurrences
4c letters
n 4c
in g
the labels
graphs in
a word
i a
2 k
relation defined
graphs and
of k
of length
sigma n
under taking
gamma2 then
cycle k
c 4
h m
is adjacent
polynomial time
labels of
l y
l h
by i
graphs can
0 707
a letter
intersection graph
graphs are
3 i
the vertices
is tight
graphs as
1 k
p n
the cycle
rise to
that l
an induced
l n
w l
recognized in
n j
a k
the class
i g
of threshold
w hence
clique in
sigma 2
these symbols
in polynomial
of size
lemma 1
alphabet and
g assume
2 sigma
hence l
three or
graph on
b n
is well
be between
on four
finite alphabet
label of
graphs g
vertices are
p 4
graph minor
adjacencies we
distinguish four
exceeds 0
least size
word consisting
lettericity exceeds
for easier
superscripts are
rewrite relation
if adjg
toma z
ordering stable
and halfplanes
minor relation
topological minor
th block
word its
letters whose
contiguous subword
vertices 1
graphs unbounded
iii g
fewer vertices
following assertions
g ding
permitting to
subgraph ideal
word obtained
labelled a
cochromatic number
halflines and
p sigma
of nonisomorphic
arranged linearly
labelled the
n labelled
easier reference
graphs closed
ding has
cases w
whose lettericity
being adjacent
letter it
no induced
alphabet permitting
superscripts distinguish
taking induced
sigma gives
whose letter
threshold graph
versus independent
equivalent ii
quasi ordered by
k letter graphs
g p w
g sigma p
2 letter graphs
well quasi ordered
the lettericity of
an independent set
unbounded interval graphs
a 3 k
on n vertices
is well quasi
of k letter
k a 1
n vertex graphs
the induced subgraph
k a 2
ordered by the
and well quasi
induced subgraph relation
a i a
a 1 1
x g y
a 1 k
p w is
to an independent
forbidden induced subgraphs
a 1 precedes
well quasi ordering
a graph g
vertices of g
a clique or
of 2 letter
of length 3k
or an independent
clique or an
well quasi order
of size three
l h m
are well quasi
ordered by i
a k letter
pairs of letters
lettericity of a
subgraphs and well
induced subgraphs and
1 precedes a
minimal forbidden induced
either a clique
3 k a
letter graphs is
1 k a
a 2 k
by the induced
of g p
2 k a
rise to an
check that g
that g p
k a 3
graph g is
the labels of
independent set of
graphs on n
are n vertex
a letter graph
interval graphs and
independent set s
obs g sigma
b n 4c
gamma2 then it
as a letter
the cycle k
letter graphs and
vertex graphs in
must be between
l g assume
three occurrences of
graphs is well
is the cycle
be recognized in
n vertex graph
p as x
n 4c letters
k letter graph
g y if
that x g
cycle k a
of threshold graphs
letter graphs can
s is tight
recognized in polynomial
of unbounded interval
sigma p and
lettericity of cycles
nonisomorphic n vertex
w l g
sigma p is
i gamma2 then
hence l h
0 707 n
all graphs on
set of size
this is impossible
graphs can be
is adjacent to
g is denoted
an n vertex
has proved that
x l y
an induced subgraph
closed under taking
1 a 3
is an induced
of a graph
g as a
the vertices of
the class of
that a 1
graph on n
vertices of c
of v g
in w and
finite alphabet and
induced subgraph of
class of k
as x l
w is the
a word w
a 3 1
three or more
in polynomial time
ordered pairs of
n there are
of ordered pairs
the label of
g assume that
set of ordered
g k is
can be recognized
a finite alphabet
classes of graphs
of c n
this case x
easy to check
g is the
n is large
y for all
it follows that
gives rise to
of an n
labels of the
from theorem 4
graphs on four
the intersection graph
no induced subgraphs
however being adjacent
in sigma n
symbols from sigma
of each letter
relation defined at
graphs from g
distinguish four cases
see how these
n the path
quasi order on
which define adjacencies
sigma n coincides
are equivalent ii
obs g k
intersection graphs of
subgraphs as a
all three occurrences
determine the lettericity
quasi order by
the word obtained
t n mod
superscripts are added
theorem 2 iii
graphs is 2
t i gamma2
remains to see
a counting argument
conversely let g
g p z
for g sigma
for easier reference
to obtain g
whose lettericity exceeds
has no induced
being adjacent to
corresponding to those
sets versus independent
corresponding vertices this
k different letters
graph is c
precedes a 2
cases w r
a graph which
the corresponding vertices

corpus/krapavin2000-test/606695.txt
wcsl
_
stability
cos
sin
switched
switching
lyapunov
homogeneous
trajectory
controller
margaliot
holcman
rh
law
origin
rv
clockwise
unstable
stabilizing
ugas
polar
asymptotically
trajectories
closed
sgn
rotates
rst
contours
su
cient
dv
const
bxg
rapoport
pyatnitskiy
es
integral
homogeneity
integrals
satises
f0g
veriable
stable
fax
designing
coordinates
destabilizing
encircling
langholz
stabilized
dynamical
unbounded
contour
denition
characterization
asymptotic
weizmann
nonlinear
rotate
boundary
counter
dene
radially
dierential
lemma
nd
fig
equilibrium
positively
chapter
convex
admits
stabilizes
transforming
zeros
df
invariant
converse
hamiltonian
yields
dierentiable
numerically
generalized
uncertain
israel
eq
contradiction
curve
stabilize
converges
perturbed
appendix
cone
stay
rotating
stableg
michaelm
homo
theless
h2r
dieren
liberzon
polysystems
76100
geneous
variartional
polytopic
69978
98513
jj
direction
novel
electrical
ln
x1
around
jump
absolute
filippov
1940
3439
integrand
dx2
aviv
fillipov
rehovot
nonquadratic
popov
2k
il
piecewise
concatenation
analyzing
xed
fa
regained
rmative
tial
tau
jjf
spiral
wisdom
tel
actuators
rection
morse
depicts
singular
dened
di
banach
dierentiate
constructive
verify
ac
analyze
recipe
attains
eng
stabilization
verifiable
collinear
explicit
globally
undergo
economics
regime
ay
digit
cult
notations
feedback
inclusions
innitely
pushes
2r
k2
nt
synthesize
absolutely
norm
denite
solutions
substituting
geometrical
matrix
bilinear
hybrid
xg
characterizations
swap
deriving
detecting
smallest
synthesizing
elds
tan
parameterization
x2
switching law
homogeneous systems
order switched
switched homogeneous
switching controller
x t
of _
system _
cos sin
the origin
switched linear
second order
a switching
solution corresponding
asymptotically stable
generalized rst
rst integral
of wcsl
holcman and
m margaliot
d holcman
stability analysis
sin cos
stability of
the switching
lyapunov function
clockwise direction
to wcsl
invariant set
rh f
cient stability
closed trajectory
h x
and su
the stability
g x
wcsl is
unstable solution
closed solution
polar coordinates
linear systems
su cient
solution of
switched systems
asymptotic stability
r _
most unstable
the trajectories
necessary and
a stabilizing
stability condition
a closed
f x
counter clockwise
sin sin
line l
for second
the solution
designing a
r sin
f g
trajectories of
function v
v x
the trajectory
rotates around
trajectory of
origin in
of 3
x g
cos j
rv x
is ugas
to polar
homogeneous functions
for switched
absolute stability
stabilizing switching
lyapunov theorem
x 2
the system
lemma 5
an invariant
g 2
x 0
r 2
2 cos
origin is
n f0g
7 1
j r
_ r
the contours
of second
see 5
the closed
around the
contours of
whose proof
0 such
every solution
positively homogeneous
case switching
veriable necessary
converse lyapunov
and rapoport
be stabilized
fax bxg
order homogeneous
the homogeneity
satises _
a clockwise
explicit lyapunov
contour h
_ 0
_ x
stability problem
easily veriable
order systems
pyatnitskiy and
the switched
rst integrals
es n
rotate in
get _
all x
assumption 1
are homogeneous
the denition
of 2
the generalized
coordinates we
denition of
a counter
an easily
of stability
sin r
_ where
_ to
stability conditions
trajectory x
unbounded and
smallest k
homogeneous of
closed curve
sin j
lemma whose
for designing
theorem 5
any x
is closed
solution x
that yields
and therefore
2 es
law that
in polar
t converges
homogeneity of
equilibrium point
of degree
controller that
and g
and m
that f
a solution
law and
controller for
integral of
a trajectory
the line
5 6
there exists
x is
yields an
characterization of
is easy
is homogeneous
fig 5
of analyzing
switching between
is unbounded
the boundary
we get
switching stability
wcsl to
since rh
common lyapunov
unstable systems
contours const
_ cos
destabilizing switching
solution rotates
focus and
a lyapunov
rh g
radially unbounded
scaling see
wcsl by
curve encircling
order switched homogeneous
switched homogeneous systems
second order switched
a switching controller
the solution corresponding
solution corresponding to
switched linear systems
around the origin
the switching law
holcman and m
and m margaliot
d holcman and
f g 2
and su cient
necessary and su
an invariant set
corresponding to wcsl
the system _
su cient stability
of 2 3
the stability of
of 3 1
the trajectories of
h x t
cos sin sin
the generalized rst
cient stability condition
for designing a
generalized rst integral
invariant set of
the most unstable
analyze the stability
origin in a
a closed trajectory
counter clockwise direction
solution of _
most unstable solution
x g x
of 1 1
a counter clockwise
rotates around the
in a counter
the origin in
consider the system
x t is
solution of 2
the line l
is a closed
for second order
that x t
is an invariant
_ r _
unstable solution of
designing a stabilizing
sin cos j
polar coordinates we
designing a switching
to polar coordinates
2 n f0g
a stabilizing switching
origin is a
a closed solution
for switched linear
stability analysis of
algorithm for designing
stabilizing switching controller
along the trajectories
rh f x
boundary of stability
coordinates we get
denition of wcsl
of second order
r 2 n
yields a closed
of 3 3
solution x t
any x 2
for all x
f x and
g x 0
the origin is
sin sin cos
0 such that
by the denition
a solution of
theorem 5 6
the denition of
of lemma 5
generalized rst integrals
absolute stability problem
worst case switching
switching law and
switching law that
a switching law
second order homogeneous
functions of degree
lyapunov theorem for
lyapunov function that
rv x g
problem of analyzing
f 2 es
we get _
9 and 5
sin j r
r sin cos
cos sin j
easily veriable necessary
rst integral of
trajectories of 3
see 5 1
j r sin
order homogeneous systems
system 2 3
explicit lyapunov function
pyatnitskiy and rapoport
veriable necessary and
is x t
converse lyapunov theorem
x t converges
cos j r
homogeneous functions of
the homogeneity of
asymptotic stability of
switching controller for
an easily veriable
x is homogeneous
is asymptotically stable
in a clockwise
lyapunov function v
case switching law
f x g
2 r 2
x 2 r
is easy to
to the origin
stability of 2
analyzing the stability
t converges to
function v x
x t with
the smallest k
5 9 and
lemma whose proof
lemma 5 5
trajectory x t
f and g
theorem 5 3
it is easy
easy to verify
if and only
and only if
2 if and
the system 2
g 2 then
on r 2
in polar coordinates
and 5 10
all x 2
proof of lemma
whose proof is
x and g
lemma 5 4
v x is
and g x
that h x
h x is
x 2 d
proof is given
if f g
the trajectory of
theorem 7 1
if the solution
x t of
g 2 if
lemma 5 2
may be seen
of the closed
trajectory of the
to verify that
in the appendix
for any xed
2 3 is
this holds for
stability of the
the boundary of
converges to the
the solutions of
that is x
r in 5
closed curve encircling
law that yields
smallest k 0
_ cos sin
detecting the boundary
positively homogeneous of
2 es and
exists a switching
margaliot and langholz
r _ cos
can be stabilized

corpus/krapavin2000-test/606706.txt
renable
mask
dilation
smoothness
interpolatory
2z
sobolev
exponent
symmetry
mz
quincunx
multivariate
masks
subdivision
matrix
exponents
eigenvalues
interpolating
2i
refinable
lattice
wavelets
satises
nitely
2k
shifts
spectral
hexagonal
isotropic
han
symmetric
invariant
axes
nonnegative
radius
norm
multiplicity
44077
nf0g
bin
dened
l1
compactly
jia
holder
16321
jj
converges
rs
stable
shall
dene
d3
bhan
group
culty
wavelet
renement
numerically
ualberta
symbol
subspace
quantity
biorthogonal
bivariate
nite
regularity
cients
coe
numerical
cbc
1161
44792
ima
16j6d
2mz
17513
d2
therein
rules
dual
operator
2r
matrices
linearly
det
quantities
joint
alberta
corollary
subgroup
992
cagd
quotient
di
eigen
cosets
butter
d1
dimension
transition
coset
denition
anisotropic
dyadic
stability
levin
references
spaces
2d
acting
matlab
completes
aided
kr
modulus
cascade
mm
lim
splines
representatives
dim
duality
11719
18321
34408
91546
36283
3241
86202
g227120136
5601
90251
riemenschneider
ree
28036
24389
teicher
zuowei
28260
igpm
deslauriers
oswald
villemoes
56039
21534
mina
zulti
01166
70431
65242
81143
11171
pinterpolatory
194481
99752
85293
79313
71514
nfg
warranty
92850
nfjj
33522
shen
schemes
3d
zhang
factorization
counting
greatly
family
equivalently
demonstrated
2g1
bidimensional
8911
tempered
g121210654
fredholm
kuk
hogan
dubuc
adi
preassigned
ca
overcome
routines
mention
min
generalizing
dilations
679
kak
determinants
659
extraordinary
nonseparable
uniqueness
interpolation
renable function
dilation matrix
smoothness exponent
2z d
symmetry group
sum rules
mask a
sobolev smoothness
exponent of
renable functions
z d
b m
algorithm 2
the dilation
a m
a mask
the sobolev
interpolatory mask
multivariate renable
the mask
symmetric multivariate
smoothness exponents
invariant under
matrix m
on z
the renable
interpolating renable
lattice mz
a symmetry
mz d
nitely supported
the smoothness
subdivision scheme
a dilation
r d
full axes
exponents of
the shifts
a satises
group with
symmetric renable
mask g
a renable
matrix 2i
shifts of
of order
satises the
is invariant
spectral radius
a symmetric
rules of
t b
an interpolatory
interpolatory masks
the quincunx
the eigenvalues
the lattice
2k 1
eigenvalues of
a nitely
masks in
v 2k
axes symmetry
supported on
an interpolating
compute 2
supported mask
mask with
mask on
quincunx dilation
order k
d r
converges in
k a
bin han
2i 2
subdivision schemes
mask and
is isotropic
function with
multivariate re
the hexagonal
m converges
with mask
the matrix
p norm
have k
in 25
m j
m a
and dilation
the l1
numerical computation
l p
in algorithm
refinable function
scheme associated
group a
computing the
a is
mask of
d 2z
the interpolatory
computing smoothness
joint spectral
norm joint
transition operator
rs r
of symmetric
by algorithm
the subdivision
matrix t
the sum
the symmetry
compactly supported
general dilation
corollary 3
linearly independent
we shall
g 3
l1 norm
are linearly
method in
are stable
hexagonal symmetry
dilation m
2i 3
subspace v
matrix mask
dilation matrices
renement equation
holder smoothness
quantities m
group h
by 2z
dimension three
2 44077
m 2z
mz 2
dual mask
symbol of
by corollary
is supported
d such
m is
sequence u
g d
let a
of are
let be
culty in
respect to
the spectral
a 3
dened to
not k
interpolatory subdivision
numerically stable
with respect
of multivariate
smoothness of
a d
to compute
2 1
is nonnegative
2 n
is dened
matrix size
m d
a be
m be
radius of
matrix and
m 1
example 4
the numerical
g r
operator t
quincunx lattice
m invariant
mask is
2r with
mask 2d
have 2z
mask has
a compactly
2d mask
u 2k
j det
jj 6
6 jj
p smoothness
and renable
isotropic dilation
function vectors
using method
counting multiplicity
nonnegative symbol
order 2r
order 2k
smoothness exponent of
dilation matrix m
the dilation matrix
sum rules of
rules of order
algorithm 2 1
the sum rules
exponent of a
t b m
on z d
satises the sum
the smoothness exponent
the sobolev smoothness
is invariant under
a symmetry group
mask a and
renable function with
a dilation matrix
group with respect
symmetry group with
computing the smoothness
of a symmetric
multivariate renable function
the lattice mz
a symmetric multivariate
symmetric multivariate renable
the renable function
to the lattice
the shifts of
sobolev smoothness exponent
smoothness exponents of
lattice mz d
interpolating renable function
a satises the
a renable function
dilation matrix 2i
invariant under the
the eigenvalues of
k a m
the mask a
a nitely supported
an interpolatory mask
method in 25
and the dilation
all the eigenvalues
is supported on
with the mask
the full axes
to compute 2
full axes symmetry
axes symmetry group
converges in the
v 2k 1
in algorithm 2
of order k
1 a m
to the dilation
the numerical computation
shifts of are
m is isotropic
is an interpolatory
is an interpolating
an interpolating renable
the quincunx dilation
is a symmetry
mask on z
be the renable
nitely supported mask
z d such
respect to the
2 a m
by algorithm 2
corollary 3 2
symmetry group a
g d r
mask a is
a is invariant
we have k
subdivision scheme associated
therefore by corollary
of a renable
interpolatory masks in
sobolev smoothness exponents
exponents of symmetric
m converges in
interpolatory mask with
mask g 3
mask with respect
a and dilation
the symbol of
with respect to
by corollary 3
under the full
the subdivision scheme
scheme associated with
the spectral radius
spectral radius of
numerical computation of
algorithm 2 5
norm joint spectral
of z d
joint spectral radius
shifts of m
have k a
symmetric renable functions
the mask g
p norm joint
l p r
interpolatory mask a
the interpolatory mask
2z d 2z
2z d r
d 2z d
in the l1
symmetric renable function
renable function and
compute the sobolev
a m p
p r d
of symmetric renable
a symmetric renable
dilation matrix and
the transition operator
a mask a
a d d
a be a
of m a
general dilation matrix
a m d
a general dilation
1 6 p
that the symbol
a m 1
theorem 3 1
p a m
eigenvalues of t
z d and
m 1 1
the l1 norm
d such that
are linearly independent
m be a
for the numerical
2 r d
2 n 0
function with a
the di culty
be a mask
in dimension three
not k 1
the quantities m
quincunx dilation matrices
to a dilation
m a are
b is invariant
be a symmetry
but not k
a mask on
be a dilation
associated with mask
2z d m
computing the sobolev
a m 2
the hexagonal symmetry
m 2z d
matrix m it
when a mask
that a satises
with mask a
quantities m j
order k but
matrix 2i 2
of are linearly
dened in 1
by 2z d
z 3 a
and dilation matrix
hexagonal symmetry group
with a nitely
account the symmetry
algorithms 2 1
function with the
j 2 n
dened to be
let a be
di culty in
which is much
2 1 we
the method in
6 p 6
a is nonnegative
the l p
function and 2
r d we
2 n d
that the shifts
the matrix size
1 we have
using algorithm 2
of order 4

corpus/krapavin2000-test/606717.txt
spai
multigrid
smoothers
coarsening
smoother
smoothing
seidel
gauss
amg
sparsity
grid
sparse
inverses
diusion
interpolation
convergence
preconditioners
inverse
coarse
approximate
preconditioner
damped
jacobi
pq
frobenius
algebraic
uences
anisotropic
ilu
coarser
dierential
eective
rotating
stuben
grids
mg
ow
preconditioning
priority
dependencies
mak
128128
convection
robustness
geometric
diagonal
norm
ruge
equispaced
gridsize
huckle
anisotropy
galerkin
convergent
prolongation
dependency
discretization
pp
shall
locally
inherently
weakly
qq
di
rates
denite
operators
ki
mesh
cult
entries
stencil
iteration
grote
preconditionings
uh
residual
squares
priori
128
adaptivity
symmetric
unstructured
interplay
strong
hackbusch
prolongations
benzi
cheap
interpolated
ve
nest
boundary
stencils
q3
agglomeration
adjusted
matrix
triangular
green
correction
promising
coarsest
satises
ll
tang
denser
xed
neighbors
aligned
factorized
diverges
weak
culty
heuristic
dened
tolerance
solver
smooth
laplacian
expert
pattern
inherent
comparative
levels
usefulness
greedy
proceeds
row
interpolating
mpi
numerical
splitting
scalability
cient
smoothed
siam
elliptic
approximates
nonzero
culties
conguration
frequency
dominated
sorted
parallelize
multilevel
classical
prescribed
dierences
wan
controls
cycle
agonal
benson
undecided
15index
q3141312
smoo
decient
strategy1020301020300
mccormick
lently
thers
computersmyampersandmdash
3232
stben
512512
riority
beowulf
10231023
wesseling
frederickson
upwinding
tuma
6464
40964096
meurant
candidates
nite
parallelism
densities
hierarchy
strongly
conjugate
dier
94
ciently
circles
strategy
tends
greatly
powers
ciency
lu
eth
nev
couplings
cosity
ertheless
spai 0
spai 1
approximate inverse
sparse approximate
the spai
gauss seidel
approximate inverses
algebraic multigrid
coarse grid
sparsity pattern
and spai
spai algorithm
multigrid iteration
q m
a pq
of spai
c points
the smoother
coarsening strategy
f points
damped jacobi
the coarsening
spai smoothers
convergence rates
inverse preconditioners
geometric multigrid
seidel smoothing
rotating ow
frobenius norm
the smoothing
m q
smoothers for
smoothing property
the sparsity
the frobenius
inverse m
algebraic coarsening
locally anisotropic
the coarse
pattern of
multigrid methods
the multigrid
sparsity patterns
in uences
m h
the coarser
inherently parallel
1 smoother
for multigrid
for spai
coarsening algorithm
anisotropic diusion
the rotating
grid selection
h k
of m
x k
a convergent
grid levels
a pp
c point
ow problem
a sparse
mak in
0 spai
ki mak
smoothers spai
table amg
improved robustness
amg convergence
coarsening goal
of multigrid
dependencies of
we shall
for geometric
smoothing steps
f point
y h
most promising
a multigrid
proceeds until
the diusion
multigrid method
grid correction
point p
m is
of sparse
unstructured grids
classical smoothers
geometric mg
green s
weak dependencies
spai smoothing
semi coarsening
interpolation operators
xed sparsity
local adaptivity
inverse smoothers
with spai
seidel 0
frequency behavior
multigrid v
v cycle
m gauss
eective sparsity
multigrid solver
non expert
seidel and
convergent multigrid
f splitting
smoother q
a qq
0 smoother
ilu smoothing
with gauss
two grid
smoothers based
as smoothers
symmetric gauss
seidel spai
uences of
c dependency
rates q
via sparse
strong dependency
to damped
norm for
an eective
di cult
matrix a
solution of
the approximate
partial dierential
and algebraic
positive denite
the discretization
even further
2 94
parameter free
grid method
smoothing step
preconditioner for
smooth error
priori sparsity
inverse preconditioner
smoother is
interpolated from
approximation property
the error
convergence rate
the interpolation
least squares
k th
a priori
inherent parallelism
o diagonal
remain bounded
row m
rates obtained
ll in
smoother for
for interpolation
high frequency
the convergence
coarser level
the gauss
the nest
0 18
smoothing and
points are
end for
m of
leads to
smoothing in
squares problems
unknown a
overall complexity
linear systems
d q
greedy heuristic
robustness and
dierential equations
algorithm proceeds
even by
on level
the matrix
q 2
linear system
all points
obtained with
s function
patterns for
robustness of
diagonal smoothers
jacobi or
denser m
problem 12
property 15
smoothers are
inverse smoother
sparse approximate inverse
sparsity pattern of
pattern of m
and spai 1
m q m
q m q
sparse approximate inverses
spai 0 and
the spai algorithm
the frobenius norm
approximate inverse preconditioners
the sparsity pattern
gauss seidel smoothing
0 and spai
in the frobenius
approximate inverse m
spai 0 2
the smoothing property
a sparse approximate
the coarse grid
of m is
rotating ow problem
coarse grid selection
spai 1 smoother
y h k
the spai 1
locally anisotropic diusion
of sparse approximate
x x k
for geometric multigrid
mak in the
1 and spai
spai 1 and
and algebraic multigrid
spai 1 the
smoothers spai 0
ki mak in
spai 0 spai
table amg convergence
algebraic coarsening strategy
the multigrid iteration
0 spai 1
the rotating ow
of the spai
the coarsening algorithm
number of multigrid
the spai 0
the coarsening strategy
the approximate inverse
sparsity patterns for
g x x
end for all
the most promising
coarse grid correction
a and m
the matrix a
smoothers for multigrid
green s function
the spai smoothers
rates obtained with
m h k
an eective sparsity
for the rotating
convergence rates q
multigrid v cycle
gauss seidel spai
1 the sparsity
to damped jacobi
with gauss seidel
in uences of
the coarser level
a convergent multigrid
eective sparsity pattern
c points are
the algebraic coarsening
smoothers based on
symmetric gauss seidel
convergence rates obtained
point p as
high frequency behavior
frobenius norm for
gauss seidel and
smoother q m
approximate inverse smoothers
of spai smoothing
spai 0 is
gauss seidel 0
the gauss seidel
spai 0 smoother
q m gauss
convergent multigrid iteration
c f splitting
m gauss seidel
2 d q
seidel spai 0
two grid method
of spai 0
the convergence rate
the k th
the solution of
on the coarser
approximate inverse preconditioner
o diagonal entries
m of m
the approximation property
on the nest
m is that
proceeds until the
the high frequency
a priori sparsity
unknown a priori
norm for a
k th row
and its neighbors
overall complexity of
the algorithm proceeds
partial dierential equations
least squares problems
inverse of a
o n log
aligned with the
n log n
comparative study of
we shall consider
a point p
cost of computing
a 128 128
the subtle interplay
the parameter controls
on the robustness
pq 6 0
xed sparsity patterns
to the smoother
and stuben 22
ilu smoothing matrix
jacobi or gauss
a two grid
spai algorithm 13
performance of spai
the standard ve
s function interpretation
the interpolation operators
dierent dependencies possible
spai the sparsity
ruge and stuben
most promising candidate
the discrete laplacian
as smoothers for
weight a pq
strong dependency dependency
10 6 3
an algebraic multigrid
inverse preconditionings i
approximate inverses are
points are represented
matrix and preconditioning
coarsening strategy and
to c dependency
and wan 25
squares problem 12
the weight a
on an equispaced
is parameter free
and a pq
via sparse sparse
exceed o n
for geometric and
determines the coarse
interpolation operators which
minimize ki mak
and coarse grid
parallel algebraic multigrid
dependency c point
spai 0 3
of gauss seidel
frobenius norm naturally
all f points
point f point
tang and wan
the original spai
0 is parameter
inverse preconditioners robustness
the discretization the
amg convergence results
f points are
inverse preconditioners via
approximate sparsity patterns
original spai algorithm
spai 1 smoothers
that of gauss
smoother gauss seidel
that sparse approximate
of spai smoothers
via the spai
coarsening goals 1
of the multigrid
preconditioners robustness and
iterative solution of
for varying on
for locally anisotropic

corpus/krapavin2000-test/606722.txt
preconditioner
schur
ainv
nonsingular
inverse
markov
irreducible
complement
singular
matrix
ilu
sep
tot
sparse
preconditioning
separator
ldu
preconditioners
inverses
diagonal
approximate
cgstab
factorization
matrices
krylov
preconditioned
biorthogonalization
chains
penrose
ncd
nonsymmetric
mutex
leaky
incomplete
nonnegative
avg
dom
triangular
bi
processors
nonzeros
factorized
gamma1
telecom
minors
density
subspace
stationary
chain
frobenius
partitioning
nonzero
subdomain
sparsity
nonsingularity
aq
qn
spai
dropping
generator
factorizations
iterative
block
pseudoinverse
conjugate
aa
gamma
structurally
moore
principal
entries
gn
ups
precondi
dayar
cimmino
subgraphs
schmidt
ergodic
subdomains
stochastic
2d
factors
parallelization
dense
numerical
queueing
null
scalability
pivot
entry
iterations
perron
thetam
tioning
jacobi
generalized
processor
ir
nnz
convergence
parallelize
reducible
irreducibility
projector
gram
norm
blocks
90
solvers
gmres
cardinality
oblique
drop
tables
inversion
lu
reliability
84
neumann
symmetric
inner
leading
seidel
pivoting
ods
meth
gauss
products
coefficient
inexact
grows
78
row
accumulation
timings
invertible
converging
breakdown
page
arising
59
multilevel
smoothly
gradient
wavelet
multiplicity
1603
66049
axjj
entrywise
24511
symmetrizable
23426
tril
30977
grul
10073
11414
156026
20261
ffii
5099
20491
62193
5363
9758
15421
platis
splittings
aliakbar
6521
2534
vectorize
17749
onauer
4226
triu
maglogiannis
101041
relativeley
124729
montazer
agapios
2018
16641
39203
arator
7336
straightfoward
593115
104625
3268
gamma16
4919
ilias
10229
metis
mishev
6579
schur complement
the preconditioner
m matrix
approximate schur
approximate inverse
sparse approximate
nonsingular m
separator set
a nonsingular
it time
the approximate
tot time
the ainv
p density
singular m
complement s
the separator
a 11
2 inverse
p time
markov chains
avg dom
sep size
singular irreducible
ainv algorithm
irreducible m
inverse factors
a singular
markov chain
graph partitioning
krylov subspace
inverse of
a gamma
generalized inverse
bi cgstab
chain problems
matrix a
a biorthogonalization
ldu factorization
no its
table matrix
m matrices
the schur
inverse preconditioners
inverse a
diagonal blocks
a gamma1
factorization of
the generator
null space
generator matrix
inverses of
generalized inverses
the ldu
biorthogonalization process
group inverse
leading principal
exact schur
principal minors
preconditioner in
u gamma1
the incomplete
a 21
subspace methods
a sparse
time 1
z 11
approximate inverses
preconditioner for
inverse preconditioner
incomplete process
linear systems
of markov
the diagonal
preconditioner is
the matrix
is irreducible
moore penrose
its it
parallel preconditioner
matrix hard
6 o
1 19
a 22
upper triangular
the stationary
s is
distribution vector
nonsymmetric linear
t aq
preconditioned krylov
z matrix
blocks a
test problems
a parallel
chains a
the group
a is
0 38
hard p
unit basis
approximate 1
diagonal block
diagonal entry
subspace method
schmidt process
aa gamma
for markov
ilu methods
preconditioner has
ergodic markov
incomplete factorization
unit upper
and mutex
drop tolerance
to ilu
preconditioner construction
the moore
structurally symmetric
unit lower
row stochastic
average subdomain
gamma1 11
ilu factorization
gn r
dimensional null
preconditioner can
incomplete a
ncd and
singular case
iterative solvers
approximate inversion
irreducible singular
generalized gram
the singular
markov process
l gamma1
block a
gamma1 and
the markov
11 is
the inverse
inverse techniques
19 0
finite markov
factorized sparse
minors of
chains with
large markov
to markov
dropping in
in factorized
ainv preconditioner
ups are
matrix all
two level
the exact
8 processors
a nonnegative
gamma is
the leading
a 12
u 11
18 1
pseudoinverse a
of nonzeros
nonzeros in
gram schmidt
factorized form
parallel implementation
0 14
markov models
numerical experiments
matrix in
and u
of sparse
factors of
last one
m gamma1
nonzero entry
queueing network
38 0
coefficient matrix
diagonal matrix
21 a
large state
complement is
speed ups
1 39
an irreducible
matrix is
the 1
scalability of
q t
solution of
are positive
see 26
the parallel
matrix with
a z
approximate schur complement
the approximate schur
a nonsingular m
nonsingular m matrix
the separator set
sparse approximate inverse
of the preconditioner
schur complement s
1 2 inverse
is a nonsingular
of a 11
singular m matrix
singular irreducible m
irreducible m matrix
is a singular
the ainv algorithm
a singular irreducible
markov chain problems
of the separator
approximate inverse preconditioners
a sparse approximate
the schur complement
krylov subspace methods
inverse of a
the generator matrix
the group inverse
leading principal minors
the diagonal blocks
complement s is
separator set is
a biorthogonalization process
exact schur complement
a 11 is
diagonal blocks a
the exact schur
approximate inverse preconditioner
of the approximate
s is a
factorization of a
inverse of the
q t aq
2 inverse of
its it time
the ldu factorization
preconditioned krylov subspace
the test problems
blocks a i
that a gamma
the leading principal
in the separator
approximate inverse factors
a z matrix
m matrix in
and u gamma1
the incomplete process
a is a
of the diagonal
gamma1 and u
the approximate inverse
z and w
l gamma1 and
markov chains a
nonsymmetric linear systems
sparse approximate inverses
the preconditioner is
inverse preconditioner for
the 1 2
21 a 22
inverses of the
of markov chains
of the generator
the matrix a
existence of the
a fast and
the preconditioner construction
large markov models
2 inverse a
in the singular
p time 1
and upper triangular
principal minors of
the ainv preconditioner
matrix hard p
finite markov chains
complement s of
a singular m
the average subdomain
preconditioner has been
drop tolerance in
the singular case
minors of a
the graph partitioning
hard p time
distribution vector of
m matrix the
incomplete a biorthogonalization
singular m matrices
krylov subspace method
pseudoinverse a y
positive and the
generator matrix a
gram schmidt process
dimensional null space
it time 1
matrix a the
11 in a
compute the preconditioner
unit upper triangular
irreducible singular m
one dimensional null
nonsingular m matrices
1 19 0
a 11 in
the incomplete a
a gamma is
generalized gram schmidt
no its it
p time 0
approximate inversion of
m matrix a
preconditioner can be
a gamma1 11
all the leading
schur complement is
approximate 1 2
ldu factorization of
the moore penrose
a 21 a
that s is
scalability of the
nonzeros in the
speed ups are
linear systems a
in factorized form
markov chains with
factorized sparse approximate
to 8 processors
matrix all the
in the incomplete
approximate inverse techniques
solution of markov
the inverse of
number of nonzeros
the markov process
0 38 0
up to 8
of nonzeros in
the coefficient matrix
a gamma a
cardinality of the
the last one
a 1 2
factors of a
of the stationary
number of processors
approximation to a
are positive and
of the markov
the existence of
in the graph
number of iterations
obtained with a
the cardinality of
s of a
course of the
of the ldu
a nonsingular approximate
of markov chain
very large markov
comparison of partitioning
p density no
an ergodic markov
schur complement the
set is small
table matrix p
cg for the
0 09 p
the inverse factors
nonsingular approximate schur
of nonsymmetric linear
telecom p time
the subgraphs and
block versions of
ir m thetam
in the ainv
a 22 then
to ilu methods
theory of nearly
dropping in the
inverse techniques in
m matrix proof
level iterative solvers
systems a fast
be a singular
14 no its
generalized inverses of
solution of nonsymmetric
will see this
formed and stored
matrix p time

corpus/krapavin2000-test/606859.txt
differentiable
ncp
differentiability
differential
psi
phi
lipschitzian
complementarity
semismooth
burmeister
fischer
merit
matrices
differentials
nonsmooth
nonlinear
fx
stationary
gowda
bouligand
phijj
1jj
subdifferential
ravindran
thetan
nonnegative
subsequence
locally
matrix
frf
row
echet
co
optimality
jacobian
theorems
dg
variational
omega
diagonal
quadruples
componentwise
univalence
monotone
solves
regularity
frchet
convex
piecewise
newton
unconstrained
continuously
corollary
claim
penalized
clarification
rf
minimizer
nonzero
jz
contradiction
clarke
regular
ad
rn
fa
fr
remark
contradicting
proposition
valued
equivalence
lagrangian
strictly
converging
remarks
proves
superset
ft
62
min
formulating
calmness
defeng
solodov
semiconvex
eodory
carath
tawhid
lorentz
21250
homeomorphisms
facchinei
gamma2
index
ng
calculation
satisfying
inequalities
continuity
smooth
conversely
semicontinuous
versely
mangasarian
zeros
constrained
quasi
strict
soares
compact
minimizing
nonempty
recalled
relaxations
minimizers
semidefinite
gammaz
timization
lim
subcase
implication
injectivity
multivalued
hypotheses
ith
hadamard
p0
referee
bx
separation
weaken
unify
jy
nonsingular
jong
bd
enjoy
mathematics
completes
applicable
baltimore
lg
subsequences
representative
pang
specializing
stated
ff
sun
contradict
jie
weakening
shi
md
abuse
fix
vectors
neighbourhood
convergent
characterizations
164
peng
methodologies
minimization
hx
fv
149
optimization
respec
regularization
algebraic
reformulation
prop
lems
tively
0g
simplicity
hull
maryland
f2
reversed
cg
113
carried
semi
fc
fy
affine
researchers
motivates
inequality
smoothing
implicit
oe
generalized
statements
dealt
func
consequences
h differential
h differentiable
an h
h differentiability
differentiable at
at x
ncp f
t psi
ncp function
r n
differential of
is h
t x
locally lipschitzian
fischer burmeister
p 0
row p
psi x
nonlinear complementarity
merit function
burmeister function
differentiable function
phi x
p matrix
0 property
x with
fx k
f x
differentiability of
an ncp
p matrices
differential given
x consists
p function
complementarity problems
the h
differential t
h differentials
p property
solves ncp
differentiable functions
function phi
f at
the fischer
that phi
of psi
a p
arbitrary when
x solves
co t
regular point
of f
when i
complementarity problem
2 t
of h
stationary point
phi f
necessary optimality
diagonal matrices
j x
function f
that psi
f is
when arbitrary
0 p
the row
theorems 6
applications of
the merit
sequence fx
stationary points
the ncp
strictly regular
subsequence fx
phijj 2
c differentiable
the bouligand
gowda and
bouligand subdifferential
62 j
ncp functions
psi 1jj
1jj phijj
psi is
continuously differentiable
optimality condition
x is
2 r
in r
k j
a subsequence
two applications
x k
t f
matrices then
above corollary
differential is
and ravindran
s x
there exist
that 0
solution of
phi be
differentiable with
i 62
further suppose
0 matrix
2 co
6 0
are nonnegative
of phi
an index
f r
k g
generalized jacobian
under appropriate
suppose if
suppose 0
a semismooth
ad 0
echet differentiable
c differential
quadruples a
0 matrices
lipschitzian at
all quadruples
matrices satisfying
frf x
are diagonal
local global
nonsmooth functions
2 j
suppose that
that x
we see
of p
property then
on r
x and
problem min
co e
fr echet
function under
piecewise smooth
nonnegative diagonal
fa has
local optimal
then proof
that f
j g
b f
exist a
local minimum
n thetan
that ad
index i
a local
x 2
with an
a matrix
x i
x such
that theorems
fixed parameter
min f
see this
a nonlinear
f and
every x
of matrices
convex combination
second application
the stated
nonzero vector
15 there
with t
x when
a 2
above theorem
and 7
application we
a w
x 6
x as
a contradiction
suppose f
theorem is
first application
contradiction since
by further
w d
a solution
x g
stated equivalence
corresponding merit
fx dg
min function
lipschitzian function
ft k
an h differential
is h differentiable
differentiable at x
h differentiable at
at x with
with an h
h differential of
of h differentiability
applications of h
x with an
t psi x
is a p
differential of f
fischer burmeister function
p 0 property
f at x
the row p
consists of p
the h differentiability
of f at
x consists of
has the row
h differentiability of
differential given by
an ncp function
h differential given
as an h
an h differentiable
h differentiable function
a p 0
2 r n
a 2 t
2 t x
in r n
the fischer burmeister
h differential t
solves ncp f
p 0 p
row p 0
2 j x
arbitrary when i
x solves ncp
when i 2
when arbitrary when
differentiable function f
differentiability of f
f is h
is an h
x is a
j x and
nonlinear complementarity problem
row p property
of p matrices
f x consists
differential t x
a p matrix
the merit function
ncp function phi
theorems 6 and
k j g
stationary point of
x 2 r
i 2 j
on r n
of an h
f r n
x and d
is a local
j x when
h differential is
exist a subsequence
theorem is h
co t psi
the h differential
1jj phijj 2
a subsequence fx
h differentiable functions
a nonlinear complementarity
the bouligand subdifferential
h differentiable with
when i 62
necessary optimality condition
strictly regular point
x when arbitrary
gowda and ravindran
i 62 j
psi is h
2 co t
fx k j
psi 1jj phijj
62 j x
t x consists
p 0 matrix
index i such
of p 0
r n and
that t x
nonlinear complementarity problems
two applications of
b f x
suppose that t
the above corollary
r n such
sequence fx k
an index i
there exist a
fx k g
x as an
further suppose that
we see that
a solution of
that x i
every x 2
v a w
exists an index
that 0 2
p 0 matrices
that ad 0
if x solves
diagonal matrices satisfying
phijj 2 is
suppose f r
the problem min
by further suppose
differential is an
be the fischer
differential of phi
if possible that
p matrices then
fa has the
point of psi
w d with
given by further
0 2 co
optimality condition for
a stationary point
quadruples a v
a p function
0 2 t
local optimal solution
2 is h
ncp f proof
fr echet differentiable
2 t psi
are diagonal matrices
suppose if possible
has an h
merit function under
min f x
x are diagonal
p property if
a necessary optimality
nonnegative diagonal matrices
0 p matrices
all quadruples a
ncp f we
minimizing the merit
locally lipschitzian at
a local optimal
frf x g
of all quadruples
0 p function
6 and 7
a function f
a matrix a
t x is
stationary points of
show that phi
a v w
then proof suppose
to an h
at x 2
v w d
x with t
v and w
applicable to the
solution of the
x such that
to see this
a point x
suppose that 0
x 6 0
carried out for
and a matrix
x i 6
a regular point
and d 2
for every x
t x are
function f r
convex combination of
c has the
the second application
and z i
local minimum of
f x k
the above theorem
and x is
r n r
of the h

corpus/krapavin2000-test/606884.txt
gu
skorokhod
t1
gj
entrant
qi
dv
rf
nonnegative
ni
xi
mq
j1
idling
gi
rn
saddle
hamiltonian
uniqueness
complementarity
lipschitz
orthant
xb
queueing
dynamics
server
u0
queue
load
boundary
filippov
ej
bf
aj
ji
interior
dierential
54
hu
dt
fluid
uu
hamilton
service
gub
gua
pgu
optimality
ai
ik
exogenous
maximizer
52
loads
g2
verifications
viscosity
xa
queues
continuity
supremum
x2
trajectory
family
53
reflection
0fori
gtj
tn1
gei
mjt
jk
wi
tn
dai
calculations
confirmed
mj
di
arrivals
x1
andi
policy
customers
feedback
s1
jj
inequalities
integrable
dj
convex
jacobi
virtue
ui
q2
confirmation
accord
idi
jk1
siui
uand
nlt
isaacs
draining
andq
akj
0andq
2s2
uis
s1s
inflow
game
stability
1k
nonempty
projection
strategies
confirming
departures
eect
calculation
velocity
xj
nonzero
coordinate
unserved
dupuis
s2
piecewise
strategy
scalar
existence
dicult
x3
maximal
exit
singleton
pi
p1
45
trac
uwe
infimum
stochastic
nj
backwards
1x
qualifications
formulas
l2
origin
66
entries
exceptions
criterion
confirm
dierent
assertions
region
outer
deductive
qualification
xk
lag
staged
72
gradient
imply
compact
q1
j2
ray
reaches
representable
invariant
exclude
suciently
ak
suces
maximizes
entry
observe
formulation
lemma
confirms
e1
sn
coecients
numerically
invoke
sucient
manifold
satisfied
exception
servers
assertion
e2
insist
pl
verify
x t
q gu
q t
u t
the skorokhod
gu 0
re entrant
dv x
any u
x v
i x
skorokhod problem
load q
v x
u x
skorokhod dynamics
x q
t x
t 0
non idling
p gu
x k
p t
0 t
p x
t1 0
qi t
minimum performance
qi 0
t p
t t1
x 0
that ni
p t1
gu t
x t1
j j
saddle point
given x
t1 p
invariant control
nonnegative orthant
ni p
0 for
with x
complementarity problem
performance criterion
the complementarity
x p
0 q
observe that
the interior
maximal sequence
server re
mq g2
x dv
strategy x
gu q
p rf
t gu
loads q
which x
t remains
t t
t in
52 54
of 52
projection map
state feedback
that x
follows that
the nonnegative
in 45
it follows
single server
x is
and 26
mq gu
gu and
the hamilton
robust control
to 54
x gu
optimal service
fluid models
rf q
hamilton jacobi
hu x
dynamics on
viscosity sense
our family
control vector
velocity projection
entry queue
x mq
state trajectory
all t
we know
of section
optimal control
the saddle
all u
of x
are positive
30 33
queueing systems
t which
the boundary
the uniqueness
control functions
j j1
xi 0
new arrivals
point conditions
for t
over u
in 2
check that
solution of
all i
supremum is
rn and
control function
interior of
i i
of 30
for x
the hamiltonian
scalar multiple
u is
25 and
a scalar
optimal policy
lipschitz in
rf v
gtj gj
control vectors
mjt mj
boundary verifications
special solution
gj x
server examples
feasible maximizer
t dv
bf p
that gj
our single
stability property
1 t1
vertical boundary
gj j
exit k
compact subset
u0 of
reflection matrix
verifications of
nonnegative load
individual hamiltonian
outer boundary
dynamics will
of dv
v rn
0fori f
a skorokhod
queueing applications
ni gu
lipschitz continuity
gi j
entrant line
x for
remains in
is indeed
the service
quadratic programming
function v
t for
the supremum
a load
0 when
the optimal
f l
the optimality
exception to
hamiltonian system
multiple server
a dierential
trajectory x
t1 x
nonnegative entries
those q
conditions 25
numerous examples
simply take
check by
and u0
t 2
that which
we will
that u
the system
x t p
x q gu
u t x
t p t
load q t
i i x
any u x
the skorokhod dynamics
x 0 q
t1 p t1
t x t
minimum performance criterion
the nonnegative orthant
of the skorokhod
p gu 0
the minimum performance
x t remains
0 t t
0 for all
it follows that
dv x t
the skorokhod problem
l i x
gu 0 for
the complementarity problem
gu q gu
t remains in
q gu q
ni p gu
server re entrant
of x t
25 and 26
t x 0
for which x
for any u
of x v
x t 2
of our family
q gu and
t gu t
invariant control vector
q t which
for t t1
q t gu
1 x t
the invariant control
a load q
x q t
any u t
loads q t
skorokhod dynamics on
rf q gu
x t1 p
saddle point conditions
velocity projection map
as in 45
the saddle point
is a scalar
a given x
x t x
0 q t
all t 0
t x q
the load q
x t k
all u x
x 0 k
a scalar multiple
the interior of
section 2 4
t 0 for
that p x
f l i
scalar multiple of
of v x
that x t
f i x
for all t
for all u
that for 0
t 0 we
x t for
that ni gu
the vertical boundary
and u0 of
control functions u
t dv x
v 0 when
state trajectory x
the strict inequality
p t1 p
queues are empty
have so that
qi t 0
given x k
single server re
the service rates
boundary verifications of
the supremum is
t t1 0
x t1 x
a skorokhod problem
u0 of our
which x t
verifications of section
g and u0
the boundary verifications
resulting state trajectory
outer boundary of
the viscosity sense
the outer boundary
bf p gu
function u t
point conditions 25
the velocity projection
control function u
construction of v
when i x
the hamilton jacobi
x x q
all 0 t
of the nonnegative
the j j
re entrant line
t1 x t1
q t and
invariant control vectors
our single server
of dv x
conditions 25 and
complementarity problem is
the reflection matrix
t the resulting
x dv x
the form for
for all i
for purposes of
on the boundary
is a singleton
u x and
x v are
function v x
given x 0
trajectory x t
any x 0
x k with
solution x t
the quadratic programming
p t as
x v in
for x k
family of solutions
j j j
by virtue of
for a given
we know that
x v is
x t in
there does exist
x t to
t t we
on the interior
the optimal control
t 0 the
with x t
q t in
the final stage
i x for
the right side
in the interior
of section 3
form for some
the resulting state
is an exception
an exception to
in accord with
are positive in
construction of the
of our model
the optimal policy
problem subject to
q t is
for all 0
with x 0
to see that
turns out that
the following hold
x k and
p x is
that which is
observe that since
we have so
it turns out
a solution of
as in 2
we have already
that for some
x is a
properties of the
first observe that

corpus/krapavin2000-test/606888.txt
sqp
alsqp
qp
optimality
newton
ssc
parabolic
lagrangian
semilinear
augmented
a5
lagrange
adjoint
banach
convergence
sucient
regularity
06
rst
multiplier
cgm
iterate
generalized
a6
augmentation
satised
derivatives
bijective
yy
bw
linearized
strongly
00
nonlinear
discretization
boundary
spaces
iter
dened
uy
pontryagin
satises
hilbert
triplet
a7
equations
convergent
u3
numerical
suciently
a1
multipliers
functional
variational
elliptic
dierential
robinson
u2
ad
iterates
belongs
kunisch
imbedded
volkwein
gnm
jjvjj
burgers
coercive
mesh
xed
fullled
perturbation
dierentiable
locally
equation
u4
endowed
regular
p3
continuous
200
a3
coercivity
denition
unconstrained
quadratic
veried
perturbed
shall
mapping
norm
assumptions
convex
verify
remark
a2
hf
diculty
mappings
subsystem
boltzmann
quadratically
ku
strong
controls
tests
c2
operator
400
grid
c1
uniqueness
kr
iterations
discrepancy
mention
concrete
dene
constrained
subject
identied
cone
signicantly
concerns
2372
precisionof
3537
sabatier
bertsekas
precised
dierents
3886
justifed
jjujj
sfb
quasilinear
cranck
augemented
5391e
7782e
kyk
polak
2817e
minimize2
khk
2318e
6610e
0004
0585
0853e
3307e
0999e
6824e
2146e
kantorovitch
3725e
0724e
9256
7989e
9980
2378
optimalit
optimalcontrol
kunish
3842e
9421e
unger
ckv
2251e
5347e
1864e
4459e
7523e
troltzsch
0149
0979e
interprete
bergounioux
mittelmann
kaumann
3663
adress
imbeddings
dsdt
5521e
2472
9337e
5013e
3653
2167e
hinreichende
reft3
8783e
ribiere
respectiveely
0404
admits
dierent
stefan
f0
sqp method
optimality system
y u
alsqp method
the alsqp
generalized equation
d qp
augmented lagrangian
newton method
lagrangian sqp
the generalized
generalized newton
control problems
from y
strongly regular
u 2
y n
the sqp
optimal control
the augmented
second order
the optimality
to u
augmented sqp
regular at
strong regularity
order sucient
semilinear parabolic
u ad
qp n
l 00
y p
00 y
optimality conditions
the lagrange
the convergence
banach spaces
condition ssc
order optimality
parabolic equations
solution of
unique solution
of class
u 4
convergence analysis
y 2
the rst
class c
u n
of qp
06 2
c c
boundary condition
adjoint state
bijective from
boundary control
the adjoint
n 1
b y
to y
f y
z y
adjoint equation
generalized equations
lagrange multiplier
equation 5
numerical tests
rst order
2 u
assumptions a1
in u
0 y
p n
qp are
locally of
state equation
sucient optimality
state constrained
lagrange newton
run 1
local solution
6 27
a u
operator from
of 5
y z
is strongly
convergence of
current iterate
control constraints
non augmented
for run
run 2
f yy
the assumptions
u y
at y
control problem
regularity of
1 u
let us
0 such
belongs to
y into
sucient condition
hilbert spaces
into y
u the
z n
u and
the associated
y to
of p
y y
dened by
the linearized
u z
optimality condition
06 1
mesh size
the numerical
system 5
z z
system of
a mapping
method for
let y
l u
the triplet
that y
by 5
of augmentation
f0 u
the cgm
associated lagrange
a semilinear
respectively u
continuous from
of semilinear
o into
a5 are
parabolic control
multiplier p
6 28
uy y
sqp methods
for semilinear
yy y
linearized equation
nonlinear optimal
ssc is
pontryagin s
and bijective
problem d
continuous linear
multipliers p
order necessary
problem qp
f uy
subject to
w n
order derivatives
14 5
an augmented
f u
is locally
problem 6
dierential equations
y v
and u
partial dierential
u b
u u
l w
the discretization
be strongly
v h
of robinson
is bijective
test corresponds
2 y
5 10
the solution
to 5
v 2
for p
update rules
in hilbert
y belongs
8 20
mapping s
ad is
fullled then
200 1
theorem 2
5 14
a y
we shall
u p
are fullled
the alsqp method
the optimality system
augmented lagrangian sqp
the generalized newton
generalized newton method
the generalized equation
optimality system of
newton method for
strongly regular at
lagrangian sqp method
the sqp method
y n 1
qp n 1
augmented sqp method
y u 4
second order sucient
of class c
c c c
is strongly regular
n 1 u
y to u
optimal control problems
p n 1
n 1 is
the augmented sqp
of d qp
generalized equation 5
the augmented lagrangian
the convergence analysis
class c 2
strong regularity of
from y 2
d qp n
y 2 to
2 to u
semilinear parabolic equations
of the alsqp
the unique solution
the second order
to u 2
of the augmented
u n 1
from y to
that y n
convergence of the
the rst order
class c 1
system of p
belongs to u
y u p
locally of class
the strong regularity
a local solution
from y u
1 from y
2 from y
rst order optimality
problem 6 27
the assumptions a1
1 u n
f y v
mapping of class
be strongly regular
local solution of
at y p
order sucient condition
order optimality system
boundary control problems
bijective from y
of the sqp
sqp method for
order sucient optimality
0 such that
the convergence of
the boundary condition
control problems for
d a u
the adjoint equation
and second order
c 2 from
second order derivatives
an augmented lagrangian
solution of p
5 14 5
unique solution of
in u 2
of the generalized
solution of d
1 1 from
regularity of the
c 1 1
partial dierential equations
to the generalized
linear operator from
to b y
sucient optimality condition
continuous linear operator
control problems of
class of optimal
optimality system 5
method for generalized
l 00 y
the update rules
of semilinear parabolic
fullled then there
z y n
sqp method in
solution to 5
f 0 v
f yy y
run 1 and
l u b
nonlinear optimal control
a mapping s
in hilbert spaces
for generalized equations
operator from y
type of augmentation
non augmented sqp
write for short
system for p
regular at y
is locally of
from y into
for run 1
z a y
and run 2
u ad is
rst order necessary
6 27 6
1 and run
is bijective from
a semilinear parabolic
f y u
continuous and bijective
lagrangian sqp methods
z n 1
a continuous linear
problem d qp
assumptions are needed
dened by 5
the lagrange newton
optimality system for
f uy y
let y u
u 2 u
a mapping of
test corresponds to
1 2 u
solution of e
optimality conditions for
the current iterate
be a local
y belongs to
are fullled then
y u 2
n 1 2
method for the
to u the
subject to z
with the norm
the vector representing
the optimal control
methods for nonlinear
z y z
of optimal control
n 1 and
n 1 n
that the assumptions
unique solution to
of the optimality
r 0 such
endowed with the
as a continuous
such that for
to the concrete
and the space
and the generalized
to the equation
is a mapping
1 n 1
as the unique
iterations for the
f u v
y 2 y
let us rst
existence and uniqueness
c1 and c2
u be a
the operator is
considered as a
for all v
the state and
z z z
obtained by taking
equations 5 4
alsqp method for
of tracking type
for all belongs
the objective functional

corpus/krapavin2000-test/606895.txt
gencan
extrapolation
spg
lancelot
tn
fe
quacan
gradient
cg
backtracking
evaluations
ge
unconstrained
chebyqad
kg
box
iterations
trust
trial
06
ks
iterate
conjugate
functional
armijo
steplength
extrap
386d
625d
sif
cute
spectral
qrtquad
scon1ls
projected
constrained
minimization
innite
unsuccessful
expquad
descent
rst
face
faces
extrapolations
quadratic
gradients
newton
nishes
directional
convergence
aatrial
unicamp
nonscomp
hadamals
secant
aamax
borwein
ime
birgin
barzilai
qr3dls
dened
subproblems
lagrangian
convergent
fortran
120
stationary
hg
iteration
k1
region
stops
nal
minimizer
derivative
augmented
satises
interior
unitary
hessian
quotient
ao
packing
cient
xnew
newtonian
pronex
04597
usp
quot
bdexp
387d
624d
fapesp
549d
projections
martnez
boundary
nish
direction
1025
1340
k2k
schrage
modications
judge
satised
xed
fx
cylinder
dene
842
multipoint
1008
cnpq
preconditioned
stopping
lim
numerical
su
truncated
incremental
preconditioning
43
accepted
go
leave
ug
599
complementarity
max
radius
nonlinear
subsequence
successful
optimization
continuity
10000
paulo
fullled
br
criterion
else
angle
perhaps
kd
leaving
subspace
aa
subroutines
178
surprisingly
79
dierence
seed
objective
active
4995260
spg2
896d
ronconi
236d
388d
mccormck
559d
kbkks
monitorized
nnaa
2072
trapolation
campinas
5750468
467d
rua
nishihara
1853
973d
linverse
films
05508
retards
969d
deconvb
300151
224d
813d
lagrangean
810d
2286
explin
imecc
133d
subalgorithms
nondegen
sociometry
egbirgin
742d
535d
functional evaluations
x k
it fe
trust region
ge cg
fe ge
line search
kg p
of gencan
box quacan
box constrained
iterations with
spectral projected
tn iterations
projected gradient
step 4
k 2
fe functional
trial point
spg iterations
cg time
algorithm 2
to step
conjugate gradient
all k
step 3
algorithm 3
gradient method
3 625d
625d 06
functional value
5 386d
2 k
the box
at step
directional derivative
global convergence
armijo condition
x kg
bound constrained
with extrapolation
in gencan
fe it
current face
of spg
x k1
constrained optimization
problem n
d k
f x
step 2
is innite
go to
k max
else go
augmented lagrangian
an unconstrained
limit point
k 5
step 1
unconstrained minimization
fx k
new iterate
k 1
of algorithm
p x
incremental quotient
the extrapolation
the trial
ks k
cient descent
hg x
simple bounds
tn extrap
computer time
06 table
evaluations at
chebyqad 50
it tn
the cute
06 3
time f
f i
step 5
direction d
exists k
by algorithm
iterate x
search direction
the spg
compute step
iterations where
the armijo
functional values
active set
well dened
to leave
the conjugate
free variables
k 4
large scale
the faces
the rst
the face
k k
of cg
constrained minimization
the spectral
minimization algorithm
the directional
for unconstrained
taking limits
qrtquad 120
do backtracking
using sif
projected gradients
every limit
lancelot in
order stationary
truncated newton
of lancelot
barzilai and
g birgin
gencan incremental
spg iteration
06 chebyqad
set trial
expquad 120
angle condition
quotient version
the barzilai
backtracking step
ks 0
stops at
gradient iterations
convergent subsequence
the steplength
judge that
nonscomp 10000
region algorithms
386d 5
iterations tn
constrained algorithm
region radius
cg iterations
06 nonscomp
extrapolation tn
unconstrained stationary
we judge
in lancelot
quadratic subproblems
that kg
4 backtracking
cylinder packing
28 23
tn step
and borwein
working set
the unitary
point is
the boundary
optimization with
x di
else set
unconstrained optimization
evaluations per
a descent
m martnez
the algorithm
k is
for optimization
and go
k g
1 compute
that ks
descent direction
many constraints
we report
we test
problems where
the direction
the feasible
strictly decreasing
indices such
5 else
conjugate gradients
s step
n it
objective function
boundary of
is computed
evaluations in
feasible set
an unsuccessful
the working
bounds a
number generator
of trust
22 28
theorem 3
algorithm 2 1
k 2 k
fe ge cg
all k 2
it fe ge
for all k
ge cg time
fe functional evaluations
x k 1
f x k
go to step
kg p x
3 625d 06
of algorithm 2
the current face
iterations with extrapolation
time f x
spectral projected gradient
it fe it
fe it fe
f x kg
problem n it
p x k1
n it fe
x kg p
algorithm 3 1
direction d k
else go to
algorithm 3 2
exists k 2
step 2 2
fx k g
step 3 1
the trial point
k is computed
the box constrained
for optimization with
trial point is
the armijo condition
su cient descent
functional evaluations at
625d 06 3
cg time f
2 k 5
there exists k
is well dened
the conjugate gradient
2 k 4
global convergence of
the line search
iterate x k
the directional derivative
the search direction
step 4 2
gradient method for
by algorithm 3
to step 5
if x k
k g is
the working set
2 k 1
k 1 is
generated by algorithm
box constrained optimization
hg x di
of trust region
rst order stationary
the spectral projected
simple bounds a
x k d
we judge that
it tn iterations
j m martnez
06 nonscomp 10000
conjugate gradient iterations
trust region algorithms
incremental quotient version
step 5 else
of functional evaluations
box constrained algorithm
tn step 1
the barzilai and
barzilai and borwein
with extrapolation tn
trust region radius
functional evaluations in
5 386d 5
that ks k
spectral projected gradients
of indices such
region algorithms for
extrapolation tn extrap
step 4 1
ks k k
within the faces
boundary of b
set s step
4 backtracking step
computed at step
06 3 625d
step 4 backtracking
22 28 23
every limit point
tn iterations where
the objective function
and go to
2 theorem 3
the solution of
step 2 1
not hold we
step 3 3
very large problems
2 f x
a descent direction
to the working
k is not
the boundary of
to step 4
to the free
1 is computed
the new iterate
at step 3
r 2 f
the matrix vector
is rst order
well dened and
the feasible set
k d k
indices such that
at step 2
k 2 f0
random number generator
4 2 if
is computed at
by algorithm 2
sequence generated by
algorithm 4 1
that k is
for each method
the free variables
x k is
this implies that
to leave the
the nal point
sequence stops at
birgin j m
unconstrained minimization problem
bound constrained minimization
this line search
to add many
gencan true hessian
4 1 compute
leave the current
tn iterations tn
2 f0 i
and simple bounds
the sequence stops
1 line search
large scale unconstrained
an unsuccessful extrapolation
constraints and simple
06 chebyqad 50
methods for unconstrained
evaluations per iteration
that lim k2k
the problems where
set to step
bounds a globally
with general constraints
that kg p
line search procedure
truncated newton approach
perform the test
stationary point or
the rst trial
bound constrained optimization
but by 2
an innite subset
were the default
projected gradient method
the trust region
order stationary proof
optimization 76 79
limit point of
for bound constrained
backtracking was necessary
additional unnecessary functional
of cg iterations
constrained algorithm the
where backtracking was
trust region methods
a successful extrapolation
onto the box
cg time it
criterion kg p
continuous projected gradient
5 is innite
iterations where the
line search of
of 6 2

corpus/krapavin2000-test/606904.txt
smoothing
04
burke
complementarity
newton
0e
predictor
corrector
pcx
fw
optimality
convergence
06
subsequence
xu
pilot
nonlinear
continuation
noninterior
interior
centering
ncp
superlinear
cholesky
8e
primal
03
4e
iterates
kb2
chks
converges
accumulation
font
netlib
mangasarian
dierentiable
02
05
7e
2e
boundedness
22228
nesm
2814
514e
maros
harker
99767839e
49727619e
2922
sc50a
perold
15362
sc50b
548e
1374
4543
087e
kanzow
monotone
reformulate
iterate
monotonically
ng
inequalities
inequality
armijo
1437
smale
inexactly
dened
rst
behaviour
updating
variational
numerical
1368
654
655
sparse
perturbed
1e
133
central
796
701
exible
jacobian
nal
340
346
statement
satises
recipe
stepsize
5e
quadratically
concave
equations
chen
314
593
cf
lemma
uence
nonsingular
514
uniprocessor
aa
proposition
750
simplex
strictly
converging
43
stopping
signicantly
objective
fx
66602616e
linearcomplementarity
truss
207e
f800
166e
55679564e
stocfor2
099e
00000047e
58113924e
910e
793e
ship04s
90905521e
57310815e
ship08s
169e
66666364e
156e
1510
standgub
098e
653e
224e
2132
d6cube
980e
585e
15018729e
732e
8806
257e
degen3
65893186e
greenbea
670e
815e
stocfor3old
203e
standata
ganges
715e
876e
33138982e
2773
49718510e
131e
41224999e
brandy
450e
758e
standmps
491e
5728
64218959e
09585736e
672e
35924858e
1932
4154
84642932e
1451
901e
049e
nonsmoothness
762e
843e
forplan
230e
38075527e
52647043e
4171
scorpion
greenbeb
adlittle
805e
592e
ship12l
416e
algorithm 2
smoothing type
optimality conditions
04 1
fw k
conditions 2
xu 3
type methods
burke and
04 2
04 5
complementarity problems
and xu
the optimality
by burke
interior point
sequence fw
step s
k g
predictor step
04 9
smoothing parameter
smoothing method
property p
nonlinear system
linear programs
all k
global convergence
k generated
central path
04 4
smoothing functions
accumulation point
of algorithm
point methods
k 2
predictor corrector
solution of
by algorithm
convergence properties
04 3
sparse cholesky
f k
lemma 2
strictly feasible
noninterior continuation
sub font
centering parameter
problem objective
the smoothing
for nonlinear
2 n
a subsequence
the sequence
w k
the linear
global and
path conditions
feasible point
continuation method
type method
of smoothing
the predictor
converges to
nonlinear complementarity
in step
x k
linear complementarity
2 1
newton s
line search
from property
s 2
chks functions
all iterates
3 0e
constrained variational
properties p
smoothing newton
quite popular
using chks
nal iterate
superlinear convergence
corrector smoothing
non interior
on chen
chen mangasarian
2 4e
8e 04
mangasarian smoothing
global linear
well dened
a suitable
functions for
from 14
the updating
and local
updating rules
the boundedness
our predictor
and superlinear
minimum function
newton type
box constrained
corrector step
numerical results
have x
for algorithm
the central
smoothing methods
newton method
an accumulation
rst note
boundedness of
fx k
variational inequalities
r n
of equations
a strictly
theorem 3
the iterates
06 1
a smoothing
proposition 3
for linear
the nonlinear
a solution
more exible
monotonically decreasing
obtain from
become quite
for monotone
continuously dierentiable
a predictor
linear systems
p 3
get from
sequence f
method from
the solution
we rst
of convergence
is monotonically
19 2
generated by
linear system
satises the
updating of
1 problem
the precise
s method
03 pilot
5 514e
font size
sequences fx
iterates is
22228 23
pilot 1368
ncp a
nesm 654
regarding statement
we 701
49727619e 03
subsequence since
automatically satisfy
the netlib
called smoothing
3 99767839e
exible choice
local superlinear
or monotone
2 2e
g converges
from pcx
pilot we
nally state
01 maros
inequality x
2 8e
chen harker
on smoothing
43 68
monotone ncp
component ng
lot 133
2 5e
n su
mapping being
cholesky code
superlinear continuation
03 recipe
to burke
15362 22228
quadratic noninterior
1368 4543
local convergence
subsequence converging
primal objective
perold 593
index ng
algorithm 2 1
optimality conditions 2
the optimality conditions
smoothing type methods
burke and xu
and xu 3
k 2 n
all k 2
by burke and
sequence fw k
in step s
of algorithm 2
f k g
the sequence fw
step s 2
of the optimality
for all k
generated by algorithm
by algorithm 2
k generated by
fw k generated
lemma 2 3
of the smoothing
interior point methods
solution of linear
the predictor step
of linear programs
2 1 is
nonlinear system of
that the sequence
central path conditions
a strictly feasible
for algorithm 2
strictly feasible point
the central path
the smoothing parameter
denotes a suitable
feasible point for
is well dened
theorem 3 3
of the linear
for the solution
the solution of
the nonlinear system
class of smoothing
2 of algorithm
nonlinear complementarity problems
on a subsequence
from property p
for nonlinear complementarity
solution of the
system of equations
s 2 of
newton s method
smoothing type method
chks functions for
method using chks
on chen mangasarian
smoothing functions for
of smoothing type
property p 3
functions for nonlinear
become quite popular
chen mangasarian smoothing
a global linear
smoothing method for
linear complementarity problems
the updating rules
predictor corrector smoothing
constrained variational inequalities
accumulation point of
conditions 2 we
boundedness of the
1 problem objective
box constrained variational
functions for monotone
w k k
continuation method for
statement of our
smoothing method using
an accumulation point
mangasarian smoothing functions
updating rules in
using chks functions
corrector smoothing method
and superlinear convergence
based on chen
proposition 3 2
global and local
that x k
the boundedness of
sequence f k
updating of the
2 3 b
2 1 have
a predictor corrector
results for algorithm
type methods the
a solution of
the linear system
rst note that
fx k g
type methods for
k g and
we get from
2 1 problem
we rst note
a more exible
in order to
is monotonically decreasing
the sequence f
2 3 c
for the optimality
satisfy the inequality
it satises the
rate of convergence
have for all
is a strictly
number of iterations
2 3 a
2 we next
in algorithm 2
essentially the same
theorem 3 5
to be presented
convergence properties as
the smoothing newton
and local quadratic
properties p 1
2 n using
for linear programs
continuation methods for
04 4 49727619e
smoothing newton method
8e 04 5
x k on
514e 05 3
non interior point
have a t
the initial smoothing
we nally state
for monotone linear
satises the linear
local rate of
perold 593 1374
subsequence since otherwise
smoothing parameter in
quadratic noninterior continuation
sc50b 48 76
lot 133 346
better numerical results
netlib test suite
some noninterior continuation
inexactly a sequence
due to burke
of smoothing functions
a sparse cholesky
a subsequence converging
path conditions 3
limit k 1
monotone linear complementarity
then f k
uniprocessor computers a
sparse cholesky code
property p 2
from 20 and
5 18 21
mixed complementarity problems
predictor step namely
global and superlinear
some useful inequalities
sequences fx k
harker kanzow smale
2 the argument
be presented below
complementarity problems some
advanced uniprocessor computers
from 14 in
2 8e 04
to burke and
the mapping being
is a predictor
more exible choice
subsequence converging to
nonlinear and mixed
19 2 8e
converging to w
proposed by burke
4 49727619e 03
global convergence properties
local superlinear continuation
automatically satisfy the
aa t using
method for nonlinear
sub font size
the nal iterate
the linear equation
and locally quadratically
xu 3 for
equation in 16

corpus/krapavin2000-test/606910.txt
stream
pi
cut
string
streams
sequent
substream
subproof
formulas
car97b
substrings
cuts
axioms
strings
contraction
axiom
elimination
r7
proofs
substring
lying
focal
bifurcation
logical
wn
contractions
subproofs
r6
vertex
r5
paths
occurrences
flow
sequents
wab
car97
defocussing
r1
arithmetical
focussing
compact
disrupted
w2
bridge
cs97
propositional
branching
lk
formula
atomic
combinatorics
car96
shall
wb
jr
passes
height
rewriting
proposition
occurrence
w1
duplicated
concatenation
car97a
rules
girard
bridges
edges
rule
wa
constituted
weak
distinguished
buss
stretched
a2
algebraic
pass
passing
directed
a3
fp
topological
a1
duplication
acyclic
gir87a
cs97a
apology
bus91
tak87
preceeds
implicitness
car97c
connectives
r3
a4
transformation
unary
bundle
gir87
extremal
chain
commutativity
remark
combinatorial
symbols
linked
exponential
provability
antecedents
extremes
induction
calculus
subgraphs
bar
cyclic
r4
distributivity
pushed
commutative
cycles
graphs
permuted
belong
reader
a6
depart
belonging
intriguing
structural
permutation
edge
undecidability
logically
formalized
associative
associativity
decomposition
purely
quantifiers
analysed
graphic
labelled
lie
interaction
shrink
deduction
additive
logic
path
induces
speak
consequent
parenthesis
universally
expansion
evolution
topology
describing
symmetry
predicate
bifurcate
substreams
outcoming
defo
falsifies
car98
regnier
tse68
danos
ssatisfying
sta73
pinpoints
ore79
cs96a
sta78
hak85
cussing
treatement
unhappy
emphazised
lafont
picture
quantified
looks
oriented
r2
horizontal
manipulation
transformed
sta79
1934
intruiging
gentzen
explicit
diagrams
induce
induced
ending
a stream
the stream
logical flow
pi 0
cut elimination
string associated
a proof
in pi
flow graph
the cut
a cut
of streams
b b
cut formulas
associated to
proof pi
of pi
stream p
of cut
input vertex
cut formula
the string
a string
stream structure
output vertex
end sequent
w 1
compact string
focal pairs
string w
lying in
w 0
the sequent
f rule
cut free
t w
form w
the proof
a substream
string b
b 2
w is
if w
of proofs
stream of
stream is
p pi
side formulas
cut rule
stream in
the contraction
rules r1
branching point
1 w
formulas in
the substream
cut edge
pi w2
subproofs pi
the subproof
pass through
the logical
in proofs
of cuts
the substrings
we shall
definition 11
passing through
a substring
flow graphs
cut on
stream passes
through the
the substring
w 2
graph of
passes through
pi is
rewriting rules
a bridge
of focal
r1 r7
in car97b
a subproof
wn wn
r1 r5
of bifurcation
stream might
pi w1
formulas of
the procedure
pi be
free proof
the height
w be
of logical
form b
the streams
v w
procedure of
described by
let w
string of
elimination the
formula in
w 3
might be
formulas a
cut edges
the arithmetical
substrings of
w1 and
pi 1
formula on
2 b
height of
of paths
twice through
arithmetical value
explicit string
acyclic directed
substream passing
in car97
the combinatorics
axiom edges
wa wab
car97b where
to streams
is disrupted
of concatenation
sequent f
f rules
after cut
of elimination
passes twice
same cut
wab wb
contractions on
streams p
formal proofs
logical rules
3 w
the form
an axiom
stream that
proof with
and pi
topological structure
proof on
a chain
formulas and
of w
last rule
the transformation
b m
f 2
weak formulas
theorem 26
directed paths
might pass
a sequent
example 22
occurrences of
the left
string is
of formulas
operation of
chain of
pi and
rule is
to b
elimination of
cuts are
are strings
branching points
negative occurrence
are oriented
w wn
paths will
f x
the f
proof which
of p
the side
logical connectives
the bifurcation
atomic formulas
the compact
is applied
strings and
the axiom
streams of
constituted by
let pi
substring of
proof is
to p
of strings
sequent is
distinguished formulas
logical flow graph
string associated to
in a proof
of cut elimination
b b b
of the stream
the logical flow
is a stream
flow graph of
a stream p
the cut formula
to a stream
of a proof
the string associated
procedure of cut
a proof pi
the form w
stream of a
in a stream
form w 1
associated to p
of the form
b 2 b
b b 2
the cut formulas
a stream is
the end sequent
the f rule
pi 0 of
if w is
on the left
to the stream
w 1 w
the procedure of
pi 0 is
a stream of
the side formulas
through the side
compact string associated
cut free proof
through the cut
a stream in
equivalent to b
on the right
1 w 2
a string w
0 of pi
stream passes through
associated to a
w 3 w
a cut edge
p pi 0
a compact string
proof of f
the stream that
cut elimination the
a logical flow
the proof pi
pi w1 and
of focal pairs
side formulas of
rules r1 r7
a stream structure
the proof on
proof pi is
be a stream
elimination of cuts
logical flow graphs
w1 and pi
the form b
in the logical
in the proof
pass through the
in the stream
of the cut
2 b 2
the height of
by definition 11
be a string
of the sequent
the string w
lying in the
a chain of
pi be a
of a cut
formula on the
let w be
proof on the
rule is applied
graph of a
of p pi
operation of bifurcation
based on v
the same cut
cut formula on
w is equivalent
after cut elimination
of the substrings
twice through the
decomposition of p
car97b where the
a substream passing
passes twice through
on v w
the string b
one input vertex
a cut free
of elimination of
wa wab wb
the cut rule
of a subproof
and pi w2
substream passing through
formula in a
passes through the
of f 2
by the string
of rewriting rules
the rules r1
is the string
extension of p
2 b b
might pass through
the cut on
node of p
flow graph is
last rule of
belong to the
described by the
number of paths
f f x
then by induction
be a proof
a cut is
is a string
2 o n
string of the
through the same
a substring of
in the cut
proof is a
such that w
of the procedure
w be a
in the end
to a string
a proof is
w are strings
in an axiom
path passes twice
describes a substream
substream lying in
strings associated to
the stream might
formulas in a
the compact string
substrings of the
the stream passes
the sequent f
formulas of a
a negative occurrence
path belonging to
stream structure is
transformation of streams
t w 0
cut formulas is
rule of pi
operation of concatenation
cut is applied
subproofs pi 0
input vertex output
paths will be
subproof pi 0
in example 22
in pi 0
compact string of
paths belong to
step of elimination
acyclic directed graph
cut free proofs
an explicit string
vertex output vertex
streams of proofs
is a cut
no path passes
proof theory and
on atomic formulas
a proof might
a focal pair
duplicated by the
by a compact
b m where
during cut elimination
the stream p
of cut formulas
substring describing the
chain of focal
of concatenation and
a branching point
the input vertex

corpus/krapavin2000-test/606912.txt
db
disjunction
dd
succinct
disjunctive
np
disjunctions
snf
dddb
9dd
fp
propositional
fpspace
mr
query
cwa
ground
lives
fplt
atoms
deductive
reductions
pi
dddbs
succ
clause
oracle
pspace
circuit
md
ddexistence
upgrading
negation
hb
predicate
circumscription
logspace
pcwa
enc
databases
datalog
string
pol
definable
queries
dduniqueness
log
lexicographical
herbrand
extensional
joe
reducible
delimiting
computable
entailed
hardness
sentence
iff
deciding
succinctly
witnesses
database
gen
indefinite
metric
clique
flinspace
closed
disjuncts
qa
conp
theta
fl
characterizations
relational
lemma
symbols
subclause
plt
optp
conversion
boolean
atom
reducibility
polynomial
foundations
combined
symbol
quantifiers
logic
succinctness
facts
mm
compensation
descriptive
gates
languages
minimal
expression
language
sat
tuple
tuples
closure
sd
america
predicates
reducibilities
interpretational
hbdb
deq
krentel
arity
literals
stewart
program
cf
nonmonotonic
corollary
successor
loves
dhb
logics
fixpoint
world
ffi
gate
rounds
logarithmic
exponentially
bodies
logical
nullary
subscrpt
obdd
supscrpt
vectorized
clauses
completeness
formula
restricted
classes
uniformly
truth
6j
proposition
semantics
encoding
resp
fc
forgetful
reasoning
ary
interpretation
turing
tools
expressive
f0
1g
max
extract
minimality
circuits
remark
char
mc
protected
encode
hard
bill
negated
immediate
mexico
isomorphic
expresses
querying
concatenating
coding
representations
membership
binary
encodings
expressible
inference
constants
dummy
transitive
formulas
presumably
structures
yr
surpassed
logicum
antagonistic
pdata
nonground
myampersandpgr
hillary
pads
usbekistan
data disjunction
fp np
data disjunctions
disjunction on
np log
unique data
expression complexity
combined complexity
of db
theta p
k dd
propositional complexity
db r
dd is
complexity of
9 dd
md db
data complexity
a snf
fpspace np
p minimal
disjunctive deductive
closed world
and combined
pspace np
lives in
the complexity
db is
db has
fl np
disjunctive ground
a disjunctive
r c
on r
log log
relation symbol
np k
snf sentence
a dddb
fplt function
of 9dd
of disjunctive
and propositional
minimal models
minimal model
a data
the unique
symbol r
polynomial time
restricted data
a program
a query
parallel queries
world reasoning
an fplt
if db
input negation
conversion lemma
9dd and
hb db
mr f
deductive databases
disjunctions in
expression and
of pi
ground facts
dd are
snf witnesses
on succinct
in joe
np pol
snf formula
pcwa db
enc a
db have
pi is
finite relational
gen c
np oracle
relational language
db p
complexity classes
lemma 6
the clause
disjunctive datalog
clique size
is entailed
successor relation
for fp
world assumption
complexity and
the expression
s t
is metric
algorithm ddexistence
uniformly closed
algorithm dduniqueness
metric reducible
disjunction over
cwa db
metric reductions
ground fact
long b
function problems
compensation lemma
mm db
binary language
2 hb
on succ
f mr
self delimiting
of md
the succinct
does db
not db
logic programming
queries to
reducible to
decision problems
complete for
in theta
boolean circuit
query over
query q
time computable
query languages
foundations of
input gates
query classes
domain elements
generalized quantifiers
succinct representation
over ordered
bounded query
global p
complexity class
p 2
of dd
finite structures
that fp
binary string
is definable
on input
deciding whether
q is
is uniformly
q b
language is
a relation
hardness results
disjunctive logic
d iff
function classes
s long
complexity results
models of
clause c
model m
extensional part
in symbols
to succinct
metric reduction
succinctly represented
q extract
that db
clause r
delimiting encoding
is fpspace
succinct circuit
for fpspace
flinspace np
succinct problems
class theta
succinct instances
dddb db
sd l
indefinite information
function computations
np pspace
complexity definition
logical characterizations
problem dd
2 mm
optp o
descriptive complexity
f reductions
program for
an np
h 1
deductive database
a is
definition 6
3 there
disjunction of
p c
a boolean
free variables
property on
iff a
db the
a data disjunction
unique data disjunction
data disjunction on
the unique data
disjunction on r
md db r
fp np log
and combined complexity
expression and combined
the complexity of
of data disjunctions
theta p 2
complexity of pi
and propositional complexity
fl np log
combined complexity of
np log log
has a data
relation symbol r
complexity of 9dd
closed world reasoning
propositional complexity of
p minimal model
a relation symbol
the data disjunction
the expression complexity
9dd and 9
models of db
db has a
a snf sentence
and 9 dd
an fplt function
the expression and
complexity of data
r s t
exist a program
restricted data disjunctions
finite relational language
for fp np
expression complexity of
lives in joe
data complexity and
fpspace np pol
data disjunctions in
a disjunctive deductive
queries to an
of 9dd and
parallel queries to
fp np k
symbol r s
data disjunction of
pcwa db p
minimal models of
a finite relational
and a relation
an np oracle
a unique data
to an np
in theta p
disjunctive deductive databases
closed world assumption
3 there exist
a program and
rounds of parallel
if not db
disjunction over r
db have a
language is uniformly
a snf formula
t q a
data disjunction over
on r if
the conversion lemma
does db have
complexity and propositional
disjunctive ground facts
complexity of dd
is a snf
of md db
db r is
global p minimal
of parallel queries
from the unique
k dd is
lives in x
that fp np
c on a
polynomial time computable
theorem 4 1
a query language
s t q
a boolean circuit
q a is
of db is
bounded query classes
program and a
data complexity of
the data complexity
minimal model of
lemma 2 3
query language is
disjunctive logic programming
of pi is
a can be
are equivalent 1
be a query
property on succ
are theta p
the algorithm ddexistence
having the free
dd is metric
the class theta
time computable from
metric reducible to
a disjunctive ground
h 2 such
disjunctive deductive database
ordered databases the
function g in
self delimiting encoding
all r c
model of db
of closed world
q extract a
a dddb db
model of c
lines 1 to
disjunction on p
of dd is
on a such
is uniformly closed
of function computations
and data complexity
m 2 mm
data and propositional
over ordered databases
db p is
if the language
dd is fpspace
the minimal models
by boolean formulas
propositional and data
clause r c
disjunctive ground fact
9 dd are
of k dd
2 mm db
logical characterizations of
complexity of graph
and expression complexity
of graph problems
optp o log
class theta p
equivalent 1 q
succinct representations of
proof 1 2
is metric reducible
is fpspace np
c is entailed
for fpspace np
in fp np
a program for
there exist a
is the complexity
theorem 5 1
is a data
complete for fp
a is polynomial
a complexity class
the combined complexity
function h 1
complexity of k
denotes the binary
databases the following
of disjunctive logic
complexity of function
in the proof
the proof of
let be a
let f be
r c d
the closed world
to encode a
corollary 5 2
in rule bodies
a clause of
1 q is
r c 2
is a program
q be a
let q be
problem is in
theorem 6 5
pi is the
computable from the
r if it
that on input
it holds that
is hard for
is a clause

corpus/krapavin2000-test/606913.txt
guarded
cgf
clique
gf
logics
lgf
modal
monadic
xed
formulae
width
bisimulation
quantication
sentence
bisimulations
satisable
loosely
fragment
countable
logic
tuple
decidability
satisability
bisimilar
sentences
rst
formula
benthem
lfp
innitary
quantier
kripke
quantiers
tree
guard
denition
calculus
gaifman
automata
decidable
propositional
atom
guards
ordinals
tuples
ml
unraveling
denable
nemeti
gradel
andreka
guardedness
v2t
arity
a2a
_
elementary
ht
substructure
exptime
backwards
induces
nite
maarten
marx
modalities
axioms
dened
ry
induction
coexist
isomorphism
rx
translation
sect
walukiewicz
gfp
vardi
theoretic
greatest
universe
fragments
saturated
ary
forth
ordinal
satised
cardinality
atoms
van
vocabulary
atomic
link
substructures
modality
denes
trees
saying
fa
axiom
quantied
erich
rabin
2exptime
unguarded
8xyz
determinacy
nestings
beth
gso
subformula
expressive
dene
decomposition
existential
isomorphisms
liberal
rwth
8z
grdel
9y
cardinal
invariant
alternating
9z
8s
tableaux
aachen
operators
denitions
informatik
notions
relations
games
simultaneous
predicates
variants
sx
ternary
ctl
forgetful
satisfiability
algorithmic
innite
pf
branching
inductively
constants
hai
ables
remark
conjunct
famous
agree
universal
stages
proposition
conjunction
packed
mu
contained
superposition
preprint
hypothesis
occurrences
relational
extensions
satises
machinery
really
fb
vari
ha
fv
permit
resp
talk
retains
overlapping
operator
structures
semantic
tyszkiewicz
graedel
rxyz
8x8y
satisies
9xyfxy
b2k
benthems
eyz
wheras
9usua
walulkiewicz
janin
tcgf
hodkinson
relativised
dismissing
mgi
clique guarded
xed point
guarded xed
loosely guarded
guarded fragment
guarded set
for guarded
tree width
point logics
model property
guarded logics
the guarded
of guarded
rst order
width k
order logic
tree model
o a
monadic second
modal logic
point logic
a structure
f v
in cgf
guarded quantication
guarded bisimulations
cgf 1
and cgf
the satisability
a clique
xed points
of width
guarded in
least xed
clique k
satisability problem
tree decomposition
second order
of gf
the modal
t d
guarded tuples
every satisable
modal logics
greatest xed
tuple b
are clique
lgf and
guarded bisimulation
most k
the tree
tuple d
a guarded
a tree
the clique
van benthem
countable trees
is clique
point formulae
cgf and
propositional modal
k bisimilar
guarded tuple
for gf
partial isomorphism
2 cgf
gf lgf
monadic relations
sentences of
node v
the calculus
f w
v of
of countable
tree e
of monadic
with universe
a2a o
kripke structure
to gf
modal calculus
nite model
satisable sentence
guarded and
guarded fixed
clique x
gaifman graph
every clique
for cgf
and greatest
induces a
calculus with
the formula
of t
set x
width at
logics are
structure b
model theoretic
x 0
of rst
the monadic
structure d
the quantier
formulae is
two structures
clique a
gf is
the tuple
clique in
a countable
sentence in
there exists
logics in
has tree
least and
some tuple
a _
a formula
g w
exists a
tuple of
cgf sentences
backwards modalities
relations o
maarten marx
guarded fragments
of cgf
and nemeti
every formula
tuples c
structure k
andreka van
with backwards
countable model
guard formulae
cgf sentence
gf the
associated tree
k unraveling
under clique
benthem and
in lgf
tuple a
invariant under
of tree
link between
in b
denition 2
formula x
a loosely
node w
a 0
2 k
structure t
order formula
the link
tree structure
coexist in
tree representations
ary relation
formula that
in sect
of bounded
arity of
the guard
free variables
a tuple
constant a
decidability of
link a
in gf
logics we
a monadic
order sentence
decidable and
automata theoretic
fragment with
formulae of
the translation
for every
g b
problem for
of modal
modal operators
and forth
is guarded
order theory
nodes on
size at
of propositional
that d
all nodes
of b
g v
fragment of
induction hypothesis
v b
all guarded
v v2t
guarded xed point
tree model property
xed point logics
for guarded xed
the tree model
monadic second order
of width k
the guarded fragment
the satisability problem
xed point logic
rst order logic
of a structure
satisability problem for
least xed point
guarded set x
of guarded logics
v of t
second order logic
at most k
clique guarded set
node v of
loosely guarded set
in g b
induces a clique
a clique guarded
is clique guarded
lgf and cgf
a 2 k
of tree width
a clique in
of rst order
on the link
width at most
tree decomposition of
a tree decomposition
most k 1
there exists a
a loosely guarded
every satisable sentence
of countable trees
and greatest xed
least and greatest
xed point formulae
clique guarded tuple
for the guarded
clique guarded bisimulations
the calculus with
theory of countable
the clique guarded
clique k bisimilar
the modal calculus
propositional modal logic
a2a o a
guarded fixed point
every clique guarded
greatest xed points
the link between
a a 0
all nodes on
tree structure t
has tree width
a structure b
kripke structure k
satisable sentence in
nite model property
fragment of rst
o a and
of monadic relations
variants of guarded
model property of
van benthem and
are clique k
gf lgf and
invariant under clique
the associated tree
andreka van benthem
notions of guarded
guarded in the
under clique guarded
a countable model
structure t d
associated tree structure
a partial isomorphism
guarded set in
guarded fragment with
b are clique
benthem and nemeti
the nite model
clique guarded fragment
of propositional modal
with backwards modalities
a guarded set
calculus with backwards
size at most
nodes on the
and only if
of size at
has a model
tree width k
set x 0
be a structure
order theory of
the stages of
exists a node
if and only
back and forth
tree width of
the tree width
a and b
be the set
to the calculus
clique in g
width of a
x x 0
the other side
the decidability of
the arity of
lfp rx r
the modal fragment
monadic relations on
to the guarded
k bisimulation between
unraveling of a
decision algorithms for
rx r x
tuple d 0
xed point sentences
2 k m
clique guarded quantication
a structure has
loosely guarded quantication
gf and lgf
the least xed
v induces a
structure with tree
and invariant under
0 is clique
all guarded tuples
for every formula
of clique guarded
with universe b
fixed point logics
relations o a
width k if
some tuple b
guarded in b
of a loosely
v v2t i
structure has tree
the k unraveling
exists a partial
tree decomposition ht
b is clique
is loosely guarded
in cgf 1
tuple of monadic
m ary relation
model theoretic properties
2 cgf 1
the automata theoretic
sentence in cgf
k in cgf
sentences of width
point formulae is
xed point formula
d is contained
constant a 2
gaifman graph of
a structure d
results for guarded
the gaifman graph
for the clique
sentences of bounded
width k in
for every clique
sentence of width
guarded fragment of
loosely guarded fragment
with tree decomposition
width k 1
monadic relations o
into monadic second
structure b is
a monadic second
theorem 4 2
a and r
is contained in
b such that
such that for
to be decidable
in sect 4
second order theory
has a countable
decomposition of width
a structure and
greatest xed point
modal logics are
order logic is
relations on t
rst order formula

corpus/krapavin2000-test/606915.txt
taut
propositional
clocked
turing
np
nondeterministic
tautology
transducer
enumerable
polynomial
sound
machines
reckhow
co
promise
jwj
cook
simulates
comp
opt
languages
pudl
kraj
cek
jxj
deterministic
ak
accepts
ff
accepting
tautologies
presentation
computable
provably
polynomially
sigma
presentability
hartmanis
kowalczyk
hemachandra
recursively
ae
fm
recursive
string
possesses
existence
categorical
uniformity
formulas
classes
acceptors
messner
fsound
relativizations
subsets
recognizable
acceptor
machine
theorems
maybe
enumerations
counterpart
covering
accepted
possess
proofs
fulfilling
soundness
satisfiable
cap
am
bm
language
enumeration
gamma
guesses
unambiguous
formula
yes
fn
sat
iii
jcomp
sengupta
revelation
presentable
nondeterministicg
obler
unsuccesfully
glaer
fhm
algoritms
samik
representability
8w2l
quantified
independence
tupling
jffj
posed
guess
chief
selman
mutations
theoretic
structural
analogously
267
shut
manners
strength
strong
connection
conp
pay
intensively
transducers
attacking
padding
names
fl
characterization
restated
familiarity
lectures
boolean
strings
reducibility
rice
promises
symmetrically
recursion
1979
corollaries
247
halts
producing
structurally
hm
sight
attaching
deeper
connections
christian
reflecting
encodings
provable
tor
proven
proves
simulation
obey
cryptography
versus
undecidable
working
connectives
complements
clocks
word
symbol
distant
alan
similarity
systematically
springer
verlag
recognizing
outputs
fi
equivalence
alphabet
produces
efficiency
classifying
zeros
question
notion
verify
statements
procedures
searched
translating
proving
aimed
formalized
displays
62
reductions
claimed
contrary
seem
classification
reasoning
translates
public
devices
complementary
translate
propositional proof
time clocked
proof system
of taut
optimal propositional
clocked turing
polynomial time
np co
proof systems
turing machines
complete languages
co np
a propositional
nondeterministic polynomial
for taut
turing machine
propositional tautology
easy subset
all easy
easy subsets
nondeterministic turing
recursively enumerable
promise classes
np presentation
p optimal
machine m
optimal proof
complete language
comp gamma
ae taut
clocked transducer
taut we
enumerable list
an optimal
languages for
for up
a ae
there exists
taut and
recursive np
np easy
t provably
gamma sound
taut there
for np
np and
transducer m
sound jwj
for promise
g comp
p simulates
a recursively
deterministic turing
n i
m on
time computable
theory t
the machine
the existence
every tautology
sound jxj
accepts taut
tautology ff
good form
exists a
a polynomial
existence of
in polynomial
input w
in good
which accepts
subsets of
a nondeterministic
a turing
turing transducer
pudl ak
classes np
i cek
provably np
taut which
kraj i
machines covering
every theory
taut is
p presentation
languages from
a string
of nondeterministic
complexity classes
polynomial p
polynomially bounded
these classes
a recursive
uniformity property
nondeterministic algorithm
any propositional
exists an
if and
t there
sound if
on complete
length n
of complete
an easy
string x
of propositional
language for
deterministic polynomial
computable function
a complete
cek and
np if
p pudl
s cook
covering languages
provably easy
bounded propositional
fm n
j accepting
r reckhow
simulates any
optimal nondeterministic
strong nondeterministic
propositional tautologies
j kraj
cook reckhow
taut possesses
transducer n
a proof
time bound
any input
for every
any polynomial
and only
not t
2 sigma
that opt
if there
presentation of
the class
on input
accepted by
systems for
of length
of machines
exists j
from np
cook and
jxj k
certain fixed
accepts w
relative efficiency
machine n
a polynomially
of turing
main results
by m
complete problems
and up
exist an
any fixed
sigma is
possesses a
all languages
optimal deterministic
only if
w if
ff has
almost optimal
the classes
p such
proofs in
system then
theorem 5
m w
a computation
be any
i j
a deterministic
list of
m 0
string w
boolean formulas
input of
is polynomial
of polynomial
proof of
up is
w is
working in
there does
computations end
i iii
jwj and
jwj where
versus co
fulfilling 1
tautology let
maybe and
taut in
propositional proof system
polynomial time clocked
optimal propositional proof
time clocked turing
np co np
an optimal propositional
clocked turing machines
complete languages for
nondeterministic polynomial time
subsets of taut
easy subsets of
subset of taut
easy subset of
optimal proof systems
a propositional proof
turing machine m
propositional proof systems
a propositional tautology
all easy subsets
exists a polynomial
a complete language
of the existence
complete language for
of all easy
recursively enumerable list
co np and
algorithm for taut
enumerable list of
time clocked transducer
recursive np presentation
an easy subset
comp gamma sound
nondeterministic turing machine
proof systems for
a recursively enumerable
there exists a
the existence of
is a propositional
taut there exists
is in good
a ae taut
for promise classes
g comp gamma
p optimal propositional
of taut we
theory t there
of complete languages
existence of complete
a recursive np
in polynomial time
polynomial time computable
proof system is
t there exists
in good form
proof system and
exists a recursively
for np co
language for np
clocked turing machine
clocked transducer m
a p optimal
proof system the
every tautology ff
class of all
if and only
and only if
machine m 0
m on input
nondeterministic turing machines
a polynomial p
deterministic turing machine
there exists an
if there exists
of an optimal
for every tautology
for every theory
system then for
proof system then
np and up
and for up
np presentation of
t provably np
is not t
of taut which
nondeterministic algorithm for
gamma sound jwj
not t provably
classes np co
of taut there
which accepts taut
taut which is
np and for
with time bound
exist an optimal
provably np easy
every theory t
kraj i cek
languages for promise
only if there
polynomial p such
n i j
of length n
a computation of
is a computation
input of length
time computable function
any polynomial time
such that for
a proof of
a nondeterministic turing
on input w
a polynomial time
question of the
is a nondeterministic
complete problems for
deterministic polynomial time
that for every
is polynomial time
if there does
exists an optimal
of polynomial time
cook and r
list of nondeterministic
prove that opt
i j accepting
proof of length
gamma sound jxj
optimal nondeterministic algorithm
a certain fixed
machines covering languages
accepts taut and
taut possesses a
bounded propositional proof
p pudl ak
np if and
and p pudl
a polynomially bounded
that a ae
polynomially bounded propositional
ff has a
working in polynomial
of turing machines
the classes np
j kraj i
optimal deterministic algorithm
produced by m
presentation of all
an optimal nondeterministic
a turing transducer
i cek and
and r reckhow
exists an easy
t provably easy
machine n i
co np if
has a proof
cek and p
simulates any propositional
of taut possesses
from these classes
proof of ff
covering languages from
systems for taut
s cook and
of nondeterministic turing
languages from these
sound jxj k
by j kraj
language for up
proof systems and
almost optimal deterministic
any propositional proof
problem of the
the class of
d i j
problems of the
of all languages
there exists j
exists j such
of propositional proof
a string x
an almost optimal
deterministic algorithm for
possesses a recursive
turing machines we
existence of optimal
a deterministic turing
p such that
set of all
on any input
on an optimal
a set a
m is a
our main results
the machine m
2 sigma is
is a proof
a string w
w if and
classes and the

corpus/krapavin2000-test/607032.txt
hypergraph
diagen
editing
diagram
conn
editors
editor
hyperedge
grammars
layout
syntax
flowchart
flowcharts
diagrams
flowout
hypergraphs
varrow
lhs
grammar
hyperedges
attachment
parser
directed
srg
productions
flowin
asg
fig
reducer
drawing
arrows
visual
derivation
modeler
layouter
blockseq
diamond
attribute
rhs
developer
box
schurr
subdiagrams
parsing
arrow
edges
statement
cf
uml
prototyping
transformation
attributes
erent
visited
syntactic
berthold
nonterminal
boxes
resp
languages
creating
terminal
hoffmann
java
eer
vispro
subdiagram
reker
arity
multiset
stmt
areas
specification
edge
hline
syntactically
di
generator
match
parsed
language
block
programmed
dag
er
semantic
modes
production
ers
rules
edited
embeddings
gathers
parsers
internal
automatic
labels
rekers
nassi
nonterminally
costagliola
chok
shneiderman
add_rule
shapely
penguins
polese
harrow
genged
deufemia
operationsupport
gral
colimes
drewes
minas
grayed
rule
specifying
compiler
removes
vertical
tool
gray
modifies
please
diamonds
marriott
screenshot
tailored
lexical
rapid
mode
transformations
replacement
ladder
canvas
graphics
adjusted
text
arrangement
shaped
dags
gennaro
vincenzo
reduction
rectangular
graphical
spatial
seamlessly
omitted
connect
free
hyper
11a
relationships
pascal
modify
nodes
transformer
crossed
specify
rectangles
shelf
9c
9b
interfaces
compilers
realization
indicated
force
9a
ort
labeled
generic
constraint
macros
supplied
primarily
created
adds
meaning
morphisms
drawings
cond
informaticae
carries
outlined
thick
fundamenta
depicted
giuseppe
string
connected
occurrences
reads
ected
suited
abstract
realized
textual
hypergraph model
directed editing
the hypergraph
syntax directed
conn conn
free hand
hand editing
reduced hypergraph
editing operations
the diagram
diagram components
of diagram
diagram language
the editor
diagram editors
attribute evaluation
attachment areas
hypergraph grammar
a diagram
the reduced
editing operation
graph grammars
diagram layout
diagen editors
diagram languages
hypergraph transformation
diagram component
diagram analysis
diagram editor
graph transformation
hypergraph models
editor developer
context free
automatic layout
derivation tree
specific diagram
drawing tool
the lhs
the reducer
condition conn
hypergraph grammars
editor framework
reduction rules
editing is
in fig
for flowcharts
the diagen
statement statement
application conditions
free hypergraph
each diagram
each hyperedge
syntactic structure
and arrows
edges which
visited nodes
c statement
the flowchart
the modeler
the derivation
cf fig
the syntactic
the srg
and schurr
diagen editor
the hyperedge
constraint multiset
of diagen
multiset grammars
new statement
hypergraph parser
editors which
statement box
editing mode
derivation structure
layout mechanism
the layouter
conn condition
internal model
of fig
editing the
an editor
hypergraphs are
program generator
transformation rule
lhs and
for creating
cf section
boxes and
uml class
visual languages
di erent
diagram is
o er
h c
a flowchart
conn edges
reduction step
vertical arrow
diagram model
conditional block
class diagrams
attachment area
starting hypergraph
with embeddings
hypergraph transformations
the asg
statement condition
berthold hoffmann
grammars are
internal diagram
prototyping tool
diagram editing
both editing
editing modes
in diagen
editors and
a flowout
grammars and
a hypergraph
allow to
corresponding nodes
of graph
transformation rules
of diagrams
program code
of syntax
editor for
lines and
a parser
productions of
grammars with
and rhs
reduced one
semantic representation
hypergraph which
rapid prototyping
layout is
a syntax
structure of
an internal
the parser
by graph
arrow and
fig 10
quite similar
the layout
for free
a rapid
diagrams in
o ers
visual representation
diagram the
the user
indicated by
hyperedges which
algebraic approaches
diagen uses
between attachment
drawing tools
creating diagram
flowout edge
editing or
edited diagrams
srg and
schurr s
derivation dag
flowin flowout
diamond shaped
varrow edge
diagen a
editing and
reduced model
with diagen
shaped conditions
support syntax
of editing
diagram into
visual language
correct subdiagrams
string grammars
sub hypergraphs
of hypergraph
hyperedge replacement
editors is
correct diagram
specify box
hyperedge the
hyperedges of
component edges
a blockseq
evaluation cf
the varrow
reker s
statement below
on hypergraph
diagen o
cross model
transformation part
conn statement
syntax directed editing
conn conn conn
free hand editing
the hypergraph model
reduced hypergraph model
the reduced hypergraph
of the diagram
directed editing operations
of the hypergraph
hypergraph model and
hypergraph model of
the diagram language
of diagram components
the hypergraph grammar
the editor developer
of the reduced
specific diagram language
lines and arrows
the syntactic structure
syntactic structure of
context free hypergraph
directed editing is
the editor framework
of a diagram
the derivation tree
a a a
constraint multiset grammars
for free hand
reduced hypergraph models
a diagram editor
condition conn condition
to the hypergraph
a syntax directed
a new statement
a specific diagram
by the editor
conn condition conn
free hypergraph grammars
the diagram components
cf fig 2
hypergraph model is
directed editing operation
editing operations are
a rapid prototyping
of syntax directed
the derivation structure
the reduced one
the visual representation
of diagram analysis
h c statement
graph grammars and
of the flowchart
hypergraph transformation rules
uml class diagrams
hypergraph model as
set of diagram
grammars with embeddings
rapid prototyping tool
internal diagram model
each diagram component
diagram components and
both editing modes
hypergraph model which
hand editing the
shown in fig
structure of the
lhs and rhs
by the syntactic
quite similar to
is necessary for
used for creating
visual representation of
which has been
a diagram component
diagram languages which
by attribute evaluation
computing by graph
of diagram languages
of attachment areas
the starting hypergraph
diagen a rapid
attachment areas are
approaches to graph
the editing operation
an internal model
specify box b
representations of diagrams
the drawing tool
graph transformation part
the reduction step
on hypergraph transformation
by free hand
to the diagram
editing operation is
by syntax directed
derivation tree of
creating diagram editors
a diagram layout
hypergraph models of
and schurr s
based on hypergraph
the reduced model
hypergraph model the
a correct diagram
model the hypergraph
relationships between attachment
or free hand
of the editor
s and schurr
conn conn statement
3 the hypergraph
step of diagram
of graph transformation
a vertical arrow
attachment area of
an automatic layout
to graph transformation
prototyping tool for
attribute evaluation cf
schurr s approach
diagram language this
flowchart of fig
diagram component is
implementation of visual
hand editing mode
between attachment areas
the varrow edge
and realization of
editing operations can
in the hypergraph
automatic layout mechanism
shows the hypergraph
diagen o ers
of editing operations
editing or free
editing operation which
algebraic approaches to
directed editing or
diagram editors which
hypergraph grammars with
vertical arrow and
diagram component and
hypergraph model fig
an internal diagram
diamond shaped conditions
support syntax directed
reker s and
for creating diagram
please note that
node of the
be connected to
for that purpose
analyzed by the
syntax directed translation
tailored to a
some kind of
which have been
just a single
from the reduced
the diagram is
an editor for
edges and nodes
for specifying the
to the reduced
which have to
which it can
the diagram the
which is used
as well as
in the reduced
which is necessary
can be connected
cf section 5
applying the rule
to the user
have to be
fig 4 shows
information from the
they are actually
of fig 3
area of a
the syntax of
to be removed
model which is
nodes which are
in fig 10
operations are specified
processing steps which
of the srg
directed editing too
editors and does
for shapely nested
and general in
aspects of both
has been omitted
areas are modeled
statement h c
rule in fig
support free hand
with just a

corpus/krapavin2000-test/607196.txt
broadcast
tune
frames
signature
clustered
disks
indexing
cycle
index
frame
hybrid
scattering
ivb96
flat
client
signatures
ll96b
meta
tree
attribute
mobile
replicated
info
sig
channel
wireless
bd
channels
disk
scheduling
aafz95
probe
sparse
air
integrated
access
segment
tunes
organization
overhead
broadcasting
1e
clients
packets
chunks
efficiency
segments
drop
arrival
caching
comparisons
minor
filtering
hll98b
saved
pull
dissemination
retrieving
clustering
query
dik
selectivity
chien
block
lun
waiting
afz97
srb97
hll98c
retrieve
cycles
prefetching
05
pointers
lee
chunk
indexed
disseminated
skewed
push
hashing
false
schedule
retrieval
conservative
workaholics
sleepers
afz96b
cyw97
qinglong
afz96a
jianliang
ivb94b
arrives
height
estimated
environments
levels
downloads
jianting
spinning
desired
offset
frequency
requested
overheads
indexes
interleaves
monitoring
children
wang
superimposed
equals
dk
gruenwald
strengths
ds
lcm
asymmetric
waterloo
imbalanced
attributes
hu
bandwidth
worse
consumption
chong
hwang
formulae
proportional
units
interleaved
frequently
scheduled
server
strings
speeds
cluster
successive
logically
accommodating
beginning
power
song
bit
delivery
conservation
battery
probes
items
retrieved
geographical
a3
updates
consecutively
peng
record
impacts
ffl
balancing
packet
broadcasts
allocation
inversely
missed
ll96a
enviroments
cycle1010001
leong
fanouts
tuneb
imitates
cycle110010000
consump
quinglong
qingzhao
821
administrating
071e
hambrusch
091
zfa94
employeed
influencies
clusterness
hv97
yuni
dmitri
ivb94a
factor48121620
kwangjin
factor1000001e
interrelation
sv96
meee
sence
kalashnikov
hll98a
baihua
prabhakar
index tree
tune in
broadcast cycle
data frames
the tune
access time
broadcast disks
clustered broadcast
non clustered
the index
the broadcast
flat broadcast
in time
index methods
the signature
data frame
signature method
integrated signature
the access
indexing efficiency
frames in
data broadcast
a broadcast
scattering factor
tree method
the hybrid
sparse index
for broadcast
meta segment
data block
broadcast channels
desired frames
false drop
the client
non index
data organization
signature methods
broadcast scheduling
index method
initial probe
of frames
cycle the
clustered and
time overhead
clustered data
indexing method
meta segments
signature and
broadcast channel
cost models
for clustered
indexing techniques
the sparse
1e 05
time saved
minor cycle
on broadcast
replicated part
05 frames
each meta
and tune
the indexing
a clustered
cycle with
frames with
indexing methods
time for
hybrid index
the clustered
info frame
clustered cycle
frames tree
of data
tree and
is broadcast
drop probability
the replicated
time and
of broadcast
both clustered
desired frame
index overhead
waiting time
broadcast the
tree is
hybrid method
desired data
hybrid indexing
hybrid methods
frame is
first desired
index frames
conservative indexing
info info
tree overhead
probe time
client tunes
frame frame
tree techniques
hybrid figure
cycle x
x 1e
data access
same attribute
in broadcast
an index
overhead for
cycle is
frames are
broadcast in
attribute value
for retrieving
power conservative
on air
distributed indexing
each disk
for flat
comparisons for
of index
wireless broadcast
the scattering
average access
sig hybrid
broadcast cycles
average false
frames before
wang chien
minor cycles
tunes into
tree sig
frame info
broadcast units
chien lee
frames is
frames to
the data
data broadcasting
for data
disks and
estimated as
of packets
the desired
time of
the integrated
in cycle
signature the
data dissemination
an integrated
the non
each data
signature is
broadcast schedule
attribute indexing
of tune
for signature
a mobile
and signature
method has
tree the
time is
mobile computing
retrieving all
broadcast for
and non
a cycle
the arrival
and scheduling
clustering and
upper t
index trees
mobile computer
signature techniques
true match
t levels
information frames
level signature
expected access
query signature
broadcast d
time comparisons
simple signature
index nodes
ivb96 ll96b
saved per
signature technique
to ivb96
whole index
control index
disks is
frames can
the air
the signatures
10 0
be broadcast
of indexing
cycle i
the disks
the clients
cycle for
access patterns
tune in time
the index tree
the tune in
the access time
clustered broadcast cycle
of data frames
access time and
index tree method
a broadcast cycle
of the index
the signature method
non clustered broadcast
and the tune
sparse index tree
index tree is
access time overhead
index tree and
in the broadcast
the sparse index
the index methods
broadcast cycle with
number of frames
frames in the
in time of
for broadcast disks
broadcast cycle the
the broadcast cycle
the desired frames
the non index
in time for
a non clustered
access time for
and non clustered
data frames in
each meta segment
the data frames
in time is
time and the
for a clustered
an integrated signature
time and tune
and tune in
clustered and non
1e 05 frames
each data frame
an index tree
frames with the
and the hybrid
broadcast cycle is
number of data
a clustered broadcast
the broadcast channel
the data frame
of frames in
05 frames tree
index tree the
false drop probability
in time saved
the indexing efficiency
signature and the
time of the
the hybrid method
the signature and
in time and
data frame is
clustering and scheduling
both clustered and
data frames are
the replicated part
time for retrieving
the integrated signature
cost models for
of the broadcast
for the index
for a non
the broadcast disks
the data block
the same attribute
of the signature
for flat broadcast
the scattering factor
x 1e 05
a data frame
8 0 10
the clustered broadcast
frames in cycle
power conservative indexing
hybrid indexing method
index tree techniques
index tree overhead
the initial probe
the client tunes
the hybrid methods
first desired frame
signature method is
6 0 8
non index method
the non clustered
cycle x 1e
initial probe time
data frames with
in cycle x
broadcast disks and
same attribute value
tree and the
in the index
in a cycle
waiting time for
all the desired
frames in a
and the signature
the number of
be estimated as
in a broadcast
2 0 4
4 0 6
0 8 0
broadcast cycle we
tunes into the
index tree for
desired frames in
non clustered data
cycle the tune
of a broadcast
tree and signature
tree method and
the hybrid index
client tunes into
tree sig hybrid
broadcast cycle for
clustered data organization
frames tree sig
sig hybrid figure
index methods for
frames before the
for retrieving all
of tune in
desired data frames
broadcast disks is
clustered data broadcast
average false drop
the desired data
cycle i e
for non clustered
on broadcast disks
wang chien lee
number of packets
0 10 0
time for the
of the desired
of an index
the cost models
before the arrival
data frames to
arrival of the
for the signature
frames can be
of the hybrid
0 4 0
0 6 0
integrated signature and
data access patterns
offset to the
data on air
in time are
replicated part of
amount of tune
into the broadcast
time saved per
wireless data broadcast
upper t levels
the broadcast channels
scattering factor m
info frame info
time and indexing
tree is broadcast
for a broadcast
of access time
saved per unit
the whole index
the index overhead
index tree to
for broadcast channels
broadcast cycle i
the average access
t levels of
data frames can
indexing techniques for
for both clustered
frame frame frame
initial probe the
index tree can
of indexing methods
clustered broadcast cycles
the expected access
whole index tree
the average false
signature method has
data frames before
expected access time

corpus/krapavin2000-test/607200.txt
penl
enl
nl
outliers
dataset
disk
array
block
blocks
internode
outlier
buffer
processors
reciprocal
mining
bsp
count
arrays
minptsub
cheung
hung
counts
calculations
pages
objects
superstep
unmarked
reads
synchronization
800000
dimensionality
percents
sp2
fill
reading
swap
barrier
distance
lof
pnp
is4
ready
quadratic
object
node
exports
money
page
database
np
counter
neighborhoods
400000
bulk
processor
b0
mark
staying
card
repeat
besides
200000
temp
evenly
passes
comp
nications
32000
contains4
9076
128000
nearest
communication
neighbor
100000
50000
supercomputer
outperforms
workstations
5625
communications
read
nearly
va
fraud
names
accessing
interconnected
parallelize
filling
d0
1gb
commonalities
kn
detection
comparisons
density
dimensions
year
items
loaded
calculation
c0
neighbour
waves
please
temporary
synchronous
electromagnetic
mine
marked
improvement
pp
cluster
datasets
spatial
satellite
commodity
a0
send
reverse
minor
transferred
quantum
costs
association
execution
threads
neighbourhood
kong
databases
resident
credit
ibm
neighborhood
8000
clustering
arrangement
targets
nested
memory
commerce
dist
cheung0
1563
theroretical
23095637
37500
7459
6250
974467
orginal
comparions
hksar
domestic
lied
8636
supersteps
excep
8743
8487
hifh
breunig
athletes
852000
architetures
knorr
seconds100100001
commuication
222400000
75000
618697
amost
3pp
p2sc
17763925
loadleveler
333100000
cpenl
3125
fraction
transferring
sequential
discovery
b1
studies
identification
cell
message
proximity
disks
ratio
categories
served
enhanced
passing
buffering
criminal
250mhz
cx
first array
disk i
the dataset
i o
second array
of outliers
linear to
of objects
outliers in
object t
blocks reads
o time
of processors
objects in
penl is
block reading
reciprocal of
in penl
hung and
based outliers
internode communication
the reciprocal
the counts
nl and
of calculations
quadratic to
the block
local disk
a block
computation cost
execution time
and enl
non outlier
in enl
array do
and cheung
reading order
large database
each object
of nl
nl algorithm
parallel mining
dataset size
cost is
dataset is
of pages
of penl
enl the
enl is
of blocks
the disk
each node
mining of
in large
the blocks
penl with
set counter
second arrays
minptsub nearest
the count
computation time
neighbor node
distance d
the total
of distance
two arrays
as done
no read
of dataset
m mark
bsp model
t distance
increase count
and penl
read required
dataset passes
for penl
mark t
enl and
array as
a page
is linear
of computation
fill the
count i
do i
the buffer
block is
local memory
the computation
density based
swap the
total of
4 blocks
o communication
buffer size
distance based
the dimensionality
is quadratic
performance studies
block in
blocks in
penl algorithm
third array
report unmarked
enl to
np p
of enl
unmarked objects
algorithm penl
computation operations
ready blocks
blocks loaded
three arrays
the internode
distance calculations
nearest neighborhoods
original nl
if second
major cost
of memory
be t
all blocks
then with
communication time
node has
of disk
2 blocks
array with
blocks the
total number
pages in
communication network
a total
arrays and
blocks are
3 communications
synchronization time
as outliers
array if
count m
the names
bound of
the neighbor
names of
array is
reverse the
counter c
communications for
processor number
above from
processors ffl
count by
dataset the
time is
parallel algorithm
a count
do a
data mining
d if
reads is
theoretical analysis
1 blocks
a barrier
node 0
array which
memory is
in first
local block
800000 objects
to penl
each superstep
otherwise mark
algorithm nl
nothing system
temp buffer
with enl
for nl
parallel bsp
1 label
if count
5 repeat
passes is4
order swap
the bsp
all ready
kn 2
nl for
local blocks
blocks staying
percentage change
bsp computer
change percentage
money and
va file
nearly evenly
2 fill
calculations actually
count j
penl using
disk i o
the first array
number of objects
linear to the
number of processors
outliers in large
i o time
to the reciprocal
of objects in
number of calculations
quadratic to the
reciprocal of the
the second array
the reciprocal of
of outliers in
mining of outliers
each object t
in large database
the number of
the dataset size
is linear to
in a block
a non outlier
first array do
block reading order
hung and cheung
parallel mining of
nl and enl
for each object
number of pages
the disk i
first array as
the computation cost
for a total
number of blocks
objects in the
in the dataset
array do i
object t in
of nl and
to the dataset
swap the names
distance based outliers
is quadratic to
and second arrays
object t i
the block reading
computation cost is
in the first
of disk i
the dataset is
of the number
as a non
the neighbor node
a total of
the execution time
of the dataset
amount of memory
marked as done
of 2 blocks
2 blocks reads
no read required
t distance d
increase count i
m mark t
in first array
to t distance
close to t
upper bound of
in each node
the total number
total number of
distance d if
i o communication
if the count
each node has
the time of
the dataset the
total of 2
pages in a
the names of
the above from
minptsub nearest neighborhoods
the internode communication
fill the second
second array with
array which are
the major cost
processors ffl the
above from step
unmarked objects in
objects in first
repeat the above
first array which
report unmarked objects
of dataset passes
mark t as
fill the first
arrays and repeat
number of dataset
of processors ffl
density based outliers
the count m
to the dimensionality
array is marked
names of first
of comparisons of
blocks reads and
table of comparisons
count m mark
count by the
second arrays and
repeat until all
array as outliers
block of objects
compared to first
cost is quadratic
to first array
if second array
3 communications for
of blocks in
of pages in
d if the
with the size
execution time is
local disk i
in a node
the block is
the block in
send the data
to the neighbor
our parallel algorithm
array to the
blocks the total
o time is
the upper bound
and disk i
dataset size and
block in the
the counts of
which are close
of processors as
of first and
first and second
t as a
the local disk
with a block
is as the
the two arrays
bound of the
of number of
be the number
data mining a
is marked as
and repeat the
the computation time
objects in a
and the number
a block of
spatial data mining
of penl is
o kn 2
pages contained in
object t j
all ready blocks
the count by
count as a
n ae pnp
of calculations actually
change percentage change
percentage change of
of computation cost
and count j
first array in
or a done
done state 2
reading order do
and linear to
j is unmarked
as ready the
otherwise mark the
two arrays of
in enl the
the computation operations
array if object
blocks staying in
ready or a
a ready or
blocks loaded and
nl algorithm is
local block number
temporary minptsub nearest
state 2 fill
i and count
second array if
and local disk
over the dataset
dataset passes is4
communications for a
reading order as

corpus/krapavin2000-test/607278.txt
designs
orbits
ff
theta
automorphism
intersection
mesner
mendelsohn
psl
orbit
kramer
kohler
subgroup
automorphisms
sylow
149
72
598
isomorphic
block
intersections
representatives
597
78
isomorphism
138
152
148
76
141
172
laue
normalizer
120
84
105
117
151
159
77
156
126
group
600
prescribed
73
132
11100
11400
1658
4800
trung
betten
wassermann
13200
13800
170
75
nh
admitting
134
167
113
599
116
114
131
125
130
133
144
71
74
equations
68
147
omega
85
7200
3600
169
64
128
pairwise
67
165
164
dale
602
qiu
cosets
60
171
83
119
6000
136
139
66
79
81
112
10800
22800
14400
kerber
grabmeier
weispfenning
127
rong
70
107
111
137
sv
101
88
153
98
lexicographically
57
143
121
69
109
2400
lll
orderly
volker
kaltofen
f2g
tran
103
1200
140
blocks
fix
58
pg
86
118
94
ng
173
stabilizer
johannes
157
146
124
100
145
135
55
80
12000
reinhard
1800
87
160
92
erich
15000
82
610
york
142
wu
400
isomorphisms
gf
106
subsets
96
162
binomial
123
triangle
163
150
48
154
sprott
385000
tomorphisms
myampersand
f8g
140215
765140
15800
f30
8400
f95g
161500
f110g
225075
1545
f48g
119g
1230
f111g
9 d
intersection numbers
d ff
ff 9
block intersection
ff 2
ff 3
designs with
2 9
9 b
b h
the designs
intersection types
automorphism group
orbits of
3 9
psl 3
of designs
31 10
non isomorphic
theta 75
global intersection
8 designs
8 31
of automorphisms
t designs
148 149
of mendelsohn
types ff
theta 74
theta 73
intersection type
all designs
designs are
h ff
pairwise non
600 theta
theta 76
theta 71
global intersections
m subset
intersections 6
theta 72
of kohler
theta 77
kramer mesner
of orbits
subgroup p
10 100
numbers of
the equations
essential block
intersection number
fix omega
theta 78
7 designs
149 151
a sylow
167 169
147 148
58 60
ng p
6000 theta
a orbits
72 75
sylow subgroup
151 152
nh a
76 77
64 66
the automorphism
equations of
subgroup of
these numbers
isomorphism problem
12 theta
119 120
100 101
omega a
98 100
theta 70
group of
of blocks
the isomorphism
arbitrary m
design theory
the 8
the orbit
the intersection
173 block
mendelsohn 10
153 156
prescribed automorphism
400 theta
70 72
dale m
13200 theta
tran van
3600 theta
10 orbits
theta 85
theta 69
of kramer
van trung
theta 79
rong wu
131 132
1658 designs
theta 67
113 114
simple 8
170 171
7200 theta
11400 theta
120 121
trung qiu
157 160
the kramer
171 173
full group
165 167
149 150
kramer and
full symmetric
qiu rong
156 159
133 134
simple 7
theta 80
m mesner
84 85
theta 68
orbit representatives
128 130
4800 theta
designs admitting
125 126
100 designs
170 172
1200 theta
and mesner
designs for
ff s
a as
the group
the design
normalizer of
the normalizer
theta 84
numbers ff
75 76
two designs
92 94
60 64
are pairwise
3 5
for ff
group theoretic
triangle of
pg 2
admitting a
theta 64
the orbits
the essential
a on
theta 10
ff t
symmetric group
subset m
designs is
designs we
a g
k sets
group on
group then
order s
b 0
following way
fact all
of classes
group are
k subsets
and intersection
the prescribed
1 ff
24 theta
120 125
164 170
145 146
isomorphism problems
theta 82
orderly generation
there more
intersection equations
ordinary intersection
mendelsohn for
2400 theta
105 109
67 2400
class sizes
9 d ff
2 9 d
ff 2 9
ff 9 b
3 9 d
ff 3 9
9 b h
d ff 3
d ff 2
block intersection types
intersection numbers of
psl 3 5
8 31 10
h ff 9
b h ff
group of automorphisms
types ff 9
pairwise non isomorphic
intersection types ff
the equations of
of the designs
global intersections 6
31 10 100
of the design
global intersection numbers
block intersection type
are pairwise non
the essential block
classes of size
147 148 149
numbers of higher
fix omega a
block intersection numbers
essential block intersection
the global intersection
equations of mendelsohn
the isomorphism problem
b h for
subgroup p of
the intersection numbers
orbits of a
of classes of
the automorphism group
of a on
full symmetric group
the 8 designs
qiu rong wu
prescribed automorphism group
equations of kohler
t 1 m
the 8 31
order s of
designs admitting a
the full symmetric
8 designs with
kramer and mesner
the block intersection
automorphism group are
9 d for
tran van trung
simple 7 designs
of the automorphism
600 theta 67
parameters and intersection
10 100 designs
intersections 6 3
an arbitrary m
m of v
a sylow subgroup
van trung qiu
intersection type of
orbits of the
171 173 block
the kramer mesner
pg 2 5
full group of
ff t 1
m subset m
admitting a as
arbitrary m subset
dale m mesner
173 block intersection
trung qiu rong
solve the isomorphism
t v k
are non isomorphic
of order s
the normalizer of
3 theta 10
the designs are
of orbits of
subset m of
the orbits of
of ff 2
0 i t
on the set
the following way
two different ways
following table shows
as a group
3600 theta 69
ff i 0
76 77 78
kaltofen volker weispfenning
sets of blocks
intersection numbers ff
the design for
kramer mesner system
wu and dale
cited references computer
164 170 171
the intersection triangle
of kramer and
9 d 3
on k sets
theta 67 2400
isomorphism problem for
m subset of
designs with ff
number of orbits
151 153 156
94 95 98
that all designs
with automorphism group
average class size
m with d
149 151 152
67 2400 theta
2 the designs
172 block intersection
167 169 172
9 d in
75 7200 theta
intersection numbers are
and dale m
a on k
of simple 7
120 124 125
the average class
intersection number of
a as their
58 60 64
of designs with
f2g global intersections
theta 64 600
fixed m subset
mendelsohn systems 14
designs are constructed
with ff 2
64 66 71
be mixed up
60 64 66
this case ff
75 76 77
handbook springer verlag
72 75 76
169 170 172
mendelsohn 10 for
31 10 designs
intersections 6 4
designs with designs
64 600 theta
designs with automorphism
the a orbits
class of designs
by mendelsohn 10
92 94 96
69 6000 theta
3 5 on
intersection triangle of
generalized mendelsohn systems
55 56 58
numbers of designs
late intersection numbers
again let m
117 119 120
149 151 153
72 10800 theta
d 2 ff
80 82 83
kerber laue wassermann
10 orbits of
volker weispfenning cited
a maximal subgroup
numbers ff t
t designs with
theta 69 6000
simple 8 designs
an automorphism group
of designs is
141 142 144
10800 theta 73
ordinary intersection numbers
and intersection equations
1 parameters and
148 149 150
design which has
159 167 169
designs with small
149 150 151

corpus/krapavin2000-test/607292.txt
jacobi
enumerator
coset
polarization
polynomials
codes
golay
molien
invariants
designs
weight
enumerators
extremal
codewords
gammadesign
gdd
ozeki
covering
macwilliams
jt
dual
packing
bivariate
assmus
magma
invariant
mattson
octad
gammahomogeneous
series
resp
self
delsarte
simultaneous
divisible
coefficient
sol
wc
cosets
reynolds
gleason
aronhold
polarizations
4397342400
gammas
gammaset
43719104
hammingcomposition
gammasets
bannai
d16
puncturing
combinatorial
polynomial
taylor
homogeneous
bachoc
72
hamming
wz
reed
joint
na
zx
muller
codeword
combinatorially
609
christine
congruent
schur
varieties
192
am
code
rank
assertion
blocks
outer
groups
correcting
operator
gammaform
bidegree
2119532800
decresing
gammaforms
michio
1631
suggestively
actes
restatements
wzxy
jg24
gammadesigns
monodimensional
eiichi
prange
gammasubsets
1916
2461
14336
issai
30888000
congr
choie
9223731055
gammauples
wzx
emmynoether
lattices
subtraction
algebra
68
m0
discr
bonnecaze
xix
hironaka
anyways
congress
witt
steel
ematiques
calderbank
group
acting
fixes
monomials
degree
shall
expansion
spaces
putative
leaders
gammaj
coordinate
pb
noticing
chap
aj
equ
shortening
monomial
yields
secondary
modulo
gammat
gammai
n0
elusive
quadruples
injectivity
radius
binary
decomposition
x5
enumerates
combinatorics
counts
matrix
nice
gd
allan
denotations
x6
children
notations
cp
wiley
44
congruence
contemporary
n1
gf
m1
cumbersome
1970
233
strengthening
forms
formula
stands
scalar
doubly
owner
standing
vanish
ffi
math
det
incidence
361
148
generating
enumerating
belonging
places
substitutions
dm
jacobi polynomials
weight enumerator
self dual
molien series
of jacobi
enumerator of
jacobi polynomial
the jacobi
weight enumerators
covering designs
type ii
given weight
dual codes
design with
codewords of
simultaneous invariant
ii code
the weight
of weight
the coset
enumerators of
coset weight
hold a
a t
generating series
golay golay
extremal type
bivariate molien
distribution matrix
weight hold
the molien
polarization operator
the polarization
polynomials j
joint weight
packing and
a simultaneous
the assmus
with jt
jacobi forms
assmus mattson
weight distribution
and covering
coefficient of
with parameters
j c
invariants in
22 p
the packing
c t
group divisible
finite groups
p sol
am n
codes on
outer distribution
an octad
combinatorial interpretation
invariant space
28 y
for jacobi
reynolds operator
of degree
a code
the coefficient
invariants of
of length
the macwilliams
mattson theorem
extremal self
invariant theory
all codewords
the reynolds
of invariants
an extremal
a coset
t design
j 8
codes a
code c
in length
the codewords
of self
g 2
two polynomials
same group
designs a
binary codes
codes of
pairs in
spaces of
polynomials are
binary code
degree 40
jt may
t gammadesign
by hamming
seen combinatorially
polarizations of
d16 t
length 32
coset x
2 designs
j 16
the hammingcomposition
for jt
length 72
j d16
1 gammadesign
codeword then
x 44
coordinate place
muller code
r designs
a taylor
rank parameters
the aronhold
y 28
this counts
homogeneous if
aronhold polarization
by subtraction
covering design
y 43719104
t supports
wc i
octad then
weight t
codewords whose
combination 8
ffi p
length 8
secondary invariants
macwilliams relation
4397342400 x
n groups
series f
primary invariants
of coset
yields after
44 y
t gammahomogeneous
simultaneous invariants
divisible designs
the code
codes and
invariants and
if t
invariant of
a design
length n
t with
w z
group g
code obtained
macwilliams formula
of codewords
collection b
36 16
order 192
extremal codes
new rank
of extremal
w 8
reed muller
covering radius
t sets
or outer
binary linear
sol e
for spaces
place i
polynomials were
christine bachoc
by ozeki
following decomposition
a macwilliams
dual code
weight 4
simple combinatorial
for codes
second assertion
a group
t r
w x
sense of
all t
72 36
4 design
no word
z 6
5 terms
cosets of
four variables
t distribution
from 22
a codeword
algebra system
in j
space of
the jacobi polynomial
weight enumerator of
j c t
the weight enumerator
of jacobi polynomials
self dual codes
a simultaneous invariant
type ii code
weight enumerators of
terms of degree
packing and covering
space of jacobi
weight hold a
t with jt
and covering designs
hold a t
the molien series
a design with
is a simultaneous
given weight hold
bivariate molien series
the assmus mattson
the packing and
the coefficient of
jacobi polynomials j
of self dual
jacobi polynomials are
the invariant space
combinatorial interpretation of
golay golay golay
the coset weight
design with parameters
of the polarization
bound on b
for jacobi polynomials
the joint weight
extremal type ii
an extremal type
joint weight enumerator
the reynolds operator
of finite groups
of a code
a t design
extremal self dual
assmus mattson theorem
code of length
a self dual
codes of length
the same group
number of pairs
of length n
linear combination 8
simple combinatorial interpretation
hold a 5
contains no word
in w z
p sol e
jt may be
coset weight distribution
in an octad
the polarization operator
cases in length
on b t
codewords of every
every given weight
coordinate place i
any given weight
of a coset
j d16 t
t distribution matrix
jacobi polynomials were
parameters for spaces
coefficient of u
theory of error
outer distribution matrix
homogeneous if the
formula for jacobi
invariant of g
collection b j
in four variables
if the codewords
x 44 y
given weight in
codewords of given
coset x c
rank parameters for
be seen combinatorially
combination 8 1
the macwilliams relation
new rank parameters
in the molien
jacobi polynomial is
of the aronhold
simultaneous invariant of
polynomials j d16
a codeword then
the aronhold polarization
all codewords of
a macwilliams formula
coefficient of w
j 8 s
ii code of
designs with parameters
distribution matrix in
group divisible designs
of generating series
generated by two
t r designs
of weight t
or outer distribution
t supports a
codes on the
the t distribution
weight distribution of
of length 32
a collection b
enumerator of c
invariant for g
v k t
of jacobi forms
with jt may
aronhold polarization operator
reed muller code
terms of generating
of given weight
a t gammadesign
72 36 16
that all codewords
no word of
gives the packing
is the hammingcomposition
c t with
macwilliams relation for
5 terms of
d16 t with
use the reynolds
w z x
vectors of any
4 design with
of every given
if t supports
invariants of finite
molien series f
enumerator of a
polarization operator a
code c of
a 4 design
codes a and
an octad then
the sense of
pairs in the
the space of
b t c
the weight distribution
jacobi polynomials for
the codewords of
introduced by ozeki
c of length
of codewords of
also follows from
of the assmus
of u n
of weight 4
shown in 7
enumerator of the
macwilliams formula for
of order 192
group of order
of error correcting
that j c
g 2 a
self dual code
for spaces of
contained in an
the following decomposition
the covering radius
codewords of weight
word of weight
c is the
if c is
design with a
group g 2
a i x
the taylor series
the linear combination
in 7 that
of pairs in
respectively to the
upper bound on
the algebra of
a t are
invariant under the
j a b
blocks of size
may be generated
is a design
i c is
a group g
the vectors of
f u v

corpus/krapavin2000-test/607301.txt
codes
dual
harmonic
extremal
enumerators
weight
designs
polynomials
harm
codewords
self
rx
enumerator
doubly
zc
wc
hahn
macwilliams
wt
juj
jacobi
unimodular
spherical
assmus
lattices
mattson
classication
venkov
characters
nw
coe
cryptography
permutation
xed
xy
word
invariants
dened
jc
announced
tz
krawtchouck
polyno
gaborit
betsumiya
isodual
mials
koichi
formally
rst
lattice
notations
lemma
0it
harada
poisson
2k
mod
polynomial
ozeki
masaaki
denition
code
fourier
ng
unknowns
invariant
chap
equations
cients
strengthening
summation
formula
possibilities
classi
degree
equality
ig
satises
ju
series
cardinality
subgroup
spaces
transform
binary
corollary
milenkovic
quebbemann
dualcodes
kenichiro
enu
reprove
fnw
merators
_4
byp1
isoduality
p101461
abh
extremality
olgica
masson
pless
tanabe
algebra
combinatorial
remark
subsets
meeting
dierentiation
molien
0010
bijections
uj
bonnecaze
delsarte
magma
bachoc
sits
calderbank
classical
intersection
cw
circulant
isometric
deduces
kin
geom
group
nd
meets
denitions
aw
huffman
matrices
analogy
position
positions
duals
zx
coding
covering
recover
classify
ideals
coset
automorphism
shadows
resp
christine
gathers
valuation
euclidean
usual
cient
nite
analogues
referee
settle
302
odd
325
rep
argumentation
weights
modular
384
homogeneous
ker
bijective
tf
eight
corollaries
transposition
philippe
orthogonal
scalar
283
specialize
332
sole
math
g2
g1
preprint
148
siam
hypothesis
dene
theta
belongs
jt
belonging
dimension
overlap
shadow
play
identied
correcting
self dual
formally self
dual codes
even formally
harm k
harmonic weight
code c
doubly even
weight enumerators
weight 4
2 harm
extremal even
dual code
k t
xed weight
c f
h k
weight enumerator
of weight
codewords of
hahn polynomials
the harmonic
length 12
t design
z c
of xed
w c
codes and
an extremal
to permutation
even self
relative invariants
zc h
group g
harmonic functions
words of
the codewords
of degree
degree k
cryptography v
designs codes
binary code
weight in
in c
even unimodular
theta series
n 2k
2 rx
xy k
harmonic function
rx k
t set
c form
f 2
the characters
and cryptography
the extremal
codes of
of length
t designs
of codewords
assmus mattson
jc t
weight 6
notations of
intersection numbers
a t
nw i
lemma 2
f n
g 2
designs and
the polynomials
code of
j l
c be
the group
the coe
wc h
mod 24
macwilliams type
characters k
b venkov
wt u
design if
summation formula
poisson summation
the code
associated to
a code
u 4
length n
to c
i t
the macwilliams
mattson theorem
if wt
dual doubly
the nw
enumerators and
4 word
of ng
binary linear
of doubly
code b
invariant theory
designs in
corollary 2
codes we
weight 2
v z
these codes
b 12
jacobi polynomials
f z
let f
let c
word in
1 t
from lemma
t u
lemma 6
0 mod
derive some
polynomials we
linear codes
are relative
the notations
the polynomial
fourier transform
of harmonic
t are
c c
u 2
i g
a harmonic
8 theorem
an element
g 1
6 1
codes are
k w
set t
f x
l s
for again
even weights
six unknowns
betsumiya masaaki
codes an
support t
koichi betsumiya
spherical designs
unimodular lattices
krawtchouck polynomials
wt v
wc f
enumerator associated
tz the
of rx
masaaki harada
clearly n
this classication
6 words
juj and
enumerators wc
four possibilities
certain harmonic
classication result
spherical codes
g 0it
designs supported
harmonic spaces
extremal formally
wt t
all matrix
from hahn
such words
polyno mials
ju t
codewords support
some invariant
usual weight
of hahn
codes which
dened by
i f
only depend
a binary
theorem 2
equations in
polynomials in
all f
an even
and properties
we recall
possibilities for
one possibility
some information
x k
formally self dual
self dual codes
even formally self
h k t
harmonic weight enumerators
self dual code
z c f
2 harm k
f 2 harm
extremal even formally
of xed weight
a t design
code of length
w c f
even self dual
the harmonic weight
xed weight in
doubly even self
of length 12
the code c
of weight 4
the group g
up to permutation
c form a
codes and cryptography
a binary code
group g 1
and cryptography v
designs codes and
of degree k
zc h 1
c f x
t set t
codewords of xed
the extremal even
word in c
let f 2
dual codes of
code c and
the notations of
of codewords of
nw i t
j l s
weight in c
h 1 t
lemma 6 1
let c be
a code c
codes of length
theorem 2 1
2 f n
of length n
code b 12
design if and
of doubly even
mod 24 the
words of weight
of an even
a harmonic function
k w c
an extremal even
weight 4 in
poisson summation formula
the nw i
t design if
wc h k
k t u
for the characters
are relative invariants
4 in c
24 the codewords
of weight 6
t design for
the characters k
weight 4 word
equations in the
dual doubly even
some information on
the codewords of
only one possibility
assmus mattson theorem
in c form
v 2 f
set of codewords
weight enumerators and
1 k t
form a t
self dual doubly
lemma 2 3
binary code of
group g 2
all f 2
from lemma 6
6 1 we
corollary 2 2
length n and
the coe cient
be a binary
belongs to c
c be a
and properties of
fourier transform of
for all f
of the lattice
the fourier transform
only depend on
of the code
of harmonic weight
harmonic function of
divided by xy
by xy k
to permutation only
from hahn polynomials
enumerators and the
4 word in
cient of x
solution is trivial
an even formally
the codewords support
the polynomials z
overlap and covering
dual code we
denitions and properties
weight enumerator is
code c form
the self dual
of coordinates of
j they are
the polynomial algebra
f w c
designs and self
constructed from hahn
case k 0
macwilliams type equality
the usual weight
all matrix a
wc f x
space of relative
for all matrix
xy k w
only solution is
characters k dened
and from lemma
of invariant theory
jc t for
if wt t
enumerators wc h
8 theorem 5
codes which are
koichi betsumiya masaaki
weight 2 word
doubly even code
dual code of
betsumiya masaaki harada
even code of
t g 0it
harmonic function f
weight enumerators wc
extremal formally self
harmonic weight enumerator
0 mod 4
usual weight enumerator
with the characters
linear code c
otherwise the sum
invariant linear forms
polynomials z c
relative invariants for
results of invariant
to certain harmonic
function of degree
ju t j
have weight 4
element of rx
and ju t
f are relative
all 0 i
be an extremal
2 rx k
and formally self
a if n
weight 6 words
harm k and
t j they
c of weight
a t set
d of i
to derive some
dual codes with
compute the fourier
of hahn polynomials
enumerator associated to
6 1 there
certain harmonic functions
two such words
weight enumerator associated
t respectively of
when the codewords
2 word in
juj and ju

corpus/krapavin2000-test/607562.txt
fevbdds
evbdds
fevbdd
evbdd
fevbddeval
diagrams
hc
obdds
nonterminal
terminal
h0
gcd
ev
affine
fractions
boolean
ans
rulei
matrix
multiplication
matrices
rational
isomorphic
mtbdds
obdd
arithmetic
designators
factored
child
multiplicative
termwise
fgilp
lai
package
op
valued
complement
word
numerator
edge
jhc
weights
verification
normalizing
weight
additive
recursion
decision
nonisomorphic
walsh
val
consumption
precision
binary
cache
integers
gammak
pivot
kolmogorov
reconverging
sparse
denominator
jf
manipulation
ilp
multiply
swapping
bmd
9f
zy
mtbdd
scalar
edges
row
associating
vertex
delta
graphs
inversion
spectral
signals
operands
additionally
circuit
integer
subgraph
chapman
multiples
node
vrudhula
euclid
subblocks
fdds
sevbdds
recursively
encode
goes
pivoting
inverses
bytes
branches
savings
drechsler
jgj
canonicity
cad
transposition
offer
representations
bit
rule
evi
redirected
signed
expansion
flattened
subgraphs
xy
subtraction
transforms
tabular
mbyte
subcase
multiplying
shifting
logic
realized
bdd
submatrices
rolf
concisely
canonical
denoting
encoding
routine
compact
ei
isomorphism
rows
lookup
conversion
calls
kronecker
gaussian
else
solver
uniqueness
compactly
jaj
maximal
assignment
hash
pointers
symbolic
fractional
mode
storing
divisor
recursive
column
absent
fields
fw
hx
transformation
concept
successfully
behavioral
internally
division
comp
expands
8f
ffx
hreth
nowwe
seminumerical
xz5
khc
fdd
dds
mcgeer
rowadd
binarily
ite
gebraic
fevb
zy5
decisiond
dne
6x
jfj
evbddeval
deltafevbddeval
bahar
risen
coladd
kgk
okfdd
fromnode
decision diagrams
function graphs
binary decision
edge valued
valued binary
the fevbdd
boolean functions
word level
complement edges
that fevbddeval
affine property
fevbddeval h0
terminal node
recursion step
rational rule
the evbdd
goes here
every recursion
child e
for evbdds
child t
the rational
edge weights
f and
weight normalizing
evbdds and
factored edge
and g
the terminal
w f
the gcd
holds that
by lai
nonterminal vertex
two fevbdds
recursively affine
computation cache
vertex f
gcd rule
a fevbdd
lai et
integer linear
the affine
logic verification
scalar multiplication
matrix multiplication
to matrix
node 0
it holds
arithmetic functions
multiplicative weight
to fevbdds
using fevbdds
isomorphic then
fevbdds can
to evbdds
additive property
n gammak
of fevbdds
on evbdds
on fevbdds
an evbdd
and fevbdds
function graph
fevbdds are
boolean function
new node
memory consumption
non isomorphic
arithmetic operations
boolean operations
c f
g are
o jf
f child
are isomorphic
numerator and
linear programming
top variable
weight with
t f
matrices that
f 6
of matrices
fevbdd node
affine matrix
evbdd and
are nonisomorphic
associating both
nonterminal then
fevbdd representing
o jhc
column designators
for fevbdds
f rulei
evbdds by
of evbdds
of multiplicative
fevbdd representation
affine transformation
e f
operations on
the numerator
of boolean
an affine
matrix representation
by associating
multiple precision
of apply
a multiplicative
f e
computational complexity
multiplicative weights
terminal case
arithmetic function
matrix inversion
matrix package
additive and
then let
w t
done for
as can
input signals
certain operations
matrix multiply
a recursively
calls to
to represent
and denominator
for matrix
on function
the function
an additive
and fevbddeval
jhc f
conversion rules
matrix add
spectral transforms
ev w
single terminal
evbdd representation
of reconverging
multiplicative edge
the chapman
if child
directly represent
chapman kolmogorov
max field
evbdds additionally
for obdds
weights allows
if ev
nonisomorphic then
assignment f
evbdd representations
make new
evbdds 14
hc f
fractions are
hc fi
termwise operations
fevbdds however
by fevbdds
normalizing rules
row swapping
precision fractions
function decomposition
ev f
reconverging branches
mtbdds or
pseudo boolean
fevbdds since
kolmogorov equations
normalizing rule
non sparse
multiplication of
as integer
offer a
complexity o
w g
generated using
and matrix
jf j
operation op
maximal element
and manipulation
the arithmetic
the concept
concept of
x n
been done
integer or
with complement
three calls
moment diagrams
binary moment
of complement
of obdds
package to
topology except
edge valued binary
valued binary decision
binary decision diagrams
f and g
the affine property
every recursion step
child e f
the terminal node
factored edge valued
terminal node 0
that fevbddeval h0
and g are
the rational rule
g are isomorphic
in every recursion
child t f
by lai et
lai et al
it holds that
integer linear programming
a multiplicative weight
been done for
x n gammak
the gcd rule
weight with the
the function graph
holds that fevbddeval
calls to matrix
evbdds and fevbdds
the computation cache
are non isomorphic
an affine transformation
f t and
of boolean functions
denotes the arithmetic
additive and a
both an additive
6 c g
an additive and
the additive property
such that fevbddeval
associating both an
nonterminal vertex f
nonterminal then we
vertex f 2
a recursively affine
on function graphs
by associating both
and a multiplicative
recursively affine matrix
multiplicative weight with
the numerator and
as can be
o jf j
of matrices that
class of matrices
the arithmetic function
f x n
matrices that can
arithmetic operations on
of arithmetic functions
multiplication of two
by an affine
the top variable
then let f
the concept of
generated using the
such as integer
computational complexity for
has been done
representation and manipulation
numerator and denominator
weights allows us
compared to evbdds
g then let
matrix representation and
to matrix add
o jhc f
three calls to
based on evbdds
weight normalizing rules
a word level
proposed by lai
the fevbdd representation
function graphs have
to the rational
with complement edges
based on fevbdds
complexity o jf
f and w
conversion rules are
to matrix multiply
same topology except
max field of
introduction of multiplicative
of arbitrary precision
of complement edges
the operation op
solving the chapman
weight normalizing rule
g t are
complexity of apply
of reconverging branches
make new node
f 6 c
a terminal case
the single terminal
f child e
fractions of arbitrary
the chapman kolmogorov
are isomorphic then
to directly represent
multiplicative edge weights
same weight normalizing
satisfy the affine
word level function
as integer linear
a nonterminal vertex
t f child
are nonisomorphic then
directly represent the
and two pointers
chapman kolmogorov equations
evbdds additionally the
as it has
a new node
a boolean function
then we must
the computational complexity
as has been
in the function
based on function
of word level
binary moment diagrams
been generated using
diagrams and their
and g t
and f e
decision diagrams and
new node is
integer valued functions
verification of arithmetic
graphs have been
that c f
such as addition
assignment such that
we must have
we can easily
operations can be
us to directly
array of boolean
the same topology
c f is
f be an
time complexity o
lemma 3 1
be represented by
with the edges
t and f
ordered binary decision
the edge weights
method was proposed
a more compact
based algorithms for
matrices can be
have been generated
can be seen
be seen from
operations such as
the same weight
f such that
if we use
let f be
of the circuit
we have to
modeling of conditional
matrix multiply and
terminal node 1
concept of complement
types of vertices
function with complement
that fevbddeval hc
multiplicative weight to
the imposed variable
concisely as a
no two nonterminal
represents the constant
and column designators
also nonterminal then
the multiplicative weights
is no nonterminal
two pointers in
the constant denotes
represent the so
if w t
is nonterminal then
the edges connected
of functions concisely
the evbdd and
the same subgraph

corpus/krapavin2000-test/607573.txt
markings
rs
pn
reachability
marking
rg
hn
transitions
ln
net
nets
pns
kronecker
rgs
places
aggregated
petri
lns
regions
invariants
transition
reachable
firing
tokens
coloured
macro
st
plates
subnets
spns
matrices
enabled
p13
compositional
belt
incidence
successor
p6
sect
hierarchical
producer
p10
gspn
bordered
consumer
agg
gspns
cpn
cpns
fflt
lt
arcs
region
symmetries
compact
ut
zz
generation
hierarchy
hierarchically
boolean
invariant
en
structured
matrix
xh
tnr
conveyor
p7
t5
trivial
fired
subvectors
uncolored
spn
subnet
covered
superposed
radix
p9
successors
od
r1
stochastic
synchronized
p3
p5
t4
obdds
aggregation
p4
reduction
internal
crane
ap2
ap1
consumers
additionally
substituted
argumentation
place
r2
production
vectors
stubborn
9t
elevating
pastor
ord
numbering
unreachable
t1
isolated
runtimes
622
metal
t6
t7
bags
consecutively
exploration
cell
na
huge
combinations
jv
composing
analogously
obdd
p8
prop
b2
ffl
effort
oe
arc
induction
characterize
242
lcm
feeding
nh
interleavings
t3
buffer
merged
robot
b1
polygons
sequences
decomposed
theta
thetan
belonging
markov
hashing
structuring
live
202
representations
projection
assures
p2
mb
shaded
270
ri
generate
considers
jsj
t2
254
minimal
partition
nb
reg
submatrix
versa
cpu
fig
subsequently
experiences
fulfill
conquer
obviously
preserving
vice
handled
row
exploitation
consequently
priori
asynchronously
omitting
delta
omega
aggregate
realized
clarify
workstation
reachability set
extended net
the hn
the reachability
of rs
rs j
rs pn
pn s
rs h
reachability graph
p invariants
h pn
transition t
marking of
the kronecker
reachability sets
rs and
of markings
of transitions
the ln
and rg
reachability analysis
the marking
level net
rg generation
kronecker representation
marking m
minimal regions
ln j
reachable markings
enabled in
markings in
set rs
hn and
structured rs
in rs
of rg
petri nets
transitions in
2 rs
generate structured
local transitions
macro marking
macro markings
markings are
rs hn
generate rs
aggregated places
net for
an extended
a marking
transitions t
markings for
rs is
a pn
the pn
an aggregated
markings and
non trivial
n ffl
transitions which
q h
of places
place p
the net
net is
petri net
hn marking
successor marking
kronecker operations
p invariant
trivial regions
marking x
the rg
generated reachability
rg h
rg pn
successor markings
is enabled
n s
the places
a transition
in marking
invariant computation
state space
of regions
of ln
reduction rules
transitions of
incidence matrix
marking is
st st
a region
hierarchically generated
component rgs
aggregated description
level nets
complete rg
markings from
zz n
p agg
in pn
of generate
rs the
markings which
low level
t 2
initial marking
the complete
running example
a place
linear combinations
2 t
pn and
analysis approaches
production cell
m 0
the aggregated
t out
compact representation
pn is
2 lt
a ln
gspn models
pns in
aggregated marking
hierarchical reachability
preserving reduction
lt j
compositional analysis
behavior preserving
new places
rg can
out r
place bordered
t invariants
marking y
of rgs
the hierarchically
aggregated place
n r1
tokens on
transitions is
covered by
all transitions
j x
sequence s
transitions are
generation of
high level
markings of
hn are
net n
possible transitions
a compositional
representation of
the effort
by positive
do remove
of aggregated
space generation
m x
the extended
each place
nets the
and reachability
integer vector
a j
net and
from rg
rgs are
complete reachability
after t5
internal behavior
pn which
for pns
markings is
g rs
pn into
synchronized transitions
identical reachability
for rs
fired after
net into
for coloured
rs i
characterize rs
of pns
kronecker product
rgs is
exploration for
pn with
p3 p6
to hn
mixed radix
on rs
in generate
for gspn
extended nets
complete net
the reachability set
an extended net
the marking of
h pn s
rs h pn
the kronecker representation
generate structured rs
rs and rg
the reachability graph
number of markings
marking of the
of the hn
is enabled in
high level net
t 2 t
generated reachability set
reachability set and
reachability set rs
low level net
rg h pn
markings in rs
level net for
t is enabled
number of regions
of the reachability
non trivial regions
the complete rg
of p invariants
zz n m
by p invariants
of rs h
of markings in
covered by p
of the ln
low level nets
in rs h
hierarchically generated reachability
m 2 rs
rs j x
of rs and
the initial marking
p 2 p
extended net n
set rs j
size of rs
the extended net
the hierarchically generated
size of rgs
net for a
t out r
the incidence matrix
rg can be
a macro marking
subset of transitions
reachability sets and
place p 2
of the pn
local transitions in
rs pn and
rs hn and
a p invariant
net n s
of aggregated places
macro marking of
of transitions in
level net and
covered by positive
representation of rs
behavior preserving reduction
the number of
the production cell
enabled in marking
of reachable markings
number of aggregated
state space generation
compact representation of
number of non
of non trivial
the size of
for a pn
of generate structured
g rs j
for the hn
rg generation is
hierarchical reachability graph
that the reachability
2 lt j
representation of rg
of tokens on
marking m 0
of rs j
n r1 n
an aggregated place
kronecker representation of
place bordered subnets
t 2 lt
on the places
in the hn
of an aggregated
and reachability graph
generate and represent
set and reachability
reachability graph of
aggregated description of
2 rs pn
the effort for
reachability graph generation
of ln j
the aggregated description
marking of ln
and possible transitions
markings and possible
enabled in m
extended low level
and the reachability
rs pn s
generation of rs
the complete reachability
the hn marking
projection of rs
the complete net
reachability analysis can
markings which are
all successor markings
q h t
ln j and
of a pn
when the marking
a compact representation
of the net
reachable markings and
in a compositional
net for the
transitions between markings
transition t is
c or d
of places and
6 do remove
reachability set of
a transition t
transition t 2
methods for efficient
induction step we
reachability sets of
analysis of large
n 0 r
st st st
effect of transitions
transitions t 2
a place p
is covered by
be applied for
stochastic petri nets
number of places
in a j
a very compact
an integer vector
for a transition
only a subset
for a region
the running example
are denoted as
to generate and
the hierarchical representation
of petri nets
our running example
in the subset
a petri net
has to be
b is defined
set of transitions
is an extended
transitions in the
a non trivial
a j and
for the generation
the dynamic behavior
set of output
of a j
have to be
dynamic behavior of
the two level
transitions of the
i l j
a n theta
for the induction
a sequence s
the induction step
of non zero
for the efficient
w r t
approach can be
a subset of
a set of
the set of
computed from the
the generation of
characterize rs the
theory for coloured
places p1 gamma

corpus/krapavin2000-test/607620.txt
kernel
gsk
lsk
documents
svm
document
reuters
lsi
corpus
semantic
training
baseline
text
generalised
vsm
feature
latent
classifier
864
learning
matrix
gram
generalisation
retrieval
kernels
dimensionality
categorization
medline1033
alch
846
margin
eigenvalue
conducting
buc
acq
inner
bvsm
wheat
gvsm
siolas
category
money
schmidt
f1
regression
dimension
ionosphere
joachims
micro
datasets
products
bag
dimensions
crude
singular
query23
modeapte
earn
eigenvalues
pca
indexed
gaussian
classification
similarity
752
medline
svd
averaged
co
decomposition
bias
indexing
ridge
grain
eigenvectors
norm
vectors
spaces
polynomial
informative
ship
soft
rank
fx
splits
query20
orthogonalisation
yaoyong
kermit
reuters21578
9603
hypernym
newfeat
tfidf
feat
corn
ff
experiments
categories
500
rise
diagonal
vector
multilingual
3299
wordnet
husband
spouse
kms
equalization
machines
word
principal
projection
entries
ir
synonymous
wife
815
shawe
855
statistical
565
748
756
punctuation
857
features
learnt
mapped
incorporating
occurrence
mapping
correlations
metric
proximity
conducted
onto
reminiscent
corpora
improvements
extraction
sparse
split
frequency
recipes
nr
sv
lewis
approaching
preprocessed
impressive
ordinal
dual
extract
trade
relevant
tuned
subspace
orthogonal
approximation
substantial
extracting
fed
classifiers
1000
weight
demonstrate
sought
dictionary
conjunctions
extracts
avg
external
2pr
krieging
grauman
25431
hff
2877
maillet
eigensubspaces
gvsms
satarupa
zilan
haixian
smola
generalistion
solias
spi
kevyn
21578
isometrically
neurocolt2
97dimension
kristen
pun
recode
remultiplying
dulong
feature space
the feature
gsk algorithm
an svm
svm with
the lsk
a kernel
kernel matrix
the kernel
latent semantic
svm classifier
the corpus
linear kernel
semantic kernel
the gsk
864 0
0 864
kernel for
baseline method
support vector
relevant documents
the documents
generalisation performance
document matrix
lsk and
vector space
space model
inner products
the baseline
the gram
information retrieval
gsk lsk
of svm
eigenvalue decomposition
with gsk
text categorization
by document
for text
vector machines
term by
generalised version
kernel k
a document
documents in
baseline figure
money fx
f1 numbers
co occurrence
by conducting
a semantic
the generalised
gram matrix
the polynomial
gram schmidt
classifier with
text data
semantic indexing
alch e
the vsm
term term
non text
products between
vsm matrix
d alch
kernel defined
e buc
generalised gsk
0 846
basic vector
defined feature
gsk is
reduced feature
kernel methods
training set
the document
experiments on
matrix p
statistical learning
of documents
kernel function
semantic information
indexed by
documents are
first k
siolas and
lsk step
term similarity
new kernel
846 2
the lsi
reuters categories
some datasets
polynomial mapping
semantic network
low rank
two documents
feature spaces
we selected
the training
text classification
dimensionality of
bag of
averaged f1
rank approximation
th feature
kernel based
micro averaged
dimension of
the dimension
the matrix
and linear
feature vector
of experiments
a generalised
ridge regression
a feature
documents that
matrix d
test set
of dimensions
the dimensionality
inner product
each document
optimal value
document is
the latent
documents by
documents into
the term
semantic proximity
ionosphere data
of gsk
buc 23
k training
cross language
conducting preliminary
the gvsm
any kernel
0 752
a svm
gaussian construction
752 0
the reuters
in intervals
on reuters
joachims 10
same documents
conducting experiments
polynomial kernel
indexing lsi
lsk method
similarity matrix
reuters and
occurrence information
and svm
end for
by term
a training
results demonstrate
e ff
the semantic
representation is
training data
of words
t do
vector d
j th
semantic kernels
splits of
soft margin
different terms
kernel that
enough positive
feature map
co occur
documents we
matrix is
machine learning
a vector
set we
documents the
term matrix
component analysis
approximation strategy
new space
original feature
gaussian kernel
on text
document it
100 random
preliminary experiments
performance of
these results
onto the
demonstrate that
singular value
space in
vector machine
categorization with
document by
the feature space
the baseline method
0 864 0
generalisation performance of
the gsk algorithm
vector space model
in the feature
with gsk lsk
svm with gsk
performance of svm
linear kernel for
by document matrix
gsk lsk and
of svm with
lsk and linear
in the corpus
the term by
generalised version of
the kernel matrix
term by document
and linear kernel
svm classifier with
support vector machines
a feature space
latent semantic indexing
documents in the
an svm classifier
reduced feature space
d alch e
an svm with
alch e buc
a semantic kernel
a semantic network
defined feature space
basic vector space
kernel defined feature
and d alch
the gram matrix
of the feature
the first k
feature space in
for text categorization
the new kernel
as the j
inner products between
the polynomial mapping
a kernel k
the generalised version
to t do
siolas and d
of the gsk
generalised gsk algorithm
non text data
0 846 2
micro averaged f1
the vsm matrix
the basic vector
th feature of
feature space we
to the baseline
dimension of the
number of dimensions
low rank approximation
onto the first
the latent semantic
j th feature
bag of words
in a feature
the dimension of
the dimensionality of
value of c
the documents are
of the kernel
results demonstrate that
the j th
by conducting preliminary
semantic indexing lsi
the lsk step
with a semantic
by term matrix
864 0 752
of the lsk
eigenvalue decomposition of
we selected randomly
the eigenvalue decomposition
experiments on one
f1 numbers for
a svm classifier
conducting experiments on
the lsk method
e buc 23
a generalised version
vsm matrix p
the polynomial or
version of gsk
the reduced feature
with linear kernel
conducting preliminary experiments
original feature space
joachims 10 and
of an svm
0 752 0
of gsk algorithm
co occurrence information
the same documents
by conducting experiments
term similarity matrix
set of experiments
demonstrate that the
of the term
a document is
number of documents
j as the
into a new
term by term
space model for
documents into a
the document by
feature space of
statistical learning theory
of inner products
results are averaged
projection onto the
the inner products
relevant documents in
in information retrieval
in the kernel
singular vectors of
to the kernel
the original feature
document is represented
inner product between
a new example
text categorization with
feature space the
of the corpus
a singular value
the norm of
optimal value of
rise to the
for each category
do end for
a vector is
are averaged over
space in order
for text classification
split of the
feature space and
support vector machine
the proposed method
dimensionality of the
the training set
the parameter c
these results show
the optimal value
training set and
often in the
indexed by the
the feature vector
we focused on
gives rise to
comparable to the
to n do
data set we
of these experiments
an inner product
averaged over 100
svm with linear
on some datasets
view the lsk
set and test
acq money fx
by placing more
the documents into
yaoyong li john
feature extraction process
set we selected
indexing lsi 4
return feat i
polynomial or gaussian
gsk algorithm this
term term correlations
the generalised gsk
ff which satisfies
husband and wife
and svm classifier
756 0 846
retrieval using the
the new feature
feat i j
data matrix d
text and non
k training set
matrix d the
748 0 846
towards relevant documents
documents that share
on a semantic
approximate dimension equalization
latent semantic kernel

corpus/krapavin2000-test/607623.txt
hmm
documents
training
page
missionary
pages
classifier
emission
text
hmms
xt
categorization
american
scribners
monthly
bayesian
markov
category
bayes
em
dataset
document
dt
learning
isolated
naive
hidden
articles
ocr
frasconi
ck
emissions
classifiers
year
unlabeled
eq
transition
classification
realizations
categories
rabiner
moa
labeled
xi
1884
nigam
ergodic
bag
ct
trained
contextual
heckerman
datasets
grammar
jensen
magazine
mccallum
sequences
accuracy
sequential
baum
journals
crawling
word
d1
nb
merging
x1
stochastic
welch
1989
editorial
overfitting
contents
topology
america
xt1
indians
charniak
1871
ten
cj
independence
belief
eqs
books
extracted
1997
probabilistic
transductive
xix
diligenti
selection
pertains
portals
cultural
extraction
feature
percentages
inference
labels
retrieval
networks
outperforms
surveys
article
evidence
home
1996
conditional
pearl
saturate
cornell
temporally
collapses
classifying
michigan
likelihood
labeling
transitions
maximization
libraries
century
unseen
boundaries
induction
recognition
xn
generative
occurrences
2000
hierarchically
society
ci
automating
graphically
dictionary
counts
probabilities
1988
moaxmlfilessuppliedwiththedocumentscollections
estimationofemissionparametersinthiscasewouldbeaccomplished
althoughissuesofscribnersmonthly
20021
enriches
trash
6035
kalt
undoubt
americans
typeset
obtainedfrom12trainingissues
scrib
founders
preface
asociated
1893
typesetting
hyphenated
bengio
3222
afurtherdirectionofinvestigationisthereforerelatedtothedevelopment
inhypertextsbyextendingthearchitecturedescribedinthispaperisstillanopenproblem
edly
byreplacingcounts
stepisperformedinthestandardwayfortransitionparameters
hypertexts
magazines
theassignedcategorieswerethen
bicknese
afro
poems
dedication
misspelledwords
dor
childhood
thegeneralcaseofdirectedgraphsisdifficultbecauseofthepresenceofcycles
1870
deservesattention
blumson
tales
toc
passerini
metae
year1871
exceptforthefeatureselectionprocessdescribedinsection4
nonexistent
lucke
trainingset
estimation
performances
speech
parsing
convenient
gain
plausible
focused
biased
variability
internet
the hmm
american missionary
naive bayes
hidden markov
text categorization
feature selection
multi page
markov models
scribners monthly
bayesian networks
the american
isolated page
labeled documents
the training
page classification
bayes classifier
hmm topology
page documents
frasconi et
training set
the em
text classification
p dt
hmm is
unlabeled documents
the emission
sequential classifier
emission parameters
missionary dataset
the naive
em algorithm
al 2000
of pages
for text
the category
jensen 1996
an hmm
pages of
for training
contextual information
of labeled
page classifier
rabiner 1989
induced hmm
state realizations
page categories
journal issues
hmm states
bag of
the isolated
heckerman 1997
nigam et
page of
the sequential
of text
bayesian network
training sequences
the page
the dataset
pages in
documents using
classification using
the document
page category
page labels
text pages
emission model
emissions are
d1 dt
average accuracy
page boundaries
w ck
xi x
model induction
ocr text
of hmms
transition structure
the baum
labeled pages
the scribners
year 1884
and unlabeled
et al
training and
vector machines
categories are
the ten
a page
of words
topology for
training documents
page t
of america
baum welch
transition graph
from labeled
focused crawling
making of
remaining issues
of word
machine learning
the making
dt is
information gain
labeled and
structure learning
networks for
and retrieval
accuracy is
the journal
documents in
two datasets
the observed
belief networks
a document
classification accuracy
in eq
outperforms the
classification and
category is
markov model
of class
eq 6
the transition
support vector
isolated pages
mccallum et
account contextual
internet portals
biased by
training text
ergodic hmm
extends over
hmm outperforms
models feature
some pages
the xix
merging collapses
selection text
p ck
are bag
hmm architecture
hmm transition
eqs 11
occurring less
ten categories
transductive inference
in jensen
observed sequence
missionary the
p xt
portals with
transition distribution
of hmm
were pruned
hmms have
traditional isolated
pearl 1988
whose emissions
monthly dataset
reached note
hierarchically classifying
extracted grammar
ck is
hmm with
conditional word
in nigam
isolated vs
hmm classifier
process pertains
ten states
state xi
ck w
as ct
class ck
charniak 1993
article 2
grammar extraction
page sequences
using em
partially labeled
transition parameters
on isolated
collapses two
for focused
model merging
by bayesian
name description
data induced
emission distribution
sequential classification
given xt
classifier that
state evidence
multiple states
induction by
sequential organization
word w
digital libraries
dataset is
the american missionary
hidden markov models
the naive bayes
naive bayes classifier
frasconi et al
the training set
in the training
the em algorithm
multi page documents
the sequential classifier
american missionary dataset
et al 2000
bag of words
hmm topology for
induced hmm topology
a page of
nigam et al
for text categorization
while the hmm
xi x j
on the american
of labeled documents
making of america
labeled and unlabeled
isolated page classification
classification and retrieval
isolated page classifier
for multi page
and unlabeled documents
an hmm is
the average accuracy
of the hmm
the isolated page
of labeled pages
the scribners monthly
sequence of pages
the baum welch
from labeled and
text classification and
of word w
pages of the
the making of
bayesian networks for
feature selection is
may be convenient
for text classification
feature selection in
support vector machines
page in the
pages in the
in the document
the case of
be convenient to
process pertains to
a new probabilistic
sequential page classification
in jensen 1996
eqs 11 15
of digital libraries
hmm outperforms the
w in pages
into account contextual
whose emissions are
documents using very
account contextual information
of text classification
the information gain
is reached note
text classification from
the ten categories
bayesian model merging
for training text
reached note that
models feature selection
markov model induction
in the american
the structure learning
with partially labeled
classification from labeled
is biased by
occurring less than
by bayesian model
domain name description
data induced hmm
page classification on
p xi x
of internet portals
vs sequential page
of class ck
structure learning algorithm
american missionary the
merging collapses two
feature selection text
hierarchically classifying documents
information gain criterion
training text classifiers
are bag of
ocr text pages
the sequential organization
be responsible of
in both datasets
methods for focused
hmm with ten
the two datasets
within the sequence
observed sequence of
percentages of labeled
ck is the
unlabeled documents using
evaluation methods for
prediction is biased
collapses two states
conditional word independence
inference and learning
scribners monthly dataset
very few words
pages the hmm
model of text
numbers in each
at page t
x if they
on isolated pages
induction by bayesian
contextual information into
hmms have been
word w in
the observed sequence
two states x
to improve accuracy
of induced hmm
documents using em
traditional isolated page
states x and
training set each
outperforms the isolated
labeled pages the
automating the construction
internet portals with
algorithm for training
new probabilistic model
example of induced
sequential organization of
partially labeled documents
error rate reduction
the hmm is
construction of internet
percentage of labeled
the remaining issues
the emission model
words occurring less
transductive inference for
with machine learning
mccallum et al
portals with machine
class ck and
the parameters using
model induction by
within a document
occurrences of word
with ten states
learning algorithm presented
isolated vs sequential
for the hmm
inference for text
second dataset is
text classification using
sequential algorithm for
p ck w
in nigam et
classifying documents using
w ck is
n w ck
for focused crawling
pages of class
labeled with the
in the case
few words a
using very few
task consists of
probabilistic independence networks
each node correspond
and x if
hidden markov probability
the available training
page of class
the sum on
classification using support
obtained from eq
category is known
and retrieval a
independence networks for
the category is
markov probability models
based mapping method
an example based
by the em
the e step
during the state
belief networks as
using support vector

corpus/krapavin2000-test/607624.txt
hoovers
foil
hypertext
classication
knn
classiers
linked
pages
regularity
univ
competitor
classier
tagged
document
web
nb
documents
categorization
regularities
text
meta
hyperlinks
datasets
hyperlink
names
microavg
encyclopedia
page
preclassied
255
corpus
micro
category
averaged
webkb
precision
vocabulary
bayes
title
links
dataset
learning
company
scores
html
naive
training
macro
referencing
categories
jungyun
macroavg
youngjoong
chakrabarti
competitors
seo
score
patents
baseline
thresholding
suered
ko
representations
classification
cristo
tags
hyperlinked
classied
anchor
companies
sites
informative
curves
mining
dierent
corpora
patent
marcos
gonalves
articles
co
kernels
classifying
univ6
furnkranz
words0
topic
neighboring
joachims
yahoo
relational
elds
crawler
reinforce
oh
exploiting
avg
neighbors
rich
pvel
svms
citations
calado
examinations
extracted
content
faculty
home
learner
break
link
noisy
ribeiro
sigir
classi
extraction
treating
10000
label
classifiers
tasks
feature
nd
selection
retrieval
identiers
hoovers28
yiming
4285
evgeniy
jinwoo
kisiel
ziviani
multistrategy
only0
nivio
homework
gabrilovich
getoor
sication
hoovers255
aixin
denoyer
categorisation
brunessaux
marco
clas
predictive
20000
management
linguistics
orleans
eective
weighting
improving
neighborhood
topically
moura
25000
ludovic
shaul
gallinari
edleno
tagging
markovitch
dened
words
hypotheses
word
ve
hill
candidate
decisions
domains
taipei
conned
2550
sources
peng
automated
site
8000
6000
specic
zhang
comparative
cosine
degradation
neto
baselines
linkage
berthier
conventional
exible
signicantly
yielded
online
trade
4000
labels
univ 6
tagged words
linked words
competitor names
the hoovers
meta data
linked names
hypertext classication
text categorization
web pages
hoovers datasets
hoovers 255
nb knn
page only
knn and
hoovers 28
on univ
the linked
on hoovers
co referencing
naive bayes
feature selection
and knn
classication tasks
hypertext regularities
micro averaged
the web
classiers on
our classiers
referencing regularity
macro averaged
only linked
this regularity
the words
linked pages
words tagged
test document
the webkb
text classication
linked documents
hypertext categorization
for text
web page
for hypertext
with nb
the classication
encyclopedia regularity
even line
knn foil
a classier
title meta
in hypertext
words from
words in
break even
and foil
nb and
web sites
categorization using
each classier
youngjoong ko
chakrabarti et
meta linked
words title
preclassied regularity
names foil
foil on
data regularity
jungyun seo
microavg number
names score
recall knn
vocabulary sizes
names break
of hypertext
classification proceedings
recall precision
same class
the document
category labels
that document
of linked
f 1
the baseline
each document
the hypertext
classication performance
and macro
partial co
neighboring documents
candidate categories
three classiers
category distributions
6 dataset
local words
regularity we
recall and
management an
text classification
regularities in
class label
class a
the classiers
document classification
training documents
a hypertext
the univ
selected features
and precision
the text
the links
n a
to documents
used with
words and
names nb
ko jungyun
averaged f
webkb university
regularity use
knn competitor
links per
nb competitor
linked neighbors
html title
the encyclopedia
for foil
and tagged
company web
marco cristo
classication problems
foil competitor
classication decisions
html meta
university corpus
using hyperlink
thresholding strategies
hyperlinks and
linked neighborhood
features foil
rich information
the knn
using web
names competitor
foil is
and hoovers
words linked
this dataset
a document
and management
of selected
words on
and nb
information extraction
an international
conference on
documents in
oh et
the competitor
of classiers
regularity if
averaged and
of categories
proceedings of
of meta
document d
the category
when using
each representation
those pages
for nb
between pages
information processing
documents of
a study
of web
the pages
trade o
words instead
document as
and meta
processing and
journal v
the documents
for web
the names
each test
of exploiting
text of
from linked
local text
per company
same topic
ibm patents
the patent
foil linked
being classied
conventional text
classication scheme
joachims et
on univ 6
the hoovers datasets
on the hoovers
only linked words
co referencing regularity
used with nb
nb and knn
linked words tagged
with nb knn
break even line
words tagged words
nb knn foil
words title meta
meta data regularity
tagged words title
knn and foil
names break even
title meta linked
microavg number of
meta linked names
chakrabarti et al
classification proceedings of
the same class
words in the
of selected features
number of selected
information processing and
processing and management
and management an
management an international
recall and precision
proceedings of the
univ 6 dataset
knn and nb
the words from
partial co referencing
the univ 6
of the linked
knn foil on
nb knn and
all the classiers
page only linked
for the hoovers
foil on hoovers
classiers on univ
of web pages
in the linked
all the links
from the web
the words in
and meta data
for text classification
all the documents
for text categorization
micro averaged and
names foil competitor
ko jungyun seo
averaged and macro
28 and hoovers
selected features foil
hoovers 28 and
competitor names score
and tagged words
and macro averaged
of meta data
linked names competitor
competitor names nb
classiers on hoovers
webkb university corpus
youngjoong ko jungyun
hypertext categorization using
names competitor names
precision and f
names nb competitor
tagged words instead
recall precision and
the linked documents
the webkb university
nb competitor names
performance of classiers
averaged f 1
competitor names foil
foil competitor names
on hoovers 255
recall knn competitor
document classification proceedings
the candidate categories
knn competitor names
and hoovers 255
competitor names break
hypertext classication tasks
an international journal
all the three
international journal v
and f 1
words from the
text categorization using
oh et al
in a hypertext
the text of
international conference on
of class a
f 1 values
the web pages
words instead of
results for each
for each test
the f 1
on that document
recall precision trade
of the hoovers
a test document
0 n a
of a classier
tagged words the
on hoovers 28
the total pages
the linked words
links per page
the linked neighborhood
of page only
documents neighboring class
of this regularity
the three classiers
precision microavg recall
the baseline performance
words from linked
microavg recall knn
learning to classify
text categorization proceedings
precision macroavg recall
company web sites
linked words and
for our classiers
using tagged words
for each classier
each test document
neighboring class a
macroavg recall knn
page used with
both knn and
6 5 of
regularity use the
regularity if the
the competitor information
related web sites
local words in
to reinforce the
precision trade o
representations for hypertext
micro averaged f
categorization proceedings of
class a documents
of hypertext regularities
microavg precision microavg
on the univ
from related web
thresholding strategies for
test document to
macroavg precision macroavg
joachims et al
n t d
strategies for text
foil with the
conventional text categorization
meta data in
web page used
hoovers 255 and
the encyclopedia regularity
category distributions for
information extraction techniques
composite kernels for
the patent database
of training documents
data regularity use
5 meta data
the same topic
the web page
on the web
a n a
n a n
share the same
for all the
a study of
as if they
classification information processing
journal v 40
links between pages
each document as
the observed performance
the target page
web pages and
for all three
text categorization with
50 70 90
sigir conference on
feature selection for
words on the
conference on research
a web page

corpus/krapavin2000-test/607698.txt
semicontinuous
lters
sat
monasse
lter
hole
caselles
morphological
grain
jsat
cc
ir
holes
connected
continua
morphology
n2in
selfdual
jhj
extrema
compact
nonincreasing
proposition
closed
continuum
proves
image
levelings
shapes
operators
open
ker
ltered
dual
topographic
denition
invariance
idempotent
dened
union
nondecreasing
jcc
meets
internal
family
lindelof
grains
operator
inclusion
self
neighborhood
serra
equality
filters
continuous
sup
maxima
nite
intersection
jcj
dene
thanks
commute
lemma
keshet
joj
attenings
heijmans
masnou
unicoherent
satc
zoretti
rst
insu
dierent
deduce
subsequence
filter
structuring
cient
shall
contradicting
resp
additively
5a
inf
00
contradicts
nested
connectedness
removes
monotonicity
su
families
minima
mathematical
tu
renato
disjoint
jdj
commutes
scarce
complement
acting
fk
consequence
meyer
symmetrically
62
monotone
conversely
multiscale
ne
nonempty
map
denitions
driven
claim
contours
acts
invariant
decreasing
xg
satises
ju
fx
jg
corollary
0962
pnpgc
0234
curvu
0be
watersheds
nnn
idempotency
c02
2ir
g30u
nestedness
pics
semicontinuity
jsatcj
g3u
mathematicae
guichard
morphologicae
bfm2000
y2b
jsataj
mwhich
monasse11202
salembier
saturation
regional
segmentation
images
pruned
uniformly
observe
texture
morel
semilattice
homeomorphism
voluntarily
c2c
n2n
cosity
senses
saturations
ct98
semilattices
stressing
cardinal
ator
jo
indierently
fmrx
carpet
tree
conclude
preserving
implying
innite
contradiction
shape
criterion
pruning
additivity
underlines
436
bunch
ages
b2b
homeomorphic
lim
external
concerning
contrast
stretches
upper semicontinuous
level sets
connected components
caselles and
v caselles
p monasse
hole of
internal hole
a connected
have that
self dual
extrema lters
semicontinuous functions
hole h
of connected
connected component
internal holes
holes of
semicontinuous function
k n
of u
open sets
components of
mathematical morphology
connected operators
sat x
cc x
a hole
is some
is open
compact sets
x 2
the connected
the grain
u is
sat k
2 ir
open and
grain lter
contrast change
of continua
k 0
that u
proves that
c n
continuous functions
sat c
union of
let u
if u
the family
that sat
sat a
h n
that x
cc o
jsat c
connected operator
n n2in
this proves
connected and
lower level
a continuum
of c
is connected
h 0
this equality
some n
m u
y 2
of open
the extrema
u 00
set operator
on upper
and p
of k
family of
conclude that
c j
we conclude
n2in is
morphological lter
nonincreasing sequence
side term
being open
topographic map
structuring elements
these lters
a morphological
2 sat
of level
closed set
k y
increasing and
of y
the denition
compact set
may write
we may
is increasing
x we
any n
a nonincreasing
on connected
connected neighborhood
observe that
we get
are nested
ir n
o n
prove that
n 0
open set
h of
closed sets
some g
we observe
we deduce
that g
of upper
may assume
u be
an open
function u
denition of
2 h
c l
thanks to
direct consequence
of ir
invariance properties
u n
m 0
semicontinuous on
or disjoint
nested or
m uniformly
lter on
grain operators
cient measure
change g
connected sets
lindelof s
external hole
sat b
the lters
contrast invariance
lower semicontinuous
lters and
image u
other inclusion
the topographic
also open
grain criterion
monasse we
morphology and
level set
jcc u
lter t
meets some
g k
for any
a compact
that m
is idempotent
deduce that
u y
all n
shapes of
u a
is upper
u x
component of
thus x
x 62
to upper
3 u
2 g
upper and
we shall
a union
and self
y n
closed in
on compact
equality to
with upper
of insu
given 0
write we
2 ker
n since
since g
that v
be such
uniformly in
the intersection
any x
neighborhood of
connected components of
caselles and p
v caselles and
and p monasse
lower level sets
a connected component
internal hole of
there is some
we have that
the connected components
upper semicontinuous function
upper semicontinuous functions
that x 2
hole h of
hole of c
an upper semicontinuous
level sets of
is open and
hole of k
internal holes of
we conclude that
of open sets
connected component of
in a hole
and lower level
of level sets
neighborhood of y
a hole h
is some n
the extrema lters
union of open
of connected components
the family of
the tree of
a hole of
for any n
this proves that
u be an
x 2 g
a compact set
of k 0
be an upper
if u is
nonincreasing sequence of
semicontinuous function and
components of level
increasing and self
jsat c j
on upper semicontinuous
shapes of u
hand side term
of connected operators
is upper semicontinuous
sequence of continua
a nonincreasing sequence
sat k n
components of upper
on connected components
to upper semicontinuous
any 2 ir
is a continuum
of internal holes
family of connected
the grain lter
components of k
some n such
n n2in is
a connected operator
we may write
is a connected
an open set
we deduce that
m u is
u is continuous
that y 2
and self dual
of this equality
may assume that
we observe that
we may assume
implies that u
let u be
is connected and
is an open
a direct consequence
is a basis
a union of
be such that
a morphological lter
holes of x
y 2 h
mathematical morphology and
on continuous functions
is a nonincreasing
u is upper
p monasse we
level sets in
an internal hole
sequence of compact
nested or disjoint
is lower semicontinuous
f b is
contrast change g
topographic map of
family of internal
the other inclusion
components of u
proves that and
holes of c
with upper and
x 2 sat
cc o x
of compact sets
the topographic map
that the connected
g k n
lindelof s theorem
of upper level
whose associated set
sat k 0
upper level sets
that v caselles
such that u
upper and lower
is a compact
n n 2
the union of
the denition of
we would have
a basis of
open or closed
connected neighborhood of
b we get
on compact sets
thanks to lemma
of insu cient
to continuous functions
proof let u
direct consequence of
is self dual
h of c
will be su
a closed set
we get that
x 2 d
x we denote
its connected components
shall prove that
this implies that
n such that
such that x
as the intersection
x 2 c
we shall prove
for all n
be su cient
be a connected
as a union
that and thus
sets of a
we prove that
intersection of a
as the union
proof we have
0 such that
we denote by
we dene the
for any 2
of them has
the set u
n n 0
is a closed
the right hand
and m 0
the shapes of
written as the
0 and we
and 2 ir
l l 2
have that either
a connected neighborhood
sat a is
union of c
conclude that y
of a subsequence
using corollary 1
invariance properties are
holes of k
write we claim
it meets some
h n we
is idempotent proof
semicontinuous on compact
that u c
a contrast change
the connectedness of
that m closed
u 00 and
d g b
connected and meets

corpus/krapavin2000-test/607707.txt
watanabe
singularities
learning
eq
asymptotic
neural
pole
bayesian
amari
blowing
identifiable
perceptron
stochastic
2001a
kullback
expansion
dw
layered
parametric
statistical
algebraic
samples
analytic
density
poles
1999b
shun
murata
geometrical
generalization
units
ciently
likelihood
exp
estimation
training
regression
neighborhood
clarify
ichi
priori
dxdy
opper
sumio
su
artificial
hidden
layer
resolution
hierarchical
ups
aic
hironaka
haussler
machines
fisher
ect
ozeki
1974
mixtures
curves
nh
inequality
meromorphic
zeta
unrealizable
fukumizu
atiyah
solla
tomoko
geometry
regular
nk
compact
singular
jw
inequalities
bias
trained
foregoing
entropic
sato
tishby
bic
largest
contained
mellin
conic
minimizes
probability
networks
variance
posteriori
gaussian
akaike
perceptrons
mackay
error
firstly
asymptotics
universal
1993
satisfies
clarified
boltzmann
mathematically
definite
analytically
proven
levin
schwarz
algorithmically
mathematical
continued
realizable
1995
extensively
1970
manifolds
1985
wavelets
rational
statistics
secondly
radial
1980
1992
curve
jensen
1989
log
jacobian
degenerate
miki
dacunha
cousseau
hiroyuki
nakahara
combing
keisuke
1013
castelle
neuromanifolds
hyperfunctions
shinomoto
abic
aoyagi
prehomogeneous
gassiat
2001c
identifiablity
reys
hyperparatemeter
prespective
kashiwara
holomorphic
paramaters
hyeyoung
perceptorn
merhav
1949
rissanen
yamazaki
haikun
estimator
mixture
conditional
calculation
rank
1990
cramer
ork
2001b
donsker
hagiwara
hartigan
florent
identifiability
1007
machine
adopt
fujita
homogenous
933
shintani
1065
ror
pth
1038
843
1999a
924
subsection
speaking
interpolation
inference
empirical
1033
chui
yamanishi
asymptotic expansion
generalization error
stochastic complexity
hierarchical learning
learning machines
the true
learning machine
bayesian estimation
regular statistical
h w
f n
the generalization
the parameter
j z
three layer
true distribution
probability density
g n
an asymptotic
the stochastic
true probability
parameter space
the bayesian
y x
hidden units
x w
neural networks
largest pole
p y
w j
training samples
parameter w
artificial neural
layer perceptron
n has
watanabe 2001a
algebraic geometrical
w dw
singularities in
learning curves
assumption a
of singularities
analytic function
the learning
parametric case
kullback information
non identifiable
by eq
distribution is
density function
su ciently
the kullback
w is
pole of
priori distribution
regression function
algebraic geometry
1999b watanabe
true regression
watanabe 1999b
error g
q x
the parametric
w 0
not contained
the asymptotic
w w
blowing up
an analytic
neural computation
ciently large
q y
statistical model
g u
of learning
of w
blowing ups
extensively large
shun ichi
independently taken
ichi amari
priori probability
a priori
statistical models
of training
parametric model
neighborhood of
compact then
eq 30
and eq
contained in
the a
v t
of parameters
clarify the
learning theory
case when
perceptron with
of layered
error by
probability distribution
z has
neural network
w z
exp 2
has an
if g
samples independently
information matrix
analytically continued
2001a in
kullback distance
sumio watanabe
exp nh
algebraic variety
asymptotic property
x dxdy
complexity f
a three
an inequality
estimation is
statistical estimation
that minimizes
units and
maximum likelihood
the neighborhood
learning in
an algebraic
z w
error of
fisher information
its order
pole and
units k
eq 18
singularities and
geometrical structure
poles of
asymptotic theory
the largest
n w
of j
singular points
likelihood method
the fisher
layered neural
resolution theorem
the singularities
using samples
n satisfies
a parametric
parameter that
resolution of
n is
natural number
nk 2
the pole
in algebraic
parametric models
learning curve
x q
w and
g x
bounds of
expansion of
e ect
approximation error
function j
input units
dimensional vectors
trained using
likelihood function
output units
the assumption
conditional probability
a universal
if n
learning model
eq 19
function approximation
bias and
ciently small
then g
a su
an arbitrary
w then
log p
expansion for
log n
computation v
firstly we
function of
previous paper
1992 amari
eq 35
samples watanabe
true parameters
far smaller
levin tishby
and unrealizable
the generalization error
the stochastic complexity
an asymptotic expansion
p y x
has an asymptotic
y x w
n has an
the true distribution
the parameter space
three layer perceptron
true distribution is
hierarchical learning machines
when the true
the true probability
g n has
a three layer
the largest pole
of training samples
in the parametric
artificial neural networks
probability density function
the kullback information
hierarchical learning machine
regular statistical models
of j z
the a priori
of the stochastic
of the generalization
the learning machine
a priori distribution
if g n
contained in the
h w is
regular statistical model
the true regression
the bayesian estimation
h w z
generalization error by
true regression function
a regular statistical
an analytic function
bayesian estimation is
watanabe 1999b watanabe
resolution of singularities
true probability distribution
q y x
generalization error g
the assumption a
the asymptotic expansion
error g n
parameter w j
su ciently large
of the parameter
case when the
the parameter w
in the parameter
is not contained
not contained in
number of training
asymptotic expansion of
on the parameter
g n is
a priori probability
hidden units and
function of w
priori probability density
z w dw
the parametric model
of singularities in
parameter that minimizes
a hierarchical learning
parametric case when
support of w
f n has
1999b watanabe 2001a
then g n
true probability density
y x q
the parameter that
shun ichi amari
layer perceptron with
of learning curves
conditional probability density
w z w
the maximum likelihood
generalization error of
that the generalization
for an arbitrary
that the true
error of the
extensively large then
log p y
algebraic geometrical structure
the parametric models
of hierarchical learning
a case when
poles of j
asymptotic expansion for
by eq 18
eq 18 and
samples independently taken
a parameter w
the three layer
non parametric case
complexity f n
18 and eq
geometrical structure of
asymptotic property of
and its order
end of proof
respectively the largest
the regular statistical
function j z
function approximation error
learning machine is
pole and its
q x dxdy
perceptron with k
19 is trained
independently taken from
trained using samples
w w dw
and eq 19
an algebraic variety
analytic function of
using samples independently
a parametric case
watanabe 2001a in
x w be
stochastic complexity f
h w and
then j z
eq 19 is
the algebraic geometrical
largest pole and
number of parameters
is defined by
distribution is not
of w is
neighborhood of the
w is a
neural computation v
f n is
the neighborhood of
upper bounds of
the pole of
density function on
error by the
v w j
the previous paper
regression function is
if the support
in algebraic geometry
layered neural networks
maximum likelihood method
generalization error is
singularities in the
natural number n
x q x
the learning curve
is an analytic
if the true
ciently large n
then f n
is trained using
0 is a
function on the
q x is
w w 0
w j are
w be a
n is equal
a non parametric
w j and
su ciently small
f n and
of f n
and m 1
is a positive
of a hierarchical
by the assumption
and f n
given by eq
probability distribution is
the support of
w is an
to clarify the
e ect of
it is well
we consider a
the model is
w is the
in practical applications
a su ciently
up technology in
distribution is contained
geometrical method we
on learning curves
arbitrary natural number
is to clarify

corpus/krapavin2000-test/607896.txt
evolutionary
wcet
sa
timing
categorizations
cache
fitness
generations
instruction
analyzer
caches
bcet
individuals
longest
population
testing
mutation
cycles
recombination
schedulability
loop
reinsertion
bubblesort
temporal
shortest
static
caching
loops
extreme
defense
mueller
hit
offspring
miss
execution
associativity
flow
predictions
railroad
gnat
kiran
preemptive
hardware
instructions
worst
sigma10
trio
portability
loc
calculator
misses
calling
frank
permissible
chapter
simulator
deadlines
compiler
estimates
calculated
references
conflicts
systematic
matrices
stopping
seth
correctness
reproduction
uncached
benz
rotenberg
4095
daimler
kaustubh
aravindh
22626
8095
anantaraman
instrumentation
genetic
gcc
electronics
datum
regard
risc
pipeline
harman
crossover
yifan
ipx
389
insufficiently
dfa
843
cles
patil
848
iterations
cy
multitude
619
program
cached
processor
prediction
afterwards
paths
optima
toolbox
cycle
generation
portable
confidence
software
assuring
edf
tighter
multiplication
examination
inner
simulation
safe
procedures
graphics
child
analytical
programs
matlab
recommend
executing
et
tester
coverage
logical
interrupt
quantify
thoroughly
overhead
fit
categorization
309
embedded
stopped
adjustments
optimum
timed
zhu
measurements
outer
diversity
pipelining
parents
header
procedural
nested
sys
configurations
selection
inversely
missed
conservative
addresses
300
deadline
categoriza
popula
expenditure
bination
11872718
11826117
71350
retargeting
preheaders
vpcc
mandrioli
35226
fittest
sporadically
regehr
creased
dasarathy
12050569
24469014
brylow
12234507
23466
asymptoted
sibin
sigma3
substantiated
mutating
decls
pohlheim
15357471
timum
vpo
13007019
binkley
brightest
dudani
execution times
evolutionary testing
time systems
timing analyzer
real time
longest execution
extreme execution
temporal behavior
execution time
the wcet
the timing
evolutionary algorithms
static cache
of real
the temporal
timing analysis
static analysis
the population
of evolutionary
and et
schedulability analysis
test object
timing constraints
loop level
by sa
the shortest
the evolutionary
case execution
the bcet
the longest
the test
control flow
for schedulability
wcet of
test data
the actual
cycle level
the bubblesort
temporal correctness
best worst
of generations
actual execution
sa and
cache simulation
flow information
cache simulator
frank mueller
test objects
evolutionary computation
shortest execution
best case
the extreme
logical correctness
of sa
the instruction
worst case
data flow
instruction categorizations
systematic test
timing tree
and wcet
time environments
shortest and
worst best
bcet and
bubblesort algorithm
testing real
timing predictions
remaining associativity
associativity levels
and longest
the loop
input parameters
the caching
test methods
of static
the program
caching behavior
the et
both approaches
testing is
instruction and
run times
behavior of
cache behavior
analyzer for
path analysis
for et
static timing
the execution
individuals are
testing the
cycles for
population size
evolutionary optimization
sa approach
testing et
test program
population and
et was
shortest run
calling structure
the sa
test datum
et approach
time determined
input situations
kiran seth
defense electronics
gnat gcc
function instance
times determined
discrete recombination
fitness values
categorizations for
address calculator
evolutionary algorithm
the cache
the calling
and evolutionary
data caches
entire program
current work
each loop
instruction cache
data references
the fitness
first miss
specified timing
analyzer can
times were
for real
existing test
the defense
the individuals
portability of
analytical method
loc and
stopping condition
the multiplication
executing the
cache state
the portability
instruction caches
over many
first hit
analysis and
specified for
multiplication of
experiments the
within the
of test
of matrices
processor cycles
test programs
the control
confidence in
with regard
the worst
time of
was increased
the examination
call graph
fit into
was set
the experiments
two methods
an execution
a loop
for static
n a
random testing
of individuals
that reason
calculated by
case and
on testing
population of
determined by
increased to
caches and
addresses of
first misses
caching into
mutation is
high fitness
driven software
100 generations
mutation probability
categorizations have
since instruction
the daimler
4095 the
miss hit
analysis sa
cycles results
generations the
for sa
program lines
generations was
real time systems
of real time
the temporal behavior
extreme execution times
the timing analyzer
longest execution time
the longest execution
temporal behavior of
the extreme execution
actual execution times
the test object
behavior of real
sa and et
for schedulability analysis
the actual execution
static analysis and
number of generations
longest execution times
static cache simulation
the shortest execution
the control flow
case execution time
instruction and data
of static analysis
shortest execution time
shortest and longest
testing the temporal
a systematic test
method of static
worst best worst
static cache simulator
and longest execution
each loop level
the remaining associativity
the bubblesort algorithm
the caching behavior
multiplication of matrices
testing real time
execution times were
the bcet and
real time environments
remaining associativity levels
bcet and wcet
best worst best
control flow information
worst case execution
a n a
n a n
into the remaining
best case execution
for the longest
the wcet of
execution time of
static timing analysis
of the test
the population size
for real time
cycles for the
time systems the
the execution times
determined by sa
evolutionary testing et
temporal behavior is
temporal correctness of
the evolutionary algorithms
execution time determined
timing analyzer can
the timing tree
and evolutionary testing
case and best
execution times determined
shortest run time
the et approach
the shortest and
of evolutionary algorithms
test object with
executing the test
analysis and evolutionary
the temporal correctness
timing constraints of
the sa approach
and best case
the population and
the entire program
the multiplication of
the worst case
execution times for
fit into the
the best case
for the shortest
execution time that
of the wcet
specified timing constraints
was increased to
for the best
and data caches
the portability of
case execution times
provides the means
execution times the
timing analysis of
for each loop
confidence in the
the examination of
the means to
the execution time
with regard to
the method of
for testing the
an execution time
worst case and
by executing the
have to be
execution times in
for that reason
of the program
of the entire
of the population
number of input
data flow analysis
specified for the
for the worst
of the actual
to check if
worst case the
the cache configuration
obtain high fitness
calculated by sa
of support for
of different systems
time environments where
again the longest
processor cycles for
where soft real
the shortest run
the mutation probability
time environments may
it is potentially
of the extreme
the test objects
the previous generation
caching behavior of
counter of the
temporal system behavior
of evolutionary computation
actual running system
for instruction and
support for testing
the cache behavior
population size was
evolutionary algorithms is
new individuals are
and et in
for inner loops
on testing the
use of formal
constraints of real
of static cache
methods to verify
of existing test
run times possible
their fitness and
to small systems
and maximum run
timing constraints specified
within the control
important analytical method
test methods shows
more extreme execution
the program or
cache simulation and
afterwards the new
to verify timing
actual real time
time determined by
extreme run times
is a lack
in the timing
for the wcet
static analysis sa
the absolute maximum
the instruction categorizations
associativity levels but
bottom up within
verify timing constraints
individuals are selected
after 300 generations
cycles results if
the defense electronics
execution times obtain
both matrices are
lack of support
development of real
of interrupt driven
that was determined
test data are
the calling structure
method for assuring
to schedulability analysis
all conflicts fit

corpus/krapavin2000-test/608017.txt
squashing
logistic
regression
roc
dumouchel
mart
92000
likelihood
classication
squashed
empirical
boosted
weights
unweighted
moments
regressions
diminishing
coe
training
bayes
curves
predictor
weighted
owen
cients
score
missing
credit
sampling
reweighting
predictors
8000
weighting
imputed
classiers
benet
sample
stratication
4000
friedman
scoring
1999
variance
proprietary
dierences
gains
hellinger
99720
liebler
equationsn
stumps
variates
999871
condentiality
misclassication
classied
won
ij
bad
accelerates
custom
expect
population
curve
madigan
zm
dms
774
trees
plotted
correlated
prediction
records
strata
dollar
estimator
predict
dierence
match
boosting
477
431
ambitious
kullback
benets
proportion
samples
adjusts
customized
convex
conditional
returns
additive
rst
averages
variances
monte
1000
region
mining
categorical
scaling
1987
euclidean
predicted
probabilities
estimators
withn
99733
lawless
posse
condential
744963
baggerly
99163
overtting
99895
98830
hoadley
9433
99571
wol
semma
999651
98950
9999
99707
99026
prot
99889
volinsky
hesterberg
9274
9419
tibshirani
cochran
unweighed
ridgeway
hastie
9244
unrealized
obfuscating
lohr
9326
99844
nason
underpinnings
splus
99147
24430
99624
99891
9361
999858
9435
mineset
rabinowitz
0072445
9238
jerome
99172
nonmissing
999625
8w
9704495
staple
999832
pregibon
reweight
99877
99217
309262
999793
99881
999754
99885
99656
626
98980
99829
999819
bratley
99761
obfuscated
99150
99846
78165
99689
cast
accuracy
regions
settings
column
nn
children
carlo
numerical
maximize
eective
reweights
empirical likelihood
logistic regression
data squashing
dumouchel et
likelihood weights
roc curves
al 1999
diminishing returns
bayes error
squashed data
logistic regressions
roc curve
the bayes
missing values
regression on
of squashing
likelihood weighted
good cases
likelihood squashing
coe cients
weighted and
to expect
data set
credit scoring
weighted logistic
unweighted logistic
the squashed
the roc
the logistic
global features
g m
simple random
the regression
the weights
reasonable to
original data
x ij
and unweighted
of dumouchel
likelihood weighting
boosted trees
regression estimator
regression weights
squashing to
an roc
using empirical
from squashing
a credit
sample sizes
the data
w i
the empirical
squashing is
classication trees
shown are
correlated with
random sample
training algorithms
predictor variables
expect an
weights w
data sets
min v
classied as
won t
local features
full data
is reasonable
et al
with global
accuracy in
a score
values were
y i
expect squashing
in monte
curves tend
3 signicant
nn h
with boosted
1999 might
kullback liebler
variance reduction
equationsn log
share values
477 0
conditional moments
squashing will
on 8000
99720 0
0 774
0 477
speed gains
and won
that empirical
a logistic
conditional means
of predictor
categorical variables
2 empirical
records have
dimensional family
the diminishing
regression for
approximate form
4000 8000
and 92000
the reweighting
774 0
m functions
in dumouchel
signicant places
both weighted
non categorical
cases classied
regression coe
accelerates the
predictor values
8000 4000
boosted decision
0 999871
boosted classication
other distance
these roc
4000 2000
power p
scoring problem
control variates
the squashing
0 99720
increased accuracy
mart models
for squashing
squashing method
all 92000
predicted probabilities
squashing with
a squashed
zero bayes
proprietary score
are diminishing
moments on
regression weighting
n increases
gains in
the population
the weighted
numerical integration
coe cient
for training
the unweighted
moments in
predict when
order moments
431 0
up algorithms
lines correspond
will and
0 431
weights it
bad cases
have records
likelihood based
max v
will t
smaller sample
moments the
of predictors
error rate
of good
this data
for weighted
carlo simulation
the customized
or empirical
returns for
the percent
been transformed
in classication
of estimated
log f
a proprietary
bottom are
8000 and
expect that
training data
the rst
x i
and 1000
estimator is
regression is
pairs x
more ambitious
for empirical
regression the
where more
that essentially
only 20
are learned
a classication
dumouchel et al
empirical likelihood weights
et al 1999
empirical likelihood squashing
empirical likelihood weighted
logistic regression on
the empirical likelihood
the bayes error
reasonable to expect
the squashed data
weights w i
empirical likelihood weighting
simple random sample
the logistic regression
global features of
a credit scoring
a simple random
of good cases
weighted and unweighted
of dumouchel et
the regression estimator
using empirical likelihood
an roc curve
likelihood weighted logistic
unweighted logistic regression
an error of
it is reasonable
is reasonable to
the full data
as n increases
the original data
shown are the
of the data
to expect that
and y i
features of the
zero bayes error
method of dumouchel
of data squashing
accelerates the rate
4000 8000 and
regression on 8000
logistic regression for
are diminishing returns
the weighted and
we expect squashing
increased accuracy in
at 0 2
the regression weights
a logistic regression
to 3 signicant
credit scoring problem
dimensional family of
classied as good
x ij with
mean of those
like x 1
the records have
squashing method of
a proprietary score
predicted probabilities from
the roc curve
the diminishing returns
when it will
expect an error
form of squashing
moments on the
1 dimensional family
there are diminishing
in dumouchel et
regression coe cients
that empirical likelihood
both weighted and
ij with y
roc curves tend
m 1 dimensional
on all 92000
4000 2000 and
used in monte
1000 2000 4000
described in dumouchel
of scaling up
it will and
scaling up algorithms
regression on all
bayes error rate
h n where
and won t
diminishing returns for
boosted decision trees
these roc curves
the roc curves
g m x
or empirical likelihood
other distance measures
instead of scaling
logistic regression coe
8000 4000 2000
regression estimator is
with global features
in monte carlo
squashing with global
log f x
share values for
when the records
al 1999 might
with boosted decision
have records with
weighted logistic regression
dierences in the
will and won
the missing values
for empirical likelihood
0 477 0
2 0 8
2000 4000 8000
2000 and 1000
functions g m
0 774 0
boosted classication trees
those x ij
logistic regression is
3 signicant places
squashing is used
the conditional moments
non categorical variables
cases classied as
approximate form b
n will t
predict when it
curves tend to
point at 0
0 99720 0
distance measures such
2 empirical likelihood
up algorithms to
8000 and 92000
weighted logistic regressions
of bad cases
roc curves are
bottom are for
data to match
the bayes rule
algorithms to large
are no solutions
logistic regression the
lines correspond to
0 431 0
curves from top
t in memory
v min v
of those x
an n m
only 20 of
g m a
the percent of
family of solutions
roc curves for
of g m
will t in
are correlated with
on n points
to bottom are
a parameter vector
monte carlo simulation
2 h n
n m 1
n increases the
of the good
correlated with the
proportion of the
of the bad
the reason is
reason is that
can be much
from top to
i and y
top to bottom
in data mining
data set and
are those that
measures such as
the proportion of
that the original
the coe cients
by a linear
the euclidean distance
as described below
we can expect
in the text
0 2 0
in the simplest
much better than
large data sets
the training data
the data to
the rate at
chosen so that
rate at which
the eect of

corpus/krapavin2000-test/608041.txt
b2c
b2b
commerce
servers
sites
server
tailed
traffic
site
heavy
burstiness
front
web
utilization
arrival
response
business
load
bursty
secs
av
workload
requests
hurst
00pm
transfer
file
request
day
periods
ssl
logs
secure
collected
services
estimator
plot
arriving
disk
buying
4p
00am
weekday
corporations
self
disks
database
ldap
sec
attributed
security
processor
characterization
catalog
sustained
queue
consumer
speculation
firewall
morning
sizes
back
period
aggregated
4000
night
llcd
balancer
businesses
30am
12am
5sec
busy
nature
scalability
configuration
nda
population
similarity
evening
customer
observed
series
users
6000
till
burst
bucket
internet
fic
3000
normal
service
traf
bytes
loader
662
powered
billion
5000
microsoft
activity
clients
peak
studies
files
bursts
req
aggregating
inspection
image
customized
stationary
buckets
tests
serve
encryption
office
granularity
planning
estimating
environment
scales
queuing
estimated
rate
characteristics
perceived
wavelet
serving
refutes
arby
the1030500
reqs
5pm
lrd
at10305070900
site20000600001000001400001800000
complying
51525
accruing
https
diurnal
unmistakable
log10
portal
server1000300050000
httpd
throttle
90th
titchkosky
site10305070
of2000006000001e
9am
delphi
4000th
balancers
propelled
arlitt
characetrization
extent
impact
popularity
simplified
workloads
industry
valuable
regularity
availability
db
visual
representative
sensitive
lance
revenues
veitch
selling
amazon
immense
smtp
512mb
seasonal
williamson
netscape
shopping
divulge
oltp
vironments
speculated
conducts
reluctant
10000
figures
hours
am
cumulative
implications
proportion
socket
stationarity
e commerce
back end
end servers
the b2c
b2c site
heavy tailed
the back
front end
commerce sites
the b2b
the front
response time
b2b site
h parameter
response times
arrival process
tailed behavior
end server
the response
transfer sizes
burstiness in
the traffic
web servers
utilization of
file sizes
the arrival
end web
business to
s plot
the heavy
servers is
processor utilization
b2c and
b2b space
commerce environment
database servers
the av
5 secs
server this
a heavy
plot test
response file
commerce traffic
commerce servers
secs figure
b2b sites
load periods
response size
load on
web environment
commerce site
in nature
behavior of
web server
queue length
self similar
the burstiness
hurst parameter
main d
av estimator
and b2b
arrival traffic
time series
arriving at
the load
the web
self similarity
size distribution
was collected
the site
be heavy
web traffic
traffic arriving
transfer times
the server
the utilization
the sites
site and
the h
consumer b2c
in b2c
tailed in
a b2c
general web
b2c environment
b2c sites
request size
catalog server
b2c server
b server
the business
workload characterization
site is
of transfer
and response
database server
the workload
r s
the transfer
of e
arrival rate
servers are
b2b and
more bursty
series obtained
bursty than
logs from
tailed distribution
found to
in e
collected at
the transactions
observed that
to consumer
to business
these servers
in web
data was
server the
end and
the day
the behavior
request and
these sites
disk utilization
sites have
the hard
times observed
normal web
business b2b
9 00am
ldap server
5 sec
ssl off
the hurst
at b2b
high burstiness
sites serve
entire day
simplified configuration
image servers
of file
attributed to
sites is
the r
of self
parameter is
reported on
site the
hard disks
nature with
observation period
sec time
access logs
commerce server
utilization time
different load
main database
sizes do
services to
traffic and
the database
servers the
process at
of response
the system
user population
3000 4000
a granularity
load conditions
hard disk
two sites
capacity planning
configuration of
the servers
service time
not follow
the request
this behavior
heavy traffic
2000 3000
4000 5000
d b
characteristics of
be observed
visual inspection
estimator and
server and
the study
used for
sizes is
servers when
high load
estimated to
of request
been reported
follow a
time at
of web
this data
the back end
back end servers
the front end
e commerce sites
the b2c site
heavy tailed behavior
burstiness in the
of e commerce
in e commerce
the b2b site
for the b2c
front end web
r s plot
the response time
utilization of the
the heavy tailed
at the back
the h parameter
front end server
e commerce environment
the arrival process
load on the
a heavy tailed
of the front
the load on
s plot test
response file sizes
e commerce traffic
in the b2b
end servers is
tailed behavior of
e commerce servers
the r s
of the traffic
e commerce site
the web servers
front end servers
in the back
in the b2c
of the b2b
processor utilization of
main d b
the main d
at the server
traffic arriving at
in the arrival
degree of self
front end and
at the front
found to be
of self similarity
request and response
be heavy tailed
to be heavy
behavior of the
on the system
data was collected
in web environment
arrival process at
the arrival traffic
back end server
was collected at
business to consumer
than the front
end web servers
the database servers
to consumer b2c
b2c and b2b
and response file
b2c site is
d b server
h parameter is
business to business
heavy tailed in
tailed in nature
the b2c server
end server this
end web server
the av estimator
follow a heavy
the b2b space
observed that the
arriving at the
the response times
the behavior of
to the heavy
the burstiness in
more bursty than
heavy tailed distribution
time series obtained
the time series
response times in
used for estimating
the utilization of
time at the
in the response
for the study
configuration of the
the request and
are used for
the two sites
the transfer sizes
a granularity of
e commerce server
to business b2b
av estimator and
end servers the
most e commerce
the hard disk
high burstiness in
an e commerce
at the b2c
response times observed
series obtained from
the b2c and
collected at a
behavior of transfer
the hurst parameter
simplified configuration of
b2b site the
the user population
a visual inspection
logs from the
5 secs figure
request size distribution
size distribution over
of transfer sizes
business b2b and
using the av
that the load
can be observed
the observation period
response time at
bursty than the
at a granularity
estimating the h
response time distribution
sizes do not
in nature with
the traffic arriving
not follow a
due to the
attributed to the
reported on the
of the site
and the back
end and the
on the back
of response times
of the back
2000 3000 4000
do not follow
arrival process is
3000 4000 5000
of the web
for estimating the
that the response
1000 2000 3000
to the back
observed by the
estimated to be
as explained earlier
and the r
characteristics of the
this is due
response time is
was observed that
has been reported
being used for
the service time
even though the
of the main
to a higher
for e commerce
of the servers
of the workload
it was observed
is due to
of the response
to be 0
with an average
plot test are
the actual response
the business model
and e commerce
web response times
in secure mode
commerce servers is
one powered by
33 13 figure
bursty in nature
site is shown
both the sites
load behavior of
not heavy tailed
and business to
hurst parameter is
arrival rate at
heavy tailed nature
normal web traffic

corpus/krapavin2000-test/608045.txt
lossy
channel
d0e
channels
nonprimitive
eb
reachability
0n
d1e
undecidable
termination
aj96b
decidable
weakly
decidability
workspace
dke
perfect
tm
nets
polarity
congurations
abdulla
expanders
ackermann
encodings
ack
petri
nite
markers
behaviors
turing
prop
lost
folder
jonsson
finkel
bz83
dack
recursive
hs
bisimulation
unreliable
expander
conguration
verication
hq
losses
innite
simulation
automata
letters
consumes
folders
countdown
eb1
ak95
fin94
may00
antonn
aj96a
cfp96
mm81
cjt00
schnoebelen
kuera
hardness
b1
undecidability
innitely
tape
equivalences
contents
alphabet
petr
reset
transition
alain
monotonicity
transferring
rabinovich
subword
transfered
writes
primitive
visit
204
hw
consumed
encoding
faithful
induction
verification
202
fo
encodes
terminates
visits
inverses
marker
entail
veri
encoded
communicating
fig
proposition
messages
equivalence
faithfully
rst
rotation
simulating
isolate
accepts
resp
hstart
runnings
kuske
giorgio
fs01
delzanno
clumsy
hig52
djs99
subalphabet
irremediably
uncontrived
reworded
ddci
d4e
formk
mayr
eventuality
aab99
egin
genest
sch01
jancar
hac76
nomenon
boc78
jan01
dfs98
revisits
expansive
shorthands
janar
subrun
akp97
abj98
956
meyssonnier
abpj00
hab
abracadabra
unfaithful
dme
buers
abba
inevitability
verifying
fifo
writing
unbounded
letter
accept
consume
da
asynchronous
lemma
protocols
loops
simulate
entitled
dietrich
slogan
phe
estelle
gadget
920
amadio
muscholl
notication
higman
blaise
lose
machines
everywhere
quasi
appendix
mode
loop
grard
oneself
anca
faithfulness
713
tween
nordic
underlining
channel systems
lossy channel
for lossy
channel c
nonprimitive recursive
c n
s 0n
channel system
recursive complexity
a n
channels c
c 1
ack n
eb d0e
e n
d0e eb
weakly compute
a run
lossy behaviors
tm s
encodings of
f n
prop 3
a channel
lossy systems
b1 e
shown decidable
has nonprimitive
decidable problems
termination for
t n
primitive recursive
petri nets
of prop
one b
one e
n s
one 1
decidability of
systems with
single channel
decidable for
for petri
other channels
every w
finite state
a 1
from c
nite equivalence
can weakly
dack n
d1e d0e
hq w
and jonsson
weakly computing
0n m
d0e d0e
have nonprimitive
undecidable problems
probabilistic lossy
accepts in
perfect run
perfect step
in aj96b
unreliable channels
abdulla and
several channels
n channel
reset nets
c x
of numbers
a nite
induction over
w i
termination and
are encodings
to lossy
are decidable
reachability for
one channel
a perfect
the simulation
in fig
our systems
ackermann s
and undecidability
z times
control state
a lossy
as bounded
systems has
over n
q n
to c
systems are
automata that
run from
a conguration
and reachability
these systems
our construction
encodes a
state systems
the contents
systems is
the channel
contents of
turing machine
by induction
been lost
m using
decidable in
n e
simulation of
transition rules
behaviors that
nite state
of s
n and
n k
w j
computation v
n have
no message
s 0
s function
lemma a
a turing
the direction
in primitive
contain encodings
accept figure
in unreliable
the lossy
most ack
innite run
1 november
recursive time
to behaviors
polarity is
folder systems
lossy behavior
d0e dke
their inverses
are nonprimitive
dke d1e
between lossy
other undecidable
about probabilistic
weakly computes
channels contain
antonn kuera
huge workspace
d0e d1e
eb1 k
the expanders
it under
and folder
reachability are
hence corollary
202 n
with huge
proof omitted
structured transition
writes back
always write
into channel
verication problems
perfect steps
nets between
alain finkel
communication information
consumes one
unreliable computations
store auxiliary
of lossy
perfect channels
in ackermann
that weakly
systems everywhere
leaving q
while channels
for tm
bounded workspace
a cjt00
e markers
congurations 0
run that
1 lossy
v 202
allocated workspace
run hs
verifying lossy
d1e eb
improved search
expanders we
a countdown
state automata
in state
channels are
lossy channel systems
for lossy channel
nonprimitive recursive complexity
channel c 1
a channel system
channels c 1
d0e eb d0e
a n k
from c n
to c n
c n 1
encodings of numbers
channel systems has
the other channels
systems has nonprimitive
and one e
channel systems is
of prop 3
eb d0e eb
has nonprimitive recursive
induction over n
channel c n
every w i
simulation of m
n 2 a
1 to c
a 1 n
n and f
by induction over
shown decidable in
dack n e
can weakly compute
have nonprimitive recursive
channel systems are
a perfect step
perfect step is
automata that communicate
are decidable for
abdulla and jonsson
contains one b
prop 3 2
proof of prop
termination and reachability
the e n
channel system s
channel systems can
c 1 contains
reachability for lossy
channel systems that
one b and
encodes a number
termination for lossy
decidable for lossy
s 0n m
probabilistic lossy channel
and f n
and computation v
information and computation
are encodings of
state automata that
b and one
the t n
for n 2
the contents of
ackermann s function
of e n
lemma a 1
is a nite
all n 2
for petri nets
c x c
c 1 to
x c x
of a n
a turing machine
of t n
theorem 2 3
of the channel
between lossy channel
channel systems the
hard as termination
in primitive recursive
termination for tm
weakly computes a
improved search strategy
q c has
that weakly compute
reset nets between
nite state automata
v 202 n
structured transition systems
undecidable problems in
0 n to
isolate the congurations
c 1 into
contain encodings of
weakly computing a
lossy behavior of
with unreliable channels
lossy systems with
letters and writes
of channel c
w i contains
a perfect run
systems that weakly
weakly compute the
while channels c
d0e dke d1e
compute the a
only one channel
d1e d0e eb
d1e eb d0e
e then every
1 from c
channel systems with
1 november 2005
communication information and
of tm s
some 1 s
1 contains at
primitive recursive time
and other undecidable
one 1 from
verifying lossy channel
if a run
into channel c
of s 0n
with the e
nets between decidability
that communicate via
a rule q
all channels contain
decidable in aj96b
other undecidable equivalences
beyond the allocated
as bounded workspace
problem for petri
behaviors that do
a run from
for tm s
dke d1e d0e
inverses a 1
with huge workspace
recursive function of
and bisimulation between
rule q c
well structured transition
writing it under
channel systems and
as a countdown
the f n
a run hs
channels contain encodings
systems with only
simulation and bisimulation
search strategy for
the congurations where
l a n
channel systems from
accepts in space
reasoning about probabilistic
f n s
as termination for
d0e d1e eb
consumes one 1
202 n 2
following formal sense
s 0 n
or a e
contents of channel
other channels c
i n have
a lossy channel
transition systems everywhere
in unreliable computations
of lossy channel
channels c 2
equivalences for lossy
systems is at
most ack n
contents of c
eb d0e d1e
m with huge
m is simulated
systems have nonprimitive
run of s
m using c
expander e n
an improved search
infinite state systems
it under the
n s are
bisimulation between lossy
bisimulation and other
control state reachability
that every w
hence corollary 4
ack n steps
the allocated workspace
channel systems have

corpus/krapavin2000-test/608119.txt
classiers
mdts
meta
mdt
classier
cdp
mlc4
stacking
attributes
bla
odts
scann
c4
bagging
predictions
voting
learning
boosting
classication
vote
predicted
trees
induced
expertise
ac4
base
cml
odt
ordinary
diversity
signicantly
ltree
tac
toe
decision
hypothyroid
hepatitis
soya
diabetes
echocardiogram
ionosphere
ensembles
wine
waveform
glass
combiner
tic
correlation
classifiers
inducing
dierent
training
conf1
breast
entropy
plurality
german
bridges
australian
combining
accuracy
chess
improvement
c45
condence
conf
iris
td
heart
prediction
leaf
insignificant
distributions
cn2
car
625
nn
siers
induce
clas
bayes
probability
cdps
weka
impurity
j48
outperform
domains
comprehensible
certainty
propositional
signicant
areas
balance
knn
combine
nearest
stratied
classi
errors
correlated
frameworks
stacked
naive
modication
mining
cascading
dependence
cd
worse
pruning
dierence
0jx
1jx
14144
brazdil
111111
00385
lml
gama
maxprob
aml
accuracies
uci
ensemble
info
classied
appendix
image
discriminant
regression
weight
arbiters
classications
losses
c2
rst
ve
leaves
neighbor
density
error
ect
condent
875
expressive
c1
3a
na
validation
attribute
pavel
dierences
twenty
repository
species
predicting
votes
comprehensibility
induces
classify
identifying
concise
vs
post
ilp
asterisk
predicts
select
slope
fold
endfor
settings
cv
suite
dened
paired
renement
constructing
calculate
bernard
signicance
cn
conquer
unseen
tree
art
3b
wins
neural
pred
cross
calculated
split
expressiveness
avg
returned
enko
domingo
ibl
base level
level classiers
meta level
level attributes
meta decision
decision trees
mlc4 5
the base
class probability
level classier
c4 5
combining classiers
error correlation
relative improvement
the mdt
data set
induced using
of meta
the meta
ordinary decision
for combining
classiers the
mdts induced
predicted by
of expertise
classier c
level learning
the predictions
predictions of
learning algorithms
with mdts
induced with
of mdts
accuracy improvement
diversity of
level data
ac4 5
multiple classiers
the class
class value
tic tac
tac toe
distributions predicted
expertise of
that mdts
select best
combining multiple
probability distributions
the diversity
mdts are
predicted class
stacking with
relative areas
cdp bla
classiers in
classier is
class values
signicantly worse
ordinary attributes
bridges td
insignificant significant
breast w
using cdp
mdts over
mdts is
probability distribution
signicantly better
the classier
of classiers
k nn
examples in
plurality vote
mdt leaves
balance breast
chess diabetes
and signicantly
trees mdts
distribution properties
diabetes echocardiogram
short line
induced from
decision tree
line density
for inducing
voting schemes
class distribution
example x
learning algorithm
image ionosphere
hypothyroid image
iris soya
bagging and
its prediction
soya tic
trees induced
ionosphere iris
conf1 0
classiers c
w bridges
level classifiers
toe vote
wine insignificant
td car
echocardiogram german
constructing ensembles
vote waveform
glass heart
classication errors
given example
waveform wine
german glass
car chess
hepatitis hypothyroid
australian balance
classifiers australian
and bagging
classiers induced
heart hepatitis
of base
attributes used
boosting and
classiers are
improvement of
areas of
improvement over
data sets
the voting
is signicantly
the entropy
between base
the odt
0 625
voting scheme
ensembles of
correlation between
set m
to induce
of accuracy
of decision
the predicted
improvement achieved
see table
condence of
dierent learning
attributes bla
significant figure
mdts can
original base
conf 1
and boosting
by mdts
the combiner
tree induced
mdt induced
classication error
mdt cdp
density 5
better than
the examples
to combine
for learning
errors of
c 1
naive bayes
worse in
of c4
classiers with
trees vs
attributes are
machine learning
table 6
set l
induced on
the classication
the c4
on combining
relative accuracy
the certainty
c j
conf 2
distribution predicted
mdts with
using class
error c
cdp set
inducing meta
of mdt
stacking framework
learning mdts
the cdp
boosting of
odts induced
bagging of
with odts
current subset
with mlc4
values predicted
combine classiers
using bla
maximum probability
base level classiers
the base level
meta level attributes
meta decision trees
of the base
base level classier
the meta level
the class probability
class probability distributions
by the base
of meta level
level data set
meta level data
for combining classiers
ordinary decision trees
areas of expertise
level classiers the
class probability distribution
predicted by the
predictions of the
tic tac toe
the error correlation
distributions predicted by
base level attributes
of expertise of
of base level
combining multiple classiers
the predictions of
diversity of the
the diversity of
error correlation between
relative areas of
meta level learning
data set m
mdts induced using
set of meta
the predicted class
relative improvement over
level classiers are
probability distributions predicted
balance breast w
level classiers in
decision trees mdts
of the mdt
short line density
of decision trees
relative improvement of
the class value
tac toe vote
soya tic tac
toe vote waveform
bridges td car
hepatitis hypothyroid image
w bridges td
a given example
breast w bridges
constructing ensembles of
wine insignificant significant
german glass heart
image ionosphere iris
glass heart hepatitis
level learning algorithms
is signicantly better
of meta decision
ionosphere iris soya
conf1 0 625
australian balance breast
echocardiogram german glass
car chess diabetes
heart hepatitis hypothyroid
boosting and bagging
level classier c
hypothyroid image ionosphere
diabetes echocardiogram german
waveform wine insignificant
induced using cdp
vote waveform wine
td car chess
between base level
level classifiers australian
base level classifiers
classifiers australian balance
and signicantly worse
iris soya tic
chess diabetes echocardiogram
signicantly worse in
correlation between base
meta decision tree
ensembles of classiers
see table 6
a a a
the examples in
set of base
of the class
decision trees induced
each base level
mlc4 5 and
with mdts is
class distribution properties
decision tree induced
decision trees vs
original base level
used to induce
insignificant significant figure
of c4 5
the original base
condence of the
line density 5
achieved with mdts
dierent learning algorithms
of the diversity
shows that mdts
examples in l
of error correlation
sets of meta
diversity of errors
as meta level
relative accuracy improvement
signicantly better than
of the examples
in appendix a
of errors of
c j i
single data set
errors of the
of the error
the c4 5
6 and table
of the predictions
decision trees and
c 1 and
table 6 and
trees induced with
expertise of the
induced using the
level attributes bla
the cdp set
class values predicted
boosting of decision
two base level
of mdts over
used for classication
examples in s
classiers with mdts
the maximum probability
a meta decision
the certainty and
for combining multiple
certainty and condence
odts induced with
classiers induced by
classiers can be
domains and signicantly
area of expertise
table 10 in
induced with mlc4
cdp set of
and condence of
highest class probability
bagging of decision
the plurality vote
mlc4 5 is
base level learning
for learning mdts
the linear regression
10 in appendix
values predicted by
level classiers induced
level classiers c
c4 5 17
for constructing ensembles
distribution predicted by
method for combining
combining classiers with
accuracy of mdts
ect the certainty
with mlc4 5
and ac4 5
that mdts outperform
level attributes used
base level predictions
density 5 0
to combine classiers
bagging and boosting
one data sets
4 relative improvement
linear regression line
twenty one data
and c 2
1 and c
for further work
degree of error
decision trees is
improvement achieved with
the relative improvement
the highest class
degree of the
side of figure
a single data
used to classify

corpus/krapavin2000-test/608175.txt
bmd
sov
bmds
fulladder
substitution
circuit
nonterminal
adder
terminal
multipliers
jf
subst
multiplier
backward
wallace
diagrams
substitute
bits
verification
calls
multiplication
substituted
gates
moment
mult
cells
circuits
topological
lambdab
word
gate
cut
labeled
substituting
arithmetic
successor
successors
boolean
su
xm
reverse
substitutions
ca
hsis
aand
edge
product
combinational
recursive
unsigned
node
md
multiplicative
outputs
ast
costs
vlsi
bdds
additionally
partial
verifying
cir
carry
primary
integer
pointing
products
binary
subsection
polynomially
inputs
crossing
rema
theorema
fullad
mediately
4to2
fulladders
phdd
hamaguchi
boole
3to2
makenode
dividers
automatical
subtraction
forming
vertices
moved
ends
depth
processed
bit
weight
diagram
predecessor
reaches
gamma2x
cuit
e4
substitu
representations
realization
specifications
weights
outgoing
encoding
verified
fa
645
figured
oneself
handed
ladder
1176
2w
cuits
mtbdds
vertex
bounded
256
dfg
watching
prematurely
orders
lemma
phi
final
simplifies
multipli
theo
totally
feasibility
summing
bdd
testable
intermediate
2n
incoming
synthesis
onto
ful
superfluous
destroyed
decision
suggestion
argu
thermore
ally
formal
sure
downward
stant
manipulation
constructing
named
diagonal
ago
adds
interrupt
feasible
unchanged
destroy
dag
middle
symbolic
shannon
visualized
spectively
errors
hybrid
mo
divisor
overcoming
add
representatives
decomposes
tree
continually
attain
fur
analyzed
proves
maximally
considerably
breadth
specification
polynomial
extracts
composition
resolving
sizes
afterwards
logic
der
orderings
analyze
please
calculates
nally
the bmd
partial product
a bmd
product bits
backward construction
initial partial
variable order
the substitution
sov structure
bmd for
in sov
adder part
the sov
bmd f
substitution of
the adder
binary moment
the circuit
o jf
terminal node
the bmds
moment diagrams
by backward
labeled with
bmd is
of wallace
fulladder cells
wallace tree
high edge
topological order
reverse topological
by su
high successor
like multipliers
subst calls
verification by
a terminal
the variable
input word
nonterminal node
recursive subst
resulting bmd
substitute algorithm
bmd in
the substitute
the fulladder
substitution process
by o
the cut
f 0
variable x
the multiplication
a i
the multiplier
arithmetic circuits
of backward
node for
bounded by
bmd after
su and
low path
l xm
bmd constructed
partial products
bmds for
chosen reverse
carry output
product bit
add calls
tree like
is bounded
o n
b j
of verification
by ca
jf 0
and gates
word sizes
been substituted
and carry
decision diagrams
of variable
substitution is
node x
verification of
calls of
execution steps
sum and
lemma 4
linear moment
final bmd
b variables
bmds have
md a
lambdab md
calls because
only experimental
construction applied
multiplier circuit
verifying arithmetic
bmd has
bmd representing
multiplicative binary
to mult
all fulladder
same fulladder
of multipliers
method of
of f
x i
the chosen
x variables
arithmetic functions
theorem 4
low and
time independent
the variables
the costs
the method
in f
the low
variable a
x k
the complexity
node labeled
substituting x
variable orders
integer multiplication
of arithmetic
with binary
recursive calls
word level
terminal vertices
a nonterminal
one nonterminal
of substitutions
functions with
to time
has size
primary inputs
algorithm calls
a variable
independent of
bits a
level specifications
edge of
the node
formal verification
and high
the partial
substituted by
calls is
to space
outputs of
jf j
upper part
boolean variables
cut is
to integer
constructing the
give classes
phase lines
high f
time vlsi
named low
variables denote
aand b
hybrid decision
bmd 2
products bits
bmd by
ca we
low x
moment diagram
unchanged otherwise
unsigned integer
mult ends
high successors
sov and
bmds are
v labeled
intermediate bmds
terminal value
specific multiplier
multipliers a
4 complexity
by lambdab
fulladder in
fulladder the
multipliers is
diagonal line
256 bits
su is
starting bmd
bits into
i obviously
b variable
weighted variables
add during
ends immediately
partial product bits
initial partial product
the adder part
the sov structure
the variable order
the substitution of
by backward construction
for the adder
verification by backward
bmd for the
the bmd for
binary moment diagrams
wallace tree like
of wallace tree
reverse topological order
of the circuit
of backward construction
adder part of
of the bmd
a terminal node
class of wallace
tree like multipliers
bounded by o
is bounded by
sum and carry
the substitute algorithm
i by su
of verification by
bmd in sov
the partial product
recursive subst calls
a bmd in
by o jf
the substitution process
substitution of x
method of verification
the resulting bmd
of the substitution
variable a i
x i by
the method of
respect to time
constructing the bmd
jf 0 j
chosen reverse topological
and carry output
method of backward
input word sizes
sov structure of
is in sov
to time independent
the initial partial
of o jf
an initial partial
j by ca
partial product bit
of the multiplier
n 4 with
high edge of
the chosen reverse
the bmds for
x j by
the sum and
low and high
4 with respect
respect to space
with binary moment
by o n
lemma 4 1
independent of the
node labeled with
of execution steps
number of execution
verification of arithmetic
with a variable
o n 2
time independent of
the bmd representing
bmds for the
all fulladder cells
to space and
x l xm
experimental data has
carry output of
for verifying arithmetic
by su and
and high edge
the low path
is a bmd
lambdab md a
md a i
topological order for
n 2 with
bmd f 0
backward construction applied
resulting bmd is
the same fulladder
substitution is bounded
verification of multipliers
to be substituted
be a bmd
call to mult
for the substitution
the bmd constructed
multiplicative binary moment
construction applied to
in a bmd
o jf 0
of variable orders
only experimental data
calls to add
product bits a
calls because of
of binary moment
nonterminal node for
o n 4
of the variable
are labeled with
of the method
bits a i
one nonterminal node
the primary inputs
k x l
size of f
the low and
is a terminal
arithmetic functions with
the complexity of
of the chosen
topological order of
x k x
of node x
labeled with a
node for each
substitution of the
part of the
the size of
on the variable
the class of
the upper part
data has been
to the class
with respect to
formal verification of
2 with respect
2 lemma 4
in the variable
order for the
we can give
a formal proof
of f 0
i reaches its
primary inputs of
give classes of
non terminal node
multiplication of a
add calls because
circuits with binary
on the bmds
in bmd f
node with value
as can easily
by lambdab md
a b variable
each variable representing
sov structure as
reaches its final
substitution of node
diagrams for verifying
structure of f
space and o
a bmd for
backward construction the
we give classes
are named low
the final bmd
4 4 complexity
product bits into
multipliers is bounded
by the bmds
output lines of
diagonal line the
bmd f is
delta b j
verifying arithmetic circuits
product bit a
the variables representing
remains unchanged otherwise
starting bmd f
su and x
substitute the variables
product bits if
functions over boolean
node x by
with input word
terminal high successor
the chosen variable
by su the
during the substitution
the and gates

corpus/krapavin2000-test/608176.txt
tfi
automata
tla
hytech
acr
rm
abr
newrm
automaton
efi
ost
ela
aux
conformance
cell
coq
reception
snapshot
timed
cells
klay
emx
locations
monin
asap
transition
calife
atm
parametric
urgent
init
pi
modelling
invariants
verification
transitions
guard
action
rate
reachability
location
itu
upde
updal
dgcra
checking
stable
idle
auxiliary
inductive
ait
resp
ab
ideal
i3
prover
reaching
371
invariance
9a
zone
env
correctness
reachable
updag
connexions
rabadan
fertilizing
atcs
updatable
synchronized
assistant
proving
clock
moves
evolve
inv
proofs
algorithmic
protocol
arrival
hybrid
henceforth
subcases
incremental
checker
updated
discrete
gcra
aenv
alur
rnrt
endb
negociated
9b
telecom
delay
update
guards
forbidden
mechanical
invariant
admissible
events
henzinger
i2a
kronos
standardized
conjunct
move
assertional
i2b
atc
loca
updates
audio
human
subcase
floyd
vardi
transitivity
universal
flaws
dates
tactics
encoding
automated
specification
emitted
datalog
reacts
enriched
arithmetic
appendix
actions
modeled
constraint
rn
schedulers
unified
dataflow
scripts
hoare
viz
mechanically
checked
tool
months
discrepancy
convex
conjunction
reasoning
merits
life
france
tools
arrives
symbolic
reformulated
simultaneous
reaches
arrivals
proved
receiving
i1
1b
explain
qos
fruitful
generic
executions
gained
isdn
antoine
reformulating
updat
0also
subsidiarily
recasted
latters
uppaalmyampersandmdash
negociation
sttc
recapitulation
conformit
rouillard
davy
additionnaly
examplified
olufsen
confrontation
accurateness
paves
sertions
automa
bouyer
ambivalent
mentionned
endi
dufourd
p automata
rm cell
s tfi
acr t
tfi tla
p ost
p automaton
rm cells
b 0
abr conformance
tfi and
timed automata
an rm
model checking
property u
time s
rate acr
ab 0
stable locations
of abr
p constraint
in coq
current time
of acr
and tla
reaching tfi
ideal rate
ost q
of rm
proof methods
algorithm b
reception of
algorithm i
auxiliary properties
efi ela
q init
update relation
operation 9
conformance control
action move
discrete variables
a p
variable r
project calife
synchronized product
action moves
cell rate
universal clock
new rm
the reception
discrete variable
real time
reachability analysis
framework of
value e
verification of
s t
automated proof
s reaches
parametric timed
efi and
two proof
for abr
371 1
transition newrm
inductive invariance
inductive invariants
w ait
p zone
expected rate
the abr
a env
delay moves
i 371
reaches tfi
hybrid systems
reachable states
the ideal
automata and
of p
algorithm f
value r
theorem proving
of transitions
theorem prover
the user
a parametric
complete sequence
ideal algorithm
initial location
upon reception
the unified
the snapshot
the rate
e t
when s
the p
data cell
from less
has s
s becomes
location is
of hybrid
automata in
the proof
updated to
is updated
the reachable
time systems
s w
form evaluation
location less
correctness property
last rm
cell rates
of monin
product automaton
admissible state
rate value
delay move
received rm
proof assistant
cross fertilizing
standardized algorithm
newrm followed
france telecom
at current
automaton are
parametric real
by reachability
coq and
the standardized
automaton ab
performing 9
when current
an urgent
by invariance
convex constraint
is forbidden
cell reception
transition snapshot
guard s
snapshot action
clock s
monin and
hybrid automata
ela emx
and ela
conformance algorithm
monin klay
symbolic states
aux 0
hytech 14
emx r
and klay
modelling framework
tla and
tla when
tfi which
model checker
locations and
of locations
unified framework
a delay
of timed
automata a
a transition
be proved
by inductive
initial p
target location
9a or
becomes equal
19 18
rate e
greater and
p re
of project
and snapshot
the correctness
computation of
r k
algorithm called
parameter t
data cells
automata this
a compared
order functional
from location
snapshot from
of b
carried by
bit rate
conjunction of
time increases
an incremental
with p
receiving an
automata model
conformance of
of p automata
an rm cell
algorithm b 0
current time s
s tfi tla
a p automaton
of rm cells
of an rm
rate acr t
p ost q
tfi and tla
of acr t
of b 0
ideal rate acr
the ideal rate
p automata and
reception of an
ost q init
framework of p
with p automata
new rm cell
s tfi and
p automata in
of hybrid systems
the proof by
of p ost
unified framework of
two proof methods
of abr conformance
a new rm
parametric timed automata
the expected rate
the p automaton
the unified framework
i 371 1
the reachable states
complete sequence of
analysis of hybrid
all the reachable
upon reception of
of timed automata
the reception of
is updated to
the current time
real time systems
sequence of transitions
b 0 and
of parametric timed
computation of acr
ab 0 is
of monin klay
p automata model
p automata this
efi and ela
initial p constraint
closed form evaluation
algorithm for abr
universal clock s
model of monin
by inductive invariance
rm cell reception
if s tfi
and delay moves
efi ela emx
a convex constraint
time s becomes
time s reaches
newrm followed by
two stable locations
p automaton are
when current time
the product automaton
has s tfi
a p zone
the standardized algorithm
rm cells as
transition snapshot from
tfi which is
receiving an rm
monin and klay
a delay move
acr t as
algorithm i t
a universal clock
parametric real time
tfi tla when
last rm cell
of project calife
property u we
at current time
s becomes equal
the auxiliary properties
s reaches tfi
an update relation
framework of project
automaton ab 0
form evaluation for
of a p
is a p
of model checking
an algorithm called
the user is
of the system
in the framework
when s t
becomes equal to
a complete sequence
the value e
value e t
verification of real
h a 0
the framework of
of data cells
higher order functional
a discrete variable
correctness of algorithm
of algorithm b
in order to
the model of
section 7 1
s t in
the form h
a 0 i
had to be
to the ideal
to the user
when the current
to be proved
a theorem prover
order to implement
model of p
a 1 and
computation of p
model checking for
the maximum of
and a 2
as explained above
in our model
a higher order
the correctness of
0 was successfully
the abr conformance
p automata 8
transition newrm from
a p constraint
constraint s tfi
conformance control algorithm
of conformance control
if tfi tla
complete sequences of
list is complete
the allowed cell
newrm r snapshot
and is preserved
reasoning for concurrent
i2a i2b i3
ost q is
by reachability analysis
automata in coq
the correctness property
auxiliary variables efi
algorithm called due
called p automata
received rm cell
clock s the
of action move
implement the higher
mechanical verification of
the algorithmic analysis
value a of
algorithm of abr
as a fixed
when reaching tfi
called due to
assertional reasoning for
the synchronized product
preserved through any
automated proof checking
automaton are a
automata for modeling
datalog queries with
a compared study
i1 i2a i2b
tool suite for
to the modelling
standardized algorithm for
the respective merits
for datalog queries
like i algorithm
pairs t e
modelling of the
conformance of cells
be several hundreds
incremental abr conformance
a r then
rm cell with
form h a
inductive invariants and
of alur henzinger
as an international

corpus/krapavin2000-test/608242.txt
controllability
controllable
lie
subalgebra
ad
jordan
sachkov
subsec
metabelian
ls
sp
bj
diml
codimension
invariant
solvable
spectrum
algebra
jurdjevic
kupka
eigenvalues
ae
gamma
hypersurface
v1
eigenvalue
groups
semidirect
yu
gl
geometrically
sigma
bilinear
nilpotent
group
operator
matrix
subgroup
rank
adjoint
attainable
matrices
adbj
sallet
vectorfields
eigenspaces
subalgebras
oe
spaces
span
phi
proposition
saturation
corollary
algebras
lemma
commensurable
bonnard
complexification
gauthier
fi
sufficiency
ff
item
plane
why
coinciding
sec
kalman
quotient
violated
rb
6ae
iff
definiteness
root
virtue
nonzero
motions
hypotheses
bravo
blocksb
dimg
levi
cocompact
lawson
realification
mittenhuber
hilgert
lille
agrachev
subspace
conjugate
decomposition
connected
semi
purely
ayala
reductive
semigroups
preimage
sufficient
necessity
additionally
contradiction
globally
adjoined
compact
lemmas
fields
subspaces
analogously
russian
connectedness
z1
cos
determinant
0g
products
vector
cyclic
top
dirk
passage
dynamical
covering
omega
sin
affine
linearly
sl
tc
radical
subgroups
author
identity
raw
chain
chains
fft
nonnegative
theta
satisfied
remark
principle
corollaries
perturbations
jacobi
items
lim
cl
dimensional
1a
bases
subsection
professor
dim
psi
cone
euclidean
multiplicity
cz2
crouch
aw1
eigengalue
coresponding
erard
sussmann
cx1
0531
acces
sibility
fondamentale
assoudi
1079
bornard
complexifications
tirao
stipend
93b05
nonuniquely
17b20
polysystem
subsemigroup
subsemigroups
brockett
00805
homotheties
hautus
semisimple
operators
jth
spanned
ffl
inclusion
dc
homogeneous
geometric
base
x1
controllability of
right invariant
ad c
controllability conditions
system gamma
l 1
invariant systems
lie algebra
group g
operator ad
ls gamma
the lie
bj l
algebra l
controllable on
lie group
lie groups
of right
ae l
yu l
l sachkov
is controllable
simply connected
a 0
sp 1
ad bj
2 sp
c b
a lie
l 2
ad b
controllability condition
sufficient controllability
is why
gamma is
the group
a v1
rank controllability
in subsec
b a
subalgebra of
for controllability
codimension one
6 l
space l
c a
solvable lie
system sigma
groups g
conditions 1
the vector
vector b
g m
the operator
geometrically simple
eigenvalue a
conditions for
lie saturation
necessary controllability
i kupka
controllability on
v jurdjevic
span x
the matrix
gamma on
control systems
systems on
subsec 4
on g
hypersurface principle
gl n
0 ad
adjoint operator
attainable set
the controllability
jordan base
n pair
1 diml
not controllable
real n
r n
2 r
of ad
following conditions
lie algebras
the attainable
a codimension
gamma oe
the hypersurface
2 c
lie a
invariant system
root space
globally controllable
simple spectrum
its lie
one subalgebra
purely complex
diml 3
the jordan
v1 ad
2 ls
ae ls
lie subalgebra
the adjoint
theorem 1
6 0
top a
matrix a
a 2
of l
j a
in sec
sec 2
2 l
subsec 5
a has
the system
sigma is
vector a
lemma 3
suppose that
l containing
containing b
l ae
plane r
now we
in view
the rank
vector space
adbj l
spectrum sp
eigenspaces of
semi simple
jurdjevic and
v1 a
of controllability
jordan chain
remarks a
g sallet
kupka and
for lie
systems gamma
c bj
a jordan
cyclic spaces
bilinear system
metabelian lie
conditions 30
derived subalgebra
connected lie
invariant vector
kalman condition
for solvable
on solvable
compact group
the eigenvalue
n pairs
g with
e 2
of theorem
the spectrum
3 l
0 l
of definition
bilinear systems
ffl real
sp a
of eigenvalues
is globally
vector fields
single input
n theta
lemma 5
lemma 4
motions of
1 c
definition 3
the plane
finite dimensional
for simply
r ae
a ae
a l
theta n
the quotient
corollary 2
l 6
condition 6
the kalman
of motions
and condition
b 6
other cyclic
complex spectrum
mathematical control
coinciding with
input systems
simple lie
algebras l
ad c b
right invariant systems
b a 0
of right invariant
controllability of right
c b a
the system gamma
that is why
l 1 a
controllability conditions for
the group g
lie algebra l
the operator ad
yu l sachkov
system gamma is
sufficient controllability conditions
the lie algebra
ad bj l
gamma is controllable
group g m
bj l 1
is controllable on
c a 0
lie group g
of the operator
2 sp 1
ae l 1
the vector b
the rank controllability
a 2 sp
a system gamma
operator ad b
a lie group
l 1 c
rank controllability condition
0 l 2
space l 1
the system sigma
the matrix a
the following conditions
1 c a
of the lie
is not controllable
subalgebra of l
ls gamma oe
the attainable set
the hypersurface principle
invariant systems on
the adjoint operator
a 0 ad
necessary for controllability
0 ad c
adjoint operator ad
0 a v1
a 0 l
2 c a
on the group
a codimension one
a 6 0
6 l 1
in subsec 4
1 the matrix
of definition 3
then the system
the space l
lemma 5 1
gamma on g
a purely complex
codimension one subalgebra
groups g with
sigma is globally
for controllability of
1 diml 3
v1 ad c
top a a
lie a b
operator ad bj
has a purely
is globally controllable
operator ad c
right invariant system
conditions 1 2
lie groups g
controllability of the
solvable lie groups
of ad c
l 2 c
group g with
2 ls gamma
a v1 ad
ae ls gamma
bj l i
a l 2
a lie algebra
1 a j
3 l 2
a 2 c
of theorem 1
of the vector
l 2 r
in view of
a has a
the group of
f l 1
the vector a
has a nonzero
n theta n
l 6 l
2 l 1
any a 2
sp 1 is
attainable set a
l ae l
ad c bj
one subalgebra of
on a lie
kupka and g
simple and semi
the necessary controllability
and semi simple
controllable on r
of motions of
geometrically simple spectrum
system gamma on
group of motions
matrix m has
controllable on g
adbj l 1
1 is simple
c bj l
ad b a
necessary controllability conditions
and g sallet
v jurdjevic and
gl n r
2 in sec
the spectrum sp
the kalman condition
l 1 b
system sigma is
invariant vector fields
i kupka and
l 2 ff
a v1 a
proved in subsec
globally controllable on
for simply connected
exists a codimension
k y k
of ad bj
vector b in
l 1 ae
j a 2
on r n
in sec 2
l i 2
matrix a has
motions of the
the eigenvalue a
group g a
of l containing
following conditions hold
a 0 a
a j a
for the group
1 2 of
x k y
l 1 r
used in theorem
the plane r
1 a l
for any a
introduce the notation
conditions 1 3
theta n matrix
l 2 a
l 1 in
that l 1
of the group
of lemma 5
in subsec 3
with their derived
and i kupka
a used in
gamma 1 diml
have ls gamma
for lie groups
control systems on
controllability condition for
spaces of ad
not coinciding with
on solvable lie
1 a ae
hypotheses of this
a a v1
j p gauthier
jordan base of
bonnard v jurdjevic
the sufficient controllability
g e 2

corpus/krapavin2000-test/608323.txt
lopt
centres
cls
mwp
pmp
alt
centre
dec
entities
ssc
subproblems
subproblem
mladenovic
weber
entity
median
u1060
rvns
malt
dissimilarity
mwpm
optimum
quality
switzerland
allocated
hansen
cent
p654
brimberg
1963
allocation
cities
clustering
instances
diminishes
vehicle
1985
rosing
depot
beasley
pla85900
brd14051
vns
pcb3038
location
cooper
taillard
centroid
200
solutions
3c
decomposition
dissimilarities
optimally
haca
vns2
ch2863
2863
vnss
1000
glover
heuristic
greedy
solving
2b
allocate
succeeded
1983
proportion
2a
50
solved
160
1975
sg
3b
unused
neighbourhood
routing
sparc
900
1997
euclidean
facility
airports
brim
bongartz
weiszfeld
jura
1937
vns1
revelle
mwps
cantons
lakes
vns3
candidate
perturbation
1990
irregular
100
multisource
swiss
taboo
1060
1965
7000
hartigan
59
procedures
clusters
700
repetitions
300
quick
nearest
bubble
berg
tabu
originate
5a
opening
3a
perturbed
weighted
170
performances
gravity
empirically
article
800
5000
locating
10000
sort
lake
44
400
85
serviced
500
70
287
seconds
deterministic
5b
1996
meta
policy
grows
78
1500
88
averaged
1992
improving
heuristics
1993
distances
repeat
consuming
optimizes
multivariate
149
behaviour
weights
lem
workstation
improvements
estimated
position
81
prob
3000
positions
fleischmann
5242
dokmeci
ordez
improvedand
409677
lequel
peeters
4770
2597
bhaskaran
murtagh
85900
96330296
reinelt
mladenovi
255509536
3149
2796
niwattisyawong
schilling
wesolowsky
4658
mirchandani
9400
of centres
alt procedure
the centres
the alt
p median
and lopt
the mwp
a centre
dec 20
of entities
of dec
solution quality
20 50
computing time
the entities
entities allocated
the pmp
location allocation
of lopt
dec and
initial solution
computing times
the computing
candidate list
the lopt
p centres
for ssc
allocated to
the subproblems
centres and
best solutions
each centre
by dec
and mwp
lopt is
centres are
dec lopt
our cls
the ssc
of cls
20 200
mwp instances
the p
complexity of
o n
clustering problems
centres to
cls procedure
malt 100
dissimilarity measure
lopt 10
ssc and
cls 1000
greedy procedure
centroid clustering
list search
solution values
of subproblems
good solutions
p increases
vehicle routing
best solution
each subproblem
quality of
entities are
the solution
median problem
routing problems
diminishes as
the cls
centres for
cooper 1963
mladenovic and
per cent
and cls
for mwp
weber problem
with cls
of switzerland
subproblems solved
nearest centre
r centres
the complexity
10 200
10 50
for solving
solution known
instances with
time s
each entity
problem instances
as p
o p
step 2b
allocation procedure
centres in
lopt for
multi depot
mwp and
centres the
cls 100
subproblem i
pmp instances
brimberg et
brd14051 and
source weber
search cls
subproblem with
and mladenovic
p grows
50 lopt
solutions known
for pmp
lopt we
hansen and
t centres
times seconds
pmp the
lopt procedure
solutions than
heuristic methods
our methods
50 and
dynamic programming
sub problems
the centre
entities and
the optimum
this table
the allocation
centre is
multi source
local optimization
better solutions
at step
the quality
solutions of
step 2a
initial problem
sparc 10
entities with
decomposition methods
n p
methods for
procedure can
quick sort
optimum number
deterministic procedure
solving a
a solution
an entity
facility location
solving the
centres with
solution value
relatively uniform
s sparc
dec procedure
23 clusters
into 23
for lopt
mwp or
respective computing
step 3c
and pla85900
lopt diminishes
cent over
cls algorithm
rvns for
p entities
taillard 1996
optimum location
than dec
switzerland into
centres is
perturbed solution
centre the
lopt to
lopt method
pmp and
hansen mladenovic
entity i
depot vehicle
cls dec
and pmp
re location
quality time
from hansen
alt is
beasley 1985
centres can
and taillard
quality obtained
on sg
a pmp
we succeeded
of alt
mwp solution
centre on
ssc mwp
number of centres
the alt procedure
the p median
dec and lopt
the solution quality
entities allocated to
of the alt
dec 20 50
for the mwp
set of entities
the computing time
for the ssc
for the pmp
computing time of
the best solutions
p median problem
candidate list search
vehicle routing problems
as p increases
values of p
centroid clustering problems
of the entities
dec 20 200
to a centre
of subproblems solved
the computing times
of entities allocated
diminishes as p
for the p
the complexity of
o n p
a n b
better solutions than
p a n
times seconds on
solution quality of
a candidate list
the entities allocated
the lopt procedure
centres and the
p of centres
complexity of dec
list search cls
of dec and
best solutions known
obtained by dec
for mwp instances
the p centres
the centres are
alt procedure the
ssc and mwp
computing times seconds
brimberg et al
multi source weber
and lopt for
lopt 10 50
of the lopt
20 50 lopt
hansen and mladenovic
of dec 20
the quality of
the best solution
allocated to a
a complexity of
number of entities
heuristic methods for
best solution known
4 4 4
non deterministic procedure
the initial solution
optimum number of
problems with a
if the problem
the nearest centre
we succeeded in
s sparc 10
into 23 clusters
number of subproblems
location allocation problem
the optimum location
all the best
with our cls
multi depot vehicle
hansen mladenovic and
view is to
centres in the
lopt diminishes as
table 8 we
of centres to
computing times of
respective computing times
best solution values
of switzerland into
of centres the
of lopt is
depot vehicle routing
re location policy
and taillard 1996
centres can be
of cls 100
and the centres
very good solutions
of a centre
of cooper 1963
brd14051 and pla85900
succeeded in improving
of the centres
the greedy procedure
decomposition of switzerland
our cls procedure
complexity of lopt
an initial solution
originate from hansen
at step 2a
location allocation problems
alt and cls
p grows linearly
mladenovic and taillard
pmp and mwp
in per cent
time s sparc
solution quality obtained
in o t
for each centre
n p entities
quality time s
10 50 and
alt procedure to
entity i to
on an entity
per cent over
o n 2
number p of
of the literature
input set of
the entities are
with dynamic programming
by dynamic programming
with n the
of entities with
et al 1997
the problem is
seems to be
the initial problem
complexity of these
the entities and
this table we
a given solution
see e g
for solving the
able to find
and b 1
overall complexity of
linearly with n
the solution obtained
methods for large
to partition a
table we can
o p 2
complexity of o
the number of
in o n
us mention that
by solving a
of our methods
methods presented in
from this table
the overall complexity
has a complexity
quality of the
we have considered
of the methods
o n for
let us mention
of the solutions
large number of
2 5 2
the memory requirement
grows linearly with
solution to the
we have observed
is o n
a large number
we can conclude
a solution that
5 8 2
20 50 20
lopt 7 50
for ssc instances
instances with 50
time of dec
nearest centre for
solutions of similar
mwp instances brd14051
solution quality provided
to the perturbed
of entities of
for a unified
on entities set
computational results for

corpus/krapavin2000-test/608327.txt
wavelet
coe
deconvolution
noise
thresholding
subbands
deconvolved
equ
cients
satellite
image
transform
subband
erent
packet
noninformative
regularization
cwp
textures
snr
inhomogeneous
cient
gaussian
bayesian
rhea
regularizing
wavelets
di
variance
homogeneous
denoising
invariance
mle
covariance
nonquadratic
shift
restoration
inversion
estimation
deblurring
hyperprior
cnes
residual
tailed
fourier
psf
artefacts
areas
sharp
fig
rey
risk
law
prior
spot
selectivity
db
blur
signal
imaginary
images
estimate
transforms
adaptive
directional
kalifa
decimated
denoise
kingsbury
cwpt
noisy
french
ciently
approximate
exhibits
diagonalization
erentiate
su
filtering
agency
wiener
filters
separable
convolution
je
packets
heavy
filter
biorthogonal
dct
trees
reconstruction
enable
invariant
nearly
visually
exponent
estimator
hybrid
impulse
quadratic
improper
blurred
regularized
insu
minimax
supposed
frequency
attenuation
posed
directions
map
quad
priors
rotational
variational
doubling
accelerated
histogram
variances
bank
mes
scales
behaviour
decomposition
edges
orientations
ill
cosine
posterior
enabling
symmetry
drawback
unknown
spatial
symmlet
ecole
noisefree
amplifying
hyperparameters
decorrelate
assumimg
miroirs
restauration
invertable
undecimated
deconvolving
rivaz
econvolution
pix
ondelettes
attenuated
noninvertible
cmapx
128x128
mallat
cowpath
deconvolutions
nonregularized
magnitude
regions
rough
ome
amplified
une
diagonalized
mcmc
intermediately
decorrelated
bidimensional
amplifies
deconvolve
contaminates
polytechnique
donoho
directionally
usion
onboard
512
soft
inverse
separating
estimated
classical
recombined
unacceptably
satellites
dans
integrable
exempt
enables
redundancy
automatic
thresholded
dispersion
subsampled
amplification
reconstructs
penalizes
orientation
wavelet packet
complex wavelet
coe cients
the noise
approximate original
the deconvolved
di erent
original image
deconvolved noise
real wavelet
satellite image
coe cient
packet transform
homogeneous areas
residual noise
the coe
the wavelet
shift invariant
gaussian model
wavelet transform
parameter estimation
the approximate
the fourier
the map
the deconvolution
cwp transform
unknown coe
prior law
spot 5
wavelet thresholding
original coe
wavelet packets
shift invariance
the inhomogeneous
for satellite
approximate image
a wavelet
in homogeneous
cients of
proposed algorithm
the proposed
packet basis
satellite images
w r
the variance
the prior
transform is
each coe
frequency space
the transform
heavy tailed
thresholding the
wavelet based
each tree
deconvolved image
agency cnes
generalized gaussian
regularizing model
noise coe
space agency
regularization method
given subband
image deblurring
adaptive parameters
je rey
new transform
minimum risk
the nonquadratic
rey s
equ 19
the rhea
constant areas
rhea algorithm
french space
the subbands
complex wavelets
4 trees
thresholding technique
image deconvolution
detail subbands
see equ
equ 17
r t
the complex
e cient
the estimation
the covariance
the adaptive
directional selectivity
by equ
fourier space
homogeneous regions
the cwp
using equ
the signal
z j
the magnitude
wavelet coe
erent methods
hybrid technique
textures and
by fig
noise variance
into 4
the snr
quadratic model
the unknown
the residual
expression of
j k
we detail
between di
map estimate
estimate the
noise and
estimation is
invariance properties
areas which
the french
to enable
p k
image restoration
noise as
transform which
proposed method
a complex
transform of
observed data
the detail
s 2
independent in
to estimate
complete data
variance of
rotational invariance
and textures
nearly diagonal
bayesian thresholding
data mle
better directional
deconvolution algorithm
blurred and
homogeneous model
original complex
to denoise
known h
psf h
the hyperprior
inhomogeneous gaussian
noninformative prior
thresholding to
fully bayesian
automatic parameter
adaptive gaussian
erent subbands
with equ
preserve textures
each subband
strongly oriented
complex transform
packet decomposition
invariant real
also between
the subband
proposed complex
cient noise
variational method
noise remains
estimate x
the regularizing
wavelet domain
6 directions
invariant transforms
real separable
the noninformative
thresholding function
subband k
equ 20
mle is
behaviour even
transform exhibits
mes spot
deconvolution is
both signal
without regularization
cwpt of
soft thresholding
equ 21
real satellite
thresholding functions
erent trees
the mle
restoration by
variances s
the psf
the inversion
5 simulation
noise is
su ciently
the image
complex wavelet packet
approximate original image
the approximate original
the deconvolved noise
of the noise
wavelet packet transform
the coe cients
of the deconvolved
complex wavelet transform
w r t
the proposed algorithm
the unknown coe
the prior law
the wavelet packet
the residual noise
coe cients of
computing the map
z j k
each coe cient
of the approximate
expression of the
satellite image deconvolution
the noise coe
a complex wavelet
a given subband
the detail subbands
complex wavelet packets
je rey s
real wavelet packet
space agency cnes
the rhea algorithm
in homogeneous areas
the adaptive parameters
spot 5 simulation
the french space
the 4 trees
wavelet packet basis
satellite image deblurring
noise coe cients
french space agency
the fourier space
the frequency space
unknown coe cients
the complex wavelet
original coe cient
the approximate image
the expression of
the original image
in the wavelet
estimate the unknown
r t the
wavelet coe cients
di erent methods
between di erent
the proposed method
variance of the
the variance of
the estimation is
cients of the
in the fourier
model is used
divide by f
estimation is made
image of n
in homogeneous regions
the known h
signal and noise
using the known
wavelet thresholding to
the deconvolved image
histogram of a
transform is not
regularization and wavelet
the redundancy is
or imaginary part
wavelet based image
as seen on
by using equ
known h and
this new transform
behaviour even if
the noise as
di erent subbands
h and see
both signal and
the regularizing model
parameter estimation the
within a bayesian
for satellite images
cwp transform of
thresholding to obtain
compared to real
blurred and noisy
the original coe
thresholding technique we
using equ 19
the proposed complex
for the coe
estimate the adaptive
of n mes
seen on fig
have the prior
complete data mle
adaptive parameters of
model described by
n mes spot
adaptive gaussian model
rhea algorithm 11
thresholding functions are
homogeneous areas which
into 4 new
new complex wavelet
proposed algorithm consists
each subband k
of the inhomogeneous
and wavelet thresholding
variance s 2
di erent trees
residual noise of
original complex wavelet
described by equ
the inhomogeneous gaussian
for satellite image
a complex transform
by f h
the original complex
mes spot 5
a new hybrid
shift invariant real
automatic parameter estimation
from the noise
proposed complex wavelet
and also between
shift invariant transforms
variances s 2
original image x
inhomogeneous gaussian model
compute the variance
parameter estimation step
be nearly diagonal
wavelet packet decomposition
use a wavelet
of the rhea
equ 19 in
the di erent
used to estimate
parameters of the
to compute the
coe cient as
real or imaginary
trees a b
observed data and
the inversion process
the observation y
enabling one to
the noise is
the real or
when the estimation
the transform is
the textures and
the magnitude it
the observed image
by the french
noise as well
a wavelet based
the noise n
noise of the
imaginary part of
illustrated by fig
original image using
computation of k
heavy tailed distribution
the map estimate
in these areas
an e cient
is supposed to
possible to use
of complexity o
coe cient is
of each coe
the noise the
by doubling the
d j k
a new complex
are estimated by
the histogram of
the complete data
of the frequency
is why we
for parameter estimation
transform coe cients
to estimate the
proposed algorithm is
computationally e cient
are su ciently
independent in the
to enable a
the resulting image
on the magnitude
if we compute

corpus/krapavin2000-test/608350.txt
posterior
pac
bayesian
srm
stochastic
averaging
countable
gibbs
qjjp
concept
prior
density
uncountable
learning
trigram
dp
selection
theta
fi
stochastically
continuous
4m
training
guarantees
concepts
mdl
sample
bigram
nonzero
cq
vacuous
fit
barron
kuhn
tradeoff
hx
tucker
guarantee
smoothes
gjjh
langford
catoni
divergence
nearly
loss
feasible
suffices
lemma
mixture
distributions
probability
empirical
minimizing
inequality
yjx
unigram
delta
fits
smoothed
jensen
avrim
maximizing
warmuth
schapire
yi
goodness
kearns
expectation
densities
theorems
ffi
bonn
22nd
normalizing
compact
quantity
chernoff
leibler
mild
satisfying
kullback
selecting
blum
nondecreasing
estimation
trees
prediction
measurable
yang
differentiable
mixtures
weighted
induces
robert
classifiers
truth
du
formula
objective
tyerms
ffjp
lafferty
mcallester98
inequali
mugizi
matti
rajashekar
rwebangira
mincuts
renormalization
gjjf
laviolette
kriinen
classifier
bounds
quantities
minima
f0
ffl
constraint
rates
distribution
1g
subtrees
picks
ln
superior
majority
named
weighting
inspiring
marchand
arindam
regulariza
x2s
smoothing
classes
generalization
justified
pruning
enlarging
yishay
seeger
newspaper
letting
expert
risk
yoav
reddy
mansour
yamanishi
manfred
iid
xd
lection
sampling
parametric
probabilities
error
bias
singer
chervonenkis
tong
488
emphasizing
banff
analogous
generality
john
theoretically
germany
yoram
signifies
freund
vapnik
ith
fl
gradient
valued
416
infinitesimal
abbreviates
interval
decision
simplify
coefficients
exponentially
pittsburgh
ia
meir
classifications
23rd
divergent
instances
likelihood
settings
interpret
justifying
learnability
rb
model selection
stochastic model
pac bayesian
model averaging
f i
posterior distribution
the posterior
ffl f
b q
l theta
a pac
the prior
theta x
loss function
distribution on
a gibbs
concept classes
theorem 1
probability measure
on concepts
q fi
concept class
prior probability
prior distribution
l c
d qjjp
continuous concept
posterior distributions
the loss
measure on
sample s
feasible set
distribution q
vector theta
prior on
a concept
performance guarantee
a countable
performance guarantees
guarantees for
guarantee is
delta c
possibly uncountable
line guarantees
arbitrary prior
optimal posterior
countable concept
trigram model
simpler posterior
posterior q
concept c
the training
a sample
formula 1
training data
p l
following 8
gibbs distribution
concept f
is nonzero
density estimation
function l
for model
a bound
a posterior
empirical error
density p
each concept
follows where
a continuous
machine learning
the concept
for density
of theta
m instances
now suffices
compact feasible
continuous density
srm tradeoff
pairs hx
bigram model
countable class
fit well
arbitrary posterior
vacuous for
e cq
continuous model
on theta
the kuhn
averaging for
decision trees
following where
generalization error
lemma 1
probability distribution
loss of
at y
hx yi
description length
bayesian approach
objective function
distribution p
learning p
distribution d
for stochastic
on line
have that
error rates
active at
on machine
fi 0
constraint 10
first main
concept space
density on
l q
nearly optimal
minimizing the
main result
sample of
suffices to
posterior density
to distribution
kuhn tucker
second main
over fit
r n
a bayesian
an arbitrary
a prior
s inequality
c x
any probability
named by
on delta
a smoothed
class where
is vacuous
follows s
for continuous
error rate
continuous function
concept is
theta is
normalizing constant
a guarantee
a normalizing
of fi
learning algorithm
implies the
of theorem
bound on
any prior
error bounds
any assumption
define l
jensen s
the sample
parameter vector
selection algorithms
and compact
the pac
8 s
it now
f 3
a probability
to prove
guarantee for
of concepts
the expectation
q i
minimizing b
quantity d
give special
small divergence
following dp
delta satisfying
density h
drawn independently
continuous probability
there happens
maximizing subject
distribution g
gibbs posterior
divergence from
dp dp
concept distribution
proving lemma
prior a
unigram model
any posterior
loss l
bayesian mixture
constraint 12
uncountable continuous
or theorem
constraint 13
over exponentially
cq l
qjjp is
stochastic model selection
l theta x
a pac bayesian
ffl f i
theorem 1 is
loss function l
is a gibbs
l c x
the posterior distribution
have the following
the training data
on a possibly
for stochastic model
for model averaging
on line guarantees
a gibbs distribution
density p l
an arbitrary prior
a possibly uncountable
simpler posterior distributions
concept f i
the prior on
the following 8
continuous function of
sample of m
loss of the
a sample s
for density estimation
as follows where
main result of
we have the
2 f 3
p l is
the loss of
probability distribution on
probability measure on
i is zero
the following where
compact feasible set
guarantees for model
the density p
function of theta
theta x is
posterior distribution on
model selection algorithms
first main result
pairs hx yi
is vacuous for
prior probability measure
a countable class
it now suffices
countable class of
on theta is
model averaging for
distribution on delta
parameter vector theta
i is nonzero
concept class where
measure on concepts
the kuhn tucker
where each concept
prior on theta
theta 2 r
each concept is
follows where z
of m instances
vector theta 2
continuous concept classes
vacuous for continuous
performance guarantee is
now suffices to
a posterior distribution
pac bayesian approach
conference on machine
machine learning p
implies the following
on machine learning
a bound on
a continuous function
of the prior
the loss function
is a normalizing
second main result
that the posterior
the first main
for any prior
measure on a
closed and compact
1 f 2
f 1 f
f 2 f
as follows s
be active at
any probability distribution
the second main
is a continuous
f i is
error rate of
active at the
at the maximum
the feasible set
of the posterior
a concept class
truth of the
f i x
a normalizing constant
and the prior
jensen s inequality
of a bayesian
over the interval
a probability measure
the performance guarantee
goodness of fit
the error rate
p on a
on an arbitrary
where z is
on the models
r n and
to be the
can assume without
suffices to prove
of the concept
z is a
2 r n
small divergence from
of stochastic model
concept that fits
exponentially many different
cq l c
the quantity d
nearly optimal performance
on a concept
guarantees for deterministic
well against the
posterior distribution q
instances if the
like to give
consider a countable
an arbitrary posterior
line guarantees and
noted in 15
model selection algorithm
possibly uncountable set
against the optimal
on ffl f
a vector theta
that fits well
averaging for density
there happens to
concept distribution u
bigram model and
for fi 0
concepts f 1
measurable loss function
continuous probability density
the following 4m
provides a guarantee
3 17 9
all p i
prior distribution on
b q fi
define l c
that select a
following for any
been given by
superior to analogous
model selection a
class of concepts
a bayesian prior
i minimizing the
quantity d qjjp
or theorem 1
posterior is a
bound on each
loss of a
bayesian stochastic model
over exponentially many
f i this
fits the training
for any posterior
is nondecreasing over
smoothed trigram model
divergence from g
8 s note
pac bayesian stochastic
drawn independently according
on pairs hx
algorithms that select
multiple local minima
than stochastic model
and is continuous
model selection that
guarantee for stochastic
fi 0 k
minimizing b q
following 8 s
the constraint 10
a smoothed trigram
countable concept classes

corpus/krapavin2000-test/608351.txt
tls
vovk
warmuth
reinforcement
learning
episodic
forster
trial
regression
learner
outcomes
trials
gammay
temporal
td
episode
loss
lstd
thetan
pseudoinverse
discounted
prediction
signals
definite
barto
episodes
predictions
inv
invertible
morrison
sherman
bradtke
1jm
azoury
bounds
widrow
fl
outcome
gamman
schapire
discount
hoff
boyan
vectors
expectation
ridge
predictor
clipping
sutton
predict
predicts
clips
comparator
motivation
pseudoinverses
akwk
kwk
kivinen
instances
squares
1i
jm
sums
matrix
infimum
rk
profits
stochastic
semi
lie
proven
cy
norms
minus
clip
1997
logarithmically
foster
euclidean
equality
weight
beta
unknown
losses
1996
difference
1999
conjecture
grow
inequality
minimizes
lemma
inverse
gamma1
gradient
matrices
company
covariance
gamma
rahmen
flannery
merman
unclipped
teukolsky
rektorys
landern
stearns
doktorandenstipendium
bund
hochschulsonderprogramms
graps
9821087
duffy
herbster
gemeinsamen
4y
logarithmic
orthonormal
setting
ff
signal
relative
norm
exponentiated
cesa
nigel
saunders
gam
diction
regressor
bianchi
daad
hassibi
jurgen
convex
transforms
receive
worst
continuous
differences
yt
atr
hindsight
gammaq
interval
1998
corollary
tuned
fourier
dimensionality
walker
muth
manfred
introductory
arithmetic
formula
war
practitioner
converges
rate
alternate
rates
clipped
unpublished
square
theta
rescaling
xx
und
absolute
markov
tg
bx
interpret
recipes
des
supremum
assures
technical
divisible
month
inverses
f0g
1995
vector
substantially
advance
1985
wavelets
proofs
comparatively
policy
grows
tune
strategy
lengths
logs
shorter
really
em
relative loss
loss bounds
temporal difference
difference learning
tls algorithm
the tls
the outcomes
reinforcement signals
linear regression
the learner
trial t
r n
outcomes y
for temporal
gammay y
at trial
bounds for
total loss
forster and
k warmuth
j forster
loss 1
y t
and warmuth
vovk s
2 r
a 0
future reinforcement
a inv
a t
n thetan
best linear
trials 1
the instances
x t
order algorithm
the pseudoinverse
the loss
loss of
of trials
learning algorithm
interval gammay
for episodic
for linear
semi definite
through t
second order
of examples
m k
the prediction
the predictions
morrison formula
outcome y
1 gamman
vovk 1997
linear predictor
episodic learning
the sherman
regression algorithm
sherman morrison
the episodic
order algorithms
vectors x
positive semi
and barto
thetan is
the temporal
linear function
vector w
theorem 9
lemma a
same episode
azoury and
episodic setting
temporal least
new second
discount rate
discounted sum
algorithm td
predicts with
stochastic strategy
warmuth 1999
additional loss
are i
1 through
positive definite
the relative
case a
expectation of
the examples
i d
instances x
real interval
schapire and
pseudoinverse of
the expectation
gamma the
definite matrix
learning setting
invertible and
case relative
ridge regression
the reinforcement
of theorem
vector x
theorem 6
s t
d with
rate parameter
parameter fl
lie in
a gamma1
unknown distribution
reinforcement learning
line algorithm
x 0
instance vector
t might
lstd and
for vovk
1i jm
warmuth 1996
at trials
trials are
for trials
loss bound
discounted sums
in gammay
in vovk
td algorithm
consider temporal
algorithm minus
continuous setting
1jm 1jm
bradtke and
prediction b
gamman x
learner at
reinforcement signal
arbitrary sequences
into episodes
of tls
squares tls
minimizes 2
expected relative
clips the
t 2
theorem 3
corollary 6
the equality
t is
proven for
first inequality
weight vectors
follows from
then with
on line
consider linear
every vector
not invertible
the trials
widrow hoff
y lie
bound y
learning rates
order learning
predictor for
known relative
to know
6 1
examples in
and m
least squares
the learning
theta r
formula 2
parameter a
signal r
predict with
pseudoinverse a
an outcome
s prediction
9 1
lower bound
k s
to zero
n theta
0 then
y then
s linear
trials the
first order
sums of
i i
6 2
average case
any sequence
learning rate
fl 2
setting with
relative loss bounds
temporal difference learning
loss bounds for
the tls algorithm
for temporal difference
loss of the
the relative loss
2 r n
the outcomes y
bounds for temporal
total loss of
at trial t
forster and m
m k warmuth
and m k
j forster and
relative loss 1
for linear regression
the total loss
of the tls
the best linear
case a 0
the case a
future reinforcement signals
the loss of
i d with
outcomes y t
trials 1 through
1 through t
are i i
sequence of examples
loss 1 2
interval gammay y
that the outcomes
i i d
t 2 r
of the learner
r n thetan
if a 0
for a 0
with the predictions
sherman morrison formula
outcome y t
second order algorithm
the temporal difference
examples in r
the sherman morrison
best linear predictor
the future reinforcement
gammay y then
a 0 then
positive semi definite
r n theta
x 2 r
then with the
of the best
the expectation of
loss 1 3
pseudoinverse of a
for episodic learning
second order algorithms
morrison formula 2
real interval gammay
the reinforcement signals
difference learning setting
new second order
y then with
azoury and warmuth
schapire and warmuth
rate parameter fl
discount rate parameter
the examples are
temporal least squares
the same episode
the temporal least
case relative loss
and warmuth 1999
the real interval
lemma a 2
of examples in
theorem 6 1
a 0 we
bounds for the
for the case
theorem 9 1
n thetan is
the pseudoinverse of
algorithm for temporal
trial t is
the parameter a
bounds for linear
in r n
number of trials
n theta r
the instances are
vector x t
of a t
of the instances
x t 2
theorem 3 1
of the on
on line algorithm
of the relative
theorem 3 2
needs to know
expectation of the
unknown distribution on
instance vector x
a t might
algorithm the expectation
minimizes 2 2
in the episodic
the additional loss
the continuous setting
vovk s prediction
the expected relative
s 1 gamman
the episodic setting
first order algorithm
best linear function
gammay y and
reinforcement signal r
s linear regression
clips the prediction
1 gamman x
gamma the learner
that the instances
1 consider temporal
for the tls
and warmuth 1996
theorem 9 2
prediction b 0
t might not
arbitrary sequences of
linear regression algorithm
expected relative loss
vector w 2
sequences of examples
tls algorithm the
distribution on r
squares tls algorithm
vovk s linear
that minimizes 2
the trials are
lie in gammay
order learning algorithm
consider linear regression
that the loss
w 2 r
consider temporal difference
all vectors x
for trials 1
the learner at
order algorithm for
bradtke and barto
in gammay y
line algorithm minus
theta r such
second order learning
difference learning in
outcomes y lie
least squares tls
uses the weight
known relative loss
tls algorithm for
signal r t
difference learning with
algorithm minus the
by the pseudoinverse
relative loss bound
average case relative
vectors x 2
minus the total
formula 2 5
for vovk s
linear predictor for
at trials 1
of the outcomes
any sequence of
the first inequality
of the future
a t is
1 2 is
2 0 1
sequence of trials
to the learner
because of lemma
a 0 let
the pseudoinverse a
corollary 6 2
of theorem 9
y lie in
a t in
is not invertible
the on line
the weight vectors
for all vectors
r t 2
bound of theorem
if a t

corpus/krapavin2000-test/608352.txt
certifying
keerthi
qp
wd
int
wolfe
gilbert
convergence
svm
samples
chunking
working
indices
lanl
_
i2i
joachims
jv
3800
dual
gsmo
cristianini
anysubset
smo
optimality
chang
lp
ur
shawe
svms
rate
2000
bl
platt
nite
dened
cient
stepwise
sv
training
dene
properly
machines
decomposition
optimum
lin
modication
su
nished
vapnik
la
qpsolve
pairg
fdetermine
kkt
feasible
drive
criterion
taylor
dr
cortes
karush
dunn
zoutendijk
normalization
epsi
qw
regimes
denition
iterations
learning
nontrivial
convex
classier
kuhn
satises
rates
tucker
1998
polynomial
routine
ong
concave
motivates
rst
margin
1979
cancel
diers
classi
light
sample
barrier
constrained
edition
ordered
technical
slight
placing
00
equations
1467
1918
avriel
hush
serafini
zanghirati
parenthetic
jochamin
finitially
2549
etadoty
osuna
2543
4lc2m4
scovel
extremals
igel
glasmachers
steinwart
innitesimal
1492
performq
fsample
hsuen
zanni
betadoty
nikolas
qiao
algorithmic
excessive
specically
integral
jr
decomposing
concavity
gaetano
shevade
1466
1437
clint
bhattacharyya
soft
2001
decompose
guarantee
unspecied
pai
covariates
1889
jumped
unattractive
nonseparable
pass
1st
improvement
628
aw
hulls
fif
tobias
singular
terminates
optimiza
mercer
yg
769
skips
neglecting
637
733
iteration
asymptotic
converges
restricting
chooses
violate
hao
ingo
log
index
establish
dierence
gramming
kelly
1976
ulrich
thorsten
leveraging
rong
sqrt
303
syan
nishes
subscripted
improper
sorting
sort
preliminaries
ru
certifying pair
rate certifying
a certifying
v low
working set
i low
v high
low v
wolfe dual
wd s
d high
i high
qp problem
support vector
algorithm a
vector machines
for wd
properly ordered
working sets
i int
jv int
gilbert 2000
the wolfe
keerthi gilbert
high v
a rate
chang et
qp problems
certifying pairs
keerthi et
low i
for support
ordered for
each working
the certifying
o m
pair in
smaller qp
ur 00
la ur
00 3800
lanl technical
report la
high low
v i
log m
a 1
high and
m log
of convergence
al 2000
pair the
low and
of algorithm
its optimum
cristianini shawe
one certifying
stepwise improvement
certifying algorithm
taylor 2000
existing svm
certifying condition
svm algorithms
step convergence
lin 2000
joachims 1998
the anysubset
model algorithm
is properly
the working
su cient
of samples
al 2001
if jv
m light
sv m
low 0
the lp
samples in
convergence for
shawe taylor
high i
low low
m time
learning research
all samples
two indices
samples with
decomposition algorithms
technical report
the indices
into i
i2i high
in cristianini
smo algorithm
constrained wolfe
in keerthi
chunking algorithm
optimality using
nite step
anysubset routine
v int
i2i low
keerthi and
nontrivial components
gsmo algorithm
_ w
for stepwise
gives and
d low
the chunking
original qp
m operations
et al
polynomial time
a feasible
cient to
decomposition algorithm
int and
the criterion
a nite
the rate
of machine
in i
slight modication
using certifying
that low
int w
is nished
1 2006
v k
convergence rate
w c
of v
solution to
0 d
indices in
v l
for s
research 7
these equations
run time
index set
the v
the journal
the convergence
low high
w contains
optimality condition
indices for
k denote
12 1
problem s
current solution
to within
machine learning
solve a
not properly
to drive
pair then
of indices
data while
this interval
drive the
th iteration
q 2
many existing
open the
qw c
samples into
integral then
three regimes
linear classier
1st edition
leaves open
platt s
high where
that keerthi
al chang
for svm
cortes vapnik
3 optimality
sequential minimal
margin formulation
be excessive
remainder is
this increasing
z i2i
prove necessary
al keerthi
not integral
low g
feasible directions
the qp
2001 keerthi
overall run
guarantee progress
3800 3
methods 1st
training errors
algorithm a 1
a certifying pair
a rate certifying
rate certifying pair
support vector machines
for wd s
i low i
of algorithm a
the wolfe dual
for support vector
keerthi gilbert 2000
chang et al
certifying pair the
certifying pair in
keerthi et al
properly ordered for
each working set
ordered for s
is properly ordered
the certifying pair
m log m
lanl technical report
high v high
d high v
report la ur
low v low
la ur 00
ur 00 3800
smaller qp problems
high low v
technical report la
o m log
et al 2000
the working set
i high and
cristianini shawe taylor
for the wolfe
v high low
v low v
rate certifying algorithm
rate certifying condition
i high i
if jv int
existing svm algorithms
shawe taylor 2000
of its optimum
least one certifying
one certifying pair
contains a certifying
et al 2001
sv m light
journal of machine
machine learning research
index set of
of convergence for
the solution to
of machine learning
su cient to
a 1 where
in o m
the criterion to
nite step convergence
the v i
of v low
i int and
time bound on
using certifying pairs
algorithms for support
certifying pair for
low i i
problem s t
v low and
where the anysubset
model algorithm for
criterion to within
working set contains
where the working
qp problem into
the rate certifying
the chunking algorithm
is a rate
working sets that
jv int w
working set w
stepwise improvement of
for algorithm a
constrained wolfe dual
original qp problem
is not properly
of a rate
in i high
a model algorithm
certifying pair then
in i low
the original qp
not properly ordered
optimality using certifying
drive the criterion
in cristianini shawe
the anysubset routine
low i high
for stepwise improvement
with i 0
i low and
working set is
class of algorithms
the index set
v l l
w contains a
samples in i
polynomial time bound
2 by 2
let k denote
learning research 7
solve a sequence
research 7 p
12 1 2006
we provide a
the journal of
set of s
not clear that
case of algorithm
through the list
in this interval
log m time
number of samples
pass through the
1 where the
on the convergence
k th iteration
at least one
the current solution
components of d
if and only
and only if
at the k
have a solution
pair in the
number of iterations
and su cient
necessary and su
is a feasible
bound on the
s if and
that the certifying
increases by c
open the question
al 2001 keerthi
v k v
remainder is used
wd s if
v i from
certifying pair we
algorithm a 2
m light algorithm
one sample from
i from i
the karush kuhn
combinations of v
from k in
original problem solution
methods 1st edition
high 0 d
to implement 32
v int v
pair in o
et al keerthi
int low v
determine a certifying
normalization for r
negative at least
wolfe dual problem
cortes vapnik 1995
of training errors
decomposing the original
an appropriate normalization
this barrier can
classier in h
barrier can be
current solution plus
feasible _ w
subset of samples
within m of
vector machines the
m operations to
linear classier in
a nite step
d low 0
certifying pair i
with this value
samples with this
certifying pair dened
guarantee progress toward
high v low
conditions for stepwise
proof is nished
low v int
low and v
al keerthi gilbert
the working sets

corpus/krapavin2000-test/608356.txt
scenarios
scenario
backward
heitsch
romisch
ternary
stochastic
redistribution
k0
simultaneous
reduction
forward
rel
50050024
weekly
cardinality
selection
mourier
fortet
load
tree
168
index
branching
trees
proposition
144
attained
u2f1
l2f1
xed
deleted
distances
lipschitz
supp
convex
dened
probability
metric
subtree
ng
min
120
norm
numerical
regular
electrical
72
distance
jr
recommends
deletion
nondecreasing
minimal
specic
perturbations
96
nitely
fast
conceptual
satises
fu
fn
discretization
600
altogether
formula
prescribed
indices
jg
nomially
bmbf
iwith
hourly
nondierentiable
recommendable
stochasticity
reduktion
kantorovich
maxfj2
8149
displays10300
rom5b3
handbooks
szenariob
j280
accuracy
sorting
measures
hp
subtrees
mass
discrete
experience
motivates
nonlinearly
integrands
nfor
borel
minfd
favourable
9000
maxf
piecewise
rst
binary
48
running
ending
rubinstein
pected
flg
expense
shifted
nonempty
horizon
probabilities
minf
recourse
ux
lowing
mbyte
780
measure
deleting
qn
german
behaviour
dierence
determining
dirac
announced
balls
j2
729
stability
768
disregard
summands
programming
un
accurate
f0
fk
gorithms
conrms
management
gures
prices
summand
deeply
variant
seconds
closest
opposite
turns
ecient
endowed
kl
regularly
battery
ki
reducing
tests
kg
reformulated
continuous
exhibiting
lagrangian
fol
arg
conguration
modication
selecting
finitely
concept
k1
von
formulated
cf
formulas
quotient
duality
pessimistic
interpretation
atoms
ll
180
_
preferable
successors
hardly
closer
stable
tables
ects
propositions
dening
entering
fc
backward reduction
scenario tree
forward selection
fast forward
simultaneous backward
scenario reduction
stochastic programming
of scenario
index set
n scenarios
ternary scenario
heitsch romisch
rel c
reduction algorithms
scenario sets
in stochastic
probability measure
set j
redistribution rule
c time
scenario trees
time rel
binary scenario
load scenario
of scenarios
regular binary
probability measures
it holds
the redistribution
c c
of simultaneous
load process
72 96
168 figure
96 120
reduced probability
probability metric
144 168
tree reduction
50050024 48
the weekly
the index
z i
holds that
an index
120 144
48 72
stochastic programs
reduction of
n n
d j
of backward
running times
minimal distance
numerical experience
relative accuracy
proposition 3
r r
algorithms in
all algorithms
measure p
that j
the optimal
function c
backward of
simultaneous fast
distance scenarios
fast lower
bound distance
convex stochastic
minimal distances
rule 10
sets backward
forward bound
weekly electrical
power management
lower minimal
and ternary
1 redistribution
management model
regular ternary
all scenarios
number backward
electrical load
metric c
fortet mourier
xed cardinality
load tree
scenarios rel
containing n
algorithm 2
in case
level k
the scenarios
tree with
operations for
in 4
a regular
distances of
tree number
measure q
original scenario
with scenarios
backward forward
c distance
maximum norm
to scenario
minimal n
jr j
detail of
selection is
consists in
optimal reduction
r jr
branching points
initial probability
applies with
obtain for
the reduced
scenarios of
of fast
the backward
scenarios and
at level
is dened
a scenario
problem 11
of 11
step i
t r
z 1
for reducing
binary and
numerical tests
is attained
scenarios that
computational complexity
and reduced
a probability
the running
l i
called backward
remaining scenarios
scenarios hence
scenario generation
reduction concept
next scenario
mean shifted
optimal deletion
reduced measure
that heitsch
corresponding mean
non branching
fn n
i requires
considering subsets
test trees
backward type
deleted scenarios
supp p
reduced trees
u2f1 ng
reduced tree
cardinality in
a fortet
reduction heitsch
tree 50050024
redistribution by
ng z
conceptual algorithm
l2f1 ng
unit mass
selection works
scenarios or
having cardinality
formula 14
reduced subtrees
2 k0
optimal redistribution
shifted tree
i operations
reduced measures
fu un
reduction load
example 4
time table
running time
the tree
each j
holds for
tree is
we obtain
reduction and
when comparing
set fu
n holds
form min
k0 1
integer program
each scenario
fast forward selection
simultaneous backward reduction
in stochastic programming
reduction algorithms in
scenario reduction algorithms
algorithms in stochastic
rel c time
of scenario sets
index set j
ternary scenario tree
backward reduction of
the index set
c time rel
binary scenario tree
time rel c
reduction of scenario
c c c
the redistribution rule
load scenario tree
forward selection is
r r r
an index set
holds for each
the function c
50050024 48 72
scenario tree reduction
a regular binary
scenario tree with
120 144 168
at level k
72 96 120
96 120 144
of fast forward
48 72 96
144 168 figure
of backward reduction
the backward reduction
the relative accuracy
n 2 n
exists an index
in case that
scenario tree number
lower minimal n
simultaneous fast lower
fast lower minimal
weekly electrical load
binary and ternary
of simultaneous fast
case that j
tree number backward
a regular ternary
n of scenario
backward reduction is
redistribution rule 10
the weekly electrical
r jr j
scenarios rel c
backward of simultaneous
c time table
electrical load process
forward bound distance
distance scenarios rel
containing n 2
sets backward forward
minimal n of
power management model
number backward of
scenario sets backward
the forward selection
algorithm 2 4
of simultaneous backward
of the scenarios
bound distance scenarios
the maximum norm
backward forward bound
it holds that
it holds for
theorem 2 1
such that j
the optimal reduction
c distance of
we obtain for
proposition 3 1
i is dened
the minimal distance
algorithm 2 2
probability measure p
for the minimal
i 2 i
a probability measure
consists in the
the computational complexity
that the index
a solution of
in case of
proposition 3 2
for each j
discrete probability measure
scenario tree representing
dened in 11
i satises condition
1 binary scenario
any feasible q
in a power
tree and reduced
t r starting
detail of t
illustrates a detail
minimum is attained
that heitsch romisch
step i requires
using formula 14
the original scenario
u i satises
and ternary scenario
scenarios hence we
backward reduction load
n 1 redistribution
between a regular
representing the weekly
subset containing n
set fu un
solution let a
regular ternary scenario
considering subsets of
2 j there
the subtree t
all non branching
a scenario reduction
d min n
a reduced tree
is increasing with
reduced tree with
optimal reduction concept
subtree t r
general case too
fu un g
higher running times
of higher running
of scenario trees
the optimal redistribution
operations for determining
the reduced measure
1 redistribution by
2 applies with
n holds for
the c distance
load tree 50050024
conceptual algorithm called
reducing a set
mean shifted tree
slightly more accurate
redistribution by 10
consider the probability
non branching points
i operations for
index set fu
the tree consisting
the distance c
operations for selecting
holds that z
the corresponding mean
by considering subsets
called forward selection
that z i
ng z 1
the problem 11
a fortet mourier
j having cardinality
a power management
n scenarios to
a probability metric
reduced probability measures
case too 2
1 step i
subsets of j
scenarios to a
load process in
a scenario tree
and j that
and reduced subtrees
i step n
tree 50050024 48
the next scenario
reduced by deleting
reduction heitsch romisch
and fast forward
backward reduction and
called backward reduction
3 2 applies
corresponding mean shifted
2 n scenarios
result follows for
reduction and fast
for reducing a
set j such
optimal redistribution rule
scenario tree 0
z i step
the optimal deletion

corpus/krapavin2000-test/608456.txt
survival
regression
cv
risk
dippon
robustified
univariate
bandwidth
therapy
kernel
cancer
estimate
breast
observable
nonparametric
covariate
componentof
hn
pn
patient
validation
predictor
reasoning
pm
pt
bandwidths
neighborhoods
cross
ps
distance
ht
multivariate
age
estimated
jx
censored
patients
dh
stuttgart
ardle
3g
es
dn
statistical
influence
l2
averaging
estimates
tumor
fz
ms
gr
tick
robustification
resubstitution
nadaraya
menopause
7894
lymph
quart
scree
supremum
realizations
unknown
sample
bosch
ost
valley
f1
diagnosis
splitted
covariates
physician
categorical
status
ratios
validated
simulated
akaike
1964
h0
prediction
mn
loader
estimation
watson
plot
minimization
curse
simulations
marks
empirical
alive
stone
simplification
nominal
observed
minimal
norm
dg
missing
dotted
date
valued
determination
big
wants
component
plug
naive
article
fx
cutted
regresion
histological
simonoff
estrogene
tnm
quartile
missingg
robustify
distibution
8281
therapies
02610
20011
progesterone
f100
reponse
efjm
categorial
shibata
yng
sensitively
mariuzzi
menopausal
02610h
jmn
smooths
metastases
uncensored
3th
menachem
interquartile
krankenhaus
thatk
ey
82age
quartiles
wishing
carbonez
7932
kolodner
closely
estimator
seeks
d1
variance
suggested
samples
fy
1990
200g
censoring
ellipsoidal
1961
pursuit
refering
median
smoothing
fold
squared
axis
doesn
ffi
estimating
solid
column
withdrawal
penalizing
minimizes
1991
distances
identically
splits
coded
selection
scaling
dimensionality
fig
match
equals
underestimation
occurence
bandwith
1p
grading
accidental
dispense
coined
2 risk
survival time
case based
based reasoning
kernel estimate
e h
distance function
estimated l
observed survival
j dippon
dippon et
statistical approach
observable variables
to case
new case
cv h
bandwidth h
l 2
cross validation
the regression
the robustified
regression estimate
breast cancer
risk of
optimal bandwidth
h i
component 1
regression function
a statistical
robustified bandwidth
the observable
r d
distance functions
the bandwidth
pt pn
x componentof
regression estimates
univariate kernel
pn pm
bandwidth e
y jx
h 2
bandwidths e
function m
estimate of
h j
the l
nonparametric regression
is minimal
the therapy
pm es
cv function
the cv
local averaging
componentof component
es ps
l2 risk
of x
jx i
new problem
e y
cancer data
given new
by cross
m x
h 1
choose that
predictor variables
y i
estimate is
to breast
ms ht
the covariate
regression estimation
y component
ht pt
that distance
most similar
z j
most closely
2 3g
final result
n h
the univariate
a univariate
ps 0
cv 1
the optimal
a distance
a kernel
with values
closely match
component 2
the distance
a regression
time observed
that subset
the estimate
the kernel
f1 2
data dn
axis right
run left
column cross
new patient
univariate bandwidths
i solid
univariate regression
survival times
of breast
new predictor
d valued
h ardle
validation estimated
cancer patients
validated l2
norm distance
function dh
solid i
by tick
marks if
function cv
min oe
the survival
cross validated
tick marks
similar cases
multivariate kernel
bandwidth selection
column univariate
the multivariate
censored survival
i dotted
via cross
age ms
component j
influence on
r v
the predictor
if within
of univariate
the via
ae min
supremum norm
i depending
risk is
estimate with
dotted and
bandwidth such
x i
1 e
et al
1 of
the patient
in regression
2 f1
is close
of e
those cases
h 3
testing data
y fig
of observable
component x
the so
an estimate
0 5
left column
unknown distribution
date of
so called
by d
close to
right column
kernel function
valued random
simulation run
the estimated
n l
fx 1
the ratios
2 r
one wants
approach to
to x
realizations of
k cases
therapy a
gr es
deciding this
f0 3
decision which
suggested method
pm gr
h0 cv
akaike s
scree plot
of diagnosis
averaging estimate
appropriate therapy
l 2 risk
case based reasoning
to case based
approach to case
statistical approach to
dippon et al
j dippon et
estimated l 2
observed survival time
a statistical approach
2 risk of
the l 2
the optimal bandwidth
the observable variables
e h i
the regression function
and the robustified
optimal bandwidth h
component 1 of
the robustified bandwidth
bandwidth e h
robustified bandwidth e
e y jx
risk of the
bandwidth h i
e h 1
of x componentof
bandwidths e h
y jx i
1 of x
of e y
the distance function
e h j
estimate of e
of the observable
1 e h
y i s
h 2 r
a given new
the new case
x componentof component
the estimated l
pt pn pm
componentof component 1
the regression estimate
a kernel estimate
that distance function
the kernel estimate
a distance function
by cross validation
h 1 e
breast cancer data
f1 2 3g
of the regression
e h 2
univariate kernel estimate
l2 risk of
survival time observed
ht pt pn
es ps 0
to breast cancer
i 2 f1
pn pm es
in case based
d n l
most closely match
m n h
time observed survival
distance function which
distribution of x
the final result
most similar to
2 r d
2 f1 2
the new problem
h 2 e
column univariate kernel
marks if within
run left column
of breast cancer
left column cross
cv function cv
survival times of
j are indicated
given new case
estimate the l
simulation run left
cross validated l2
to choose that
based reasoning is
the survival time
jx i using
i is close
i the optimal
the bandwidth h
ae min oe
column cross validated
the via cross
kernel estimate with
times of breast
r d valued
of observable variables
y component 2
jx i depending
pm es ps
ms ht pt
of univariate bandwidths
solid i 2
2 risk is
validation estimated l
univariate bandwidths e
breast cancer patients
regression function m
h i solid
via cross validation
censored survival time
component 2 y
tick marks if
by tick marks
distance function dh
i solid i
cv h l
determination of univariate
unknown distribution of
right column univariate
realizations of x
axis right column
i dotted and
regression estimate of
the univariate regression
age ms ht
supremum norm distance
indicated by tick
choose that distance
kernel estimate of
bandwidth h j
x axis right
cross validation estimated
dotted and the
h i dotted
a new case
validated l2 risk
observable variables and
the bandwidth such
of the bandwidth
of x y
to the new
for the kernel
e h 3
of distance functions
i depending on
h j are
and to choose
h 3 for
on the bandwidth
regression function is
closely match a
the predictor variables
r p q
family of distance
if within the
is close to
the so called
influence on the
using the optimal
2 e h
is most similar
r v s
h j and
for which the
of the l
estimate of the
the y i
r d r
which is most
i using the
than the second
close to zero
of the simulated
one wants to
h i the
of the predictor
an estimate of
within the range
respect to h
x 2 in
distance function d
with values in
far away from
are indicated by
the second component
x i is
d j z
functions as parameters
cv h 0
of local averaging
plug in methods
n x ffi
risk of m
the twenty runs

corpus/krapavin2000-test/608626.txt
impedance
arm
torque
controller
controllers
macarena
matari
servo
jerk
joints
pd
joint
dof
motion
adonis
movements
elbow
ivaldi
mussa
postures
human
animation
primitives
posture
robotics
movement
hodgins
torques
shoulder
force
behaviors
cartesian
kinematics
articulated
manipulator
humanoid
angles
biological
pulse
tasks
agents
sub
motor
dance
arms
velocity
giszter
orientation
naturalness
your
velocities
stiffness
torso
field
qualitative
palm
hogan
williamson
maja
touch
unnatural
robot
damping
straight
hip
manipulators
jacobian
positions
collision
kluwer
wrist
bed
head
trajectory
collisions
body
rigid
1985
actuated
waist
schaal
frog
raibert
ribs
atkeson
neck
position
trajectories
simulation
task
effector
spacetime
imitation
damper
panne
locomotion
equilibrium
desired
spring
specification
dynamics
quantitative
1981
pai
1991
fields
constrain
moving
gravity
physically
inverse
1995
calculated
inspired
style
1982
leg
subtask
craig
1988
salisbury
lamouret
mataric
lapse
bizzi
imitate
pomplun
swinging
gaits
servos
hollerbach
ik
avoidance
sequencing
profiles
tradeoffs
mechanical
1992
interpolate
angle
smooth
1997
frames
revolute
dancing
totaling
wampler
legged
anthropomorphic
primitive
file
1980
appearance
virtual
superposition
solver
whitney
jessica
legs
1989
tuned
interpolation
orientations
finger
brien
encapsulating
watching
brady
aesthetic
flexibility
smoothness
activated
reaching
pulses
mason
specifying
move
forces
freedom
inspiration
touching
trends
robotic
people
1990
recorded
profile
simulated
walking
peak
timing
3d
workspace
metrics
tuning
baker
1983
hands
chose
coordinated
joint space
sub tasks
pd servo
the arm
sub task
matari c
the hand
torque field
the macarena
impedance controller
mussa ivaldi
the impedance
impedance control
the joints
force field
the pd
the controllers
hand to
m matari
via points
the torque
c et
the elbow
different controllers
human data
kluwer style
control of
the joint
style file
field controller
desired angles
hand position
three controllers
controllers and
inverse kinematics
end point
the controller
orientation of
naturalness of
of your
task specification
position and
control the
movements that
servo controller
space controllers
force fields
to control
controller is
the human
controllers are
hogan 1985
the arms
torques at
elbow and
controllers the
articulated agents
human movement
space torque
and impedance
jerk values
straight out
the torques
hand positions
in joint
arm motion
dynamic simulation
maja j
whole arm
ivaldi giszter
of movement
qualitative and
rigid body
human like
joint limits
hand movements
x desired
and quantitative
cartesian space
non linear
each sub
computer animation
test bed
upper arm
this controller
the head
and orientation
moving the
different types
robotics and
palm up
spring and
same macarena
ivaldi 1997
and damper
actual is
mechanical impedance
velocity profiles
hand tuning
space force
virtual spring
the frog
pai 1990
servo torque
complex articulated
torso simulation
space controller
hodgins et
controller use
humanoid torso
e sub
torque angle
dynamic simulations
actual gamma
macarena the
touch left
giszter 1992
the dance
frog s
the jerk
between sub
postures are
position control
desired position
and velocities
motor primitives
williamson 1996
pulse functions
combination approach
hand palm
cartesian impedance
c 1997
get posture
arm path
touch right
20 dof
the simulation
to generate
the jacobian
primitives for
back of
the different
the motion
controller the
the pulse
different control
from task
de panne
end effector
arm is
task 10
hand tuned
field approach
control in
the control
of control
control and
motion is
human motion
controllers for
the shoulder
avoid collisions
the movements
motor control
joints in
collision avoidance
behaviors for
force f
in cartesian
control for
the desired
more complex
constrain the
robot arm
controller has
of force
in robotics
and controller
and hand
set points
hand and
the inverse
the back
a force
reference frames
and animation
of sub
the cartesian
et al
performing the
low level
to task
a controller
of primitives
the force
physically based
angles and
in sub
of desired
al 1995
the pd servo
of the arm
the joint space
m matari c
the impedance controller
matari c et
c et al
kluwer style file
the torque field
torque field controller
the three controllers
orientation of the
of the hand
each sub task
pd servo controller
joint space controllers
the different controllers
the end point
at the joints
hand to the
qualitative and quantitative
position and orientation
mussa ivaldi giszter
right hand to
torques at the
the whole arm
naturalness of movement
joint space torque
the elbow and
of the arms
of the macarena
the arm motion
left hand to
the hand to
impedance control the
moving the hand
the back of
the upper arm
the inverse kinematics
different types of
and orientation of
pd servo torque
the hand position
between sub tasks
the torques at
touch left hand
virtual spring and
in sub task
use and flexibility
hand palm up
the frog s
complex articulated agents
i e sub
matari c 1997
controller use and
performing the macarena
from task to
of the controllers
touch right hand
the same macarena
ivaldi giszter 1992
spring and damper
of the elbow
controllers and the
space force field
joint space force
of sub tasks
hodgins et al
sub task 10
go to point
task to task
the desired position
mussa ivaldi 1997
e sub tasks
and the human
the arm is
van de panne
to control the
control of the
approach to control
the positions of
end point of
to the back
degrees of freedom
et al 1995
the position and
could be used
used to generate
the orientation of
applied to the
between the different
hand to your
hand to top
three different controllers
to top of
and x desired
arm can be
cartesian impedance control
force fields and
torque angle relationship
also been explored
sections 20 degrees
information is input
force field approach
between the controllers
for the pd
values per arm
shown do not
the 12 sub
stiffness of the
behavior decomposition is
a gaussian potential
time lapse image
the fundamental tradeoff
three controllers we
waist y z
controller has the
straight out palm
baker wampler ii
consisting of eight
y z 3
left torque field
matari c pomplun
types of controllers
1997 inspired by
primitives for movement
sub tasks as
control in computer
this desired force
dancing the macarena
controllers we implemented
the mechanical impedance
joint space control
arm straight out
sub tasks and
human performing the
work the primitives
a virtual spring
of impedance control
control the elbow
detailed specification of
simulation test bed
sub task 8
12 sub tasks
the hand from
of freedom wrist
eight rigid links
maja j matari
controllers the torque
wrist waist y
3 dof neck
actual is the
space pd servo
elbow and hand
humanoid torso simulation
velocity and jerk
of your ribs
force f is
x actual is
velocities for the
controllers pd servo
servo joint space
shoulder sub task
and controller use
pd servo and
same macarena sub
in joint space
panne lamouret 1995
angles of all
rigid body simulation
a torque angle
servo torque field
of basis behaviors
of control the
1995 van de
for human like
force field based
of your head
gamma desired actual
of force field
raibert hodgins 1991
the joints are
sub task of
tradeoffs involved in
joints of one
with revolute joints
merging mechanism for
side of your
the desired angles
natural for example
and pulse functions
field controller the
requires hand tuning
sub tasks were
8 rigid body
combination approach to
a time lapse
joint space controller
robotics and animation
non linear controllers

corpus/krapavin2000-test/608634.txt
agent
host
agents
specication
customized
connectors
functional
client
issarny
saridakis
dfs
architectural
web
connector
originator
declared
interaction
typeformat
server
specications
rpc
hosting
acceptance
adls
remote
policies
coordination
pcc
mobile
requested
prototype
middleware
conguration
declaration
typedsc
hostfileserver
ambients
architecture
rejection
port
hosts
software
notication
customization
resources
bindings
le
execution
matching
fs
resource
accept
ports
trust
format
authentication
requirements
specied
binding
typeint
matchinter
svce
leserver
intranet
nonfunctional
open
safely
accepting
denes
environment
csp
reception
ambient
assure
interactions
adl
characterizes
evaluates
verication
unavailability
dened
repository
compatibility
piece
servers
abstractly
promote
checkpoint
fd
mobility
dierent
informal
eld
dene
architectures
formal
customizing
instantiation
cient
assistant
verifying
java
execute
standpoint
benets
modular
characterize
gross
com
correctness
exposing
prominent
conforms
entity
retrieved
subdivided
benet
practicality
prover
threads
regarding
component
instantiate
exible
safety
instigate
agentsecuritymanager
sacricing
failureatomicity
conicts
ticated
securitymanager
5kb
matchfunc
inscape
nement
agentsecurity
matchports
aster
matchnonfunc
primitives
security
match
declarations
interfaces
dier
raise
supporting
signatures
possess
keys
availability
relieving
employment
somebody
approval
noties
closet
8c
conne
rections
signify
notied
omg
specica
hosted
dispose
approved
16kb
systematic
interacting
rst
checks
signicant
accepted
services
service
su
aims
describing
capabilities
requests
carrying
interface
environments
fdr
agrams
hostile
poli
cgi
damages
authen
denition
interconnection
read
subsection
behaviors
heavy
substitution
proposal
the agent
execution properties
the host
agent s
an agent
functional properties
non functional
host environment
web agents
architectural elements
host s
execution environment
remote execution
interaction properties
customized remote
software architecture
s requirements
issarny and
v issarny
t saridakis
s specication
s policies
typeformat format
s originator
of web
the client
the dfs
agent and
agent is
of agent
open software
s execution
formal specication
web agent
formal specications
agent based
the architectural
the execution
agent to
software architectures
declared by
the declared
the server
the open
a host
specication of
pattern matching
le server
open components
agent component
and connectors
accepting an
host agent
agent the
of agents
host is
execution of
using pattern
architectural description
with host
rejection is
declaration of
a software
customized to
specication the
the customized
a component
open architecture
a conguration
the acceptance
which dene
format functional
customized execution
functional property
specication matching
properties should
mobile ambients
server typeformat
client typeformat
software repository
typedsc fd
environment customized
agent that
to agent
our prototype
agent in
agent can
architecture which
a connector
of rejection
client component
host can
declared in
acceptance of
policies and
functional and
resource management
of ports
given agent
requested by
the functional
description of
our web
matching techniques
agents a
an rpc
reason of
properties which
web servers
components and
provided by
mobile agents
the associated
properties are
properties that
the coordination
and interaction
agents and
the software
evaluates to
s code
host to
its interface
of architectural
this function
to true
specied in
to assure
the declaration
the correctness
components agent
host hence
component providing
server non
close typedsc
agent specication
open component
connectors declared
available architectural
0 match
conguration made
requirements regarding
except from
fd interaction
explicit declaration
middleware customization
elements available
o agent
connectors svce
connector is
agent x
bindings among
host according
logic e
web s
agents 11
host does
client com
interaction open
typeint close
agent characteristics
close read
matchinter i
functional interaction
gross organization
software agent
c client
format server
server interaction
port client
trust issues
service binding
modular constructions
dfs architecture
dfs binding
mobile assistant
if functional
server checks
binding same
interaction points
instantiation process
coordination processes
associated execution
agent denote
declared operations
those declared
coordination process
conforms with
accept an
associated key
formally specifying
properties requirements
originator and
functional typeint
operation signatures
safely accept
svce service
agents 15
the connectors
functional non
the agent s
the host environment
non functional properties
the execution properties
agent s requirements
of web agents
remote execution of
execution of web
customized remote execution
agent s execution
and t saridakis
issarny and t
v issarny and
of an agent
agent s specication
host s policies
by the host
agent s originator
the architectural elements
the host is
formal specication of
of the agent
the execution environment
of agent s
for the agent
agent based on
an agent s
from the host
by the architectural
using pattern matching
components and connectors
with host s
accepting an agent
functional properties are
of execution properties
s execution properties
execution properties that
and non functional
to the agent
agent and the
the agent is
this function can
by the agent
to true if
the acceptance of
architectural elements and
if the host
the agent component
execute the agent
specied in terms
open components and
functional and interaction
execution environment is
client typeformat format
declared in its
environment customized to
the open components
of architectural elements
agent s code
open software architectures
open software architecture
sends the agent
typeformat format functional
and interaction properties
the customized execution
on pattern matching
s policies and
customized execution environment
reason of rejection
of rejection is
server typeformat format
the client component
implemented using pattern
acceptance of an
the formal specication
an agent the
of non functional
provided by the
of the host
a i h
the reason of
the software architecture
agent can be
with the host
of the dfs
set of ports
the functional properties
the host s
evaluates to true
agent is a
in its interface
an agent that
the agent and
an agent to
if the agent
and the host
s requirements and
by an agent
be implemented using
piece of code
in the host
on the host
in terms of
true if the
the declaration of
are provided by
of the client
c this function
s specication the
specication the host
by host to
functional typeint close
the host does
service binding same
connectors declared by
correctness of component
execution properties and
gross organization of
open close read
environment to meet
on trust issues
close typedsc fd
functional properties like
characterize a unit
functional properties which
conguration made of
description of agent
to accept an
correctness of bindings
elements and resources
on the acceptance
declared by agent
binding in figure
host is able
required and provided
specication of an
of formal specications
a conguration made
agent if the
accept the agent
host environment the
a software agent
e g authentication
acceptable for the
the host however
close read write
properties should be
the associated execution
connectors svce service
typeint close typedsc
interaction properties should
non functional and
which the agent
architectural elements the
architecture description languages
interaction and non
description of open
are specied in
execute to completion
the gross organization
an rpc protocol
typedsc fd interaction
binding same as
an agent whose
pattern matching however
based on trust
safely accept and
functional properties it
agent denote respectively
server non functional
upon the reception
if the reason
declared by c
an open software
on available architectural
host agent denote
the host hence
the communication protocols
given agent is
to the declared
s requirements with
a le server
functional non functional
that are provided
dfs binding in
the host according
client server interaction
and coordination processes
for customized remote
explicit declaration of
properties which characterize
any non functional
possess a component
memory and disk
port client typeformat
svce service binding
except from the
same as dfs
format server typeformat
a component providing

corpus/krapavin2000-test/608635.txt
commitment
commitments
agents
auctioneer
compliance
fish
multiagent
bidder
creditor
agent
debtor
metacommitments
discharge
protocols
bid
aamas
autonomous
protocol
causality
price
delegate
singh
munindar
bidders
mq
venkatraman
tex
messages
market
message
metacommitment
quasimodel
noncompliant
observer
money
coordination
yolum
release
cancel
parties
participating
ctl
commerce
violation
committed
yes
interactions
joint
party
announces
irrevocable
discharged
messaging
timestamp
temporal
b1
reasoning
interaction
authority
social
web
02
sell
he
timestamps
skeleton
causal
netherlands
meanings
act
behaviors
mallya
takers
wronged
ashok
pathsae
pnar
pinar
supply
commit
electronic
ag
heterogeneity
abbreviation
phi
proposition
propositions
autonomy
events
event
ordinarily
guerin
sigecom
spoiled
entail
testing
actions
logics
gamma
assign
specifications
skeletons
commits
guilty
auctions
meaningfully
bologna
rationality
synthesizing
heterogeneous
received
pending
resolved
clock
bucket
feng
open
eventually
obeying
wan
meaning
pitt
blowup
specifi
tokens
behave
tells
checking
logic
proto
bnf
lowers
multiparty
tems
specification
intentions
comply
abbreviates
pool
customary
functioning
anyone
ultimately
fourth
1999
create
monolithic
beliefs
resolves
who
specifying
jeremy
authenticated
iis
rational
observations
action
subtle
meta
designs
concrete
designers
manipulated
totally
community
reflecting
says
quantification
authentication
created
sys
executions
deals
inform
b2
flexible
hagent
adver
pagespace
ordination
jure
fmessageg
systemic
l12
9529179
l15
pliance
justifiable
naur
afdom
conceptsae
interoperation
gq
rethinking
m5
contractual
legitimizes
trueuq
sential
pathae
the auctioneer
commitment protocols
the fish
a commitment
the agents
the commitment
multiagent systems
the creditor
autonomous agents
commitment c
fish market
the debtor
with commitment
multiagent system
market protocol
the commitments
compliance with
aamas tex
no v
02 1999
16 40
on commitments
the bidder
tex 20
40 no
20 02
an agent
1999 16
potential causality
a bidder
the multiagent
agents and
p singh
munindar p
and multiagent
price if
participating agents
venkatraman singh
on autonomous
local models
commitment to
in open
international joint
joint conference
committed to
v compliance
commitment protocol
the messages
agents may
base level
of agents
agent systems
model checking
commitment is
commitments in
the participating
if he
discharge the
fish if
fish at
is noncompliant
auctioneer is
says yes
compliance testing
commitments are
systems july
agent communication
the price
z c
fourth international
temporal logic
agents are
multi agent
agents in
compliance of
action c
in violation
the compliance
the agent
x c
of multiagent
open systems
2005 the
global model
the message
the given
29 2005
a multiagent
single message
electronic commerce
a model
operations on
agents is
the parties
the protocol
member agents
proposition meaning
auctioneer a
few constraints
message patterns
technical framework
discharge x
compliance can
level commitments
feng wan
or assign
the bidders
delegate x
money i
commitments that
testing compliance
auctioneer and
bidder says
a quasimodel
create x
their evidence
protocol example
a metacommitment
delegate or
debtor to
the discharge
performed by
meaning the
a protocol
the web
to z
each agent
agent can
message it
agents another
assign y
communication languages
and heterogeneity
pool their
the autonomy
of fish
compliance in
some agents
message pattern
july 25
our approach
l gamma
g p
supply the
yes the
price i
the applicable
abbreviation for
agents must
autonomy and
bucket of
25 29
the observations
an abbreviation
causality and
the observer
y z
distributed computing
the netherlands
protocols are
message m
the protocols
true in
much attention
the present
an open
the fourth
to coordinate
behaviors of
agents the
multi party
a state
the proposition
message from
protocols in
and multi
bidder in
u mallya
he gets
patterns constructed
commitments proceedings
for meaning
new creditor
level commitment
commitments as
will sell
ordered communication
heterogeneous autonomous
via commitments
any observer
agents commitments
compliance checking
bidder is
interactions nor
commitments among
using commitments
bid for
is discharged
discharged if
bidder b1
with commitment protocols
compliance with commitment
the fish market
fish market protocol
autonomous agents and
40 no v
aamas tex 20
16 40 no
tex 20 02
20 02 1999
02 1999 16
1999 16 40
and multiagent systems
munindar p singh
on autonomous agents
conference on autonomous
the multiagent system
the commitment c
operations on commitments
the participating agents
international joint conference
agents and multiagent
joint conference on
of the agents
v compliance with
no v compliance
that the agents
multi agent systems
multiagent systems july
in the fish
the auctioneer is
the fish if
a commitment protocol
by the debtor
the fourth international
performed by the
a commitment to
systems july 25
fourth international joint
2005 the netherlands
29 2005 the
25 29 2005
of the fourth
in an open
july 25 29
create x c
autonomy and heterogeneity
delegate x z
says yes the
approach for testing
x z c
the commitment to
yes the auctioneer
of the commitments
in the multiagent
bucket of fish
assign y z
compliance can be
fish if he
in open systems
delegate or assign
a commitment c
commitment to z
the price if
discharge the commitment
discharge x c
base level commitments
few constraints on
bidder says yes
y z c
agents and multi
agent systems v
of the message
and multi agent
be performed by
the agents are
agent communication languages
on the agents
the autonomy and
a single message
of the messages
an abbreviation for
of the participating
distributed computing and
proof from theorem
of an agent
theorem 2 and
the construction of
proceedings of the
an approach for
hold and p
m i creates
resolved through a
to discharge the
this action c
independence of their
c to z
c and message
from the debtor
of local models
commitment c and
if message m
commitments proceedings of
the observer is
meanings of formulas
feng wan munindar
to verify compliance
q and abbreviates
debtor to the
debtor creditor context
given multiagent system
given state q
action c usually
c debtor creditor
commitment c it
the new creditor
causality and temporal
the fish is
the price in
the creditor to
that the creditor
ashok u mallya
commitment protocols in
the main reasoning
various operations on
discharged if ag
a unique yes
wan munindar p
agents are not
created or manipulated
q will eventually
patterns constructed for
the given multiagent
compliance based on
one bidder says
open multiagent systems
compliance in open
eventually hold and
the agents commitments
when the observer
committed to the
auctioneer and a
in a multiagent
commitments that the
observer s model
the debtor to
in violation if
c discharge x
from each observer
of potential causality
commitment c is
will eventually hold
meaning the fish
yolum munindar p
c usually holds
g p at
is committed to
and a bidder
of multi party
the message patterns
with few constraints
whether the auctioneer
performed on c
reflecting the independence
for price i
auctioneer is noncompliant
auctioneer announces the
compliance checking procedure
multiagent system is
and temporal logic
p proof from
tells us which
0 c holds
protocol our approach
of fish at
j for price
the same context
the compliance checking
creates commitment c
the bidder does
i creates commitment
all the commitments
logics of program
heterogeneous autonomous agents
the applicable metacommitments
by any observer
of any commitments
functioning of open
violation if he
base level commitment
potential causality is
through a release
of mq the
same context and
the given protocol
the given commitment
application of causality
market protocol example
bid is received
lowers the price

corpus/krapavin2000-test/608643.txt
agent
fipa
acl
veriable
verication
semantics
agents
kqml
speech
hearer
wooldridge
speaker
sl
acls
semantic
respecting
acts
ks
modal
believes
act
conformance
dene
message
beliefs
ungrounded
logic
language
autonomous
dened
quantied
performative
propositional
kif
veriability
performatives
cando
formulae
cohen
austin
mcburney
logics
communication
request
sender
denes
levesque
sincere
attitudes
parsons
eect
inform
recognised
denition
perrault
commissives
sincerity
frameworks
desires
standards
grounded
rational
multiagent
temporal
action
specication
simon
michael
pr
checking
recipient
content
spkr
lprolog
searle
labrou
formula
97
kripke
belief
article
addr
sending
propositions
program
messages
finin
utterances
tea
recognise
wants
classical
falsity
operability
rst
desire
ag
logical
intention
denitions
preparatory
actions
languages
planning
dialogue
truth
conform
mental
informing
satised
commerce
indistinguishable
characterise
annotations
practically
perlocutionary
draa
felicity
1990s
aairs
maudet
intending
mentalistic
rogier
chaib
illocutionary
eijk
p46
kse
syntax
connective
joint
decidable
york
ontology
jl
price
dening
demonstrating
commitment
stand
programs
peter
paradigm
attributing
standardised
believe
signicant
uncertain
preconditions
began
social
consequence
grounding
arti
verifying
communicate
eects
identied
np
jj
species
war
commitments
phrased
sends
unlikely
satises
feasibility
referring
requesting
verbs
exchanging
pre
intentions
verifiable
nite
uncertainties
unsolved
theoretic
saying
declaring
strange
argumentation
encodes
enjoys
readings
branching
promising
receiver
claims
van
hoare
send
dierent
successful
harder
equivalently
richer
characterised
agent communication
an agent
speech acts
the semantics
the fipa
communication language
semantic language
l s
communication framework
state l
semantics of
agent program
respecting the
language l
in agent
logical consequence
michael wooldridge
l c
semantic issues
fipa 97
model checking
autonomous agents
of speech
framework f
fipa acl
semantics for
multi agent
communication languages
program semantics
is veriable
an acl
dene what
the speaker
program i
agent systems
in state
multi modal
classical propositional
a message
is respecting
quantied multi
of l
cohen and
formulae of
the request
for agent
propositional logic
semantics are
a program
agents and
l 0
simon parsons
speaker to
peter mcburney
practically veriable
paradigm case
the hearer
be respecting
rational eect
verication problem
proof problem
the program
the sender
issues in
agent is
the semantic
on autonomous
modal logic
dene the
it believes
checking approaches
the act
mcburney simon
temporal logic
f 1
in sending
proof theoretic
a communication
agent i
and multiagent
international joint
formula of
of agent
multiagent systems
the message
program satises
acl semantics
semantic function
and perrault
be veriable
kqml and
want pr
must believe
speech act
believes it
agent programs
97 acl
cando pr
communication frameworks
conformance testing
speaker must
propositions that
the rational
of propositions
of agents
joint conference
a formula
ks ks
beliefs desires
with annotations
knowledge theory
belief desire
that program
what it
when in
sender of
agent will
a semantics
agents communicate
program in
the beliefs
for members
it wants
i l
whether or
the communication
it means
respect the
pre conditions
the truth
attitudes such
and finin
a veriable
request act
language sl
dened syntax
s believe
fipa semantics
intention logics
believe s
successful completion
acl is
kripke semantics
hearer to
of kqml
that hearer
that send
o conditions
hearer is
labrou and
logic l
modal connective
veriable and
perform action
preparatory conditions
veriable in
of sl
a quantied
for quantied
precisely dene
and levesque
rational action
acl standard
physical actions
0 logical
means for
reduces to
well dened
to stand
the agent
w l
sends a
world in
co np
this article
that agents
indistinguishable from
dened in
l i
formal framework
np complete
grounded semantics
by programs
semantics where
arbitrary programs
an inform
based theory
desire intention
veriable i
plan based
falsity of
recognise that
classical rst
desires and
stand for
semantics is
eect of
the world
a semantic
the content
the semantics of
in agent communication
of speech acts
semantic issues in
language l s
respecting the semantics
an agent communication
in state l
agent communication framework
issues in agent
an agent program
the fipa 97
the semantic language
communication language l
the communication language
of l s
autonomous agents and
of l c
classical propositional logic
semantics of l
multi agent systems
quantied multi modal
semantic language l
a communication language
theory of speech
language l c
is respecting the
the fipa acl
agent communication languages
means for an
multi modal logic
dene what it
model checking approaches
logical consequence of
be respecting the
a semantic language
the rational eect
it means for
conference on autonomous
on autonomous agents
semantics of the
determine whether or
that the sender
what it means
peter mcburney simon
when in state
mcburney simon parsons
international joint conference
agents and multiagent
and multiagent systems
whether an agent
an agent will
a formula of
agent communication language
joint conference on
agent communication frameworks
of propositions that
that the hearer
of that program
set of propositions
fipa 97 acl
a program semantics
rational eect of
dene the semantics
to the fipa
state l we
the world in
stand for members
done in time
cohen and perrault
the program semantics
agent program i
to be veriable
of the request
sends a message
of an agent
the sender of
for members of
whether or not
an agent is
of a program
a well dened
co np complete
if an agent
semantics of a
to stand for
that the semantics
labrou and finin
or falsity of
verication problem is
l s then
a modal connective
formulae of classical
well dened syntax
the request act
framework f 2
dened syntax and
the successful completion
desire intention logics
0 logical consequence
with annotations to
formula of l
a logical consequence
the truth or
program i has
agent is respecting
the fipa semantics
i o conditions
to perform action
successful completion of
claims to conform
a quantied multi
communication language semantics
of the fipa
l 0 logical
must believe that
plan based theory
classical rst order
agents communicate by
the speaker must
if it believes
respect the semantics
of the act
that claims to
cohen and levesque
annotations to stand
of classical propositional
attitudes such as
speaker must believe
a proof problem
propositional logic l
of agent communication
logic l 0
semantics are given
the program satises
agent systems v
agents and multi
of a message
of the communication
the properties of
of the message
is in state
to the semantics
and multi agent
language such as
be done in
the semantics for
dened in terms
f 1 is
that a program
in the fipa
m i l
l c are
beliefs desires and
based theory of
the speaker to
belief desire intention
semantics for agent
is a modal
an agent i
normal i o
that allows us
of the program
that the program
pre and post
sender of the
eect of a
this message is
truth or falsity
for l s
idea is that
reduces to a
for agent communication
for an agent
as a formula
the sender is
terms of a
in time o
most important of
to conform to
rst order logic
in terms of
in order that
of f 1
the idea is
semantics can be
of model checking
and post conditions
the problem of
a semantics for
it sends a
of a communication
able to perform
l c semantic
the plan based
multi agent scenarios
an l s
i knows are
about a state
message must satisfy

corpus/krapavin2000-test/608645.txt
qpa
umdl
auction
agents
sellers
strategic
buyers
agent
seller
market
ss
offer
sss
profit
sell
clearing
profits
buyer
bbss
bids
price
multiagent
buy
mc
strategy
ssss
cp
bbs
bss
zi
bs
bid
bbbss
standing
fm
bbbs
bbbbss
bbsss
prices
auctions
durfee
markup
bsss
bbbbs
zlotkin
rosenschein
vickery
matches
offers
social
inefficiency
goods
incentive
surplus
bbbbbsss
bbbbsss
bbbbbss
bbbbbs
bbbsss
efficiency
session
society
smart
designers
services
arrival
dynamics
societies
wellman
bidding
sandholm
emergent
economy
quote
1996
self
decreases
qpas
bbbbbssss
bbbssss
bbssss
bssss
gode
sunder
outsmart
evolve
collective
laws
negotiation
submits
arrives
tradeoffs
payoffs
birmingham
sharply
match
reasoning
submit
double
library
sms
honestly
economies
thinking
seeking
allocation
probabilities
beneficial
designing
1993
architects
competing
valuations
mechanism
matched
population
inefficient
michigan
contracts
digital
settings
reservation
who
interval
populations
game
lowest
utility
trading
gets
highest
service
advantages
success
b2
transaction
simpler
auctionbot
ubiquitousprovides
seller6
uia
ossowski
bbbbssss
brafman
seller2
100300500sessionsessionsessionsessionsess
reassuring
extrememaking
bbbbsssss
chaudhury
barbour
seller7
backfire
mullen
buttner
bbbsssss
seize
hasn
misrepresenting
sssss
markups
9411287
seller3
seller4
uias
bbsssss
buye
tennenholtz
1095
vain
service_high
ionsess
rust
misrepresentation
kicked
santanu
bbbbbsssss
traders
exerting
seller5
cera
sascha
rackham
failurefailure
bsssss
seller1
hiranmay
school_science
incorrect
seconds
participants
preventing
participating
rs
unrealistic
encounter
conventions
strategies
transition
expect
p strategy
the umdl
the auction
p qpa
the p
strategy agents
cp qpa
umdl auction
strategic agents
the mc
fm qpa
strategy agent
qpa and
the clearing
buyers and
self interested
the offer
mc model
clearing price
profits of
market efficiency
other agents
and sellers
the profit
umdl system
offer price
the cp
zi qpa
interested agents
the market
agents to
its offer
strategic reasoning
umdl is
total profit
multiagent system
of buyers
an agent
profit of
agents use
umdl service
the fm
auction process
mc states
auction the
offer interval
sell offer
service market
qpa the
market society
strategy seller
the profits
the sellers
agents in
digital library
the seller
mechanism design
buy offer
multiple p
their true
collective behavior
bbss s
who bids
goods and
buy offers
bid their
standing offers
auction mechanism
s offer
simpler strategy
offer rate
agents increases
the zi
agents and
social laws
of sellers
of buy
decreases with
its cost
a market
price is
a multiagent
of matches
strategy that
and services
standing offer
fixed markup
sell offers
offer becomes
bs ssss
the bbss
ss bbbbss
emergent properties
simpler strategies
strategic thinking
of strategic
and sell
offer arrives
best offer
as sharply
qpa s
agent population
with strategic
profit seeking
buy and
market based
seller who
double auction
sell prices
smart agents
bbss state
qpa with
bbbbss s
interested agent
sellers at
bids its
clearing interval
agent can
automated negotiation
higher profit
per match
2 standing
the buyer
where agents
profit per
allocation efficiency
an auction
sharply as
agent societies
cost plus
agent designers
price when
s ss
a strategy
for automated
transition probabilities
agents as
a seller
the arrival
strategy is
our experiments
overall system
strategy called
of p
individual agents
agents is
simple strategy
against other
we measure
c c
game theory
success and
strategy and
efficiency of
decrease as
and failure
tradeoffs between
the collective
when there
agent in
multiagent systems
surplus extraction
park durfee
incentive engineering
sss bss
for qpa
qpa is
bss sss
bbss ss
ss bbss
umdl in
auction is
seeking behavior
sellers each
s bbsss
slightly up
bsss s
zero intelligence
buyer submits
highest buyer
bs sss
the payoffs
of equally
smart decreases
a buy
price quote
their bids
reservation prices
double auctions
sunder 1993
offer rates
query planning
eventually decreases
market inefficiency
designing multiagent
lowest seller
some use
umdl agent
s bbs
agents into
the p strategy
p strategy agents
in the umdl
the p qpa
the umdl auction
of p strategy
p strategy agent
the mc model
of the umdl
buyers and sellers
of the auction
the umdl system
the cp qpa
the clearing price
of the p
self interested agents
the total profit
p strategy seller
number of buyers
umdl service market
the fm qpa
the profits of
service market society
qpa and the
use the p
the umdl is
for the umdl
the market efficiency
the umdl service
p strategy is
at the auction
the auction process
the profit of
profits of the
in the auction
a simpler strategy
qpa and p
the zi qpa
multiple p strategy
collective behavior of
the auction the
goods and services
p qpa and
and p qpa
of buyers and
profit of the
of other agents
a multiagent system
decreases with the
c c c
seller who bids
success and failure
and the offer
sellers at the
bid their true
a seller who
p strategy and
not decrease as
the collective behavior
bids its cost
the best offer
best offer price
strategy agents in
its cost plus
cp qpa the
a market based
sharply as one
p strategy in
emergent properties of
offer interval and
other agents use
number of p
clearing price is
in the mc
as sharply as
the mc states
with strategic agents
agents increases the
the bbss state
buy and sell
decrease as sharply
fm qpa and
who bids its
self interested agent
price when there
profit per match
agents in the
for automated negotiation
number of matches
the overall system
we measure the
a simple strategy
probability of 0
that the p
as one might
one might expect
efficiency of the
the number of
laws for artificial
group of designers
digital library with
strategic agents to
to evolve to
no match a
as its offer
the offer intervals
more buyers to
of the market
p qpa with
adaptive p strategy
agents use simpler
standing offers in
probabilities between the
smart agents increases
auction for qpa
markup a seller
strategic agents in
to maximize their
terms of market
between the mc
the clearing interval
the profit seeking
to task oriented
ssss bs sss
based digital library
agents as the
expect the umdl
the auction figure
buyer submits its
exhibits certain properties
overall system behavior
evolve to a
p strategy to
bs ssss bs
artificial agent societies
seeking behavior of
not always beneficial
gode sunder 1993
from the bbss
p strategy works
enough other agents
a sell offer
arrival of equally
the offer rates
task oriented domains
submits its bid
information goods and
social laws for
negotiation and its
a self interested
a new sell
ss bbbbss s
because of no
equally smart agents
digital library umdl
multiagent systems with
auction the auction
durfee et al
of a market
arrives and it
michigan digital library
since the p
point where some
p strategy we
mc model represents
and sellers at
seller s offer
market and allocation
transition probabilities the
maximize their profits
with the cp
strategy an agent
sell offer becomes
becomes a standing
market based digital
submit their bids
capability of complex
of no match
types of sellers
eventually decreases with
mc model for
some agents use
offer becomes a
of buy and
numbers of p
fm qpa zi
fm qpa s
the payoffs of
p strategy that
of strategic agents
automated negotiation and
profit seeking behavior
p qpa in
efficiency measured by
p qpa but
of michigan digital
auction mechanism may
and allocation efficiency
a standing offer
payoffs of success

corpus/krapavin2000-test/608654.txt
agent
gaia
agents
roles
responsibilities
permissions
customer
liveness
quote
multiagent
coffeefiller
coffee
autonomous
customerrequirements
role
acquaintance
organisation
customerdetails
quotemanager
methodologies
safety
kgr
creditrating
bologna
service
oo
protocols
activities
services
serviceislegal
bespoke
joint
interaction
coffeestock
checkstock
methodology
oriented
modelling
schema
qm
dignum
mylopoulos
costing
coffeestatus
awaitempty
informworkers
customerhandler
realise
organisations
protocol
supplied
nil
organisational
costbespokeservice
vetcustomer
coffeemaker
checkservicelegality
servicetype
csd
italy
melbourne
interactions
mas
president
bdi
vetting
giorgini
getcustomerrequirements
customervetter
intelligent
fill
organizational
madrid
jennings
stock
multi
2002
software
business
ffl
rating
engineering
wooldridge
activity
society
paolo
individuals
australia
concrete
company
2003
concepts
elaborating
fredrik
arnon
tropos
enacting
coffeemachine
onn
costservice
continuationdecision
pot
gandon
wernstedt
davidsson
karageorgos
institutionalised
corrado
mehandjiev
archon
perini
shehory
kinny
dmars
pathways
quebec
july
carrying
development
sigsoft
juan
micro
wic
credit
fabien
legality
santoro
workers
sturm
nikolay
premature
summarised
initiator
annotation
commerce
montreal
maker
antonella
cust
fipa
behaviour
organizations
commitment
dd
specification
fifth
fusion
inheritance
elaborated
giunchiglia
fausto
notes
permission
achievement
rights
vladimir
dai
reads
production
simon
article
abstract
resources
goals
auction
schemata
anna
spain
intelligence
behaviours
departments
ao
responsibility
abstraction
reiko
emiliano
societal
networkdesigner
vet
kolp
pavn
brewed
customeragent
vettingresponse
vzquez
sierra
prabhat
giverequirements
padgham
conceptions
carles
shatz
legalcheckrequest
holvoet
depke
returncosting
konushy
aose
winikoff
zambonelli
multi agent
agent oriented
agent systems
autonomous agents
an agent
multiagent systems
and design
agents and
on autonomous
agent based
international joint
and multiagent
agent system
joint conference
a role
the agent
the customer
agent types
the role
in gaia
agent model
software engineering
roles model
acquaintance model
the gaia
gaia is
of agent
and activities
systems part
bologna italy
2002 bologna
analysis and
for agent
19 2002
july 15
oriented analysis
responsibilities liveness
role schema
first international
role is
services model
agent type
for role
coffeefiller role
the coffeefiller
the roles
liveness properties
15 19
protocols and
reads supplied
proceedings of
conference on
design process
the services
the quote
the acquaintance
the coffee
2003 melbourne
1 july
part 1
the kgr
of coffee
permissions reads
liveness expression
kgr approach
liveness responsibilities
analysis stage
18 2003
interaction model
of roles
customer is
a methodology
systems july
between agents
modelling techniques
to realise
july 14
roles and
design of
business process
and multi
quotemanager role
role s
informworkers checkstock
this role
liveness expressions
john mylopoulos
the quotemanager
between roles
stock level
liveness safety
oo methodologies
gaia methodology
a multi
methodology for
schema for
computing march
safety properties
based system
agent technology
second international
applied computing
and agent
on applied
the interaction
systems v
credit rating
systems proceedings
melbourne australia
fifth international
the analysis
object oriented
the protocol
roles in
interactions and
engineering review
14 18
of multi
there will
run time
checkstock awaitempty
role will
oriented development
supplied customerrequirements
quote nil
paolo giorgini
of oo
the permissions
fusion 6
frank dignum
oriented methodologies
oo modelling
ffl those
has permission
role has
coffee machine
agent carrying
role coffeefiller
concrete concepts
role might
intelligent agent
oriented software
carrying out
associated with
the protocols
a service
to agent
and interaction
is satisfactory
agents in
2002 madrid
madrid spain
customer s
distributed artificial
safety figure
interaction models
and safety
the system
knowledge engineering
acm symposium
the service
at run
the fifth
and concrete
more instances
open systems
role and
2001 montreal
of role
december 18
protocol definition
full or
will typically
agent s
notes v
sigsoft software
engineering notes
information systems
or empty
montreal quebec
agent communication
the liveness
acm sigsoft
the design
agents are
specification of
electronic commerce
in multi
agents p
on intelligent
quebec canada
based systems
service is
software development
agent instances
society or
coffeestock stock
corporate semantic
agent classes
customerrequirements quote
analysis and design
autonomous agents and
multi agent systems
conference on autonomous
on autonomous agents
international joint conference
agents and multiagent
and multiagent systems
joint conference on
multi agent system
a multi agent
protocols and activities
2002 bologna italy
first international joint
multiagent systems part
19 2002 bologna
the first international
proceedings of the
15 19 2002
july 15 19
oriented analysis and
of multi agent
agent based system
and design of
agent systems v
agents and multi
part 1 july
systems part 1
1 july 15
and multi agent
schema for role
for agent oriented
the acquaintance model
design of agent
of a role
the roles model
out the role
the coffeefiller role
the analysis stage
the customer is
the agent model
the kgr approach
permissions reads supplied
agent oriented analysis
of agent oriented
july 14 18
systems july 14
18 2003 melbourne
second international joint
14 18 2003
the analysis and
2003 melbourne australia
multiagent systems july
with the role
agent oriented software
symposium on applied
on applied computing
applied computing march
responsibilities liveness safety
the quotemanager role
methodology for agent
a role is
customer is satisfactory
the second international
there will be
systems proceedings of
agent based systems
if the customer
the fifth international
in multi agent
of an agent
knowledge engineering review
engineering review v
the knowledge engineering
of the role
of the fifth
of the first
has permission to
agent carrying out
the interaction model
full or empty
with a role
for agent based
the ieee wic
informworkers checkstock awaitempty
an agent type
oo modelling techniques
the services model
on intelligent agent
the gaia methodology
the role is
the role s
agent systems proceedings
acm symposium on
associated with the
at run time
oriented software engineering
on the role
11 14 2002
2002 madrid spain
2002 acm symposium
distributed artificial intelligence
14 2002 madrid
carrying out the
that the agent
n 3 p
a methodology for
intelligent agent technology
an agent will
2001 montreal quebec
an agent based
agent technology p
or more instances
conference on intelligent
december 18 22
may 2001 montreal
and the agent
18 22 2006
engineering notes v
acm sigsoft software
sigsoft software engineering
software engineering notes
march 11 14
montreal quebec canada
fifth international conference
computing march 11
run time system
autonomous agents p
n 2 p
wic acm international
ieee wic acm
relationships between agents
a single role
jennings and kinny
changes coffeestock stock
customer contact information
the role coffeefiller
modelling techniques and
an agent oriented
empty changes coffeestock
stock level of
paul davidsson fredrik
an acquaintance model
coffeestock stock level
of agent based
supplied customerdetails customer
level of coffee
the agent instances
customerdetails customer contact
of interaction that
a liveness expression
giunchiglia john mylopoulos
agent instances that
roles in a
object oriented analysis
antonella di stefano
liveness safety ffl
between roles and
a corporate semantic
instances that will
design of multi
abstract and concrete
and design process
agent systems and
modelling and design
protocols associated with
rights associated with
safety ffl true
those such as
reads supplied customerdetails
agent oriented development
and interaction models
the quote process
business process management
davidsson fredrik wernstedt
coffee pot is
liveness and safety
to realise the
coffeestatus full or
of the coffeefiller
corporate semantic web
the key roles
in gaia are
ffl true figure
fausto giunchiglia john
model identifies the
both the macro
or empty changes
that the coffee
wooldridge jennings and
agent oriented methodologies
a one to
in the system
an agent s
the role of
the 2002 acm
that there will
of the analysis
of the second
and safety properties

corpus/krapavin2000-test/608666.txt
stalker
skipto
wien
wrapper
extraction
landmark
knoblock
landmarks
wildcards
semistructured
muslea
minton
sources
tokens
disjunct
craig
ec
training
disjuncts
wrappers
matches
web
ion
items
token
zagat
skipt
restaurant
documents
steven
e3
rules
learndisjunct
softmealy
refining
uncovered
wrap
item
la
document
e4
kushmerick
learning
tex
induction
e2
phone
candidates
weekly
wrapped
content
match
whisk
skipuntil
exs
wildcard
perfect
parent
seed
prefixes
pages
r0
disjunctive
e1
extract
imperfect
perfectly
zip
slot
prefix
consume
src
hierarchical
fewer
learned
unconsumed
restaurants
r7
altigran
las
rule
extracting
refinements
extracted
consumes
you
adisjunct
htmltag
listiter
rapier
r19
candidate
wraps
r4
agents
learns
html
r1
lists
laender
imperfectly
missing
accuracies
late
labeling
terminals
extracts
automaton
iteration
tuple
prefer
punctuation
orders
addresses
silva
wai
everything
early
learn
accuracy
format
wic
generates
tuples
100
covered
automata
variations
soderland
skipu
quafafou
srv
accur
alphabetic
turmo
cuisine
mecca
retv
seafood
s21
ntil
r13
listextr
desai
colfax
habegger
orderdisjuncts
page
transition
failed
da
consumed
prefers
anything
unsupervised
1997
inductive
codes
2293
visa
s9
fe1
sourav
capitalized
atzeni
r15
r12
postprocess
bhowmick
street
alberto
median
intelligent
rejects
refine
ignore
tie
readable
name
1570
chawathe
expressive
terminal
1999
tries
linguistic
lam
suffix
ends
fails
ribeiro
neto
r5
berthier
508
embedded
refinement
ashish
523
docs
extraction rules
wrapper induction
craig a
a knoblock
information sources
steven minton
semistructured information
for semistructured
ion muslea
hierarchical wrapper
training examples
muslea steven
minton craig
the ec
information extraction
skipto b
induction for
the wrapper
iteration rules
ec tree
sources that
the content
content of
a landmark
16 12
list extraction
paper tex
tex 19
skipt o
the extraction
of tokens
19 11
1999 16
the landmark
missing items
until you
various orders
stalker s
seed example
100 1
the items
list iteration
to wrap
extraction rule
initial candidates
perfect disjunct
skipto i
that consumes
la weekly
uncovered examples
and e4
you find
11 1999
the web
rule that
correct matches
the restaurant
tokens in
extraction from
which wien
early matches
area code
everything until
stalker and
wien s
wien stalker
data extraction
landmark l
landmark that
e1 and
disjunct in
information agents
and e3
of training
rules are
the sources
extraction and
that matches
the rule
the list
be extracted
restaurant name
area codes
examples stalker
matches within
refining process
fewer wildcards
the stalker
extraction language
stalker generates
linear la
and wien
of stalker
extraction tasks
late matches
perfect rules
failed matches
and stalker
end rule
wien fails
stalker can
inductive algorithm
refining candidate
by stalker
ec description
the zip
prefer candidates
by wien
stalker uses
that stalker
stalker is
candidates that
token in
e2 and
data knowledge
to extract
positive examples
items that
l i
the rules
web pages
a perfect
12 p
to match
the document
fewer tokens
s da
a refining
test domains
match on
consumes the
altigran s
knowledge engineering
rules based
for information
a disjunct
da silva
examples on
the uncovered
its parent
appear in
rules that
the item
other ones
a wrapper
training example
tokens from
and iteration
engineering v
in various
the start
that wien
to stalker
src wien
all tokens
can wrap
or items
other disjuncts
correct rule
extract all
imperfect wrappers
stalker requires
zip code
wien the
accuracy below
stalker wraps
wildcards that
skipto rules
last token
each wildcard
landmark automata
stalker creates
for sources
more tokens
a wildcard
more terminals
wildcards and
rule skipto
extracting data
tokens until
embedded lists
and zagat
wrapper has
ignore everything
extraction systems
covered examples
token landmark
be wrapped
stalker a
disjunct d
to wien
wrapper generation
linguistic constraints
three initial
initial candidate
prefix x
weekly and
o skipto
zagat document
stalker may
craig a knoblock
semistructured information sources
hierarchical wrapper induction
for semistructured information
wrapper induction for
steven minton craig
minton craig a
ion muslea steven
induction for semistructured
muslea steven minton
the extraction rules
the content of
16 12 p
tex 19 11
1999 16 12
the ec tree
paper tex 19
11 1999 16
19 11 1999
in various orders
list extraction and
a perfect disjunct
appear in various
until you find
sequence of tokens
of training examples
content of the
e1 and e3
e2 and e4
information extraction from
to be extracted
number of training
data knowledge engineering
knowledge engineering v
of the items
for information extraction
everything until you
prefer candidates that
the list extraction
stalker and wien
information sources that
extraction and iteration
missing items and
candidates that have
on which wien
the seed example
ec description of
that consumes the
and iteration rules
the restaurant name
of the restaurant
from the web
s da silva
altigran s da
rules based on
tokens from the
in order to
the relevant data
a rule that
from its parent
number of examples
start and end
extracting data from
extraction rules are
wrapper has to
the ec description
or items that
all tokens until
sources on which
on just a
more terminals to
a correct rule
src wien stalker
problem into several
a refining terminal
active learning techniques
the first token
ignore everything until
uncovered examples stalker
skipt o skipto
first token in
extraction rules based
the area code
stalker uses a
the list iteration
which wien fails
learning extraction rules
matches within the
information extraction systems
area codes from
to match on
weekly and zagat
o skipto b
the wrapper has
la weekly and
prefix x p
the paper tex
that matches t
extract all the
skipt o b
list iteration rules
tokens until you
an accuracy below
rule that consumes
extraction rules for
and e4 and
for each wildcard
based on just
the last token
three initial candidates
web information extraction
the zip code
a landmark l
adding more terminals
the initial candidates
a linear la
items and items
the two systems
tokens in the
alberto h f
is a perfect
a single example
rule that extracts
of the ec
the item to
its parent p
h f laender
list of addresses
web based information
item to be
based on a
by adding more
web intelligence p
extraction from the
september 20 24
many as possible
of a tie
the 2004 ieee
2004 ieee wic
the other ones
20 24 2004
examples for the
on web intelligence
algorithm that generates
to generate a
conference on web
wic acm international
allow the use
ieee wic acm
n 2 p
the start of
most of the
of the rules
of the documents
l i j
proceedings of the
the items in
0 1 0
there are some
international conference on
just a few
labeled by a
it tries to
of a page
of the parent
we plan to
already covered examples
100 accuracy and
ignore all tokens
match immediately after
of stalker and
the landmark l
1 token landmark
domain specific wildcards
of the uncovered
after each other
be human readable
items that appear
list iteration rule
immediately after each
document in figure
label just a
most difficult sources
the wrapper applies
the ec structure
extraction rules presented
median number of
hard problem into
a zagat document
10 training examples
items that may
are missing or
extraction rule that
and goes towards
the existing landmarks
the manual wrapper
token that represents
best refining candidate
missing items or
unconsumed prefixes longer

corpus/krapavin2000-test/608686.txt
agent
agents
mobile
message
delivery
channel
channels
messages
flushed
mobility
arrives
detained
delivered
destination
forwarding
fifo
snapshot
ahead
home
buffering
identifier
holding
deliver
incoming
broadcast
processed
migration
faults
telescript
mole
aglets
platform
arriving
communication
slave
held
flush
action
node
runtime
master
multicast
originate
active
network
outgoing
remote
movement
released
buffered
mechanisms
orphan
connectivity
transitions
aforementioned
recording
progress
reliable
server
pre
simplistic
eventually
voyager
shout
livered
implementability
neighbors
arrive
notably
gateway
transit
retransmission
catches
source
sent
host
hosted
kqml
buffer
arrived
mechanism
overly
sender
tcl
received
visited
passing
subnetworks
platforms
delivering
reply
argue
sockets
flushing
broadcasting
sheer
ip
open
willing
consumption
dynamically
checkpointing
reliability
spanning
finished
migrate
defeat
guaranteed
conventional
inherently
ensuring
associating
effectively
applicability
amenable
leave
transition
copy
provision
nodes
intentionally
unreasonable
enhancements
piece
straightforwardly
traveling
constrains
ffl
guarantees
guaranteeing
burst
bidirectional
enhancement
complicates
forwarded
missed
moves
fault
umbilical
dynamicity
hojjat
yazdani
objectspace
qusay
navid
misunderstood
jafarpour
nasser
rectional
departed
masif
centralization
cuiting
strawman
merseguer
buenes
emerald
ilarri
bidi
curmsg
chore
trapping
daoud
listener
resorts
mosaab
rive
bazzaz
zadeh
scenarios
traffic
party
challenge
move
site
visit
traversed
invocation
propagating
coordination
lost
diagram
transitioned
counterarguments
operative
spawning
nel
shouting
mahmoud
lime
9624815
gration
reintroducing
omg
argentina
missing
locating
wait
assumes
enable
mobile agent
mobile agents
message delivery
the agent
the message
the channel
an agent
agent is
network graph
message j
pre message
the mobile
home agent
the messages
the agents
a message
the network
arrives action
agent arrives
j arrives
of mobility
delivery to
channels are
agent systems
channel is
a mobile
runtime support
incoming channels
the fifo
agent platform
of mobile
message is
for mobile
our mechanism
multiple message
held agents
arriving on
the channels
ahead of
communication mechanism
last message
message to
a channel
next message
message source
agents are
agents that
highly mobile
reliable communication
group communication
delivery in
master agent
pre agent
distributed snapshot
be delivered
of agents
the destination
message i
the state
agents in
fifo property
the node
the home
our algorithm
agent and
delivery of
agent in
to open
this channel
any messages
the source
all messages
destination node
the delivery
state of
and forwarding
any node
communication to
of messages
channels and
identifier of
be processing
underlying mobile
holding channels
physical mobility
message processed
messages 5
detained agents
forwarding scheme
agent migration
holding j
flushed or
message received
of faults
the runtime
each message
channel in
the identifier
been delivered
current message
using mobile
orphan detection
messages arriving
message passing
a node
delivered to
a distributed
the nodes
reliable message
agent a
multiple messages
every node
processing of
state transitions
the aforementioned
the movement
movement of
sent from
catches up
no incoming
message arrives
same message
to deliver
faults in
node where
delivery and
exactly once
a copy
our solution
source the
visited by
in transit
of nodes
presence of
remote procedure
g because
agent has
connectivity of
the communication
processed by
broadcast and
the master
processed at
are guaranteed
channels open
mole 1
d processing
tree broadcasting
action buffer
fifo assumption
one host
message action
gateway servers
agent message
active graph
eventually arrive
sheer presence
agents release
making z
to flushed
the party
4 pre
open channel
processing action
pre no
channel transitions
processing same
propagating in
outgoing channels
grow dynamically
incoming channel
the detained
source ahead
tuple spaces
like remote
message identifier
guarantees message
conventional mechanisms
messages originate
once semantics
agent arrived
eventually released
agents therefore
agent server
destination ahead
slave agents
agents it
y active
that detained
free network
channel y
on holding
agent platforms
finished processing
action deliver
related diagram
author in
agents arriving
j finished
agents out
the mobile agent
a mobile agent
mobile agent systems
for mobile agents
pre message j
mobile agent platform
the channel is
presence of mobility
message delivery to
highly mobile agents
the last message
the next message
of the channels
of mobile agents
the home agent
of the message
a distributed snapshot
the fifo property
message j arrives
multiple message delivery
j arrives action
mobile agents in
of mobile agent
of the network
in the system
the state of
the network graph
the destination node
where the message
agents that are
the runtime support
identifier of the
the agent is
the message is
a message to
the identifier of
state of the
no incoming channels
using mobile agents
case the channel
message source the
each message source
last message processed
messages 5 8
delivery in a
mobile agents are
broadcast and forwarding
source the identifier
the master agent
underlying mobile agent
purpose of using
message processed by
of using mobile
any node to
our mechanism to
pre agent arrives
the underlying mobile
messages arriving on
communication to a
group of agents
last message received
e g because
reliable message delivery
delivered to all
the current message
in this work
in the network
of the channel
an agent is
of our algorithm
a copy of
when the message
when an agent
of a message
of messages is
ahead of the
to be delivered
by the agent
if an agent
the message to
of faults in
are guaranteed that
that all messages
messages to be
we are guaranteed
of the agent
for a time
for each message
the problem of
faults in the
the movement of
this work we
processed by the
first author in
that detained agents
and related diagram
agent arrives d
host to another
finished processing action
the sheer presence
y to z
for multiple message
making z y
mobile agent platforms
author in the
either do not
agents it is
because the messages
are put into
can be processing
delivery to a
a remote server
to all agents
action 4 pre
by connectivity of
channel transitions to
diagram for multiple
open channel on
of mobility and
mobile agent is
channel is active
from one host
mobile agents by
network graph we
buffering channels are
for mobile agent
currently available mobile
these messages arrive
message delivery by
willing to host
initially all channels
nodes and channels
static network graph
i arrives action
release held agents
flushed or buffering
3 pre message
related diagram for
the agent arrived
to message delivery
detained agents are
to highly mobile
could be delivered
allowing any node
pre no incoming
d processing same
our communication mechanism
delivery to highly
held agents release
agent systems currently
delivery of information
next message is
processing action 4
agents release held
in message delivery
arrives action buffer
same message action
deliver to held
yet been delivered
spanning tree broadcasting
many mobile agent
possibility of faults
message j finished
4 pre message
to allow concurrent
2 pre message
done with respect
current message delivery
one host to
the party is
if 3 pre
the gateway servers
the fifo assumption
the message delivery
mobile agent but
guarantees message delivery
arrives action deliver
buffer message i
the active graph
to host agents
an agent arrives
and messages can
released and that
the channel transitions
agents arriving on
to grow dynamically
multicast communication to
algorithm to allow
message delivery in
agent systems provide
channel on a
mobile agent server
active state is
processing same message
mechanism for mobile
g because the
available mobile agent
burst of messages
on holding channels
and d processing

corpus/krapavin2000-test/608696.txt
seller
sellers
myopic
price
profit
pricing
shopbot
kephart
agent
prices
learning
agents
opponent
players
wars
policies
fl
discount
war
reward
economies
tesauro
player
profits
simultaneous
policy
sairamesh
myoptimal
consumers
lookahead
convergence
undercutting
economy
rewards
diamonds
nash
learner
economic
vs
myopically
crites
games
game
dynamics
consumer
buyers
foresight
stationary
quality
alternately
payoffs
reinforcement
instantaneous
asymmetric
equilibrium
buyer
lookup
undercut
unending
greenwald
rl
anticipate
dashed
amplitude
plot
filtering
approximators
trajectory
action
profitability
opponents
hanson
sandholm
converged
differentiation
markov
landscape
asymmetries
competing
cyclic
curve
discounting
infinitely
1998
competition
regime
minimax
baseline
curves
monotonically
symmetric
products
barto
priced
littman
prisoner
pfig
abandon
watkins
discounted
abandons
multiagent
cumulative
alternating
economically
wellman
allowable
equilibria
landscapes
markets
charging
deterministic
discretized
corresponded
persist
payoff
iterated
1999
compete
observable
markovian
immediate
dilemma
circle
chess
adjusting
instantaneously
arrows
self
actions
strategic
consequences
td
asymmetry
filled
optimize
infeasible
autonomous
turns
history
tables
implied
pq
competitive
perfect
leading
cross
training
evolves
consistently
plots
offering
amongst
discretization
yielded
symmetry
adjust
tirole
scissors
useable
fudenberg
fluctua
infintely
damp
subgame
substitutability
kreps
welfare
hashimoto
montonically
hunters
pricebots
differen
tesfatsion
rampant
microeconomic
leigh
undercuts
yoshitsugu
collusive
deltaq
utilites
shopbots
gammon
bargain
charge
deterministically
extent
terminating
simplifying
despite
phenomena
simultaneously
problematic
realistic
adaptive
hu
circles
unpredictable
ordinary
q learning
seller 1
seller 2
the sellers
simultaneous q
the q
and kephart
price quality
vs myopic
discount parameter
price war
q functions
profit functions
price wars
myopic vs
the price
q function
shopbot model
both sellers
q derived
quality model
q learner
kephart 1999
agent q
the shopbot
both players
multi agent
of seller
of fl
average profit
tesauro and
for seller
expected profit
the myopic
two player
learning in
and seller
agent economies
the consumers
information filtering
parameter fl
two sellers
pricing policies
seller s
other seller
cyclic price
asymmetric solution
derived price
price pair
myopic opponent
profit for
immediate reward
in tesauro
the discount
state action
the seller
expected reward
a myopic
take turns
price curves
cross plot
kephart 1998
time step
state space
dashed line
plot of
single agent
filtering model
sellers in
each seller
zero sum
vs q
non stationary
current price
the state
by seller
2 open
of price
their prices
s price
than seller
setting prices
action pair
fl dashed
alternately take
myopic optimal
exact convergence
pricing algorithms
vs discount
approximate convergence
alternating turn
quality seller
curves at
indicates baseline
price curve
sairamesh and
economic models
the players
the agents
of q
and policies
learning is
lookup tables
longer term
profit per
b cross
the prices
of sellers
state s
for both
an agent
of simultaneous
learning by
a average
a seller
other agents
policies and
p 2
obtained at
reinforcement learning
diamonds and
price competition
arbitrary sum
high prices
derived policies
deterministic policy
cumulative profit
future rewards
derived policy
stationary environment
solid diamonds
open diamonds
self consistently
sairamesh 1998
two seller
and crites
defined order
that seller
model myopic
optimal pricing
minimum price
fixed strategy
myoptimal pricing
unending cyclic
instantaneous profits
expected profits
sellers alternately
optimal policies
myopic policy
function approximators
fully observable
competing sellers
reward or
term consequences
no convergence
and sairamesh
sandholm and
pricing policy
and shopbot
kephart hanson
war regime
diamonds vs
self consistent
wars when
optimal price
theoretical guarantees
s current
also found
three models
price and
per time
convergence to
each agent
software agents
history dependent
nash equilibrium
q table
sum games
prices are
two competing
1 solid
agent systems
step for
hanson and
and arrows
exact or
prices of
p 1
of theoretical
lookup table
full knowledge
good approximate
adjusting their
the profit
in agent
two step
arrows indicate
that simultaneous
learning rate
optimal policy
simultaneous q learning
myopic vs myopic
q learning in
price quality model
agent q learning
the price quality
and kephart 1999
tesauro and kephart
for both sellers
discount parameter fl
the shopbot model
for seller 1
the price war
the other seller
the q functions
in the shopbot
the two sellers
q learning is
the discount parameter
in tesauro and
and seller 2
q derived price
the q learner
the q function
single agent q
for both players
cross plot of
and kephart 1998
the information filtering
cyclic price wars
plot of q
q learning by
of q learning
of the discount
of q derived
the q derived
in the price
seller 2 s
the state space
of the q
information filtering model
learning in the
of seller 2
q functions and
alternately take turns
derived price curves
seller 2 open
price curves at
of simultaneous q
vs discount parameter
functions and policies
model a average
multi agent q
state action pair
profit for both
q s a
b cross plot
profit per time
by seller 1
a average profit
seller 1 s
fl dashed line
average profit per
sairamesh and kephart
time step for
in the information
values of fl
other seller s
s q function
value of fl
per time step
at each time
each time step
well defined order
the myopic opponent
arrows indicate a
solid diamonds and
the sellers alternately
seller 1 as
that the sellers
price wars when
price for seller
a myopic opponent
the q table
than seller 1
model myopic vs
expected profit for
against a myopic
parameter fl dashed
case the seller
term consequences of
that simultaneous q
sellers alternately take
that seller 2
line and arrows
the myopic optimal
hanson and sairamesh
step for seller
price war regime
longer term consequences
sandholm and crites
line indicates baseline
kephart hanson and
q derived policy
good approximate convergence
lack of theoretical
agent s current
more interesting and
optimal price for
q derived policies
in two player
seller 1 solid
information filtering and
filtering and shopbot
in agent economies
diamonds vs discount
when the sellers
diamonds and seller
2 open diamonds
and sairamesh 1998
of theoretical guarantees
1 solid diamonds
myopic optimal price
open diamonds vs
unending cyclic price
adjusting their prices
the immediate reward
and arrows indicate
as a function
state s 0
of p 2
a function of
multi agent systems
of the myopic
despite the lack
dashed line indicates
dashed line and
number of sellers
function of fl
of the sellers
all three models
in all three
for small values
the current price
each value of
is obtained at
full knowledge of
of multi agent
the extent that
the more interesting
small values of
the other agents
a plot of
to the extent
and multi agent
in our model
p 2 is
plot of the
in a well
in which both
autonomous agents and
very good approximate
price of approximately
assumptions of knowledge
or identical products
profit landscape for
turns setting prices
discount parameter in
current q function
symmetric solution in
sellers as a
vs q shopbot
vs myopic pricing
basis of price
the sellers products
if so whether
of single agent
prices in a
we study simultaneous
price dynamics trajectory
the asymmetric solution
current price pair
non stationary environment
random entry in
of pricing policies
step lookahead calculation
were generally set
two player alternating
state space transitions
have full knowledge
very high prices
generally set to
stationary environment for
myopic 2 average
whether such solutions
the profit functions
each seller s
profits for both
the policies implied
vs myopic expected

corpus/krapavin2000-test/608736.txt
ard
dependence
ards
grains
rw
ro
00000000000000
wf
interprocedural
grain
dependences
loop
subscripting
oset
writefirst
accesses
array
stride
summary
privatization
readonly
readwrite
subscript
000000000000
art
intersection
classication
ne
summaries
summarization
compiler
loops
parallelization
anti
polaris
idiom
dimension
reshaping
expressions
lmad
tfft2
descriptor
rst
parallelizing
osets
overlap
parallelize
0000
arc2d
rlist1
enclosing
omega
read
subscripts
span
mca
classifying
testing
access
transformations
strides
outer
references
symbolic
simplication
intersections
arc
tests
representative
memory
interprocedurally
bdna
swim
privatized
ocean
privatizing
locations
region
induction
ow
intersect
eective
dim
flo52
parallelism
enclosed
expansion
classied
codes
declared
inductions
tomcatv
dierence
subroutine
summarizing
flow
endif
location
army
intersecting
index
compilers
removed
benchmark
scientic
nested
conservative
expand
descriptors
boundaries
new_writefirst
dimnew
lmads
oating
dierent
ag
inner
marked
trfd
removable
statements
nest
recognition
dimensions
mdg
intersected
happened
iteration
dimensionality
safely
fm
referencing
unwieldy
gated
program
dened
expanded
parallelized
remove
indivisible
writes
brie
contexts
reduction
depen
fpg
comma
ssa
analyses
coupled
contract
ignored
patterns
nd
write
ron
reductions
nding
translated
doing
calling
interpretation
universal
sink
gcd
reference
triplet
instruction
translate
subroutines
reads
perfect
passed
cross
spec
likewise
implication
abstract
classify
nonlinear
spans
vi
across
dimensional
declaration
indices
eliminating
internal
predicate
rethink
rwn
viet
intraprocedurally
recursing
interpretion
kaist
benchmarksmyampersand
nga
agged
dierentiated
summary sets
the ard
dependence analysis
00000000000000 00000000000000
summary scheme
range test
dependence testing
non a
an ard
access region
write order
a ne
loop index
the art
data dependence
list ard
summary set
ard is
omega test
subscript expressions
the accesses
read only
the access
a dependence
ard list
dependence grain
representative dependence
later grain
order summary
the omega
memory location
the loop
two ards
two grains
dependence grains
region test
stride equivalent
ard for
000000000000 000000000000
end do
removed by
the summary
and rw
the write
subscripting expressions
by privatization
ro wf
base oset
procedure boundaries
access summaries
enclosing context
dependence arc
only summary
do do
dependence test
memory accesses
ard in
ne expressions
input dependence
of ards
between grains
ne subscript
anti output
the ards
ards are
the subscripting
memory locations
memory references
across procedure
compiler transformations
array access
wf and
intersection algorithm
memory access
the read
a dimension
subscripting oset
flow anti
internal overlap
array reshaping
recursive intersection
dim ard
dimensional recursive
sets ro
oset sequence
enclosed context
access patterns
be removed
the range
an intersection
for dependence
test could
dependence between
expansion by
loop based
dimension index
linear memory
memory related
the array
the dependence
the program
outer loop
accesses within
sets for
abstract interpretation
memory classication
or reduction
region descriptor
classication analysis
classifying memory
actual argument
single ard
execution predicate
multiple subscript
ard rlist1
overlap due
complex array
art the
remove dim
0000 0000
order summarization
rst access
rw 2
or rw
art can
general dependence
point dependence
of memory
interprocedural dependence
cross iteration
the later
a loop
for parallelizing
accesses to
the compiler
to list
the enclosing
intersection between
output dependence
array dependence
based dependence
anti and
array subscripting
of classifying
a memory
level 2
of loops
to point
test is
marked as
array reference
single memory
parallelism detection
coupled subscripts
flow dependence
art is
an array
symbolic analysis
intersection operation
do i
base address
loop indices
execution order
multi dimensional
dependence tests
do end
induction variable
the intersection
rw 1
simplication operations
ro t
happened rst
new summary
do j
of osets
wf 1
dependence this
two dependence
grains in
idiom recognition
could parallelize
ro ro
access representation
by privatizing
the grains
expand i
writefirst and
our dependence
the lmad
for ards
not stride
real u
iteration dependence
wf ro
type input
grain and
span is
conservative direction
both grains
summaries for
00000000000000 00000000000000 00000000000000
the range test
non a ne
the summary sets
the access region
the write order
the omega test
order summary scheme
write order summary
only summary scheme
summary sets for
access region test
read only summary
the ard is
be removed by
the read only
across procedure boundaries
000000000000 000000000000 000000000000
of the ard
a ne expressions
the later grain
the two grains
wf and rw
removed by privatization
a ne subscript
of the accesses
the loop index
by the loop
of an ard
list ard list
ro wf and
to list ard
recursive intersection algorithm
the enclosing context
the subscripting oset
ne subscript expressions
multi dimensional recursive
flow anti output
dimensional recursive intersection
linear memory access
the ard for
add to list
ard list ard
that the art
subscripting oset sequence
point to point
in the later
of memory references
memory classication analysis
do end do
an input dependence
to point dependence
test could not
the actual argument
access region descriptor
dependence between grains
as a dependence
a single ard
ard for the
classifying memory locations
single memory location
representative dependence arc
summary sets to
in execution order
accesses within a
remove dim ard
a representative dependence
end do end
the non a
loops that the
the art can
write order summarization
a summary set
the rst access
overlap due to
anti and output
section of code
a dependence test
array dependence analysis
can be removed
a loop index
a single memory
sets for the
interprocedural dependence analysis
by a loop
dependence exists between
in the program
accesses to a
input flow anti
two ards are
cross iteration dependence
1 rw 2
set of memory
removed by induction
memory access descriptor
two dependence grains
list ard rlist1
induction or reduction
marked as having
the array access
loop index of
new summary sets
summary sets ro
do j 1
of loops that
0000 0000 0000
construct and return
three summary sets
based dependence testing
fails level 2
anti output flow
the memory accesses
5 4 0
internal overlap due
expansion by a
of the summary
the notation should
an execution predicate
parallelize and the
by privatizing the
access summaries for
in both grains
a dependence grain
the two ards
end do real
omega test could
could parallelize and
it fails level
memory accesses within
the art the
dependence testing to
range test can
sets ro wf
array subscripting expressions
range test could
dependence type input
type input flow
ard is a
memory referencing unit
subscripting expressions such
an intersection operation
summary sets by
for parallelizing compilers
number of loops
of the art
must be done
and return a
based on access
the linear memory
a dimension of
the power test
the dimension index
return a new
a technique for
the outer loop
dependences can be
the variable in
are read only
the art is
rst in the
dependence can be
is the rst
non empty intersection
of data dependence
analysis for parallelizing
the dierence between
data dependence analysis
is marked as
for the array
the multi dimensional
for dependence analysis
a section of
the intersection is
would correspond to
expressions such as
to a memory
in a nested
the same memory
parallelization of the
a nested loop
of the loop
to a single
of the dimension
loops in the
of the dependence
for the variable
between any pair
3 5 1
programming with polaris
with new as
in either induction
with summary sets
in many scientic
interprocedural array region
to point testing
of d comma
analysis exact side
represent memory accesses
new construct and
real u 1

corpus/krapavin2000-test/608747.txt
pssa
predicated
cmpp
hyperblock
pspec
guarding
chr
predicate
t1
speculation
schedulable
dependences
predicates
z1
bagf
trimaran
agf
uc
earliest
instruction
renaming
hyperblocks
cagf
epic
ssa
height
speculated
y1
scheduled
cycle
bahf
fpp
predication
ebagf
lbagf
cahf
ecagf
guarded
r1
scheduling
ac
lbahf
op
br
schedule
renamed
edcagf
ahf
fpps
ebahf
ecahf
edcahf
ia
un
dependence
register
w1
branch
ilp
live
join
registers
playdoh
instructions
branches
statements
false
p2
block
tag
mahlke
paths
p3
flow
duplication
duplicated
static
conversion
committed
operands
code
path
pred
optimized
aggressive
alvinn
rename
isa
assignment
reduction
r2
def
optimizations
sensitive
statement
cfg
t2
scheduler
cycles
operand
expansion
64
reaching
compiler
rand
normal
guard
flexibility
disjointness
exit
architecture
superblocks
speculating
nbradar
predicating
cydra
fib
specint95
parallelism
copy
duplicate
b1
definitions
defining
fir
nullify
compress
oe
executed
traditional
qsort
relieve
hewlett
region
infinite
v1
character
blocks
remove
b3
packard
wc
file
benchmarks
recurrences
italics
floating
selective
intel
speculate
eliminating
execution
profile
utilization
clean
removing
waiting
accomplish
architectural
profiling
exiting
names
unnecessarily
mm
architectures
corporation
assure
weighted
transformed
introduces
post
merged
reflect
converted
benchmark
wave
pipelining
versions
expose
targets
prior
b2
pressure
normalized
anded
tiberiu
elimation
rodric
vinod
chelcea
rabbah
poison
budiu
multiflow
y5
copen
y6
10305070
stmts
merced
the hyperblock
if true
guarding predicate
height reduction
control height
schedulable cycle
earliest schedulable
predicated code
cmpp un
un uc
pspec and
z1 7
predicated execution
predicated speculation
true 3
full path
cmpp an
and chr
path predicates
t1 r1
for predicated
its guarding
path information
the pssa
br out
cmpp op
using pssa
a hyperblock
static single
false dependences
guarded by
ia 64
predicate sensitive
of y1
t1 7
normal op
speculation and
single assignment
predicated hyperblock
uc t1
the guarding
predicated static
guarding predicates
instruction scheduling
predicated on
7 if
16 way
if conversion
its earliest
on true
code expansion
scheduled at
control flow
r1 if
t r
lbagf ebagf
to predicated
ebagf cmpp
ac t1
the cmpp
w1 2
next def
cmpp statements
sensitive analysis
be scheduled
the predicate
and t1
an ac
the operation
the definition
definition of
true and
dynamic code
an an
oe functions
renaming and
join block
epic architecture
control paths
bagf cagf
of predicated
t1 r2
assignment pssa
ecahf edcahf
pssa transformed
lbahf ebahf
bahf cahf
cmpp operations
edcahf cmpp
ecagf edcagf
of pssa
cmpp ac
edcagf cmpp
predicate registers
ebahf cmpp
optimized infinite
cmpp operation
pssa to
guarding pred
of ssa
block predicates
out if
y t
and control
predicates that
original code
flow graph
a predicate
data flow
scheduled in
r if
operation is
ac ac
define predicates
op guarding
that pssa
cahf cmpp
pssa allows
b predicated
cagf cmpp
by trimaran
the trimaran
renamed variables
with pspec
pssa dependence
non predicated
agf ahf
def get
pssa pspec
infinite results
during instruction
pssa form
multiple control
hyperblock is
multiple definitions
3 bagf
issue machine
t1 s
block predicate
uc w1
predicated region
their earliest
op schedule
pssa with
to pssa
by pssa
transformed code
graph b
is guarded
control dependence
of control
definitions of
basic blocks
r2 if
operation s
in figure
the optimized
if p2
after optimization
t2 t1
control path
eliminating false
original control
per cycle
predicates to
that defined
level parallelism
b q
predicates are
be committed
dependence graph
branches with
predicate is
is true
of operations
for predicate
in cycle
operations that
flow analysis
chr and
3 ecahf
sensitive implementation
on pssa
traditional code
3 ecagf
an z1
trimaran system
hyperblock pssa
1 agf
3 lbahf
predicate register
duplicated code
an t1
executed cycles
if p3
same cycle
uc z1
y1 5
op earliest
and pspec
earliest schedulable cycle
control height reduction
cmpp un uc
if true 3
full path predicates
its guarding predicate
pspec and chr
static single assignment
and control height
y t r
t r if
z1 7 if
speculation and control
predicated static single
7 if true
un uc t1
in the hyperblock
of the hyperblock
its earliest schedulable
predicated speculation and
for predicated code
br out if
control flow graph
the definition of
the guarding predicate
cmpp an ac
cmpp an an
lbagf ebagf cmpp
t1 7 if
w1 2 if
at its earliest
t1 r1 if
dynamic code expansion
definitions of y1
predicated on true
value of true
predicate sensitive analysis
pssa transformed code
t1 r2 if
single assignment pssa
cmpp ac ac
ecahf edcahf cmpp
ecagf edcagf cmpp
lbahf ebahf cmpp
of its guarding
t t s
the original code
guarded by the
is true and
in a hyperblock
r1 if true
eliminating false dependences
uc w1 2
an ac t1
next def get
pssa pspec and
un uc w1
3 bagf cagf
through the hyperblock
definition of y1
ebagf cmpp an
t2 t1 s
uc t1 7
guarding predicate is
scheduled at its
bagf cagf cmpp
r if d
flow graph b
5 if true
using pssa with
at their earliest
bahf cahf cmpp
of predicated execution
in figure 5
be scheduled at
is guarded by
instruction level parallelism
on the definition
number of operations
each operation is
the operation s
to be defined
predicated speculation pspec
b predicated hyperblock
with pspec and
the predicate or
5 x if
operations in figure
an an t1
the same cycle
for predicate sensitive
predicate sensitive implementation
uc z1 7
cmpp op guarding
the hyperblock are
flexibility in scheduling
ac ac z1
bagf and cagf
a original control
12 to 68
3 ecagf edcagf
true 1 agf
s earliest schedulable
of the guarding
for predicated execution
3 ecahf edcahf
f b 2
on pssa transformed
an an z1
between the definition
un uc z1
their earliest schedulable
guarding predicates are
sensitive implementation of
16 way original
d b 3
true 3 ecagf
path along which
ac z1 7
multiple control paths
pssa dependence graph
during instruction scheduling
out if l
true if true
3 lbagf ebagf
normal op target
and t1 7
graph b predicated
multiple definitions of
7 and t1
for a 16
a 16 issue
16 issue machine
non predicated code
2 if true
v1 y1 5
q if p2
true 3 lbagf
predicate defining operations
original control flow
s if d
in the trimaran
predicated execution is
for renaming and
true 3 ecahf
the trimaran system
3 lbahf ebahf
original 16 way
an z1 7
the cmpp operation
r 5 x
r2 if true
b q if
if true 1
optimized infinite results
defining bagf and
op earliest schedulable
7 if f
using pssa to
and t1 r1
need for renaming
f true if
operation s guarding
t1 s if
true 3 lbahf
a predicate sensitive
in ia 64
op guarding pred
schedulable cycle f
to pssa form
height reduction chr
support for predicated
to remove false
renaming and for
s guarding predicate
to predicated code
implementation of ssa
z1 7 and
the optimized infinite
a is true
the operation is
data flow analysis
g b c
if g b
definition of its
hard to predict
true and c
path leading to
if f 3
if a is
from 12 to
predicates to be
is predicated on
c t r
be scheduled in
all other operations
control flow and
b c t
operations to be
of the operation

corpus/krapavin2000-test/608786.txt
skewing
locality
tomcatv
nest
loop
balance
tile
loops
ow
stencil
calculations
calculation
scalable
mw98
cache
live
wl91
tiling
stripe
int
nests
iteration
break
wol92
array
temporaries
stripes
arrays
dependences
rxm
rym
benchmark
tiles
wolf
oating
cur
ry
interference
rst
lam
skew
residuals
gj88
spec95
kpr95
ros98
sw98
won95
mct96
iterations
ne
statements
tridiagonal
temporary
inhibit
outer
1340
reindexing
sixth
optimizations
multiplication
bandwidth
stencils
dimension
spaces
improving
unimodular
fth
l2
traverse
seven
nn
grows
513
raises
library
memory
transformation
ding
latency
produced
sustained
layout
virtual
code
aa
compile
transformations
limits
hope
carries
xed
grow
scans
statement
omega
codes
dependence
inner
aect
occurred
extremely
rastislav
pw98
smg98
kristof
regrouping
pw93
6900
128k
mcc95
mlg92
seshia
outpace
strout
armando
liviu
recompress
maksim
lezama
jeanne
orlovich
semicoarsening
taxes
kreaseck
shallower
hypre
gilad
9808694
sanjit
beyls
mccalpin
tancau
bodik
block
completing
skewed
reused
linearly
sublinearly
300m
hollander
guohua
permutable
intermediately
ferrante
1028
michelle
aberrant
complier
saraswat
2ns
refactorings
hoisting
producing
192
expanding
symbolic
ignore
subscript
contend
yonghong
carter
mills
ischia
crummey
bump
mellor
denition
expand
supercomputing
initialize
seconds
derives
matrix
nd
empirical
fourth
experiences
proportional
scsi
unoptimized
tiled
kmp
lexicographical
3t
rosser
sketching
4500
indices
blocks
nal
solar
erik
widening
coerce
corrupting
mckinley
multigrid
borders
scalable locality
time skewing
time loop
for int
are live
time step
iteration t
int for
a calculation
achieve scalable
locality for
live at
data ow
the balance
balance of
produce scalable
compute balance
in mw98
machine balance
the calculation
do do
loop nest
step calculation
improving locality
the tomcatv
in iteration
int figure
iteration spaces
o b
main memory
ow of
in cache
step calculations
in tomcatv
skewing transformation
time block
skewing in
tomcatv benchmark
wolf and
seven arrays
locality we
problem size
cache interference
of calculations
three point
iteration of
matrix multiplication
the time
code generation
locality and
all loop
tile size
a break
and lam
the break
a ne
the iteration
virtual memory
value produced
break occurred
break statements
e loops
ry i
of tomcatv
for tomcatv
wl91 wol92
stencil calculations
each stripe
solve tridiagonal
and tiling
extremely high
iteration space
oating point
value based
omega library
balance as
memory locality
generation system
l2 cache
with extremely
balance we
each array
the ow
skewing and
point stencil
nest of
the locality
outer loop
the loops
values produced
is live
to main
i loop
calculation in
produced in
the code
the omega
current techniques
the rst
loop carried
loop nests
n values
data locality
b g
values that
of locality
the hope
the loop
loop bounds
calculations in
this dimension
calculation is
of time
ow dependences
skewing a
cur i
locality with
next tile
speed has
initialize c
skewing on
the cur
tomcatv the
wol92 mct96
step completing
two nests
rst nest
the tile
fourth nest
tiling if
s sustained
exhibits scalable
this nest
place stencil
nest is
time skewed
high balance
mw98 we
of temporaries
mw98 section
such calculations
of stripes
cache requirements
stripe by
locality if
temporary values
determine maximum
locality proceedings
inhibit scalable
calculations that
and rym
cache requirement
cur array
by wolf
gj88 wl91
break statement
live simultaneously
j dimension
grows less
temporaries to
from wl91
high machine
stripes each
ignore issues
nest when
exhibit scalable
where nn
skewed code
sixth nest
calculation if
2004 chen
previous iteration
optimizations to
the j
for figure
operations performed
g e
the outer
raises the
arrays of
end of
temporaries that
skewing the
our cache
as matrix
the fth
transformation systems
the stripe
achieving scalable
live on
chen ding
a tile
measures our
have results
locality this
will t
come from
locality of
the sixth
perform this
the time loop
for int for
int for int
scalable locality for
achieve scalable locality
in iteration t
produce scalable locality
time step calculation
that are live
the balance of
of time skewing
are live at
for int figure
to achieve scalable
of the time
live at the
time skewing transformation
wolf and lam
ow of values
iteration t j
the time skewing
time step calculations
the tomcatv benchmark
of the calculation
the data ow
the value produced
a time step
iteration of the
do do do
the problem size
values that are
the ow of
t j i
code generation system
class of calculations
with extremely high
three point stencil
o b g
for improving locality
used in iteration
the time block
locality for a
produced in iteration
skewing and tiling
j i of
to produce scalable
i of the
the omega library
previous iteration of
the outer loop
of the outer
the code generation
to main memory
of operations performed
the end of
t i of
the iteration space
an iteration of
at the end
the previous iteration
the values that
for time skewing
measures our ability
the tile size
discussed in mw98
time loop must
the cur array
raises the hope
values are reused
time skewing a
machine balance we
in mw98 we
inhibit scalable locality
achieving scalable locality
this loop nest
be a ne
nest of tomcatv
ignore issues of
c to zero
iteration data ow
operations on o
which the break
time skewed code
outer loop which
extremely high machine
locality we must
calculations for which
the j dimension
run with t
in single assignment
time optimizations to
can achieve scalable
main memory but
such as matrix
locality for figure
as matrix multiplication
machine balance in
of temporaries that
calculation in figure
in place stencil
while loops or
zero for int
the sixth nest
the break occurred
with time skewing
grows less than
the next tile
any time step
tiling if we
machine balance as
the e loops
step calculation if
and time skewing
of value based
of locality we
iteration t i
given in mw98
ry i j
values are live
all seven arrays
exhibits scalable locality
extremely high balance
scalable locality we
locality proceedings of
2004 chen ding
value produced in
balance of this
of a calculation
the fourth nest
that will t
to which values
skewing in this
a run with
follow the data
stripes each of
the iteration spaces
j loop from
time step completing
initialize c to
live on entry
and all loop
the time skewed
achieve the appropriate
within the stripe
t in cache
entirely in cache
time loop in
the machine balance
are live simultaneously
time skewing in
scalable locality if
improving locality and
exhibit scalable locality
the rst nest
balance as the
compile time optimizations
gj88 wl91 wol92
b g e
high machine balance
domain of our
wl91 wol92 mct96
ability to apply
than linearly with
by wolf and
time skewing the
of scalable locality
a factor of
with the problem
degree of locality
arrays of size
spatial locality and
ow of information
techniques for improving
of the loops
all loop carried
value of time
less than linearly
loop nest of
algorithm for time
execution order and
balance of a
is live at
if we rst
on the dierence
of spatial locality
the hope of
on entry to
o n b
our ability to
the i loop
per time step
this raises the
code generation for
memory bandwidth and
current techniques for
1 i 1
with the square
from the values
the iterations of
in the original

corpus/krapavin2000-test/608853.txt
huffman
comma
decoder
codeword
s444
td
circuits
compression
lh
pm
encoding
lc
td1
chakrabarty
coding
td2
iscas
bist
log2
jtdj
pseudorandom
encoded
codes
le
circuit
patterns
fsm
vm
gat
decoders
bits
m1
rom
cuts
decoding
occurrence
imd1
flmin
fimax
murray
iyengar
flops
strat
xi
precomputed
gentest
codewords
pi
td0
ipi
tgc
n1
flip
chip
skewed
probabilities
me
l0
wi
n0
cut
coverage
pm1
hitec
vij
limm
s35932
counter
combinational
1s
clock
bit
p1
leaf
m0
l1
testing
0s
gate
primary
p2
krishnendu
dc
overhead
gen
te
pattern
inputs
deterministic
pp
gatest
ppici
dlog2
anshuman
unencoded
n2qi
hbits
pm3
cbits
automation
hit
x1
fig
scan
2dlog
ic1
chandra
l2
fault
89
n2
vec
m2
vj
xm
percentage
sequential
sequences
benchmark
fm
tree
vi
proc
stream
n2l2
fim1
vm1
tbits
crbits
tgcs
2121
id1
n1l1
s526
ddlog2
hrbits
jtdjd
pm2
dc0
compressed
runs
sg
saving
fm1
rences
2126
netlist
saab
1875
ith
clocked
parent
conf
literal
fi
prefix
encode
cores
atpg
generation
jointly
literals
duke
electrical
entropy
vol
lowest
cycles
patel
statistical
000
mini
epoch
counts
statistically
michigan
offset
1991
unmarked
europe
repeating
moderate
diagram
core
ce
det
built
received
x2
near
si
considerably
v1
hardware
storage
probability
niermannandj
fs382
fies
pij
the huffman
test set
run length
huffman tree
unique patterns
test sets
of occurrence
test patterns
encoded test
test application
lh d
in td
huffman and
primary inputs
and comma
comma codes
the s444
the test
the comma
length encoding
patterns in
deterministic built
test sequences
comma code
huffman coding
codeword length
length coding
p2 pm
vm m1
huffman code
td1 and
comma coding
set compression
s444 test
pattern generation
equal length
the decoder
fault coverage
sequential circuits
probabilities of
application time
comma encoding
lc lh
and td2
and murray
iyengar chakrabarty
lc le
decoder for
statistical encoding
precomputed test
a codeword
of flip
iscas 89
chakrabarty and
flip flops
multiple cuts
unique pattern
pseudorandom testing
gat strat
hit gat
pattern xi
decoder dc
of huffman
decoder overhead
gen hit
no of
the encoded
p1 p2
average length
in pattern
of primary
the probabilities
the cut
the counter
built in
the unique
of bits
d imd1
pattern decoder
pm be
lc d
for s444
average codeword
let p1
d le
pm c
the fsm
huffman codes
length decoder
huffman codeword
length for
test pattern
for sequential
of test
for test
test sequence
is skewed
td is
bit stream
huffman encoded
huffman encoding
codeword is
pi c
full binary
clock cycles
design automation
of patterns
satisfy 2
than equal
these circuits
and decoder
occurrence of
bits in
data compression
of unique
limm 1
length codes
lowest probabilities
comma decoders
compression achieved
for comma
n1 pi
encoding procedure
h td1
single decoder
set td
iscas circuit
for td
test vec
which comma
set encoding
of s444
codewords for
unique test
binary tree
coding is
d 1
sets for
we next
testing time
encoding for
gate level
codeword the
the pseudorandom
a chip
on test
shared among
of runs
tree for
encoding of
near optimal
the encoding
on chip
krishnendu chakrabarty
increase in
the proposed
probability of
in test
of clock
d 0
benchmark circuits
compression for
the run
the average
of compression
vi and
ppici 1
d n2
and lc
coding equal
89 benchmark
log2 fimax
optimal huffman
then lh
codeword for
s444 example
f ppici
unencoded test
for huffman
prefix free
parent vm
is offset
le be
example test
a bist
proposed test
percentage compression
strat gen
decoder circuit
imd1 ipi
anshuman chandra
flmin 1
murray table
sequence generator
of comma
c n2qi
codes perform
in literals
literal counts
h td2
the huffman tree
unique patterns in
the unique patterns
encoded test set
probabilities of occurrence
huffman and comma
patterns in td
run length encoding
deterministic built in
in pattern generation
built in pattern
probability of occurrence
of primary inputs
of occurrence of
p1 p2 pm
huffman tree for
test set compression
codeword length for
the test set
number of primary
the comma code
the encoded test
td1 and td2
iyengar chakrabarty and
s444 test set
of the huffman
chakrabarty and murray
the probabilities of
test application time
of flip flops
average length of
equal length coding
of a codeword
hit gat strat
the huffman code
gen hit gat
for the s444
test sets for
the average length
in the test
patterns in the
for sequential circuits
number of flip
the test application
of test patterns
huffman tree is
than equal length
the s444 test
pm be the
decoder for the
let p1 p2
the average codeword
p2 pm be
run length decoder
no of bits
the run length
average codeword length
lc lh d
occurrence of the
of bits in
of the unique
full binary tree
the test patterns
be the probabilities
a full binary
of clock cycles
number of patterns
the lowest probabilities
which comma codes
test data compression
worse than equal
on test set
under which comma
test patterns are
statistical encoding of
n1 pi c
of unique patterns
if the huffman
results on test
for td is
a single decoder
precomputed test sequences
lh d le
tree for td
and comma encoding
run length coding
test set encoding
unique test patterns
equal length codes
test set td
length of a
number of clock
on a chip
binary tree with
for these circuits
experimental results on
test set for
number of unique
test set the
be the average
circuit gen hit
the ith unique
of the repeating
is offset by
n1 d n2
each unique pattern
ith unique pattern
lc d imd1
and vm m1
sets for two
for comma coding
using the s444
generation for sequential
cost in literals
comma code is
codes perform worse
chandra krishnendu chakrabarty
huffman encoded test
the unique test
le be the
the pattern decoder
huffman tree to
iscas 89 benchmark
among multiple cuts
anshuman chandra krishnendu
the fsm decoder
of precomputed test
strat gen hit
comma codes perform
and run length
for the iscas
lh d pm
gat strat gen
clock cycles c
a codeword is
and murray table
the s444 example
length for comma
td is skewed
huffman codeword length
the huffman encoded
then lh d
f ppici 1
pi c n2qi
the proposed test
d imd1 ipi
for the patterns
encoding of precomputed
pm d 0
decoder cost in
increase in testing
parent vm m1
use of comma
coding equal length
89 benchmark circuits
test application the
test set of
number of bits
of the test
the number of
in testing time
test sets to
same probability of
high value of
pattern generation for
the iscas 89
flip flops to
iscas 89 circuits
with the lowest
built in self
of occurrence and
primary inputs and
is near optimal
we next present
test set are
higher fault coverage
testing time is
large number of
a power of
of patterns in
perform worse than
only one bit
condition under which
a high value
state transition diagram
to the cut
is generated for
the test sequence
a single bit
bits in the
present experimental results
the same probability
for the test
for the proposed
the increase in
of the counter
a large number
required to store
of the pattern
is a power

corpus/krapavin2000-test/608855.txt
cores
bypass
core
port
tpgr
misr
scan
bit
shortest
sink
ports
circuitry
bypassing
schedule
pcf
mode
cbg
circuit
infinity
wires
accessibility
cycles
testing
packets
dijkstra
controller
interconnections
transfer
paths
stop_4
bypasses
read_port_1
read_port_2
read_port_3
send_port_1
stop_3
stop_2
stop_1
bist
isolation
coverage
scheduling
fault
chip
interconnects
po1
send_port_2
structural
transferred
parenthesis
widths
registers
asap
route
serial
isolated
c3
mergeable
asic
reusable
dft
factorizing
inputs
po2
2c1
syntest
multiplexors
transistor
clock
circuits
signatures
primary
faults
fastest
micron
compass
yoneda
tomokazu
interconnect
activities
match
automation
path
routes
outputs
chains
tentative
cmos
factorize
rtl
fujiwara
datapath
intellectual
hideo
embedded
unmarked
signal
schedules
overhead
chain
pipeline
bus
signature
bypassed
soft
buses
testable
synthesis
factorized
programmable
testability
tri
hpcn92
programmability
j_k
bomu76
mabd98
comp93
6062
abbr85
packetization
15390
cota
9180
packetizing
kowa97
packetize
lubaszewski
demi94
i_k
bhgv96
carro
rika
width
logic
vlsi
europe
source
pile
gentest
busses
mux
ston90
nin
interfering
flip
char
c2
characteristic
scrambled
501
packetized
vertex
c1
overlap
pipelining
socs
vq
manuals
signals
protection
consumes
interface
predefined
eight
luigi
bellman
munich
stages
packet
pipelined
connections
marcelo
flops
jej
electronic
ort
entirety
shaded
wrapper
pursued
designer
summarized
tester
providers
cycle
ij
session
output
pseudocode
buffers
thoroughly
reusing
gate
cheaper
modes
library
methodology
patterns
reflecting
test time
core 1
the core
test data
the bypass
a core
each core
infinity infinity
bit match
bit data
output test
system primary
core k
under test
shortest paths
cost values
fault coverage
the test
test paths
test path
structural test
bypass mode
time cost
shortest path
cores in
core input
tpgr misr
test controller
four cores
dijkstra algorithm
to bypass
the shortest
of core
b bit
output ports
output port
to transfer
core 2
bypass scheduling
port i
test shortest
port j
core is
input test
packets of
bit widths
the pcf
bypass circuitry
bypassing data
between cores
isolated core
bypass schedule
test point
core 4
bit width
input port
the cores
input ports
cores are
test points
and sink
input output
core based
for core
port to
cores signal
stop_2 stop_1
stop_1 send_port_1
signal name
match circuit
misr stop_4
misr misr
core under
stop_3 stop_2
tpgr tpgr
core environment
of bypass
read_port_2 read_port_3
read_port_1 read_port_2
stop_4 stop_3
send_port_1 read_port_1
m bit
primary inputs
on chip
for test
test patterns
core and
test overhead
of cores
scheduling method
to port
hard cores
source and
embedded cores
cores with
of test
the system
data between
global source
i mode
complete bypass
bypasses data
directed weighted
existing interconnections
test methodology
bit test
ports to
read_port_3 send_port_2
serial to
when core
that core
fastest route
name 17
bypass routes
send_port_2 cores
transfer test
core in
inputs outputs
accessibility of
to overlap
design automation
a test
system on
the bit
paths 1
scan out
17 under
and test
is transferred
1 bit
characteristic function
to serial
source sink
logic level
4 bit
between source
primary outputs
and core
mode and
time overhead
n bit
path algorithm
data will
the existing
on design
reusable blocks
isolation techniques
n stages
bypass data
s bit
e cycles
2 c1
without interfering
state buffers
the cbg
tri state
are reusable
scan registers
proposed structural
tentative path
micron cmos
global global
through core
core circuitry
path weights
graph modeling
one core
core when
existing wires
a bypass
8 micron
cycles cores
cbg graph
interface cost
programmable e
core output
our structural
core 3
po1 po1
interconnects and
data from
is under
schedule for
16 bit
packet of
k bit
scan in
of figure
the circuit
transferred in
two test
m n
for system
the fault
route to
weighted graph
cores a
the dijkstra
cores the
core to
the test time
infinity infinity infinity
for each core
the shortest path
test shortest paths
cores in the
of a core
of the core
source and sink
system on chip
misr stop_4 stop_3
core under test
bypass schedule for
stop_2 stop_1 send_port_1
is under test
stop_4 stop_3 stop_2
stop_3 stop_2 stop_1
bit match circuit
stop_1 send_port_1 read_port_1
cores signal name
read_port_1 read_port_2 read_port_3
the bypass mode
output test shortest
send_port_1 read_port_1 read_port_2
tpgr misr stop_4
input port to
b bit data
input output test
data is transferred
the shortest paths
the time cost
to the core
dijkstra algorithm to
fastest route to
directed weighted graph
the output port
tpgr tpgr tpgr
to port j
schedule for core
signal name 17
a directed weighted
of 4 bit
and output ports
two test points
parallel to serial
a b bit
name 17 under
read_port_2 read_port_3 send_port_2
between two test
transfer test data
send_port_2 cores signal
system primary inputs
for core 1
test data between
bit test data
misr misr misr
is transferred in
the existing interconnections
read_port_3 send_port_2 cores
serial to parallel
the bit width
of figure 7
of test data
the cost values
between source and
finding the shortest
time cost of
of core k
our proposed structural
of the bypass
the dijkstra algorithm
the core under
test methodology for
tri state buffers
test data distribution
8 micron cmos
accessibility of the
cost d b
bit data from
input test paths
weighted graph in
are reusable blocks
to bypass data
0 8 micron
isolated core environment
environment of core
the cbg graph
bit input port
system primary outputs
the core circuitry
i to port
port of a
programmable e g
the system primary
the existing wires
the test controller
to overlap the
the core input
input test path
of core 1
the fastest route
core is under
output test path
packets of data
output test paths
4 bit data
the bypass circuitry
route to transfer
s bit match
core input ports
the i mode
packets of 4
global global source
scan and our
for all core
to transfer test
p s bit
port i to
from system primary
bit width of
cores are reusable
2 2 c1
the data is
to the output
shortest path between
all the input
from the system
as a whole
a core based
of core based
a core is
core based system
time cost d
core does not
design for test
the fault coverage
on design automation
example of figure
in the system
m n m
data will be
an n bit
shortest path problem
core based systems
a packet of
all vertices are
under test and
as a directed
the time overhead
the core and
test data for
data distribution and
shortest path algorithm
system as a
terms of time
which the data
input and output
test in europe
design automation and
testing theory and
figure 8 b
for the test
of electronic testing
automation and test
and test in
electronic testing theory
figure 7 c
the characteristic function
by which the
journal of electronic
graph in which
algorithm to find
in terms of
the bit match
m bit input
transferred in 8
paths 1 i
8 cycles using
the above issues
fault coverage in
rika cota luigi
to carry test
available bypass connections
n bit output
the participating core
factorize the characteristic
for 4 cycles
the core output
point 2nd test
input ports to
wires if the
char interface cost
test data b
cores with s
the overall test
our method test
problem as finding
user manuals for
test time for
and core 4

corpus/krapavin2000-test/608920.txt
tam
wrapper
tams
soc
cores
scan
ppaw
core
chains
ilp
width
testing
d695
pnpaw
socs
p93791
chain
paw
widths
wrappers
marinissen
chakrabarty
bypass
krishnendu
kmax
pw
enumerative
chip
enumerate
sehgal
automation
europe
erik
longest
p1500
anuja
sc
co
internal
partition
goel
bus
sandeep
wmax
functional
balanced
maxfs
extest
jan
minimized
assignment
pb
bfd
ijk
clock
optimization
os
bits
ozev
sule
intest
16975
chips
jk
cycles
exec
np
flops
kumar
nicolici
sog
interconnect
lengths
w1
halted
philips
flip
vikram
designs
bin
iyengar
multiplexed
partitioning
scheduling
minimize
industrial
partitions
embedded
terminals
qiang
unbalanced
linearized
integration
lpsolve
maxrfl
daisy
psc
20094
multiplexing
nicola
objective
conjecture
vlsi
optimizing
architectures
inputs
tester
521
yoneda
stones
tomokazu
reconfigurable
scalable
xu
smin
fujiwara
iscas
hideo
adaptation
electronic
outputs
infrastructure
sizing
assigned
munich
mathematical
analog
435
cells
priority
utilization
stepping
formulated
assignments
progression
combinational
44
a1
modular
ics
solver
solved
c1
minimizing
circuits
address
standardized
pseudocode
enumerated
wrapped
exceeding
ff
addressed
iii
fit
serialization
mode
modes
06
bins
methodology
patterns
1000
heuristic
48
bit
formulation
created
mixed
determining
rings
ultra
flexible
10410
1030920
zahra
zhanglei
minmax
saleh
24021
minftg
wenhua
jianhua
924909
minimiz
arbitrating
634488
oostdijk
1031200
6127
873276
peripheral
2123437
24197
22246
optimizaion
burleson
30108
2174501
807909
wrapper scan
testing time
tam width
scan chain
scan chains
internal scan
wrapper design
of tams
wrapper tam
the tam
of tam
co optimization
the wrapper
tam optimization
the soc
tam design
tam co
the testing
ilp model
testing times
cores on
of cores
to tams
each core
test access
total tam
cores to
scan in
ppaw enumerate
test wrapper
of wrapper
design wrapper
the tams
tams and
the cores
design for
jan marinissen
for ppaw
the ilp
longest wrapper
design automation
for core
and test
krishnendu chakrabarty
a wrapper
on design
core such
tam widths
for soc
tams of
and tam
functional inputs
core assignment
b tams
core i
of w
on chip
core based
an ilp
scan out
erik jan
core 6
for tam
for d695
system testing
the core
clock cycles
system on
in europe
an soc
test bus
automation and
tam lines
test wrappers
ieee p1500
balanced wrapper
soc d695
test scheduling
a core
general problem
soc test
mathematical programming
test width
two tams
bit tam
each tam
width among
problem pw
a tam
tams for
functional outputs
kumar goel
width partition
8 ff
tam and
anuja sehgal
chain 8
partition of
test in
wrapper and
core test
n cores
access mechanism
sandeep kumar
and wrapper
is minimized
of core
execution time
core is
chains are
europe p
the conference
design problem
times obtained
programming model
chain elements
width required
pb w
goel erik
tam are
to tam
pnpaw 1
industrial soc
d695 for
system chips
soc p93791
tam j
scan elements
ilp formulation
width adaptation
chains created
ilp models
the longest
assignment of
assigned to
cores and
test patterns
chains of
time is
and scan
w among
wrapper is
optimal partition
chip test
out chain
i os
optimization that
embedded core
in scan
core testing
of test
chains and
time for
np hard
optimal testing
infrastructure design
wrapper chains
tams the
our tam
interconnect test
bin design
tams an
tams is
soc testing
tam is
longest internal
access architectures
test architecture
enumerate is
new wrapper
bus model
wrapper for
minimize testing
tams in
optimal tam
test infrastructure
test time
the width
an optimal
16 20
width w
optimization for
obtained using
an industrial
of lengths
problem of
w j
an assignment
based system
be np
design algorithm
for socs
chakrabarty test
2 wrapper
pw is
for embedded
the scan
i w
for test
the functional
wrapper scan chains
wrapper scan chain
the testing time
internal scan chains
wrapper tam co
number of tams
tam co optimization
testing time is
testing time for
total tam width
of cores to
internal scan chain
wrapper scan in
cores on the
cores to tams
for each core
to the wrapper
on the soc
longest wrapper scan
assignment of cores
wrapper design for
on design automation
system on chip
conference on design
design for each
the wrapper scan
system testing time
core such that
erik jan marinissen
the testing times
each core such
the tam width
the total tam
test in europe
design automation and
automation and test
and test in
of wrapper scan
a wrapper design
the cores on
balanced wrapper scan
scan chains are
the longest wrapper
time is minimized
values of w
chain 8 ff
sandeep kumar goel
mathematical programming model
testing times obtained
the ilp model
the internal scan
scan chains of
of tam width
for soc d695
on the tam
test access mechanism
scan chain 8
of wrapper tam
number of wrapper
the conference on
of the conference
an assignment of
problem of wrapper
core based system
the system testing
testing time and
in europe p
tam width partition
time for d695
ilp model for
n cores and
scan chain elements
1 bit tam
test wrapper and
for d695 for
goel erik jan
width among the
of w among
the wrapper design
an optimal partition
tam width required
optimal partition of
and tam width
tam optimization that
chains of lengths
kumar goel erik
number of tam
t i w
an ilp model
an industrial soc
among the tams
general problem of
scan out chain
in scan out
scan chains and
scan in scan
more general problem
the number of
be np hard
for system on
the problem of
the test bus
core assignment to
longest internal scan
co optimization for
wrapper design algorithm
cores and b
for core 6
w among the
core testing time
test infrastructure design
b tams of
created in part
to tams and
and b tams
for core i
and a wrapper
test access architectures
testing time on
test width adaptation
test bus model
model for ppaw
minimize testing time
the functional inputs
infrastructure design for
of tam design
based system chips
the scan elements
chains created in
tam width among
of the cores
scan chain is
tams and a
for embedded core
the execution time
values of b
of the longest
for core based
of testing time
partition of w
for a core
several values of
partitions of w
proceedings of the
a partition of
in part i
i w j
is assigned to
transactions on very
large scale integration
vlsi systems v
very large scale
integration vlsi systems
scale integration vlsi
partition of the
stated as follows
to be np
each value of
test data for
1 2 3
problem of determining
for each value
length of the
the width of
on a chip
ieee p1500 standard
of ppaw enumerate
models for tam
assignment to tams
the ppaw problem
scan chain 1
of core terminals
tam design and
to the tams
tams of given
to tams of
soc testing time
every core is
february 16 20
sule ozev krishnendu
the optimal testing
1000 clock cycles
wrapper chains created
time 1000 clock
chip proceedings of
total testing time
and test scheduling
d695 and p93791
assignments of cores
tams for the
using ppaw enumerate
tam optimization models
16 20 2004
testing time t
problem pw is
assigned to tam
soc as well
ilp models for
partitioning wrapper scan
scan chains in

corpus/krapavin2000-test/609176.txt
retraction
cps
sps
lambda
transform
oe
joek
pi
app
typing
axioms
transforms
omega
monads
moggi
jmkae
mog88
typed
definable
continuation
ae
embedding
calculus
tg
provable
soundness
codomain
sequents
interpretation
sw96
denotational
style
interpretations
monadic
constants
equational
axiom
divergence
inference
untyped
wand
logic
pcf
recursive
equivalence
encap
caluclus
mw85
mit88
mps86
divergent
lemma
abs
gamma
joe
meyer
definitions
passing
pure
fij
fixpoint
closed
inductively
substitution
reasoning
inverse
language
sabry
8n
retract
functional
implication
felleisen
semantics
ml
fs
sound
mutable
continuations
diverges
understood
says
equality
induction
modified
asserting
theorems
interfering
assertion
difficulty
membership
sketch
asserts
isolate
parameterized
notions
hyperdoctrines
mog89
diver
9504288
numerals
9216185
sw74
sf92
axions
aefv
overline
plo75
rey93
continutions
c97
ste78
fil94
rv95
bar84
oef
metalanguage
wad90
crole
mog91
unrea
sto77
strachey
app92
operators
equalities
interpret
discipline
recursion
equipped
hypothesis
mapping
extensions
programs
recovered
cp92
impure
discoveries
sonable
1015
retractions
deltak
comprehending
viswanathan
queen
effortlessly
filinski
riecke
letrec
closure
imperative
letters
languages
effects
elementary
fill
var
motivate
typable
definability
singled
unjustified
andrzej
haven
fore
abstract
satisfies
affirmative
pitts
disambiguate
tuitively
gence
isolating
correspondence
contin
fj
monad
banach
axiomatization
typ
analogous
operator
truth
validity
preserves
stronger
mantics
xk
hypotheses
ku
reynolds
abbreviates
uation
seemed
act
computations
extend
constructs
picture
naval
the retraction
retraction theorem
the cps
cps transform
the sps
lambda terms
computational transform
type oe
sps transform
r oe
modified computational
call by
by value
retraction embedding
the transform
of terms
t pi
type sets
transform t
terms r
cps and
sps transforms
t oe
transform we
term m
oe and
terms e
m pi
computational lambda
lambda calculus
and r
extended with
terms and
r e
theorem for
passing style
e oe
type system
type inference
lambda term
a type
embedding pairs
define terms
retraction for
constants e
soundness lemma
prove the
logic of
transform and
a typing
transform as
a lambda
the definitions
terms m
recursive type
the modified
r k
simple type
terms to
e and
transform in
fixed point
equivalence classes
abstract transform
2 joek
embedding pair
r app
computational effects
codomain of
app and
computational effect
conditions y
m oe
of lambda
oe r
recursive types
continuation passing
interpretation of
c r
value v
definition 3
of type
a term
the codomain
the transforms
gamma x
the type
oe is
of c
transform is
closed term
oe n
of types
extend the
the interpretation
the logic
denotational semantics
lemma 3
provable in
closed terms
any closed
c extended
language with
point operator
oe 0
to lambda
value evaluation
moggi s
types oe
satisfies gamma
simple types
transforms we
joe k
typing hypothesis
closed lambda
particular transform
joek fs
closure conditions
n pi
typing assertion
show s
pcf with
terms extended
retraction approach
with assignment
joek r
s joek
theorem to
e k
to extend
defined using
we define
simply typed
oe m
term r
transform for
e r
the soundness
inverse of
be understood
the definition
x n
m of
a substitution
the recursive
r exist
as parameterized
axiom r
every type
other transforms
fs tg
equational correspondence
value pcf
the axioms
all terms
r r
to prove
larger class
gamma m
k oe
and monads
compute r
and types
definitions we
we study
e s
r s
interpretations of
terms that
s oe
let ae
can type
a call
types and
omega gamma
terms we
an interpretation
relation between
sound for
in models
all closed
and axioms
in let
to ae
x oe
the computational
a value
oe the
e x
for call
k instead
transform to
terms p
can extend
x m
the interpretations
the equational
by name
to c
oe x
the retraction theorem
the cps transform
the sps transform
retraction theorem for
modified computational transform
call by value
e and r
for the cps
prove the retraction
the modified computational
of the retraction
and the sps
transform t pi
the cps and
the sps transforms
of the cps
cps and the
logic of c
simple type oe
of the transform
theorem for the
type oe r
lambda terms to
of terms and
the computational transform
of type oe
constants e and
retraction theorem to
retraction embedding pairs
for the sps
the logic of
a lambda term
c r e
the recursive type
equivalence classes of
r oe n
r r oe
cps transform as
codomain of the
e r app
terms e and
in the codomain
retraction embedding pair
for any closed
class of terms
conditions y and
the codomain of
the soundness lemma
classes of terms
cps transform we
t oe 0
the transform t
r app and
a call by
to prove the
computational lambda calculus
of lambda terms
c extended with
inverse of the
terms and types
fixed point operator
interpretation of types
a language with
the type system
continuation passing style
of a type
a larger class
the equational correspondence
let x m
the retraction embedding
a typing hypothesis
gamma m oe
as parameterized by
retraction theorem is
terms extended with
terms to lambda
terms r oe
oe r oe
to lambda terms
transform for any
soundness lemma for
oe and e
ae x n
function s joek
define terms r
any closed term
axioms of c
joek r r
that c r
to show s
joek fs tg
extend the retraction
retraction theorem in
a type oe
transform we define
to the cps
by value evaluation
sound for call
lambda term r
value pcf with
lemma 3 10
x n pi
recursive type system
x m in
define the interpretation
interpretations of terms
of simple type
terms m and
computational transform t
r k oe
lambda terms m
joe k and
extend the type
m of simple
retraction for the
the transform in
s joek fs
types oe and
type t oe
application in the
in the logic
to extend the
a relation between
of the form
of e r
in c r
e s and
cps transform and
transform is defined
closed term m
interpretation of terms
in let x
should be understood
and r exist
by value pcf
in the definition
can extend the
the definition of
we prove the
any value v
larger class of
for call by
terms of type
we can extend
lemma for the
term m of
be a substitution
lemma 3 9
for the modified
the type inference
finally we define
call by name
m and n
y and z
a term m
an interpretation of
be defined using
and r s
defined using the
the inverse of
v such that
we need to
be understood as
particular we will
of the modified
this work we
the interpretation of
the new terms
and types as
transform we study
e x e
type oe is
models of c
in general depend
or the sps
all m of
retraction for t
for t pi
define the extended
terms m of
transform of m
gamma x 1
pcf with assignment
computational effects can
there a lambda
two constants e
a typing assertion
particular transform and
cps or the
class of extensions
transforms as well
ae be a
with mutable store
term m r
such that 8n
show s 1
r m pi
the term e
define the retraction
relation between direct

corpus/krapavin2000-test/609180.txt
dlet
binding
deps
continuations
resumable
handler
lisp
calculus
exceptions
dynamic
axioms
lookup
eval
lexical
expressiveness
fmark
equational
deep
abstractions
exception
felleisen
passing
ltc
queinnec
xd
speculative
sabry
ml
translation
syntactic
semantics
delimiters
operand
lk
extent
observational
lexically
signalled
raised
scope
hostname
emacs
intro
latest
style
continuation
stuck
elim
eulisp
abstraction
functional
adds
placeholder
maclisp
environment
assignments
equationally
purely
shallow
gnu
accessible
mandatory
language
bind
sequential
notices
associative
fluid
bindings
propagate
feeley
apparition
xd1
ffix
southampton
expressive
binds
43
conciseness
sigplan
programmer
print
lambda
funarg
syntax
inverse
programs
enclosing
calculi
refine
xg
monitor
alue
scoping
organisation
popping
essence
sensible
innermost
operator
dialects
popped
combinator
duplicated
axiom
scoped
mccarthy
perl
amr
favour
xr
behaviour
languages
name
fork
mutable
reasoning
creation
growth
parallelism
duplicating
fig
xs
transform
haskell
explanatory
pop
indefinite
theories
translated
vn
equivalences
signal
transition
strengthen
inside
primitive
ffi
dynamically
denotational
register
xed
constructs
displayed
bug
cons
christian
hole
translations
annotation
sound
active
correspondence
fivefold
stoyle
penalise
k30773
magorzata
observationnally
mitscheme
so17
stolen
denigrate
cartwright
barendregt
penalises
alued
chieh
hicks
bierman
ribbens
abortive
multilisp
biernacka
wansbrough
dynamicness
sperber
1bj
destruct
gavin
soton
manual
duration
pushed
declarations
occurrence
evaluation
site
relies
derivations
body
macro
lazy
resource
fi
db
simulate
soundness
revised
expression
dynamic binding
dynamic environment
dlet dlet
evaluation function
deps d
the dynamic
parallel evaluation
that dynamic
deep binding
dynamic extent
environment passing
dynamic variables
dynamic variable
evaluation context
binding is
of dynamic
sequential evaluation
a dlet
dlet construct
latest active
syntactic theory
adds expressiveness
the calculus
a dynamic
the handler
continuations and
of exceptions
dynamic abstraction
dlet propagate
binding adds
passing style
purely functional
d calculus
passing translation
propagate 0
associative list
binding list
expressive programming
passing transform
common lisp
binding for
a syntactic
inverse translation
program m
equational reasoning
functional language
the evaluation
expressiveness to
binding which
shallow binding
dynamic abstractions
ml 26
expressiveness 8
dlet intro
2 deps
fluid let
resumable exceptions
eval c
lisp 43
control delimiters
exceptions like
the latest
the deep
handler is
semantics of
the semantics
extent of
call by
first class
class continuations
transition rules
of future
value calculus
d any
same dynamic
m 7
axioms of
by value
exception was
programs using
scope of
the exception
continuation passing
programming technique
of fmark
axioms dlet
context e
active handler
dlet elim
emacs lisp
lookup 2
primary axioms
current dynamic
lk 2
binding technique
style exceptions
partial continuations
eval l
dynamic scope
lookup 1
43 or
dlet error
by dlet
e xed
observational equivalence
gnu emacs
active binding
rule dlet
the dlet
rule ltc
equationally corresponds
ml style
print number
binding strategy
and operand
when evaluation
felleisen s
syntactic theories
and dlet
target language
binding in
the scope
on programs
a binding
of axioms
any program
equational correspondence
a purely
m 2
reasoning on
a growth
lookup operation
sabry and
and felleisen
transform d
control state
of exception
notices v
programs in
the binding
sigplan notices
the operator
state space
the programmer
an exception
d gamma1
was raised
the operand
using dynamic
and assignments
or dynamic
acm sigplan
notion in
the continuation
translation which
in lisp
environment e
standard ml
in dynamic
value v
an expressive
to define
that variable
the lookup
theory that
8 to
operator and
theory of
special form
a calculus
error if
let body
if dlet
as resumable
rules dlet
binding was
allows equational
intro and
structure organisation
programming patterns
appears inside
on terms
the mandatory
future construct
variable hostname
implementation strategies
dlet ffix
with lisp
remains accessible
feeley 7
dynamically bind
derived axioms
lexical binding
intro 0
resumable ones
binding as
of fluid
if evaluation
e evaluation
dynamically bound
the dynamic environment
that dynamic binding
of dynamic binding
dlet dlet dlet
dynamic environment passing
sequential evaluation function
dynamic binding is
a syntactic theory
the latest active
the dynamic extent
binding adds expressiveness
dynamic binding adds
the evaluation function
dlet propagate 0
the deep binding
prove that dynamic
dynamic extent of
a dynamic abstraction
a dynamic variable
purely functional language
to a purely
a purely functional
environment passing style
m 2 0
same dynamic environment
expressive programming technique
theory of dynamic
common lisp 43
equational reasoning on
environment passing transform
program m 2
parallel evaluation function
syntactic theory of
the d calculus
any program m
a dlet construct
adds expressiveness to
scope of a
the semantics of
class continuations and
the same dynamic
first class continuations
the exception was
call by value
of a dynamic
by value calculus
show that dynamic
the call by
the scope of
the target language
set of axioms
the operator and
for any program
binding is a
lookup 1 and
in dynamic environment
of exceptions like
adds expressiveness 8
a parallel evaluation
8 to a
a dynamic extent
passing transform d
environment passing translation
passing translation which
ml style exceptions
present a syntactic
current dynamic environment
semantics of exceptions
latest active handler
an expressive programming
evaluation function of
programs in dynamic
dynamic variable is
dynamic abstraction is
the binding list
expressiveness to a
semantics of future
rule dlet propagate
dynamic environment the
of a dlet
of dynamic variables
the current dynamic
equationally corresponds to
expressiveness 8 to
syntactic theory that
for parallel evaluation
and dynamic binding
deep binding strategy
reasoning on programs
on programs using
latest active binding
continuations and assignments
2 deps d
a growth of
using dynamic binding
binding is an
a sequential evaluation
the sequential evaluation
in the dynamic
the control state
abstraction is applied
by the handler
the inverse translation
evaluation function is
evaluation function in
from the dynamic
programs using dynamic
exception was raised
inside the scope
sigplan notices v
acm sigplan notices
sabry and felleisen
a dynamic environment
the lookup operation
of the dynamic
to the calculus
an exception is
growth of the
for the duration
of an expression
the name of
ae dlet dlet
1 and lk
here and now
exceptions like resumable
parallelism and distribution
is an expressive
and lookup 2
1 and lookup
associated with lisp
gnu emacs lisp
dlet intro and
an evaluation context
further refine the
order to strengthen
variable is translated
dlet ffix x
by the latest
of dynamic abstractions
of fluid let
numbers should be
dlet ae dlet
alue d any
perform equational reasoning
define a parallel
dynamic binding as
an associative list
v alue d
and now that
lk 1 and
should be displayed
deep binding technique
expression a dynamic
for dynamic binding
fluid let 18
theory that allows
primary axioms of
a context rewriting
to parallel evaluation
xd extend e
explanatory purpose we
define a calculus
the associative list
the axiom dlet
defined and equal
the dlet construct
space binding list
exception is signalled
of sequential control
refine the evaluation
inverse dynamic environment
and popped at
dynamic environment is
active binding for
x d v
dlet dlet ffix
active handler is
parallel evaluation because
argument to each
control state for
d any value
popped at the
the evaluation context
mutable dynamic variables
error if dlet
evaluation function and
eval l m
kinds of exceptions
notion in semantics
and lk 2
claim that dynamic
and complete with
dynamic variables are
binding with value
in programs in
dlet construct is
e evaluation context
duplicating the dynamic
transition rules dlet
dlet merge dlet

corpus/krapavin2000-test/609199.txt
mutex
catch
caller
asetq
semaphore
kernel
queue
ready
dispatch
continuation
applicative
lambda
cons
busy
interrupts
cond
car
exclusion
cont
nil
rplaca
msg
preemption
interrupt
wait
saving
deleteq
ans2
ans1
denotational
arg
multiprocessing
elementary
lisp
restarted
protection
fork
algol
sem
processes
hewitt
manager
cell
semaphores
reynolds
steele
languages
count
waiting
modules
semantics
preempt
privileged
sussman
indiana
cdr
disable
foo
val
block
fn
processor
continuations
locus
stack
rplacd
fn2
fn1
uninterruptible
demo
progn
landin
brinch
addq
emptive
create
calling
schedulers
shall
bliss
funarg
junk
creates
private
ideas
returns
flag
syntactic
holland
church
executing
released
scheduling
throw
operating
garbage
pointer
gen
amsterdam
pp
hansen
spin
puts
returned
multiprogramming
handler
argument
binding
facility
processors
arguments
protected
module
eval
1980
decentralized
expects
monitors
calls
track
critical
forth
dummy
pages
executed
language
answers
interpreter
loop
labels
serpette
multistack
vliet
06678a01
revive
fuss
mcs79
161cn
mcs75
add1
funargs
microcomputers
commend
unjustly
blithely
grips
trickiest
parc
errset
02115
biagioni
enue
preempting
republished
neuhold
debakker
04183
edoardo
entrance
dcom
hyperspace
quietly
greaterp
sub1
prog2
serializer
interdefinable
cleanness
verona
boussinot
xerox
someplace
emptyq
reversed
syntax
bottleneck
alleviate
code
cc
timing
causes
lock
treatment
execute
adequate
ml
north
resource
past
passing
lost
started
region
revised
huntington
maclisp
individuation
reclaimed
rib
expounded
the kernel
busy wait
ready queue
make ready
create process
the ready
process saving
applicative languages
next process
lambda msg
msg cond
of catch
its caller
elementary exclusion
the semaphore
a continuation
check done
mutex v
caller of
cont arg
an applicative
mutex p
catch caller
kernel s
test and
a process
and set
a dispatch
the manager
one done
critical region
kernel dispatch
enable preemption
catch in
caller block
rplaca x
no arguments
of interrupts
run it
denotational semantics
by value
the caller
the continuation
call by
the catch
car x
cons cell
of applicative
is restarted
scheme 3
class instance
of processes
process which
read loop
mutex is
catch expression
create queue
wait lambda
ready caller
block mutex
gen kernel
block make
data protection
of asetq
have state
try later
this semaphore
ready cont
deleteq q
mutex busy
disable preemption
the queue
the car
we shall
process to
of scheme
kernel is
language design
applicative language
set car
returns t
multiprocessing system
catch and
which called
dispatch to
catch is
a multiprocessing
argument t
processes waiting
in denotational
and try
process is
global state
processes which
control access
with argument
call on
l values
calls on
a semaphore
released and
queue q
have written
always returns
processes and
queue and
the code
give up
waiting on
call to
queue a
modules for
the processor
kernel to
a queue
creates a
is released
kernel and
of no
queue with
asetq x
causes control
cond lambda
use catch
lambda val
val asetq
semaphore if
brinch hansen
emptive scheduling
computation 11
cons ans1
association list
semantic ideas
t nil
kernel make
of semaphores
kernel define
the indiana
x rplaca
preempt x
by worth
x cons
process cont
things we
asetq count
mutex mutex
completely decentralized
cons process
lambda dummy
lambda error
waiting process
semaphore let
car rplaca
past mutex
with fn
cons t
calling it
catch operator
scheme demo
semaphore the
mutex into
kernel exclusion
get past
ready process
deleting it
find inside
caller with
from semantics
function create
process lambda
sussman and
v mutex
protection error
lambda check
nil labels
of algol
self lambda
preemption lambda
timing interrupt
many functions
interrupt handler
x car
write code
ans1 ans2
small many
define cons
complex schedulers
t mutex
demo 1
asetq in
hansen s
count mutex
single argument
caller t
continuation object
some modules
with catch
to applicative
the cons
scheduling system
the ready queue
test and set
lambda msg cond
the caller of
the kernel s
on the ready
call by value
a class instance
catch caller block
of applicative languages
of no arguments
use of catch
scheme 3 1
ready queue and
the kernel is
v is executed
the count is
ready queue with
on this semaphore
function of no
up and try
give up and
inside the kernel
an applicative language
processes waiting on
dispatch to find
queue with argument
wait lambda msg
to its caller
busy wait lambda
in an applicative
and set car
and try later
make ready caller
system the kernel
mutex busy wait
is released and
ready cont arg
and process saving
block make ready
a dispatch to
use of call
control access to
we have written
a multiprocessing system
released and the
the process which
3 1 system
in denotational semantics
a test and
to control access
the critical region
the use of
the test and
order and symbolic
the kernel and
of call by
of the kernel
higher order and
and symbolic computation
a process to
access to the
the state of
we shall consider
create process to
preemption lambda error
of process saving
next process run
multiprocessing system the
and call cc
area of applicative
continuation and an
lambda val asetq
mutex into the
preemption and enable
class instance with
kernel s job
of object identity
the scheme 3
msg cond lambda
cons t nil
caller of the
labels self lambda
expects a single
kernel and some
busy wait is
the calling process
find inside the
s job is
always returns t
car rplaca x
the kernel it
many functions which
ready to run
nil labels self
kernel s ready
which are ready
process which called
continuation in denotational
and an argument
a single argument
job is to
by value to
disable preemption and
functions which one
its caller with
cons cell is
the processor executes
modules for a
mutex v mutex
through the semaphore
north holland amsterdam
an elementary exclusion
let x cons
kernel make ready
deleting it from
set car x
t mutex v
else to do
report on scheme
busy wait let
and enable preemption
to the flag
one argument which
calling it with
make ready cont
the kernel this
syntactic restrictions which
mutex p if
small many functions
and some modules
of asetq in
the kernel we
copies of it
process lambda check
cons ans1 ans2
next process is
self lambda msg
when a v
writing the kernel
x run it
11 2 pp
to make ready
for a multiprocessing
mutex is released
critical region the
becomes less of
the catch expression
with argument t
something else to
very small many
wait in the
executes a dispatch
executed the calling
process is restarted
a timing interrupt
and set loop
process run it
assign a process
waiting on this
calling process first
the car of
ready queue we
of the catch
run time structure
a process as
to find inside
the catch operator
cons process cont
busy wait in
is restarted by
processor executes a
catch in the
normally expect to
check done asetq
past mutex into
create process lambda
computation 11 2
some modules for
account of when
brinch hansen s
creates a continuation
use of asetq
its caller and
caller of x
causes control to
caller block make
to find something
when two modules
its caller in
kernel the kernel
error protection error
symbolic computation 11
process cont arg
of catch in
must get past
the semaphore the
pre emptive scheduling
of x run
t nil labels

corpus/krapavin2000-test/609202.txt
specialization
aeow
specializer
tempo
specialized
program
cache
loader
int
residual
stat
cached
dyn
dioeerent
romberg
explosion
computations
loops
loop
speedup
scienti
bpf
ruf
smirnov
knoblock
spline
compile
chebyshev
early
unrolled
cubic
binding
opportunities
gi
fft
expensive
ooe
unspecialized
static
doubly
signi
conditionals
bene
interpolation
strategies
specializing
nested
programs
nition
calculations
reader
void
cant
innermost
frontier
singly
unrolling
encodes
speedups
ps
lter
struct
dioeerence
eoeciently
dioeer
aizu
unrolls
annoted
ineoeective
caching
ts
speculative
invocation
fragments
integration
consel
rst
late
berkeley
aimed
body
extern
asian
lawall
danvy
specializations
limitations
annotated
trigonometric
g3
approximates
backward
julia
packet
identi
rpc
rt
concretely
appendix
essence
preprocessing
fourier
iterations
compiled
olivier
intensive
sun
ambient
estimations
mainly
displayed
g2
g1
ct
procedures
textual
inexpensive
optimizes
analyses
evaluated
looked
costly
code
degrades
invocations
propagates
korsholm
izer
bulyonkov
franoise
brieaey
rohde
linearisation
isystemj
intpow
val3
tegration
robertas
meur
damaeviius
eoecient
gyu
hornof
barzdins
malmkj
myong
ooeering
fabs
tuikys
malmkjr
karoline
getrusage
ager
val1
eoeect
ooeers
iuserj
vytautas
japan
graphics
slower
hundred
charles
calls
named
torben
renaud
amtoft
shaders
rebuilt
henning
nitions
mads
thibault
simpli
marlet
improves
512
compilers
ve
dropping
dynamic
matcher
widen
thoughtful
metaprogramming
manipulate
improvements
park
tour
genera
eighties
cantly
pratt
alias
assess
phases
ed
integrate
instruction
data specialization
program specialization
specialized program
early computations
control aeow
program and
specialization can
the specialization
the specialized
the loader
code explosion
and data
specialization strategies
aeow computations
the program
residual program
specialization is
both program
specialization we
data aeow
cubic spline
procedure f
specialization does
the cache
specialization and
the residual
specialization at
specialization for
specialization to
specialized with
a program
program is
partial evaluation
spline interpolation
gi procedures
at compile
specialization the
is specialized
program specializer
of program
compile time
of early
static dynamic
program which
computations and
doubly nested
the gi
be cached
code size
scienti c
cached by
specialized at
knoblock and
cache int
and ruf
specialization when
int stat
cause code
the romberg
dyn d
romberg integration
expensive data
specialization encodes
program specialized
by program
binding time
at run
computations which
problem size
specialization in
int j
void f
specialization as
expensive enough
run time
of procedure
loop and
nested loop
two programs
the reader
innermost loop
the control
time analysis
speedups see
specialization problem
dyn int
struct data
specialization are
specialization opportunities
combined specialization
or cached
intensive a
expensive calculations
the unspecialized
beyond some
e stat
berkeley packet
specialization time
a specializer
combining program
int d
computations program
aeow intensive
stat is
ooe line
int dyn
aeow graph
packet lter
bene ts
e dyn
dioeerent specialization
data specialized
unspecialized program
residual code
ts and
smirnov integration
the loop
a residual
size increases
de nition
new program
the invocation
the early
the cubic
not expensive
static computations
binding times
the bene
singly nested
analyze two
mainly consists
specialization process
preprocessing phase
specialization or
perform data
limitations of
and limitations
nested loops
original one
where performance
of specialization
the fft
of programs
invocation of
the computations
the innermost
c programs
cache is
1 program
dynamic or
the frontier
both strategies
signi cant
a doubly
points n
or static
which approximates
reader the
program to
a binding
is data
and program
aimed at
this program
programs where
automatic program
on partial
this situation
data cache
specialization actions
fourier transformation
specialization produce
performing speculative
speculative evaluation
becomes static
specialization phase
integration appendix
dioeer in
using estimations
than 512
in doubly
similar speedups
evaluated or
control construct
for specialization
d struct
test e
hand program
action analysis
nition is
aizu japan
where constructs
manipulation p
these expensive
estimations characteristics
tempo with
program 4
ps rt
specialization because
program applications
and data specialization
program and data
the specialized program
both program and
data specialization can
the control aeow
data specialization does
of early computations
is specialized with
cubic spline interpolation
program specialization at
the early computations
specialization does not
specialized with respect
at compile time
of the specialized
program specialization and
result of early
the gi procedures
data aeow computations
specialization can be
data specialization is
data specialization we
of the specialization
the residual program
at run time
binding time analysis
specialization is applied
the cubic spline
program specialized at
expensive enough to
of program specialization
by program specialization
program specialization can
early computations and
knoblock and ruf
program specialization is
specialization at compile
a program which
in the residual
of program and
of the program
a residual program
size of the
and limitations of
the innermost loop
the cache is
the code size
a new program
the invocation of
intensive a program
computations of each
data specialization are
dyn d j
data specialization to
invocation of procedure
if e dyn
specialization time and
code size of
data specialization for
for program specialization
procedure f is
cause code explosion
the specialization process
data specialization in
dynamic or static
a doubly nested
expensive data aeow
in the reader
computations program specialization
encodes the result
to perform data
berkeley packet lter
is data specialized
1 program specialization
of both program
struct data cache
analyze two programs
e dyn d
ts and limitations
two programs where
in the loader
the residual code
specialized program and
int dyn int
data specialization when
control aeow graph
aeow intensive a
program specialization or
control aeow computations
than the unspecialized
specialized program is
speedups see figure
the specialization problem
to program specialization
programs where performance
scienti c programs
perform data specialization
the bene ts
or cached by
the unspecialized program
the romberg integration
computations which depend
specialization and data
dyn int d
bene ts and
by data specialization
or static dynamic
data specialization the
in a doubly
problem size increases
program specialization the
doubly nested loop
program is data
nested loop and
mainly consists of
if if e
the original one
the program is
to be cached
on partial evaluation
a binding time
program and the
which depend on
of the computations
partial evaluation and
of the early
the size of
the reader the
number of iterations
does not improve
loop and the
its time complexity
program to be
can be completely
as the problem
side of figure
more than half
than half of
the result of
whereas data specialization
kept dynamic to
with data specialization
assess the bene
similar speedups see
limitations of these
c k w
are made dynamic
specialized and program
is mostly the
specialized at compile
hand program specialization
programs data specialization
this situation data
asian symposium on
int w n
c programs 8
contrast data specialization
are kept dynamic
is parameterized with
line program specializer
both aimed at
both strategies and
parameterized with respect
the size increases
systems 10 11
which approximates a
cache int j
int stat int
specialized program using
source program b
propagates binding times
interval using estimations
one hand program
are both aimed
specialized program figure
data aeow intensive
candidate for program
produced by program
specialization we now
program applications the
2002 aizu japan
program is mostly
than the specialized
ps ct the
code explosion if
2 data specialization
body can be
program b specialized
e stat is
because a new
2 1 program
september 12 14
ct the program
specialization for a
case of program
cached by data
14 2002 aizu
beyond some number
d struct data

corpus/krapavin2000-test/609203.txt
cyclone
tal
template
mexp
codegen
splice
tempo
int
compiler
instructions
certifying
fill
hole
popcorn
specializer
annotated
templates
cut
specialization
safety
holes
x86
italicized
env
stack
assembly
safe
code
cgdump
templatebeg
verifier
generation
scoping
region
declarations
sp
certificate
ml
dyc
dumped
eax
malloc
macros
compile
constructs
front
hidden
jumped
esp
frame
cgfill
cgstart
splc
specializers
templateend
compiled
outermost
compilation
morrisett
vis
instruction
arguments
gen
dialect
italics
typing
markers
mode
mov
float
action
fragments
precondition
modulus
cghole
specialized
lexical
postcondition
macro
program
necula
microsoft
statement
visible
analyses
italic
marker
filled
optimizations
typed
specializing
register
issued
language
stmt
emits
bugs
exp
body
dump
executable
invariants
concerns
specializa
cgabort
modifiers
cgend
untrusted
assembled
label
exponent
plate
exponentiation
programmer
object
nested
compiles
tem
translation
consel
masm
retn
shaders
normal
id
manipulating
beg
impressions
crew
lawall
statically
filling
meta
linker
dumps
popped
programs
translated
interpreter
statements
allocating
args
return
generators
fig
ffl
evaluated
julia
encountered
certified
pointer
jump
closures
emitted
invariant
security
translating
allocate
box
caught
notices
mobile
func
fills
source
generating
concatenated
declares
unsafe
writer
transforms
loop
translates
translate
sigplan
speedup
generates
manipulated
aircraft
aborts
frames
usable
expression
bindings
appended
environments
gram
static
expands
allocates
neces
strmer
modifier
plesko
helsen
blau
ible
tered
provokes
codegens
tal t
code generation
run time
a template
time code
action annotated
the cyclone
object code
a cyclone
in cyclone
of mexp
the tal
mexp sp
certifying compiler
of tal
the template
generation region
the hole
annotated program
cyclone program
mexp gen
template and
type safe
template code
the tempo
assembly language
front end
a certifying
time specializer
and fill
function mexp
return codegen
m templatebeg
cyclone compiler
cyclone and
a tal
splice and
codegen int
t instructions
dynamic code
code that
type safety
f int
local variables
certifying compilation
normal mode
int mexp
t program
x86 instructions
time specialization
codegen cut
into tal
cut splice
splice statement
jumped to
italicized constructs
tal instructions
fill holes
cut statement
ml box
a codegen
code and
the type
the compiler
our system
the code
c program
a type
the verifier
in tal
and tal
at run
the stack
int f
lexical scoping
code fragments
type system
typing rules
m templateend
non italicized
template end
esp 0
template mode
of x86
codegen expression
l hole
int base
compile cyclone
cyclone env
safe dialect
l template
tempo front
e vis
be jumped
meta ml
invariant arguments
to tal
during specialization
the popcorn
cyclone s
the function
that generates
and template
template the
instructions are
the region
dialect of
generation process
the front
of tempo
first template
and certificate
morrisett et
int s
is compiled
be evaluated
the object
typed assembly
template is
compiler is
int x
first non
static analyses
label l
declarations of
and local
the while
type of
constructs that
in italics
arguments are
a cut
italicized code
float int
hidden frame
subsequent paper
mov esp
non italic
exp int
popcorn compiler
codegen s
normal code
on cyclone
splc end
exponent and
ffl tal
cyclone has
int mod
new tal
generates code
is dumped
0 eax
int exp
object templates
cyclone programs
region stack
generation regions
of morrisett
fill e
codegen or
tal procedure
env cyclone
old region
m fill
nested codegen
move instruction
non hidden
ffl cyclone
mod f
cyclone to
or splice
inter template
to cyclone
cyclone language
tem plate
tempo and
of cyclone
the cut
program into
mobile code
instructions to
source code
a hole
is encountered
a precondition
template at
evaluated when
modular exponentiation
tal a
our compiler
fill is
int g
of env
new template
an int
template that
specialized function
hole is
while loop
second phase
run time code
time code generation
the tal t
action annotated program
code generation region
the object code
the code generation
a certifying compiler
and local variables
run time specializer
of a template
tal t instructions
a cyclone program
return codegen int
object code and
dynamic code generation
the type of
the front end
run time specialization
tal t program
splice and fill
of tal t
cut splice and
code generation process
dialect of c
codegen cut splice
an action annotated
the cyclone compiler
type of a
a type safe
at run time
a template and
of the template
the tempo front
to tal t
f int s
function mexp sp
int s t
code and certificate
parameters and local
be jumped to
tempo front end
t x d
into a cyclone
the action annotated
type safe dialect
safe dialect of
tal t to
morrisett et al
the first template
code that will
code that generates
a code generation
front end of
typed assembly language
a procedure is
the first non
a c program
the old region
fill the hole
non hidden frame
int exp int
of morrisett et
a tal procedure
program to cyclone
float int f
within a template
sequence of x86
exp int mod
mov esp 0
env cyclone env
the new tal
annotated program to
in tal t
in normal mode
tal t will
the template and
mod f int
a template is
that generates code
code of mexp
the region stack
splice statement is
be evaluated when
of code generation
used to fill
of x86 instructions
a subsequent paper
new tal t
int float int
ffl tal t
nested codegen s
and tal t
esp 0 eax
body of h
x d s
into tal t
the popcorn compiler
first non hidden
code generation regions
the cut statement
cyclone to tal
int mod f
a codegen expression
tal t is
code generation it
of mexp sp
program into a
the while loop
f int x
int f int
and the front
declarations of the
the source level
of the tal
a template with
function that generates
code generation is
the specialized function
that will be
of a function
higher order types
that generates a
is compiled into
in a subsequent
will appear in
the second phase
a function that
in our example
a sequence of
to range over
in the body
a run time
of run time
the body of
can be evaluated
appear in a
26 template end
a source language
template code that
is issued at
a tem plate
popped off the
compiles a type
generation region this
sequence of tal
cyclone compiler is
during specializa tion
template end splc
1 action annotated
cg fill holes
produces object code
in template mode
to compile cyclone
generate a function
label or address
postcondition of the
a simple move
mexp int base
onto the stack
are x86 machine
cut can only
to object code
codegen or splice
c 20 21
source language program
an outermost frame
stack of code
language program and
arguments are invariant
tal t language
args on stack
c into tal
write e vis
example the cyclone
go beyond what
types in cyclone
instructions are x86
a non italic
local variables will
with register allocation
popcorn compiler of
that supports run
object code satisfies
in italics in
generates a function
using pointer types
the current code
label l template
pushed onto the
code generation cyclone
and emits tal
of mexp gen
cyclone source code
takes a source
expression fill e
and the tal
base int exp
int mexp int
written in cyclone

corpus/krapavin2000-test/609226.txt
reflective
reification
interpreter
reified
datalist
dispatch
argse
reifiable
reflection
locale
mops
instancelink
reify
eval
java
expmethod
methodlist
mop
tower
arg
metaj
referent
m11
lookupdata
isreified
deification
expid
baseinstance
msg
interpreters
exp
lookup
fn
lookupmethod
expassign
4pair
methodid
fst
object
superclass
m1
extendslink
expnew
1k
args
field
runtime
snd
basename
eval_original
name
receiver
string
parser
specially
metaobject
tostring
f1
smith
fields
classid
meta_level
aclass
towers
explist
wf88
baseclass
reifiedrep
instancewithtrace
println
tailored
constructor
transformation
lisp
clos
private
sender
generic
exemplified
exps
baserep_field
expdata
getextendslink
metapair
booleanvalue
metacircular
printablepair
kic91
return
body
extends
meta
introspection
lhs
languages
semantics
13b
oriented
prototype
technicalities
smalltalk
accessible
operator
tracing
dispatching
interpretation
jjt
java2expvisitor
aff95
iguana
unreified
countinstances
instanceof
stringlist
bri89
ghjv95
intercession
amy96
meu98
krs
mul92
smi84
entities
classes
color
security
environment
interprets
parsed
debugging
agora
asai
imperative
senders
layer
creates
seminal
implements
stack
trace
modify
13a
ast
expression
representations
syntax
coda
verbatim
distinguishes
active
sake
inheritance
accessed
transformational
remember
arguments
selective
objects
operators
protocols
adaptability
prog
9b
gaining
delegated
prints
suppressed
base
levels
expressive
interfaces
identifier
calls
nr
message
functional
ba
tackled
null
rhs
modified
typed
correctness
profiling
instantiating
programming
programs
traces
super
intentionally
id
dynamically
redefine
designers
else
rewriting
program
branches
middleware
lightweight
reflective interpreter
non reflective
dispatch object
of reflective
the interpreter
the dispatch
the reification
reification of
reified representation
the reified
generic reification
class instance
method call
argse add
the reflective
reflective programming
reification technique
base representation
class pair
environment locale
eval environment
our reification
m 1k
the class
reification scheme
data eval
arg m11
reflective systems
return this
original class
reflection in
extends exp
reification operator
interpreter definition
specially tailored
a reflective
original interpreter
interpreter in
see figure
class name
a reified
method m1
datalist datalist
interpreter at
arg m
instancelink datalist
m11 arg
interpreter is
an instance
class class
object oriented
interpreter s
this representation
program transformation
of pair
string name
environment argse
f1 type
dispatch objects
type fn
reified object
be reified
lookup name
this datalist
reflective interpreters
field referent
class instancelink
fst and
class expmethod
non reifiable
active representation
tailored mops
object pair
the method
the transformation
the base
pair is
a dispatch
type f1
and snd
a class
base class
local environment
of reflection
the receiver
at runtime
arg fn
method lookupdata
accessible representation
f1 arg
reflective tower
datalist field
the deification
reflective programs
oriented interpreters
instance class
explist args
exp private
private exp
interpretation layer
3 lisp
using reflection
data lookupdata
method reify
arg f1
to reify
class expid
reflective towers
reflective languages
on reflective
smith like
prototype based
dispatch class
system out
out println
reflective system
instance see
pair pair
this isreified
lookupdata string
our generic
exemplified in
smith s
be modified
the non
runtime system
level n
representation is
interpreter program
method return
return new
security properties
of instance
at level
the sender
user programs
an accessible
provides access
the tower
an object
the field
its method
our approach
representation to
as exemplified
syntax tree
interpreter for
the superclass
after reification
language designers
class baseinstance
reflective one
m11 type
a mop
metacircular interpreter
field f1
fn name
m1 method
pair string
interpreter as
metaobject protocols
send msg
eval_original locale
method eval
to reflection
meta object
reified one
1k arg
datalist lookup
type m11
msg msg
extra interpretation
field instancelink
expmethod extends
non reified
expmethod eval
name return
fn arg
m1 type
type m1
representation instance
field fn
deification operators
interpreter memory
m1 arg
method lookupmethod
a reification
reification process
field list
reification operation
side expression
global environment
reflective capabilities
its class
definition of
the object
a method
type m
current representation
private string
non reflective interpreter
the non reflective
the dispatch object
the reified representation
the base representation
in the interpreter
data eval environment
eval environment locale
the class instance
of the reflective
a non reflective
of reflective programming
arg m 1k
the reflective interpreter
of the interpreter
the original interpreter
the original class
the method call
fst and snd
specially tailored mops
f1 type fn
reflective interpreter in
reification of the
a dispatch object
interpreter at level
the class pair
generic reification technique
at level n
of the non
a method call
the interpreter s
representation to the
the interpreter at
an accessible representation
our reification technique
to the dispatch
our reification scheme
exemplified in section
the field referent
object oriented interpreters
class instancelink datalist
the reification of
system out println
instancelink datalist datalist
reified representation is
instance see figure
extends exp private
of our reification
representation is active
environment argse add
reflective interpreter is
m11 arg m11
interpreter in order
the generic reification
the object pair
the reification operator
our generic reification
generic reification scheme
if this isreified
data lookupdata string
dispatch object and
interpreter s memory
lookupdata string name
as exemplified in
definition of the
of the transformation
provides access to
to be modified
in order to
this datalist lookup
method m1 type
m1 arg m11
a generic reification
m1 method m1
of reflection in
and security properties
work on reflective
arg m11 type
use of reflection
by the interpreter
datalist datalist field
type m1 method
reflective programming in
the current representation
the reflective tower
m11 type m
in the reflective
the deification operators
method call is
the reification process
type m 1k
a reflective interpreter
the method lookupdata
class expmethod extends
m1 type m11
method m1 arg
original class name
dispatch object instance
arg f1 type
return this datalist
of the reification
type fn arg
type f1 arg
the interpreter memory
examples of reflective
m 1k arg
by a dispatch
f1 arg f1
accessible representation of
the dispatch objects
the method eval
the class class
arg m11 arg
hand side expression
fn arg fn
string name return
original interpreter definition
name type f1
datalist lookup name
name return this
pair pair pair
efficiency and security
reified representation of
expmethod extends exp
1k arg m
base representation to
type m11 arg
smith s seminal
from the base
of the generic
see figure 12
list of methods
the base class
the value denoted
a potentially infinite
for debugging purposes
provide access to
by a class
for object oriented
by an instance
value denoted by
representation of the
of the method
is implemented by
remember that the
by means of
the sake of
for the sake
of a class
object oriented languages
of the class
the behavior of
almost all of
dispatch class instance
after reification of
add reifiedrep this
smith like reflection
above do not
as eval in
reflective programming is
points back from
incoming method calls
baseinstance say b
meta_level booleanvalue return
field f1 type
to among others
denoted by 4pair
type fn field
a reified representation
mops in this
representation and a
object protocols mops
infinite tower of
parser java jjt
the active representation
instancelink denotes the
generated dispatch class
level n interprets
or the reified
args data eval
method lookupmethod string
if locale member
on reflective middleware
constraints are different
extra interpretation layer
interest in practical
others expressive power
method call tracing
e isreified is
datalist datalist instance
our non reflective
called meta object
reified object is
a reflective system
fn name referent
called metaj metaj
seminal work on
has been reified
new tower level
java java2expvisitor java

corpus/krapavin2000-test/609228.txt
powerdomain
security
pers
secure
st
jck
hs91
binding
semantics
noninterference
powerdo
flow
equivalence
command
leino
hh
probabilistic
lj98
powerdomains
slam
termination
commands
joshi
hr98
jhh
jp89
denotational
strictness
nondeterminism
snd
equational
volpano
your
you
interpretation
denotations
semantic
soundness
denotation
extensional
confidentiality
confidential
nondeterministic
theta
sabelfeld
hun91
lau89
hun90
leak
analyses
relations
zdancewic
sigplan
notices
flows
lapadula
programs
jp
convex
projection
anindya
polymorphic
strict
andrei
imperative
mains
calculus
static
specification
behaviours
correctness
iff
deemed
sensitive
vsi96
sv98
ipo
conditio
mastroeni
lubs
gm82
egli
declassification
isabella
giacobazzi
quotienting
smy78
interpreta
denning
h2st
benton
den76
milner
isomorphic
idempotent
financial
hoare
ker
dependencies
ap90
leakage
launchbury
kleisli
mads
axiomatic
lift
evaluations
program
dependency
nontermination
downgrading
chalmers
clarifies
possibilistic
banerjee
projections
treatment
dam
hunt
forgetting
myers
compositional
lattice
language
composition
lattices
operational
nonterminating
threaded
smyth
steve
id
instrumented
pow
equiv
relational
subtyping
powerset
secrecy
plotkin
integrity
jb
untrusted
concurrent
den
polymorphism
smith
inclusion
roberto
style
nick
abstract
arguments
deterministic
unwanted
unifies
ning
interference
sequential
degrees
fi
encryption
bell
reflecting
observer
trust
subsets
inspired
finitely
partial
jc
functional
vary
sound
reflexive
cunningly
hankin
etayer
ms92
mantel
giambiagi
indiction
publicdomain
oteborg
leonor
goo
formali
ar80
trusting
p97
nie90
fandrei
wad89
rbaek
cheol
preoreder
justifica
jbks
99g
02st
security condition
information flow
equivalence relations
secure information
high theta
binding time
the security
theta low
security properties
probabilistic powerdomain
time analysis
per d
command c
of security
partial equivalence
powerdomain semantics
a per
2 per
all theta
p st
of powerdomain
equational security
jck c
convex powerdomain
termination sensitive
security type
slam calculus
and joshi
the per
low high
of secure
a command
low security
the slam
leino and
information flows
per model
is secure
the program
the probabilistic
and low
program c
based security
upper powerdomain
type high
calculus hr98
jhh k
projection analysis
probabilistic security
equivalence relation
the denotation
denotation of
the convex
security levels
deemed to
high part
the equational
flow in
type system
higher order
high and
high low
log file
of pers
sequential programs
partial evaluation
order functions
acm sigplan
in st
of commands
notices v
g ffi
pers to
per based
powerdo main
partially confidential
concurrent language
per p
powerdomain interpretation
lower powerdomain
for strictness
anindya banerjee
pers on
of confidentiality
correctness arguments
probabilistic semantics
security types
in lj98
powerdomain p
powerdo mains
relational semantics
ker c
flow properties
theta id
andrei sabelfeld
sigplan notices
jp j
for secure
a program
semantics based
is isomorphic
semantics of
static analysis
abstract interpretation
the hoare
ffi f
strictness analysis
imperative language
any command
of binding
steve zdancewic
non interference
theta st
high security
one must
of information
denotational semantics
constant function
a security
dependencies in
the high
of evaluations
security by
of st
computer security
a low
semantics we
semantics and
flow analysis
program analysis
programs are
e d
on d
analysis is
let us
an extensional
lattices of
in security
the denotations
the semantics
a probabilistic
of program
condition for
to lift
we might
treatment of
for security
denotations of
analysis for
in sequential
security analysis
nondeterministic choice
of h
relations all
joshi lj98
alternative semantic
variables h
power domain
termination insensitive
g subsets
lift a
pers we
command b
bottom reflecting
pers in
your sensitive
den ning
jc 1
that jck
clarifies and
high variable
terminates but
security half
powerdomain is
smyth or
powerdomain in
security conditions
thus able
to pers
powerdomain 1
static arguments
discrete powerdomains
ning s
mads dam
an instrumented
powerdomain the
c myers
launchbury s
sensitive security
discrete powerdomain
in hs91
representing degrees
2 jck
roberto giacobazzi
analysis hs91
l st
hs91 this
unifies a
domain st
secure iff
secure information flow
the security condition
binding time analysis
high theta low
of information flow
of secure information
information flow in
partial equivalence relations
high and low
low high theta
the slam calculus
theta low high
leino and joshi
per model of
the convex powerdomain
security properties of
equational security condition
the equational security
a command c
security condition is
2 per d
the probabilistic powerdomain
c is secure
the denotation of
value of h
deemed to be
of the security
higher order functions
sigplan notices v
acm sigplan notices
the state is
properties of higher
of security properties
r 2 per
choices of powerdomain
degrees of security
for any command
information flow the
information flow properties
use of pers
all theta id
in sequential programs
the per based
slam calculus hr98
model of secure
how the per
information flow analysis
security condition for
any command c
of the slam
a concurrent language
based security condition
function in st
type high low
g ffi f
the equivalence relations
denote the relation
the high part
high part of
the semantics of
h and l
of computer security
in the security
is isomorphic to
of higher order
the denotations of
a r b
order functions and
and a low
formal specification of
value of l
notices v 39
we show how
of the program
that the domain
a function in
in the convex
parts of the
partially confidential data
jck c b
equivalence relations in
the upper powerdomain
the f g
is termination sensitive
based formal specification
den ning s
sequential programs based
choice of powerdomain
for secure information
at partial evaluation
an extensional semantics
model dependencies in
of pers in
induced discrete powerdomain
roberto giacobazzi isabella
a pair where
this view motivates
security condition to
by leino and
of a command
specification clarifies and
discrete powerdomains p
to other forms
volpano and smith
output of program
a low security
thus able to
of program c
specification of secure
powerdomain of evaluations
in specifying binding
semantics based formal
a per p
known at partial
static analysis is
that jc 1
and low as
powerdomain is isomorphic
of high and
f g subsets
information flow we
is a per
probabilistic information flows
security type high
pers to model
specifying binding time
powerdomain p l
for strictness analysis
variables h and
are deemed to
the egli milner
style of semantic
unifies a number
f g sets
to pers we
which expresses that
bell and lapadula
security by partial
pair where h
the low security
powerdomains p st
intuitively the equation
symmetric and transitive
define the extension
high theta st
andrew c myers
run on data
probabilistic powerdomain semantics
calculus hr98 and
time analysis hs91
giacobazzi isabella mastroeni
of specific correctness
per d e
clarifies and unifies
our semantic interpretation
of the hoare
et al vsi96
the hoare or
pers in static
for binding time
the relational semantics
equivalence relations all
the smyth or
probabilistic powerdomain of
the lower powerdomain
p all theta
on representing degrees
to specify security
variables or processes
and unifies a
specify security properties
c run on
the probabilistic semantics
time analysis must
expresses that g
st is isomorphic
specification of what
security conditions in
subsets of st
partial evaluation time
of security by
a probabilistic powerdomain
st in the
to model dependencies
function g ffi
proposes an extensional
functions and partially
view motivates the
specific correctness arguments
inspired by and
extensional semantics based
equal if the
projections for strictness
denotation of a
to the convex
probabilistic security properties
sets of values
per d and
time analysis lau89
flow properties in

corpus/krapavin2000-test/609230.txt
jvm
cl
loader
invokevirtual
loaders
srmethod
loading
jdk1
desc
bytecode
srclass
def
java
getr
denition
findclass
soundness
saraswat
overrides
lvars
typing
objectref
subtyping
wf
vp
verication
dened
invv
resolved
bridge
formedness
parent
instruction
typedness
specication
predicate
java2
spoong
areturn
widening
overriding
ok
stack
rr
applet
speakup
verier
resolution
bug
dispatch
superclass
denes
selects
invocation
invokeinterface
resolves
mt
environments
loadings
safe
inside
applets
name
lemma
subtype
safety
formalization
bytecodes
stata
ndclass
verifyrecord
classname
tvalue
satises
linking
rst
descriptor
env
trusted
conversion
augmented
string
symbolically
delegation
constraint
veried
denitions
remembers
veries
dene
classdef
iface
delegations
cc
instructions
pc
delegates
abbreviates
abadi
modication
referenced
lang
redene
judgement
satised
transitivity
premise
names
lazy
transition
loaded
vironment
invariant
l1
00
dention
aws
classloader
exeception
coredumps
bracha
retval
loadclass
classes
security
heap
inconsistencies
exive
ects
preserves
nalization
invariantly
runtime
environment
transitive
selection
violation
induction
correctness
dierent
whereby
speci
interfaces
unrelated
resolve
member
aw
cial
supertype
appearing
descriptors
l2
signature
delegate
sun
virtual
sub
invoked
ow
eld
semantics
dening
formalizations
override
symmetry
violates
lemmas
cf
rt
succeeded
tokyo
loc
straints
indirect
transitions
invariance
consistency
ns
exibility
proved
en
typed
diers
veri
closure
super
formalizes
judgment
predicates
threads
expresses
faithfully
jensen
subroutines
elds
violate
proving
remember
references
existence
the jvm
def 2
loading constraint
of invokevirtual
constraint scheme
cl n
the loading
method resolution
class loaders
class loader
cl 0
jdk1 2
class loading
bytecode verication
n cl
method selection
the bytecode
saraswat s
value typing
cl cl
findclass scheme
the findclass
denition 2
class c
and def
vp l
l 0
class name
of java
the method
c cl
loading constraints
jvm is
method m
from def
invv ok
widening conversion
method desc
method dispatch
ok e
the soundness
well formedness
our model
soundness of
well typedness
objectref class
parent loader
type spoong
t class
method cl
dispatch table
the lemma
a method
l 00
subtyping relation
lemma 1
loaders are
class d
s bug
denes class
jdk1 1
of jdk1
bytecode verier
the symbolically
bridge safety
symbolically referenced
predicate selects
jvm state
loader 0
and method
selection process
a class
denition of
jvm and
string list
def 4
the denition
of class
an environment
each class
the java
the widening
formedness of
soundness theorem
method overriding
l vp
r speakup
in jdk1
loader 2
loader l
direct parent
wf parent
parent e
augmented typing
0 cl
context cl
class loadings
cl pc
augmented value
loader 1
java virtual
any class
the type
dened in
the specication
the augmented
superclass of
method invocation
object value
soundness proof
the subtyping
is dened
r l1
rr getr
d getr
cl is
cl method
i getr
its bytecode
c selects
invokevirtual and
srmethod and
method overrides
stata and
the ndclass
safe e
found inside
method cc
theorem trusted
srmethod the
context l
ndclass scheme
trusted environments
wf method
applet loaders
parent loaders
predicate overrides
bridge safe
r getr
error state
selects srmethod
selects m
x loader
name desc
and abadi
loaders the
instruction of
the class
in context
1 correctness
class names
s problem
therefore from
of method
l 2
states that
n l
l 1
environment e
r l
resolved into
loader in
java is
of environments
objects classes
type safety
2 4
in e
virtual machine
2 5
relation between
resolution process
also invariant
sun s
verication the
the well
2 7
is resolved
which satises
rule of
method e
type r
premise of
been resolved
safety of
satises the
into c
invocation of
subtype of
2 13
pc lvars
by loader
local stack
t method
r l2
signature x
type env
of saraswat
c name
of java2
of the jvm
loading constraint scheme
the loading constraint
the method resolution
and def 2
the findclass scheme
the method selection
cl n cl
the jvm is
the bytecode verication
invv ok e
method selection process
correctness of invokevirtual
from def 2
method dispatch table
the jvm and
cl cl n
the widening conversion
the symbolically referenced
a class loader
saraswat s bug
of the lemma
the soundness of
of the loading
soundness of the
well formedness of
wf parent e
if the jvm
parent e p
saraswat s problem
the well typedness
1 correctness of
augmented value typing
of jdk1 2
the denition of
the well formedness
the java virtual
the subtyping relation
java virtual machine
def 2 7
an error state
n cl 0
l vp l
bytecode verication the
constraint scheme and
method resolution process
superclass of c
def 2 9
the method dispatch
wf method e
the ndclass scheme
n cl cl
the bytecode verier
of class loading
the augmented typing
stata and abadi
lemma 1 correctness
loader in e
proving the soundness
bridge safe e
for the soundness
denition 3 1
n l 0
l n l
is also invariant
section 2 4
e an element
the lemma the
6 6 6
the invocation of
an element of
10 rule of
assume the rst
def 2 6
if wf parent
the jvm the
the jvm it
with the loading
tvalue and t
class loading of
1 and def
vp l 00
the invokeinterface instruction
class t loader
re exive and
def 2 1
method overrides srmethod
vp l 0
in jdk1 1
the soundness proof
jvm is in
subtyping relation between
class loader l
is resolved into
0 cl 0
existence of method
of class loaders
a jvm state
def 2 13
cl 0 n
objectref class and
between objectref class
t class t
and t method
type spoong in
typing which is
second premise of
l 0 vp
srmethod and method
each class name
cl 0 cl
wf class e
lvars and stack
context l 2
symbolically referenced method
symbolically referenced class
cl vp l
property related to
lemma 3 existence
existence of constraints
the jvm which
applet loaders are
of saraswat s
s problem 13
select a method
the local stack
the jvm are
of type r
rule of invokevirtual
why applets cannot
resolved into c
cl n 0
direct parent loader
cl pc lvars
cl method desc
with signature x
the second premise
objects classes and
t loader tvalue
spoong in jdk1
that the jvm
theorem trusted environments
lemmas 1 1
dened in figure
2 10 rule
0 vp l
inside the current
def 2 10
def 2 3
the type spoong
loader tvalue and
about to execute
method cl method
to execute invokevirtual
its bytecode verication
is dened in
safety of the
section 2 5
satises the following
the induction hypothesis
in section 2
the following fact
denition 2 7
class c has
the method invocation
instruction of the
r l 1
3 existence of
which satises the
a safe state
value v is
rst line of
r l 2
class loading in
class loaders are
dynamic class loading
be an environment
is proved by
with respect to
2 3 5
and transitive closure
the rst line
specication of the
in a safe
the type safety
for each class
3 1 1
l 2 the
the current context
cf section 2
type safety of
p l 0
transitive closure of
the following constraint
an environment which
of our work
in the java
formal model of
and a class
the specication of

corpus/krapavin2000-test/609232.txt
ml
termination
nat
dml
reducible
withtype
terminating
cs
int
recursion
reducibility
acc
metrics
fun
typing
redex
programmer
hi
xs
metric
typed
derivable
par
funs
ackerman
datatypes
cmp
mutual
orderings
f91
bool
ack
proving
program
char
p2
p1
polymorphism
structural
recursive
dependent
decorated
verification
trss
natg
qs
matches
expressions
proven
dom
liveness
checking
establishing
hongwei
nuprl
founded
judgments
pvs
quicksort
erasure
judgment
index
practicality
syntax
rewriting
xi
substitutions
realistic
ordering
checker
continuation
nating
feel
datatype
lexicographic
attach
body
currying
donnelly
mercury
1i
satisfaction
renewed
explode
typable
coq
labelling
annotation
readily
verifica
height
labels
closed
verifies
nonterminating
termi
isabelle
len
primitive
contexts
programs
difficulty
formed
omit
characters
verified
safety
induction
interactive
ji
forming
jej
rules
verifying
errors
verify
novelty
accept
derivation
treatment
semantics
abstracting
synthesize
sorts
calculus
kevin
substitution
programming
loop
usual
automated
handled
toplas
hn
clause
string
unclear
calls
detecting
effort
informally
fn
expression
pattern
guaranteeing
constructors
smoothly
lam
language
prototype
corollary
semantic
hesitant
minating
glenstrup
easing
0092703
untrue
undeniably
belling
endless
carthy
hap
mechanized
unobtrusiveness
1147
obtrusive
amram
ilam
thunk
arne
chiyan
ats
cast
contribution
91
else
suffices
spend
normalizing
star
demonstrating
interpretations
integer
minor
tuples
lambda
unwilling
deem
technicality
subscripting
1215
redexes
pens
dependently
decorate
trs
godel
checks
label
program termination
in ml
dependent types
termination verification
ml 0
in dml
mutual recursion
is terminating
termination checking
index expressions
type system
reducible for
the programmer
termination of
a redex
program errors
structural ordering
ml is
recursive function
is reducible
int i
i nat
reducible if
are reducible
cs matches
for ml
the termination
well typed
with metrics
of ackerman
cmp x
programming features
proven terminating
establishing program
redex which
ackerman function
metric typing
types in
of reducibility
the metric
of form
to program
a type
the type
a program
general recursion
interactive theorem
typed program
every well
if e
derivable in
the dependent
n nat
program in
programmer to
a metric
typing rules
reducibility for
int a
dml can
par cmp
structural orderings
hi j
nat j
withtype a
metric hi
length cs
detecting program
loop j
and polymorphism
assume derivable
primitive recursion
our approach
for establishing
higher order
rewriting systems
theorem proving
e is
reduces to
term rewriting
of cs
ml in
types int
cs 0
of ml
a 7
a list
e 0
type checking
metrics for
natural numbers
language ml
18 14
nat n
subject reduction
an implementation
be proven
dynamic semantics
recursion the
order functions
a derivation
to e
the body
which reduces
nat int
usual lexicographic
program error
hongwei xi
f reducible
automated termination
b int
a decorated
recursion higher
have types
of dml
decorated type
hi ji
closed recursive
informally explain
fun f
significant programming
reducibility let
j nat
else acc
termination proofs
xs withtype
rule type
termination checker
derivable and
systems trss
reducibility is
acc is
closed expression
p1 p2
body of
rules for
well founded
satisfaction relation
simply typed
of index
of dependent
we write
we form
practical programming
typed closed
type annotation
int j
types developed
char c
terminating in
including mutual
founded orderings
f 7
and int
facilitate program
i int
datatypes and
termination analysis
7 e
checking in
safety property
a safety
e 2
that e
a closed
function call
recursion is
of pattern
of type
be readily
programming language
terminating with
pattern i
we attach
a language
an expression
verify that
to verify
expression of
proving the
then e
for verifying
2 dom
checker for
metrics with
x xs
be formed
the treatment
the usual
liveness property
development cycle
lexicographic ordering
index variable
attach the
f in
ordering on
corollary 3
type and
implementation of
a termination
program termination verification
to program termination
dependent types in
in ml 0
the termination of
the type system
approach to program
types in dml
notion of reducibility
in ml is
for establishing program
redex which reduces
a redex which
derivable in ml
of ackerman function
are reducible for
establishing program termination
is a redex
of index expressions
well typed program
reduces to e
every well typed
interactive theorem proving
the programmer to
an implementation of
typing rules for
a language ml
that every well
implementation of ackerman
be proven terminating
typed program in
of reducibility for
reducible if e
reducible for all
the dependent types
in dml can
par cmp x
detecting program errors
the metric hi
e is reducible
which reduces to
our approach to
term rewriting systems
type system of
in the type
corollary 3 10
of dependent types
in the body
allows the programmer
a safety property
prove that every
termination of a
a recursive function
need to verify
the body of
cannot be proven
termination verification is
rewriting systems trss
of pattern i
with a structural
recursive function call
for detecting program
of form a
types developed in
a structural ordering
fun f a
program in ml
every term in
form of dependent
e are reducible
closed expression of
reducibility let e
attach the metric
program errors that
program termination is
programming features such
significant programming features
ml 0 is
mutual recursion higher
1 of pattern
the usual lexicographic
a termination checker
language ml 0
rules for ml
dependent types developed
proven terminating with
types int i
the dynamic semantics
i nat j
closed recursive function
a decorated type
programmer to provide
nat j nat
is terminating in
including mutual recursion
well typed closed
usual lexicographic ordering
a closed expression
termination proofs for
recursion higher order
errors that cause
higher order functions
of f in
by corollary 3
well founded orderings
in practical programming
types in practical
for program termination
programming language that
e 2 in
program development cycle
contribution of the
a type system
is a derivation
term in t
to verify that
that allows the
of our approach
e e 0
lemma 3 9
to e 2
that e 0
we form a
of type and
a liveness property
the program in
the satisfaction relation
we can derive
it is common
be a closed
e 0 is
program in figure
in t is
let e be
a prototype implementation
e is a
the notion of
can be readily
i pattern j
difficult to be
kevin donnelly hongwei
theorem proving systems
design a type
e is 0
of par we
dependent sum type
j funs f
for termination checking
par in the
program termination and
than 0 under
k nat int
decreasing when a
p1 p2 if
of which hold
combines types with
terminating in ml
metrics for verifying
is 0 reducible
integer expressions with
xs of x
type for integer
which hold since
essentially extends the
a character list
prefix of cs
with some significant
a metric typing
withtype n nat
quicksort on a
nested recursive function
closed metric e
that of ml
structural ordering on
donnelly hongwei xi
only primitive recursion
n u r
p2 i nat
char list i
is terminating we
nat int k
a list n
technical contribution of
a renewed effort
handled with a
sequence of index
nuprl 2 coq
subject reduction theorem
we informally explain
approach to realistic
if e are
realistic programming language
termination verifica tion
example can not
either programs or
datatypes and polymorphism
often have difficulty
acc p1 cs
algebraic datatypes and
f 7 e

corpus/krapavin2000-test/609238.txt
xpoint
cbv
uniformity
iterator
filinski
axioms
calculus
continuations
hasegawa
kakutani
rigid
recursion
axiom
category
iterators
operators
monad
operator
uniform
functionals
axiomatization
bijective
simpson
kleisli
categorical
rst
plotkin
switch
stable
selinger
cps
continuation
cpo
morphism
typed
pets
centre
lambda
correspondence
algebra
monads
bot
fixpoint
semantic
xpoints
sml
stability
algebras
theories
eects
duality
centrality
eta
morphisms
central
coproducts
denition
justied
sound
proposition
loop
recursors
bekic
conway
premonoidal
dinaturality
fuhrmann
rigidness
style
products
syntactic
bijectivity
axiomatized
eect
equational
strict
functional
dene
canonically
typing
parameterized
adt
nite
tx
ty
iteration
reasoning
characterisation
fun
lemma
spelling
hy
principles
dened
counterpart
axiomatics
fossacs
thunkability
filin
dinatural
jerey
discardable
strictness
arose
summarised
focal
monadic
arrow
languages
categories
diagonal
adjoint
equivalently
predomains
thielecke
inspecting
constructions
converse
axiomatic
ki
response
principle
name
hofmann
judgements
moggi
nj
hx
veried
theoretic
thesis
contravariant
capital
carsten
cartesian
bottom
completeness
sabry
totality
axiomatizations
ski
exponentials
dierent
remark
combinators
uniquely
amounts
dening
maps
passing
ole
soundness
commutes
parametrically
judgement
subterm
congruence
enjoys
semantics
sucient
strong
graphical
conversely
shall
strengthen
characterised
recalling
objects
notion
calculi
negative
presence
family
parameterization
appendix
consideration
lifting
syntactically
expansion
sums
interpreting
notions
distilling
tinuations
specialise
blain
alpgebra
2030
trivialising
thunkable
schweimeier
ciple
chasings
ohori
partical
isao
copyable
tensorial
distill
axiomatisations
xpoint operator
call by
by value
xpoint operators
t xpoint
uniform t
stable uniform
c calculus
cbv xpoint
the uniformity
filinski s
an iterator
for recursion
in call
axioms for
and kakutani
hasegawa and
rst class
recursion in
class continuations
uniform cbv
the cbv
uniformity axiom
be m
operator on
value xpoint
rigid functionals
bijective correspondence
cbv calculus
the call
switch 1
uniformity principle
the c
value calculus
category of
m in
uniform call
uniform iterator
a uniform
r c
category c
t algebra
a xpoint
simpson and
our axioms
by name
of continuations
on negative
and plotkin
computational lambda
x v
uniformity for
of simpson
uniform xpoint
iterator on
algebra morphism
s uniformity
in let
a category
axiomatization of
a bijective
lambda calculus
x be
not free
algebra structure
uniformity principles
c theory
uniform iterators
restricted on
cbv theory
a cbv
negative types
the axioms
calculus as
free in
r a
of rst
sound and
c t
uniformity condition
operators in
the category
function types
by filinski
stability axiom
cps transformation
negative objects
of xpoint
strong monad
rigid functional
and iterators
recursion and
and complete
category with
correspondence between
passing style
with rst
continuation passing
base category
object r
rigid in
is rigid
nite products
from iteration
and uniformity
fixpoint operators
let x
a response
a value
categorical semantics
values f
recursion from
notion of
a term
the stable
principles for
response category
least xpoint
plotkin 27
our axiomatization
xpoint equation
central if
cpo s
axiom on
t fixpoint
diagonal property
kleisli category
monad t
f holds
and switch
the uniform
an algebra
calculus in
of call
domain theory
is central
a stable
internal language
value programming
the kleisli
eta expansion
the cps
response object
is total
term m
computational model
models of
main result
total functions
centre and
with nite
second main
of uniformity
side eects
in bijective
s construction
calculus and
axioms are
the stability
the notion
reasoning about
h f
in n
operators and
and iteration
n x
of uniform
of centrality
rst main
in sml
value recursion
algebra morphisms
the bijectivity
value setting
value strictness
iterators in
iterator is
our uniformity
continuation monad
strict maps
types terms
step pets
iterators and
style reasoning
xpoint axiom
hy ki
of filinski
the monad
bekic property
loop g
iterator loop
operator restricted
recursors and
total such
about recursion
complete class
iteration theories
rigid by
a bot
uniquely extends
call by value
uniform t xpoint
the c calculus
be m in
t xpoint operator
recursion in call
in call by
axioms for recursion
the call by
xpoint operator on
for recursion in
rst class continuations
hasegawa and kakutani
uniform cbv xpoint
stable uniform cbv
cbv xpoint operators
t xpoint operators
by value xpoint
a uniform t
x be m
by value calculus
bijective correspondence between
stable uniform call
the uniformity principle
uniform call by
the cbv calculus
call by name
presence of rst
category of continuations
the uniformity axiom
simpson and plotkin
of rst class
computational lambda calculus
a bijective correspondence
value xpoint operator
the stable uniform
xpoint operators in
a uniform iterator
a stable uniform
not free in
sound and complete
let x be
of the c
cbv xpoint operator
t algebra structure
on r c
filinski s uniformity
iterator on r
the uniform t
uniform xpoint operator
an iterator on
of simpson and
xpoint operators and
an algebra morphism
in a cbv
with rst class
is a bijective
m in n
models of the
the category of
the cbv xpoint
a cbv theory
are not free
on negative types
a c theory
the stability axiom
of xpoint operators
of uniform t
recursion from iteration
base category c
notion of uniform
a xpoint operator
continuation passing style
the base category
v be m
m in let
in the c
a category of
in the presence
the notion of
of the cbv
operator on negative
value programming languages
uniform t fixpoint
xpoint operator is
a response category
value xpoint operators
be n in
centre and focus
a t xpoint
an internal language
in let y
category with nite
and plotkin 27
xpoint operator in
filinski s construction
internal language of
the kleisli category
c calculus as
t fixpoint operators
of call by
in the call
a call by
a computational model
u n x
and call by
by value programming
the uniformity condition
the computational lambda
from the uniformity
second main result
the presence of
of the call
the second main
of r c
in bijective correspondence
as an internal
y are not
operator on the
for reasoning about
and complete for
such that holds
iteration in the
recursion and iteration
lambda calculus 18
cbv xpoint axiom
uniquely extends to
by value recursion
on negative objects
h is rigid
n be m
xpoint operators with
cbv calculus as
from an iterator
switch and switch
operators of simpson
by value strictness
the least xpoint
stable uniform xpoint
in sml nj
total such that
and switch 1
language of a
complete class of
xpoint operator and
cbv calculus in
restricted on negative
response object r
a rigid functional
on general function
c calculus and
stability and uniformity
by value setting
calculus as an
2 the call
no other than
recursors and iterators
on an iterator
algebra morphism from
notion of centre
rst main result
with nite products
uniformity principles for
uniformity axiom on
our axiomatization of
our axioms are
the underlying categorical
operator on c
a uniform xpoint
operator restricted on
any value f
and complete class
a response object
category of algebras
such an h
computational model with
m in u
uniform iterators and
the cps transformation
an eta expansion
the xpoint operator
of rigid functionals
and focus in
in n be
xpoint operator restricted
h is total
1 the c
a t algebra
least xpoint operator
let y be
a sound and
f 2 c
let v be
family of functions
for any value
typed call by
c t x
free in f
a category with
calculus and the

corpus/krapavin2000-test/609316.txt
qos
seamless
wireless
mobility
portable
mobile
prayer
home
caching
backbone
file
consistency
disconnected
cached
handoff
tcp
network
negotiation
transport
adaptation
migration
cdpd
disconnection
networks
adapt
owned
outdoor
connection
ip
challenges
indoor
mode
policies
adaptive
management
notification
stations
files
hoard
autonomously
networking
cellular
reintegration
service
mosquitonet
hoarded
reaction
bayou
connections
environment
hoarding
modems
invalidation
server
interoperable
csma
collaboratively
fields
gracefully
contemporary
commercially
notifications
reconnection
bandwidth
medium
afs
network2
getqos
network1
template
pricing
goals
manager
diverse
aware
consistent
cells
10kbps
records
graceful
os
react
offs
conflicts
agent
notifies
rollback
organizations
station
trade
wired
ram
switches
standards
accompanied
operating
commercial
operated
policy
across
coda
record
connectivity
authentication
proprietary
inter
kept
transparent
semantic
mailbox
barwan
reintegrate
wlan
onus
dane
reintegrated
seer
appointments
mdm
pconsistency
ficus
private
scarce
imposes
traffic
grain
descending
notified
technologies
handling
bursts
granularity
mechanisms
invalidate
writes
man
supports
secretary
pda
100ms
voluntary
witnessed
provider
servers
read
clients
services
emergence
induce
layer
exception
virtual
environments
filesystem
1mbps
tdma
dwyer
snoop
stubs
security
explores
interfaces
heterogeneous
dynamics
granted
session
dynamically
partially
copy
disconnects
connectedness
mth
disconnections
sprite
abort
connected
viable
drivers
calendar
mh
predictive
email
directed
broad
targeting
negotiated
parametrized
nfs
interact
client
cache
reads
puters
priority
block
migrate
awareness
ghz
intermittent
managed
the portable
seamless mobility
mobile computing
the home
computing environment
portable computer
wireless networks
adaptive computing
consistency management
file system
wireless network
multiple wireless
mobility across
the mobile
disconnected operation
the backbone
qos class
the prayer
consistency policies
home computer
home and
a mobile
mobility over
qos changes
the application
partially connected
and consistency
the file
dynamic qos
caching and
application directed
mobile user
the network
network qos
different wireless
inter network
connected operation
support for
mobility and
different networks
the wireless
the qos
data transport
connection manager
in mobile
connected mode
backbone support
caching consistency
reaction to
qos negotiation
whole file
a portable
adapt to
commercial networks
computer may
application servers
kept consistent
environment which
and adaptive
of qos
dynamic operating
in qos
outdoor wireless
re negotiation
owned and
network mobility
adaptation support
between networks
migration between
handoff between
providing seamless
the environment
file systems
across different
networks and
base stations
cached data
the challenges
for partially
network level
available network
the applications
for mobile
distributed file
tcp ip
same network
application level
negotiation and
ip address
exception handling
computing environments
in prayer
collaboratively adapt
provide seamless
consistent read
variable qos
portable is
non interoperable
portable the
invalidation mode
cellular modems
home is
reintegration mode
and operated
prayer mobile
support disconnected
provides seamless
semantic record
autonomously owned
record caching
to qos
acceptable qos
network migration
for seamless
qos re
and outdoor
user mobility
challenges in
operating conditions
wireless networking
portable and
a wireless
cells of
over multiple
to provide
commercially available
semantic structure
qos in
three broad
execute if
switches between
upon reconnection
network connections
which support
to adapt
base station
challenges and
the dynamic
on top
application structure
uniform framework
networking technologies
and reaction
for disconnected
computing model
qos and
virtual point
networks is
a uniform
a template
mobility on
local copy
update conflicts
consistency on
networks a
and application
a file
of wireless
which supports
environment to
backbone network
may induce
applications to
prayer supports
low qos
level adaptation
qos the
home the
qos change
indoor and
point connection
measured qos
predictive caching
logical ip
user switches
g switches
interoperable wireless
in caching
level solution
medium transparent
qos network
qos bounds
in connected
to outdoor
portable in
multiple connections
ffl seamless
several viable
desired qos
service goals
in mosquitonet
then adapt
explicit consistent
to collaboratively
area wireless
contemporary research
home if
to hoard
and seamless
pricing structure
mobile computing environment
the mobile computing
the portable computer
seamless mobility and
the home and
caching and consistency
seamless mobility over
and the portable
multiple wireless networks
home and the
mobility and adaptive
on the backbone
seamless mobility across
and adaptive computing
a portable computer
the wireless network
and the home
at the portable
different wireless networks
partially connected operation
a mobile user
in mobile computing
a mobile computing
of the file
mobility across different
over multiple wireless
across different wireless
network for data
between the portable
the home computer
computing environment which
and consistency management
with the home
the file system
to the dynamic
wireless network for
portable computer may
adaptive computing and
between the home
the exception handling
environment which provides
the portable and
for partially connected
be kept consistent
the consistency management
the whole file
for data transport
wireless networks is
dynamic operating conditions
providing seamless mobility
mobile computing environments
wireless networks and
the same network
adapt to the
for applications to
the network qos
which support disconnected
provide seamless mobility
the dynamic operating
qos re negotiation
computer may have
the prayer mobile
for disconnected operation
negotiation and reaction
computing environment in
for seamless mobility
kept consistent with
when the portable
support disconnected operation
the home is
and reaction to
portable and the
change in qos
owned and operated
the portable is
provides seamless mobility
autonomously owned and
semantic record caching
inter network mobility
virtual point to
the portable the
prayer mobile computing
mobile computing model
to execute if
in order to
on top of
wireless networking technologies
home computer the
the different networks
and consistency policies
quality of service
dynamics of the
the challenges in
wireless networks a
of the wireless
to be provided
consistent with the
to be kept
mobility on top
e g switches
the home if
outdoor wireless networks
to point connection
and seamless mobility
indoor and outdoor
commercially available wireless
collaboratively adapt to
ideal scenario in
non interoperable wireless
on shared data
to qos changes
class is granted
backbone support for
indoor to outdoor
network level solution
procedure to execute
networks is typically
with multiple wireless
portable computer with
portable computer and
computing environment should
whole file is
network is unable
a virtual point
and application servers
of several viable
the portable in
application directed caching
of seamless mobility
of the prayer
and outdoor wireless
computer and the
dynamic qos re
inter network migration
to applications for
are three broad
and the exception
file systems which
seamless mobility is
support for applications
systems which support
logical ip address
available network qos
computing and seamless
of wireless network
choice of wireless
which provides seamless
to collaboratively adapt
disconnected operation on
to provide seamless
at the home
a network level
desired qos class
qos class is
the measured qos
networks and provides
for consistency management
heterogeneous wireless networks
typically accompanied with
of the portable
mobility over multiple
the home the
seamless mobility on
sequence of acceptable
for the portable
mobile user switches
computing environment is
in connected mode
qos negotiation and
application level adaptation
wide area wireless
the ideal scenario
the dynamics of
to adapt to
descending order of
if the network
file system clients
the backbone network
of file system
the connection manager
the dynamic qos
mobile service stations
the local copy
wireless networks the
a uniform framework
the base stations
the procedure to
distributed file systems
mobile computing the
cells of the
need to be
address for the
for a mobile
a wireless network
the network layer
order to provide
a change in
point to point
of mobile computing
ip address of

corpus/krapavin2000-test/609391.txt
ic
qam
qpsk
bpsk
modulation
cancellation
multistage
users
interference
fading
cdma
multicode
ber
rayleigh
noise
awgn
channel
channels
baseband
mf
mixed
signal
cancelled
mai
gaussian
ds
nddic
multicodes
multiuser
ary
variance
detector
zeroth
stage
pilot
imperfect
spreading
ranking
cancellations
signals
stages
multirate
symbol
receiver
symbols
detectors
analytical
gold
sequences
ae
signature
simulations
rec
ff
strongest
format
db
eqns
psfrag
icu
asynchronous
stationary
coherent
orthogonal
orth
amplitude
filter
matched
simulation
analysed
rate
flat
synchronous
five
branch
qq
cancelling
perfect
received
caused
decorrelating
dtt
canceller
nonselective
replacements
ser
decision
composite
decoded
transmitted
energy
employing
nels
oe
qi
127
subscript
th
gain
formats
rectangular
mobile
pulses
codes
power
rates
radio
correlation
theta
conditioned
transmission
amplitudes
detection
holtzman
sers
correlator
estimates
uncorrelated
transmits
degradation
spread
sin
outputs
schemes
optimistic
prospect
interfering
unconditional
analyse
division
average
estimated
variances
chan
agree
spectrum
successive
bit
gamma2
decoder
iq
shadowing
mix
station
preferable
calculate
patel
subtracted
synchronously
capacity
noticed
probability
partly
chip
conventional
frequency
quadrature
pdf
error
ave
near
successively
stringent
cancel
slowly
estimation
statistics
block
128
approximation
estimate
rewriting
optimum
bank
delta
thereafter
suboptimal
expression
expressions
multiples
counteract
antipodal
9303363
demodulation
koe
sic
despreading
quaternary
despread
verd
intersymbol
asyn
suboptimum
mmse
jamal
cellation
multiaccess
implicates
mistaking
decorrelator
mixed modulation
interference cancellation
16 qam
qam users
qpsk users
single stage
rayleigh fading
ds cdma
th user
multistage ic
stage ic
of ic
m ary
ary qam
the users
parallel channels
modulation systems
signature sequences
gaussian approximation
five stages
average ber
ic scheme
baseband signal
multicode system
ae i
users in
modulation format
noise caused
user bound
bpsk and
the bpsk
h th
cancellation of
e b
k l
the variance
stationary awgn
decision variable
the ic
a multicode
the multistage
modulation system
multiple access
simulation results
the noise
cdma systems
the mai
channel parameters
imperfect cancellation
single bpsk
pilot symbols
ic the
by imperfect
single rate
gaussian noise
users and
the interference
fading channels
and five
single user
ber for
matched filter
and qpsk
bpsk figure
flat rayleigh
i branch
bpsk users
mf rec
for bpsk
each user
the 16
i k
system with
i q
the h
multicode systems
ic and
multistage scheme
composite signal
symbol error
bpsk qpsk
all users
b n
the channel
users the
one two
users is
i h
a gaussian
the signal
near far
in mixed
the ber
random sequences
rate systems
user s
and simulation
performance of
the decision
with ic
ic is
spreading sequences
rate users
cdma system
strongest user
15 qpsk
mf receiver
qpsk and
successive interference
multistage interference
to noise
the performance
two and
ff k
oe k
analytical and
variance of
q k
the single
similar expression
awgn channels
0 values
decision variables
the i
the average
signal in
n i
signal to
n 0
a mixed
h i
k h
equal for
data rates
i theta
power control
noise term
channel gain
cancellation in
non decision
for multistage
an mf
multiuser detectors
decision directed
ratio ae
channels per
ic but
cancellation the
with multistage
zeroth symbol
perfect ranking
users have
noise ratio
caused by
stages of
two parallel
systems with
ber of
multiple data
i ae
user is
division multiple
cancellation for
code division
psfrag replacements
known channel
the zeroth
i where
error probability
k th
of symbol
the received
in rayleigh
simulation analysis
th stage
data rate
noise and
and 16
to ff
directed interference
orth gold
perfect power
rec simulation
in awgn
modulation formats
imperfect cancellations
orthogonal spreading
mai and
ber is
multicodes is
first user
analysis single
cancelling the
per bit
rec single
stage interference
received signal
average power
other users
i ii
16 qam users
m ary qam
the h th
mixed modulation systems
single stage ic
a gaussian approximation
b n 0
e b n
two and five
noise caused by
mixed modulation system
and five stages
five stages of
single user bound
the 16 qam
stages of ic
a multicode system
and simulation results
k th user
i k l
the single stage
caused by imperfect
h th user
the decision variable
simulation results for
performance of a
single bpsk figure
ds cdma systems
and qpsk users
flat rayleigh fading
a mixed modulation
bpsk and qpsk
the i branch
one two and
the average ber
and 16 qam
the single user
by imperfect cancellation
of a multicode
for m ary
th user s
n i q
in mixed modulation
the bpsk and
two parallel channels
analytical and simulation
rayleigh fading channels
signal to noise
variance of the
for the h
single rate systems
the other users
the multistage ic
gaussian approximation is
stationary awgn channels
qpsk users and
imperfect cancellation of
ae i ae
multistage interference cancellation
of the mai
the ic scheme
the gaussian noise
sum is the
15 qpsk users
successive interference cancellation
n 0 values
the performance of
users in the
the variance of
i h i
probability of error
for all users
of the users
of the h
respect to ff
of a mixed
a similar expression
the noise term
all the users
the channel gain
to noise ratio
equal for all
the i and
ds cdma system
probability of symbol
interference cancellation for
of symbol error
multicode system with
from the composite
ratio ae i
ber of the
modulation systems with
non decision directed
stage ic but
parallel channels per
an mf receiver
results for an
the e b
channels per user
the composite signal
noise ratio ae
theta n i
q k l
ae i h
the matched filter
interference cancellation the
interference cancellation in
cancellation of the
the k th
average ber for
code division multiple
the near far
division multiple access
gaussian noise and
the decision variables
ber for the
of the decision
gaussian noise the
i ae i
in rayleigh fading
the expected value
to the single
systems with ic
of ic and
users in rayleigh
multiple data rates
decision directed interference
analysis single bpsk
multistage ic scheme
system with 15
qpsk and 16
for one two
for an mf
to the zeroth
the noise caused
strongest user is
i theta n
simulation analysis single
for ds cdma
qam users is
rec simulation analysis
using order statistics
for multistage ic
for the bpsk
mf rec single
orthogonal spreading sequences
the first user
i q k
rec single bpsk
with 15 qpsk
bpsk qpsk and
the strongest user
mf rec simulation
decision variable for
the multistage scheme
energy per bit
after five stages
and two parallel
high rate users
i and q
the variance in
given by i
the signal to
at the i
the whole system
average probability of
i th stage
users and two
after cancellation of
the average probability
average ber of
for single stage
modulation system with
the first sum
for the 16
of the 16
performance of the
is given by
l i k
is analysed in
s i k
number of stages
in the system
of the received
for the single
of ic the
stage of ic
qpsk 15 users
mean square value
graph shows analytical
th user the
2 multistage interference
users for the
and q signature
stage interference cancellation
bpsk and 16
for random sequences
single rate system
multirate ds cdma
number of ic

corpus/krapavin2000-test/609397.txt
channel
cell
nccs
cochannel
channels
fca
borrowing
blocking
station
traffic
dca
cells
interference
hca
borrowable
sharing
cellular
cbwl
nominal
mobile
inner
radio
outer
pool
adjacent
neighbor
occupancy
borrowed
region
cir
locking
pools
assignment
borrow
distributor
load
pb
borrows
tier
terminal
wireless
stations
resources
terminals
directional
handoff
coverage
adapt
probability
density
swapping
schemes
base
receiver
probabilities
teletraffic
distributors
mobility
dynamics
register
equipped
db
occupied
lending
regions
loads
signal
lent
bandpass
capacity
link
frequency
reuse
arrival
users
intra
underflow
radius
congestion
fl
six
blocked
slope
conflict
band
fig
separation
service
telephone
carrier
retry
ff
spot
rejection
network
binomial
management
unused
calls
turned
guard
quality
hot
communications
overflow
omnidirection
richest
falloff
handover
04075r
splatter
eqivalent
weihua
chak
indoormultimedia
tiers
transceivers
satisfactory
utilization
busy
f0
filter
sg
controller
interleaving
5r
directionally
transmitters
subscribers
zhuang
itrc
3r
occupancies
transmitting
exclusive
caused
interferences
passband
bcc
antennas
handoffs
652
assigned
expense
spectrum
divided
distance
cdma
conventionally
excellence
birth
flowchart
scheme
initiated
signals
groups
connection
adaptive
death
modulated
rf
rearrangement
satisfactorily
shadowed
referred
achieves
loaded
hexagonal
eligible
heavily
resource
cleared
separations
sector
happens
situation
spacing
suppressed
ae
overcome
allocated
power
calculated
suppress
off
voice
disappears
282
margin
autonomously
telecommunication
deficiency
unchanged
measurable
selectivity
terrain
admission
light
offers
269
cell region
inner cell
blocking probability
the nccs
channel assignment
channel sharing
nccs scheme
the channel
base station
outer cell
adjacent channel
call blocking
channel interference
traffic load
channel borrowing
neighbor cells
nominal channels
cochannel interference
cell 1
a channel
of cell
cell 17
cochannel cells
sharing channels
sharing pool
the traffic
the blocking
channel occupancy
the cochannel
cell 2
traffic density
neighbor cell
channel resources
each cell
borrowable channels
channel locking
the sharing
the inner
link quality
the cbwl
cell 24
channel from
the cell
the adjacent
from cell
blocking probabilities
each base
the fca
borrowed channel
cell regions
the call
channels from
mobile terminal
channels of
and cell
cell and
the outer
no channel
with channel
the cir
lower call
cbwl scheme
dca schemes
cir value
nominal channel
sharing pools
channels and
channels in
the mobile
assignment schemes
same channel
dynamic channel
pb c
to traffic
cells in
channel is
the base
radio link
and adjacent
probability of
and borrowable
borrows a
cell network
fca scheme
borrowing conflict
sharing channel
traffic dynamics
the borrowed
channel swapping
channels assigned
wireless cellular
the borrowing
cell channel
first tier
other channel
adaptive channel
sharing nccs
mobile cellular
adjacent channels
in cell
sharing scheme
channels are
can adapt
its neighbor
as compared
station has
cellular network
mobile is
borrow the
and sharing
are occupied
cellular mobile
mobile terminals
adjacent cells
channels to
compared with
mobile communication
cellular networks
communication systems
a cell
base stations
available channels
both cochannel
channel separation
c channels
the borrowable
borrowed channels
channel available
2 channel
borrowing is
any channel
directional borrowing
24 borrows
n nominal
dca and
call connection
channel resource
desired channel
and hca
occupancy in
load distributor
intra cell
six cochannel
interference issue
than fca
cell the
the neighbor
the nominal
the cells
a call
interference and
cell i
new call
traffic loads
traffic adaptive
two cell
and outer
channel management
of nominal
cell is
of channel
for channel
density a
adapt to
probabilities of
radio channel
overall traffic
for cellular
24 from
cellular systems
call is
d b
of radio
channel can
a traffic
station and
assigned to
a mobile
a mean
and channel
terminal and
that cell
terminals in
a cellular
cells are
region the
scheme is
cell has
register is
of sharing
proposed scheme
the receiver
channel in
divided into
and nccs
exclusive use
proposed channel
adapt channel
reuse distance
bandpass filter
the nccs scheme
the inner cell
call blocking probability
adjacent channel interference
inner cell region
the outer cell
the call blocking
outer cell region
the adjacent channel
blocking probability of
the base station
each base station
of the nccs
in the inner
the traffic load
the channel occupancy
the channel sharing
the cochannel interference
the blocking probabilities
the traffic density
the blocking probability
as compared with
of the channel
a channel from
in the outer
of cell 17
channel from cell
pb c 1
nominal channels and
from cell 17
channel assignment schemes
radio link quality
the sharing pool
channel sharing scheme
lower call blocking
the cbwl scheme
a channel sharing
the channel resources
of cell 1
probability of the
the same channel
in the sharing
its neighbor cells
the first tier
the fca scheme
blocking probability for
channels from its
inner cell and
channel sharing pool
interference and adjacent
cochannel interference and
using the nccs
cochannel cells in
channels assigned to
the cir value
outer cell 1
cell region the
channel from the
cell channel sharing
channel sharing nccs
a lower call
borrows a channel
blocking probabilities of
the neighbor cell
adaptive channel assignment
the borrowed channel
neighbor cell channel
of the fca
borrow the same
base station has
and adjacent channel
mobile is in
mobile communication systems
the mobile is
from its neighbor
cells in the
compared with that
traffic adaptive channel
channel assignment and
of nominal channels
with channel sharing
the nominal channels
dca and hca
two cell network
that the nccs
for wireless cellular
1 and cell
the desired channel
cell region and
cell 2 channel
traffic density a
the borrowable channels
both cochannel interference
assignment schemes the
with channel borrowing
mobile terminal and
six cochannel cells
n nominal channels
channel occupancy in
to traffic dynamics
the sharing channels
nccs scheme is
the cochannel cells
the sharing pools
a channel borrowing
adapt to traffic
inner cell regions
and cell 2
cell and outer
wireless cellular networks
24 borrows a
sharing channels to
all the nominal
traffic load distributor
other channel assignment
cell 24 borrows
scheme can adapt
and outer cell
for the nccs
of sharing channels
2 channel occupancy
sharing nccs scheme
occupancy in the
dynamic channel assignment
same channel from
outer cell regions
probability of cell
channels and borrowable
and borrowable channels
cell 24 from
at the base
all the cells
channels in the
can adapt to
channels of the
cell 1 and
base station and
for each cell
of the cell
channels to be
is observed that
the overall traffic
each cell is
with a mean
a d b
is a random
in each cell
that the channel
it is observed
the q i
a base station
the performance improvement
d a d
order to overcome
compared with other
referred to as
assigned to a
two channels assigned
overcome the adjacent
channel sharing among
schemes can adapt
cell 1 for
cochannel interference issue
base station are
intra cell handoff
its six neighbor
desired channel and
the same numbers
channels of each
mobile terminals are
directional borrowing which
six neighbor cells
17 caused by
light traffic load
neighbor cells can
satisfactory link quality
channel assignment to
24 from cell
c 1 inner
inner cell mobile
the c channels
a nominal channel
q i value
situation due to
cell region then
fca scheme is
interference issue as
cell region of
channel borrowing will
a call connection
borrowed channel can
borrowed channel is
cell 17 caused
traffic load dynamics
and other channel
cell 17 is
of n nominal
larger channel sharing
nccs schemes in
17 is lent

corpus/krapavin2000-test/609461.txt
ber
qam
fading
channel
nakagami
nmf
cnr
adr
capacity
constellation
fl
spectral
rayleigh
channels
adaptive
acr
outage
rate
carrier
modulation
awgn
inversion
db
gamma3
delay
transmitter
adaptation
multipath
regions
target
wireless
efficiency
bpsk
transmission
received
bits
ora
psk
bandwidth
figs
hz
noise
receiver
power
demodulator
fade
gamma6
pdf
fb
symbol
mobile
nonadaptive
achievable
transmitted
exp
suffers
alouini
arq
truncated
link
ff
shannon
policies
cutoff
degradation
radio
average
fig
diminishes
1998
penalty
qm
gammafl
policy
feedback
coding
sec
adaption
cnrs
fluctuation
columbia
normalized
degardation
tifr
cifr
opra
dalei
slim
continuous
schemes
perfect
vancouver
omega
agc
modulator
inverts
marcum
british
nth
approx
transmit
bessel
tolerated
diversity
impact
gammam
indoor
communications
bit
plotted
closed
gamma2
dash
satisfactorily
pilot
thresholds
instantaneous
substituting
iv
rates
urban
budget
ratio
hr
discrete
band
bers
ae
quadrature
wu
proceeding
gaussian
km
reconfiguration
suffer
wired
mohamed
song
slowly
gain
estimation
flat
negligible
299
compensation
canada
operate
amplitude
complementary
march
solid
varying
ci
qos
expressions
conditioned
exact
responds
gamma
goldsmith
qingwen
geir
configurated
speidel
spectrally
mfl
vegard
sheikh
nyquist
belhaj
rician
sanqi
tives
tdd
hassel
nesrine
ien
1t
3013579achievable
gesbert
giannakis
946
chengzhi
pedestrians
switching
duration
estimator
confirmed
numerical
integral
sounding
mimo
configures
unattainable
fades
shengli
poisson
ms
probability
cross
m qam
spectral efficiency
target ber
average ber
adr m
nakagami fading
time delay
rate m
channel inversion
channel capacity
rate adaptation
constant power
constellation size
the channel
average received
ber of
fading channel
nmf channels
the ber
ber for
rayleigh fading
received cnr
variable rate
adaptive m
continuous rate
regions regions
a target
the capacity
unit bandwidth
link spectral
capacity per
capacity of
10 gamma3
carrier to
13 1998
and rate
power and
acr m
nmf channel
discrete rate
2 qam
g db
the nakagami
awgn channel
rate adaptive
fading channels
march 13
the constellation
received carrier
power variable
adaptive modulation
ber 0
per unit
noise ratio
optimal rate
fixed rate
gamma3 and
outage probability
ratio g
per symbol
normalized time
of adaptive
to noise
bits sec
optimal power
capacity optimal
ber average
fading m
in nakagami
qam fig
adaptive transmission
truncated channel
over nmf
average bit
of 10
perfect channel
the average
closed form
in rayleigh
adaptive 2
the transmitter
channel estimation
fading parameter
qam b
nakagami m
adaptive continuous
achievable spectral
shannon capacity
channel fading
of nmf
db average
adaptive discrete
bits per
an awgn
qam for
the cnr
the rayleigh
channels with
channel with
substituting 2
total channel
ber degradation
fl o
a nmf
over nakagami
of outage
qam over
b psk
transmit power
c ora
sec hz
for adr
qam schemes
feedback path
ber n
exact ber
m distribution
inversion with
qam scheme
rate and
non adaptive
assuming perfect
bit rate
of fading
qam is
ber in
10 gamma6
rate optimal
channel conditions
multipath fading
channel at
of bits
the shannon
communication system
mobile radio
obtain closed
diminishes as
in capacity
average link
fl and
and constant
efficiency of
modulation and
suffers a
m n
the receiver
m 4
the received
with channel
power continuous
ratio cnr
power constraint
ber requirement
nonadaptive bpsk
a ber
figs 14
qam exact
the nmf
bandwidth awgn
qam discrete
inversion total
of nonadaptive
exact average
delay f
constellation is
switching thresholds
for nmf
qam adr
qam non
approximation 28
fading regions
that rate
db capacity
cnr for
different adaptive
ber ber
regions capacity
rate transmission
approx adr
regions acr
the adr
adaptive policies
cnr at
capacity penalty
cnr fl
plotted by
cross layer
different adaption
qam comes
cnr and
efficiency regions
channel fade
fading decreases
power truncated
qam approx
adaption policies
rate regions
cnr db
1998 average
inversion fig
a target ber
adr m qam
rate m qam
for a target
power and rate
adaptive m qam
capacity per unit
march 13 1998
carrier to noise
per unit bandwidth
link spectral efficiency
target ber of
of 10 gamma3
the average ber
the capacity of
and rate adaptation
ber of 10
spectral efficiency of
acr m qam
received carrier to
average ber for
to noise ratio
power variable rate
variable rate m
the constellation size
10 gamma3 and
average received carrier
rate adaptive m
normalized time delay
optimal power and
bits per symbol
constant power variable
ratio g db
noise ratio g
the channel capacity
continuous rate m
average received cnr
target ber average
truncated channel inversion
over nmf channels
regions regions regions
ber average received
and constant power
adaptive 2 qam
rate and constant
optimal rate and
rayleigh fading channel
impact of time
of time delay
the average received
of bits per
non adaptive 2
in rayleigh fading
the shannon capacity
in nakagami fading
adaptive discrete rate
the target ber
the received cnr
of nmf channels
constellation size m
the nakagami fading
to time delay
capacity of nmf
nmf channel capacity
bounds the exact
achievable spectral efficiency
g db average
adaptive continuous rate
the ber of
average bit rate
capacity of an
the capacity per
average link spectral
time delay for
continuous rate adaptive
a nmf channel
fading channel with
ber for m
the exact ber
time delay on
optimal rate adaptation
m qam schemes
increase in capacity
obtain closed form
of an awgn
over nakagami fading
discrete rate adaptive
m qam scheme
total channel inversion
inversion with fixed
nakagami fading channel
the nakagami m
bits sec hz
probability of outage
with fixed rate
channel inversion with
of the rayleigh
of adaptive m
m qam is
assuming perfect channel
the spectral efficiency
for adr m
on the ber
m qam for
discrete rate m
nakagami fading m
number of bits
at the receiver
delay for a
channel estimation and
over the channel
an awgn channel
delay on the
the rayleigh fading
capacity of a
diminishes as the
size m n
performance of adaptive
small increase in
m n is
w bits sec
average ber degradation
qam adr m
channel at time
spectral efficiency for
db capacity per
figs 14 and
estimation and negligible
channel inversion fig
spectral efficiency regions
of the nakagami
adaptation is the
approx adr m
qam approx adr
ber degradation due
m qam over
m qam adr
the nmf channel
received cnr db
qam non adaptive
regions regions capacity
qam over nmf
qam discrete rate
are plotted by
the link spectral
rate adaptation and
plotted by the
and negligible time
cnr db capacity
capacity optimal rate
power truncated channel
the approximation 28
bandwidth awgn channel
channel capacity for
db average bit
regions regions acr
the nth region
constant power continuous
exact ber for
m qam comes
2 qam b
unit bandwidth for
time delay up
the channel fading
nakagami fading channels
channel inversion total
target ber 0
different adaption policies
channel capacity optimal
received cnr for
n a positive
b psk fig
m qam fig
2 qam fig
flat fading channel
inversion total channel
regions capacity optimal
channel capacity c
exact non adaptive
rate optimal rate
qam exact non
negligible time delay
nakagami fading parameter
nakagami m distribution
time delay f
regions acr m
of fading decreases
adaptive modulation and
13 1998 average
power continuous rate
capacity optimal power
of adaptive transmission
bit rate regions
qam b psk
m qam discrete
constant power truncated
of acr m
perfect channel estimation
delay up to
the adr m

corpus/krapavin2000-test/609902.txt
nasty
adversary
learning
noise
pac
sample
vc
2j
nsn
bad
malicious
ncn
binomial
delta
pr
learnable
ffi
errs
accuracy
1g
f0
dimension
learn
oracle
classification
hypothesis
concept
target
coin
probability
agnostic
misclassified
label
vcdim
nastyconsistent
nastylearn
chervonenkis
learns
vapnik
hypotheses
hoeffding
boolean
nb
noisy
ff
valiant
sub
intervals
flipped
ffl
36j
tosses
learnability
vote
confidence
gamma
rate
sauer
cesa
bianchi
composition
labeled
unmodified
theoretic
inequality
dnf
majority
incorrectly
labels
learned
consistency
sees
concepts
biased
unreliable
modify
tolerant
adversarial
complemented
drawn
margin
trivial
samples
suffer
advance
js
4g
modified
boundary
statistical
chooses
event
flip
random
unseen
ki
outputs
request
gets
2e
certainty
weight
gamma1
misleading
requested
polynomial
sufficiently
fcjx
scon
talagrand
cam
blaine
cpcn
jbad
neutralize
decatur
78k
nastiness
hjc
misclassifies
17j
prd
barreno
sears
commencing
weakly
corrupted
scenarios
knows
queries
variability
dual
incomplete
symmetric
remove
geometric
events
informative
argue
shattered
tygar
classes
asks
differences
showing
consistent
presence
reverses
taipei
unjustified
identically
fourier
resulted
implied
wrongly
reorders
maliciously
untouched
compression
query
distort
destructive
outputting
expectation
net
uniformly
wrong
happen
half
omega
distribution
settled
deviates
russell
subintervals
sharper
taiwan
error
proceeds
hg
boosting
nelson
randomly
decides
characterizing
bernoulli
choosing
randomized
strategy
combinatorial
cell
joseph
negations
exhausted
generalizes
criterion
constitute
anthony
blum
flips
learning algorithm
the adversary
the learning
distribution d
vc dimension
concept class
noise model
the sample
classification noise
nasty noise
the nasty
with accuracy
malicious noise
with probability
target function
class c
s g
sub sample
bad 2
nasty sample
rate j
learning with
sample s
binomial distribution
for learning
class h
probability at
bad 1
sample noise
nasty classification
pac learning
pac model
instance space
accuracy ffl
gamma 2
the target
c t
the pac
f0 1g
d gamma
a nasty
m examples
the ncn
sub intervals
with nasty
nasty adversary
random classification
1g x
learning in
the binomial
the malicious
the class
composition theorem
noise rate
learning from
of examples
adversary is
gamma ffi
concept classes
h f0
a concept
the nsn
pr bad
symmetric differences
probability j
noise of
1 gamma
over x
distributed according
a sample
with parameters
the vc
of vc
h 2
d over
sample for
c h
sample points
c with
distribution with
least 1
dimension d
points that
of rate
ffl 2j
trivial class
bad 3
noise learning
errs on
ffi 4
trivial concept
2j delta
d gamma1
consistency algorithm
any class
x 2
learning algorithms
j delta
an ff
the algorithm
points from
point x
this model
of points
c 1
from noisy
m points
positive result
agnostic learning
total error
parameters j
noise tolerant
that learns
original sample
non trivial
information theoretic
each example
x according
random variable
of noise
h j
the hypothesis
pac learnable
accuracy parameter
2 c
modified by
can learn
class with
noise is
target concept
function h
the probability
of learning
lower bound
sample complexity
vapnik chervonenkis
function c
complete sample
ff net
nsn model
is pac
biased coin
delta sample
of nasty
bad part
with malicious
result showing
than 2j
bad sub
misclassified by
2 bad
that bad
error rate
adversary chooses
class of
event that
probability distribution
w h
to learn
examples that
efficient learning
n in
a delta
at least
query learning
learnable from
7 f0
e points
smaller sub
statistical query
bad bad
parameters m
b nb
algorithm sees
confidence ffi
sub domain
noisy examples
according to
h to
x d
examples are
2 h
w a
sample of
space x
ffl and
the distribution
confidence parameter
learning any
nb n
a consistency
from x
of symmetric
polynomial in
g i
i s
the instance
a hypothesis
sample and
its choice
the learning algorithm
the target function
to the learning
d gamma 2
probability at least
with probability at
binomial distribution with
by the adversary
nasty sample noise
with accuracy ffl
the concept class
sample s g
the distribution d
the binomial distribution
distribution with parameters
number of examples
vc dimension d
learning in the
random classification noise
c with accuracy
the malicious noise
noise of rate
classification noise model
malicious noise model
f0 1g x
nasty classification noise
h j i
of rate j
concept class c
class c with
of the sample
1 gamma ffi
distribution d over
the vc dimension
by the learning
h f0 1g
class h f0
learning from noisy
composition theorem for
learning with nasty
x d gamma1
distribution d and
d over x
of vc dimension
theorem for learning
with probability j
distributed according to
the class c
least 1 gamma
the pac model
a concept class
learning algorithm the
modified by the
the instance space
probability distribution d
that the learning
at least 1
on the sample
h 2 h
in this model
the random classification
instance space x
from x according
trivial concept class
in the pac
s g of
gamma ffi 4
the nasty noise
pac learning with
for c h
parameters j and
of symmetric differences
the nasty classification
non trivial class
non trivial concept
algorithm that learns
point x 2
the point x
a function h
according to the
c t x
the original sample
s g is
to the binomial
g i s
the total error
with parameters j
x according to
presence of noise
the adversary is
that the algorithm
sample for the
vc dimension of
for learning algorithms
class of symmetric
a sample s
c t 2
presented in 8
from the sample
the class of
in the presence
the event that
a random variable
for learning in
t 2 c
the adversary chooses
that with probability
delta sample for
the h j
the complete sample
bad sub intervals
variable distributed by
an ff net
pac learnable from
the noise rate
smaller sub sample
the bad part
is pac learnable
the nsn model
pr bad 1
any distribution d
a nasty adversary
class with accuracy
points from x
better than 2j
gamma 2 8
concept class with
misclassified by the
with a nasty
x 7 f0
noise rate and
with malicious noise
consistency algorithm for
most d gamma
gamma 2 2
of m points
nb n in
concept class h
that pr bad
learning algorithm sees
target function the
thus with probability
a composition theorem
with nasty noise
call the nasty
a delta sample
target function c
nasty noise model
any non trivial
b nb n
a consistency algorithm
that the adversary
be the two
a non trivial
this model the
efficient learning algorithms
a majority vote
can learn the
and in 1
class c of
j i s
learning algorithm has
7 f0 1g
for learning with
function c t
h 2 c
sample points that
x c t
statistical query learning
the presence of
the sample size
the probability that
to the distribution
any class of
algorithm for c
by the binomial
parameters and in
choice of n
using a sample
random variable distributed
the number of
set of points
function h 2
is the target
number of sample
for the concept
distributed by the
is a random
shows that any
of examples that
of theorem 8
model the adversary
that the hypothesis
model called the
the g i
for the class
j and m
learning algorithm is
a class c
of sample points

corpus/krapavin2000-test/610812.txt
computable
solids
computability
rational
solid
prp
countable
dcpo
lebesgue
lub
disks
recursive
continuous
ftt
boolean
tolerances
dyadic
geometry
requicha
membership
theoretic
scott
predicate
pdvs
polyhedra
voxel
deltag
predicates
operators
interval
realistic
uncertain
ux
domains
compact
boundary
converging
modelling
fkjr
lebesgues
polyhedron
effectively
fxg
epsilon
robust
subsets
topology
rectangles
directed
cad
rigid
modeling
fractals
infimum
mathematical
proposition
regular
regularization
domain
tt
partial
hausdorff
truth
observable
unreliable
semi
enumerable
poset
euclidean
ff
maximal
disk
turing
uncertainties
boxes
complement
f0
robustness
neg
1g
inclusion
notions
union
ir
intersection
curved
calculi
functionals
polyhedral
xg
sequences
ae
interior
appendix
defining
tangent
manufacturing
spaces
effective
embedding
beware
lieutier
repr
fnjb
tehran
revis
edalat
esentation
pvds
compactification
bjy
physics
intervals
equipped
closed
equivalently
lambda
recursiveness
ershov
771
discriminated
ziegler
closure
open
image
segment
outline
classical
uncountable
finitary
ited
abbas
manufactured
827
enumeration
differential
element
ram
similarities
1o
thinks
dangling
cagd
idealization
rudimentary
coordinates
isomorphic
classically
banach
polynomials
surfaces
consistent
reverse
capture
theoretically
greatest
basis
stronger
metric
849
endow
behaviour
adjacent
geometric
sound
captured
shrinking
jb
hospitality
regularized
a2a
tangential
andr
classifications
methodology
notion
program
algorithmic
wrt
802
catastrophic
oo
cauchy
idealized
partially
requirement
horizontal
measuring
unsatisfactory
downward
mathematics
situations
topological
epsrc
sign
entail
unavoidable
endowed
digits
stands
solid domain
partial solids
of rational
of computability
a computable
domain theory
boolean operators
1 n
the solid
computable if
partial solid
solid modeling
domain theoretic
a domain
interval disks
semi computable
0 1
s 0
recursive analysis
r e
a a
a countable
rational numbers
an increasing
not computable
membership predicate
interval domain
lebesgue computable
rational polyhedra
effectively given
countable basis
a b
increasing sequence
is computable
regular sets
computability on
continuous domain
computable partial
boundary representation
real numbers
theoretic approach
of prp
solid a
ftt ff
an continuous
a dcpo
continuous membership
figure below
non computable
recursive partial
compact subsets
prp s
basis elements
maximal elements
are computable
a v
real number
computational geometry
subset a
the domain
1g 1
rational interval
rigid solids
domain is
is recursive
open set
ff g
gamma g
computable real
computable sequence
proposition 3
element a
robust algorithms
machine model
continuous domains
the boolean
b a
information than
set is
program to
a rational
f gamma
computable function
v b
computability over
rational polyhedron
dyadic voxel
computable computable
lebesgue measures
with requirement
robust interval
best continuous
upper space
directed subset
or uncertain
cad situations
every open
lub of
every directed
for solid
voxel set
reverse inclusion
sub rectangles
solids and
is effectively
of computable
a program
an element
r n
this predicate
computable non
scott open
operators over
scott topology
observable properties
least upper
of 0
of basis
recursive if
two partial
exact real
solid modelling
to computability
domain d
operators on
i 0
is r
b are
every element
consistent set
non regular
computability in
partial order
the lebesgue
real functions
of solid
ae r
notion of
are rational
set theoretic
truth table
of recursive
of output
a finite
f a
the interval
compute an
to recursive
elements of
all non
and b
mathematical model
domain can
least element
b 2
recursive function
mathematical theory
more information
a least
there exists
fkjr k
finite part
subset o
11 values
ram machine
s defining
real solids
infimum or
its regularization
computability but
correct algorithms
computable elements
unreliable programs
membership predicates
realistic as
domain introduced
basic scott
computable but
modeling operators
representation modelling
countable it
increasing chain
prp is
lub s
finite program
purpose computer
bound lub
is lebesgue
are dyadic
valid polyhedral
interval solid
empty compact
way below
real ram
computable however
into unreliable
their lebesgue
for computable
actual robust
effective limit
0 1 n
the solid domain
a a a
s 0 1
exists a program
program to compute
of a computable
sequence of rational
domain theoretic approach
notion of computability
an increasing sequence
the interval domain
element a b
a b a
an element a
a program to
is computable if
of rational numbers
of 0 1
2 s 0
b 2 s
is r e
a domain theoretic
b a b
of basis elements
the figure below
boolean operators on
compute an increasing
a countable basis
of prp s
partial solid a
1 n are
f gamma g
ftt ff g
a v b
that a and
computable sequence of
f0 1g 1
computable if it
is not computable
the boolean operators
a b 2
of all non
a domain is
a and b
a real number
see the appendix
and b are
two partial solids
of solid modeling
non regular sets
solid a b
an continuous domain
open set is
consistent with requirement
computable non computable
real number is
the upper space
boolean operators over
scott open set
rational interval disks
computable if the
the continuous membership
of rational interval
recursive partial solids
predicates and operations
every directed subset
computable partial solid
if the set
least upper bound
i 0 1
1 n is
if it is
1 n such
a computable function
the set theoretic
and domain theory
is recursive if
all non empty
ae r n
of algorithms in
maximal elements of
of boolean operators
computability on the
the set of
theoretic approach to
the truth table
domain is a
information than a
a least element
of an increasing
the least upper
of r n
set of output
of the solid
there exists a
more information than
domain can be
every element of
a b is
mathematical theory of
of s 0
a set is
1 n ae
recursive analysis and
of an effective
set theoretic aspects
computable partial solids
given for every
for actual robust
mathematical model for
theta d to
data 8 19
into unreliable programs
computable function is
observable properties of
dyadic voxel set
and a computable
continuous membership predicates
in domains see
r domain theory
2 i 0
best continuous approximation
is effectively given
lower semi computable
dcpo we say
the map x
by reverse inclusion
sequence of prp
lebesgue computable partial
for solid modeling
realistic as a
computability on subsets
a realistic machine
upper bound lub
a computable solid
effectively given continuous
analysis and domain
foundation of a
continuous approximation of
solid domain in
using tolerances to
by the collection
uncertainties of input
an increasing chain
actual robust algorithms
ordered by reverse
k l of
domain theory used
embedding onto the
membership predicate the
is countable it
of real solids
theory of computability
methodology for actual
directed subset a
solid modeling of
theory used in
to guarantee valid
capture the uncertainties
recursive analysis to
for every open
solid domain s
every open subset
the effective limit
regular sets and
that their lebesgue
partial or uncertain
represent regular sets
truth table for
when implemented turn
with local tolerances
basis elements which
computable functionals of
computable if and
a robust algorithm
semantics in data
numbers which is
fkjr k a
the best continuous
r is computable
is isomorphic with
framework for solid
two increasing sequences
real ram machine
basis of an
for every directed
model has to
correct algorithms when
towards robust interval
in actual cad
voxel set is
non empty compact
the boundary representation
a finite program
1g 1 is
interval domain i
continuous membership predicate
regular if it
general purpose computer

corpus/krapavin2000-test/610819.txt
im2
gray
digit
tape
tapes
computability
signed
sdr
stog
indeterministic
computable
embedding
pl
lled
heads
xs
stog0
cell
rst
character
innite
multihead
haskell
f0
1g
head
dyadic
expansion
denition
dene
machine
topological
conv
xor
nite
valued
alphabet
invert
sd
eternally
bra98
gtos
ds
moved
characters
code
undenedness
wei00
sequences
turing
conversion
innitely
realizes
blank
machines
outputs
bits
decimal
representations
injectivity
bit
im
topology
inverted
dened
indeterminism
bh00
she75
unlled
redundancy
tail
calculate
interval
induced
applicable
name
overwritten
symmetricity
cantor
2i
modied
tent
2x
names
subspace
composing
homeomorphic
fbg
injective
nh
golden
conversions
recursive
ll
proposition
output
cells
nondeterministic
binary
prex
shrinking
coming
skipping
arithmetic
rational
dierent
located
deterministic
fractions
usual
numbering
int
rules
integers
movements
losing
coding
realized
nondeterminism
rule
functional
kl1
addoneoftwo
coroutine
es98
bit6fig
prexes
hideki
izumi
tur36
asd90
hy84
bcro86
gia97
machiens
per89
dew93
wei85
mariko
ep97
bit3
vui90
hj92
gia96
knobel
tsu00
embbeding
111000
omnibus
gia99
distin
kamo
tsuiki
101111
explaind
smy92
guish
110000
yasugi
bottomed
uc90
hiroyasu
complement
shifting
dom
dier
repeats
converts
intervals
lazy
dening
eective
uncountably
naturality
takagi
richards
expan
grz57
itinerary
grzegorczyk
indenitely
acted
lose
putting
waits
continued
encoding
reads
101000
lling
followings
discus
ghc
zip
takeuchi
sicstus
multi
inputs
1000
paths
gray code
im2 machine
an im2
signed digit
digit representation
type 2
2 machine
output tape
the gray
as pl
the signed
multi valued
the computability
work tapes
real numbers
machine which
input output
im2 machines
the rst
code expansion
input tapes
next cell
indeterministic multihead
innite sequences
code embedding
multihead type
valued function
h 2
1g 1
input tape
a machine
sdr name
rst digit
real number
computability of
f0 1g
h 1
exact real
computability notion
usual binary
stog0 xs
pl a
an indeterministic
of stog0
computational paths
2 machines
unit open
topology on
2 o
the character
this embedding
is computable
binary expansion
embedding g
dyadic number
topological embedding
we dene
moved to
1 o
name of
an output
the heads
binary code
two heads
code computable
our machine
pl 0
a sdr
modied gray
valid results
applicable rule
remaining bits
of innite
open interval
from h
the machine
computable if
0 as
machine can
pl 1
a dyadic
nite time
output sequences
1g in
is lled
xs 0
im g
to invert
a topological
partial function
a multi
of real
embedding of
representation and
machine of
tape is
the head
is moved
of x
tape of
one head
of f0
invert the
output tapes
to calculate
real functions
lled with
number x
interval i
notion on
digit as
stog 0
which realizes
decimal point
code computability
tape as
second digit
im2 computable
whole real
blank character
i 2i
approximation information
calculate f
tape t
restricted signed
computability induced
is gray
tape has
a computable
machine we
innitely many
machine m
a type
the output
an innite
computes f
1 t
a nite
an input
a 1
innite sequence
heads of
code of
expansion of
after an
computation over
haskell program
rational interval
the blank
many names
one induced
of computability
rst bit
produce valid
code and
real line
we consider
0 0
cell is
o is
the unit
the input
induced by
2 reduction
on gray
language haskell
basic algorithms
to ll
computability and
on f0
not not
ll the
write the
cell and
the tail
o and
x to
x 7
bit 1
to gray
functional language
of i
a name
the usual
rule is
representation we
real function
computable function
when 0
function f
rst and
of figure
turing machine
sequences in
real arithmetic
interval with
topological properties
m and
is applicable
and consider
an im2 machine
signed digit representation
the gray code
type 2 machine
the signed digit
gray code expansion
multi valued function
a multi valued
h 2 o
is an im2
0 as pl
the output tape
the next cell
multihead type 2
im2 machine which
gray code embedding
a type 2
indeterministic multihead type
name of x
h 1 o
of an im2
the rst digit
gray code of
moved to the
f0 1g 1
the input tapes
type 2 machines
unit open interval
1 0 as
of innite sequences
digit representation and
as pl a
by the signed
of stog0 xs
the unit open
sdr name of
pl a 1
the usual binary
a topological embedding
is a topological
of figure 2
is moved to
the remaining bits
input output sequences
and type 2
a nite time
the computability of
output sequences in
gray code is
gray code and
1 as pl
gray code computable
a sdr name
when we know
computability of a
position of h
im2 machine of
stog0 xs 0
modied gray code
an indeterministic multihead
as pl 1
representation and type
a dyadic number
open interval i
code expansion of
an input tape
to the next
and h 2
to invert the
with the rst
a 1 0
equivalent to the
an innite sequence
o and h
input output tapes
produce valid results
output tape is
gray code computability
the whole real
machine of type
2 reduction of
usual binary code
o is moved
t is moved
functional language haskell
the restricted signed
on gray code
restricted signed digit
the second digit
stog 0 0
innite sequences of
s i 2i
computability induced by
based on gray
f x from
set of innite
function to calculate
1 2 reduction
is gray code
whole real line
the modied gray
to the computability
a name of
input output tape
multi valued functions
as pl 0
innitely many names
output is made
to calculate f
the computational paths
the computability induced
topology on f0
2 machine which
one induced by
after an output
embedding of i
reduction of figure
calculate f x
tape is lled
the one induced
a partial function
of a real
function f i
1 t is
of real numbers
section 7 and
1 o and
notion of computability
a machine which
computability of real
interval with the
f i k
h 2 t
real number x
thus we dene
h 1 i
to gray code
the binary expansion
output tape of
the rst bit
is computable if
to the signed
h n 1
exact real arithmetic
computable function f
1g in this
of the gray
to ll the
half of figure
a real number
the rst and
of the unit
induced by the
the interval with
that the machine
rule is applicable
x 2 i
form a 1
rst and the
2 the remaining
the real numbers
an input output
of real functions
a real function
n 1 t
a 1 as
k i is
is realized by
to the binary
a function to
to the position
consider that the
from i to
7 and 8
we dene the
on the interval
y i is
i k i
with the second
in section 7
to the whole
next cell and
computability notion on
the alphabet fbg
an expression starting
a l 6
invert the output
expansion of real
good approximation information
computability and domain
may be overwritten
a gray code
applying conv to
kernel language for
machine we consider
2 o is
2 machine is
second cell respectively
consider the inverse
embedding g is

corpus/krapavin2000-test/611399.txt
multipattern
text
automaton
superimposed
string
automata
character
verifications
matching
characters
nfa
patterns
pieces
partitioning
piece
verification
pattern
errors
searching
oe
filter
manber
approximate
matches
word
subpatterns
bit
match
window
ff
muth
subautomata
parallelism
hierarchical
ffoe
gammam
bits
english
plain
search
filtering
sunday
p22
searches
counting
verif
boyer
superimposing
matched
bk
superimpose
rts
shift
arrows
mn
sublinear
moore
diagonals
usefulness
occurrence
patt
gonzalo
jc
counters
searched
exact
ma
plots
substring
rn
mask
superimposition
aloha
filters
experimentally
moderate
truncate
letters
subtract
fastest
diagonal
navarro
dm
classical
count
kuri
josu
pait
cleverly
mcount
active
gammak
optimality
areas
fredriksson
kimmo
ludovic
informaticae
fundamenta
grows
occurrences
verified
masks
kmp
tour
trie
rm
advance
overflow
packing
mismatch
partition
log
asymptotically
bitwise
shifts
intrusion
deterministic
error
alphabet
nondeterministic
separator
decrement
sequential
sequentially
concatenation
bm
horizontal
ffl
halves
position
inspect
grouping
formula
retrieval
verify
faster
limit
fit
worst
grow
speedup
counter
pay
pack
mr
split
megabytes
simulation
bold
gram
deletions
dictionary
pessimistic
keyword
complexities
degrades
inside
kdm
area000000000111111111111111111000111111
superimposes
yevrus
superimp
apartitioning
aaabbbcccddd
aaabbb
retraverse
tiberio
udi
federica
2424
aho
unrelevant
atsuhiro
aaaaaaaa
progamming
1990627
takasu
martoglia
techiques
corasick
surger
lengthly
mandreoli
smarter
ddd
cccddd
rmn
jea
cells
virginia
adapt
verifying
italic
row
triggered
guided
grams
tolerate
parallelization
string matching
approximate string
exact partitioning
computer word
hierarchical verification
single pattern
superimposed automata
the text
the pattern
multipattern search
r patterns
error level
log oe
bit parallelism
text window
of patterns
pattern partitioning
bit parallel
to search
the automaton
english text
shift or
text position
of verifications
text searching
the superimposed
exact searching
for approximate
verification is
a text
many patterns
text character
partitioning is
one error
machine word
muth manber
into exact
automaton partitioning
error levels
hierarchical piece
characters of
a match
which piece
plots show
pattern in
the pieces
exact search
the patterns
is o
the nfa
gammam 1
multiple approximate
search r
ffoe 1
plain verification
jc errors
piece matched
bk jc
k errors
piece verification
j gammam
a multipattern
complete pattern
multiple patterns
the multipattern
new text
dynamic programming
patterns we
r 0
approximate pattern
on english
increasing r
matching a
a character
r oe
oe m
significant bit
partitioning into
t j
patterns is
filter is
for increasing
search is
a computer
the search
we search
1 ff
the bits
short patterns
superimposed automaton
allowing errors
approximate searching
computer words
matching probability
pattern algorithm
candidate area
character t
zero errors
superimposing automata
matching algorithms
filtering algorithms
boyer moore
length m
search for
the filter
on average
a filter
algorithm is
of length
optimality and
pattern length
k characters
pattern matches
search each
complete match
match of
each pattern
increasing k
the computer
o m
log m
most significant
o mn
text we
arrows represent
ff r
single search
of pattern
searching a
we partition
patterns have
filter based
our algorithms
errors and
a pattern
search algorithms
characters in
bit of
of approximate
pattern and
text depending
sub patterns
with bk
truncate them
active states
search superimposed
subtract 1
ffl transitions
the sunday
efficient string
per character
of subautomata
matching fast
automaton for
diagonal arrows
text areas
mn w
they advance
areas that
new character
oe log
matching approximate
for multipattern
multipattern exact
in superimposed
pieces to
k pieces
o 1
of characters
word we
pattern matching
the automata
the r
patterns in
a table
the algorithm
each one
the cost
search time
100 on
pattern at
it searches
classical algorithm
patterns each
longer patterns
bit mask
and usefulness
only previous
character c
gonzalo navarro
the error
of errors
algorithms for
occurrence of
is better
the bit
is optimal
the single
patterns to
for r
approximate string matching
number of patterns
the computer word
the single pattern
a computer word
the error level
in the text
log oe m
a single pattern
hierarchical verification is
number of verifications
the text window
for approximate string
algorithm for approximate
new text character
t j gammam
which piece matched
j gammam 1
multipattern search algorithms
bk jc errors
ffoe 1 ff
multiple approximate string
of the nfa
hierarchical piece verification
partitioning into exact
search r patterns
exact partitioning is
on english text
string matching algorithms
in a computer
the pattern in
most significant bit
approximate pattern matching
of length m
in the pattern
ff r oe
a text position
the candidate area
into exact search
the multipattern search
the complete pattern
significant bit of
character t j
pattern in k
r patterns in
single pattern algorithm
to search r
number of errors
filter based on
a single search
of approximate string
fit in a
a complete match
string matching a
characters of p
in a text
in a single
of the pattern
all the r
of the text
as we show
the new character
they advance in
computer word we
string matching approximate
for increasing k
100 on english
optimality and usefulness
bit parallel simulation
error level is
the matching probability
english text depending
for approximate pattern
the simple one
over the text
shift or algorithm
50 100 on
the r patterns
bit parallelism to
oe log oe
where each algorithm
use bit parallelism
for increasing r
partitioning is the
partitioning is better
m gamma k
the text areas
with bk jc
string matching with
o mn w
characters of the
bit parallel algorithms
cost of verifications
know which piece
efficient string matching
in superimposed automata
algorithms for multipattern
1 log oe
and search each
string matching fast
theta log oe
truncate them to
a filter based
error level ff
r patterns we
t or i
on exact searching
based on exact
text depending on
increasing r and
than k characters
with zero errors
classes of characters
determine which piece
the shift or
advance in the
patterns to search
log oe log
areas where each
pattern partitioning is
the bit parallel
the most significant
algorithm is optimal
of the automaton
to search for
the algorithm is
the bits of
the pattern length
is the fastest
we check the
for a pattern
with one error
of patterns is
to text searching
are of length
have to search
the areas where
the only previous
to the shortest
parallel simulation of
a text window
dynamic programming and
of the patterns
text we use
a classical algorithm
we have to
the point where
the probability of
belonging to p
each algorithm is
it is faster
the number of
we partition the
the filter is
as belonging to
we know which
is better in
the pattern and
with at most
less than 50
match of the
is not useful
t j 1
algorithm is o
number of bits
we show in
t i j
more than k
on the pattern
based on dynamic
to determine which
are interested in
we are interested
the search is
case of multiple
an occurrence of
of the computer
the p i
the superimposed automaton
each pattern in
partitioning we have
same text we
for multiple patterns
it is normally
automaton accepts a
automaton for each
josu kuri gonzalo
based on counting
most k errors
of pattern pieces
log oe rm
lower case english
of two then
that the subpatterns
single pattern version
and empirical comparisons
bit of b
gram locations in
pattern p 1
locations in approximate

corpus/krapavin2000-test/611411.txt
url
disk
proxy
foxy
file
proxies
squid
urls
web
requests
buddy
stream
packetizer
locality
lazy
webcosm
cache
buffers
server
read
kbytes
reads
request
movements
head
throughput
latency
caching
delete
utilization
storage
files
loc
polygraph
client
conscious
plots
internet
lru
clients
management
unix
documents
overhead
serve
solaris
contiguously
contiguous
hit
hbench
unnoticeable
directory
tcp
secondary
meta
gbyte
servers
simulator
caches
crash
traffic
trace
fragmentation
buffer
mbytes
requested
a3
improves
load
completion
magnetic
traces
directories
128
000
accesses
serving
contents
soloviev
taztool
dirs
bottlenecked
ufs
creation
deletion
requesting
noticeable
contrary
store
bandwidth
prefetching
operating
miss
http
structured
traditional
interleaved
news
page
writes
slot
response
policies
object
layout
hits
blocks
busy
threshold
disks
sustain
slots
matters
replacement
write
connection
interleaving
340
ffl
snapshot
512
fed
white
pong
clustering
dots
os
minutes
milliseconds
surges
rousskov
inktomi
maltzahn
lmbench
058
bake
cacheflow
metadata
storing
writing
workloads
nearby
stores
subsystem
serviced
fills
stored
improvements
benchmarking
seek
00
sent
origin
benchmark
zebra
serverless
watermark
mogul
evicted
custom
plotting
driven
ftp
policy
accessed
rotational
bottleneck
fsm
filesystem
seagate
millisecond
deletes
scattered
articles
arrive
grouping
firewall
cao
ping
percentage
workload
ultra
mismatch
configured
cached
plotted
block
wake
mbyte
locations
outperforms
network
achieves
suggest
improvement
html
striped
gbytes
advocate
dns
lazy reads
the disk
locality buffers
web proxies
web proxy
the proxy
read requests
file system
stream packetizer
read operations
per second
url read
file systems
url write
disk head
requests per
log structured
the file
head movements
url get
disk utilization
each url
structured file
proxy server
write operations
storage management
web server
of buddy
input load
the url
figure plots
to serve
url requests
reads loc
per file
and stream
plots the
squid and
conscious storage
proxy s
web conscious
url delete
meta data
disk i
i o
of disk
of web
disk space
all urls
urls that
of locality
free space
secondary storage
of squid
file creation
of url
disk cache
get operations
and foxy
file space
completion time
main memory
of stream
a file
000 url
get requests
locality buffer
write requests
unix like
disk read
one url
file management
o overhead
buffers the
performance of
the web
throughput of
stream of
operations per
level cache
of lazy
a web
busy web
write throughput
caching proxies
web polygraph
traditional proxies
proxies are
space management
the foxy
url per
a url
for web
of read
the locality
file i
second level
requests are
the figure
the performance
cache simulator
proxies and
new url
and delete
of file
on top
single file
web objects
operating system
read operation
performance improvements
end user
stored in
the completion
file and
url request
proxy performance
hbench os
for serving
make matters
url operations
serve around
webcosm techniques
appropriate file
origin web
gbyte disk
128 kbytes
http request
our webcosm
50 requests
buddy improves
mbytes per
disk locations
solaris 5
management overhead
like file
in url
serving 1
matters worse
traditional web
delete requests
buddy is
data overhead
proxy that
urls in
of urls
delete operations
operations will
a proxy
network file
read request
the contrary
user level
top of
improves performance
creation deletion
level web
00 00
separate file
reduce disk
trace driven
web documents
disk to
the internet
performance by
wide web
stream and
of write
the object
world wide
experimental evaluation
server and
head position
url from
requests second
system crash
the urls
in web
store all
a disk
requests that
significant performance
create and
local copy
memory cache
urls are
are fed
the http
disk seek
network bandwidth
sent to
file to
the stream
data to
disk in
single disk
disk block
the requested
level disk
340 requests
requests per second
log structured file
the file system
structured file systems
the figure plots
to the disk
figure plots the
lazy reads loc
of locality buffers
disk i o
the proxy s
web conscious storage
a web proxy
disk head movements
conscious storage management
of the disk
to the file
url get operations
the proxy server
get operations per
locality buffers the
operations per second
the completion time
of web proxies
function of disk
squid and foxy
for web proxies
url get requests
performance of stream
of lazy reads
plots the completion
of the url
on the disk
i o overhead
the performance of
the disk utilization
file i o
the disk head
url write operations
performance of buddy
one url per
url per file
url read operations
the disk i
on top of
as a function
create and delete
able to serve
a single file
a function of
on the contrary
of disk space
50 requests per
file to store
second level cache
serving 1 000
file creation deletion
stores all urls
url operations as
a file space
for serving 1
unix like file
web proxies and
mbytes per second
improves performance by
of squid and
meta data overhead
absence of locality
source of overhead
and stream packetizer
the input load
to serve around
for each url
000 000 url
to make matters
origin web server
get requests per
make matters worse
lazy reads and
a log structured
time for serving
read operations will
file management overhead
in web proxies
the appropriate file
000 url operations
traditional web proxies
file space management
all urls in
stored in the
when the disk
world wide web
the end user
a separate file
of read operations
operations as a
of disk utilization
fed into a
url from the
simulation and experimental
urls in a
a system crash
main memory cache
secondary storage management
are fed into
the secondary storage
the disk in
of write operations
of read requests
web server and
that the disk
completion time for
a factor of
data to the
a single disk
and experimental evaluation
1 000 000
each url in
the web proxy
performance of read
the url stream
long head movements
previous read request
urls per file
in significant performance
500 url get
of caching proxies
busy web proxy
disk utilization lazy
taken with taztool
input load requests
like file systems
performance by an
space tends to
stream of write
bottlenecked by their
study the overheads
webcosm a set
throughput of squid
file system operations
like log structured
340 requests per
the appropriate web
url read requests
nearby disk locations
the http request
url delete requests
read requests are
urls larger than
http request is
all urls that
lazy reads figure
url write request
utilization lazy reads
ping pong effect
stream and stream
largest source of
our webcosm techniques
our experimental environment
7 mbytes per
load requests second
sequential write operations
a busy web
o overhead of
the requested object
file creation and
of url requests
url read url
file of their
of buddy is
delete a file
that lazy reads
free space as
tcp ip connection
performance of lazy
storage management techniques
stream packetizer by
each url request
reduce this overhead
of a log
store all urls
much like log
disk is plotted
web proxies are
the url from
the object s
than a factor
to store all
are stored in
by more than
from the disk
average size of
set of techniques
disk in a
disk utilization is
a local copy
to the proxy
disk space utilization
of each url
structured file system

corpus/krapavin2000-test/611413.txt
delay
link
probes
multicast
estimator
inferred
delays
links
packet
estimated
cumulative
measurements
sample
bin
ff
ms
bfl
traffic
inference
probe
variance
distributions
deviation
simulations
correlation
tcp
1ms
receivers
internet
udp
leaf
measurement
topology
packets
correlations
accuracy
convergence
complement
mtrace
median
tomography
foreach
unicast
absolute
tree
confidence
congestion
vs
infer
dynamics
plot
cooperation
k2r
rms
std
interior
dependence
network
receiver
differentiable
largest
fl
spatial
density
duffield
bff
binned
pathchar
10000
estimates
independence
4000
estimate
10ms
5mb
queueing
loss
child
asymptotically
asymptotic
converges
8000
6000
intervals
lag
node
simulation
queuing
branching
1mb
inaccuracies
solvefor2
031e
solvefor1
k2v
presti
apportion
ipma
calibrating
topologies
utilization
francesco
parent
continuously
f0
050
vertical
lost
logical
phenomenology
discretize
timescale
probabilities
agreement
surely
experienced
root
50ms
diagnosing
monitoring
violations
assessing
1e
depth
internal
1g
hop
mea
ttl
descend
ton
accrued
towsley
persistent
comprising
comprises
background
paths
grows
felix
interarrival
gamma
seconds
bandwidth
hosts
verified
capacity
suited
bottleneck
children
postpone
proportionally
shed
presence
characteristics
normalized
rate
laplace
transit
routing
load
ns
representative
250
losses
experience
source
spread
networking
parametric
fi
traversing
dictated
bins
diagnosis
100
interval
averages
variances
lo
150
discrete
convolution
measured
sec
ip
canonical
disabled
adopted
versus
empirical
injective
covariance
experiment
networks
predicted
estimators
vacirca
0752
1053
estimated link
to end
end to
the estimator
link 1
the inferred
ff k
multicast tree
delay ms
of probes
delay distribution
delay c
average delay
delay distributions
d f
vs sample
f sample
link 6
ms estimated
estimated vs
cumulative density
function delay
sample node
the delay
link delay
link 11
sample link
per link
largest absolute
cumulative delay
bin size
b ff
sample complement
end measurements
a k
absolute deviation
link 3
logical multicast
c d
end delay
multicast based
each link
100 simulations
inferred distributions
model link
link delays
distribution estimator
spatial correlation
probes link
the cumulative
node k
delay and
all links
density function
the bin
of multicast
k i
multicast traffic
estimator variance
bin sizes
inferred and
inference of
and sample
complement of
f k
network elements
computed over
1 estimated
y k
accuracy of
a multicast
and loss
plot the
of end
packet delay
model simulation
branching ratio
based inference
sample average
leaf delays
tcp udp
network internal
the tree
deviation between
the estimates
and link
k 0
the link
sample c
link by
average delays
the estimated
the accuracy
b figure
we plot
source to
for link
probes the
links as
the variance
ms n
absolute vertical
link 8
minimum median
6 estimated
simulation topology
vertical deviation
n probes
link 9
sample distributions
actual distributions
simulations computed
inferred values
estimated distribution
11 estimated
median minimum
internal delay
maximum largest
0 1ms
continuously differentiable
by link
of network
of packet
confidence interval
to leaf
over 100
size q
confidence intervals
the logical
n of
gamma a
of convergence
of links
link k
delay measurements
estimator in
maximum median
no delay
2 std
as function
distributions we
to ff
background traffic
strongly consistent
to infer
presence of
measurements of
in f0
of delay
tree depth
of receivers
verified the
two leaf
statistical properties
estimator is
the estimate
convergence of
the internet
a f
estimated and
6000 8000
8000 10000
fi k
4000 6000
minimum delay
packets are
measured end
common link
multicast probes
from measured
our delay
fixed delays
internal approach
8 estimated
from end
interior links
delay model
std a
estimator through
udp simulations
loss estimator
largest deviation
rms normalized
link 5
asymptotically normal
different bin
tomography from
normalized error
the presence
2000 4000
the multicast
a probe
the model
simulations we
median and
link for
the root
delays are
of measurement
1 sample
end to end
c d f
delay c d
of the estimator
the cumulative density
vs sample node
ms estimated vs
n of probes
d f sample
function delay ms
density function delay
cumulative density function
estimated vs sample
delay ms estimated
sample complement of
f sample complement
to end measurements
of the cumulative
to end delay
b ff k
complement of the
logical multicast tree
largest absolute deviation
of probes link
the inferred distributions
the delay distribution
delay distribution estimator
probes link 1
a f k
delay and loss
of the inferred
number of probes
of end to
cumulative delay c
link 1 estimated
b a k
1 estimated link
source to leaf
over all links
estimated link 1
a k i
accuracy of the
we plot the
of the delay
absolute deviation between
k 0 a
sample c d
inferred and sample
the logical multicast
ff k 1
the inferred and
per link delays
bin size q
based inference of
link by link
values in f0
of the estimates
the bin size
in the internet
the estimated distribution
100 simulations computed
all links as
link 6 estimated
the actual distributions
the estimator variance
inference of network
over 100 simulations
and sample c
the estimator is
ff k i
ff k 0
from the measured
of network internal
link 1 sample
to leaf delays
6 estimated link
estimated link 11
average delay ms
11 estimated link
multicast based inference
estimated link 6
1 sample link
simulations computed over
link 11 estimated
ms n of
maximum median minimum
minimum median and
of spatial correlation
1 2 std
absolute vertical deviation
largest absolute vertical
and link by
as function of
topology of figure
the largest absolute
delay distributions and
the presence of
rate of convergence
a to g
a k 0
convergence of the
computed over all
statistical properties of
of convergence of
6000 8000 10000
2000 4000 6000
4000 6000 8000
the rate of
of the estimated
multicast tree in
the cooperation of
of per link
2 std a
sample average delay
of multicast traffic
presence of temporal
multicast traffic is
y k l
estimated and sample
a k j
5 average delay
the sample average
the maximum largest
for all links
deviation in 100
by link for
0 1ms the
k 2 v
between the inferred
the inferred values
each link delay
gamma a 1
y k m
presence of spatial
rms normalized error
the internal approach
measured end to
k 1 b
the loss estimator
the per link
delay ms n
that the estimator
links as function
computed over 100
link 1 link
cumulative delay distributions
of b ff
the multicast tree
cooperation of network
tcp udp simulations
different bin sizes
maximum largest absolute
a and link
absolute deviation in
in 100 simulations
a 0 050
a logical multicast
from end to
network internal delay
to infer the
a 2 1
takes values in
packet delay and
at node k
we evaluated our
d f s
of network elements
the statistical properties
0 050 150
using end to
presence of significant
deviation between the
to end delays
a 1 1
the source to
for k 2
and fi k
median and the
the discrete distribution
for the bin
the independence assumption
0 51 52
f k 0
0 a and
k 2 u
f k and
the two leaf
to end internet
of paths between
function of n
the same link
the minimum delay
n a and
050 150 250
the inference algorithm
on each link
taking values in
from a to
a 1 n
of n a

corpus/krapavin2000-test/611430.txt
image
skeletons
iatg
skeleton
dcg
parallelism
operators
char
images
void
unsigned
stereo
im_op
baseline
triadic
processors
monadic
dyadic
neighborhood
name1
name2
pixels
imagepointdist
taskb
1io
taska
master
pixel
task
ups
host
lters
disparity
vision
mpi
tasks
int
imaging
compositing
destination
operator
lter
algorithmic
convolution
redistribution
proling
imagewindowdist
name3
processor
dierent
window
cameras
mdg
dierence
mixed
scheduling
shifted
precedence
1o
ltering
squared
alpha
nonlinear
name4
snopt
plaza
imagepointdist_3i_1o
parallelized
headers
communication
fortran
m1
kernel
pure
sobel
tted
cpr
ecient
restoration
ref
subtract
horizontally
preemptively
panda
64mb
myrinet
rst
costs
exploiting
subtraction
200mhz
stripe
blend
executing
surrounding
exec
alu
ow
library
dene
processed
predicted
das
allocated
pcs
laplace
classication
2i
m2
edges
fig
speed
node
dicult
multicomputers
sequential
create
1024
lm
linux
coding
win
eort
speedups
num
acyclic
balanced
versus
pictures
paradigm
arithmetic
aldist
imagepointdist_2i_2o
imageglobaldist
imagepointdist_1io_c
master0processed
blood
proled
pararameter
serot
disscus
seinstra
processors81624324048
approac
imagepointdist_2i_1o
err2
ideea
imageglobaldist_1io
valencia
ral
imagewindowdist_1io
diff0
err1
imageglob
tsas
erators
koelma
imagewindowdist_1i_1o
bagdanov
crispening
diff1
image13171933
moddeling
mnkl
tabulate
err0
imagepointdist_1i_1o
asci
diff15
diff2
imagepointdist_1io
attened
imagepointdist_1io_1i
name
moved
rendered
macro
eld
source
pentium
pipelined
critical
multiply
blurring
orca
ampl
assembles
angiography
hyperspectral
okutomi
webb
formula
stands
achievable
512
emerged
nodes
rendering
corner
reference
image processing
task parallel
data parallelism
data parallel
baseline stereo
point operators
and task
task parallelism
dcg skeleton
the iatg
multi baseline
the image
skeleton for
n char
global operators
processing operators
unsigned int
stereo vision
task and
level image
int n
image operators
parallel approach
neighborhood operators
parallel framework
void im_op
algorithmic skeletons
parallel image
application task
vision application
im_op dcg
output void
using skeletons
task graph
skeletons are
mixed task
low level
image application
name1 char
char name1
char name2
processing application
output image
d x
of processors
an image
the multi
skeletons and
one input
data and
speed ups
constant d
skeletons for
processors executing
the task
source image
for neighborhood
destination image
and data
input images
operators one
communication time
both data
parallel programming
in image
each skeleton
for monadic
image and
processed area
char name
image operator
master 0
pure task
dyadic point
host processor
source images
the skeletons
processing user
destination pixel
distributed memory
for point
a destination
image is
operators we
the data
the images
parallelism is
input image
reference image
area at
processing environment
input output
the skeleton
the host
image s
images and
operators are
images for
a task
char name3
nonlinear lters
image master
function operation
graph iatg
name2 char
monadic image
processing operator
average area
monadic point
point neighborhood
d pixels
both task
skeletons is
compositing is
image operations
fortran m
neighborhood operator
processor tasks
computer imaging
disparity image
match images
operations function
tasks image
name void
either pure
ups obtained
squared dierence
critical path
data d
for dierent
shifted by
of skeletons
task number
two source
dierent image
new output
host processors
application described
one output
the speed
execution time
distribution scheme
processors allocated
communication costs
each task
the application
arithmetic and
of low
convolution kernel
image d
entire image
parallel environment
neighborhood and
framework based
parallelism can
create a
parallelism on
parallel tasks
we assigned
point communication
two dimensional
pixels of
processing applications
skeleton is
task i
for global
image the
the window
sequential code
well balanced
image from
the graph
processing the
as parameters
image point
allocated to
we dene
parallel code
kernel is
the source
of images
monadic operations
on skeletons
operator applied
task taska
master master
parallelism 7
processing library
win void
triadic point
taskb processors
operations monadic
macro data
operators takes
name2 void
imagepointdist 1io
node approach
char name4
adding data
non preemptively
data and task
task and data
baseline stereo vision
multi baseline stereo
dcg skeleton for
and data parallelism
and task parallel
low level image
the multi baseline
int n char
the data parallel
image processing operators
unsigned int n
and task parallelism
level image processing
application task graph
stereo vision application
parallel image processing
the task parallel
constant d x
mixed task and
im_op dcg skeleton
an image processing
void im_op dcg
image processing application
name1 char name2
char name1 char
the image application
task parallel framework
n char name1
image application task
the image processing
operators one input
both data and
in image processing
and data parallel
data parallel approach
skeleton for monadic
one input output
the speed ups
for the data
in the iatg
image processing user
a destination image
image processing environment
task parallel approach
processed area at
for neighborhood operators
for point operators
dyadic point operators
one output void
for global operators
the image operator
n char name
number of processors
of the image
of low level
the input image
and one output
the critical path
image and a
the data and
pure task parallelism
task parallel environment
only data parallelism
two source images
image processing operator
both task and
a new output
level image operators
for monadic point
the average area
speed ups obtained
name void im_op
task graph iatg
operations function operation
task parallelism can
skeleton for neighborhood
as parameters the
new output image
the task number
h k l
input output void
char name2 char
a data parallel
parallel framework based
name2 char name3
application described in
and global operators
operators we assigned
char name void
the source image
monadic point operators
neighborhood and global
the squared dierence
point operators one
images for each
and the image
set of processors
f m n
reference image and
distributed memory system
the image s
input images and
we assigned the
data parallelism is
framework based on
image processing applications
processors allocated to
image processing the
and communication costs
data parallel programming
the entire image
of the task
to point communication
of the graph
parallelism in a
of the multi
in the multi
on a distributed
to use for
of the images
window win void
suitable for this
with dimension order
point operators takes
parallelism 7 8
non preemptively on
exploiting mixed task
that exploiting both
compared to either
a regular well
t exec i
monadic dyadic point
skeleton for global
a 3d mesh
pro 200mhz pcs
neighborhood operator original
7 8 the
processors executing task
image an example
a data and
exploiting task and
char name3 char
top left corner
node 1 node
are algorithmic abstractions
a destination pixel
d pixels task
nodes on which
operations monadic image
using skeletons and
c using mpi
the skeleton type
are parallelized by
executing taskb processors
mpi panda library
parallelism has emerged
parallel support to
a source image
the iatg of
either pure task
connected through myrinet
2 node n
and sobel operators
therefore using only
a parallel image
is that both
image operations function
pure data parallelism
panda library 19
which need a
neighborhood operators we
vision application described
squared dierence between
a host processor
classication of low
most skeletons are
data parallelism has
parallelism is limited
parallel paradigm with
rendered separately possibly
nested task and
of images involved
large computational problems
model for integrated
host processor is
processed image master
have as parameters
pixel based on
dyadic image operators
node 2 node
image and two
ram running linux
name3 char name4
dierent image sizes
monadic image operations
costs account for
performance thus exploiting
to either pure

corpus/krapavin2000-test/611436.txt
spiht
parallelisation
coe
wavelet
pe
cients
lis
pes
renement
separators
lip
stream
lsp
coding
bpp
insignicant
compression
sm
video
separator
bit
transform
cient
bs
ospring
speedup
signicance
speedups
zerotree
ezw
spacial
psnr
unevenly
bits
sequential
mimd
subband
synchronisation
bands
trees
alteration
iterator
band
decomposition
signicant
lists
assembly
pixels
scan
threshold
entry
image
decoder
rst
entries
lter
neglectable
spacially
processall
parallelise
listless
neighbouring
lled
rene
scalability
ltered
grandma
coder
encoded
descendants
inserted
encoder
ciently
004
desc
termination
ltering
dierent
864
sub
xed
dierence
decoded
assembling
compatible
assembled
mpeg
parent
necessity
inherently
list
sign
rates
distortion
predicates
tree
rate
eect
slices
counter
sig
coarse
frames
appended
decoding
altered
pes26100
jumbles
ct950051
synchronise
fwf
qmf
packetise
p13903
uhl
epcc
standardisation
parallelised
pes5150
lena
synchronises
complexity13579
parallelising
signicances
dispenses
norcen
processcoe
515253510
utilisation
fmge
vtc
jpeg2000
tracs
visualised
drawbacks
copied
slice
_
3d
motion
ow
substitute
ciency
bigger
roots
transformed
decodes
cance
1082
austrian
localised
colours
computers
partitioning
nevertheless
overall
encodes
demands
loop
reads
collections
streams
splitted
bitmaps
initialisation
openmp
lling
breakdowns
1098
pass
consecutive
symbols
false
encode
understands
uous
inconvenient
erb
dct
jpeg
pyramidal
t3e
multirate
algo
tmr
tricks
roland
smps
multiplexed
divisibility
edinburgh
hierarchical
competitive
approximates
frame
suits
competitors
redundancies
scientic
reserves
bit stream
coe cients
wavelet transform
spiht algorithm
the spiht
renement step
zero tree
coe cient
sm based
the bit
zero trees
of coe
the parallelisation
parallelisation of
the wavelet
each pe
the lis
the sm
output bpp
single pe
original spiht
lis lip
bpp decomposition
sub band
decomposition overall
a renement
the parallel
compression rate
parallel wavelet
video data
coding part
each renement
list entries
local coe
lip lsp
stream assembly
overall spiht
direct ospring
overall coding
the sequential
sequential algorithm
d case
the coding
based algorithm
of pes
3 d
a separator
of separators
insignicant coe
approximation sub
hierarchical trees
set partitioning
of insignicant
d wavelet
lsp bs
cient p
a p
the coe
b p
the pes
discrete wavelet
unevenly distributed
has to
cients that
parallel algorithm
wavelet decomposition
the video
data distribution
xed compression
resulting bit
lis and
pe local
approximation subband
of spiht
scan order
sub bands
tree coding
transform algorithms
spiht parallelisation
all coe
14 bpp
stream bs
the ezw
separator entry
cient scan
mimd computers
pe and
video compression
end of
the speedups
the end
be encoded
algorithm is
2 d
in hierarchical
transformed data
the lip
compression rates
d algorithms
distributed complexity
of transformed
pe has
the speedup
the lists
the list
wavelet coe
each coe
rate 0
cients which
pe s
frame size
video sequence
a coe
the algorithm
non local
speedups for
inherently sequential
a list
o p
partitioning in
sub tree
inserted at
image compression
lists of
signicance of
cients in
evaluated only
coding for
a counter
of zero
c p
and c
decomposition on
low pass
the compression
entry of
pixels the
transform is
spacially oriented
list operations
process synchronisation
altered algorithm
coding algorithm
oriented coe
complicated bit
sig sign
2 zero
two competitive
renement steps
2 parallelisation
direct parallelisation
lists lis
coding figure
algorithm alteration
embedded wavelet
after parallel
the lsp
bs lis
parent coe
listless zerotree
memory demands
driven parallelisation
distributed lists
competitive approaches
cient positions
lis the
therefore implemented
of signicance
share in
mimd architectures
rst scan
mpeg 4
neighbouring pes
tree roots
spiht output
zerotree coding
desc p
pes is
bit streams
004 output
spiht a
be insignicant
insignicant sub
parallelisation e
separator is
those coe
maps sm
trees spiht
entry associated
destination list
varying compression
ezw algorithm
synchronisation and
direct spiht
software aspects
pass lter
b sm
entries after
ospring of
sequential part
the bit stream
the spiht algorithm
parallelisation of the
sm based algorithm
of coe cients
the wavelet transform
the sm based
a renement step
the parallelisation of
bpp decomposition overall
parallel wavelet transform
output bpp decomposition
the sequential algorithm
has to be
lis lip lsp
lists of coe
the coding part
spiht algorithm the
bit stream assembly
the original spiht
a single pe
each renement step
of the wavelet
b and c
partitioning in hierarchical
of the sm
lip lsp bs
insignicant coe cients
approximation sub band
spiht algorithm is
in hierarchical trees
the approximation sub
set partitioning in
local coe cients
coe cient p
of a list
a b and
the end of
b p is
set of coe
coe cients that
based algorithm is
discrete wavelet transform
at the end
of the coding
the parallel algorithm
p has to
end of a
if a p
the resulting bit
the parallel wavelet
zero tree coding
wavelet transform algorithms
3 d case
for each renement
wavelet transform is
of zero trees
3 d algorithms
within a renement
number of pes
unevenly distributed complexity
from the bit
bit stream bs
resulting bit stream
coe cient scan
3 d wavelet
0 14 bpp
of a coe
compression rate 0
the video sequence
all coe cients
of the spiht
wavelet decomposition on
number of separators
decomposition overall coding
rate 0 14
d wavelet decomposition
xed compression rate
evaluated only if
decomposition overall spiht
p is true
end of each
the parallel architecture
2 d case
wavelet coe cients
sequential algorithm is
a coe cient
each coe cient
coe cients which
inserted at the
have to be
p is false
be evaluated only
p b p
to be encoded
the coe cient
of the coe
coe cients in
see section 2
of a b
performed in parallel
of the video
a p is
image and video
single entry associated
way so that
direct ospring of
a p if
signicance maps sm
the lis and
coder using three
pe has to
bit rate the
rst scan order
collection of transformed
spacially oriented coe
a direct parallelisation
lsp bs lis
the list entries
therefore implemented as
embedded wavelet video
into the bit
of a renement
zerotree coding for
a depth rst
three dimensional set
of pes is
renement step threshold
among the pes
data has to
of the lis
sequential code parts
trees are local
wavelet transform in
of the ezw
p in approximation
therefore the global
renement step the
of process synchronisation
cients that are
video coder using
for higher numbers
that zero trees
an embedded wavelet
the frame size
lip are lled
an insignicant sub
to the bit
complicated bit stream
a separator entry
assembling the bit
of transformed data
of insignicant coe
tree without its
3 2 parallelisation
memory mimd computers
parallelisation e ciency
scalability of 2
each pe the
of wavelet coe
threshold threshold 2
containing a counter
parent coe cient
the lis the
b sm based
direct spiht parallelisation
entry associated with
sub tree without
overall coding figure
aspects for 3
share in execution
in the spiht
step threshold threshold
the decoder to
the ezw algorithm
video data size
004 output bpp
child coe cients
zero tree based
to be insignicant
software aspects for
are therefore implemented
wavelet transform as
of each renement
substitute the lists
the direct ospring
list of insignicant
number of renement
with a counter
trees of coe
using three dimensional
of renement steps
transformed data is
each pe produces
tree coding algorithm
zero tree roots
signicance of a
on the scalability
data driven parallelisation
overall coding b

corpus/krapavin2000-test/611451.txt
psdm
pseudospectrum
sweep
pseudospectra
pf
1107
kahan
triplet
curve
contours
gre
descent
newton
contour
speedups
cobra
curves
grid
disconnected
steepest
cyclic
min
arpack
processor
zi
singular
static
nished
processors
stepsize
correction
evaluations
partitioning
dn
mpi
lengths
signicant
boundary
toolbox
approximated
load
matrix
dospectrum
sparskit
imbalance
sweeps
gure
boldface
block
bekas
gallopoulos
inwards
embarrassingly
kokiopoulou
pseu
grcar
secs
depict
gradient
policy
allocate
approximate
approximating
mesh
uncontrollability
consecutive
inner
cf
partitionings
rst
polygonal
eigenvalues
prediction
wi
lying
reduction
tasks
dening
suer
rows
triplets
regarding
culty
neighboring
adaptation
balance
modied
matrices
experimented
readily
noting
matlab
jw
dropped
100
philippe
weakness
plane
outermost
proceed
master
vis
seeking
6000
proc
inferior
sgi
half
continuation
directional
upatras
secretariat
koutis
1390
d64
geo
zh
scgroup
blocksize
cuves
ameliorated
bruhl
visibly
tured
sunstantial
mipspro
2700
krg
mezher
springboard
underdetermined
spdm
mpt
astute
ceid
1560
ene
allgower
2760
3060
hpclab
satisfactory
manages
adapt
parallelism
parentheses
grain
corrected
allocated
sparse
trajectories
di
eective
nally
savings
path
owes
3750
inscribed
encircled
1466
shue
harwell
kostin
steplength
f90
jmin
embarassingly
circle
dropping
iterative
reveal
capturing
ect
inside
dene
renements
underline
1300
matics
openmp
wj
840
mathe
boeing
930
hermitian
underscore
irix
gauge
versatility
worth
target
moderate
distance
oered
unsymmetric
eorts
renumbered
arnoldi
of psdm
z k
the pseudospectrum
path following
points computed
sweep of
at z
gre 1107
point reduction
static block
by psdm
static cyclic
that psdm
disconnected components
psdm is
psdm we
the triplet
the sweep
of points
consecutive points
contour a
kahan 100
psdm on
steepest descent
newton step
points z
psdm with
initial curve
cyclic partitioning
one sweep
of pf
single sweep
and speedups
min zi
of pseudospectra
zi a
w k
relative error
point z
psdm can
pseudospectrum descent
kahan of
order 100
triplet at
dn p
psdm to
each sweep
initial contour
the contours
each processor
of table
m a
computation of
to approximate
computed by
of min
n points
of grid
singular vectors
of steepest
curve a
block partitioning
reduction policy
single newton
level curve
points dening
minimum singular
nished rst
boundary curve
with psdm
psdm in
matrix kahan
capture disconnected
method psdm
parallel nature
for gre
single boundary
psdm for
for kahan
contours computed
triplet evaluations
matrix gre
the curve
descent method
of path
points on
p e
complex plane
the speedups
load balance
points of
mean relative
based at
matrix toolbox
that min
e points
newton iteration
compute points
level curves
min u
the computation
table 8
the gradient
for computing
table 10
k 1
between consecutive
test matrix
computed via
the parallel
each task
singular value
time secs
load imbalance
u min
speedups in
w 0
approximated by
in table
cf 5
speedups are
points that
each curve
in boldface
the points
to compute
on matrix
on m
with static
and mean
processor 1
points to
real analytic
target points
grcar 50
by cobra
original curve
directions used
pseudospectrum contours
introduction cobra
pseudospectra the
y psdm
sweep psdm
stepsize of
points approximating
has nished
pseudospectra by
corrected towards
1107 1107
boundary curves
that nished
original path
points 46
curve if
pseu dospectrum
the pseudospectra
psdm will
secs 6000
sweep can
pf scheme
cobra to
e consecutive
embarrassingly parallel
use static
cyclic partitionings
wi a
rows 3
rows 7
for pseudospectra
contour m
via psdm
applied psdm
using descent
correction direction
contour lengths
curve 0
as arpack
corresponding speedups
time processor
psdm but
adaptive point
as psdm
partitioning time
polygonal path
triplet evaluation
parallel psdm
contours corresponding
nished with
a kahan
capturing disconnected
move inwards
pseudospectrum level
the psdm
block static
of triplet
by pf
in psdm
via pf
prediction direction
same contours
sweep of psdm
at z k
number of points
of the pseudospectrum
points computed by
of points computed
of path following
single sweep of
points z k
computed by psdm
computation of pseudospectra
min zi a
the initial curve
initial contour a
of table 8
kahan of order
application of psdm
one sweep of
the triplet at
implementation of psdm
dn p e
static cyclic partitioning
of psdm we
static block partitioning
points on m
pseudospectrum descent method
of order 100
the computation of
between consecutive points
consecutive points on
for the computation
z k 1
of steepest descent
the complex plane
matrix gre 1107
the parallel nature
on m a
version of pf
point z k
points of m
of psdm is
triplet at z
an initial contour
single newton step
contours computed using
distance between consecutive
parallel nature of
the point reduction
a single sweep
capture disconnected components
n points z
maximum and mean
for gre 1107
the minimum singular
computing the triplet
a single newton
the pseudospectrum descent
single boundary curve
a single boundary
of the sweep
based at z
the test matrix
min u min
points computed in
test matrix toolbox
times and speedups
for computing the
m 1 a
the number of
of m a
to each processor
0 1 a
one half of
parallel implementation of
it follows that
speedups in parentheses
of table 11
experimented with static
block static cyclic
single step of
on matrix gre
contours corresponding to
psdm will be
min q min
partitioning in which
e consecutive points
of psdm the
newton step at
of psdm to
corresponding to min
rows 7 9
directional newton methods
gre 1107 a
the directions used
of triplet evaluations
the same contours
r min x
sweep can be
outlined in table
gradient based at
the gradient based
psdm is the
min z k
indicate that psdm
methods in n
u min v
the original path
and mean relative
such as arpack
points to each
for kahan 100
real analytic in
methods an introduction
at z is
cost for computing
directions used in
partitioning time secs
disconnected components of
p e consecutive
7 9 of
has nished with
of singular vectors
is embarrassingly parallel
original method of
continuation methods an
the newton iteration
9 of table
path following method
using static block
psdm on matrix
0 w y
that psdm manages
we move inwards
to min zi
7 of table
p e points
initial curve 0
of psdm on
correction direction c
the sweep psdm
maximum relative error
static block static
evaluation at z
to the geometric
direction c k
z k i
point reduction policy
inside the initial
lying inside the
processor that nished
same contours computed
newton methods in
and cyclic partitionings
stepsize of the
cyclic partitioning in
applied psdm on
boundary curve a
cf 5 2
that nished rst
a and computed
and speedups in
in each sweep
original path following
time secs 6000
with point reduction
grid where the
point w k
time processor 1
of parallel implementation
by a pf
analytic in a
a for k
psdm manages to
adaptive point reduction
number of triplet
where the triplet
to use static
min v min
candidates for dropping
each sweep can
points of i
static block and
1 determine a
psdm can be
policy described in
curve 0 1
descent method psdm
triplet evaluation at
w k using
points dening the
capturing disconnected components
reduction policy described
the original curve
min x k
of the contours
by psdm in
parallel psdm with
of grid where
a kahan of
block and cyclic

corpus/krapavin2000-test/611453.txt
chebyshev
residuals
ellipse
residual
foci
recursions
rutishauser
richardson
ultimate
recurrences
ult
roundo
krylov
iteration
res
coecients
rec
bicg
1040
12c
eigenvalues
polynomials
accuracy
12a
axis
spectrum
conjugate
cg
acc
recurrence
ax
convergence
gradient
gap
poles
jt
195
recursion
expl
rut
joukowski
2x2
factors
159
segment
quotients
coupled
elliptic
stationary
pole
1e
oating
matrices
quotient
iterates
asymptotic
exterior
spd
12b
conformal
origin
7e
roundoff
recursively
imaginary
nonsymmetric
norm
conditioned
absolute
updated
strakos
semiiterative
cosh
001i
stagnate
solvers
uence
lie
straight
sucient
products
amplication
6e
ultimately
nth
versions
iterative
9e
elliptical
amplied
ellipses
interval
ill
3e
norms
arithmetic
90
mildly
updating
denominator
attainable
aected
zeros
achievable
errors
ridge
epsilon
corrections
slowly
seriously
six
euler
inexact
matrix
determination
symmetric
nonlinear
come
peaks
reformulation
serious
overton
manteuel
residu
arcosh
summability
shev
1959
iterationsverfahren
nonsymmetrizable
biconjugate
05i
equation2
cheby
misprints
biomin
ansatz
kublanovskaya
confocal
verfahren
omin
iterations
explicitly
converge
summarizing
bi
semi
onto
zdenek
needless
orthogonalization
greenbaum
gutknecht
overrelaxation
diagonalizable
sinh
unitarily
stagnates
stiefel
inexactly
hestenes
allgemeine
2k
rst
realization
48
slow
classical
rate
eigensystem
amplify
8e
als
lanczos
2060100
0e
nonzeros
denition
multiplicative
disk
monotone
inner
fig
iter
forecast
jbj
damped
golub
kf
bicgstab
dened
plotted
inserting
normalized
996
gmres
asymptotically
converges
dierent
oblique
chebyshev iteration
three term
the chebyshev
two term
computed residuals
ultimate accuracy
the ellipse
explicitly computed
foci c
recursively computed
term recurrences
r n
chebyshev polynomials
coupled two
with foci
recurrence coecients
order richardson
true residuals
the residual
the factors
real axis
krylov space
b ax
the ultimate
line segment
term chebyshev
residual chebyshev
residuals are
richardson iteration
acc n
rec res
res true
ult acc
w rec
an ellipse
ellipse with
true residual
the residuals
12a 12c
term recursions
term recursion
15 1040
recursions for
absolute value
conjugate gradient
iterative methods
cg and
elliptic domain
term version
factors 48
updated residuals
local errors
rutishauser versions
12 ult
iteration is
iteration with
in 10
the recurrence
x n
second order
computed residual
in oating
residual gap
the straight
n 1
the origin
straight line
segment c
t n
algorithm 1
n 12
local error
the recursions
point arithmetic
the quotient
accuracy is
as algorithm
symmetric about
w expl
factors 12a
15 159
15 195
with sucient
residual norms
semi axis
residuals is
sucient accuracy
2x2 w
ellipse must
expl res
normal matrices
ax n
residuals by
with spectrum
and rutishauser
chebyshev 2x2
gap f
space methods
and residuals
residuals we
joukowski transformation
res rec
norms chebyshev
rut w
chebyshev rut
rec residual
with updated
7e 15
16 159
number normalized
chebyshev 3
of absolute
the convergence
polynomials are
term and
oating point
n and
linear systems
the gap
axis a
achievable accuracy
recursions 6
term two
computing r
axis but
normalized residual
space solvers
iteration using
exterior of
iteration see
residual fig
residual norm
the three
than 1
the interval
asymptotic convergence
the exterior
iterates and
3 term
a pole
residuals and
the spectrum
the eigenvalues
lie on
matrices with
value smaller
the recursively
iteration number
ill conditioned
iterations needed
version with
domain e
methods based
inner products
for solving
the recursion
around 0
1 except
24 25
accuracy of
and true
a matrix
in uence
side equations
very at
term rutishauser
come very
recursions iteration
whose foci
stationary second
the quotients
step iterative
elliptical domain
and richardson
ellipse or
standard three
100 70
rutishauser s
poles and
worst for
16 195
ellipses chebyshev
for mildly
spectrum on
consistency condition
serious in
12c in
jt 2n
assume iterates
approximation problem
to cg
1040 1
residuals algorithm
roundoff effects
whose eigenvalues
the roundo
ultimately achievable
a ult
solving choose
and bicg
the chebyshev iteration
explicitly computed residuals
the three term
the ultimate accuracy
of the chebyshev
coupled two term
chebyshev iteration is
second order richardson
with foci c
straight line segment
the recurrence coecients
ult acc n
recursively computed residuals
res true residual
acc n 12
order richardson iteration
w rec res
r n 1
ellipse with foci
and r n
two term recurrences
the chebyshev polynomials
the real axis
three term recurrences
about the real
oating point arithmetic
ultimate accuracy is
the factors 48
12 ult acc
same as algorithm
chebyshev iteration with
term chebyshev iteration
line segment c
three term version
n 12 ult
the straight line
x n and
n 1 and
an ellipse with
of absolute value
on the straight
in oating point
symmetric about the
on the positive
the second order
iterative methods for
rutishauser versions of
chebyshev iteration using
three term recursions
chebyshev 2x2 w
chebyshev polynomials are
normal matrices with
krylov space methods
zero of t
the factors 12a
term and rutishauser
absolute value smaller
three term recursion
of the ellipse
7 for computing
with updated residuals
factors in 10
expl res true
than 1 if
factors 12a 12c
three term chebyshev
iterates and residuals
rec res rec
three term two
the residual norm
any 2 c
term two term
chebyshev 3 w
two term and
computing r n
true residual chebyshev
chebyshev rut w
w expl res
res rec residual
with sucient accuracy
rec res true
semi axis a
b ax n
by explicitly computed
normalized residual norms
onto the exterior
if the recurrence
version with updated
foci c and
residual norms chebyshev
and rutishauser versions
true residual fig
with three term
two term chebyshev
recursions 6 and
the gap f
term version with
iteration number normalized
the ellipse must
rec residual chebyshev
positive real axis
and true residuals
algorithm 1 except
number normalized residual
all of absolute
computed with sucient
r n and
n and r
as algorithm 1
real axis and
the exterior of
the recursions 6
recursively computed residual
the residual gap
or on an
krylov space solvers
spectrum of a
methods for solving
1 except that
the local error
iterations needed to
interval 1 1
the convergence of
lie on the
the spectrum of
value smaller than
methods based on
the positive real
of iterations needed
the line segment
for the three
the interval 1
except that the
smaller than 1
eigenvalues of a
for any 2
lies on the
to the origin
t n 1
the eigenvalues of
residual norm by
matrices with eigenvalues
chebyshev iteration see
equations from 4
term recurrences and
space methods based
r 0 b
the multiplicative factors
and compute for
factors 48 in
a ult acc
algorithms estimating the
residual chebyshev 3
inner products and
multiplicative factors in
the standard three
100 50 90
3 term 2
in conjugate gradient
stationary 2 step
axis a matrix
n 12 100
foci c that
iteration for solving
term recursions for
to a pole
10 for 0
recurrence coecients are
term recursions iteration
15 1040 1
coecients are computed
the factors are
term rutishauser c
for solving choose
computed residuals by
or an ellipse
c symmetric about
norm in conjugate
residuals by explicitly
of inexact chebyshev
updated and true
recursions for the
jt 2n 1
residual r n
0 b ax
step iterative methods
local error whose
avoid the residual
contrast to cg
an elliptic domain
elliptical domain e
and c so
whose components come
poles and they
conjugate gradient type
computed residuals are
ultimately achievable accuracy
that the recursion
a matrix 3
of a lies

corpus/krapavin2000-test/613633.txt
urn
hfn
dns
url
urls
lookup
hfns
urns
contact
resource
naming
name
service
replica
resources
directory
forwarding
web
proxy
resolution
scalability
leaf
pointer
server
rfc
uri
location
replicas
doi
globe
names
record
lds
subnode
geographical
replicated
caching
servers
named
humans
resolver
locality
browser
records
resolve
resolved
pointers
rds
resolving
friendly
internet
caches
root
worldwide
services
isbn
ietf
mappings
pages
node
responsible
store
shenker
authority
intel
cache
linux
host
insert
scalable
uris
tanenbaum
walfish
arno
subnodes
steen
bakker
sandpiper
visited
email
infrastructure
contacts
org
mobile
visits
src
subdomain
popular
akamai
ldap
namespace
ratnasamy
registry
2276
sigcomm
mapping
human
nl
book
requests
located
load
kbyte
originate
replication
bind
setup
sylvia
campus
vu
gbyte
houston
remembered
fanout
hari
contacting
balakrishnan
domains
nearby
administrative
ip
storing
florida
request
deals
locating
francisco
authorities
parent
scott
identifies
handle
registered
yellow
resolves
stored
miami
prefix
stable
working
subsequently
regularly
delete
corporation
wants
destinations
retrieve
middleware
lightweight
usa
texas
suffix
com
overloaded
cached
responsibility
broadens
friendliness
federations
2136
criticize
rfcs
2648
aurn
transcribable
locators
universiteit
wijngaards
brazier
vrije
1737
2141
registries
hendricks
prisco
cated
2484
mealling
2513
cnrp
posal
overeinder
crispo
area
update
hardly
users
avoids
nodes
html
associates
primarily
hosts
hierarchical
andrew
hashing
fective
akella
misusing
maarten
location service
hfn to
the hfn
a urn
the urn
name service
to url
contact record
lookup operation
web resources
a url
the lookup
dns name
the name
lookup operations
forwarding pointers
forwarding pointer
to urn
lookup length
name server
name space
the location
a resource
the url
leaf node
directory node
urn to
replica replica
the proxy
a dns
name servers
in dns
name resolution
url url
the leaf
urn mapping
url mapping
in rfc
name system
of lookup
hfn resolution
contact records
an hfn
the resource
the contact
of forwarding
a contact
geographical area
the handle
the root
the dns
domain name
host name
dns is
our hfn
mobile resources
contact field
urn and
resource records
named by
uniform resource
a name
a forwarding
working group
human friendly
urn is
replicated web
the insert
root node
resolution process
the usa
a lookup
naming authority
urn name
url resolution
urn the
large geographical
hfns are
naming system
average lookup
usa node
of name
urls are
resources we
of urls
the globe
to store
common name
url of
resource record
directory services
web browser
a location
resources and
insert operation
named resource
popular web
the named
service the
of scalability
resolving a
urls in
mapping is
to resolve
responsible for
a replica
service to
hierarchical name
intel com
handle system
linux org
identify resources
scalability problem
resource model
of uri
resolved to
common names
resource named
hfns to
existing dns
resolution scheme
lookup requests
url proxy
src linux
leaf domain
uri scheme
urls can
of urn
pointer cache
globe location
pointer caches
url at
multiple urls
search tree
the directory
contact the
service we
a user
leaf nodes
be resolved
of locality
a directory
by humans
the web
resources when
proxy to
resolution service
dns and
our naming
resolution mechanism
dns to
using dns
and email
system dns
only identifies
m relation
dns infrastructure
to name
name to
wide area
service and
when possible
processing load
scott shenker
url and
highly mobile
url is
replica is
of replicas
access information
partitioning scheme
resolve the
store the
path of
local access
record is
to contact
the domain
both systems
update operations
of contact
the resolution
stored in
to access
nodes visited
scheme called
mapping we
ip addresses
pointer to
contacts the
resources that
a scalable
domain the
replica in
its urn
one urn
this scalability
urns in
single urn
server responsible
the location service
the hfn to
hfn to url
hfn to urn
the leaf node
to urn mapping
a forwarding pointer
domain name system
of forwarding pointers
a lookup operation
a contact record
to url mapping
a dns name
the domain name
the lookup operation
the name server
the name service
replica replica replica
a location service
set of urls
url url url
path of forwarding
of lookup operations
the root node
of name servers
to url resolution
the lookup length
large geographical area
the named resource
a large geographical
the insert operation
location service the
average lookup length
sequence of name
the contact record
the usa node
the urn to
in the location
distributed over a
to be resolved
a directory node
has a contact
name service and
hierarchical name space
url of the
a urn is
to url proxy
resource named by
urn to url
of the hfn
common name resolution
urn name space
want to support
the handle system
in the contact
src linux org
replicated web resources
number of lookup
to identify resources
to a urn
a url is
name system dns
the url of
globe location service
the directory node
highly mobile resources
popular web resources
a name service
contact record the
to m relation
with a dns
the globe location
the existing dns
in the tree
over a large
number of resources
the name space
of these nodes
the request to
from the leaf
of the leaf
when a user
if we want
responsible for the
a large number
of the resource
with a urn
location service we
uri scheme called
url mapping we
forward the request
retrieve web resources
the url and
the common name
contact field with
replica is added
pointer to n
naming system we
in its subdomain
number of contact
where a url
directory node for
service in step
stored in dns
about the urn
of locality is
leaf node where
andrew s tanenbaum
working group is
replicated web pages
that the name
the leaf domain
leaf domain the
way to name
requires our name
usa node the
name web resources
name service we
url resolution mechanism
uniform resource identifiers
forwarding pointer or
dns to store
identify resources and
the international doi
web resources named
if a resource
resources when possible
need to contact
existing dns infrastructure
the proxy step
to access resources
urn needs to
internet hosts and
form of scalability
contact record is
lookup operation finds
the contact records
operation starts by
service and in
nodes visited during
contact the sequence
the florida node
of uri is
name space in
our name service
human friendly naming
of contacting a
the urn and
of scalability requires
name servers a
a single urn
the dns name
using the domain
located near the
for a url
human friendly names
one site in
hosts and email
forwarding pointer the
an n to
urn mapping is
the lookup processing
scheme called human
node where a
to a url
an hfn to
called human friendly
url proxy to
node for d
of the globe
service to provide
a url at
web resources we
n to m
always originate from
forwarding pointers from
a user located
name server for
the same geographical
space always originate
of contact records
using the dns
forwarding pointers to
urls can be
request to its
names hfns to
lookup operation at
location service as
a urn and
name service in
international doi foundation
is resolved to
geographical area we
pages approach is
the resolution process
a naming authority
the urn working
service we use
our partitioning scheme
supports in the

corpus/krapavin2000-test/613982.txt
sp2
latency
mpi
v4
throughput
subsystem
mpps
adapters
switch
ibm
mpl
aix
message
mb
kb
upgrade
messages
interchange
swm
thmax
benchmarks
v3
collective
bt
pvm
npb
mflop
broadcast
native
communication
adapter
old
sp
c4
spooling
meiko
dd95
gregorio
passing
processors
mpich
mpp
paragon
processor
directional
nas
interconnection
grain
medium
bus
lu
bandwidth
barrier
achievable
mg
benchmark
configurations
xh96
cul96
age95
bai95
hoc94
fra95
beivide
parkbench
mpi_bcast
128
upgraded
simulator
bi
intel
bytes
irvine
destination
programmed
torus
peak
micro
numeric
reductions
channel
rendezvous
communications
regions
asymptotic
region
short
offers
hardware
fortran
software
researcher
factored
navier
1000
stokes
noticeably
plus
thousands
fitted
basically
supercomputing
nowadays
shallow
ethernet
bisection
triangular
network
tests
water
specially
designers
cache
library
reduction
community
ports
cray
77
assessing
subsystems
offering
fluid
header
kernels
discretization
frequent
tens
routers
ps
massively
jobs
3000
latencies
characterize
myricom
mpi94
tirado
euphoria
cnica
vallejo
32x32
fica
3559
hp96
argonne
dgicyt
comunicacions
tic95
gar96
2000600010000
4x4
investigaci
mpi_recv
spp1000
mpi_reduce
aprox
cs2
labarta
bechmarks
pentadiagonal
7236
mpi_max
spp1200
hockney
sangman
mpi_barrier
dongman
pstswm
benchmark2006001000
myr96
johasz
mig95
direcci
0378
5001500mg
mpi_send
llorente
zoltan
1200400600800
nonmember
fittings
comisi
823
gei94
gflop
wf95
1502
mpi_sum
bri95
dongsoo
sni95
stu95
25001500250032
unfactored
mpi_min
worley
tecnolog
massive
running
communication subsystem
the sp2
parallel applications
mb s
message length
s message
o v4
performance switch
latency and
the latency
latency s
to point
n v4
new switch
th o
o v3
of mpi
long messages
point to
and throughput
point communication
message passing
start up
the message
of latency
the upgrade
length kb
throughput mb
up time
short messages
the communication
interchange of
high performance
t h
point communications
sp2 systems
sp2 communication
native version
mflop s
execution times
ibm sp2
latency is
been increased
throughput for
average values
throughput is
collective operations
the switch
new version
bi directional
the broadcast
been measured
frequent interchange
v4 n
v4 th
s sp2
spooling time
plus mpi
v4 throughput
lu sp
the spooling
parallel simulator
v3 o
message th
the npb
micro channel
sp2 configurations
the adapter
nas parallel
of aix
adapters aix
a gregorio
v3 th
and adapters
kb region
parallel benchmarks
4 kb
the native
the old
the high
parallel computer
throughput of
of parallel
message size
the interconnection
point case
applications requiring
asymptotic throughput
minimum latency
sp2 the
obtained running
length figure
grain parallel
the throughput
latency in
the new
the start
when running
interconnection network
sp2 parallel
message latency
ibm s
processor 0
running parallel
th n
maximum throughput
mpi and
switch and
change in
the performance
intel paragon
fortran 77
the ibm
execution time
are short
latency for
built around
sp and
fine grain
to reach
for running
old and
mb of
for messages
of message
header to
software layer
the mpp
difference discretization
mpi collective
message interface
numeric applications
80 nodes
communication tests
and meiko
over mpl
latency reduction
upgrade in
as visiting
upgraded the
enough messages
mpps and
mpps including
be fitted
passing networks
software elements
32 kb
noticeably reduced
s peak
channel controller
v4 native
a sp2
r beivide
region 3
sp bt
passing software
simulated computational
case minimum
the parkbench
offers several
acknowledgements section
equations resulting
ibm has
parallel application
77 plus
sp2 when
upgrade has
the nas
several mpi
communication software
approximately factored
passing paradigm
old switch
and mpl
c4 s
region 1
the interchange
our group
ibm offers
directional ports
messages while
bt swm
of mpps
switch which
interchange very
implicit finite
current mpps
aix v4
mg lu
random traffic
rendezvous protocol
the adapters
throughput has
for short
basically the
times of
to offer
hardware and
these programs
one half
point to point
latency and throughput
high performance switch
s message length
latency s message
the communication subsystem
version of mpi
the new switch
to point communication
of the sp2
the high performance
with the old
start up time
message length kb
throughput mb s
the start up
the latency is
of parallel applications
native version of
to point communications
sp2 communication subsystem
and throughput for
mb s message
has been increased
the ibm sp2
execution times of
the point to
o v4 n
grain parallel applications
th n v4
v4 n v4
o v4 th
n v4 throughput
length kb region
switch and adapters
message length figure
messages are short
results obtained running
s message th
v3 th o
o v3 o
v3 o v4
to point case
frequent interchange of
th o v3
message th o
v4 throughput mb
v4 th n
the spooling time
o v3 th
of short messages
nas parallel benchmarks
th o v4
j a gregorio
and adapters aix
with the new
of the new
new version of
of message passing
in the communication
the message passing
obtained running the
for long messages
a communication subsystem
sp2 parallel computer
to the switch
the old and
the interconnection network
the latency and
the execution times
to offer a
for point to
by the message
change in the
hardware and software
of the communication
l 1 2
the performance of
one half of
the message size
performance of parallel
a new version
finite difference discretization
can be fitted
several mpi collective
reduction of latency
mpi collective operations
over 4 kb
e a message
message passing networks
by our group
throughput for the
the upgrade in
message size required
very similar behavior
average values are
parallel applications the
lu sp bt
asymptotic throughput of
for short and
and medium messages
message header to
a frequent interchange
characterization of latency
to 80 nodes
experiment a significant
ibm sp2 the
sp2 when running
for short messages
v4 native version
for running parallel
the nas parallel
aix v4 native
implicit finite difference
mb s peak
up to 80
mg lu sp
header to reach
running parallel applications
adapters aix v4
micro channel controller
regions that correspond
is used i
message passing software
offers several alternatives
be fitted to
bi directional ports
equations resulting from
simulated computational fluid
performance switch which
latency is noticeably
s for systems
message latency in
communication subsystem we
throughput are the
random 2 sets
times of parallel
developed by our
of equations resulting
throughput has been
c4 s sp2
message passing paradigm
difference discretization of
sp and bt
and software elements
for the sp2
components of latency
throughput for point
point communication a
77 plus mpi
new communication subsystem
interchange of short
of latency in
latency for short
mpps including the
on a sp2
is noticeably reduced
old switch and
the sp2 communication
parallel applications is
the interchange of
1 point to
regarding the hardware
the sp2 when
spooling time t
the latency for
fortran 77 plus
with processor 0
communication subsystem will
sp2 the sp2
mpi and mpl
3 parallel applications
achieved throughput is
large data structures
of the npb
communication a first
sp bt swm
fitted to equation
parallel applications in
reductions in execution
the parallel simulator
when writing this
the problem size
the reader can
introduction of the
of the high
the operating system
the message header
to equation 2
resulting from an
increase the throughput
mb s the
of the navier
required to transmit
the regions that
communication subsystem of
run parallel applications
and fine grain
i o bus
has been measured

corpus/krapavin2000-test/614294.txt
gabor
pca
wavelets
wavelet
texture
kohonen
laser
visualization
neurons
fig
multidimensional
frequency
facial
sylvia
pyramid
color
fourier
training
colors
segmentation
neuron
landmarks
face
shape
multiresolution
principal
scanner
eq
valued
decomposition
feature
image
orientation
transform
figured
pipeline
nostrils
lvq
subspace
features
2d
mouth
eye
centroids
gaussian
evidently
orthonormality
trained
coding
regions
surface
pupils
sine
amplitude
nose
spatial
envelope
imaginary
visualizing
encode
green
cosine
curvature
faces
orthogonal
3d
images
eyes
topological
coefficients
visualize
tip
competitive
supervised
localization
coordinates
onto
map
gross
orthonormal
nonseparable
scanners
filters
frequencies
eigenvectors
shifting
scaling
vectors
encoded
eigenspace
orange
self
clusters
reconstruction
layer
red
graphics
human
resolution
eigen
areas
rotated
convolution
postprocessing
oscillation
markus
covariance
antisymmetric
normalization
volume
plane
21c
8x8x8
brows
cheeks
moustache
diagonalizes
gatti
darmstadt
demarcated
similarities
modulation
dimensionality
signal
scientific
dc
fft
neural
localized
spectral
expansion
products
visual
coordinate
18b
decorrelated
surgery
staadt
illumination
blue
selectivity
eigenvector
depicted
rendering
energy
cylinder
bases
heisenberg
luminance
pink
female
tensor
window
extraction
clustering
filter
16b
radiosity
rgb
reacting
euclidian
morphing
photographs
dure
topology
interpreted
depicts
decompositions
directional
eigenvalues
transforms
proce
grain
rotation
organizing
rendered
rough
respective
cortical
roger
cylindrical
geometric
preservation
around
compact
network
elegantly
superimposing
vision
detection
picture
scaled
reconstruct
width
coherent
pyramids
decompose
reveal
corner
normalized
the gabor
range data
gabor wavelets
kohonen map
complex valued
gabor function
laser range
the kohonen
the pca
data features
and texture
gabor functions
r g
sylvia s
training areas
g b
feature vector
in fig
s image
shape and
texture data
fourier transform
the feature
image function
visualization pipeline
the wavelet
topological mapping
without pca
frequency plane
data sets
principal component
component analysis
based visualization
texture information
of gabor
visualization of
feature vectors
feature based
m h
x y
gabor decomposition
multidimensional feature
of sylvia
of multidimensional
the texture
range and
human faces
the landmarks
with gabor
in frequency
range images
the segmentation
u v
figured out
the data
gabor pyramid
convolution products
competitive layer
g m
wavelets and
the competitive
i u
and orientation
features from
the frequency
the decomposition
self similar
data set
map was
color space
scaled and
h gross
the wavelets
similar colors
gaussian in
computer graphics
the training
the features
non orthogonal
color information
scalar valued
sine and
wavelets are
right eye
multidimensional data
to encode
g l
the range
real part
m i
around the
i x
each neuron
scientific visualization
the network
features in
spatial frequencies
competitive neurons
face features
face data
in eigenspace
valued gabor
valued 2d
similar functions
mapped as
oscillation term
gabor transform
expansion basis
with pca
compact coding
signal analysis
orthonormality and
a topological
tip of
the nose
was trained
2d image
frequency domain
and color
detection of
the topology
it s
the method
and scaling
the gaussian
data analysis
volume rendering
the mouth
in fourier
the scanner
inverse fourier
2d gabor
a gabor
markus h
is figured
projected into
of laser
range information
similar features
the color
into r
feature space
to visualize
of principal
the localization
amplitude and
b color
texture analysis
gabor filters
in wavelet
pyramid is
of fig
data of
from fig
the complex
onto the
the fourier
each surface
normalization and
encode and
a supervised
important data
and imaginary
arises how
spatial domain
surface point
feature extraction
decomposition of
at m
and frequency
principal components
data only
the bases
the multidimensional
neurons in
a multiresolution
the eyes
data from
local data
of self
the neurons
encoding scheme
dimensionality reduction
be interpreted
a complex
straightforward way
the face
fine grain
of detection
trained with
c means
initial data
analysis and
neural network
wavelet transform
the covariance
of human
the spatial
data using
of colors
r g b
the kohonen map
shape and texture
laser range data
the gabor function
of the gabor
sylvia s image
feature based visualization
i x y
i u v
g m i
the frequency plane
principal component analysis
of the kohonen
m i x
visualization of multidimensional
the gabor decomposition
of the pca
of sylvia s
based visualization pipeline
a complex valued
the feature vectors
of self similar
the gabor pyramid
into r g
2d image function
with gabor wavelets
kohonen map was
local data features
of the landmarks
the competitive layer
in the frequency
the complex valued
the range data
of the data
have to be
of the nose
tip of the
and texture data
complex valued 2d
within the training
complex valued gabor
face data base
the multidimensional feature
important data features
g b color
performance of detection
the gabor wavelets
the principal component
of multidimensional data
the convolution products
a topological mapping
and phase of
encode and analyze
set of self
the training areas
gaussian in the
the texture data
each surface point
kohonen map is
multidimensional data sets
around the eyes
m i u
range data using
self similar functions
initial data set
arises how to
b color space
from the gabor
image function and
g x y
detection of the
markus h gross
inverse fourier transform
functions of different
amplitude and phase
width and length
feature vectors are
at each surface
is figured out
the r g
can be interpreted
of the feature
real part of
to be normalized
of the texture
of detection of
of human faces
of shape and
feature extraction and
of the wavelet
due to the
left and right
phase of a
the feature vector
decomposition of the
a x a
the covariance matrix
fourier transform of
of the gaussian
of the image
the fourier transform
the constraint of
corner of the
is not restricted
not restricted to
depicted in fig
be interpreted as
using complex valued
finite energy function
no immediate way
around right eye
coefficients in our
topology preservation of
figured out in
data features from
it s fourier
surface point and
function a set
of similar features
any finite energy
vectors of sylvia
cylindrical coordinate system
range data in
and rotated version
to perfectly reconstruct
analysis normalization and
convolution products g
be projected into
is no straightforward
using the gabor
diagonalizes the covariance
complex data sets
primarily applied to
data using complex
signal analysis and
the wavelet features
onto the r
the pca for
s fourier transform
fourier transform g
with a supervised
multidimensional feature space
the pca on
data from human
to be projected
of the wavelets
proposed in 23
topological mapping neural
the orientation and
in fourier space
s image encoded
m h and
is no immediate
as an expansion
features within the
multidimensional feature vector
an expansion basis
affected by specific
range function is
valued 2d image
training areas demarcated
in the competitive
and texture features
and kohonen map
range data from
similar functions of
the feature based
texture data only
a subspace that
gabor functions of
raw laser range
products g m
gabor function can
and in frequency
the landmarks using
range data sets
component analysis and
information elegantly and
a texture onto
the dimensions from
for laser range
in wavelet space
s image a
methods in particular
according to appendix
scaled and shifted
of range data
cluster analysis and
multidimensional face features
complex valued decomposition
map was trained
way to perfectly
feature vectors g
from fig 7
computer graphics center
texture data is
restricted to that
vectors g l
figured out by

corpus/krapavin2000-test/614303.txt
vortex
vorticity
vortices
tube
corrector
skeleton
tubes
pressure
predictor
turbulent
flow
core
vortical
cross
seed
cores
shear
visualization
hairpin
grid
skeletons
isosurfaces
velocity
unsteady
tracktur
visualizing
fourier
spiral
plane
radius
perpendicular
rendering
quantities
volumetric
surface
helicity
grooves
feeders
robinson
reconstruction
graphics
elongated
radial
silver
turbulence
animation
integration
fig
3d
gradient
interpolation
moin
spanwise
streamwise
enstrophy
deborah
field
flows
volume
fluid
shaped
locate
helical
sectional
cambridge
viewer
scalar
wall
workstation
stretching
curves
curve
polygonal
reprinted
jiminez
jfm
quadrilateral
skeletal
fields
shape
interactive
circular
polygons
tracking
figs
cylinder
samples
aligned
press
faithful
reconstructed
visualize
wander
filament
intensity
mesh
connective
varying
polygon
coherent
continuation
frames
integral
finely
numerical
display
enhanced
regions
seeds
boundary
frame
compressed
velocities
magnitudes
ellipsoids
spot
sampled
shapes
cell
motion
streamlines
reduction
cray
1e
datasets
image
gigabytes
predicted
storage
wanders
interiors
woodring
marched
feeder
tangle
cantwell
centripetal
resolved
eigenvalues
shen
region
dynamics
isosurface
head
unstructured
spherical
polar
jiang
interpolate
bytes
interior
surfaces
coordinate
rotation
inward
laminar
emanate
physicist
advecting
cylinders
locating
fold
permit
meshes
reconstruct
silicon
center
layer
hundreds
capturing
coefficients
1a
spirals
wireframe
eduard
turk
dissipates
twists
tensor
capture
lie
discarded
identification
curvature
backwards
angle
machiraju
twist
indigo
transitional
p8
intense
reconnection
decimation
flagged
xin
thin
thousand
planes
gradients
the vortex
a vortex
vortex tube
the vorticity
predictor corrector
cross section
vortex core
vortex tubes
the predictor
vortex skeleton
the cross
cross sections
vorticity lines
the skeleton
vortex cores
corrector method
the pressure
the flow
the tube
of vorticity
the core
skeleton line
of vortex
seed point
the vortices
vortex skeletons
vortices are
low pressure
vorticity vector
corrector scheme
data reduction
time varying
vorticity and
flow field
pressure and
the corrector
vortices in
shear flow
vorticity line
vortical structures
the surface
pressure minimum
and vorticity
in turbulent
integration from
vortex is
numerical simulation
unsteady flow
seed points
flow data
a shear
perpendicular to
the velocity
cambridge university
fourier series
radius function
a turbulent
pressure gradient
flow quantities
reverse integration
tube the
corrector phase
hairpin vortex
tubes are
polygon count
corrector technique
vortex cross
new vortex
time step
turbulent flow
structures in
flow fields
the spiral
an unsteady
on visualization
university press
in fig
large vorticity
streamwise direction
vortex this
integral curves
low intensity
deborah silver
average radius
channel flow
of pressure
vortex the
integral curve
turbulent channel
the streamwise
velocity gradient
vortices over
skeleton point
reference vector
turbulent spot
plane l
vortex head
boundary layer
reconstructed vortex
vortex stretching
core the
grid cell
grid point
a flow
point p
plane perpendicular
surface of
the plane
to locate
continuation of
3d grid
isosurfaces of
predicted point
a viewer
a seed
cross sectional
flow in
of storage
a point
shape of
the seed
computational domain
by factors
time steps
volumetric data
to visualize
an interactive
factors of
the vortical
0 degree
scale vortices
tube s
turbulent boundary
nearly circular
faithful reconstruction
vorticity to
section plane
of turbulent
structures within
tube at
reprinted with
degree direction
free shear
boundary layers
finely sampled
locate vortices
direct numerical
shaped vortex
a vorticity
vortical flow
with fourier
wall normal
jfm v
vorticity magnitude
circular cross
given vortex
quantities for
tube can
vorticity at
in flow
s cross
vortex we
skeletal representation
a hairpin
vortical motion
skeleton points
hairpin vortices
the continuation
skeleton is
visualization system
vector n
the predicted
vector field
normal vector
for visualizing
forward integration
identification schemes
domain boundary
fig 1e
original 3d
for vortex
s shaped
skeleton that
of vortices
3d grids
planes perpendicular
fourier representation
of cambridge
quadrilateral mesh
tubes in
dimensional flow
in free
our predictor
rendered on
corrector algorithm
visualization of
representation of
per second
flow the
the technique
of the vortex
the predictor corrector
the cross section
the vortex tube
the vortex core
of a vortex
the vortex skeleton
predictor corrector method
predictor corrector scheme
in a vortex
the vorticity vector
a vortex core
of the cross
the flow field
the vortex tubes
a vortex tube
of the tube
the skeleton line
perpendicular to the
of the vortices
cambridge university press
the corrector phase
a shear flow
vortical structures in
pressure and vorticity
the cross sections
predictor corrector technique
the vortex cross
of the skeleton
the streamwise direction
on the vortex
the vorticity line
a vortex is
of the pressure
the velocity gradient
turbulent channel flow
a seed point
of the vorticity
the pressure gradient
in a shear
within the flow
plane l k
the numerical simulation
the pressure minimum
from the vortex
integral curves of
the continuation of
to the vortex
plane perpendicular to
the surface of
of the flow
cross section of
surface of the
by factors of
the seed point
the predicted point
an unsteady flow
continuation of the
the plane perpendicular
in the plane
cross sections of
a time varying
conference on visualization
representation of the
in the flow
of the predictor
that the predictor
the vortex cores
fourier representation of
vortex tubes are
reverse integration from
of cambridge university
s shaped vortex
to the pressure
the polygon count
magnitude of vorticity
vorticity lines in
cross section plane
vortex skeleton is
to locate vortices
the fourier series
reduction and reconstruction
circular cross sections
a hairpin vortex
vortex tube the
a given vortex
reconstructed vortex tubes
note the spiral
vortex tube at
permission of cambridge
the pressure and
shaped vortex head
the average radius
of a hairpin
and the vorticity
along the core
tube s cross
follows the core
to the vorticity
a radius function
vector n k
in free shear
the reconstructed vortex
corrector method is
isosurface of constant
in turbulent channel
three dimensional flow
an integral curve
reprinted with the
the 0 degree
of vortex tubes
0 degree direction
a domain boundary
vortices over a
s cross section
vortex cross section
tubes are not
the vortex skeletons
our predictor corrector
through the flow
gigabytes of storage
visualizing time varying
with the permission
structures in a
whether a point
a predictor corrector
the core the
the flow data
planes perpendicular to
predictor corrector algorithm
the conference on
a point is
of the conference
the computational domain
the permission of
from the seed
l k 1
the cross sectional
the shape of
a scalar field
to the core
over the course
han wei shen
section of a
lines in a
time varying data
of the velocity
on a workstation
in order to
of time steps
point on the
eigenvalues of the
shape of the
tube that ends
tube can be
vortex core is
core can be
finite cross section
corrector scheme provides
rendered on a
machiraju david thompson
time varying volumetric
a three point
represent the vortex
in planes perpendicular
cray seconds in
visualize vortical structures
vorticity is a
the same vortex
of vorticity and
large magnitude of
the radial distance
to identify vortices
tubes from the
grooves follow integral
vortex tubes in
point vorticity lines
vorticity field in
vortex tube that
the skeletal representation
that the vortex
in the vorticity
thick line is
the grooves follow
the vorticity at
zero cross section
new normal vector
vortex cores the
the 3d grid
the local pressure
scale vortices are
low intensity region
to vorticity lines
vortex then the
to visualize vortical
data reduction in
vortex skeletons we
vorticity vector field
predictor corrector skeleton
seed points from

corpus/krapavin2000-test/614304.txt
quaternion
frenet
4d
frame
quaternions
curve
frames
transport
curves
3d
sphere
curvature
streamlines
streamline
torsion
rotations
orientation
knot
0q
fields
vanishing
projected
rotation
ball
smoothly
lighting
field
visualizing
tangent
differential
scalar
eq
visualization
geometry
display
smooth
hanson
color
moving
hyperhemisphere
displayed
torus
euclidean
diametrically
tangents
binormal
eps
rolling
perpendicular
light
surfaces
solid
gammaq
similarities
fig
dt
coordinate
assigning
pathological
interactive
orientations
vanishes
plane
alpern
mensions
0375
66q
thickening
viewer
viewing
numerical
gray
straight
ffl
manifolds
undefined
jump
sign
surface
triad
tubes
ambiguous
illumination
rotate
stream
differentiable
multiplication
interpolation
expose
tandem
bishop
discontinuous
projection
orthogonal
southern
families
lying
volume
sudden
scales
highlighting
plot
piecewise
everywhere
rigid
intrinsic
populated
rendering
displays
polar
densely
angle
manifold
opposite
reciprocal
intrinsically
locally
geometric
volumetric
arc
degrees
segment
integrate
dense
derivatives
derivative
ambiguity
tensor
unit
plots
freedom
vector
inner
interactively
coordinates
angular
equations
slerping
mathematicians
reexpressing
posite
meshview
alterna
177this
equations6
06389
bled
37explicitly
fig1
singles
discontinuously
form66
pseudocol
allax
indeterminable
tubing
fig2
kauffman
antisym
codi
pseudocolored
abstractcurves
pseudocolor
entations
framings
fig3
treatise
shoemake
altmann
hart
perhemisphere
displaces
solomon
theta3
crack
evolve
quantities
displaying
similarity
analog
rendered
normal
continuity
north
flow
andrew
meeting
distinguishing
serret
ponent
8c
invent
ored
7d
ori
heng
hemispheres
6d
gents
lationship
parallel transport
frenet frame
the quaternion
quaternion frame
the frenet
transport frame
three sphere
quaternion frames
frame components
the 4d
four vector
space curves
space curve
quaternion field
the curve
moving frame
quaternion space
curvature and
the parallel
the frame
frame is
frame field
a curve
3d space
the curvature
of quaternion
and torsion
4d light
frenet frames
a quaternion
torus knot
vanishing curvature
frame fields
3 sphere
differential geometry
quaternion frenet
transport frames
unit quaternions
curves that
four space
projected from
euclidean space
of streamlines
scalar fields
0 th
vector field
frame upper
4d lighting
color scales
streamline data
two quaternions
quaternion fields
components showing
smooth quaternion
3d rotations
vector quaternion
4d rotations
vector frame
4d quaternion
in quaternion
0q 0q
scales indicate
a 3d
of curves
a projected
curve s
b selected
rolling ball
in four
curve with
x t
s four
projected image
curve is
the plane
the tangent
frame at
four dimensional
left graph
plane perpendicular
of space
curves in
from 4d
curve x
same quaternion
quaternion representation
of quaternions
3d rotation
4d to
curvature vanishes
eps figure
initial frame
solid ball
by quaternion
moving coordinate
4d normal
sphere plot
quaternion parallel
given curve
quaternion multiplication
each point
perpendicular to
s 3
in fig
upper left
to 3d
frames in
the 3d
coordinate frame
frame or
stream surfaces
frame see
ffl compute
unit quaternion
see e
geometry of
curve the
the 0
frame and
frames on
arc length
a 4d
coordinate frames
with vanishing
non vanishing
th component
frames can
the moving
a frame
curves and
of 3d
components in
path of
q 0
in 3d
dimensional euclidean
frame with
curves with
three space
from four
a numerical
the 3
a unit
scalar product
and surfaces
the three
inner product
similarities and
indicate the
theta 3
eq 6
points on
normal vector
frame for
frames the
independent degrees
initial reference
curve shapes
ball will
space color
selected parallel
curvature we
its quaternion
in 4d
of vanishing
southern hyperhemisphere
3 orthogonal
identical curves
frame coordinates
triad of
defined everywhere
torsion as
4d unit
visualization methods
transport method
ball interface
single curves
orientation frames
lighting formula
with 4d
each 3d
knot b
diametrically opposite
into quaternion
reference orientation
4d projection
5 torus
66q 0q
viewing strategy
pathological curve
space picture
quaternions using
assigning quaternions
orientation control
sphere embedded
curvature on
curves such
quaternions that
assigning smooth
quaternions remain
the frenet frame
the parallel transport
parallel transport frame
the three sphere
the quaternion frame
quaternion frame components
of the quaternion
of space curves
curvature and torsion
in the quaternion
frame components in
parallel transport frames
for a curve
in the three
the 0 th
of the frame
of the curve
differential geometry of
scales indicate the
a curve with
vector frame upper
s four vector
a projected image
projected image of
graph in c
the 3 sphere
0 th component
upper left graph
indicate the 0
left graph in
3d space curve
frenet frame is
color scales indicate
frame components showing
four vector frame
in quaternion space
the curvature and
curve s four
frame upper left
the curve s
the plane perpendicular
in the plane
plane perpendicular to
components in the
of quaternion frames
a unit quaternion
quaternion frenet frames
the curvature vanishes
three sphere plot
four dimensional euclidean
a four vector
a given curve
projected from four
the quaternion frames
in four dimensional
the frame at
the 4d quaternion
curve x t
quaternion frame is
4d normal vector
four vector field
frame see e
the same quaternion
the differential geometry
four vector quaternion
from four space
quaternion parallel transport
from 4d to
see e g
of a 3d
the curve is
on a curve
the frame is
to the sign
in three space
in the 4d
th component of
path of the
frames can be
image of a
in 3d space
dimensional euclidean space
at each point
3 theta 3
of curves and
ffl if the
curves and surfaces
on the curve
the path of
four space color
triad of orthogonal
unit three sphere
transport frame is
quaternions q and
the 4d projection
using the 4d
frames the frenet
the solid ball
properties of space
a 3d 3
transport frame components
normal c the
geometry of curves
parallel transport method
quaternion frame coordinates
curve is locally
q 0 t
on the differential
3d rotations of
torsion scalar fields
b selected frenet
when the curvature
a quaternion field
the 4 vector
frenet frame for
frenet frame field
b selected parallel
knot c the
alpern et al
frenet frames the
the s 2
quaternion frenet frame
5 torus knot
of orthogonal axes
smooth quaternion frame
space curves we
selected frenet frame
knot b selected
from their neighbors
the 4d lighting
theta 3 orthogonal
solid ball will
field that is
curves in three
in the frenet
columns of eq
be displayed as
3d 3 5
moving frame of
non vanishing curvature
the resulting quaternion
independent degrees of
the unit three
for the frenet
as a four
ffl select a
by alpern et
3 5 torus
0q 0q 0375
ball has points
moving coordinate frame
select a numerical
its quaternion frame
of a pathological
dt d x
lighting formula and
a quaternion frame
the moving frame
three sphere projected
components d the
euclidean space picture
numerical approach to
frame field plotted
and then highlighting
rolling ball interface
the entire curve
pathological curve segment
sphere embedded in
frenet frame components
frame components d
space color scales
sphere projected from
d the path
three sphere color
c the quaternion
the fourth dimension
compute a candidate
streamline data set
4d quaternion space
4d to 3d
the normal c
a numerical approach
parallel transport analog
to the frenet
of similar curves
quaternion representation for
families of space
rotate the frame
set of streamlines
of two quaternions
x t dt
curve segment b
frame at x
sphere color scales
and torsion scalar
initial frame or
quaternion multiplication can
vanishing curvature on
frame with its
s 2 surface

corpus/krapavin2000-test/614306.txt
gasp
animation
polyhedron
animations
faces
style
atomic
geometric
pluck
ayellet
programmer
colors
visualization
scene
viewer
debugging
graphics
screen
file
button
poly
vert
tal
mesh
programmers
fade
rotate
geometry
inventor
sweepline
text
animated
video
ascii
fading
fades
cones
naive
vertices
objects
camera
char
polyhedra
dobkin
animate
fig
visual
titles
create
int
advanced
hands
obj
visibility
visualizations
movies
creation
undo
cone
visualized
geometer
buttons
visualizing
minnesota
meshes
thumbwheels
balsa
shneerson
plucking
thumbwheel
heapsort
princeton
panel
editing
heap
window
object
motion
polyhedral
visualize
fonts
snippets
default
segments
float
spheres
floats
accompany
cylinders
writer
fourteenth
plane
push
conceptual
created
units
animating
click
views
minneapolis
creator
document
creating
isolate
script
apart
annual
nmax
geometers
blinks
lpr
polyhe
dron
videotapes
medford
examiner
linearpath
zeus
mainloop
color
files
ease
attach
home
holes
united
anima
xxx
videotape
crossno
weizmann
tango
explanations
users
sweep
maria
windows
quick
triangulation
aspects
library
animator
mathematica
stc
elucidate
traveling
electronic
combinatorial
highlight
students
world
days
backwards
green
hooks
motif
tices
concerned
classroom
documents
dimensional
margins
taste
invaluable
cubes
creates
map
explains
rotation
movie
grasp
watch
unit
configurations
experiment
thirteenth
411
pause
red
facilitates
rectangles
david
primitives
mpeg
annotate
seventeenth
prints
sorting
intersections
remove
interfaces
spin
arrangements
ver
finish
symposium
array
dimensions
yellow
struc
the animation
style file
algorithm animation
animation system
gasp s
atomic unit
the style
the scene
atomic units
the polyhedron
animation is
an animation
a polyhedron
geometric algorithms
ayellet tal
by gasp
naive programmer
the viewer
of gasp
gasp is
advanced programmer
animation and
animation the
computational geometry
dimensional geometric
visibility map
taken apart
vert no
add faces
style files
the screen
geometry p
geometric objects
the algorithm
three dimensional
conceptual model
by fading
advanced programmers
gasp can
visual aspects
the camera
highly complex
two hands
the creation
annual symposium
the colors
process 1
creation of
experiment with
the user
to animate
new faces
text window
the objects
objects and
the advanced
button to
visual debugging
fade in
p dobkin
gasp supports
unit style
animation as
rotate world
control panel
obj to
apart with
after level
david p
create polyhedron
gasp allows
the geometer
logical phase
single pluck
colors of
animation can
on computational
a mesh
process 2
visualization of
the visibility
to create
of geometric
geometric algorithm
animation systems
animation to
by editing
animation for
polyhedron p
an object
of faces
the visual
fading in
combinatorial objects
the text
the faces
of objects
the naive
s environment
world or
level after
for geometric
an electronic
lines points
get polyhedron
ascii data
fades in
gasp in
naive programmers
finish early
with gasp
the gasp
classroom proceedings
ascii style
faces to
and gasp
and titles
the animations
polyhedron fades
algorithm windows
programmer interface
inventor s
enables others
that gasp
unit gasp
end atomic
maria shneerson
push buttons
shneerson ayellet
electronic classroom
snippets of
level starting
name char
script file
thumbwheel for
the code
a tree
and experiment
c code
the programmer
s code
the operations
end users
animation of
to experiment
animation an
animation at
application writer
1998 minneapolis
code includes
this animation
screen we
objects combinatorial
united states
objects that
which belong
the graphics
the heap
our system
that cannot
the visualization
is running
to visualize
to change
algorithm implementation
s library
fourteenth annual
10 1998
polyhedron is
it easily
the what
an ascii
each atomic
the cone
file to
computer graphics
faces of
in three
the application
be created
creator of
knows how
the fourteenth
interact and
mesh can
be animated
line segments
user s
the atomic
aspects of
meshes a
the creator
scene a
use it
a document
text and
file we
an aid
june 07
minnesota united
of the animation
the style file
algorithm animation system
the animation the
the animation is
be taken apart
the advanced programmer
cannot be taken
the naive programmer
computational geometry p
on computational geometry
symposium on computational
animation system for
with two hands
the visibility map
on the screen
annual symposium on
objects that cannot
colors of the
three dimensional geometric
into the scene
the creation of
in the style
david p dobkin
supported by gasp
apart with two
a single pluck
of geometric algorithms
the algorithm animation
with the animation
taken apart with
the visual aspects
style file to
the animation and
dimensional geometric objects
level after level
an animation system
gasp s environment
experiment with the
of the algorithm
of objects and
the text window
aspects of the
and experiment with
the colors of
of computational geometry
visualization of geometric
the code includes
the animation as
for algorithm animation
use it easily
the atomic unit
domain of computational
the animation for
that enables others
the control panel
animation as an
code includes only
objects combinatorial objects
visual aspects of
text and titles
logical phase of
an algorithm animation
snippets of c
knowledge of computer
after level starting
style file is
the algorithm implementation
geometric algorithms can
fade in the
the conceptual model
others to use
each atomic unit
interact and experiment
by fading in
animation is running
an electronic classroom
a mesh can
classroom proceedings of
shneerson ayellet tal
the animation at
enables others to
gasp s library
maria shneerson ayellet
electronic classroom proceedings
that cannot be
to experiment with
of c code
which belong to
to create an
creator of the
07 10 1998
animation the animation
june 07 10
an atomic unit
very helpful in
10 1998 minneapolis
fourteenth annual symposium
system that enables
the application writer
the new faces
1998 minneapolis minnesota
an aid in
the scene a
the animation system
of the faces
of three dimensional
can be created
to use it
the fourteenth annual
and the animation
the animation of
mesh can be
of computer graphics
animation can be
the cross section
proceedings of the
of the objects
be very helpful
possible to create
knows how to
the creator of
of the fourteenth
objects can be
we use the
to do it
be concerned with
as an aid
would like to
minnesota united states
minneapolis minnesota united
domain can be
make up the
the application s
in two dimensions
the end user
the user needs
the way it
the visualization of
in the scene
a tree is
of fig 1
in three dimensions
creation of a
the user s
a single object
to create a
see the animation
small representation of
different animation will
to be visualized
facility for geometric
style file b
the polyhedron p
a geometric object
only manipulations of
medford massachusetts united
two hands using
we click the
p dobkin ayellet
object on a
the what but
user from any
of the animator
the polyhedron fig
it happen on
objects typical objects
system for algorithm
highly complex geometric
the scene by
the heap is
about how graphics
animation system that
is still generated
to observe interact
the reader of
to animate a
the geometer and
no int vertices
line sets point
matter of days
animation will be
use inventor s
single pluck the
like to experiment
animation in the
in a matter
a polyhedron and
each create function
if the style
the initial line
from the scene
assist the geometer
an animation and
lines points line
animation is still
of the gasp
2001 medford massachusetts
nature of geometry
initial line segments

corpus/krapavin2000-test/614325.txt
ijk
1z
ezier
volume
lmn
solids
deformation
tri
abc
energy
uzawa
continuity
olume
solid
dudvdw
primitives
preservation
volumes
deformations
tensor
surfaces
geometric
configuration
surface
variate
primitive
interactive
parametric
animation
tolerances
manipulation
lsq
ijklmnopq
ciarlet88
physics
bernstein
cubic
preserving
derivative
pressure
revolution
ffd
gauss
nurbs
interaction
object
ae
lagrange
minimization
du
nw
determinant
cube
borrel91
hsu92
hydrostatic
duv
brep
modeling
graphics
physical
boundary
derivatives
orders
outer
breathe
bhrigu
respiration
celly
dilorenzo
constraints
multipliers
configurations
tuning
multiplier
endowing
deriva
unconstrained
inner
squares
chiu
zordan
motif
constrained
smooth
displacement
arbor
deform
mechanical
proportions
iterations
fl
convergence
utilizes
workstations
material
michigan
stokes
mouse
deformed
industrial
bill
deformable
tog
jf
triplet
det
ann
curves
manipulated
lagrangian
mathematical
explains
tive
multiresolution
vanishes
coordinates
jacobian
patches
neglected
dist
inside
hyperpatch
welch92
coquillart91
bercovier93
gentaro
renee
kallay93
ijklnmopq
xabc
chadwick89
hujun
celniker91
gib
dilating
1det
griessmair89
gineering
ciples
farouki85
sculpturing
mathematicalrequirements
poport94
fang92
arrow58
liu87
terzopoulos94
selectable
trivariate
ffds
rel94
abstractsome
stefanie
are2
bercovier81
overstepping
moreton92
funck
coons
xinguo
manipu
shears
terzopolus94
son44
basile
geome
rijk
elber
hughes87
jaroslaw
shapiro88
joy91
greiner93
dvw
youlus
barzel88
1jf
theisel
georges
multylinear
opq
naftali
terval
baining
amphora
press88
duw
xiaohan
aumann92
elber94
maheshwari
sederberg86
gamma2
objects
cubes
product
column
cell
notations
ijk ijk
b ezier
control points
free form
control point
1z 1z
z 1z
the volume
1z 1
form solids
volume size
point configuration
volume preservation
continuity constraints
v olume
ezier solid
olume p
linear constraints
tensor product
the uzawa
during interaction
ijk lmn
form solid
geometric modeling
deformation energy
p z
the energy
lmn p
desired volume
point manipulation
tri variate
tri cubic
whose components
ijk and
physics based
the control
basis functions
lmn lmn
ezier basis
preservation algorithm
for tri
the primitives
column vector
non linear
unit cube
product b
volume of
deformation of
volume preserving
problem m
of control
the object
computer animation
the constraints
1 f
energy the
constrained minimization
a tensor
components are
the user
z abc
ezier solids
points configurations
industrial design
x ijk
a tri
of revolution
variate tensor
fully interactive
bernstein polynomial
tri quadratic
point constraints
form objects
each primitive
direct manipulation
the deformation
displacement constraints
energy p
interactive for
point displacement
form deformations
boundary surfaces
a deformation
surface design
or least
object design
uzawa algorithm
of free
primitive and
partial derivatives
constraints and
an object
the determinant
defined by
volume and
the algorithm
minimization problem
finite element
configuration to
physical properties
a desired
the b
p x
the partial
constraints are
linear equations
our case
the lagrange
have z
primitives the
an energy
takes about
the unit
points the
p p
constraints between
volume is
a control
for modeling
denote by
manipulation of
ae 1
solid modeling
v w
the boundary
global computation
deriva tive
practical order
mathematical notations
tuning parameters
variate b
unconstrained min
max problem
v nw
on deformation
constrained deformations
abc where
solid primitive
form volume
x lmn
geometric continuity
derivatives abc
inner problem
object composed
body defined
usual geometric
parameters ae
interactive setting
product solids
p ijk
volume sizes
desired volumes
hydrostatic pressure
i dudvdw
hsu92 the
in borrel91
energy computation
example abc
uzawa based
borrel91 hsu92
ensuring high
than surface
volume constraint
order continuity
j dudvdw
solids while
using gauss
primitive a
modeled from
several tensor
original object
abc p
preserving free
uzawa s
animation industrial
simple constrained
current workstations
proportions between
abc denote
tolerances are
nw linear
2006 victor
local coordinates
dudvdw z
mathematical problem
solid design
iteration limits
d du
write ijk
solid models
order combination
both tolerances
new control
interactive design
ezier volumes
a column
on solid
and ae
the desired
the vector
ijk ijk ijk
z 1z 1z
free form solids
1z 1z 1
control point configuration
the control points
v olume p
1z 1 f
b ezier solid
free form solid
of control points
whose components are
the b ezier
lmn p z
product b ezier
tensor product b
control points the
control point manipulation
a control point
the volume size
olume p p
ezier basis functions
be a column
b ezier basis
volume preservation algorithm
between the primitives
of free form
of the volume
constrained minimization problem
components are the
a tensor product
the partial derivatives
the unit cube
direct manipulation of
u v w
a column vector
volume of each
point displacement constraints
each primitive and
control points configurations
have z 1z
p z abc
the uzawa algorithm
variate tensor product
free form objects
called the lagrange
tri variate tensor
the desired volume
b ezier solids
point configuration to
lmn lmn p
continuity constraints between
uzawa algorithm for
ijk lmn lmn
for non linear
the constraints are
physics based modeling
a b ezier
free form deformations
the boundary surfaces
of linear constraints
column vector of
algorithm requires the
real time for
in our case
algorithm for non
in an interactive
of the solid
on the control
we have z
while preserving the
a bernstein polynomial
control points to
utilizes the uzawa
r is x
use free form
industrial design and
f j dudvdw
in equations such
tuning parameters ae
deformation energy the
hence can be
interactive for tri
for modeling an
of each primitive
surface based models
animation industrial design
unconstrained min max
for tri quadratic
the tri variate
simple constrained deformations
basis functions hence
the primitives the
form objects in
the volume preservation
based on deformation
deformation energy or
usual geometric primitives
ijk ijk and
one control point
dudvdw z 1z
a deformation of
primitive and ensuring
object composed of
derivatives abc abc
of a tensor
1 and ae
rather than surface
high order continuity
inner problem is
f i dudvdw
tri variate b
number of linear
bernstein polynomial of
form solid primitives
resulting in equations
an interactive setting
b ezier volumes
a body defined
one whose components
method for modeling
abc p z
practical order combination
fully interactive for
order continuity constraints
or least squares
all for every
this takes about
the problem m
for tri cubic
the inner problem
than surface based
ensuring high order
x lmn p
min max problem
tolerance of 10
a tri variate
desired volume of
v nw linear
the method utilizes
july 2006 victor
to 10 gamma2
in borrel91 hsu92
iteration limits are
and ensuring high
by z 1z
of several tensor
energy or least
by v olume
p the column
functions hence can
surface of revolution
the mathematical problem
primitives the method
abc abc p
interactive performance in
design and mechanical
every practical order
the original object
minimization problem m
can write ijk
on the orders
paper we integrate
body defined by
method utilizes the
uzawa s method
p whose components
lagrange multiplier for
preservation algorithm requires
for example abc
nw linear equations
for every practical
product solids while
the iteration limits
point configuration that
are the partial
preserving free form
of a bernstein
p of control
computer animation industrial
the desired volumes
configuration to another
the usual geometric
on deformation energy
on current workstations
free form volume
p x ijk
of v olume
during interaction the
of constraints can
an object composed
about 3 seconds
1z 1 and
tensor product solids
endowing the tri
modeling an object
of physics based
primitives defined by
probabilistic point constraints
several tensor product

corpus/krapavin2000-test/614330.txt
isosurface
cells
isovalue
cell
span
kd
visualization
extraction
iso
grids
unstructured
isosurfaces
livnat
intersect
pv
graphics
octree
sweeping
min
simplices
yarden
extrema
triangulation
sweep
nv
volume
parker
marching
hansen
tree
itoh
pointerless
koyamada
pascucci
subtree
max
united
han
bajaj
trees
utah
buckets
grid
count
submited
tetrahedral
intersected
fig
root
search
traversed
charles
johnson
striped
median
francisco
wei
october
cubes
rendering
mode
salt
triangle
intersects
lake
vertices
brain
torso
geometry
san
skip
structured
fem
wilhelms
fd
near
decomposition
gelder
scanned
sub
array
california
visualizing
mri
valerio
schikore
chandrajit
interactive
chiang
delta
jen
geometric
shen
contour
intervals
active
trim
snoeyink
cludio
heart
ray
traverse
carolina
octrees
city
polygon
vis
tracing
subgroup
spans
bucket
surface
peter
lie
searches
coordinate
seed
noise
scalar
lutz
lists
rumpf
ohlberger
encompassed
61091
pike
doted
multidimentional
2048383
painter
10713
shirley
worst
jack
128
preprocess
scientific
yi
steven
horizontal
head
fields
north
7th
locate
recursively
neighborhood
purged
koji
takayuki
isocontouring
safari
kettner
marks
routine
mario
coherence
2001
siggraph
silva
field
scans
accelerated
hans
1996
yamaguchi
v4
subranges
puppo
rossignac
sutton
thinning
jarek
bentley
node
116
3d
pseudo
multiresolution
perspective
park
nano
quicksort
ertl
457
haimes
flag
98
depicts
eq
milliseconds
degenerate
cpu
97
489
yasushi
montani
sloan
scopigno
criterion
the isosurface
isosurface extraction
kd tree
span space
the span
cells that
iso value
the cells
on visualization
the kd
active list
of cells
unstructured grids
intersect the
count mode
search max
sub tree
data set
the isovalue
min iso
search min
value root
that intersect
computer graphics
o n
isovalue is
sweeping simplices
visualization and
optimal isosurface
max min
space decomposition
sweep list
data sets
the min
extraction algorithm
an isosurface
the cell
maximum values
yarden livnat
right sub
the iso
kd trees
han wei
the active
near optimal
the count
an isovalue
a kd
geometric space
the search
cells in
graphics v
united states
value space
minimum and
of o
structured grids
the conference
sub trees
array size
the sweeping
each cell
the sweep
marching cubes
the marching
the octree
ff october
near search
v node
isovalue v
johnson a
isosurface we
isosurface intersects
min pv
pv v
wei and
pointerless kd
root left
construct polygon
livnat han
francisco california
log n
the tree
volume visualization
and computer
min and
that lie
list is
complexity of
isosurface and
tree as
isosurface the
polygon s
s minimum
fast triangulation
s cell
proceedings of
worst case
san francisco
and maximum
cell is
a cell
charles hansen
1996 san
neighborhood search
isosurface can
the algorithm
the data
and johnson
for unstructured
minimum value
the median
new isovalue
fd 128
graphics submited
extrema graphs
skip node
isosurface as
and gelder
cell set
build array
intersect an
structured grid
min list
a pointerless
29 1996
isosurface generation
root s
volume data
the points
california united
conference on
min max
a near
october 18
large data
cell s
wilhelms and
isovalue the
l bajaj
given isovalue
varying fields
span filter
those cells
salt lake
lake city
memory requirement
october 28
ray tracing
the extrema
underlying domain
of isosurface
node s
search over
less then
yi jen
minimum values
extraction proceedings
wei shen
jen chiang
cell search
a worst
n log
two sub
algorithm using
isosurface inside
simplices algorithm
search skip
average isosurface
and koyamada
new isosurface
min coordinate
isosurface will
the striped
fem u
cubes method
previous isovalue
lie above
itoh and
right search
steven parker
left else
left sub
striped area
one subtree
noise algorithm
max coordinate
max iso
node right
u grid
value skip
seed cell
skip min
search phase
root right
optimized search
28 29
maximum value
a complexity
o k
the span space
cells that intersect
the cells that
the kd tree
the active list
conference on visualization
intersect the isosurface
iso value root
the count mode
min iso value
using the span
number of cells
search max min
optimal isosurface extraction
isosurface extraction algorithm
visualization and computer
on visualization and
transactions on visualization
and computer graphics
and maximum values
near optimal isosurface
the iso value
right sub tree
that intersect the
of cells that
computer graphics v
the conference on
proceedings of the
of the conference
of o n
the right sub
the sweeping simplices
the isovalue is
the sweep list
extraction algorithm using
complexity of o
minimum and maximum
the data set
francisco california united
of the cells
a kd tree
cells that lie
set of cells
san francisco california
of the isosurface
johnson a near
kd tree as
pointerless kd tree
wei and johnson
the isosurface we
livnat han wei
pv v node
han wei and
construct polygon s
and johnson a
28 29 1996
1996 san francisco
29 1996 san
algorithm using the
cells in the
all the cells
for unstructured grids
the marching cubes
a near optimal
california united states
in the isovalue
s cell search
near search max
the geometric space
iso value is
active list the
polygon s from
of the kd
that intersect an
a pointerless kd
active list is
computer graphics submited
max min iso
wilhelms and gelder
intersect an isosurface
over the span
value root left
max min pv
min pv v
the minimum and
o n log
october 28 29
the cell s
size of the
a complexity of
n log n
two sub trees
ff october 28
kd tree is
time varying fields
of the data
o n in
salt lake city
the memory requirement
ieee transactions on
the cells in
isosurface extraction proceedings
structured and unstructured
the isosurface and
by the isosurface
a worst case
han wei shen
extraction proceedings of
yi jen chiang
in the sweep
the size of
complexity of the
of o k
value root right
the new isosurface
search min iso
itoh and koyamada
s minimum and
span space a
list is then
geometric space g
a fast triangulation
search min max
a seed cell
complexity of only
left sub tree
the min list
search skip min
kd tree construction
the left sub
iso value skip
underlying domain we
the isosurface intersects
the isosurface will
of the span
from root s
the search phase
root s cell
the min coordinate
array size criterion
max iso value
sweeping simplices algorithm
line at v
isosurface extraction methods
value skip node
skip min iso
fem u grid
the extrema graph
over unstructured grids
the given isovalue
s from root
marching cubes method
isosurface are those
for the cells
node s minimum
build array size
and minimum values
the value space
the previous isovalue
need to traverse
the isosurface inside
the new isovalue
large data sets
cells that are
maximum and minimum
case complexity of
the points in
of the tree
2000 salt lake
lake city utah
city utah united
the worst case
research triangle park
23 1998 research
18 23 1998
on visualization 98
october 18 23
triangle park north
1998 research triangle
visualization 98 p
park north carolina
utah united states
north carolina united
only o n
out of core
carolina united states
of only o
bajaj valerio pascucci
to intersect the
the 7th conference
isosurface extraction in
on visualization 96
the isosurface extraction
interactive ray tracing
value is greater
for the count
of the octree
isosurface extraction is
o n while
and unstructured grids

corpus/krapavin2000-test/614335.txt
streak
particle
tetrahedron
unsteady
velocity
particles
tetrahedral
cell
tracing
visualization
interpolation
flows
grid
interactive
tapered
injectors
flow
rake
grids
curvilinear
tetrahedra
coordinates
windtunnel
advection
physical
cylinder
cfd
fig
runge
vortex
kutta
fluid
interpolations
dt
hexahedral
processors
zone
wing
cells
location
odd
lines
raphson
gigabytes
integration
visualize
shedding
interactively
decompositions
frames
numerical
frame
stream
traces
trilinear
interpolated
numbering
newton
megabytes
face
steady
injecting
crossed
field
levit
darmofal
buning
adjoining
bulirsch
lucy
novoselov
violator
pao
virtual
rates
rendered
falko
bryson
stoer
onyx
advections
haptic
kuester
bruckschen
velocities
injection
doubling
christopher
joy
advected
hamann
graphics
decomposition
haimes
airfoil
sgi
jacobian
determinant
dale
oscillating
nasa
bernd
temporal
halved
ralph
fields
sec
simulations
simulation
batch
kenneth
motion
spatial
roman
angle
tolerance
tables
visualized
interpolating
lawrence
locate
configuration
dependent
sought
inverted
abstractstreak
smoke
22k
terrill
peskin
creon
sungho
judith
recirculation
jespersen
128th
subsetting
scrutiny
12961
albertelli
clump
polina
tunnels
rudiger
sadarjoen
1001030number
m_fork
bashforth
75mhz
kruger
karman
752x
hultquist
aeronautical
understeer
synergistic
kipfer
renderframes
hagedorn
kelso
kondratieva
131k
satterfield
displacement
solvers
accuracy
released
probe
adaptation
nearby
conventions
tests
render
conditional
moving
4th
continuity
advance
transformed
commensurate
remapped
streaklines
sikorski
barycentric
surrounds
crawfis
filament
2834
plot3d
3x3
r8000
tracers
bends
weaving
chaderjian
malaterre
14k
core
delta
hundreds
streak lines
particle tracing
point location
natural coordinates
the particle
the velocity
unsteady flows
a particle
same cell
velocity interpolation
of streak
physical space
time steps
cell same
of particles
step size
the streak
tapered cylinder
unsteady flow
computational space
the tetrahedral
2 tetrahedron
tetrahedral method
the tapered
visualization of
frame rates
odd and
the tetrahedron
three processors
stream lines
h z
lines and
time dependent
x h
particle traces
in unsteady
an unsteady
unsteady particle
streak line
particle path
tetrahedron 5
1 tetrahedron
4 tetrahedron
path lines
tetrahedron 4
3 tetrahedron
tetrahedron 2
virtual windtunnel
tetrahedron 3
tetrahedron 1
x z
tetrahedral decomposition
velocity field
the cell
up tables
the flow
curvilinear grids
tracing algorithm
simulation time
the grid
important flow
physical coordinates
lines could
even tetrahedral
tracing algorithms
kutta scheme
and rendered
tetrahedral decompositions
time lines
cell search
time step
the natural
z x
runge kutta
data set
look up
particle s
hexahedral cell
be interpolated
steady flows
data sets
and velocity
grid and
delta wing
multi zone
particles in
z 0
to visualize
the interactive
numerical integration
and visualization
interactive streak
spatial interpolation
path line
the rake
location technique
temporal interpolation
a odd
line generated
flow simulations
particle would
zone data
step doubling
space tracing
line injectors
have crossed
test tetrahedron
lines path
crossed the
particles sec
lines streak
advection rate
on visualization
newton raphson
for interactive
frames per
location and
a a
y z
the step
computed and
tetrahedron that
tracing in
vortex shedding
sec on
curvilinear grid
interactive frame
interactive performance
velocity vector
non dimensional
rendered at
large unsteady
10 frames
coordinates at
particle advection
the virtual
per second
the odd
in fig
interpolation function
b even
tetrahedron is
linear basis
one two
dependent particle
flow features
raphson method
5 z
t l
finite element
velocity at
jacobian matrices
in steady
conditional test
of particle
the newton
t dt
lines are
error tolerance
at discrete
a cell
vector field
interpolation is
equation 4
current position
time t
bounding tetrahedron
interactive computation
roman y
studying unsteady
100 simulation
space particle
fraction d
continuity between
current tetrahedron
visual haptic
this unsteady
a lawrence
size adaptation
which tetrahedron
44 streak
0 same
y pao
lines on
numbering convention
buning 15
actual motion
numbering conventions
tracing was
tetrahedral elements
interpolated in
by interactively
lucy y
batch computations
and streak
space schemes
of injectors
size dt
bulirsch stoer
by darmofal
the natural coordinates
of streak lines
same cell same
cell same cell
x h z
x z x
a a a
streak lines and
the tetrahedral method
z x z
the tapered cylinder
in unsteady flows
the streak lines
3 tetrahedron 4
tetrahedron 3 tetrahedron
1 tetrahedron 2
the virtual windtunnel
2 tetrahedron 3
tetrahedron 4 tetrahedron
4 tetrahedron 5
tetrahedron 1 tetrahedron
number of streak
tetrahedron 2 tetrahedron
look up tables
an unsteady flow
in an unsteady
particle tracing algorithms
the cell search
the point location
streak lines could
lines could be
runge kutta scheme
simulation time steps
particle tracing algorithm
computed and rendered
even tetrahedral decompositions
number of particles
the particle s
the velocity field
step size is
point location and
be computed and
odd and even
could be computed
location and velocity
tetrahedron 5 z
a point location
particles sec on
odd and b
and velocity interpolation
test tetrahedron 1
particle would have
to be interpolated
multi zone data
would have crossed
in steady flows
conditional test tetrahedron
and b even
natural coordinates x
have crossed the
zone data sets
line generated by
is the particle
lines and time
a odd and
of the tetrahedron
coordinates x h
the particle would
the physical coordinates
lines streak lines
the velocity vector
unsteady particle tracing
and time lines
point location technique
interactive streak lines
and three processors
the odd and
the a odd
1 x h
streak line injectors
and rendered at
the step size
frames per second
and visualization of
dependent particle tracing
on three processors
one two and
h z 0
for point location
interactive frame rates
linear basis function
taken to compute
of particles in
newton raphson method
time steps and
the newton raphson
time dependent particle
to compute and
x y z
in the flow
visualization of large
two and three
of time steps
the current position
this data set
time taken to
lucy y pao
the grid to
fraction d is
flows numerical simulation
simulation of flow
expensive for interactive
the current tetrahedron
computation and visualization
important flow features
generated by tracing
darmofal and haimes
the numerical integration
a particle moves
computational space to
tetrahedral method in
particle tracing in
had 100 simulation
the conventional algorithm
the flow over
space to make
particle advection rate
streak lines the
space particle tracing
and streak lines
at 10 frames
interpolation is performed
physical space tracing
by darmofal and
flows the velocity
velocity field to
an sgi onyx
field or until
0 the particle
into physical memory
the bounding tetrahedron
physical space particle
on one two
dale a lawrence
the streak line
the curvilinear grid
location at time
100 simulation time
computational coordinates are
to section iv
capture these features
particle traces are
b tetrahedral decomposition
flow field or
changes in time
christopher d lee
the step doubling
0 same cell
the vortex shedding
interactive computation and
when the sum
5 z 1
the cell being
linear interpolation function
unsteady particle traces
tapered cylinder and
streak lines are
continuity between cells
roman y novoselov
particle tracing was
tetrahedral decomposition a
steps of data
0 or z
the interactive tests
the interactive performance
by buning 15
needed to identify
being sought is
x z tetrahedron
streak lines on
time fraction d
time t d
evaluated directly from
actual motion of
or z 0
the worst violator
be interpolated in
grid and velocity
grid and solution
with the tetrahedral
the particle advection
particles in the
stream lines path
a particle path
z 0 same
streak lines were
step size was
tapered cylinder data
tracing in computational
a hexahedral cell

corpus/krapavin2000-test/614347.txt
terrain
ray
voxel
voxels
footprint
pvs
rendering
rays
byc
pixel
traversal
photo
flythrough
image
sticks
stick
hit
frame
camera
visualization
height
pitch
casting
flight
images
resolution
emanating
photograph
3d
photographs
pixels
color
tiles
graphics
flying
aerial
accelerated
viewing
texture
terrains
prp
resolutions
processor
realistic
cavities
frames
textured
pyramid
multiresolution
sgi
scud
kilometers
maxvideo
parris
subvoxel
hippi
egbert
arie
loaded
vertical
column
gigabytes
rasterization
undersampling
meter
ntsc
cards
coherence
eye
colors
ibm
sky
extrapolated
mapped
interpolation
visual
sculpting
horizon
scsi
sampled
master
bytes
card
secondary
tracing
warp
kaufman
toy
supersampling
voxelized
oversampled
15hz
fps
huamin
double
rate
challenge
trajectories
warping
vital
roll
pipeline
sampling
incrementally
emanate
busses
100mb
t62
pool
workstation
mbytes
plane
textures
angles
background
meters
ware
tank
cline
hardware
transparent
sec
impression
pyramidal
realism
coordinates
scenes
colored
speed
cast
margins
slave
elevation
australasia
r4400
qu
hierarchical
hierarchy
objects
generation
processors
semaphore
video
viewpoint
field
disk
interactive
625
speeds
projection
innovative
cpus
memory
array
portability
grid
angle
load
smooth
east
discrete
database
ethernet
flat
united
asia
columns
simulator
heights
emphasized
bandwidth
aliasing
cohen
carolina
vertically
post
vast
fields
transparency
controllers
6000
square
map
projecting
header
internally
2n
shared
architecture
insignificant
wan
polygonal
grey
postprocessor
stephenson
pellacini
jiafa
kadosh
tiltan
shibolet
the terrain
the pvs
the ray
the image
photo realistic
voxel based
the rendering
x byc
the voxels
rendering algorithm
the voxel
real time
generation rate
ray q
frame generation
image footprint
a voxel
terrain is
the rays
visual flythrough
hit point
ray casting
ray coherence
the frame
on visualization
the camera
multiresolution traversal
realistic images
the stick
terrain model
emanating from
traversal the
of ray
terrain the
three photographs
the pixel
accelerated by
hierarchical traversal
pitch angle
flight simulation
power visualization
a hit
based objects
post rendering
sampled and
rendering processor
pvs is
the viewing
time performance
q x
parallel machine
the 3d
a ray
3d objects
ibm power
the footprint
images generated
mapped back
ray are
camera position
visualization system
image is
computer graphics
the hit
shared memory
the sky
disk array
rays emanating
global terrain
previous hit
the pitch
square kilometers
tiles that
column footprint
geometric pipeline
the subvoxel
footprint are
terrain at
height field
sticks which
frame footprint
target area
the maxvideo
cast from
traversal 5
flying trajectories
pixel footprint
time photo
discrete ray
meter resolution
memory architecture
traversal is
in real
one column
be loaded
the master
ray tracing
the frames
next frame
by ray
the prp
viewing parameters
coherence and
flight simulator
height x
photographs of
voxel space
double step
power challenge
step size
the height
speed up
semi transparent
ray emanating
global memory
of voxels
ray i
pyramid is
rays are
the traversal
rendering of
main memory
the images
below it
graphics v
and multiresolution
the tiles
viewing direction
colors of
lower resolution
a discrete
generated by
visualization and
image pixels
the eye
a height
the ibm
a rate
was designed
the column
location of
image space
and mapped
sampling rate
the background
the sampling
rate of
field of
q j
of up
of steps
q y
the pool
see figure
per second
z q
the object
height of
realistic impression
voxels representing
control stick
who built
kilometers of
sign q
desired real
sticks a
terrain color
cards each
voxel the
pvs was
realistic visual
target areas
secondary rays
ray traverses
to voxel
the flying
image column
realistic rendering
soft transition
those rays
the voxelized
voxel is
background voxels
pixel if
k egbert
voxels are
real frame
david cline
memory cards
voxels since
rasterization hardware
hit between
vertical grid
secondary ray
terrain voxels
down traversal
footprint is
2n equations
pixels back
flat traversal
the frame generation
frame generation rate
the image footprint
the rendering algorithm
of the terrain
over the terrain
the terrain is
by the pvs
of the image
a voxel based
the terrain the
real time performance
in real time
field of view
multiresolution traversal the
of the ray
the hit point
ray q j
photo realistic images
voxel based objects
images generated by
power visualization system
q j 1
ibm power visualization
the ibm power
post rendering processor
of the column
along the ray
shared memory architecture
conference on visualization
the global terrain
the voxel space
ray coherence and
real time photo
three photographs of
discrete ray casting
the terrain model
height x byc
double step size
the power challenge
the tiles that
coherence and multiresolution
of ray q
by ray coherence
mapped back to
the rays emanating
terrain is a
sampled and mapped
the 3d objects
up the rendering
the pvs is
the column footprint
the terrain at
accelerated by ray
photographs of a
time photo realistic
rays emanating from
be the location
and multiresolution traversal
to the height
the disk array
the next frame
the viewing parameters
the ray are
number of steps
the image is
generated by the
visualization and computer
the main memory
computer graphics v
and computer graphics
on visualization and
transactions on visualization
the image space
switch to a
emanating from the
of up to
location of the
from the bottom
the height of
the location of
algorithm is based
a rate of
in the image
the conference on
from the viewpoint
of the conference
based on a
at a rate
the sky is
three different viewing
cline parris k
hierarchical traversal 5
by the rays
z q x
consists of up
x incrementally update
cast from a
are created at
the pvs are
an innovative rendering
kilometers of 0
z height x
along the major
sign q x
different viewing directions
the frame footprint
the rendering but
to voxel ratio
tiles that are
the major axes
flying trajectories are
using ray coherence
a hierarchical traversal
global terrain is
pitch angle is
to the terrain
color at x
achieve real time
a photo realistic
innovative rendering algorithm
viewing direction the
david cline parris
purpose parallel architecture
terrain at a
powerful parallel machine
of the pvs
the vertical grid
hit the terrain
of ray i
of 10 15hz
the flying trajectories
the terrain color
realistic images in
rendering algorithm the
binary pyramid is
since the terrain
on the terrain
challenge with a
footprint over the
the steps are
incrementally update the
via an hippi
the ray q
bytes in total
who built the
loaded on the
the pixel footprint
occur at an
background pixels back
top down traversal
pixel to voxel
rendering algorithm is
generation rate is
of a toy
of data resolutions
for a hit
the post rendering
the texture mapping
image such as
a double step
between the ray
and mapped back
memory consists of
the previous hit
a discrete ray
the non background
integer coordinates of
hit between the
terrain the terrain
voxel space resolution
sticks which are
by the prp
to the voxel
parris k egbert
q x incrementally
hit point of
the pitch angle
real time rates
a soft transition
to an innovative
3d objects are
to the pool
desired real time
and its orientation
voxels since the
two seconds on
rendering but also
photo realistic visual
square kilometers of
from these images
the pixel to
that the terrain
the terrain database
from a distance
the desired real
and the colors
x byc and
a height field
the rasterization hardware

corpus/krapavin2000-test/614361.txt
animation
implicit
deformations
skeletons
contact
deformable
surfaces
collision
skeleton
surface
volume
blending
interpenetration
forces
elastic
substances
collisions
sti
layer
substance
soft
deformation
animating
field
fusion
particles
bodies
inelastic
motion
ness
articulated
friction
blend
territories
elasticity
particle
isosurface
rigid
radial
flesh
coated
solids
characters
compression
layered
separation
colliding
erent
graphics
preservation
unwanted
bryan
propagation
physically
object
brien
deformed
character
force
modeling
fluids
animations
di
skin
sampling
sample
animated
coating
goktekin
intercollisions
tolga
klingner
response
variations
mass
detection
siggraph
volumes
gradient
contributions
clay
transverse
deforming
meshes
contacts
displacement
cani
paule
disconnected
smooth
region
feldman
deforms
tog
objects
visualization
reaction
shapes
cient
detected
fig
damping
ji
solid
interactive
fluid
locally
pieces
marie
influence
fiction
coats
alexis
grabbed
bargteil
lennard
skele
angelidis
pliers
haptics
compactness
shape
a0
contributing
slope
frames
breathe
detailing
respiration
dilorenzo
celly
bara
bhrigu
alteration
floaters
lobb
repulsion
melt
interpenetrations
territory
nixon
boxes
james
depicted
animator
kitchen
inertia
eurographics
behaviors
convincing
chiu
voxels
attraction
zordan
controlled
controlling
flexible
opposite
displayed
pentland
isovalue
thickness
sudden
ects
precise
geometric
infinitesimal
nodal
ent
collide
sectional
defining
massachusetts
controller
boston
fields
inside
material
piecewise
adam
undergo
exacerbated
grenoble
ers
coherence
dynamics
68
3d
jing
qin
attenuation
rendering
correspondence
jones
zone
spheres
hua
particularly
simplified
falling
implicit layer
the implicit
implicit surfaces
the animation
collision detection
implicit surface
base structure
sti ness
contact surface
sample points
field function
animation of
exact contact
field functions
contact surfaces
the field
volume variations
interpenetration region
field contributions
the interpenetration
deformable models
applied forces
contact modeling
response forces
with implicit
physically based
particle system
s gradient
the blending
volume preservation
and deformations
blending graph
local volume
skeleton territories
soft substances
constant volume
unwanted blending
point skeletons
of implicit
each skeleton
and fusion
separation and
the surface
the object
the isosurface
an animation
di erent
of influence
of soft
implicit object
soft substance
james f
collision processing
coated with
forces and
soft inelastic
the deformation
the volume
of skeletons
relative motion
skeleton s
motion of
surfaces for
an implicit
deformations and
smooth surface
a collision
of volume
made of
elastic behavior
articulated skeletons
linear elasticity
deformable bodies
separation or
between applied
processing collisions
volume during
implicit formulation
inelastic substances
controlled blending
field term
skeletons coated
deformation field
characters made
the contact
character animation
o brien
for animating
a deformable
time step
point p
the skeletons
of articulated
volume of
a smooth
forces are
skeletons that
deformable objects
forces that
s i
the base
computer animation
f o
of deformable
collisions with
collision is
section iii
the propagation
for animation
skeletons and
field s
an articulated
surfaces a
of animation
local coordinate
acm siggraph
bryan m
changes such
colliding bodies
m klingner
model contact
implicit flesh
four frames
compression field
bryan e
volume variation
surface around
tolga g
erent skeletons
transverse propagation
cient collision
friction forces
blending list
during deformations
surfaces between
field terms
simplified characters
under compression
force r
fusion threshold
k a0
a0 w
as separation
animation step
along contact
local volumes
propagation region
substances capable
between colliding
precise contact
surface between
volume control
e feldman
or fusion
g goktekin
articulated structure
modeling soft
computer graphics
f p
iii d
animation and
deformations of
f i
a particle
of sample
a skeleton
models v
each object
other object
a layered
of separation
adaptive sampling
purely geometric
for collision
animation where
p ji
blend together
computed between
flesh and
particles are
and damping
skeleton this
collisions between
of skeleton
to collisions
contact between
for instance
non linear
other objects
control of
object s
a rigid
graphical models
using implicit
volume v
layered construction
the deformable
the unwanted
deformable model
the substance
the implicit layer
the implicit surface
the base structure
of the implicit
the animation of
separation and fusion
of implicit surfaces
the field function
the interpenetration region
with implicit surfaces
f o brien
implicit surfaces for
exact contact surfaces
in the interpenetration
james f o
relative motion of
the relative motion
a smooth surface
in the propagation
the field s
implicit surfaces a
field s gradient
articulated skeletons coated
characters made of
the contact surface
soft inelastic substances
of articulated skeletons
skeletons coated with
between applied forces
correspondence between applied
physically based model
made of articulated
applied forces and
of sample points
a particle system
collision detection and
the other object
of each object
next time step
first introduced in
set of sample
section iii d
the volume of
a collision is
a skeleton s
of soft substance
during the animation
when a collision
skeleton s i
substances capable of
local volume v
volume v i
inelastic substances capable
the deformation field
the implicit object
used for collision
with the implicit
the field contributions
with implicit flesh
k a0 w
of separation and
field function f
modeling soft inelastic
changes such as
the blending graph
coated with implicit
smooth surface around
tolga g goktekin
contact surface between
along contact surfaces
contact surfaces between
such as separation
the implicit formulation
precise contact modeling
a k a0
on the implicit
separation or fusion
cient collision detection
forces and deformations
using implicit surfaces
e cient collision
during an animation
the unwanted blending
an articulated structure
bryan e feldman
interpenetration region and
bryan m klingner
to each skeleton
radius of influence
a layered construction
of point skeletons
capable of separation
for modeling soft
between colliding bodies
surfaces between colliding
di erent skeletons
be used for
graphical models v
equations of motion
detection and response
with other objects
an implicit surface
as depicted in
the next time
transactions on graphics
graphics tog v
on graphics tog
of the animation
for the implicit
contributing to the
of the skeletons
marie paule cani
depicted in figure
at the next
sample points on
and non linear
of the object
by the base
the normal vector
as the sum
the equations of
in section iii
motion of the
s i s
order to generate
of the field
a point p
skeletons s i
controlling the volume
collisions between pairs
hong qin haptics
implicit layer and
generate exact contact
a local volume
the compactness and
second builds on
of response forces
generated by skeletons
1 structure used
by locally deforming
richard lobb a
by pliers and
soft object model
i giving the
may separate into
of simple characters
to the deformed
animation of simple
models using implicit
75 july 2002
way of modeling
brien bryan m
particularly well adapted
between skeleton territories
motion and deformations
lennard jones forces
as lennard jones
a0 w x
k f p
as emphasized in
e feldman james
fluid based soft
jing hua hong
animating soft substances
decreasing functions of
displacement of p
volume would be
force along the
the skeletons and
for implicit surfaces
j s gradient
local sti ness
the animation kitchen
lobb a fluid
exact contact modeling
all the field
such as lennard
than simulating deformations
a rigid solid
moves and deforms
opposite of the
deformations generated by
the speed vector
contact with other
animation kitchen fiction
of deformable objects
paragraphs explain how
instance a rigid
object model ieee
into several components
fusion under compression
local volume variations
precise collision detection
processing collisions between
inside outside function
away by pliers
topological changes such
non linear elasticity
and radius of
during animations the

corpus/krapavin2000-test/614370.txt
sweep
rendering
scanline
ray
casting
aedge
slice
grids
cells
plane
lsrc
vertices
mesh
giertsen
irregular
blunt
fin
status
volume
dataset
yagel
cell
rays
facets
visualization
datasets
vertex
event
grid
sorting
pixel
oxygen
segment
tetrahedra
3dheap
curvilinear
liquid
unstructured
queue
leftward
swept
segments
slices
convex
coherence
boundary
wing
chamber
edges
meshes
3d
incident
combustion
viewing
axis
hits
insertions
sorted
300
tetrahedral
sweeping
graphics
scanlines
disconnected
kaufman
513
2d
pixels
subdivision
active
22mb
2dheap
silva
tetrahedron
image
intersections
voxels
post
polyhedron
intersected
pointers
rendered
lazy
visibility
theta
480
375
coordinate
deletions
coordinates
depth
facet
lighting
critical
connectivity
395
nonconvex
8mb
ordering
resolution
milliseconds
187
firstcell
21mb
garrity
hertel
priority
seconds
polyhedra
shooting
complexes
shading
polygons
preprocessing
edge
projection
events
polyhedral
crossed
mehlhorn
acl
presorted
sweeps
sort
seed
screen
900
topmost
polygonal
planes
endpoint
675
bottommost
topological
slicing
render
ertl
degeneracies
farias
cludio
williams
intersects
thereby
handling
mitchell
storage
hardware
arie
bucketing
005
field
faces
worst
600
scalar
endpoints
19s
57mb
37s
7mb
64s
2dsweep
22s
tetrahedralized
uselton
lichan
ram
spent
salt
encounters
linked
lake
230
maintaining
scratch
handles
consumption
ricardo
36
format
stabbing
splatting
9mb
503
plot3d
681
wedges
regular
intersecting
dot
buffer
spatial
doubly
utah
volumetric
bottom
geometry
47
ma
reading
the sweep
sweep plane
ray casting
sweep line
irregular grids
line status
the mesh
3 space
3d sweep
a sweep
volume rendering
critical vertices
blunt fin
active edge
the aedge
event queue
the rendering
the slice
sweep status
2d sweep
active edges
the cells
a scanline
aedge list
status structure
the event
o n
mesh s
sweep ray
liquid oxygen
oxygen post
300 theta
depth ordering
rendering times
regular grid
rendering of
a ray
the viewing
rendering time
event points
plane hits
lazy sweep
leftward segments
event handling
the blunt
data structure
z axis
of cells
boundary vertices
sweep of
vertices of
the ray
for rendering
sweep algorithm
the z
sweep in
513 375
2 rays
sweep we
yagel et
rendering irregular
theta 300
cells of
each ray
direct volume
along each
casting algorithm
visibility ordering
handling time
the sorted
in 36
curvilinear grids
image size
post 513
each scanline
status data
giertsen s
187 395
viewing plane
subdivision s
combustion chamber
the datasets
of s
the 3d
incident on
the image
time o
use set
of irregular
cells are
y coordinates
priority queue
log n
worst case
of ray
unstructured grids
tetrahedral cells
the vertices
topological information
the 2d
the boundary
y coordinate
the lazy
the dataset
vertices and
graphics hardware
our method
data structures
of curvilinear
projection methods
on visualization
per pixel
vertex of
segments incident
the scanline
bottom segment
other ray
current scanline
disconnected grids
s 300
aedge and
irregular grid
event point
lsrc algorithm
sweep the
giertsen 15
current sweep
fin 187
per scanline
viewing coordinate
segment objects
scanline and
each slice
n a
list of
a regular
our implementation
plane with
of active
y axis
segment data
milliseconds per
cell complexes
the rays
slice we
sorting them
the grid
along the
intersections of
sorted order
volume visualization
the active
of vertices
connected components
and sorting
the subdivision
rays that
ray shooting
grids is
delta wing
of voxels
cells in
a mesh
the y
cost per
point p
boundary of
intersected by
a polyhedron
rendering for
connectivity information
crossed by
grid of
to sort
z i
sorted list
n log
lower bound
t silva
vertices that
in aedge
and mehlhorn
he reports
topmost vertex
hertel and
full pixels
z plane
lsrc is
wing combustion
slice to
integration time
mehlhorn 16
dimensional ray
casting problem
swept over
we sweep
edge list
theta 200
convex cells
this sweep
the sweep plane
the sweep line
sweep line status
of the mesh
the event queue
the 3d sweep
the aedge list
sweep ray casting
by the sweep
liquid oxygen post
of the cells
line status structure
lazy sweep ray
of active edges
the 2d sweep
the blunt fin
the sweep status
a sweep plane
when the sweep
along each ray
sweep plane hits
the z axis
of the sweep
in 3 space
rendering irregular grids
300 theta 300
yagel et al
n 2 rays
the lazy sweep
event handling time
an active edge
vertex of c
the event handling
a regular grid
of irregular grids
ray casting algorithm
direct volume rendering
the critical vertices
sweep of 3
of 3 space
post 513 375
to the sweep
status data structure
time o n
of ray casting
sorted order of
volume rendering of
cells of the
vertices of s
along the z
as the sweep
of the rendering
to the viewing
in the slice
the ray casting
with the sweep
sweep status data
regular grid of
sweep plane the
complexity of ray
the current sweep
segments incident on
grid of voxels
the sweep of
stop the sweep
fin 187 395
of curvilinear grids
the mesh s
number of connected
blunt fin 187
the viewing plane
the viewing coordinate
s 300 theta
algorithm for rendering
for rendering irregular
other ray casting
the cost per
vertices of the
the sorted order
parallel to the
n log n
of the slice
the boundary of
in the mesh
of the vertices
s n a
a cross section
coherence in the
boundary of the
on the boundary
list of the
of connected components
of unstructured grids
pointers to its
rendering of unstructured
conference on visualization
the worst case
sorted list of
of our method
y coordinates of
ray casting for
irregular grids is
the liquid oxygen
a mesh s
exploit spatial coherence
a depth ordering
blunt fin liquid
the current slice
are for results
the subdivision s
a sweep line
the current scanline
2d sweep we
event point p
their y coordinates
active edge list
and then maintaining
the rendering times
and mehlhorn 16
oxygen post delta
1 005 675
0 0 z
cells of s
of critical vertices
sweep plane encounters
through the mesh
transformation and sorting
lsrc post 513
the image resolution
use set of
critical vertices this
within each slice
the segment data
leftward segments incident
no leftward segments
the topmost vertex
fin liquid oxygen
sweeping 3 space
3d sweep in
delta wing combustion
the rendering time
viewing coordinate system
ray casting problem
volume rendering for
x z plane
the y coordinates
the use set
two dimensional ray
along a ray
of the scanline
hertel and mehlhorn
o n vertices
removed from aedge
wing combustion chamber
a single common
post delta wing
is swept across
rendering of irregular
critical vertices and
incident on p
dimensional ray casting
in the 3d
of the dataset
our current implementation
of the datasets
the cells are
insertions and deletions
of the active
the mesh is
the o n
the active edges
number of facets
row gives the
the active edge
not empty do
the input mesh
the x z
the sweep algorithm
for the sweep
the image size
of the n
the conference on
of the conference
in the worst
we stop the
list of active
of the grid
have not yet
a list of
order of the
the y axis
the mesh in
cludio t silva
in the sweep
the intersections of
our method is
omega gamma n
take advantage of
in time o
on the complexity

corpus/krapavin2000-test/614371.txt
isosurface
cells
dataset
cell
unstructured
datasets
intervals
extraction
active
interval
isovalue
visualization
coherence
marching
chess
black
volume
dr
hash
tetrahedra
vertex
vertices
normals
3h
bluntfin
grids
board
isosurfaces
white
fighter
surface
visited
tetrahedral
speedup
tree
span
structured
cubes
mesh
graphics
facets
cthead
seed
extremes
bajaj
strip
gridded
gradients
hexahedra
occupancy
1997
prisms
forest
overhead
big
auxiliary
lists
intersected
pyramids
discriminant
traversal
sigma
seeds
bucky
unstr
tmin
connectivity
field
2m
chandrajit
livnat
edelsbrunner
exploit
adjacencies
rendering
trees
array
shen
lying
adopting
scanned
query
storage
wilhelms
grid
iso
october
layers
adjacent
edges
encoded
flag
redundant
curvilinear
gelder
interpolation
addressing
bong
dataset0
sohn
siddavanahalli
normal
efficiency
regular
courtesy
hansen
advancing
hexahedral
nasa
traversed
arrays
extracted
han
sorted
fig
adopted
fitting
deepest
itoh
isocontouring
16k
pascucci
individuate
exploiting
oe
implicit
edge
stored
tradeoff
interpolated
propagation
ffi
layer
san
storing
accelerated
indexes
sutton
isosurfacing
vinay
tmax
isovalues
thinning
soo
3d
interactive
triangular
arrangement
spans
subdivision
classification
redundancy
ertl
warrant
langley
haimes
ascending
collisions
indices
arc
patches
conceptual
traverse
octrees
stripe
dashed
spanned
scalar
california
backward
node
triangles
triangulated
playback
octree
finkelstein
list
march
wei
united
charles
gradient
depth
lutz
celebrating
sector
bare
sectors
massachusetts
irregular
boston
francisco
adam
chiang
optimally
meshes
searched
timing
jen
coordinates
interval tree
isosurface extraction
active cells
the isosurface
the interval
local coherence
white cells
black cell
march 7
7 1997
black cells
the dataset
unstructured datasets
chess board
the chess
of cells
isovalue q
range based
structured datasets
span space
of intervals
interval trees
data structure
on visualization
marching cubes
board approach
cell selection
the intervals
the span
q 0
tree data
at q
hash table
the active
each active
it off
visualization and
cell classification
the black
the hash
unstructured grids
of unstructured
and normals
ffi r
vertex normal
active intervals
storage cost
based methods
al and
normal data
an interval
volume data
the cells
the marching
active cell
input mesh
to speedup
intervals of
active white
query value
gradients at
isosurface vertices
global coherence
seed set
active black
value q
active at
the unstructured
active list
computer graphics
space based
cells of
each cell
the tree
of structured
of isosurface
auxiliary structures
and unstructured
and dr
it on
a dataset
found move
cell oe
between isosurfaces
exploit local
connectivity list
dr lists
dr list
off fig
big al
edges of
surface normal
memory overhead
and normal
structured and
an isosurface
the al
intervals in
the big
is visited
graphics v
to exploit
an isovalue
while intervals
extremes a
isosurface facets
search structure
active edges
varying fields
coherence between
cells for
are visited
tree is
by adopting
vertices and
auxiliary data
of tetrahedra
surface based
move i
timing for
of active
dataset is
memory requirements
vertex and
the conference
for structured
intersected by
the vertex
dataset are
not active
all intervals
and graphics
cells that
datasets the
be stored
speedup the
all active
tetrahedral cells
the cell
interval i
of vertices
normal computations
livnat et
edelsbrunner 5
visited recursively
i ffi
of 3h
memory words
unstructured case
big dr
else while
other range
branching node
3h 2m
hash indexing
adjacent white
1997 fig
white cell
at isovalue
the gridded
structured ones
by edelsbrunner
standard marching
range domain
conceptual organization
the structured
made of
on it
graphics october
coherence in
grids in
of surface
extraction process
cells in
time varying
efficiency and
time efficiency
cells at
volume visualization
an active
a hash
cells can
the seed
oe j
for unstructured
volume dataset
marching tetrahedra
regular dataset
isosurface is
facets it
wilhelms and
new conceptual
scanned until
optimally efficient
active edge
prisms and
list of
dataset the
proceedings of
vertices of
the interval tree
march 7 1997
the chess board
interval tree data
of the dataset
the span space
of the interval
chess board approach
case of unstructured
the black cells
range based methods
case of structured
an interval tree
of active cells
vertices and normals
vertex normal data
of unstructured datasets
al and dr
active at q
it on it
on it off
the hash table
the input mesh
at q 0
q 0 are
number of cells
conference on visualization
of the isosurface
structured and unstructured
the vertex normal
normal data structure
active white cells
the local coherence
the case of
number of intervals
tree data structure
in the span
the isosurface extraction
vertex and normal
in the case
of the black
the intervals of
the marching cubes
found move i
of structured datasets
the big al
each active black
active black cell
it off fig
interval tree for
tree data structures
are found move
the active intervals
exploit local coherence
0 are found
the seed set
timing for the
the dataset are
active cells at
black cell the
coherence between isosurfaces
local coherence in
query value q
and dr lists
interval tree can
a black cell
computer graphics v
on visualization and
visualization and computer
and computer graphics
transactions on visualization
proceedings of the
the conference on
visualization and graphics
and q 0
of the conference
edges of the
auxiliary data structure
interval tree is
for each active
intervals of i
to speedup the
time varying fields
on the interval
q and q
intervals in the
the number of
of the cell
of the tree
the dataset is
in the vertex
cells of the
data structure the
to exploit local
for cell selection
and unstructured datasets
by edelsbrunner 5
of the gradients
forest of interval
interval trees and
proposed by edelsbrunner
livnat et al
hash table in
hash indexing technique
a range based
interval tree the
the dr list
efficiency and memory
else while intervals
interval tree and
of interval trees
storage cost of
is visited recursively
order to speedup
the range domain
not active at
surface based methods
of i ffi
active cells for
and normal computations
facets it on
isovalue q 0
in the gridded
lists of type
of intervals to
other range based
the interval trees
an isovalue q
wilhelms and van
new conceptual organization
interval tree of
the unstructured case
7 1997 fig
at isovalue q
i ffi r
seed set is
white cells that
interval trees the
to be stored
on the basis
and graphics october
cells can be
in order to
intersected by the
a new conceptual
input mesh is
and van gelder
isosurface extraction in
list of cells
using an interval
by adopting a
in the dashed
span space is
given an isovalue
the storage cost
computation of surface
layers in the
with the interval
in the unstructured
to avoid redundant
the min max
pre computation of
extraction in time
the vertices of
in the worst
with the use
the list of
of surface normals
is searched for
both structured and
of volume data
the basis of
in the example
by using an
tree can be
are reported the
of unstructured grids
han wei shen
the output size
intervals to be
isosurface extraction and
grids proceedings of
are not captured
ratio between the
the use of
edge of the
2002 boston massachusetts
interval in the
in time varying
an interval i
for the interval
the current node
lying in the
an array of
1999 san francisco
2001 san diego
and memory requirements
data structure for
vertices of the
a hash table

corpus/krapavin2000-test/614386.txt
tetrahedra
multiresolution
mesh
rendering
sigma
dataset
warping
curvilinear
datasets
tetrahedral
tetrahedron
visualization
tetrahedrization
isosurface
volume
convex
decimation
simplification
meshes
lod
vertex
refinement
delaunay
vertices
omega
buckyball
tetra
irregular
approximated
multires
tan
lifting
accuracy
bluntfin
resolution
progressive
birth
dvr
gui
sites
tot
oe
accuracies
pt
deltar
subsampling
graphics
isosurfaces
historical
boundary
patches
2d
death
collapse
extractor
gamma
client
3d
polyhedron
module
opacity
terrain
interactive
incident
triangulations
hexahedron
surface
surfaces
hexahedra
sgi
wavelet
windowing
piped
submodule
regular
bucketing
extraction
covering
field
representations
visualized
warped
hybrid
triangulation
extracted
apriori
marching
coincident
hexahedral
geometries
che
hamann
lying
manage
triangles
polyhedra
triangular
cells
resolutions
facets
modality
cell
irregularly
heuristics
iv
face
bernd
ffl
interactively
depth
interpolation
32x32x32
openinventor
tetrahedrize
cracks
floriani
translucent
lods
baricentric
xforms
tetrahedrizations
hull
performances
block
960
transfer
simplified
physical
theta
128
image
blocks
64
unstructured
adopting
collapsing
datum
error
iteratively
adopted
occupancy
wavelets
terrains
splatting
leila
r4000
subcomponent
graphic
piecewise
scalar
lifted
levels
geometry
discontinuities
inserted
post
topographic
joy
hoppe
isovalues
adjacent
window
contrary
visualizing
ram
projected
decomposition
indigo
electron
parallelepiped
warranted
warrant
simplicial
warrants
subsampled
maximises
orientation
public
inside
inserting
spatial
approximation
scopigno
ws
complexes
file
cubes
spanned
editing
prepared
hardly
fig
supports
cignoni
triangulated
rectilinear
mt
simplices
estimate
inconsistent
multiresolution model
the multiresolution
non convex
data simplification
the mesh
curvilinear datasets
a multiresolution
mesh sigma
tetrahedral mesh
each tetrahedron
of sigma
mesh at
of tetrahedra
volume data
the refinement
historical sequence
hybrid rendering
irregular datasets
tetrahedrization of
convex curvilinear
sigma c
volume rendering
a tetrahedral
tetrahedral meshes
tetrahedra that
of v
tetrahedron oe
convex irregular
a tetrahedrization
convex datasets
multires model
sigma is
direct volume
the dataset
all tetrahedra
omega c
isosurface patches
warping of
meshes at
tot tetra
delaunay tetrahedrization
model tot
of gamma
an approximated
computational domain
a mesh
vertices of
in 2d
of sites
volume dataset
and warping
a volume
approximated model
at accuracy
mesh gamma
the rendering
refinement algorithm
refinement procedure
of omega
gamma is
of detail
the warping
tetrahedra are
visualization of
omega gamma
at v
transfer function
a tetrahedron
a vertex
approximated hybrid
block decomposition
curvilinear case
pt algorithm
domain omega
multiresolution extractor
deltar v
in physical
the client
v is
the user
at different
volume visualization
of volume
theta 32
tetrahedra and
point v
of vertices
visualization and
each vertex
vertex v
sigma in
regular datasets
the delaunay
birth and
multiresolution models
the field
rendering is
the convex
full resolution
sites of
the approximated
and death
in computational
on visualization
mesh is
the accuracy
modeling module
tan system
warping increase
built through
representations at
convex case
depth order
the pt
approximated mesh
of approximated
the tan
tetrahedra incident
edge collapse
lod representation
decimation algorithm
progressive rendering
no tetra
tetra no
rendering modality
the decimation
inside oe
through lifting
and opacity
multiresolution visualization
32 theta
physical space
oe c
rendering of
boundary of
omega is
and sigma
the historical
at full
reference model
accuracy is
the boundary
hexahedral mesh
multiresolution data
bucketing structure
multiresolution representation
curvilinear dataset
gamma c
visualization system
dimensional case
error and
data points
a regular
in 3d
points of
levels of
for volume
see figure
as vertices
dataset at
sigma 1
boundary vertex
different resolutions
datasets is
the curvilinear
for convex
to manage
the modeling
construction algorithm
initial mesh
computational space
on tetrahedral
physical domain
convex or
isosurface rendering
the visualization
accuracy of
data structure
datasets the
sample points
simplification of
gamma and
maximum among
isosurface extraction
covering a
on data
maximum warping
datasets sample
space omega
datum v
lod is
multiresolution rendering
interactive phases
e sigma
of tan
low lod
current mesh
piped to
on refinement
images refer
the multiresolution model
a multiresolution model
non convex curvilinear
a tetrahedral mesh
direct volume rendering
points of v
non convex irregular
of the mesh
model tot tetra
multires model tot
boundary of sigma
vertices of gamma
error and warping
a tetrahedrization of
on data simplification
levels of detail
the mesh at
of the multiresolution
of the dataset
deltar v w
tetrahedrization of the
convex irregular datasets
approximated hybrid rendering
the historical sequence
at full resolution
a tetrahedron oe
birth and death
the warping of
the refinement algorithm
in physical space
of the refinement
the boundary of
32 theta 32
color and opacity
the modeling module
in depth order
a mesh at
the curvilinear case
the multiresolution extractor
volume visualization system
an approximated model
no tetra no
of sigma is
in computational domain
representations at different
multiresolution model on
convex curvilinear datasets
mesh sigma c
at different resolutions
multiresolution model is
for convex datasets
the refinement procedure
of sigma in
tetrahedral mesh sigma
the tan system
model is built
of vertices of
the window in
for non convex
for each tetrahedron
window in the
number of tetrahedra
on the basis
the computational domain
of volume data
the maximum among
the public domain
the accuracy of
if v is
in the public
blocks of size
the points of
volume rendering of
a lod representation
the block decomposition
sites of sites
through the gui
warping and error
omega gamma and
of the tan
point of v
the bluntfin dataset
tetrahedron oe is
at accuracy 1
and direct volume
warping of the
is built through
adjacent to v
tan v 2
file for each
the current mesh
the pt algorithm
of curvilinear datasets
standard surface graphics
mesh at full
all tetrahedra that
example in 2d
the decimation algorithm
block decomposition refinement
tetrahedral meshes with
lies inside oe
dataset which represents
a given accuracy
set of tetrahedra
domain omega gamma
based on refinement
the multiresolution data
a volume visualization
the convex case
from the multiresolution
1 and sigma
images refer to
no sites of
of gamma the
and sigma 2
select min vertex
the visualization module
between the field
tetra no sites
refinement procedure is
mesh at accuracy
sigma see figure
multiresolution data structure
the reference model
accuracy 1 0
of detail buckyball
through standard surface
dataset at different
curvilinear datasets the
a bucketing structure
the maximum warping
of the bluntfin
sigma in the
tetrahedra and isosurface
the non convex
datasets sample points
the basis of
at each iteration
gamma is a
on the boundary
by the user
based on data
the size of
omega is a
an initial mesh
on tetrahedral meshes
hull of v
case of curvilinear
a volume dataset
currently under implementation
smaller than ffi
sigma 1 and
three dimensional case
theta 32 theta
visualization of volume
based on tetrahedral
of non convex
to non convex
the volume dataset
a regular dataset
of the field
is obtained by
the user can
at different levels
conference on visualization
case the point
a non convex
and non convex
the whole dataset
all data points
for each vertex
basis of the
size of the
the smaller the
at the points
in 3d space
is currently under
in computational space
in the refinement
at each vertex
vertices at the
number of sites
difference between the
v and the
on the contrary
the user to
sigma is the
accuracy of the
if the model
a priority queue
the transfer function
by the client
two dimensional case
a previous paper
in this case
in section iv
v on the
v is called
algorithms described in
the sequence of

corpus/krapavin2000-test/614387.txt
octant
streamline
streamlines
octants
visualization
cells
core
octree
disk
tetrahedral
unstructured
cell
megabytes
coordiates
000
workstation
mbytes
block
queue
fetching
preprocessing
graphics
memory
interactive
rendering
meshes
kurc
tahsin
pv3
tests
cludio
millions
saltz
million
paging
pool
waiting
silva
virtual
particle
resident
ready
overhead
streamtubes
chialin
joel
calculations
scientists
interpolation
initialization
airplane
workstations
grids
tracing
seed
ueng
shyh
file
blocks
eight
sussman
scientist
farias
neighboring
streaming
mid
vm
kuang
finished
partitioning
node
created
sparc
fetch
coordinate
2001
sun
policy
id
integration
cells30507090
catalyurek
nickolas
streamribbons
atalyrek
ribarsky
___
coefficients
stored
mesh
released
scheduling
timing
files
chunk
jen
claudio
kenneth
child
calculating
constructing
ricardo
seconds
ibm
william
october
indices
kuester
falko
faust
1051
connectivities
bruckschen
moran
chunks
operating
management
record
program
resolution
storing
ellsworth
2mb
joy
umit
hamann
rs6000
allocated
queues
chang
visualizing
precomputed
wall
buffers
redundancy
grid
8mb
cancels
irregularity
128
face
positions
read
initiate
octrees
schroeder
unsteady
alan
searching
concurrently
connectivity
volume
fly
sp2
tunnel
bernd
san
velocity
store
interactivity
celebrating
ralph
stores
costs
transformation
chiang
searched
cfd
isosurface
overload
preemption
flow
raw
dedicated
reveal
spatial
davis
jiang
sharing
minutes
california
moderate
field
intersect
bounding
united
resolutions
wind
diego
enter
conducted
carolina
bytes
eurographics
fields
center
attain
swapping
multiresolution
fluid
octant size
maximum octant
of core
memory space
size level
streamline construction
the streamline
the octant
node node
block size
the out
000 cells
core program
an octant
main memory
a streamline
the block
out of
streamline is
streamline visualization
octant is
streamline object
local disk
the memory
tetrahedral cells
100 streamlines
data node
octant table
test results
visualization of
virtual memory
size is
data set
solution data
the octants
core method
space pool
million cells
streamline objects
cell record
z coordiates
streamlines are
data sets
average cost
waiting queue
the streamlines
the ready
the maximum
data size
ready queue
non local
large unstructured
coordinate transformation
memory management
coordiates node
interactive streamline
constructing streamlines
octants in
the octree
an octree
level maximum
on visualization
the waiting
of tetrahedral
an out
the data
of constructing
the preprocessing
during streamline
of octants
core algorithm
finished queue
octant the
free space
megabytes of
management policy
data partitioning
cells the
a cell
tests are
40 000
times figure
t silva
2 mbytes
disk files
memory blocks
millions of
preprocessing step
the overhead
of streamlines
tahsin kurc
space is
data visualization
y z
a memory
mbytes 4
streamline calculations
128 megabytes
one octant
octant fetching
transformation functions
constructing 100
the finished
core approach
program maximum
child octants
joel saltz
cludio t
disk space
of cells
the coordinate
cells in
the tests
interactive visualization
unstructured grids
6 times
timing of
the conference
streamlines is
data preprocessing
cell indices
neighboring cell
core rendering
space size
initialization cost
core streamline
of streamline
graphics and
of large
total cost
computer graphics
20 000
memory block
tetrahedral meshes
operating system
of main
of tests
large data
4 times
30 000
unstructured grid
interpolation functions
data redundancy
single step
ieee computer
level is
rendering of
stored in
workstation with
preprocessing stage
resident in
memory based
10 000
the initialization
july 2001
size 40
eight child
one streamline
octant containing
mid range
longer involved
mbytes 8
streamlines can
data fetching
four million
streamlines by
size initiate
vm based
octree structure
sparc 20
streamlines concurrently
fly during
streamlines the
streamline scheduling
initiate construct
step computation
this octant
construct total
octants are
visualization calculations
chialin chang
grid data
proceedings of
visualization and
are conducted
to store
in core
three parameters
vector field
is set
size the
5 000
many smaller
remaining memory
visualization software
4 mbytes
alan sussman
size 10
octree is
megabytes to
maximum octant size
out of core
the maximum octant
block size level
the out of
the block size
node node node
the memory space
octant size is
of core program
the main memory
non local disk
memory space is
solution data node
the streamline construction
in the main
octant size the
of the octant
of a streamline
size level is
streamline object is
of core method
y z coordiates
the coordinate transformation
streamline visualization of
the ready queue
memory management policy
size level maximum
of constructing streamlines
z coordiates node
a streamline is
free space pool
level maximum octant
40 000 cells
time the block
of the out
the waiting queue
an out of
of tetrahedral cells
and the block
into the main
conference on visualization
cost of constructing
a cell record
the octant table
of core algorithm
million cells the
millions of tetrahedral
when the maximum
a memory management
of large unstructured
memory space and
the average cost
the conference on
proceedings of the
of the conference
of the memory
the test results
cludio t silva
the data partitioning
tests are conducted
in the streamline
memory space size
octants in the
a streamline object
constructing 100 streamlines
mbytes 4 times
virtual memory based
octant size and
the streamline is
20 000 cells
10 000 cells
the octant the
data from disk
the streamline object
during streamline construction
of program maximum
of core approach
neighboring cell indices
timing of program
set of tests
program maximum octant
the finished queue
applications v 21
of main memory
the data size
visualization of large
stored in a
memory space for
management policy is
of core rendering
of core streamline
size is set
21 n 4
a single step
graphics and applications
ieee computer graphics
is set to
computer graphics and
unstructured grid data
test results are
the total cost
performance of the
of the maximum
in the waiting
of the coordinate
better when the
the preprocessing step
when the data
average cost of
a non local
on virtual memory
of the octants
size 10 000
number of streamlines
size initiate construct
eight child octants
achieve interactive visualization
octant size 40
single step computation
the octant containing
cell containing the
data size initiate
streamlines can be
number of octants
this octant is
streamlines are constructed
resident in the
longer involved in
8 times figure
the initialization cost
data sets on
no longer involved
6 4 mbytes
fly during streamline
megabytes of main
the streamline objects
average cost and
constructing streamlines by
the fly during
to an octant
of constructing 100
the sun workstation
mbytes 8 times
cost and overhead
main memory space
four neighboring cell
a free space
19 2 mbytes
an octree structure
the preprocessing stage
program performs better
000 cells the
size 40 000
sun sparc 20
of the streamline
in the octant
interactive streamline visualization
initiate construct total
coordinate transformation functions
streamlines by using
octant size 10
octant containing the
coordinate transformation function
in the finished
data sets are
visualization and graphics
size and the
of time steps
from the disk
this data set
if the remaining
unstructured tetrahedral meshes
core rendering of
core streamline visualization
the second program
remaining memory space
on the sun
of tests are
are conducted on
the remaining memory
number of time
number of cells
the performance of
is stored in
shyh kuang ueng
local disk of
in the ready
the free space
to achieve interactive
performs better when
v 21 n
the data sets
coefficients of the
and applications v
the operating system
computed on the
meshes proceedings of
of core visualization
data size is

corpus/krapavin2000-test/614396.txt
convolution
unsteady
lic
scattering
pathline
uflic
texture
flow
particle
pixel
advection
airfoil
visualization
vortex
tiles
coherence
pathlines
wing
noise
animation
visualizing
seed
image
integral
vortices
velocity
jittered
fields
buffer
buckets
flows
field
subregions
streamlines
cfd
steady
accum
wijk
forssell
jobard
filter
bucket
span
streamline
pixels
particles
filtering
deltat
gathering
visualize
life
spot
bursting
fig
feed
pass
integration
advects
erlebacher
processor
textures
physical
advected
traces
kao
workload
jarke
leedom
hussaini
yousuff
spots
motion
cohen
accurate
curvilinear
tails
cabral
dye
animations
bruno
simulations
speedup
surfaces
laplacian
phenomena
processors
tail
convolutions
successive
graphics
scattered
vis
gordon
accumulated
white
forward
surface
timestamp
ames
subdividing
normalized
zhanping
processors26
baptista
moorhead
weiskopf
bending
convolves
reattachments
hege
pitches
subdivide
nasa
phi
temporal
animated
travel
age
frames
shedding
eulerian
spiraling
convolved
scatters
velocities
14th
coherent
normalization
travels
resolution
accelerated
jet
advect
highlight
fi
drives
ertl
4p
leading
van
delta
mask
shen
parallelized
529
oscillating
stalling
regions
distribute
instantaneous
trailing
tile
obscure
originating
2003
theta
separations
convolving
animate
phenomenon
formation
intensity
devising
uncorrelated
snapshot
ring
cpus
vertical
196
simulates
successively
consecutive
varying
287
clockwise
noteworthy
ubiquitous
389
buffers
images
simulation
effectiveness
blue
create
lagrangian
patterns
backward
multiprocessor
robert
wave
breakdown
contrasts
dramatic
03
edge
timestamps
fluid
snapshots
synthesis
emerge
unsteady flow
value scattering
the convolution
line integral
integral convolution
scattering scheme
time accurate
computational time
input texture
the flow
c buffer
the pathline
the lic
high pass
accurate value
flow fields
pass filtering
for unsteady
life span
uflic algorithm
physical time
lic method
convolution algorithm
flow field
the airfoil
convolution method
successive feed
integration step
time step
every pixel
the particle
a pathline
new convolution
seed particle
over time
in unsteady
unsteady flows
the texture
for visualizing
image value
flow data
jittered high
scattering convolution
noise jittered
pass filter
leading edge
pathline convolution
spot noise
current computational
noise texture
the uflic
th integration
noise image
convolution path
steady lic
delta wing
temporal coherence
each processor
feed forward
particle s
flow visualization
pixel values
to visualize
the scattering
fi fi
the advection
our value
flow texture
texture resolution
convolution results
lic to
forssell and
and cohen
convolution image
pathline is
flow lines
value gathering
van wijk
a particle
at every
each pixel
vector fields
white noise
a convolution
time dependent
time steps
the leading
the animation
new algorithm
the noise
visualizing unsteady
buckets in
an unsteady
vector data
vector field
on visualization
convolution can
convolution values
forward process
seed particles
bruno jobard
image values
texture space
regular lic
time varying
fields using
case studies
the velocity
flow is
convolution the
of unsteady
filtering process
texture this
cohen 4
gordon erlebacher
advection of
the unsteady
our parallel
space into
the seed
flow features
phenomena in
the vortices
steady flow
n th
parallel algorithm
edge of
velocity magnitude
pixel in
of buckets
the c
jobard gordon
pathline p
every integration
flow patterns
deltat i
leedom 3
convolution result
pixel b
pixels along
dependent method
flow motion
our uflic
lic convolution
texture input
of uflic
parallel uflic
advection the
unsteady lic
using line
instantaneous method
pathline the
c buffers
yousuff hussaini
flow traces
at physical
tiles to
cabral and
shift method
convolution to
flow animations
pixel a
m yousuff
vertical tails
flow line
noise technique
convolution length
data scattering
flow advection
primary vortex
convolution for
by cabral
and leedom
our unsteady
several cfd
ring buffer
w accum
jarke j
s life
highly coherent
previous convolution
image generated
erlebacher m
reason lies
vortex bursting
a texture
image space
the line
a white
2003 vis
visualization 2003
ieee visualization
the bucket
vis 03
coherence between
03 p
a flow
of value
pixel is
14th ieee
line integral convolution
value scattering scheme
accurate value scattering
time accurate value
unsteady flow fields
the input texture
high pass filtering
successive feed forward
high pass filter
in unsteady flow
the line integral
jittered high pass
the lic method
noise jittered high
the time accurate
unsteady flow data
the leading edge
a new convolution
th integration step
current computational time
n th integration
a time accurate
the convolution path
for unsteady flow
leading edge of
a pathline is
new convolution algorithm
the convolution results
white noise image
the current computational
the seed particle
our value scattering
a convolution image
fi fi fi
the uflic algorithm
value scattering convolution
the c buffer
forssell and cohen
the flow is
of the flow
an unsteady flow
for visualizing unsteady
a c buffer
along the leading
the noise jittered
the pathline convolution
noise image as
for unsteady flows
c buffer is
the successive feed
a white noise
of value scattering
and cohen 4
integral convolution method
pass filtering process
physical time t
feed forward process
the value scattering
computational time step
at the n
scattering scheme to
computing the convolution
texture space into
the convolution values
in the convolution
of the airfoil
the flow field
at every time
every time step
of the vortices
a flow field
image as the
our parallel algorithm
edge of the
of the tail
the high pass
of the particle
buckets in a
the flow motion
jobard gordon erlebacher
the c buffers
our uflic algorithm
unsteady flow visualization
cabral and leedom
the spot noise
i th time
flow data sets
input texture this
the previous convolution
using line integral
because the flow
the instantaneous method
the vertical tails
integration step is
the flow texture
vector data in
the primary vortex
integral convolution for
the unsteady flow
as the texture
flow line integral
unsteady flow line
the pathline the
by cabral and
bruno jobard gordon
erlebacher m yousuff
the image value
computational time steps
an input texture
the life span
convolution image generated
convolution algorithm for
data in unsteady
s life span
jarke j van
spot noise technique
phase shift method
at every integration
every integration step
the texture input
physical time and
m yousuff hussaini
of the pathline
j van wijk
gordon erlebacher m
at physical time
compute the convolution
and leedom 3
integral convolution algorithm
the flow lines
unsteady flow simulation
reason lies in
life span of
the reason lies
time dependent method
of the uflic
visualization 2003 vis
output from the
october 22 24
vis 03 p
the 14th ieee
2003 vis 03
ieee visualization 2003
14th ieee visualization
our new algorithm
coherence of the
results over time
of buckets in
flow simulation of
algorithm for visualizing
following we first
that a particle
span of a
visualizing time varying
the advection of
vector fields using
visualizing unsteady flow
in the field
as the input
pixel in the
the coherence of
the computational time
time step of
bucket in the
the delta wing
flow fields the
to the bucket
visualization and computer
computer graphics v
on visualization and
and computer graphics
transactions on visualization
number of buckets
ames research center
the image space
with shared memory
nasa ames research
a time dependent
the n th
of a flow
over time in
in a c
each pixel in
of the 14th
time step the
a two dimensional
proceedings of the
we then describe
for each processor
of processors26 parallelized
convolution results over
wave of vortex
the advection is
zhanping liu robert
of uflic algorithm
flow features over
new convolution method
hussaini lagrangian eulerian
path for pixel
of the spots

corpus/krapavin2000-test/614405.txt
subdivision
bicubic
extraordinary
surface
catmull
mesh
patches
clark
eqn
surfaces
spline
faces
vertices
patch
forces
valence
shape
deformable
3d
vertex
stiffness
damping
meshes
shapes
smooth
face
nurbs
rectangular
topology
qin
physics
mass
spring
fitting
subdivided
limit
fig
mri
geometric
motion
caudate
fitted
energy
deltat
freedom
terzopoulos
genus
matrices
polyhedral
butterfly
graphics
degrees
modelers
modeling
force
recursive
vemuri
nonrigid
visualization
assembled
1997
brain
infinite
sculpting
deforms
hong
depicts
slices
recovered
interactive
normal
enclosed
recovery
3k
tension
differential
wesche
sabin
conformation
zorin
styling
baba
celniker
nucleus
chhandomay
duan
chaikin
cerebellum
balloon
anvil
gerold
mandal
superscript
dynamic
3c
analytic
fit
recover
irregular
inflation
bulb
haptic
offspring
doo
positions
old
image
incident
boundary
formulation
functionals
splines
lagrangian
workbench
responsive
interpolation
dynamics
aforementioned
multiresolution
matrix
multilevel
green
interactively
equilibrium
initialized
interpolates
ye
reconstruction
parametric
polygonal
smoothness
arbor
shells
welch
symposium
cortical
kinematics
schemes
november
recursively
continuity
solid
around
nodal
seth
subsections
dr
quantities
dyn
michigan
governing
202
levin
adaptive
edges
concatenation
hierarchical
criteria
fair
derivation
initialization
topologically
defining
physical
united
volume
interpolating
synthesized
ann
siggraph
assigning
deformations
discontinuities
animation
convergent
enumerating
edge
deformation
curvature
tangent
evolution
coordinate
thin
parameterized
scan
coordinates
jacobian
eigenvalue
gossard
droske
roughness
ro1
1779
schroder
overstruck
sagittal
zhengyi
storry
amicis
denggao
limit surface
catmull clark
initial mesh
bicubic patches
clark subdivision
subdivision surfaces
b spline
arbitrary topology
of subdivision
subdivision surface
the limit
local subdivision
extraordinary points
subdivision scheme
extraordinary point
control mesh
10 1997
bicubic b
the extraordinary
an extraordinary
of bicubic
surface model
dynamic model
extraordinary vertex
dynamic subdivision
control vertices
in fig
of arbitrary
smooth surface
november 10
recursive subdivision
the catmull
the bicubic
subdivision rules
of valence
physics based
control points
new dynamic
free form
based forces
subdivision around
special element
the dynamic
deformable models
patches in
the model
and stiffness
damping and
hong qin
stiffness matrices
spring forces
subdivision schemes
of freedom
infinite number
f s
range data
shape recovery
fitted model
spline surfaces
extraordinary vertices
normal elements
normal element
bicubic patch
dynamic catmull
the initial
degrees of
geometric modeling
the shape
around an
data points
a bicubic
spline patches
bicubic surface
eqn 17
new face
mass damping
the mass
a rectangular
mesh is
the subdivision
of extraordinary
special elements
normal faces
k matrices
subdivision algorithm
subdivision steps
final fitted
rectangular control
initialized model
control point
vertices of
u v
f f
surface is
data set
finite element
image based
shape design
vertex positions
using very
the initialized
spline patch
mesh in
surfaces of
recovery problem
in eqn
s m
patch in
for modeling
of motion
subdivision the
for surface
the mesh
the surface
smooth surfaces
many bicubic
potential energy
patches around
butterfly subdivision
surface s
smooth limit
to faces
recover shapes
d nurbs
patches from
dynamic surface
mesh m
nonrigid motion
vertices defining
model deforms
subdivision based
deforms under
control vertex
old vertex
on catmull
energy functionals
freedom control
near extraordinary
generated b
valence 3
arbitrary genus
global subdivision
generalized coordinates
analytic formulation
face point
patches corresponding
few degrees
form deformable
subdivision mesh
valence 4
vertex point
computer graphics
mesh of
a subdivision
the force
s j
the vertices
in 3d
the smooth
faces and
in geometric
m d
of degrees
points of
finite elements
dynamic nurbs
non boundary
the fitting
patches to
recursively generated
mass matrix
spline surface
fitting process
geometric shapes
patch can
surface patch
equation of
as where
model can
the control
on solid
volume data
mesh with
expression for
a smooth
defining the
surface the
be noted
surface from
based deformable
surface defined
by eqn
non rectangular
its limit
all faces
faces with
be subdivided
shapes from
motion equation
surface can
the limit surface
catmull clark subdivision
the initial mesh
of arbitrary topology
november 10 1997
bicubic b spline
clark subdivision surfaces
in the limit
of bicubic patches
dynamic subdivision surface
around an extraordinary
number of bicubic
the catmull clark
image based forces
an extraordinary vertex
the dynamic subdivision
patches in the
degrees of freedom
infinite number of
may be noted
and stiffness matrices
damping and stiffness
of the limit
new dynamic model
subdivision surface model
dynamic catmull clark
the extraordinary point
the bicubic patches
an extraordinary point
limit surface is
surfaces of arbitrary
our new dynamic
equation of motion
b spline surfaces
f f f
b spline patches
mass damping and
local subdivision around
clark subdivision surface
of infinite number
bicubic patches in
of extraordinary points
subdivision around the
the mass damping
of the bicubic
clark subdivision scheme
final fitted model
and k matrices
the initialized model
shape recovery problem
around the extraordinary
shapes of arbitrary
the final fitted
number of extraordinary
using very few
b spline patch
level of subdivision
m d and
shown in fig
the data points
d and k
in geometric modeling
number of degrees
of the initial
model can be
of degrees of
of the dynamic
bicubic surface patch
local subdivision mesh
the old vertex
deforms under the
range and volume
of subdivision steps
by eqn 17
very few degrees
control vertex positions
new dynamic surface
the dynamic catmull
mesh of arbitrary
surface model can
of valence 3
form deformable models
limit surface s
on catmull clark
vertices defining the
free form deformable
near extraordinary points
step of subdivision
bicubic patches around
generated b spline
smooth limit surface
sets using very
initial mesh m
of local subdivision
patches around an
few degrees of
recursively generated b
number of subdivision
collection of infinite
smooth surfaces of
volume data sets
the subdivision rules
of freedom control
initial mesh the
freedom control vertices
of the catmull
new face point
dynamic surface model
j g 1
the normal faces
based on catmull
and volume data
vertices of valence
assembled into the
patches corresponding to
point of valence
extraordinary point of
control mesh is
the extraordinary points
the fitting process
model deforms under
its limit surface
develop the dynamic
and its limit
its control mesh
be noted that
symposium on solid
patch can be
patch in the
given by eqn
b spline surface
can be subdivided
expression for s
the shape recovery
the dynamic model
range data set
in the initial
of the model
surface can be
z z where
that f s
surface defined by
a smooth surface
control points of
an infinite number
the shape of
the control points
graphics and visualization
under the influence
of the subdivision
be expressed as
acm symposium on
edges incident on
data sets using
of the control
faces of the
incident on the
on solid modeling
modeling and applications
vertices of the
number of vertices
can be expressed
in fig 5
the finite element
one step of
solid modeling and
proceedings of the
a user defined
the vertices of
it may be
the average of
to develop the
ffl for each
e and f
in fig 10
of catmull clark
for surface reconstruction
u v t
these forces until
depicts a slice
potential energy of
influence of these
cortical structure in
new face points
into the vector
shape representation using
clark subdivision rules
between successive iterations
and eqn 16
size 3 48
henceforth termed a
dynamic generalization of
intermediate stage of
forces are applied
slice from this
using the vertices
continuous image based
workbench proceedings of
an intermediate stage
mesh defining the

corpus/krapavin2000-test/614463.txt
gac
probe
accessibility
obstacle
gacs
bent
clipping
cmm
grown
tip
truncated
cones
workpiece
ram
cone
probes
inspection
buffer
sphere
obstructed
accessible
planning
radius
dd
straight
depth
ball
cmms
stylus
directions
half
visibility
spherical
fpg
planner
cubic
setup
minkowski
penetrate
cube
faces
face
surface
solid
plane
tactile
machining
coordinate
rendered
aligned
mesh
plan
origin
graphics
offset
centered
viewing
render
bitmaps
surfaces
measuring
inspected
articulation
assembly
wgac
renishaw
endpoint
retract
curved
shading
mechanical
direction
projection
pg
solids
intersection
shrunken
hemi
rotary
approachable
orthographic
orientations
axis
volume
abstraction
shade
orientation
polyhedral
clipped
onto
penetrates
acis
0ae
approachability
spyridi
frustum
projected
component
facial
polygons
abstractions
gray
spheres
obstacles
contact
feature
optimistic
752
rendering
repair
initializing
requicha
shades
hardware
precision
near
bitmap
9d
radiosity
pessimistic
collisions
spatial
planes
7b
opengl
chines
portion
robot
placed
maps
collide
locus
iff
tool
viewer
9c
9b
touch
complement
approximations
center
generator
tolerances
normally
distance
strips
tentative
maximize
infrequently
boundary
cylinders
map
reasoning
geometric
abstracted
light
accessed
positioned
cylinder
3a
automatic
notice
illustrates
superset
projecting
shadow
manufacturing
placing
object
coordinates
inspec
offsetting
elmaraghy
759
orient
ramani
fixturing
findpath
15404
jackman
workpieces
menq
ph6
34727
nonobvious
abstractanalyzing
penetrating
projec
probex
spection
screw
lightest
potion
spitz
digitizer
dd1
machinability
ph9
drills
limaiem
the gac
half line
depth buffer
bent probe
gac of
the obstacle
truncated half
accessibility analysis
straight probe
the probe
a bent
obstacle x
clipping plane
the cmm
first component
second component
gac for
d 1
a truncated
the gacs
the tip
at p
coordinate measuring
far clipping
dd 1
the depth
a half
global accessibility
probe can
the ram
radius d
of radius
the accessibility
line d
probe is
an obstacle
x fpg
direction cones
the grown
dimensional inspection
gacs for
obstructed by
ball of
the directions
grown by
is accessible
probe and
the workpiece
near clipping
gac x
half lines
grown obstacle
a point
point p
the clipping
of accessibility
accessibility of
the far
the viewing
solid model
accessibility cone
cubic map
direction cone
5 pg
probe to
accessible directions
not obstructed
viewing volume
can access
the near
directions from
centered at
a straight
the ball
aligned with
a ball
a distance
plan is
the origin
graphics hardware
radius r
a feature
be inspected
computing d
of dd
a direction
gacs at
probe abstractions
grown half
measuring machines
clipping operation
tip at
probe abstraction
a cmm
cmm ram
inspection planning
measuring machine
regular gac
component accessibility
unit sphere
the points
to compute
directions of
the intersection
of directions
the cube
intersection of
buffer is
probe by
not penetrate
obstacle the
the articulation
obstacle and
0 d
a solid
computer graphics
the sphere
face of
component of
the bent
line 0
cone is
component d
projection of
compute d
the solid
the cone
a spherical
obstacle is
of gray
planning for
the mesh
compute the
visibility maps
setup planning
approach retract
setup orientations
world mechanical
plane should
rotary joint
tactile probe
clipping planes
a grown
grown object
automatic inspection
tip the
surface features
mechanical part
fpg is
articulation point
facial mesh
gac algorithm
solid difference
spherical surface
with coordinate
minkowski operations
penetrate x
distance no
inspection with
cmm has
maps 5
gacs of
accessible direction
with cmms
offset point
bent probes
retract path
a facial
a sphere
a probe
a radius
each face
the projection
orthographic projection
the direction
analysis for
the feature
d 2
the tool
from which
notice that
the cubic
ram is
mechanical parts
spatial reasoning
for dimensional
probe d
the face
the faces
projected onto
is projected
axis of
direction of
directions for
the plan
of computing
to render
the unit
origin is
endpoint at
the depth buffer
the gac of
truncated half line
a bent probe
a truncated half
a half line
the second component
the first component
gac of a
half line d
the gac for
line d 1
of a bent
of radius d
a straight probe
of the tip
centered at p
gac for a
accessibility analysis for
gac of the
an obstacle x
far clipping plane
the far clipping
ball of radius
of the probe
to an obstacle
near clipping plane
probe can access
directions from which
the near clipping
the global accessibility
all the points
the accessibility of
of a feature
at a distance
not obstructed by
of the gacs
by a half
global accessibility cone
for a truncated
bent probe is
obstacle x is
of dd 1
depth buffer is
component of a
the ball of
grown by a
first component of
face of the
the unit sphere
of the obstacle
the intersection of
a point p
gac x fpg
a radius r
solid model of
of the grown
of a truncated
coordinate measuring machine
gac for the
probe is a
the grown obstacle
computing d 1
line 0 d
from the obstacle
access a point
the clipping operation
the viewing volume
half line 0
straight probe abstractions
obstructed by x
clipping plane is
the gacs for
coordinate measuring machines
the cmm ram
compute the gac
computing the gac
the bent probe
the directions from
to compute the
intersection of the
directions of the
d 1 the
of a point
point p with
set of directions
by a radius
respect to an
d 1 is
a ball of
to compute d
is the origin
is projected onto
the projection of
normal to the
approach retract path
plane should be
for dimensional inspection
a facial mesh
a spherical surface
gacs for all
approximate the intersection
the probe to
the gacs of
compute the grown
planning and programming
the obstacle x
the offset point
dd 1 is
truncated half lines
that the gac
not penetrate x
the tip the
cone of a
of accessibility analysis
half line is
with a spherical
initializing the depth
computer graphics hardware
1 x fpg
accessible directions for
a regular gac
straight probe abstraction
accessibility analysis in
that is centered
that the cmm
of the workpiece
cmm has a
given a direction
are not obstructed
placed at p
alternative approach in
accessibility of a
the cubic map
choose an alternative
clipping plane should
x fpg is
point of dd
with coordinate measuring
the articulation point
than d from
the solid difference
first component accessibility
accessibility cone of
to be inspected
the straight probe
the direction cone
a distance no
real world mechanical
a solid model
aligned with the
of the cube
p with respect
center of the
axis of the
at p the
does not penetrate
second component is
of initializing the
d 1 x
should be minimized
a light source
of a half
a feature is
cost of computing
of the unit
the center of
directions for the
the obstacle is
of a cube
the axis of
of computing d
with respect to
identical to the
is the intersection
direction of the
assume that p
d 1 and
32 theta 32
d 1 that
a point that
projection of the
of the first
algorithm to compute
from which a
point that is
a distance of
used to compute
an alternative approach
component is a
d that is
of radius r
d this is
we choose an
projected onto the
of the tool
the directions of
is placed at
p is the
includes all the

corpus/krapavin2000-test/614468.txt
radiosity
illumination
scene
patch
texture
light
unoccluded
shadows
textures
shadow
virtual
relighting
reflectance
radiance
patches
lighting
visibility
photographs
lights
irradiance
subdivision
occluded
interactive
correction
refinement
color
frontier
rendering
reconstruction
bi
scenes
images
display
mesh
links
modulated
intensity
sources
blocked
fis
preprocess
intensities
hierarchy
reflectances
debevec
interactively
photograph
emittance
ei
visible
diffuse
modulation
reprojection
insertion
calibration
modification
reality
mosaics
reprojected
imag
regions
rgb
3d
darker
eq
camera
vision
tex
image
switched
outdoors
modulating
corr
casting
objects
augmented
subdivided
off
pixel
graphics
subdivide
viewpoint
ray
floor
modulate
orange
virtually
inserted
totalcalib
loscos
tvcg00
quicktime
frs
reproject
exchanges
source
boundaries
polygons
preprocessing
geometric
inter
reconstructed
indoors
imagis
occlusion
polygon
hierarchical
pull
attenuation
geometry
indirect
leaves
registration
projected
video
manually
final
environments
specular
modifications
switch
extracted
wall
sec
photo
modify
onto
di
publications
inaccuracies
colors
lumination
rekon
photos
flectance
finement
bfv
fournier
mincolor
mindistance
distancecolor
effects
viewpoints
invisible
ev
2t
red
push
secondary
poulin
shaft
onyx2
occluders
quadtrees
polyhedra
insert
progressive
passive
refine
creation
object
estimated
coarser
reference
fr
modifica
soler
cyril
mosaic
illuminate
ture
correspondences
leaf
epipolar
convincing
sillion
updates
appropriately
ratio
removal
cast
bf
lit
opengl
bright
notably
world
clusters
turned
inria
recovering
removed
adapted
limitation
exposure
solu
accurate
tracing
gather
heuristic
real scene
virtual objects
virtual light
common illumination
the radiosity
the texture
virtual object
light source
light sources
unoccluded illumination
the real
the scene
hierarchical radiosity
and virtual
the patch
correction factor
patch i
real light
texture t
reference patch
shadow boundaries
radiosity solution
scene is
augmented reality
blocked light
in shadow
the unoccluded
real and
texture based
a virtual
real shadows
radiosity system
real objects
based refinement
modulated by
of real
the illumination
radiance images
patch hierarchy
illumination effects
shadows are
switched off
real scenes
the visibility
the light
the textures
global illumination
of virtual
illumination textures
virtual lights
original texture
form factor
bi di
display correction
two patches
the occluded
the color
the display
insertion of
each patch
the insertion
lighting conditions
dynamic range
of radiosity
left light
reflectance values
virtual and
illumination of
textures the
form factors
real lights
new reflectance
visibility information
hand light
heuristic correction
lights and
using radiance
right light
a radiosity
intensity of
reconstruction of
vision based
the frontier
multi pass
the subdivision
a original
light is
a patch
scene the
scene and
switch off
of shadow
the reflectance
the patches
the shadow
color of
the virtual
light has
radiosity to
interactive relighting
additional irradiance
new texture
radiosity in
modulating the
light intensities
current radiosity
radiosity step
high dynamic
irradiance is
illumination for
passive links
of unoccluded
debevec et
occluded patch
radiosity value
in blocked
virtual source
shadows from
from photographs
unoccluded patches
patch is
illumination tex
radiosity bi
the orange
mesh subdivision
illumination we
virtual sources
illumination between
visibility type
of debevec
shadow regions
video sequences
objects into
real world
the intensity
off the
the blocked
scene we
figure 20
viewed from
inserted into
in figure
modification of
b c
for shadow
sec 0
resulting texture
of patch
interactive modification
illumination and
scene using
geometric model
illumination is
the floor
the preprocess
computer graphics
from real
subdivision and
effects such
push pull
different lighting
adding in
source we
between real
the original
a real
c d
ray casting
patch in
the hierarchy
all links
leaves of
subdivision the
3d model
b figure
a b
links are
the emittance
www imagis
illumination texture
fis s
shadow calculations
loscos tvcg00
texture modification
light exchanges
insert virtual
imagis imag
for indoors
similar color
original photographs
illumination as
publications loscos
for radiosity
dynamic object
as shadows
from textures
patch r
source intensities
pass display
original illumination
the real scene
real and virtual
of the real
texture based refinement
a real scene
virtual light source
of the scene
a virtual light
and virtual objects
the unoccluded illumination
the patch hierarchy
a virtual object
unoccluded illumination textures
real scene is
modulated by the
by the ratio
shown in figure
the insertion of
of the radiosity
display correction factor
common illumination effects
the radiosity solution
and virtual light
real light sources
left hand light
the light sources
the reference patch
virtual light sources
of the patch
a b c
method of 8
into a real
b c d
real scene using
modification of real
the blocked light
debevec et al
in blocked light
radiosity solution is
the illumination of
virtual lights and
unoccluded illumination tex
real scene the
for shadow boundaries
high dynamic range
virtual and real
insertion of virtual
of real objects
the form factor
on the floor
of real scenes
of each patch
the radiosity system
viewed from our
intensity of the
the color of
a b figure
the intensity of
between real and
if i has
the resulting texture
leaves of the
effects such as
of the texture
of the light
the scene is
shadow due to
we modulate the
inserted into a
virtual objects in
in the radiosity
resulting texture t
the additional irradiance
real world textures
workshop on rendering
is modulated by
at 3 frames
2 sec 0
a heuristic correction
textures extracted from
light source visibility
of debevec et
lights and objects
real shadows were
http www imagis
the two patches
adding in blocked
to augmented reality
of the textures
by modulating the
fr publications loscos
sequences on the
of virtual objects
the hierarchical radiosity
modulating the texture
the right light
algorithm of debevec
virtual objects all
between virtual and
video sequences on
real objects the
the patches are
the display correction
regions of shadow
the web http
using radiance images
real scene a
the correction factor
illumination of the
imagis imag fr
form factor and
of patch i
when the patches
switch off the
the texture based
a reference patch
into the real
hierarchical radiosity system
real scene viewed
new reflectance values
virtually switched off
a similar color
the virtual light
real scene and
quicktime video sequences
to insert virtual
dynamic virtual object
unoccluded illumination texture
of common illumination
such as shadows
refinement for shadow
the original texture
the original illumination
of the unoccluded
then subdivide i
loscos tvcg00 index
the original photographs
imag fr publications
the totalcalib system
www imagis imag
publications loscos tvcg00
under different lighting
multi pass display
in the frontier
the current radiosity
scene viewed from
common illumination between
original real scene
virtual objects into
the ratio of
in the scene
an approximation of
the method of
by the user
in figure 17
is shown in
different lighting conditions
the multi pass
3 frames per
to the radiosity
0 2 sec
figure 20 a
of the illumination
was inserted into
inaccuracies of the
b the resulting
from our system
web http www
the attenuation factor
the subdivision and
scene from a
the hierarchy of
c d figure
color of the
of a virtual
inserted into the
of real and
and the color
the modification of
presented in detail
the scene and
the left hand
model of the
which results in
the creation of
figure 15 a
the leaves of
reconstruction of the
of the camera
the reconstruction of
visible in the
ratio of the
is performed using
and interactive techniques
graphics and interactive
first step is
patch chosen in
should also have
of the attenuation
exposure time t

corpus/krapavin2000-test/615161.txt
lock
transaction
locks
mode
downgrading
inheritance
downward
locking
waits
concurrency
ix
downgraded
inferiors
downgrade
tl
nested
deadlock
subtransactions
hierarchy
superiors
retained
commit
retains
subtransaction
parent
deadlocks
ancestors
yes
modes
upgrade
granules
argus
moss
parallelism
nl
acquire
sphere
upgrading
held
commits
child
locus
retainer
dbms
holding
ancestor
upward
object
offering
hierarchies
subhierarchy
opening
downgrades
camelot
eden
eot
moss85
descendants
holder
intra
rollback
requestor
lockable
tuples
locked
wait
children
committed
clouds
transactions
recovery
descendant
subobjects
controlled
retain
sibling
database
flat
fig
gr4
allchin83
rules
six
intention
uncommitted
restrictive
compatibilities
aborts
granted
conflicting
anymore
transac
trans
cooperation
rder87
gr1
ller83
unrepeatable
gray76
gray78
firewalls
consistency
isolated
siblings
detection
resolution
request
acquired
releases
avalon
durability
relationships
hierarchical
abort
superior
acquiring
avoidance
release
sec
upgrades
rolled
holders
concept
acquires
cycle
aborting
aries
aborted
inherit
inherits
incompatible
indirectly
centralized
leaf
objects
management
inferior
protocols
read
isolation
rothermel89
weinstein85
rder83
acid
requestors
downgrader
liskov85
liskov87
gr5
astrahan76
depicted
segment
subtasks
coordinated
undo
chies
wound
retaining
decomposition
offered
effects
inherited
atomicity
conflicts
root
tuple
kind
subtree
action
refined
multilevel
timeout
victim
firewall
r5
concurrent
updates
outcome
prevents
flexible
offer
logging
soon
released
concurrently
inconsistencies
nor
mechanism
requesting
o1
mohan
8a
selective
reads
operating
access
o2
act
requested
db
the lock
nested transactions
lock in
a lock
a transaction
downward inheritance
x mode
concurrency control
waits for
lock on
s mode
x lock
h ix
controlled downward
tl transaction
locking rules
inheritance of
transaction t
mode m
yes yes
level rules
object hierarchy
of locks
ix h
lock to
no no
for retained
opening up
for lock
lock modes
in nested
to level
in x
retained locks
to mode
for nested
intra transaction
retained lock
s sphere
its inferiors
parent child
level to
an object
deadlock detection
transaction parallelism
transaction hierarchy
the waits
in mode
for commit
transaction may
ancestors of
its hierarchy
upward inheritance
s lock
the locks
level transactions
lock it
single level
nested transaction
parent transaction
transaction tree
by moss
object hierarchies
a subtransaction
object o
locks on
on o
on t
retains the
lock for
may acquire
mode of
yes no
locks in
in fig
of t
the transaction
all transactions
s hierarchy
all locks
the downgrading
a mode
transactions in
it holds
tl transactions
downgrading the
are ancestors
sibling parallelism
lock relation
a tl
mode and
transactions that
lock held
transaction holds
holding a
transactions and
x on
o in
h x
the locking
or s
downgrading of
the level
of concurrency
or retains
of downward
lock relationships
lock holder
that retain
lock after
x sphere
x locks
downgrade the
rollback of
nl mode
its superiors
is ix
mode x
up deadlock
the mode
level transaction
may see
the object
holds the
of transaction
of o
transaction to
locks are
locks held
holds or
to nl
control structure
of lock
other transaction
hold the
in sec
held by
the parent
x or
trans action
the transactions
acquire a
transaction model
s x
relation r
transactions the
locking protocols
locks of
level concurrency
locks for
locks is
s locks
indirectly waits
hierarchical locking
locks it
downgraded to
granules of
t retains
see changes
downgrading a
t commits
upgrade a
mode conflicting
after downgrading
locks from
up deadlocks
transaction hierarchies
t holding
eot t
lock granules
lockable units
any mode
can downgrade
from holding
it releases
of r
transaction can
lock is
its children
mode s
of nested
transaction management
t s
transaction is
an x
mode is
holding the
to leaf
h s
releases all
rules stated
lock can
among transactions
t may
stated above
transaction s
no yes
in s
mode in
transactions to
the lock in
in x mode
lock in x
controlled downward inheritance
to level rules
for nested transactions
level to level
the level to
in nested transactions
a lock in
inheritance of locks
waits for lock
in s mode
h ix h
waits for retained
in mode m
h x on
x on t
holds the lock
ix h ix
waits for commit
the waits for
intra transaction parallelism
hold the lock
the lock to
a transaction t
a transaction may
yes yes yes
x or s
downward inheritance of
of nested transactions
lock in mode
single level transactions
holding a lock
yes no no
lock in s
ancestors of t
in a mode
transaction holds the
retains the lock
an x lock
for retained lock
no no no
yes yes no
are ancestors of
lock to mode
a tl transaction
lock in a
the locking rules
lock on o
transaction t may
other transaction holds
or s mode
holding the lock
acquire a lock
of a lock
a lock on
tuples of r
the object hierarchy
opening up deadlock
of downward inheritance
that retain the
holds or retains
retain the lock
for lock relation
retained lock relationships
downgrade the lock
lock it holds
transactions that retain
no other transaction
on an object
of concurrency control
and all transactions
root to leaf
s and x
r x h
on t 2
on t 1
a lock it
all transactions that
may acquire a
an object o
of a transaction
when a transaction
a transaction can
level concurrency control
a transaction to
t holding a
of intra transaction
all locks it
cannot hold the
may see changes
nested transactions the
a mode conflicting
downgrading the lock
locks it holds
an s lock
can downgrade the
an object hierarchy
to mode s
in any mode
of its superiors
upgrade the lock
mode conflicting with
from holding the
t may acquire
proposed by moss
x h s
mode are ancestors
releases all locks
mode and all
to s mode
it holds or
for retained locks
it releases all
downgrading a lock
offering a lock
to nl mode
opening up deadlocks
concurrency control in
in x or
if no other
the lock on
transaction may see
acquire the lock
conflicting with m
t 1 h
the concept of
concurrency control for
lock on a
of multi level
s on t
after commit of
tl transaction hierarchy
after eot t
a lock holder
concurrency control scheme
lock in any
x lock on
concept of nested
lock and waits
act as firewalls
basic locking rules
to x mode
of controlled downward
by moss moss85
the nested transaction
s lock on
ancestor of r
nested transactions for
lock on this
upward inheritance of
t 2 h
a lock held
h s on
can upgrade the
lock to a
outside its hierarchy
in its hierarchy
for single level
to mode x
locks of t
it holds to
concept of downward
indirectly waits for
lock on r
mode of the
top level transaction
on this object
locks in the
upgrade a lock
s mode if
the locks in
the transaction hierarchy
six lock on
for upward inheritance
the lock mode
a transaction tree
locking rules for
after downgrading the
transaction t holding
and waits for
the same mode
locks held by
when a subtransaction
for lock and
a subtransaction t
the mode of
of the lock
rules stated above
lock on an
lock held by
all ancestors of
in sec 4
x and s
of t s
transactions outside its
ix h is
segment s h
locks after that

corpus/krapavin2000-test/618430.txt
skin
muscle
muscles
ellipsoid
ellipsoids
bones
stuffing
animal
anchor
joints
body
cat
animals
longitudinal
coordinate
isosurface
segment
axis
origin
adjustment
tendons
animation
tissue
joint
anatomy
segments
polygonal
insertion
vertebrates
thalmann
deformations
realism
interactively
mesh
motion
volume
anchored
surface
attached
frame
lengths
positions
henne
ears
skull
zuni
reshape
vertebrae
anchors
geometry
spring
attachment
frames
comfortable
voxelization
proximal
position
texture
realtime
grid
virtual
displaced
skeleton
individuals
gelder
outward
world
moves
magnenat
hen90
jurassic
5518
hues
biomechanical
distal
physiological
jld
abdomen
toad
stuffings
nearest
adjusted
species
animations
underlying
filtered
vertices
collision
humans
interactive
extracted
animated
anchoring
purple
lc87
rhythm
soft
axes
filtering
hierarchy
realistic
anatomical
bears
graphics
3d
deformation
foot
attachments
created
simulate
feel
allen
wilhelms
rescaled
bone
cubes
modeled
move
springs
grasping
leg
dt
parameterized
creation
marching
default
parent
polygon
neighboring
drawing
modeling
layered
filter
human
dp
visual
displacements
images
scalar
geometrical
decay
connections
implicit
loose
motions
tightly
center
converted
movement
shape
loosely
field
influence
flexible
dinosaurs
karan
markush
inverte
abductor
nudged
lucasfilm
biomechanically
sd93
83x83x83
variably
mtt91
scapula
larboulette
arnaldi
fatty
figuratively
endoskeleton
cz92
cola
nh93
merril
tw90
caroline
wk94
contaction
bli82
adhoc
gourret
chadwick
jointed
vertebrate
bulbous
fingers
car94
baggy
extensor
flexor
invested
haumann
aexture
anatomically
bpw93
brates
pauline
worldspace
the skin
the ellipsoid
the muscle
skin points
skin point
muscles and
of skin
world space
bones muscles
underlying components
skin is
coordinate frame
skin mesh
and insertion
the cat
rest position
polygonal skin
during motion
muscles are
each skin
body parts
the body
origin and
z axis
muscle ellipsoids
state geometry
the muscles
bones and
underlying parts
rest length
insertion points
and stuffing
virtual anchor
axis lengths
between skin
coordinate system
the anchor
in world
ellipsoid to
neighboring skin
to underlying
ellipsoids and
the longitudinal
rest geometry
soft tissue
animal models
segment coordinate
individual muscles
ellipsoid equation
local coordinate
the origin
rest state
body moves
and skin
the animal
collision detection
a polygonal
attached to
nearest point
an isosurface
anchor ellipsoid
muscle body
its rest
three ellipsoids
local segment
muscles stuffing
muscles the
origin point
anchored to
underlying anatomy
skin model
ellipsoid coordinate
skin was
across joints
zuni cat
muscles that
allen van
longitudinal axis
stuffing and
the zuni
local position
parent segment
ellipsoids can
a skin
and muscles
virtual anchors
muscles were
joints move
local ellipsoid
axis vector
tendons and
anchor the
body segment
the skull
in position
position for
the ellipsoids
anchor points
cat is
the proximal
and animations
the rest
coordinate systems
joints and
implicit surface
finite element
the filtered
segment is
positions of
the segment
present state
texture mapping
second using
geometry the
adjacent points
and animation
point on
van gelder
the world
own local
frames per
points on
the underlying
greater realism
jld s
segments bones
and reshape
muscle axis
new muscle
origin segment
physiological principles
different individuals
x lengths
to body
most vertebrates
ellipsoid axis
skin positions
the bones
the toad
simulated muscles
adjustment iteration
muscle changes
skin automatically
body muscle
geometry bones
muscle behavior
parameterized local
muscle or
was affected
thalmann and
joint motion
1 adjustment
muscle origin
ellipsoid are
body segments
at comfortable
the tendons
were displaced
ellipsoids are
skin vertex
research provides
stored both
remarkable similarity
real animal
body deformations
the abdomen
many animal
of muscle
of jurassic
element theory
as ellipsoids
skin and
whole animal
ellipsoid for
animal model
and physiological
anatomy we
interactive speeds
flexible skin
individual bones
jurassic park
ellipsoid by
between origin
ellipsoid and
filtered value
stuffings the
body between
13 stuffings
spring constant
mark henne
loosely attached
comfortable interactive
achieves greater
any ellipsoid
skin in
of rhythm
a muscle
during joint
magnenat thalmann
and species
the skin point
origin and insertion
of skin points
of the skin
of the muscle
the rest length
in world space
of the ellipsoid
and insertion points
bones muscles and
the ellipsoid equation
skin points and
between skin points
when the body
on the ellipsoid
the body moves
body segment is
the rest position
muscles and stuffing
bones muscles stuffing
muscles stuffing and
the virtual anchor
of the cat
the skin mesh
each skin point
the underlying components
virtual anchor the
the skin is
a polygonal skin
the zuni cat
skin point in
ellipsoids can be
segment coordinate frame
allen van gelder
neighboring skin points
attached to underlying
skin point and
influence of neighboring
of neighboring skin
the ellipsoid to
coordinate frame and
nearest point on
images and animations
per second using
s s s
e g i
the z axis
under the influence
the nearest point
of the segment
frames per second
from the underlying
of the body
the influence of
the origin and
to the skull
the origin segment
produce a polygonal
muscles and soft
of jurassic park
a parameterized local
joints is a
change in position
their local segment
the local ellipsoid
during joint motion
the longitudinal axes
implicit surface and
muscles and 13
and 13 stuffings
rest length for
a skin mesh
a stable position
between origin and
four muscles are
lie along the
at comfortable interactive
the origin point
magnenat thalmann and
and soft tissue
the ellipsoid are
rest skin is
axis vector with
ellipsoid section 3
and individual muscles
this research provides
or stuffing coordinate
its rest position
local segment frames
skin points which
the three ellipsoids
position in world
thalmann and thalmann
longitudinal axes of
across joints and
loosely attached to
was affected by
state geometry the
muscle body between
parameterized local position
figures 5 9
field is usually
in its rest
local ellipsoid coordinate
the rest geometry
polygonal skin model
zuni cat is
the muscle ellipsoids
many animal models
change during joint
of the ellipsoids
skin point is
individuals and species
anatomical and physiological
the rest state
the root segment
adjacent points e
achieves greater realism
stuffing and skin
anchor ellipsoid section
positions of skin
the polygonal skin
ellipsoid to the
skin vertex is
skin is generated
frame and a
bones and stuffing
ellipsoid coordinate frame
underlying components and
tend to use
of the axis
different individuals and
body moves the
the ellipsoid axis
world space are
origin segment coordinate
comfortable interactive speeds
along the longitudinal
of individual bones
animal coordinate system
ellipsoid are a
and the skin
finite element theory
ellipsoids and the
the joint and
using 1 adjustment
research provides a
skin points from
tightly attached to
a vector between
polygonal skin is
structure of individual
henne also used
when joints move
the x lengths
a flexible skin
13 stuffings the
to the ellipsoid
second using 1
the axis vector
the skin automatically
the spring constant
and physiological principles
parent segment the
muscle or stuffing
of the muscles
skin mesh with
its parent segment
ellipsoids that form
the near point
insertion points are
each skin vertex
the anchor ellipsoid
the filtered value
changes in position
to the skin
skin points two
muscles are created
skin is automatically
to underlying parts
ellipsoid axis lengths
the muscle origin
x lengths of
1 adjustment iteration
state geometry bones
to world space
the underlying anatomy
the state geometry
individual muscles that
the whole animal
world space of
by the user
is the rest
by a flexible
the insertion point
user can interactively
grid point is
local coordinate systems
connected to it
user defined parameters

corpus/krapavin2000-test/620236.txt
scheduling
deadlines
precedence
tasks
deadline
lateness
multiprocessing
edf
preemption
schedule
preemptive
jobs
np
multiprocessor
priority
uni
overload
monotonic
resources
job
release
mok
anomalies
heuristics
static
resource
earliest
overloads
periodic
blocking
lawler
processor
processors
miodrag
potkonjak
nonpreemption
outtrees
baruah
intrees
bins
jackson
miss
scheduled
interchange
minimizing
schedulability
task
arrival
garey
scheduler
metrics
classical
packing
layland
llf
designer
bin
series
clairvoyant
laxity
preemptable
shared
completion
designers
optimality
baker
implications
preemptions
kuan
polynomial
inversion
schedules
wayne
forest
pcp
critical
implication
metric
dates
aperiodic
cessors
periods
exclusive
synthesis
off
ceiling
comp
richard
chang
ffl
blazewicz
edd
ddsched
mcnaughton
ruei
nonpreemptable
d5
mall
anup
hamidzadeh
yacine
atif
ravindranath
hardness
meet
wolf
shih
successors
timing
johnson
babak
kernelized
intree
outtree
tardiness
bfd
late
policy
exclusion
smith
automation
hard
cumulative
multiprocessors
utilization
transformable
ffd
sha
srp
constraints
bhattacharjee
chuan
multitasking
d4
preempt
rise
dynamic
worst
bf
pal
schedulable
alarms
priorities
admits
station
theorems
period
rate
sequencing
oct
commack
nova
string
minimize
multimedia
fit
d3
capacity
blocked
385
publishers
graphs
permitted
forbidden
loads
anomaly
ting
sigops
avoided
shortest
aided
stack
graham
chemical
switches
locked
ada
lee
feasible
deadlocks
predecessors
protocol
mutually
robotics
arrivals
priori
lin
iri
situations
successor
149
proven
guaranteeing
chung
concurrency
wei
prevent
pessimistic
spring
pro
real time
time systems
precedence constraints
maximum lateness
multiprocessing scheduling
shared resources
rate monotonic
scheduling algorithm
uni processor
series parallel
on line
scheduling problem
all tasks
scheduling theory
static scheduling
release times
multiprocessor scheduling
of tasks
line scheduling
time scheduling
dynamic scheduling
classical scheduling
tasks with
non preemptive
the scheduling
their deadlines
off line
general precedence
deadlines and
time tasks
the multiprocessor
np hard
z graph
deadline scheduling
earliest deadline
scheduling results
computation time
ffl what
scheduling problems
is np
tasks and
for real
np complete
preemptive model
parallel graph
scheduling of
schedule length
s rule
the tasks
of scheduling
periodic tasks
precedence relation
scheduling is
monotonic algorithm
mok 24
priority inversion
the precedence
a job
of jobs
scheduling algorithms
optimal schedule
parallel graphs
critical section
task set
of periodic
tasks are
known about
precedence graph
optimal in
the task
its deadline
each task
partial order
overload conditions
precedence relations
deadline monotonic
in overload
miodrag potkonjak
exist for
and task
minimizing the
s anomalies
single deadline
jackson s
future release
string interchange
to preemption
richard s
cumulative value
interchange relation
theory results
with precedence
processors no
scheduling list
start times
computation times
hard real
scheduling with
theorem 4
is optimal
of completion
resource constraints
unit computation
johnson 10
no resources
tasks having
multiprocessor real
tasks have
run time
constraints and
completion times
a static
the schedule
and np
decomposition tree
garey and
tasks can
the priority
scheduling for
complete 2
tasks or
jobs with
edf scheduling
bin packing
classical results
task has
among tasks
of real
be optimal
multiprocessing anomalies
kuan shih
arbitrary partial
baruah et
independent periodic
resources arbitrary
lawler s
2 pro
z graphs
preemptive multiprocessing
or outtrees
and layland
constraints shared
of edf
tasks miss
preemption for
np comp
uni processors
between polynomial
wei kuan
to precedence
the multiprocessing
systems designer
worst case
to real
implication of
execution time
of bins
no advantage
the jobs
miss their
an optimal
in real
tasks that
are np
schedule with
deadlines in
np hardness
optimal algorithms
arrival times
advantage to
the rate
problem with
the optimality
theorem 3
and johnson
job j
when tasks
problems ffl
preemptive and
static schedule
periodic processes
due date
monotonic scheduling
the metric
scheduling and
highest priority
to meet
the deadline
scheduling a
priority of
be scheduled
pro cessors
the schedulability
the edf
first fit
task having
without preemption
overload and
precedence constrained
miss its
real time systems
real time scheduling
the maximum lateness
on line scheduling
scheduling problem with
classical scheduling theory
the rate monotonic
multiprocessor scheduling problem
for real time
set of tasks
a series parallel
the multiprocessor scheduling
earliest deadline scheduling
series parallel graph
real time tasks
series parallel graphs
precedence constraints and
of real time
an optimal schedule
sum of completion
of completion times
to real time
partial order and
hard real time
of tasks with
future release times
johnson 10 the
string interchange relation
richard s anomalies
jackson s rule
with precedence constraints
scheduling theory results
a z graph
and np hard
advantage to preemption
a single deadline
10 the multiprocessor
np complete 2
scheduling algorithm can
minimizing the maximum
is np hard
time systems v
is known about
and johnson 10
line scheduling algorithm
multiprocessor real time
of periodic tasks
problem with 2
no advantage to
unit computation time
scheduling of real
priority of the
in real time
of these results
in overload conditions
garey and johnson
is np complete
the task set
number of bins
the scheduling problem
the highest priority
constraints shared resources
polynomial and np
implication of these
order and each
2 pro cessors
tasks with precedence
baruah et al
with 2 pro
static scheduling algorithm
scheduling problems ffl
general precedence constraints
off line scheduling
time systems designer
the scheduling theory
wei kuan shih
no resources arbitrary
the general precedence
boundary between polynomial
between polynomial and
liu and layland
problems ffl what
general precedence relation
a string interchange
tasks having no
the tasks having
with shared resources
a uni processor
precedence constraints shared
scheduling results for
tasks miss their
rate monotonic algorithm
arbitrary partial order
rate monotonic scheduling
evaluate the worst
precedence graph the
to static scheduling
resources arbitrary partial
scheduling list is
of the tasks
the priority of
of the general
is optimal in
scheduling problem is
dynamic scheduling of
a static schedule
is a series
is no advantage
smith s rule
ffl what is
complete 2 theorem
non preemptive model
miss its deadline
minimize the maximum
problem of scheduling
2 theorem 4
problems are np
from the tasks
the deadline monotonic
been found for
exist for a
minimizing the number
real time system
hardness of the
a critical section
of processors required
many real time
miss their deadlines
are np complete
np hardness of
what is known
number of processors
of on line
the boundary between
of tasks and
time systems the
real time computing
on line algorithm
real time control
the np hardness
a real time
on computer aided
tasks in the
the weighted sum
set of independent
at run time
ieee acm international
related by a
tasks can be
computation time is
a cost function
et al 3
optimal in many
lawler s algorithm
ffl to prevent
versus dynamic scheduling
maximum lateness is
rise to z
resources currently available
cumulative value achieved
illustrate why this
used on line
max lateness but
time is np
minimizing maximum lateness
used for such
scheduling problems are
is not np
the scheduling list
shortest processing time
a clairvoyant scheduler
the precedence constraints
can be optimal
tasks have deadlines
arbitrary release times
a preemptive model
deterministic static scheduling
np are polynomial
precedence constraints in
no on line
to prevent multiple
important classical scheduling
ddsched a distributed
graph the algorithm
proven theorem 3
forest partial order
strings of jobs
transformable to r
interest to real
i e tasks
ffl understanding the
run time scheduler
system level synthesis
periodic tasks or
any sequence that
deadlines the same
list is built
no theorem 4
times precedence constraints
intrees or outtrees

corpus/krapavin2000-test/623900.txt
ssam
atm
trap
cell
handler
traps
messages
reply
message
remote
workstations
payload
buffer
cells
multiprocessors
sparcstation
clusters
kernel
prototype
device
flow
ss
active
uiomove
read
latencies
void
interface
fiber
sba
send
communication
ssam_10
interfaces
network
driver
buffers
multiprocessor
latency
protection
request
fifo
cluster
operating
receiving
bytes
read32_msg
bandwidths
window
dest
contention
double
trip
layers
sending
fifos
replies
transfer
1995
scheduling
descriptor
pvm
extern
conn
pinned
receive
int
bandwidth
overflow
register
read_cnt
addt
syscall
multiproces
handlers
word
ni
layer
tcp
hardware
registers
coordination
buffering
sbus
ovhd
aal
virtual
interconnected
microseconds
sender
5mb
receiver
fore
supercomputing
bulk
workstation
coordinated
comparable
cdrom
instructions
retransmitted
primitives
connection
bus
arrival
polls
networks
reliable
shared
offer
architectures
translation
stream
address
thekkath
read32_rh
ssam_poll
readdouble
ssam_req_handler
principally
9ms
in_buf
demultiplexing
ssam_maxconn
futile
aal3
rett
read32_h
delivery
shelf
memory
file
transferred
net
round
reads
pull
networking
processor
aligned
writes
sent
push
loading
25mhz
kaashoek
4mb
culler
losses
protected
ip
reception
peak
overhead
cm
differences
cache
collections
spent
6mb
2mb
crc
checksum
millisecond
today
breakdown
switches
machines
integration
formatting
decstation
polled
adds
diego
sors
calls
preventing
fd
acknowledgment
sun
id
byte
art
poll
08
requests
originating
congestion
counter
destination
incoming
processes
software
corruption
dozen
measurements
reliability
across
influenced
paragon
active messages
flow control
network interface
the handler
atm networks
the network
an atm
atm network
active message
remote memory
the device
network interfaces
the trap
the kernel
of workstations
system call
the receiving
user level
address translation
a reply
write system
double word
ss 20
communication architectures
the cell
cell into
the operating
the traps
operating system
the remote
the atm
file descriptor
sba 100
the ssam
device driver
the message
the read
to send
shared memory
the fiber
receiving end
communication patterns
process scheduling
of ssam
internal buffer
remote read
messages communication
receive cells
read trap
traps to
the prototype
the address
buffer overflow
communication architecture
reliable delivery
cell loss
the flow
parallel applications
per cell
round trip
the ss
and receive
clusters of
message the
send and
connection id
handler address
art multiprocessors
by ssam
56 bytes
reply handler
ssam prototype
atm payload
s handle
remote reads
input fifo
to ssam
control transfer
a cluster
system calls
buffer and
tcp ip
a cell
of atm
s check
user kernel
larger window
communication layer
bulk transfer
the sba
and multiprocessors
1 cell
communication layers
message data
reply message
read and
interconnected by
system software
the communication
the active
memory access
parallel computing
technical point
communication performance
cluster of
operating systems
low latency
between clusters
in atm
s per
the sending
the receiver
in hardware
to clusters
request message
total for
control and
aal 5
trap the
0 cells
breakdown for
receiving network
atm cell
int conn
continuous spectrum
over atm
node address
3 ssam
multiprocessor networks
output fifo
20 ss
ssam is
operation ss
check fd
int connection
trap which
device fifos
syscall overhead
than ssam
handler at
level access
sparcstation active
standard components
extern void
computing setting
cost breakdown
interface access
the sparcstation
sparcstation atm
addt l
word aligned
do uiomove
level library
kernel interface
be retransmitted
ss 1
ssam implementation
a request
send a
of flow
s read
read write
reads and
the cost
and writes
a buffer
on supercomputing
in clusters
08 1995
and flow
1995 acm
december 04
programming models
split c
coherent shared
and replies
protection mechanism
call interface
s 11
trap and
o bus
to multiprocessors
32 s
experimental set
the buffer
comparable to
control in
high performance
bytes of
that messages
1995 san
address of
message and
the 1995
moves the
04 08
supercomputing cdrom
requests and
cdrom p
transfer the
the network interface
the flow control
an atm network
flow control and
clusters of workstations
the operating system
the cell into
the receiving end
remote memory access
at the receiving
the remote memory
and receive cells
active messages communication
by an atm
write system call
within the network
send and receive
flow control in
to the kernel
a reply message
of flow control
the address translation
s per cell
read write system
the sba 100
the art multiprocessors
remote reads and
on the ss
in the receiving
of active messages
the ss 20
to send and
a cluster of
technical point of
the active messages
and flow control
in atm networks
reads and writes
to the network
of an active
operation ss 20
the receiving network
a request message
of the fiber
cache coherent shared
receiving network interface
buffer overflow in
the input fifo
network interface access
the handler address
interconnected by an
sparcstation active messages
message data into
to clusters of
a parallel computing
level access to
user kernel interface
messages communication architecture
of standard components
a continuous spectrum
20 ss 1
ss 20 ss
cost breakdown for
5 0 s
traps to send
and the handler
the connection id
the ssam prototype
clusters and multiprocessors
parallel computing setting
user level library
over to clusters
the file descriptor
handler at the
the device fifos
requests and replies
the device driver
the internal buffer
user level access
of atm networks
access to the
conference on supercomputing
04 08 1995
08 1995 san
1995 san diego
1995 acm ieee
the 1995 acm
december 04 08
the cost of
the read and
the communication patterns
cell into the
a technical point
of the trap
i o bus
flow control information
from a technical
send a reply
experimental set up
integration of all
remote memory accesses
cluster of workstations
user level network
system call interface
the active message
read and write
of the 1995
the network and
on supercomputing cdrom
diego california united
supercomputing cdrom p
the address of
allowed to send
use of standard
for comparison purposes
of the art
overflow in the
of a request
into the network
to send a
the use of
prototype implementation of
off the shelf
of the read
a user level
acm ieee conference
is provided for
ieee conference on
it into the
on the nodes
the message the
of the active
es december 04
san diego california
california united states
data and control
the scheduling of
new communication architectures
to the traps
to the device
or flow control
incoming messages at
is roughly comparable
polls the receiver
preventing buffer overflow
well integrated into
dec 3 1995
aal3 4 compatible
2 03 s
the larger window
become available and
to ssam is
over 1 s
based network interfaces
lack of flow
cell loss in
s 12 s
the same payload
16 bits the
messages on multiprocessors
trap rett 0
protection in software
loading the cell
for 1 cell
bytes of payload
clusters use standard
transferred directly between
total for 1
the current ssam
an internal buffer
control in atm
on the sparcstation
and active messages
g tcp ip
syscall overhead 22
an aal3 4
send a request
in active messages
into the device
a remote read
int connection void
form of protection
of cells available
that network interfaces
buffering and scheduling
system call syscall
overflow within the
communication patterns are
write system calls
respect to multiprocessors
on message arrival
bulk transfer rates
fd do uiomove
write entry points
trap which receives
44 s 2
of protection mechanism
and control transfer
internal buffer and
and receive traps

corpus/krapavin2000-test/623929.txt
optical
beam
dmd
sorting
wavelength
array
beamsplitter
lens
pixel
mirror
light
electrodes
optics
deflection
rank
smart
torsion
photodetectors
subtraction
sorted
cylindrical
optoelectronic
lenslet
laser
wavelengths
emitting
modulators
imaged
reordering
optically
photodetector
lasers
dmds
focal
addressing
pixels
photonics
modulates
devices
reflected
deformable
angular
electronics
electrical
column
eqn
incident
screen
arrays
impinges
sbwp
6664
20cm
electrode
spreading
axis
prism
opaque
physically
intensity
cl
la
vertically
substrate
focused
voltage
ranks
amp
deflected
microlasers
vcsels
splitter
photonic
onto
thresholding
legend
interconnects
matrix
electronic
detector
landing
opening
fabricated
1080
device
row
electrically
1920
gammau
analog
surface
sort
gammaa
switching
fig
horizontally
integrated
tristable
polarizing
filterl
vstep
crosstalk
pentaprism
impinge
vcsel
resistive
sorter
plzt
gaas
photons
parallelism
modulation
contribute
conventions
spread
detectors
reorder
conventional
summing
modulating
deflects
cl2
zeros
positions
off
v2
silicon
position
zeroes
capable
beams
cavity
differential
wave
superimposed
si
thresholded
elec
proceeded
sp
subtracting
massive
negative
modulated
counterclockwise
transistor
occasion
optic
reflects
separates
mirrors
string
sectional
op
widespread
color
element
configuration
chip
behind
communications
spatial
filter
layout
filters
inputs
contributes
resolve
setup
vector
summed
interfering
addressed
hm
quantum
items
bandwidths
gate
bias
occupies
approx
fastest
interact
permit
equilibrium
internally
preceded
spatially
v1
ascending
seed
pointer
formed
passes
jg
reflection
axis58lenslet
stirk
gamma6664
micromechanical
of wavelength
sorted output
rank vector
smart pixel
cylindrical lens
the sorted
the rank
optical implementation
optical system
torsion beam
data elements
smart pixels
the optical
optical sorting
incident light
0 array
the cylindrical
lenslet array
deformable mirror
surface emitting
imaged onto
the subtraction
sorting algorithm
non unique
the dmd
wavelength 2
proposed optical
focused to
a array
array of
of step
sorted data
the torsion
is imaged
the mirror
a j
the lenslet
dmd pixel
beamsplitter and
the beam
opaque screen
column addressing
of optics
physically reordering
wavelength 1
difference matrix
sorting system
sorting systems
the beamsplitter
d 0
light of
parallel sorting
an optical
focal length
intensity level
light modulators
off axis
actual subtraction
deflection of
from behind
angular deflection
modulates the
original vector
rank of
column j
matrix d
light intensity
of smart
light reflected
constant time
the smart
element of
point f
d array
optical axis
2 d
onto the
pixel size
d laser
electrical inputs
unique ranks
addressed configuration
f la
spatial light
reflected light
address electrodes
emitting laser
dmds are
addressing lines
physical reordering
reflects off
top view
electronic sorting
op amp
optically addressed
reordering the
be sorted
sorting is
a sorting
viewed from
position 1
position 2
the r
are focused
potential difference
pixel array
is focused
pixel of
step 4
the d
array and
selected elements
highly parallel
as viewed
eqn 8
in fig
vector r
sequence length
a t
r 0
data arrays
subtraction of
beam is
angular beam
beam splitter
the photodetectors
optical and
of lasers
differential bias
compare every
summing each
gammaa t
unique rank
on axis
optical array
mirror device
optical setup
a dmd
theta 1080
light for
unique numbers
landing electrodes
and physically
laser array
r array
electrodes the
beam deflection
for photonic
lens to
color filter
two wavelengths
1920 theta
implementation of
sorting algorithms
off the
array as
each element
n times
of sorting
the sorting
reflected by
elements to
array the
to form
array array
fundamental operation
the column
each column
generating the
the vector
of d
number in
an element
the light
single pixel
the opaque
in eqn
and thresholding
sorting networks
the proposed
vector a
in column
pixel the
the a
every element
time parallel
subtraction is
the focal
matrix a
in constant
sorted in
its rank
switching and
reordering of
input data
capable of
implications in
for highly
reorder the
massive parallelism
the sorted output
the rank vector
the cylindrical lens
in the sorted
the torsion beam
array of wavelength
the d 0
parallel sorting algorithm
the smart pixel
of wavelength 2
d 0 array
the proposed optical
optical implementation of
is imaged onto
proposed optical sorting
the lenslet array
to the rank
the rank of
difference matrix d
the beamsplitter and
light of wavelength
the difference matrix
the actual subtraction
imaged onto the
of wavelength 1
the column addressing
intensity level of
optical sorting system
the a array
generating the rank
rank vector r
the original vector
the sorted data
the surface emitting
r 0 array
column addressing lines
viewed from behind
off the beamsplitter
an optical system
non unique ranks
data elements in
light intensity level
physically reordering the
of smart pixels
surface emitting laser
smart pixel array
reflects off the
and the cylindrical
2 d laser
lenslet array and
by the lenslet
are focused to
implementation of step
of an element
the r 0
to form the
data elements to
as viewed from
to be sorted
rank of an
elements of a
in column j
rank of a
column j of
angular beam deflection
pixel array the
cylindrical lens to
of data elements
summing each column
a top view
for highly parallel
beamsplitter and is
in eqn 8
subtraction of the
1920 theta 1080
the opaque screen
data arrays in
physical reordering of
is focused to
d array of
to point f
spatial light modulators
the optical system
reordering the data
number in column
by the cylindrical
top view of
time parallel sorting
and are focused
n data elements
and physically reordering
deformable mirror device
angular deflection of
reflected light for
2 d array
electronic sorting systems
focal length of
optical array of
an element the
optical sorting systems
by the mirror
j of d
optical system for
non unique numbers
constant time parallel
sorting is a
d laser array
of the sorted
element of the
every element of
each element of
to a j
a single pixel
the focal length
the data elements
e o 1
along the optical
of the d
view of a
of the proposed
the vector a
reordering of the
of step 4
sorting algorithm and
algorithm and its
in constant time
of the algorithm
the subtraction of
a constant time
of the optical
elements to be
array and the
of step 3
the input data
a j and
of a j
reflected by the
i e o
number of data
o 1 time
and a t
of the absolute
the absolute values
row of a
the proposed algorithm
generation of the
f along the
a i appears
to off axis
is focused by
cylindrical lens elements
a j s
detected value of
comparing each element
constant time i
optical and electrical
arrays in parallel
array array array
element a j
position 1 position
3 and part
of physically reordering
1 time this
both the optical
the detected value
pixel of size
the side where
properties of optics
and its efficient
focused to point
on axis opening
a square pixel
fundamental operation that
implementation of smart
optically addressed configuration
of wavelength negative
all matching entries
compare and exchange
reflected from position
single smart pixel
by the smart
mirror s position
reflect off the
its optical implementation
beam is in
fabricated with conventional
switching and control
sectional view of
for optoelectronic processors
of equilibrium at
pixels for optoelectronic
subtraction result of
modulates the surface
locations of selected
implementation using currently
to select discard
1 is focused
conventional si and
opaque screen by
using currently available

corpus/krapavin2000-test/624159.txt
nic
endpoint
endpoints
message
messages
firmware
virtual
packet
dma
packets
logp
nacks
gam
server
retransmission
am
myrinet
sender
acks
destination
microseconds
timer
sbus
outstanding
resident
network
nics
host
interfaces
bulk
daemons
receiver
clients
medium
nack
delivery
retransmissions
channel
senders
interface
client
multiprogramming
transport
resources
hamlyn
protocols
active
receiving
unloaded
send
transfers
timeout
receive
trip
interconnect
sending
protection
protocol
bandwidth
overruns
rates
rtt
mb
bisection
thread
microbenchmarks
shrimp
api
reliable
scheduling
reply
layers
round
virtualized
communication
bandwidths
channels
aggregate
hosts
buffer
ack
gap
unacknowledged
microsecond
mechanisms
management
mapper
undeliverable
msgs
backing
threaded
sequencing
bw
switches
streaming
workstations
credits
cables
culler
transmission
fm
latency
requests
routes
overheads
switch
contention
staging
gigabit
virtualization
benchmarks
net
flow
privileged
topology
cluster
costs
layer
unreachable
queue
delivered
transient
pm
deadlock
timestamp
networks
addressable
semaphore
supercomputing
pressure
avg
queues
martin
virtualizing
8722788
pageable
microbenchmark
overcommitted
0014
frees
unduplicated
multiplexing
arpa
graceful
request
catastrophic
accommodate
bytes
handler
hardware
copy
eicken
clm
payloads
f30602
unloading
driver
protected
latest
scheduled
replies
fellowship
destined
berkeley
micro
tags
retries
tention
mainstream
posted
traffic
unavailable
storage
acknowledged
manage
event
robin
nsf
faults
8kb
indirection
retransmitted
graduate
positively
arrives
tag
latencies
actively
corrupted
errors
spmd
responsiveness
word
probe
baseline
handling
acknowledgment
load
clusters
received
am ii
the nic
virtual networks
active message
virtual network
network interface
message rates
to nic
message delivery
network interfaces
reliable message
the network
the am
per client
timer management
outstanding messages
nic to
mb s
flow control
an endpoint
the server
active messages
the logp
non resident
endpoint scheduling
medium messages
client message
message rate
destination endpoint
k user
per endpoint
error model
virtual memory
round trip
the endpoint
transport protocols
the protocols
and nacks
host memory
resident endpoints
logical channels
medium message
destination nic
server thread
and bulk
the sbus
4 word
u net
sequencing information
sequence number
timeout and
of clients
the virtual
our system
of endpoints
average per
ii api
nic transport
independent logical
interface architecture
virtual interface
resident endpoint
active endpoints
bulk messages
retransmission mechanisms
interface firmware
rates with
single virtual
the sender
of outstanding
trip times
receive queue
endpoints with
and retransmission
each endpoint
endpoint to
re transmission
buffer overruns
back pressure
communication layers
acks and
the receiver
interfaces and
address space
communication system
send and
and receiving
and per
the send
messages are
network management
user level
of network
successfully written
cluster interconnect
nic flow
level back
rate msgs
server endpoints
request receive
and retransmissions
server message
nics delta
destination endpoints
latest nack
endpoint contention
overhead o
interface memory
the backing
additional messages
receive table
31 mb
dma transfers
copy on
control timer
message staging
send table
the interface
per packet
delivery and
endpoint is
communication resources
an acknowledgment
and receive
a message
an ack
medium and
s address
the gap
on supercomputing
a packet
endpoints are
a sender
trip time
thread is
protection checks
channel table
common destination
message layer
packet retransmissions
the interconnect
fast communication
microseconds the
network system
performance communication
contention within
microseconds for
automatic network
scheduling of
general purpose
high performance
and error
message system
transport protocol
of am
the sending
messages with
receiving an
multi threaded
per message
error handling
the transport
multiple independent
with destination
net work
these systems
parallel programs
to send
the packet
an active
resources and
link level
short messages
endpoints and
of senders
the system
communication subsystem
the latest
sender and
network access
the timer
the bisection
the protection
detecting and
per second
messages from
end points
endpoints in
packets the
communication model
the communication
table entries
delta channels
error models
bisection 5
unrelated applications
the gam
because endpoints
outstanding requests
endpoint each
the am ii
reliable message delivery
the network interface
nic to nic
per client message
message rates with
client message rates
number of clients
network interfaces and
an active message
nic transport protocols
virtual interface architecture
of network interfaces
am ii api
the nic to
to nic transport
a non resident
acks and nacks
average per client
independent logical channels
medium and bulk
single virtual network
round trip times
s address space
a single virtual
message delivery and
send and receive
contention within a
flow control timer
and retransmission mechanisms
31 mb s
level back pressure
and per client
sending a packet
destination endpoint contention
error model and
one copy on
of outstanding messages
of virtual networks
nic flow control
to nic flow
an endpoint is
link level back
of am ii
active message system
non resident endpoint
copy on the
the latest nack
the virtual interface
the virtual network
virtual network system
error model for
multiple independent logical
active message layer
server thread is
active messages with
message rate msgs
network interface firmware
in the send
and bulk messages
medium message staging
conference on supercomputing
round trip time
interfaces and communication
and communication resources
the protection checks
high performance communication
the average per
on the receiver
to the network
within a single
and error handling
number of outstanding
on the sender
destined for the
of the virtual
the network s
in our system
of the server
the destination endpoint
s topology and
back pressure the
per endpoint error
direct network access
that this hybrid
collections of endpoints
the nic must
endpoints may be
a virtual network
channel management tables
acks that may
it and receiving
virtual memory regions
the packet for
this hybrid scheme
and retransmissions for
our virtual network
delay product is
and robust communication
rate msgs s
unduplicated message delivery
of mutually deadlock
short medium and
no acks or
endpoint to endpoint
general purpose and
f30602 95 c
backing store for
clients message rate
nics delta channels
server message rates
arrives for a
network management daemons
resident endpoint or
channel table state
logp communication model
stop and wait
bandwidth and low
in the sbus
timeout and re
for non resident
a retransmission event
server and per
a medium message
endpoint contention within
additional microseconds the
communication system must
support automatic network
messages to it
and easily addressable
sun ultrasparc workstations
and re transmission
the server thread
the protocols must
with nics delta
k user is
the nic can
40 myrinet switches
message round trip
management reliable message
workstations interconnected with
wait flow control
the send table
successfully written into
0014 the california
our cluster protocol
am ii library
into their destination
to sender error
scheduling flow control
microseconds the protection
deadlock free routes
programming i o
non resident endpoints
u net and
virtual network segment
sequencing information for
interface architecture proceedings
receiving 4 word
topology acquisition and
with destination endpoint
the virtual networks
c 0014 the
the interconnect and
thorsten von eicken
california state micro
server client figure
beyond a baseline
control timer management
ultrasparc workstations interconnected
using medium messages
an error model
microseconds for the
the timer and
arriving for non
network interface card
short message rates
timer management to
dropped or corrupted
add another 1
network segment driver
return to sender
and wait flow
retransmission event on
timer and retransmission
virtualization of network
duplicate acks that
1 is spent
per message round
using per endpoint
aggregate server and
the logp communication
bandwidth mb s
message staging areas
by arpa grant
nsf infrastructure grant
sending messages from
in an endpoint
our system addresses
written into their

corpus/krapavin2000-test/624870.txt
demeter
law
supplier
acquaintance
rulename
defmethod
archive
grammar
parsedetails
preferred
referencesec
lieberherr
oriented
microfichefiles
lookup
programmer
flavors
parse
rulelist
bookssec
book
object
style
hiding
void
lookupparse
bookidentifier
karl
send
programmers
software
complexnumber
lhr88
searchgoodstyle
searchbadstyle
classes
strict
attached
symbol
dictionary
declaration
adherence
client
library
suppliers
self
lifting
coupling
message
utilities
fragment
getbody
sak88
microfiche
friend
pushing
sigplan
isbn
hierarchy
sept
loan
documents
public
documentation
member
xiao
smalltalk
violations
guideline
responsibility
interface
lr88
lh89b
frege
helm
brock
eiffel
listofbooks
riel
casais
mitch
wilde
fruleg
archmicrofiche
newobject
wirfs
lie88
messenger
ebnf
warwick
churcher
upwardly
aldrich
huitt
libraryofcongress
gar
lg86
cdromfile
compile
reusability
oct
minimization
parts
restricts
m1
1990
development
arguments
clos
cun
neville
aspectj
subpart
oops
lepe
penalties
m2
notices
f1
subparts
irwin
ignacio
browser
declare
statically
immediate
behavioral
thesis
modular
wand
obeying
maintainability
promotes
compositionality
benefits
rule
ffl
bad
1993
informally
inheritance
body
ross
encapsulated
carl
localizing
redesign
document
compiler
languages
implements
comprehensible
assuring
pacific
norman
repeat
violates
c2
growth
doug
programming
maintenance
declaring
communications
abstraction
program
visualisation
subclasses
encapsulation
aspect
c1
vancouver
alternation
264
sent
richard
dependencies
phrase
members
return
asia
objects
jonathan
silva
toplas
expresses
1992
adaptive
helps
readable
organize
boolean
versions
restriction
duplication
transform
evolution
repetition
localization
thousand
the law
of demeter
has parts
law of
object oriented
acquaintance class
acquaintance classes
preferred supplier
parts class
instance variable
lookup rulename
the demeter
demeter system
class c
class form
of class
instance variables
class archive
strict version
defmethod grammar
good style
a preferred
the strict
the programmer
symbol rulename
type symbol
c void
part class
flavors defmethod
rulename type
send self
supplier to
the method
method m
class b
grammar parse
send send
class dictionary
demeter is
book f
grammar lookup
class referencesec
preferred acquaintance
archive class
oriented software
a class
the class
classes to
a method
of preferred
an acquaintance
oriented program
to class
oriented programming
class a
class definition
law in
client of
object form
supplier classes
supplier class
a supplier
bad style
law s
void grammar
implements interface
book book
list repeat
object version
symbol send
the object
information hiding
the classes
law is
the acquaintance
class rule
oriented systems
an instance
f return
oriented design
class definitions
class class
declaration of
attached to
the methods
the declaration
preferred client
in bad
class used
demeter the
created directly
class version
information restriction
none implements
karl lieberherr
self lookup
minimization version
class bookssec
class bookidentifier
parse rulename
lookupparse rulename
j lieberherr
classes used
library class
parts none
rulename parsedetails
rulename defmethod
software engineering
class of
is list
class hierarchy
method s
adherence to
f public
class library
an object
acm v
class s
s class
communications of
of methods
for object
or ffl
objects created
acm sigplan
law the
of software
rule parsedetails
parsedetails defmethod
extended notation
rulename f
of acquaintance
flavors and
style rules
class book
class grammar
client methods
class microfichefiles
lookup symbol
archive archive
argument class
preferred suppliers
reference section
sept 1990
supplier objects
immediate parts
parsedetails c
parse symbol
fragment uses
g class
supplier object
interface class
rulename send
archive has
c case
the immediate
oriented programs
a part
on software
message f
style for
ffl b
class documents
of grammar
s preferred
rule lookup
object of
classes are
a program
the preferred
programmer might
variable class
return type
on aspect
the minimization
any object
a client
compile time
the responsibility
c has
the instance
in object
are written
class to
software development
aspect oriented
the extended
of arguments
to method
to declare
in good
b is
classes this
hiding the
given method
program fragment
method the
written in
the software
methods the
law of demeter
the law of
of the law
has parts class
the demeter system
an instance variable
part class of
the strict version
a part class
rulename type symbol
object oriented program
the law in
a preferred supplier
of demeter is
object oriented programming
the law is
of the demeter
acquaintance class of
book book f
the law s
class of c
send send self
type symbol send
an acquaintance class
attached to class
c has parts
is list repeat
object oriented systems
is a part
the class dictionary
object oriented design
class c has
in the declaration
a client of
the object form
to a method
the declaration of
object oriented software
for object oriented
of class a
to the law
in the method
send self lookup
objects created directly
grammar parse rulename
parts none implements
preferred acquaintance class
in bad style
s class form
using the law
adherence to the
defmethod grammar parse
has parts none
flavors defmethod grammar
c void grammar
and the classes
the law the
symbol send send
lookup rulename parsedetails
a class used
class c case
self lookup rulename
object version of
the class form
declaration of an
class b is
lookup rulename type
preferred supplier classes
the object version
supplier to m
none implements interface
version of the
the acm v
that the law
is a preferred
following the law
the instance variables
communications of the
method m is
of the method
the class hierarchy
is a client
number of arguments
the method the
in object oriented
on software engineering
class archive has
rulename parsedetails defmethod
interface class c
object form the
acm v 33
defmethod grammar lookup
of demeter the
the classes used
parse rulename type
a supplier to
of preferred supplier
immediate parts of
preferred supplier to
the acquaintance classes
lookup symbol rulename
parts class archive
of acquaintance classes
grammar parse symbol
grammar lookup rulename
method is attached
preferred client methods
parsedetails c void
parse symbol rulename
the immediate parts
class archive class
f g class
supplier classes to
parsedetails defmethod grammar
ffl b is
book f g
instance variable class
33 n 9
class used in
dependencies between classes
the extended notation
is a supplier
to method m
void grammar parse
implements interface class
archive has parts
rule lookup rulename
grammar lookup symbol
strict version of
of class definitions
created directly in
program fragment uses
class version of
law s class
book f return
symbol rulename f
in good style
the minimization version
a preferred acquaintance
b is a
object oriented programs
of class c
an object of
structure of complex
conference on aspect
aspect oriented software
by the law
member of class
method must be
on aspect oriented
any object oriented
the programmer might
oriented software development
which the method
a given method
are written in
class c if
number of methods
an object oriented
of the acm
software engineering v
of a class
sigplan notices v
transactions on software
acm sigplan notices
v 33 n
of the class
the development of
to an object
the object oriented
called the law
referencesec has parts
paper are written
sends function calls
part of hierarchy
instance variable of
construction class definition
acquaintance classes are
number of acquaintance
the uses relation
rule flavors defmethod
first method into
acquaintance classes the
or libraryofcongress class
defmethod rule parsedetails
to methods and
abstract syntax of
encodes the ideas
class form the
program which appears
and the programmer
lookupparse rulename defmethod
or ffl the
class b has
be a preferred
c void c
software is as
immediate subparts of
is an acquaintance
rules that constrain

corpus/krapavin2000-test/624907.txt
zeroin
decisions
maintenance
specialization
delocalized
reuse
interleaving
048
068
tol1
encapsulation
086
program
documentation
programmer
043
henshaw
049
software
xm
statements
078
buss
decision
basili
grade
fb
records
erich
037
confront
044
064
printout
077
zannier
rugaber
092
interdependencies
abs
sigsoft
fc
facilitated
parameterize
examination
spencer
053
carmen
mnemonic
028
031
abstraction
engineering
specifications
reverse
designer
fa
pieces
maurer
mills
012
flow
stack
understand
architectural
serve
documenting
pushdown
085
toronto
loop
centre
interrelated
plans
reflects
1993
ontario
rationale
comprehension
generalization
languages
decomposed
diagnostic
fragments
thought
segments
notes
collaborative
reconstruct
050
programmers
understanding
lines
save
intent
interpolation
ada
logarithms
abstractions
constructs
activities
manipulated
library
effort
recompute
likewise
prolog
students
ip
developers
developer
hiding
altered
082
cesar
kamalakar
interviews
soloway
accidently
017
ornburn
kenny
blackburn
079
fpd
unwary
hodfa
leblanc
jahnke
prado
webster
balzer
troster
homogenizing
shull
renovationan
knowledgable
marovac
lanubile
verhoef
klint
029
feather
nebulous
tilley
093
concerted
gallimore
059
intrude
karlapalem
hausi
sampaio
chiasson
1118
dak
storey
alternatives
desire
year
express
compensate
frank
invalid
adjustment
fortran
debugging
functionality
computations
responsible
decomposing
structuring
mountains
081
undocumented
herrera
intertwine
022
057
couched
engenders
lengthening
julio
653
leite
recon
analyzable
cataloging
filippo
biggerstaff
reintroduced
variously
forrest
016
s2
interleaved
code
stages
easier
canada
the program
design decisions
design information
of design
and reuse
reverse engineering
a program
design decision
software engineering
fa fb
software maintenance
this practice
decision to
maintenance and
control flow
on lines
delocalized plans
program indicates
fb and
erich buss
in zeroin
lines 048
john henshaw
the programmer
programming languages
the decision
to understand
encapsulation is
library function
program is
programming language
into pieces
and fc
and specialization
programmer must
examination of
sigsoft software
notes v
engineering notes
on collaborative
program development
advanced studies
acm sigsoft
the variables
generalization and
for design
collaborative research
the design
to express
an if
software reuse
line 068
043 if
and mills
077 078
pushdown stack
documentation to
is building
transformation approaches
maintenance programmer
lines 031
and xm
048 and
representation must
decisions have
length array
design recovery
one construct
confront the
and 049
design ideas
test made
carmen zannier
interleaving by
maurer a
write statements
restricted one
spencer rugaber
invalid records
tol1 go
if abs
frank maurer
conditional adjustment
semantic problems
interrelated decisions
buss john
practice can
designing documentation
reuse activities
031 037
for delocalized
each refinement
of zeroin
debugging printout
068 are
numeric grade
toronto ontario
in code
centre for
assignment statements
serve to
conference of
the centre
specifications are
to save
decomposed into
decisions are
these lines
representation is
of code
flow analysis
decision then
variables fa
designer is
and procedure
for maintenance
shorter and
version s2
structuring a
program understanding
computing logarithms
the counter
a representation
thought of
a description
decisions in
of software
for advanced
the component
the designer
save the
ontario canada
next state
breaking a
basili and
of specialization
the debugging
target machine
computations may
decisions can
programming constructs
languages provide
and interleaving
a variable
to reconstruct
studies on
either is
gets its
information hiding
survey and
to 70
and techniques
the alternative
decision is
the root
this program
the programming
implemented by
variable name
program variables
recognized the
the desire
often useful
its more
decisions that
s2 is
a specialization
early stages
easier to
the control
of as
and decomposition
encapsulation and
of generalization
value only
approaches and
an examination
decision in
program specification
reflects the
limited set
to parameterize
made during
some program
interpolation and
and relation
the architectural
and lines
modify a
representation for
effort required
several approaches
procedures and
recovery for
on software
counter is
interleaving of
in prolog
to recompute
the variable
of the program
of design decisions
maintenance and reuse
the decision to
the control flow
representation for design
of design information
fb and fc
program indicates that
fa fb and
for design information
the program indicates
generalization and specialization
an if then
the programmer must
design decisions in
easier to understand
of a program
software engineering notes
engineering notes v
sigsoft software engineering
acm sigsoft software
a program is
studies on collaborative
advanced studies on
centre for advanced
on collaborative research
for advanced studies
of the centre
of the variables
examination of the
the centre for
to save the
toronto ontario canada
the programming language
conference of the
compensate for delocalized
documentation to compensate
encapsulation and interleaving
save the result
the designer is
some program transformation
lines 048 and
reverse engineering and
trying to understand
design decisions can
value only from
specifications are often
designing documentation to
survey and classification
of line 068
decision to use
and modify a
fixed length array
design information to
in program understanding
frank maurer a
gets its value
function and relation
then a program
the debugging printout
the library function
design information must
representation must be
classification of some
this practice can
function that when
buss john henshaw
example of generalization
tests on lines
transformation approaches and
categories of design
of value to
composition and decomposition
048 and 049
understand the program
framework for program
a program specification
approaches and techniques
and reuse activities
that when given
for program development
and reuse the
design recovery for
for delocalized plans
erich buss john
variables fa fb
recovery for maintenance
basili and mills
data and procedure
of some program
input and which
tol1 go to
lines 031 037
program transformation approaches
go to 70
test made on
of software engineering
a description of
implemented by a
thought of as
have a cost
harder to understand
the alternative to
the variables fa
made on line
the tests on
is the decision
these lines are
decisions can be
version s2 is
makes the resulting
a design decision
for maintenance and
control flow of
its value only
counter is used
and q on
the program the
of the design
the program and
variables a b
the variables a
a survey and
program is shown
when given a
responsible for computing
software maintenance and
a program from
during the design
is often useful
in this program
by a fixed
is a specialization
a cost in
side of line
can be thought
the early stages
the counter is
and classification of
a fixed length
is a design
early stages of
the program is
effort required to
the design process
a limited set
an examination of
decomposed into two
a representation for
limited set of
by a more
if then else
be thought of
number of records
other parts of
flow of the
be seen to
indicates that it
is an example
the programmer can
p and q
to understand and
the problem domain
data types and
it is easier
used during the
a more general
another example of
to express a
structure of the
a framework for
of a more
values of the
the next state
proceedings of the
to reconstruct the
program can be
that have been
of the software
is easier to
to compensate for
be detected by
parts of the
is decomposed into
software engineering p
description of a
the distinction between
can be detected
is controlled by
the program in
of as a
architecture of the
to make the
as a whole
be described by
example it is
design of a
software engineering v
a mechanism for

corpus/krapavin2000-test/626675.txt
instruction
branch
sequencing
pipeline
instructions
branches
slots
inline
insertion
fetch
predicted
target
scratched
refill
redirects
pif
prediction
successors
incorrectly
compiler
pipelined
fetched
mcfarling
iti
delayed
expansion
hardware
unlikely
ref
inclusively
hennessy
risc
squashing
sif
interrupt
ill
likely
restructuring
exception
threshhold
benchmarks
mips
compile
processors
cycle
ps
fallthru
88000
interrupts
redirect
deep
address
pipelining
delay
buffers
slot
timing
sequential
illinois
cycles
addresses
static
freeze
incorrect
unconditional
pipelines
branching
contract
profile
cyclone
microarchitecture
r2000
processor
code
frequency
clock
036
stage
assisted
stages
freezes
reload
af
inserted
clean
n00014
ex
801
efficiency
executed
superpipelined
originals
wisq
nonproductive
61801
uncond
refilling
8809478
jsep
restartable
0656
minicomputer
hoevel
iclass
locations
fetches
tradeoffs
nasa
correctness
exceptions
accuracy
diagram
successor
hps
1270
rupt
bison
opcode
spur
crisp
nonstop
cs
executing
compiling
execution
fill
repair
fetching
aerospace
espresso
conte
motorola
hwu
vax
inputs
microprocessor
program
lemma
return
microcode
aeronautics
percentage
programs
arc
architecture
predicting
780
stanford
ncr
checkpoint
nag
threshold
predict
superscalar
machines
impact
613
subdividing
ao
mip
ensures
reaches
emerging
issue
champaign
folding
naval
urbana
administration
saved
peak
chip
correctly
subsequent
supercomputer
save
cancel
infrequently
filled
visited
unix
adjusted
cad
profiling
startup
cond
duplicate
buffer
scalar
resume
architectures
rate
office
inserting
dynamic
counter
issuing
column
ibm
format
target insertion
inline target
sequencing pipeline
instruction sequencing
the sequencing
the instruction
instruction fetch
likely branch
likely branches
original address
code expansion
i n
insertion slots
the branch
instruction issue
predicted successors
multiple instruction
branch prediction
incorrectly predicted
a likely
branch target
branch slots
sequencing efficiency
a branch
instruction sequence
per instruction
the pipeline
instructions in
of inline
delay slots
ref ill
s t
a f
instructions to
of branches
redirects the
branch instructions
the instructions
pipelined processors
code restructuring
predicted branch
sequential instruction
order execution
exception return
insertion is
are true
an unlikely
instruction i
subsequent instructions
target buffers
mcfarling and
sequencing cost
delayed branches
pipeline implementation
unlikely branch
next sequential
be scratched
interrupt exception
deep pipelining
slots for
an original
branches in
an instruction
branches the
address of
branch the
target address
and hennessy
the benchmarks
ps i
r t
the compiler
it i
code size
n inclusively
clock frequency
execution machines
ex stage
hardware methods
branch direction
delayed branching
sequential locations
an incorrectly
dynamic instructions
branch between
branch i
pif performs
impact i
fetched from
compile time
dynamic instruction
successors of
instruction is
of branch
h 0
of slots
with inline
timing diagram
prediction accuracy
c compiler
of instruction
pipeline is
branches to
predicted successor
fetch pipeline
true proof
unlikely branches
with squashing
fetch algorithm
scratched from
branch delay
branches into
per cycle
branch is
the code
between i
address is
not taken
of instructions
branches with
slots are
pipelining and
also true
and branch
branch to
branch instruction
compiler implementation
slots the
8 e
instruction execution
pipeline the
cycles per
the prediction
compiler and
the address
in pipelined
cs i
instruction can
the dynamic
the static
the clock
the hardware
pipelines with
that inline
pipelined instruction
into branch
compiler assisted
taken pif
fallthru i
target instruction
freeze cycles
target addresses
branches among
no likely
incorrect branch
sequencing rate
redirect the
time branch
relative sequencing
taken then
unit processors
expansion control
are scratched
branch redirects
return from
and pipeline
under contract
each branch
the predicted
i 0
be fetched
in cycle
the ex
t are
and multiple
successors in
time code
i s
n is
machine language
sequencing for
insertion a
static code
target buffer
fetch address
cycle this
if i
is fetched
and s
of order
profile information
pipeline for
branches are
cycle t
cost per
and i
the fetch
all instructions
contract n00014
of likely
inline target insertion
the sequencing pipeline
multiple instruction issue
the instruction fetch
a likely branch
of inline target
i n is
instruction sequencing efficiency
the instruction sequencing
i s t
is a likely
the instruction sequence
redirects the instruction
and s t
instructions in the
incorrectly predicted branch
of order execution
t are true
of the sequencing
target insertion is
i n 1
the subsequent instructions
an original address
and multiple instruction
branch target buffers
if i n
predicted successors of
between i n
an unlikely branch
mcfarling and hennessy
instructions to be
in the sequencing
t and s
the code expansion
branch between i
pipelining and multiple
order execution machines
the impact i
an incorrectly predicted
of instruction sequencing
i n inclusively
the next sequential
the clock frequency
deep pipelining and
with inline target
r t and
out of order
s t are
from the pipeline
number of slots
cycles per instruction
if r t
predicted successors in
the insertion slots
figure 8 e
sequencing cost per
delayed branches with
the predicted successors
sequential instruction fetch
i c compiler
instruction fetch algorithm
the ex stage
per cycle this
scratched from the
and pipeline implementation
compiler and pipeline
instruction fetch pipeline
cost per instruction
the branch direction
branches with squashing
impact i c
compile time code
a f i
number of instructions
is an original
r t 1
that r t
s t will
compare and branch
redirect the instruction
from the sequencing
that inline target
target insertion a
under contract n00014
s t 1
code expansion control
original address of
pipelined instruction fetch
instruction sequencing for
sequencing pipeline the
cost of branches
branches among all
relative sequencing cost
likely branch i
a dynamic instruction
static code size
the original address
is an unlikely
of code expansion
of likely branches
incorrect branch prediction
the static code
the delay slots
interrupt exception return
time branch prediction
time code restructuring
compile time branch
its original address
taken pif performs
ps i 1
fetched from its
the address of
is also true
is not taken
the instructions in
of a branch
target address is
in pipelined processors
successors in the
from its original
that the instruction
a threshold value
branch target buffer
branch prediction accuracy
t will be
instructions per cycle
for pipelined processors
be fetched from
of instructions to
instruction can be
a branch is
and i 0
reducing the cost
is fetched from
else if i
n is not
branches in the
f and i
by inline target
predicted successor of
an insertion slot
of branch prediction
no likely branch
performs a f
interrupts and exceptions
instruction issue and
better performance and
the timing diagram
predict the branch
insertion is correct
pif performs a
sequencing for pipelined
because i n
but is taken
likely branch between
next sequential instruction
sequencing pipeline for
multiple functional unit
not a branch
reaches the end
next n sequential
insertion slots of
the dynamic instructions
the branch decision
instruction is 1
a branch redirects
ref ill is
was no likely
insertion slots are
to be scratched
target insertion the
machine language program
code restructuring algorithm
case the branch
branch redirects the
functional unit processors
into branch slots
n predicted successors
may be scratched
also true proof
case 2 i
a f else
insertion slots see
instruction fetch the
target insertion and
instruction fetch unit
target insertion to
cs i n
the benchmarks the
likely branch the
stage in cycle
from an original
the alternative address
for pipelines with
branch prediction strategies
the relative sequencing
instruction sequencing mechanism
predicted branch between
because there was
the branch slots

corpus/krapavin2000-test/626722.txt
precision
mlp
bits
jamming
retrieving
learning
neural
neurons
eq
decimal
layer
neuron
rounding
propagation
weight
variance
squared
truncation
hidden
weights
propagated
bit
nonlinear
1w
f1w
perceptron
error
statistical
forward
i3
oe
activation
dive
chops
errors
training
ffl
calculation
curve
regression
operators
convergence
squares
fx
statistically
descent
hardware
updating
derivatives
derivative
delta
layers
evaluations
compound
finite
stages
lowest
r01
alippi
dives
eqs
multilayer
operator
ij
sign
cesare
chopped
fffl
network
gradient
multiplication
j0
propagates
fffi
stage
inputs
evaluated
undertaken
truncating
affine
02
central
interleaved
successive
contributing
sigmoid
random
ratio
silicon
outputs
xor
uniformly
converges
artificial
fw
formulated
sums
attained
seok
unwisely
jammed
k04
delgado
wffl
749
vassiliadis
propensity
yongsoon
r09
pizer
hiddens
stamatis
briozzo
truncated
xy
simplified
update
invoking
analytical
learn
discrete
sources
taylor
fy
trained
indicator
propagating
approximated
multiply
synaptic
j3
k3
0x
fpga
frias
luciano
soft
ffi
back
08
accuracy
divert
bum
wx
1049
precisions
momentum
fyg
off
256
lations
foe
740
060
accumulator
th
vlsi
1045
disturbance
dallas
dating
ko
leaning
dashed
backward
devoted
degradations
guideline
intermediate
generates
vs
sigmoidal
simu
versatile
477
connecting
predicted
output
concluding
interconnecting
020
systolic
converge
download
electronics
iterative
limit
drastic
inability
caused
unified
employed
mac
manipulations
intent
wseas
products
surface
impact
summed
finite precision
precision computation
forward retrieving
precision error
calculation graph
an mlp
back propagation
the finite
statistical evaluation
propagation learning
ffl y
random variables
and variance
weight updating
error generated
neural network
independent random
mean and
error ffl
retrieving and
lowest order
average sum
precision analysis
weight bits
the decimal
bits to
precision errors
16 bits
of finite
eq 9
discrete random
output delta
y i3
2 layer
one sign
successive operators
hidden delta
bit value
precision ratio
the weights
ffl x
the error
of learning
8 bit
squares of
weight update
average squared
the forward
the statistical
the squares
limit theorem
central limit
propagated error
of back
sign bit
r th
bit 3
simplified notation
bits assigned
total finite
new lowest
normal curve
truncation jamming
delta computation
ffl 1w
precision hardware
convergence stage
with range
statistically evaluated
bit weights
evaluation values
the output
output layer
network algorithms
bits for
j g
right of
computation of
regression problem
with simplified
curve shows
order bit
i g
of bits
l j
hidden layer
the 2
different stages
partial derivatives
24 bit
statistical properties
ij g
gradient descent
graph for
desired and
3 bits
decimal with
retrieving of
generates error
range 08
ffl w
th neuron
squared figure
back propagated
neuron at
network converges
fx l
bits average
q lowest
learning convergence
the retrieving
descent search
transformation interleaved
layer mlp
stages of
8 bits
and weight
the q
the back
high precision
for artificial
the hidden
and actual
the network
r 02
ffl oe
possible error
th layer
squared difference
bits one
th place
mlp the
actual outputs
the mean
artificial neural
of independent
the learning
of weight
random variable
ffl 3
low precision
order bits
02 3
output neuron
error values
in eqs
uniformly distributed
from eq
convergence and
and accuracy
error in
of error
bits of
the calculation
y y
neurons of
affine transformation
multilayer perceptron
activation values
layer perceptron
the statistically
ratio for
a nonlinear
oe i
activation function
problem after
neurons and
sum of
four different
oe 2
an 8
error with
in eq
the computation
2 r
the central
error for
using high
y i
can again
interleaved with
for neural
of bit
variance of
iterative learning
rounding techniques
precision weight
y j0
evaluated average
layer weights
training pattern
values fx
most neural
these error
9 ffl
jamming or
similar partial
retrieving phase
neurons between
input errors
the finite precision
finite precision error
finite precision computation
of finite precision
the forward retrieving
back propagation learning
of an mlp
mean and variance
independent random variables
bits to the
the statistical evaluation
calculation graph for
of the decimal
the error generated
finite precision analysis
finite precision errors
average sum of
the squares of
of the squares
a 2 layer
l j g
one sign bit
the calculation graph
forward retrieving and
finite precision ratio
the 2 r
stages of learning
2 r th
of the finite
of independent random
neural network algorithms
for the weights
central limit theorem
right of the
the back propagation
total finite precision
new lowest order
precision ratio for
statistical evaluation values
with simplified notation
convergence and accuracy
a normal curve
evaluation values of
the total finite
bits assigned to
lowest order bit
high precision computation
precision analysis of
the output delta
statistical evaluation of
3 bits to
precision computation of
between the desired
sign bit 3
precision error for
number of bits
the mean and
the central limit
of the error
desired and actual
the average sum
different stages of
the desired and
the output layer
for artificial neural
the right of
the partial derivatives
the computation of
to the finite
retrieving and back
four different stages
gradient descent search
simplified notation is
to finite precision
bits average squared
bit 3 bits
precision computation on
and actual outputs
q lowest order
and back propagation
in eq 9
affine transformation interleaved
possible error values
th neuron at
bits one sign
average squared figure
forward retrieving of
error generated by
decimal with range
order bit in
r th place
learning convergence and
lowest order bits
neuron at the
transformation interleaved with
output delta computation
retrieving of an
notation is shown
a discrete random
the new lowest
the decimal with
the statistically evaluated
using high precision
finite precision hardware
2 layer mlp
the q lowest
error ffl y
fx l j
weight bits average
actual outputs of
back propagated error
shows the statistical
the network converges
r 02 3
of the 2
and variance of
ratio for the
to the right
in a 2
due to finite
two independent random
discrete random variable
problem after the
of back propagation
discrete random variables
neurons of the
graph for the
in the forward
of the back
an 8 bit
error at the
sources of error
i g and
layer and the
statistical properties of
for the forward
given in eq
after the network
sum of the
with mean and
multiplication of the
in the 2
bit in the
artificial neural networks
of the output
formulated as a
generates error which
8 bit weights
nonlinear activation function
an output neuron
the jamming operator
precision error ffl
2 d regression
which most neural
regression problem after
in a hidden
16 bits one
being of equal
can again compute
first hidden layer
squared differences between
jamming and rounding
error values being
8 bit value
back propagation of
the retrieving phase
i th neuron
derivative evaluations using
in an output
mlp four different
hidden layer and
the nonlinear activation
12 bits to
weight bits finite
values being of
probability therefore 1
precision error in
computation of back
ij g and
jamming or rounding
by which most
chops off the
of mean and
precision error analysis
error equations are
values fx l
error generation and
updating error ffl
products of independent
bits of weights
shows that of
weight updating error
say k bits
fffi l j
fx 0 i
f1w l i
properties of independent
of bits for
weights connecting the
dashed curve shows

corpus/krapavin2000-test/626771.txt
reconfigurability
lr
embedding
reconfiguration
ea
reconfigurable
dr
lx
reliability
ft
mft
failed
arrays
redundant
graphs
subgraph
faulty
systolic
family
fault
fi
finitely
pe
dimensional
reliable
lattice
hole
hayes
fr
tolerant
vertical
nodes
ie
node
array
distance
architecture
working
vlsi
subsegments
web
dimension
locally
wsi
webs
orthogonal
wavefront
reconfigure
dynamic
es
adversary
cell
lattices
surrounded
switches
delta
changed
inner
lemma
failures
obstacle
euclidian
gas
isomorphic
tolerance
spare
ith
central
module
image
classes
pile
edges
semiring
subsegment
vertex
gammaj
claim
2c
contracting
impossible
segment
adjacent
reconfigured
border
defects
labeling
dimensions
periodic
sacrificing
projected
loop
hyperplane
architectures
connections
interior
degree
constructions
informed
runtime
resp
maintain
inform
indices
2nodes
zag
labelsecdef1
ineqality
triplicating
zig
processors
regarded
polygons
images
contiguous
edge
diagonal
contract
replacing
diogenes
avionics
ffln
connected
polygon
gamma1
static
middle
replaced
theta
chordal
fabrication
wafer
consecutive
sup
infinite
redundancy
squares
failure
replications
4m
contracted
embedded
regular
tmr
planarity
mapped
connect
generality
triangle
replaces
chooses
defective
stricter
gamma
passing
adaptability
reconfiguring
interprocessor
cells
quadruple
mk
fewest
digraph
x6
pick
neighboring
paths
wires
logn
indexed
halves
struc
corollary
replace
ij
copy
eral
pipelines
replacements
rays
convex
cn
insist
doubly
neighbor
impossibility
repetitions
confined
nth
connection
contradiction
processor
satisfies
repair
horizontally
flight
vertically
column
empty
labelling
dynamic graphs
embedding architecture
application graph
dimensional dynamic
dynamic graph
g n
g i
lr reliable
d dimensional
g r
locally reconfigurable
k nodes
reduced graph
initial embedding
reliability fi
reliable with
g a
redundant graph
be lr
have failed
i a
graph g
a family
an embedding
finitely reconfigurable
local reconfigurability
ft g
nodes in
n a
dimensional orthogonal
reconfigurability and
distributed reconfiguration
inner central
of reconfigurability
family of
in g
with reliability
n h
of g
n r
working subgraph
constant fi
empty classes
is lr
linear arrays
total distance
a d
k n
dr d
orthogonal lattice
working nodes
fi proof
g 0
dr k
is finitely
0 c
fi such
fault tolerant
of nodes
distance between
nodes have
f k
m nodes
pe s
ea is
architecture is
reconfiguration algorithm
central class
original working
failed we
es g
the distance
be faulty
after k
a 0
the redundant
r is
one dimensional
embedding function
fixed level
static graph
vertical lines
x r
single loop
graphs there
and g
two dimensional
of reliability
two nodes
one dimension
in c
k ft
redundant graphs
mft g
an ea
and lx
lx 0
h ft
node single
ea cannot
dimensional reduced
line lx
orthogonal lattices
reconfigurability for
ft n
dimensional web
ith application
lx i
line along
finite reconfigurability
hole of
n node
node x
at most
one node
image of
node of
of redundant
graph is
delta f
maintain both
to reconfigure
no embedding
n nodes
in s
nodes that
linear array
a hole
when g
vertical line
segment s
is fr
array processors
a is
fault tolerance
x i
node in
the nodes
arrays in
vertex set
1 dimensional
the obstacle
d c
a line
lemma 4
distance dr
hayes h
a nodes
reconfigurability dr
embedding strategy
reconfigurable if
lr if
that ea
spare node
after reconfiguration
vlsi wsi
not lr
of systolic
this ea
lines lx
isomorphic subgraph
one greater
satisfies 5
replacing nodes
classes thus
lattice gas
cell dynamic
redundant nodes
dimensional webs
distance cost
infinite graphs
wavefront arrays
working node
obstacle o
dr nodes
empty class
any spare
lx 1
each node
set v
the embedding
for g
any distributed
we know
an n
is locally
of d
each g
given g
the application
i r
the adversary
between node
d dimensions
a g
v x
of k
there exists
be changed
fi 2
g i a
g n a
g n r
dimensional dynamic graphs
the application graph
is a family
an embedding architecture
lr reliable with
a family of
reliable with reliability
embedding architecture is
g 0 c
with reliability fi
of d dimensional
dimensional dynamic graph
g r is
and g r
be lr reliable
d dimensional dynamic
nodes have failed
family of d
degree of reconfigurability
a d dimensional
is finitely reconfigurable
a constant fi
dr k n
constant fi such
the total distance
number of nodes
in g n
the dynamic graph
cannot be lr
ft g n
level of reliability
after k nodes
to be faulty
g a is
of g n
nodes in g
a d c
fi such that
d c a
r is a
exists a constant
graphs there exists
architecture is lr
reliability fi proof
one dimensional dynamic
is locally reconfigurable
family of linear
dimensional orthogonal lattice
distributed reconfiguration algorithm
d k n
of dynamic graphs
hole of size
application graph g
dynamic graphs there
node in c
two dimensional orthogonal
dynamic graph g
inner central class
of linear arrays
the distance between
a fixed level
fixed level of
a hole of
graph g n
function of k
nodes of g
nodes in the
theorem 4 3
i a is
in g 0
vertex set v
each node of
c a d
dimensional reduced graph
the initial embedding
local reconfigurability and
reconfigurability and reliability
k nodes have
es g i
d dimensional reduced
n h r
both local reconfigurability
h ft n
delta f k
d dimensional web
node single loop
dynamic graphs and
vertical line lx
any initial embedding
the ith application
k ft g
is lr reliable
reliability fi 2
that no embedding
when g a
a reduced graph
non empty classes
the inner central
g n h
1 dimensional dynamic
a line along
the redundant graph
dimensional orthogonal lattices
no embedding architecture
ith application graph
two dimensional dynamic
have failed we
any distributed reconfiguration
the original working
dr d k
ea cannot be
reconfigurability and a
not in s
an n node
graph g 0
given g a
family of two
g i r
most 2 delta
complexity of any
d dimensional orthogonal
a g r
set v x
our claim is
a dynamic graph
a and g
between two nodes
of nodes that
of g i
g a g
g a and
of any distributed
nodes in one
all the nodes
a is a
and a fixed
the image of
n nodes in
of nodes in
lemma 3 2
a and b
a one dimensional
in the proof
be a family
get a new
working nodes in
between original nodes
mft g i
of redundant graphs
of reconfigurability dr
2 g a
g j r
reduced graph g
delta t d
lx 0 and
static graph g
dynamic graph must
an lr reliable
surrounded by non
original nodes and
arrays and g
ft g i
0 and lx
called dynamic graphs
than the application
n m classes
distance between original
with distance dr
4 k n
can be lr
total distance between
for dynamic graphs
given an embedding
distance cost of
be faulty the
the reduced graph
one greater than
d dimensional webs
n a to
this ea is
any spare node
cell dynamic graph
a nodes have
that ea cannot
for g i
hayes h ft
empty classes thus
a redundant graph
least n m
fi proof as
total distance cost
linear arrays and
least one greater
locally reconfigurable if
original working subgraph
most m nodes
application graph is

corpus/krapavin2000-test/626779.txt
fault
dependability
injection
coverage
nac
ftams
faults
amp
injected
tolerance
tolerant
ftam
readouts
lsc
mtff
assertion
activation
validation
occurrence
esc
asymptotic
arlat
failure
dependable
predicate
fault_activated
error_signalled
impact
transition
faulty
activated
estimator
estimation
characterizing
featuring
experimental
analytical
architecture
delta
ftd
dormancy
testbed
host
duplex
tolerated
powell
mechanisms
esprit
estimators
self
nominal
markov
measures
v2
interactions
depicts
target
jean
defective
designates
aimed
cumulative
forecasting
fantechi
wonnacott
crouzet
bull
laas
la3
ferranti
martins
mtffnode
coverages
procured
eliane
nacs
error_not_signalled
milanova
fxa
coincident
extraction
testing
confidence
experiment
detection
ryder
avionic
ftmp
bondavalli
deficiency
axiomatic
predicates
reliability
rate
proportion
silent
yves
confinement
hardware
voting
percentages
experiments
instant
checking
carried
configuration
gil
censored
unobserved
pessimistic
removal
extractions
ana
rates
tolerate
limits
absorbing
configurations
prototype
optimistic
estimates
intermittent
repairing
latency
principal
pins
replicas
catastrophic
modeling
helped
refine
noting
estimated
exemplified
computers
transitions
characterizes
calibration
prominent
operational
conditional
sensitivity
temporal
estimations
determination
protocol
errors
detected
latent
repair
error
worth
fu
validating
impacts
expression
bold
proposing
constitutes
establishes
prob
transient
multiplicity
concerning
normalized
2252
fabre
diagnose
xubin
erroneous_result_delivered
scientifique
readout
kalbarczyk
leber
que
agu
midi
prori
flaviu
fertilization
la2
jenn
vaxcluster
latella
maft
steininger
spek
fault_not_activated
pdcs
baraza
messaline
1201
fuchs
beus
triplex
rabjac
automatique
equipotential
plc
precompetitive
fault injection
the fault
the coverage
dependability evaluation
the ftams
fault occurrence
fault tolerance
injection test
delta 4
of fault
test sequence
fault tolerant
asymptotic coverage
occurrence process
the dependability
coverage parameters
injection experiments
a fault
target system
assertion of
self checking
tolerant system
the nac
tolerance process
injected faults
observation domain
experimental evaluation
the delta
the experimental
4 architecture
lsc nac
experimental measures
esc nac
failure rate
tolerant systems
l l
evaluation of
estimation of
the injected
injection for
nac amp
dependability measures
characterizing the
coverage of
error detection
g see
for dependability
checking mechanisms
coverage time
the faults
the asymptotic
impact of
the target
amp software
the amp
jean arlat
distributed fault
of assertion
the readouts
experimental graph
duplex architecture
amp v2
coverage function
faults were
experiments that
validation of
coverage is
the experiments
c t
system dependability
tolerant architecture
host computer
the mean
t p
the estimation
the host
of figure
were carried
carried out
conditional coverage
fault forecasting
coverage times
the ftam
ftam coverage
of dependability
expression 10
dependability validation
nac the
variable characterizing
the lsc
4 project
confidence limits
injection based
tolerance algorithms
analytical dependability
hardware self
on dependability
the mtff
injection that
ftams in
injection on
ftams with
equivalent failure
tolerance processes
dependability analysis
mean coverage
random variable
evaluation method
the observation
depicts the
the evaluation
the assertion
instant of
predicate p
for fault
the activation
the instant
occurrence and
of experimental
on fault
transition 1
target fault
activated as
injection is
fault removal
the esc
node failure
near coincident
non infinite
coverage c
behavior of
activation of
the considered
aimed at
evaluation and
cumulative distribution
0 t
and fault
the random
designates the
and coverage
of asymptotic
ratio l
as errors
and analytical
to account
an error
in 0
analytical modeling
faulty node
that establishes
process and
the validation
experiments for
a predicate
l n
non faulty
based evaluation
asymptotic value
the redundant
faulty nodes
computers v
that were
of system
on computers
faults in
obtained for
the model
the esprit
the upper
of faults
time distribution
main characteristics
and mechanisms
results obtained
and experimental
the cumulative
worth noting
an experiment
testing of
l a
mean time
estimated by
e t
the equivalent
occurrence rates
fault dormancy
g mtffnode
ftams this
apparently tolerated
time censored
procured by
of ftam
the nacs
mtff of
activation modes
intermittent faults
martins jean
task replicas
eliane martins
of the ftams
of the coverage
injection test sequence
the delta 4
fault injection test
the fault occurrence
the fault tolerance
fault injection experiments
a fault injection
the target system
fault occurrence process
of the fault
fault tolerant system
fault tolerance process
the fault injection
assertion of p
the observation domain
dependability evaluation of
the dependability evaluation
delta 4 architecture
l l l
fault tolerant systems
estimation of the
of a fault
the experimental evaluation
the asymptotic coverage
model of figure
fault injection for
self checking mechanisms
the coverage parameters
for the coverage
of the target
e g see
the coverage of
of fault tolerance
coverage of the
impact of the
of the delta
of the amp
fault occurrence and
nac amp v2
tolerance process and
fault tolerant architecture
of fault injection
of experimental measures
p in 0
that were carried
the injected faults
on fault injection
distributed fault tolerant
of assertion of
the random variable
experimental evaluation of
evaluation of the
experiments that were
between the experimental
the instant of
of error detection
to the fault
of the asymptotic
the estimation of
were carried out
of the mean
behavior of the
the amp software
fault injection that
fault injection on
equivalent failure rate
activated as errors
mean coverage time
delta 4 project
variable characterizing the
fault tolerance algorithms
fault tolerance processes
hardware self checking
establishes the link
target system and
asymptotic coverage is
the coverage function
the esc nac
non faulty nodes
f f t
tolerance algorithms and
target fault tolerant
ratio l n
ftams with respect
the ftams in
on the dependability
of the esprit
the mean coverage
random variable characterizing
the ftams with
instant of assertion
of system dependability
esc nac amp
the lsc nac
fault injection is
of the ftam
of the ratio
of the observation
algorithms and mechanisms
in 0 t
the host computer
that establishes the
the ratio l
the evaluation of
a fault tolerant
to account for
of fault tolerant
the main characteristics
based on fault
process and the
the experimental results
the case of
on computers v
figure 2 b
transactions on computers
the model of
in a fault
main characteristics of
activation of the
of p in
link between the
of the considered
mean time to
with respect to
ieee transactions on
the experiments that
can be simply
and the fault
corresponds to the
considered for the
presence of faults
validation of the
the upper bound
the mean time
the impact of
the link between
the cumulative distribution
account for the
c t is
evaluation of dependability
tolerant architecture of
procured by the
from expressions 19
the target fault
evaluation and experimental
derivation of experimental
the mtff of
lsc nac amp
the ftams this
of t d
mtff of one
self checking capabilities
nac the fault
test sequence a
describes the behavior
injection and dependability
such an experiment
fault injection tool
coverage time the
of the nac
experiments for which
temporal parameters of
the ftams to
for dependability analysis
of asymptotic coverage
dependability analysis of
case of fault
states 4 and
and a sets
e t d
modeling for dependability
of expression 13
sequence aimed at
the equivalent failure
hardware error detection
were actually activated
empirical and physical
physical fault injection
coverage modeling for
fault injection based
random variable t
arlat yves crouzet
thus be considered
occurrence and fault
delta 4 distributed
failure rate g
the activation rate
injected faults were
4 distributed fault
dependability evaluation method
typical experimental graph
reliability modeling techniques
and physical models
ftams in the
injection on the
the f set
coverage parameters of
on the delta

corpus/krapavin2000-test/626781.txt
pe
scattering
gathering
fdf
regimen
pes
message
shoulder
schedule
transmission
messages
flit
tap
certified
lag
wakeup
certificates
children
multiport
flits
oe
transmit
certificate
dispatch
stream
tapping
segment
transmitting
nonnull
port
synchronization
certification
schedules
nonleaf
destined
nrf
dispatched
bufferless
broadcasting
spanning
parallelogram
dispatching
trees
relay
child
receives
gap
parallelizing
scheduling
collide
token
networks
streams
parallelograms
segments
tree
buffering
relaying
gaps
protocol
processors
endpoint
root
leaf
orders
communication
originating
hypercubes
toroidal
schultz
juxtaposed
routing
destination
personalized
observes
saad
parent
phases
permutation
optimality
ring
broadcast
interconnection
sending
leftmost
subtree
inequality
noncolliding
multiscattering
moral
taps
fthe
topologies
distant
receiving
nearby
transit
arrival
activities
slant
relays
wit
johnsson
leveled
scat
materially
hypercube
meshes
fl
axis
scatter
network
sends
wherein
visualized
positioned
transmissions
mesh
bhatt
scattered
contrasts
queuing
backwards
units
honor
receive
rings
rooted
indices
resides
modes
indivisible
covering
passively
acknowledges
send
lengths
neighbors
repertoire
phase
arrive
henceforth
paths
equidistant
span
contrasted
tentative
recipient
null
remark
unidirectional
reconfigurable
communicating
specifically
claim
25th
intended
begins
originate
dissemination
received
delaying
pipelining
broadcasts
shadow
breadth
hiding
deadlock
transmitted
responds
ho
interpretation
positions
fraigniaud
wagar
lessening
interlacing
schwabe
amending
tapped
abhiram
jinoo
rationalize
northwest
annexstein
claimclaim
ranade
baumslag
regimens
geppino
descibed
weizhen
bilardi
reckoning
conduit
prearranged
ensue
imen
satifies
northeast
pe p
scattering schedule
p i
message sequence
shoulder tap
certified lag
algorithm shoulder
for gathering
for scattering
fdf scattering
gathering operation
its children
lag time
and gathering
segment x
each pe
of scattering
a pe
message m
sequence m
scattering and
gap free
its message
transmit message
wakeup call
schedule oe
message stream
p 0
single port
the fdf
gathering on
transmission certification
gathering in
gathering schedule
schedule for
messages in
m i
line segment
its certified
shoulder tapping
transmission certificates
fdf regimen
message transmission
a scattering
oe 1
communication regimen
a multiport
message streams
the scattering
communication in
the message
the transmission
the pes
of messages
lag times
dispatch time
scattering schedules
algorithm transmission
root pe
flit of
nonleaf pe
message orders
the messages
destined for
the gathering
a message
transmission time
receives its
the certificates
children s
of processors
length l
c 0
oe 2
optimal scattering
transmitting its
scattering operation
transmission certificate
scattering or
general tree
its wakeup
an fdf
pe of
multiport communication
the synchronization
time for
for m
the dispatch
left endpoint
l i
networks of
the tree
port communication
of communication
of arbitrary
computes its
is optimal
the pe
intended interpretation
line segments
message order
or gathering
time receives
synchronization token
one flit
by pe
general trees
certificates from
free transmission
a transmit
the transmit
dispatch times
regimen is
i children
a wakeup
gathering to
length messages
the certified
parallelizing the
a gap
messages to
optimal algorithm
phase 2
transmission times
in networks
scattering from
observes the
parallelogram of
other pes
of gathering
a gathering
personalized communication
transmission of
spanning trees
s i
space time
the root
i j
spanning tree
and scheduling
the time
i computes
s transmission
a path
c i
optimal for
from its
every message
algorithms for
time c
of algorithm
operation of
phase 3
ff oe
in hypercubes
of message
a schedule
in scattering
toward p
flit message
l flits
flits of
disjoint trees
to relay
certificate from
gathering messages
pe can
pe to
order transmit
regimen the
children p
stream length
that gathering
pe in
pe must
nrf regimen
of spanning
buffering or
scattering operations
scattering time
under schedules
pe sends
child p
schedule fl
pe associated
form segment
be positioned
port regimen
schedules oe
free message
sub 0
certified stream
fdf schedules
scheduling activities
every fdf
p sub
originating pe
receives the
d i
time s
pe p i
algorithm shoulder tap
pe p 0
message m i
scattering and gathering
message sequence m
certified lag time
scattering schedule oe
line segment x
length l i
fdf scattering schedule
scattering schedule for
its certified lag
the fdf regimen
of scattering and
algorithms for scattering
the time for
the single port
transmit message orders
segment x i
of algorithm shoulder
a gap free
algorithm transmission certification
certified lag times
gathering on a
and gathering in
of its children
time for gathering
its wakeup call
the message stream
algorithm for gathering
each pe p
communication in which
of its message
the root pe
a pe p
port communication regimen
length n i
an fdf scattering
for gathering on
single port communication
networks of processors
p i computes
of p i
from its children
the intended interpretation
form of communication
p i s
for the operation
computes its certified
the dispatch times
d i children
optimal scattering schedule
networks of arbitrary
every message sequence
intended interpretation is
transmit message order
gathering to the
gap free transmission
scattering or gathering
operation of gathering
a wakeup call
operations of scattering
a transmit message
i computes its
a gathering operation
the gathering operation
in a scattering
root pe of
the message streams
fdf scattering schedules
the transmit message
transmission time s
schedule for m
lag time c
observes the fdf
flit of m
transmitting its message
a message sequence
all other pes
receives its wakeup
its message m
by pe p
or gathering operation
messages in a
the messages in
synchronization and scheduling
interpretation is that
its children s
optimal algorithm for
of messages in
of communication in
to its children
the operation of
is optimal for
on a path
is a form
the space time
destined for a
oe 1 and
the transmission time
via the use
of the messages
at time t
p i j
p i receives
the synchronization and
the optimality of
in networks of
network of processors
for scattering and
a scattering or
and scheduling activities
its children p
pe associated with
to form segment
child p i
of point c
for gathering in
its d i
operation a pe
a scattering operation
point c 0
the networks we
under schedules oe
for message sequence
for scattering from
transmission certification is
equal length messages
regimen is to
message streams of
in a gathering
p 0 receives
0 for m
pe of a
a multiport communication
must take at
observe the fdf
time for scattering
of spanning trees
single port regimen
toward p 0
the synchronization token
p sub 0
schedule is optimal
its gap free
from and gathering
can be positioned
schedule oe 1
optimal for m
corresponding message stream
a general tree
networks we study
gap free stream
integer s i
pes in the
dispatch times of
schedules oe 1
the pe associated
gathering schedule fl
whose left endpoint
be positioned in
scattering schedule is
length of its
certificates from its
a pe can
transmission of messages
for its children
form segment x
the certified lag
use of spanning
a one flit
in the tree
of the message
of the tree
the root of
p i 1
an optimal algorithm
x i k
its immediate neighbors
until it has
take at least
time interval during
personalized communication in
produced by algorithm
trees of arbitrary
distinct messages to
c 0 can
in a gap
p i will
message transmission in
the time axis
a form of
each of its
time c i
of its immediate
for every message
m i of
and oe 2
interval during which

corpus/krapavin2000-test/626788.txt
displayable
cscd
suffix
imp
scd
circular
scdawg
prefix
vertex
strings
ire
string
substring
redundant
de
xfl
jde
ff
occurrences
linearoccurrences
pred
rr
incident
entities
fl
entity
cv
abc
superword
edges
le
circoccurrences
jpred
edge
vertices
subword
conflicts
ul
traversals
subcase
occurrence
succ
ur
fde
letter
linearize
cabcbab
jocc
yde
flx
scdawgs
rus
conflict
visualization
jsucc
fincoming
f1g
vg
label
fi
lus
sink
ab
iff
redirected
abcbab
jflj
csdawg
cabcb
2m
incoming
delete
gabcde
subwords
genomes
jffj
bab
character
labels
processed
queries
leaving
polygons
p3
alphabet
substrings
reset
nil
abcd
p2
preceded
2n
continues
extension
verticesg
gammajfij
retrievable
oex174
processprefixredundant
circularize
f1gj
fiy
scdint
cabc
fidentify
processsuffixredundant
processbothredundant
yfl
jlcs
traversed
corollary
eliminated
fabcgabcde
intrasequence
chain
smallest
ffl
concatenation
homology
linearizing
g4
cde
shades
protein
repetition
sigma
traverse
patterns
successor
re
postprocessing
updated
acyclic
predecessor
conflicting
lemma
induction
cr
recurring
polygon
angle
p1
uniqueness
clockwise
bit
economical
contradicts
redundancy
traversal
pointers
contradiction
curves
listed
arbitrarily
modifications
2nd
sm
overlap
dm
inverted
pointer
complexities
affeffeffcfic
fifffl
bfiaffeffeffcficfiefiaffeffeffcficfibffcffdffcff
cabcbabcabcbab
jfij
fwe
fdo
jfl
fsimilar
0224
abcaaaa
babcaa
bcdabcea
abcdabce
fobtain
2446666666661122
dawg
642s
cabcaa
dabcg
step1
gammajffj
zde
gammajde
666666661122002242242446
16420
ffj
2jffj
1122102243244666666666
word
color
fg
brackets
said
pattern
directed
identifies
maximal
de v
cscd s
circular strings
of de
imp s
displayable entities
displayable entity
scd t
linear strings
in cscd
out edge
suffix redundant
de w
a substring
circular string
prefix redundant
s de
a displayable
cv s
rr in
substring of
incident on
re out
linear string
the scdawg
a suffix
s ff
occurrences of
a vertex
scdawg for
out edges
entities of
pred s
extension edge
entity of
in scd
re edge
of displayable
prefix suffix
all occurrences
t i
extension edges
to circular
w 1
linearoccurrences t
last cscd
suffix prefix
of t
v t
i j
v ffl
an re
for circular
not redundant
a prefix
jde w
ffl v
v in
v is
suffix of
prefix extension
de u
le edges
suffix extension
re edges
t v
ire last
one re
ffl cv
j n
v j
in s
for linear
is prefix
right extension
pred t
jde v
pattern ff
u s
edges to
ff of
le out
is suffix
edges incident
the vertex
are incident
w 2
prefix of
vertex in
in t
vertex v
edge from
edges from
occurrence t
superword of
leaving v
updated so
smallest superword
fl is
edge e
t ff
ff ff
conflict is
their labels
a circular
they point
j last
yde v
right edges
re le
fl ff
two re
ff 2m
not rr
circoccurrences s
left edges
redundant vertices
procedure circoccurrences
j of
d 1
size greater
of s
s t
of occurrences
the string
to w
fl i
v s
of scd
in fde
entities d
redundant vertex
left extension
an scdawg
continues to
on v
ff j
v are
label on
vertex representing
u 0
u r
algorithm a
of fl
v has
edge be
every pattern
fde a
jpred s
ff pred
w their
to vg
ff f1g
in cv
redundant only
length greater
labels are
of length
from v
is incident
edge corresponding
to v
d 2
e r
vertices in
edge is
v 1
in v
v v
the circular
vertices representing
from vertex
to de
on vertices
s v
greater than
a pattern
than n
be reset
string then
abc in
be w
indicates this
bit which
le edge
vertex corresponding
de x
suffix conflict
modified so
the smallest
the occurrence
step 3
vertex w
if de
v de
of abc
closed curves
of circular
of suffix
the edge
of de v
in cscd s
t i j
a displayable entity
substring of t
for linear strings
occurrences of de
displayable entities of
imp s de
s de v
cscd s t
a substring of
displayable entity of
de v in
rr in cscd
to circular strings
re out edge
de v is
all occurrences of
s t i
of displayable entities
last cscd s
the scdawg for
in scd t
i j of
in v t
a circular string
linearoccurrences t v
for circular strings
ffl cv s
de w 1
their labels are
a linear string
de u r
not a substring
ire last cscd
v in s
so that they
v v ffl
is a displayable
occurrence of de
jde v j
ff ff ff
edges incident on
incident on v
a suffix of
are incident on
le out edge
point to w
pred s ff
that they point
are updated so
they point to
v j n
entity of s
v ffl v
updated so that
v are updated
suffix extension edges
ff j 2
on v are
of algorithm a
out edges from
the smallest superword
i j is
fl i j
is a suffix
incident on w
is prefix redundant
scdawg for circular
ffl v t
pred t ff
of scd t
ff of length
out edge corresponding
u r y
is not redundant
de v v
label on the
pattern ff of
v ffl cv
is suffix redundant
the circular string
jde w 1
is a prefix
size greater than
greater than k
j is not
of size greater
in u s
imp s ff
prefix of de
of de w
smallest superword of
prefix extension edge
incident on vertices
suffix of t
displayable entities d
entities d 1
s l m
an re edge
a prefix extension
the label on
extension edge e
v is a
3 of algorithm
incoming edges to
edges from v
of occurrences of
that they represent
length greater than
indicates this should
let the vertex
fde a j
to be w
bit which indicates
s ff j
are modified so
and prefix redundant
is not rr
edges to vg
leaving v let
re le out
edges the bit
a suffix prefix
one re out
leads to be
w their labels
of abc in
of circular strings
every pattern ff
extended to circular
should be reset
occurrence t i
procedure circoccurrences s
delete the edge
the bit which
s ff pred
for every pattern
the linear string
vertex that it
superword of de
labels are modified
s de u
de v de
re out edges
ff pred t
to w their
j a ffl
which indicates this
suffix prefix of
in cv s
not rr in
i n j
t i n
modified so that
edge corresponding to
and d 2
1 and d
of length n
d 1 and
n j n
v in t
prefix suffix conflict
occurrences of displayable
de v must
j n is
edges to v
de v 2
v let the
let the label
re edge from
letter x in
represent the concatenation
a prefix suffix
ffl v s
vertex corresponding to
out edge e
displayable entity in
step 3 of
number of occurrences
used to represent
equal to n
v is not
occurrences of d
that it leads
u 0 s
is a substring
the vertex that
length n in
a conflict is
from v 1
of length greater
of d 1
step 2 a
a vertex v
w 1 and
less than n
they represent the
and suffix redundant

corpus/krapavin2000-test/626842.txt
ring
hot
request
processor
latency
utilization
contention
outstanding
spot
transaction
topologies
banks
station
traffic
hector
cache
rings
locality
saturation
cluster
packet
theta
cycle
branching
efficiency
cycles
memory
workload
blocking
packets
topology
utilizations
r2m30
reads
prefetching
block
slotted
module
processors
rate
spots
r4m60
localities
multiprocessors
simulator
word
exposed
ml
queue
tradeoff
misses
levels
speeds
remote
hierarchy
retries
stall
doubtful
target
transfers
memories
rates
favorite
hit
plots
unidirectional
miss
1024
page
sci
synchronization
mode
batch
probabilities
coherence
modules
dram
multiprocessor
clusters
hierarchical
saturate
bank
strobe
tango
multicomputer
versus
interfaces
questionable
inter
shared
communication
simulating
interconnection
prototype
degradation
multithreaded
crossbar
multithreading
network
interface
stations
root
response
validated
fetched
hiding
accesses
r1m60
theta10305070900
sibai
halfwidths
cyberplus
fadi
teraflop
ultracomputers
favoritism
rxmy
ratio
consistency
synthetic
factors
05
compensate
batches
significance
prohibitively
agarwal
writes
controller
limiting
ksr1
1023
migrations
drop
offered
ranges
coherent
90
loads
mem
cause
connections
bottleneck
ksr
2060100
alpha
hardware
addressing
hierarchies
near
disadvantage
subtransaction
replications
realism
hide
01
increased
traverse
saturates
distributing
workloads
load
simulation
contexts
varied
transactions
advantageous
standards
requesting
realistic
causes
tend
traversed
bandwidth
concurrency
caches
access
examine
sensitive
patterns
committee
improvement
congested
percentage
scalable
ends
chose
completes
extent
transfer
percent
read
varying
substantially
95
queues
dec
retry
sharply
imposes
request rate
ring utilization
theta theta
transaction latency
maximum ring
outstanding transactions
hot spot
communication locality
processor efficiency
memory banks
cycle time
the ring
ring cycle
target memory
processor cycles
memory cycle
blocking reads
request rates
of outstanding
the processor
multiple outstanding
inter ring
branching factors
page mode
cluster 1
the request
non blocking
ring based
memory utilization
mean remote
memory saturation
spot memory
multiple memory
block size
the hot
branching factor
ring interface
mode access
root ring
spot traffic
memory queue
base system
topologies with
cluster 2
first word
contention free
theta figure
the target
the memory
workload model
of ring
and ring
ring levels
hierarchical ring
ring hierarchy
ring utilizations
l request
versus request
traffic patterns
rate b
hot spots
u l
of memory
shared memory
factor at
the station
ring topology
in ring
ring cycles
source processor
favorite memory
processor module
e request
factors at
the hector
between cache
response packet
cache miss
processor cycle
of levels
hit ratio
cache misses
a memory
memory contention
the topologies
workload parameters
utilization is
remote transaction
processing module
ring and
memory latency
and maximum
the contention
cache hit
of processor
latency is
increasing t
increase in
traffic pattern
memory probabilities
request packet
plots efficiency
larger branching
ring saturation
1 ring
1 probabilities
ring contention
communication localities
locality model
a request
packets from
transactions and
r u
cache coherence
a transaction
memory access
one memory
memory and
maximum number
a ring
processor stall
33 theta
rate for
efficiency is
2 size
memory bank
the transaction
the root
memory is
a processor
hot memory
hardware contexts
best topologies
reads block
scalable coherent
target station
1024 processors
stall ends
ring interfaces
large branching
b 33
at request
multiple hardware
and prefetching
coherent interface
level workload
three traffic
per processing
and contention
l e
system performance
the maximum
x r
0 05
limiting factor
memory module
latency for
the simulator
and memory
the traffic
overall system
block transfers
ring connections
local ring
processor modules
on efficiency
station controller
efficiency versus
a station
banks per
increasing efficiency
maximum transaction
synthetic workload
the block
increasing the
cycle times
memory multiprocessors
per processor
effect on
each processor
the base
contention the
software cache
this tradeoff
rate 0
6 levels
memory consistency
cycles between
level 1
the network
latency in
efficiency for
and workload
0 01
the increase
the hierarchy
experiments indicate
the cluster
c l
we considered
maximum ring utilization
theta theta theta
the request rate
of outstanding transactions
the maximum ring
the target memory
number of outstanding
non blocking reads
multiple outstanding transactions
and maximum ring
multiple memory banks
memory cycle time
the hot spot
hot spot memory
request rate for
hot spot traffic
ring cycle time
x r u
page mode access
request rate b
outstanding transactions and
the first word
theta theta figure
r u l
ring utilization is
versus request rate
transaction latency is
u l request
the root ring
branching factor at
of memory banks
l request rate
the communication locality
a x r
cache hit ratio
between cache misses
mean remote transaction
m a x
remote transaction latency
the source processor
the base system
e request rate
a request rate
of communication locality
branching factors at
a memory queue
c l e
number of levels
block size of
cluster 1 probabilities
the response packet
cluster 2 size
factors at the
of page mode
inter ring interface
maximum ring utilizations
the contention free
request rate of
the ring hierarchy
the transaction latency
the processor stall
target memory is
one memory bank
33 theta theta
a block size
packets from the
overall system performance
maximum number of
a ring cycle
scalable coherent interface
hierarchical ring based
cycles between cache
per processing module
three traffic patterns
traffic patterns the
processor stall ends
multiple hardware contexts
transaction latency for
ring and memory
the best topologies
favorite memory probabilities
memory utilization and
b 33 theta
inter ring connections
ring utilization for
rate b 33
request rate a
memory and maximum
memory banks per
request rate 0
the target station
maximum transaction latency
larger branching factors
system and workload
level 1 ring
rate for different
memory and ring
number of processor
shared memory multiprocessors
number of memory
the increase in
of the transaction
rate of 0
the cache hit
the memory cycle
processor cycle time
a cache miss
reaches the processor
a synthetic workload
the maximum number
a large system
latency is the
of processor cycles
software cache coherence
of the request
f c e
the sci ring
somewhat larger branching
higher request rates
u l topologies
the workload parameters
processor ring and
level workload model
of multiple memory
the limiting factor
l e request
one outstanding transaction
different t values
at request rate
utilization and maximum
the scalable coherent
of the sci
and ring speeds
the next station
outstanding transactions per
rings at the
per memory module
the hector prototype
ring utilization the
increasing the block
transaction latency and
the primary cause
synthetic workload model
in processor efficiency
concurrency and contention
memory queue of
page mode dram
adaptive maximum number
efficiency versus request
l a y
mode access is
the traffic pattern
a plots efficiency
at a request
the ring utilization
y c l
with multiple outstanding
number of ring
we assume 0
for different t
plots efficiency versus
between concurrency and
f f c
95 0 8
communication locality model
effect on efficiency
for increasing efficiency
source processor module
access strobe line
transactions and non
mode dram access
for the hot
take prohibitively long
increase in ring
communication locality changes
memory bank per
processor cycles between
first word is
use of page
the offered load
the request packet
large branching factors
would take prohibitively
low level workload
transactions per processor
degree of communication
near the hot
ring based systems
simple node interfaces
exposed transaction latency
increase in order
ring cycles for
from the station
in cache hit
c e request
node interfaces and
tradeoff between concurrency
mean number of
shared memory multiprocessor
on the order

corpus/krapavin2000-test/626879.txt
displayable
suffix
conflicts
subword
prefix
scd
shadowsearch
nextsuffix
occurrences
entities
conflict
pet
de
vertex
string
getsubwords
occ
sink
ww
afi
sg
sublist
abc
letter
aff
superword
scdawg
pshadow
listconflicts
imp
entity
wm
cde
subwords
wmw
strings
vertices
edges
sigmaj
edge
positions
substring
jlabel
sublistj
noconflicts
display
iff
p5
dm
preceded
alphabet
afl
ms
descendants
extension
spd
superstring
sgr
p7
p4
occurrence
gabcde
psf
scdawgs
visualization
label
sv
incident
invocations
spawned
lemma
protein
optimally
suffixes
maximal
xfflsv
lambdanumber
fthere
bioinformatics
listj
pimage
color
source
ff
jx
dna
descendant
def
truth
conflicting
directed
fabcgabcde
abcde
jde
intrasequence
economical
isn
labels
concatenation
p3
p2
highlighted
homology
p9
radix
nil
suboptimal
fi
text
shadow
jv
occurence
p8
sigma
500
topological
position
leaving
loop
reporting
rf
substrings
comprising
reverse
modifying
tb
p6
lengths
acyclic
compact
highlighting
1000
followed
overlap
patterns
interactive
compaction
x6
recurring
computes
le
frequency
restricted
biology
molecular
subgraph
originates
dag
character
queries
sc
concatenating
lists
calls
sequences
statement
smallest
sm
sorted
disabled
incoming
inverted
colors
aflff
neng
nilg
sigmajp
abczdefydefxabc
superwords
fpshadow
4j
entiities
p11
affbfi
cdefcdegabchabcde
abcdbcgabcdbchbc
perword
obtaind
owsearch
aflfi
setsuffixes
tomatic
recursively
word
lemmas
transitivity
fg
pattern
traverses
pascal
fundamentals
characters
illustration
se
lines
step3
abcx
fares
xfl
flx
de v
displayable entities
prefix suffix
s v
suffix conflicts
of de
scd s
suffix extension
v w
extension edge
subword conflicts
sg s
a prefix
pet s
de w
prefix extension
displayable entity
w x
extension edges
occurrences of
w v
a subword
all prefix
d 1
ww de
in pet
occ i
suffix conflict
of displayable
de x
each vertex
of occurrences
algorithm d
conflicts between
in scd
d 2
same letter
getsubwords v
v s
a suffix
to de
subword of
between de
of scd
in s
v in
or suffix
of conflicts
right extension
imp s
algorithm c
to shadowsearch
shadowsearch v
x afi
start positions
x sublist
suffix of
prefix of
entities of
the occurrences
conflicts of
of occ
of d
conflicts with
all displayable
v source
w a
conflict free
the subword
and suffix
in sg
w b
edge from
vertex v
pshadow w
6 sink
nextsuffix v
a ww
takes o
the string
w p
conflict is
o n
in v
edges from
all occurrences
a vertex
in set
subword conflict
the sink
of subword
of nextsuffix
wmw s
v subword
of line
abc and
if de
a string
computing all
optimal algorithm
v and
w and
vertex w
string s
occurrences s
re edges
de u
a displayable
superword of
is conflict
of prefix
and de
conflicts in
right or
the prefix
from x
shadowsearch is
p wmw
p de
subword is
and cde
entities represented
x aff
procedure getsubwords
between d
set s
conflict occurs
vertex x
v is
v v
is o
v then
end positions
entities d
smallest superword
an re
subwords of
subword displayable
size restricted
all subword
all conflicts
6 source
algorithm b
of s
to v
x in
than k
vertex representing
j sigmaj
conflicts are
w in
preceded by
the for
line 5
of algorithm
x afl
string alphabet
spd w
of getsubwords
start position
jx sublistj
conflicts using
by descendants
listconflicts of
distinct conflict
do 9
average times
sv s
wm is
and displayable
of invocations
alphabet 500
occurs between
descendants of
computes all
edges leaving
is incident
500 1000
vertices in
the while
positions of
w 1
conflict the
with label
a conflict
display conflicts
maximal patterns
2000 figure
sink and
the displayable
the scdawg
of sg
without including
conflicting displayable
s consequently
end position
label f
recursively let
out edge
re edge
prefix suffix conflicts
de v w
v w x
of de v
sg s v
pet s v
all prefix suffix
in pet s
ww de v
a prefix suffix
set s v
prefix suffix conflict
prefix extension edge
to de v
de w and
respect to de
suffix extension edges
in scd s
of displayable entities
for each vertex
the same letter
suffix conflicts between
of scd s
or suffix extension
occurrences of d
s v and
occurrences of de
displayable entities of
suffix extension edge
extension edge from
in sg s
between de w
a subword of
is a prefix
is a subword
in v s
in set s
shadowsearch v w
and suffix extension
of occ i
conflicts between de
w x afi
d 1 and
vertex v in
number of occurrences
and d 2
1 and d
a suffix of
all displayable entities
for computing all
between d 1
a prefix of
of d 2
of occurrences of
nextsuffix v v
w and de
the prefix extension
a ww de
pshadow w v
right or suffix
w a ww
is a suffix
greater than k
v in scd
number of conflicts
a subword conflict
suffix of de
is conflict free
a prefix extension
each vertex v
all occurrences of
conflicts between d
extension edges from
of subword conflicts
computes all prefix
statement of line
by the same
the occurrences of
occurrences of displayable
w v w
subword of de
a displayable entity
suffix conflicts with
edge from x
of d 1
d 2 in
v subword is
each vertex w
p wmw s
w p wmw
w x aff
v w v
s v with
w b w
in v source
conflict occurs between
occurrences s v
the subword conflicts
p de v
w v x
entities represented by
displayable entities represented
calls to shadowsearch
w p de
of all displayable
takes o n
v in v
preceded by the
and de x
de v then
is a displayable
the if statement
vertex x in
smallest superword of
b w a
displayable entities d
de v is
entities d 1
all subword conflicts
of prefix suffix
the smallest superword
o n time
s is conflict
vertex w in
is o n
truth of the
all the occurrences
de u is
right and suffix
procedure getsubwords v
represented by descendants
of algorithm c
v w s
and displayable entities
suffix conflict occurs
size of size
size of string
a right extension
occur in s
2 in d
each vertex x
x in pet
number of prefix
the average times
v 6 sink
in ms for
w x afl
average times for
set of invocations
spd w v
of invocations of
without including the
abc and cde
alphabet 500 1000
prefix of fi
by descendants of
of string alphabet
of sg s
1000 2000 figure
edges from w
sv s v
of ww de
de v if
w to v
computing all conflicts
de x is
time in ms
string alphabet 500
followed by the
of the labels
re edges from
prefix of de
from w to
two displayable entities
suffix conflicts of
if statement of
between two displayable
prefix extension edges
de v in
in a string
of de w
overlap of a
d 2 with
de w is
compute all prefix
v with respect
string s is
s v is
right extension edge
an re edge
500 1000 2000
the vertex representing
the while loop
from v to
with respect to
w a w
the optimal algorithm
v in s
s such that
are greater than

corpus/krapavin2000-test/626911.txt
ctt
routing
faulty
dfs
assignments
traffic
hypercube
hypercubes
modules
links
cebn
switching
communication
link
message
hamiltonian
ctts
assignment
failures
circuit
cebm
turnaround
subcube
fault
greedy
task
cebns
cebms
multicomputers
module
packets
switched
injured
tasks
margin
shortest
cycle
outstanding
abdelzaher
bipartitioning
performances
msg
busy
objective
fig
minimizing
ij
mincut
tarek
routed
001
cube
timing
status
messages
heuristic
111
volume
wr
packet
destination
tolerant
multicomputer
congested
s1
hops
optimizing
interconnection
shin
simulation
comparatively
pronounced
bottom
node
gets
n00014
kang
annealing
embedding
tested
goodness
ella
ulations
lambda01
signments
opting
ultrix
atkins
dar
0122
topologies
executing
110
volumes
onto
processed
queue
weight
blocked
units
tzen
asymmet
ric
1115
subcubes
s2
oe
changing
predict
becoming
span
exchanged
path
000
assigning
758
preset
honored
1183
mapping
send
sent
relaxed
paths
event
communicating
improvements
abundance
absorbed
1170
hunt
kept
spread
np
plotted
arrival
traversing
degrading
occupation
narrower
differentiates
scheduling
resources
effects
plots
steadily
perturb
745
intermediate
inter
broken
011
utmost
inaccuracies
matrix
300
randomly
simulated
needing
uncertainties
naval
diminish
combinatorial
negotiation
010
opinions
whichever
diminishes
mission
absolutely
recommendations
infor
optimize
simulate
halting
inaccuracy
onr
efficiency
stated
measured
edge
driven
axis
apart
negligible
merits
deliberately
unsuccessful
adaptable
thoroughly
hamming
judge
somewhere
grows
nodes
timings
750
office
adaptive
requests
communication traffic
faulty links
dfs routing
task modules
the dfs
of faulty
link failures
assignments found
message switching
the assignments
communication performance
random assignments
task assignment
communication bound
hamiltonian cycle
found with
routing algorithm
switched hypercubes
fault free
of task
routing scheme
input tasks
the communication
a task
bound tasks
traffic is
u ij
over random
circuit switching
the routing
the task
of link
hypercube multicomputers
ij s
of packets
simple objective
communication efficiency
turnaround time
path chosen
communication turnaround
minimizing communication
communication volume
a hypercube
circuit switched
task execution
assignments with
tolerant routing
objective function
in fig
cycle in
communication matrix
in hypercube
greedy approach
shortest path
top down
cube size
assignments obtained
free hypercube
of ctt
outstanding cebn
link status
links increases
called communication
optimizing this
injured hypercube
l msg
our simulation
of communication
for message
modules is
heuristic algorithms
bottom up
tasks used
hypercube by
assignment algorithms
kept busy
of modules
for communication
a message
one module
results should
algorithms are
links are
task under
with faulty
a hamiltonian
overall communication
path routing
simulation results
different algorithms
the greedy
these algorithms
message length
an outstanding
in circuit
hypercube with
time units
time behavior
links is
routing is
intermediate node
minimizing ctt
task communication
an injured
communication oriented
assigning task
inter node
allocation onto
10 300
broken links
a cebn
links grows
communication events
wr hamiltonian
time span
volume matrix
processed immediately
recursive mincut
volume between
under circuit
mincut bipartitioning
optimize communication
message switched
assignments s1
changing t
switching however
alternative routing
a subcube
s1 still
find assignments
assignments under
switching methods
communication event
hypercubes for
assignment criterion
virtual edge
task being
different switching
ctts of
event between
tarek f
global link
cebms the
free shortest
f abdelzaher
during task
cebn is
communication volumes
a routing
and bottom
routing algorithms
on system
all links
assignment the
assignment and
a communication
each task
the cube
modules in
length of
links the
down and
in number
modules into
busy with
hypercube multicomputer
smaller communication
switching for
optimal mapping
switching is
links while
which links
hypercube embedding
units links
actually executed
actual communication
destination via
different assignments
hypercubes with
before making
those assignments
up algorithms
fault tolerant
this task
function we
message is
the length
greedy algorithm
for fault
improve communication
task graph
node communication
up approaches
known before
with simulations
for circuit
task allocation
approach e
traffic we
g shin
of faulty links
the dfs routing
number of faulty
communication traffic is
of task modules
assignments found with
of link failures
the assignments found
over random assignments
hamiltonian cycle in
communication bound tasks
minimizing communication traffic
number of packets
u ij s
number of link
the communication traffic
circuit switched hypercubes
under the dfs
simple objective function
communication turnaround time
in hypercube multicomputers
of the assignments
fault tolerant routing
for message switching
a task assignment
results should not
objective function we
a hypercube by
the cube size
assignments obtained from
dfs routing is
faulty links increases
the assignments obtained
of communication traffic
the path chosen
input tasks used
time behavior of
knowledge of faulty
pair of modules
a simple objective
an outstanding cebn
with different algorithms
found with different
for communication bound
with faulty links
overall communication traffic
random assignments with
fault free hypercube
simulation results should
links are kept
faulty links is
down and bottom
shortest path routing
ij s are
a fault free
of time units
the communication matrix
are kept busy
when the number
and bottom up
of all links
a hamiltonian cycle
the overall communication
of this task
cycle in the
the communication volume
the number of
top down and
execution of this
run time behavior
from the source
source to the
the top down
the length of
are found to
the greedy algorithm
to the destination
during the execution
links increases the
global link status
node an outstanding
hypercubes with faulty
inter node communication
alternative routing algorithm
of global link
additional link failures
a communication event
injured hypercube with
an injured hypercube
of assignments found
cebn is said
module is assigned
communication event between
improvements over random
where u ij
message is routed
the input tasks
task modules in
performance of assignments
faulty links while
message switching however
function called communication
assignment of task
fault free shortest
time units links
the task being
task being more
which links are
approach for fault
actual communication performance
where an alternative
recursive mincut bipartitioning
faulty links and
link failures is
assignments under the
the task under
timing of communication
in circuit switching
the time span
algorithms are tested
to optimize communication
called communication traffic
of input tasks
in an injured
during task execution
first search approach
free shortest path
most one module
like the dfs
sum of time
assignments s1 still
hypercube by recursive
onto a hypercube
algorithms the assignments
difficult to predict
modules in hypercube
task allocation onto
heuristic algorithms are
routing is used
optimizing this function
an alternative routing
the task assignment
effects of changing
assignments found by
traffic is proposed
before making a
search approach for
for message switched
faulty links the
of communication events
link status information
actually executed in
unless the task
that the dfs
switching is shown
a routing scheme
one module is
routing in hypercube
message switched hypercubes
communication performance especially
faulty links grows
the destination via
communication traffic we
an optimal mapping
on system implementation
by recursive mincut
the routing scheme
assigning task modules
communication performance measure
by minimizing communication
tarek f abdelzaher
graph with as
volume between each
communication volume matrix
smaller communication traffic
percentage of faulty
allocation onto a
communication volume between
than the shortest
for circuit switched
bottom up algorithms
s are characterized
as the cube
cube size and
those assignments found
node communication is
link failures occur
the communication turnaround
communication traffic of
units links are
optimize communication performance
wr hamiltonian cycle
task modules to
the source to
between each pair
in number of
these algorithms are
not be used
in fig 3
relatively small and

corpus/krapavin2000-test/626918.txt
mpi
cold
trace
caches
cache
megabyte
sampling
initmr
mult1
instructions
mult2
traces
samples
bias
bits
misses
cones
sample
references
million
sor
miss
instruction
intervals
interval
1m
mapped
megabytes
stitch
kess91
mifj90
fetches
fraction
lin
filtered
wood
associative
secondary
eeckhout
lapi88
lieven
bokw90
sampled
prefetch
90
estimates
simulate
000
ston90
confidence
workloads
byte
wohk91
bosschere
puza85
mitigate
simulation
associativity
pid
win
prime
coefficient
koen
meets
variation
lengths
64
multiprogramming
estimate
easf78
data10ratio
displays
slice
percent
billion
eight
lockup
mache
compaction
indexing
cone
overestimate
100
instruc
half
memories
award
workload
prefetching
warm
5a
millions
asterisk
driven
dagger
wrl
przybylski
borg
laha
associativities
titan
spl
aghh88
prhh89
stitching
smit82
puzak
coefficients
hierarchies
ratios
estimating
128
primary
virtual
calculate
calculating
vertical
unbiased
tv
equipment
filter
marked
locality
predicts
hashing
referenced
selecting
accurate
microarchitecture
awarded
corporation
sigmetrics
replacement
8192
billions
1000
buffers
indexed
disadvantage
examines
initialized
western
4m
kilobytes
display
direct
cpu
adve
axis
predict
multiprogrammed
6a
accurately
contiguous
index
6b
category
192
meet
underestimate
blocks
simulations
wisconsin
laboratories
fill
horizontal
les
percentile
switch
hierarchy
risc
address
biases
5b
prefix
operating
multi
accuracy
block
examine
temporal
foundation
1024
slices
bell
overcoming
bytes
cray
recording
bit
ratio
fetch
reference
configurations
tens
graduate
addresses
alumni
hils89
toomula
cold start
set sampling
mpi s
full trace
constant bits
time sampling
direct mapped
mpi long
megabyte caches
start bias
mult1 2
the mpi
multi megabyte
million instructions
mpi of
sampling goal
10 sampling
interval lengths
instructions method
sampling is
mapped cache
a sample
cache performance
4 megabyte
bias s
mult2 2
cones for
100 million
1 16
start techniques
set samples
instruction fetches
mpi for
of variation
the 10
the trace
the cold
bits method
10 million
trace mpi
the mult1
megabyte direct
way set
cache state
sample s
confidence intervals
four way
true mpi
start misses
wood et
filtered trace
fetches to
index bits
initmr estimates
set associative
the cache
fraction of
90 confidence
for mpi
of mpi
initial cache
interval length
all instructions
bits samples
1m 2
trace sampling
mapped caches
000 instructions
sampled instructions
s mpi
selecting sets
each interval
90 of
misses to
byte blocks
per instruction
miss ratio
2 1m
start technique
16 megabytes
cache sizes
the constant
to full
the references
trace data
a cache
caches and
associative caches
secondary caches
in sample
2 trace
an interval
coefficient of
the sample
of cache
of full
sets in
the traces
traces and
and caches
mpi with
miss ratios
lieven eeckhout
caches where
mpi estimates
mpi initmr
million instruction
1 megabyte
size mpi
16 th
primary cache
eight traces
10 win
of estimate
16 megabyte
lin table
trace driven
trace is
the full
an observation
samples with
trace for
the cones
cache a
a trace
the all
of cold
trace size
s true
mapped and
references in
least 90
estimates for
all sets
meets the
how well
1 64
secondary cache
misses per
sampling we
cache with
the sampled
this table
the fraction
10 of
per set
for caches
trace compaction
virtual indexing
2 mult2
100 16
win 10
that mpi
five cold
instruction intervals
table displays
percent fraction
trace interval
four interval
set sample
trace to
mitigate cold
long 1000
accurate low
128 byte
long traces
tree lin
mpi i
address bits
the mult2
cold half
use virtual
pid hashing
16 100
de bosschere
koen de
overestimate mpi
sampling coefficients
associative cache
sizes 1
cache and
these traces
sampling techniques
instructions for
1 4
references to
than 10
this figure
the true
of instructions
miss i
bits 11
sor and
caches that
cache s
address traces
10 relative
full sets
caches a
cost methods
cold start bias
the constant bits
the full trace
10 sampling goal
multi megabyte caches
the mpi of
the 10 sampling
direct mapped cache
the cold start
100 million instructions
cold start techniques
megabyte direct mapped
set sampling is
constant bits method
of full trace
fraction of full
in a sample
way set associative
coefficient of variation
a 4 megabyte
cold start misses
wood et al
full trace mpi
initial cache state
4 megabyte direct
for mpi s
instruction fetches to
the all instructions
with the constant
90 confidence intervals
mpi of a
initmr estimates for
direct mapped caches
bias s for
constant bits samples
all instructions method
cache performance of
of the trace
90 of the
million instructions for
of set sampling
the mult1 2
cold start technique
coefficients of variation
meets the 10
meet the 10
mpi s with
cones for mpi
the references in
references in a
set associative caches
for a sample
of the full
misses per instruction
of cold start
estimate to full
mult1 2 trace
sampled instructions method
cache sizes 1
sizes 1 4
of estimate to
fraction of sets
four way set
to full trace
the sampled instructions
4 and 16
for time sampling
traces and caches
sets in sample
mpi initmr estimates
for direct mapped
for multi megabyte
the true mpi
1 16 th
trace mpi initmr
trace size mpi
mult2 2 1m
a full trace
direct mapped and
of each interval
the cache performance
at least 90
of sets in
the sets in
the fraction of
10 relative error
and time sampling
of 10 million
mpi long 1000
tree lin table
accurate low cost
cache memory systems
128 byte blocks
this table displays
and four way
set sampling we
sample s mpi
these traces and
mapped and four
million instruction intervals
set sampling coefficients
sampling coefficients of
16 megabyte caches
10 win 10
2 mult2 2
low cost methods
and 100 million
16 16 100
fetches to all
sor and lin
full trace data
start bias in
mitigate cold start
bits 11 8
for these traces
mult1 2 mult2
trace sampling techniques
win 10 win
evaluation of cache
100 16 16
the mpi for
of mpi s
use virtual indexing
a set sample
to all sets
two way set
five cold start
koen de bosschere
2 1m 2
4 4 100
4 100 16
methods for performance
mpi of the
four interval lengths
cost methods for
and 16 megabytes
for the mult1
1 4 and
trace driven simulation
an observation in
sampling is the
least 90 of
than 10 of
sets in a
the coefficient of
10 of the
is the cache
a sample s
and a 4
of the mpi
the trace s
in an interval
for performance evaluation
of the references
of cache memory
reference traces of
to full sets
cold half prime
examine how well
1 megabyte caches
of large workloads
sets at random
full trace data10ratio
traces four interval
true mpi for
of variation percent
millions of instructions
eeckhout koen de
to mitigate cold
displays bias s
sampling is more
overestimate mpi s
middle 90 of
billion reference traces
time sampling with
but not operating
of mpi long
likely to miss
confidence intervals that
000 000 instructions
tv sor and
sets that share
16 1 64
alternative secondary caches
cache state at
than time sampling
estimate the mpi
selecting the sets
data10ratio of estimate
a filtered trace
time sampling is
that mpi s
a switch interval
effective than time
in sample trace
sampling fails to
calculating the mpi
data initmr estimates
mapped cache sizes
prime stitch initmr

corpus/krapavin2000-test/626956.txt
lapack
sticky
rcond
nan
strsv
exception
exceptions
arithmetic
flags
overflow
triangular
speedups
blas
floating
trap
sgecon
5000
handling
decstation
eigenvectors
eigenvalues
dec
underflow
nans
ctrevc
sbdsqr
slower
cm
quit
sigma1
c90
cray
ill
matrices
infinity
speed
alpha
ov
bisect
bisection
routine
conditioned
tridiagonal
clatrs
strcon
sgbcon
spocon
r3000
routines
fortran
endif
reciprocal
matrix
eigenvector
eigenvalue
jja
unexceptional
ctrsv
slatrs
slow
scalings
mips
subprograms
sparcstation
speeds
endfor
kahan
count
260
division
f77
nonsticky
jjxjj
cgeev
infinities
inderjit
denormals
algebra
speedup
cc
estimation
calling
cleared
dhillon
singular
scaling
algo
default
bits
toms
bidiagonal
numerical
slowly
conventional
manual
invalid
exceptional
traps
chip
gammat
machines
inner
sparc
symmetric
paradigm
attained
megaflops
pivmin
signbit
120x
demmel
denormalized
sstebz
exceptionreset
denormal
fcr31
status
oe
subroutine
unstable
precision
answer
pivot
risc
norm
ipx
buggy
sun
hessenberg
fastest
00
grained
rare
terribly
flag
solve
else
abort
jj
handles
5n
rot
reliably
quickly
testing
unpleasant
amortize
jz
raised
pipelined
ranging
solving
costs
tests
growth
spent
slowdown
mp
scaled
gamma1
pivoting
fast
diagonal
badly
multiplies
moderately
cpu
instructions
prefix
loop
inexact
lessons
ranged
register
dense
granularity
subroutines
calls
unlikely
ae
seldom
recompute
codes
pipelining
enormous
scales
52
optimized
transpose
occurred
stopping
reasonably
incorrectly
gammapivmin
trapenable
inadvisable
deserved
weitek
42x
christof
exception handling
full speed
condition estimation
sticky flags
speed full
floating point
infinity arithmetic
nan and
dec 5000
exception occurs
arithmetic with
an exception
cm 5
the blas
and infinity
the sticky
rcond 0
algorithm 2
decstation 5000
ieee standard
eigenvectors of
the speedups
except then
in lapack
then rcond
the lapack
0 quit
if except
ill conditioned
speed of
symmetric tridiagonal
linear algebra
dec alpha
exceptions occur
the speed
strsv if
cray c90
calling strsv
conventional arithmetic
triangular system
the cm
basic linear
by zero
division by
triangular solve
the decstation
trap handling
4 260
numerical algorithms
using algorithm
algorithm 7
point arithmetic
algorithm 4
handling in
no exceptions
algebra subprograms
when computing
reciprocal of
phase 2
the eigenvalues
condition number
the triangular
algorithm 1
triangular systems
sun 4
most common
lapack routine
fast exception
nan arithmetic
and nan
over underflow
slow dec
exception bits
fast dec
using exception
solve calling
blas routine
quit endif
with nans
testing sticky
bisection algorithms
ieee arithmetic
slower cc
when exceptions
from 1
the fast
of algorithm
of overflow
computing u
the bisection
the reciprocal
inner loop
eigenvalues of
in algorithm
algorithms 3
algorithm 6
a trap
eigenvector computation
triangular matrices
phase 1
lower triangular
the ieee
arithmetic the
overflow in
handling and
where no
a sparcstation
for exceptions
chip as
occurs when
were between
eigenvalues less
g un
sticky bits
speed manual
else solve
5000 and
complex matrix
all exceptions
routine strsv
strsv this
pivot growth
and sigma1
tridiagonal eigenvalue
of nan
count oe
and scalings
general complex
status flag
endfor return
matrix dimension
nonsticky exception
3 ae
overflow division
quit else
slower full
parallel prefix
via exception
nans and
count function
computing eigenvectors
and eigenvector
solve triangular
lapack library
return c
normal arithmetic
slow decstation
oe endfor
times slower
00 2
the count
of eigenvalues
2 00
spent by
the cray
point operations
quickly and
the inner
linear systems
without exception
bisection algorithm
right eigenvectors
optimized blas
jj 1
handling to
avoid overflow
mips r3000
traps and
one norm
endif else
tests and
common case
upper triangular
of exception
about n
arithmetic on
on machines
complex matrices
speed as
as conventional
software toms
toms v
max n
error bound
as fast
to avoid
n by
by n
singular value
fast as
the slow
the eigenvalue
point number
and invalid
mathematical software
matrices of
on mathematical
as cpu
the algo
for condition
speed full speed
full speed full
an exception occurs
and infinity arithmetic
rcond 0 quit
except then rcond
exception occurs when
then rcond 0
if except then
occurs when computing
nan and infinity
the speed of
division by zero
strsv if except
calling strsv if
the cm 5
basic linear algebra
floating point arithmetic
algorithms 3 and
the sticky flags
the ieee standard
the decstation 5000
sun 4 260
linear algebra subprograms
on the cm
n by n
the most common
fast dec 5000
where no exceptions
no exceptions occur
testing sticky flags
the blas routine
fast exception handling
when computing u
slow dec 5000
the triangular solve
using exception handling
solve calling strsv
0 quit endif
on the decstation
number of eigenvalues
the inner loop
exception handling and
most common case
k 1 a
floating point operations
time spent by
the reciprocal of
the condition number
to solve triangular
by zero and
the lapack routine
finding the eigenvalues
overflow division by
1 and nan
eigenvalues less than
triangular system 3
and eigenvector computation
the one norm
of nan and
the symmetric tridiagonal
tridiagonal eigenvalue problem
in condition estimation
general complex matrices
of the algo
the count function
blas routine strsv
for condition estimation
used in lapack
of general complex
trap handling in
tests and scalings
exception handling the
the lapack library
endfor return c
condition estimation and
equal to oe
eigenvectors of general
of arithmetic with
quit endif else
the fast dec
of eigenvalues less
and without exception
max n 3
oe endfor return
arithmetic with nans
decstation 5000 and
the pivot growth
the right eigenvectors
chip as cpu
the slow dec
full speed manual
zero and invalid
as conventional arithmetic
test for exceptions
slower full speed
via exception handling
n 3 ae
without exception handling
were between 1
speed of nan
nonsticky exception bits
the optimized blas
fast as conventional
estimation and eigenvector
symmetric tridiagonal eigenvalue
of a real
the eigenvalues of
to avoid overflow
exception handling to
right eigenvectors of
of exception handling
of the blas
exception handling in
as fast as
software toms v
mathematical software toms
are the right
on mathematical software
using algorithm 2
symmetric tridiagonal matrix
floating point number
spent by the
an upper triangular
the dec alpha
transactions on mathematical
a lower triangular
eigenvectors of a
the time spent
both with and
on a sparcstation
reciprocal of the
the eigenvectors of
numerical linear algebra
need to solve
eigenvalues of a
norm of a
algorithms for solving
arithmetic with denormalized
report performance results
computing eigenvectors of
of fast exception
x would overflow
dec alpha and
user level trap
from 1 14
exception handling a
exception handling section
21 and 1
the bisection algorithms
numerical algorithms via
are five corresponding
jx i j
the count value
time of 0
the scalings inside
triangular solves for
inside algorithm 2
scales carefully to
is as fast
2 solve a
arithmetic is as
for solving triangular
that used algorithm
point operations at
subprograms for fortran
extended set of
estimate jja gamma1
j where jz
when exceptions occur
exceptions occur and
slower f77 full
unexceptional floating point
faster numerical algorithms
algorithms via exception
the answer slowly
most common situation
megaflops for a
ieee single precision
use in condition
1 14 to
the computed answer
arithmetic with sigma1
long excluding comments
fortran codes for
longer than phase
r3000 chip as
from the lapack
the reduction can
rcond 1 ov
mp el 2
the sticky bits
accurate eigenvalues of
floating point operation
one norm of
of algorithm 7
with repeat solve
avoid all exceptions
conventional unexceptional floating
eigenvectors of t

corpus/krapavin2000-test/626961.txt
wave
reset
appl
stabilizing
diffusing
module
sn
atomicity
gd
layer
modules
spanning
resets
self
subsystem
father
st
root
processes
stabilization
nonmasking
arora
adjacency
fault
initiate
repairs
coordination
adj
actions
action
anish
tree
resetting
channels
request
masking
tolerant
steady
reach
tolerance
gouda
villain
karaata
nesterenko
election
completion
tolerate
session
franck
leader
enabled
8i
guaranteed
mehmet
rooted
eventually
petit
hakan
adjacent
failures
propagates
hmodulei
hactioni
gs3
declarationsi
ajoy
propagated
fairness
communicate
predefined
vincent
ht
mohamed
reaches
mittal
hongwei
healing
read
increment
stabilize
regained
schneider
mikhail
progress
initiates
guard
faults
afek
yehuda
kulkarni
datta
initiated
consensus
lost
annual
periodically
appendix
token
resuming
cycle
requests
interleaving
erroneous
updates
channel
reachable
rounds
layered
reconfiguration
var
maintains
480
snap
fail
wireless
terminate
resume
forest
networking
passing
protocols
impossibility
travels
putation
restored
convergence
irrespective
layers
stop
snapshots
inconsistent
propagate
62
rings
transient
telecommunications
updated
predicate
spanningtree
hassignment
redress
bapat
thetadg
hparameter
ravikant
colette
anat
cournier
upsets
alternator
paulitsch
conjoined
johnen
bumped
prajwal
attie
hguardi
naik
azzedine
seiya
696
precaution
bremler
strarvation
boulinier
fujii
boukerche
1193
biconnected
maximizable
gradinariu
tta
kopetz
abrougui
cobb
liming
miyashita
wilfried
arumugam
statementi
kaouther
fatima
vora
kulathumani
belkouch
bui
joffroy
1543
hmodule
marco
collective
mask
lastly
executing
comprises
maintenance
exhibit
zhang
ensuring
symposium
wave i
appl i
i module
sn i
self stabilizing
distributed reset
i modules
reset subsystem
diffusing computation
root i
st i
tree i
up processes
global state
reset wave
process p
the reset
the wave
wave layer
spanning tree
root process
tree layer
write atomicity
a reset
state in
completion wave
module wave
distributed system
request wave
reach a
in gd
adjacency relation
the spanning
our reset
each appl
a state
application layer
reset is
the tree
guaranteed to
arbitrary state
the adjacency
a distributed
distributed computing
appl j
wave reaches
each wave
local appl
distributed resets
each process
the system
layer is
is guaranteed
read write
to initiate
masking fault
state of
some appl
given global
i sn
6 reset
session number
module maintains
predefined global
repairs of
and channels
processes and
fault tolerance
starting at
anish arora
nonmasking fault
fault tolerant
the root
f i
state satisfying
to reach
the father
to eventually
the state
p i
i to
in progress
of appl
root j
8i sn
low atomicity
updates st
local wave
rooted spanning
a diffusing
increment operation
been reset
adj i
under system
wave of
reset the
processes in
our design
a steady
i 6
an arbitrary
state the
and wave
initial graph
stop failures
arbitrary distributed
n st
of distributed
h l
leader election
coordination between
steady state
the request
of up
d i
can tolerate
p j
self stabilization
stabilization of
the predefined
reset to
state where
failures and
system is
62 n
v 62
modules in
fail stop
system execution
eventually reach
its local
each tree
vincent villain
upon starting
petit vincent
when faults
module tree
variable st
process action
wave wave
father process
wave from
self stabilize
hakan karaata
layer discussed
gd where
global reset
reset of
mehmet hakan
diffusing computations
adjacent processes
stabilizing global
module appl
value denotes
and repairs
i root
j module
adjacent process
franck petit
the appl
mohamed g
propagated the
g gouda
state detection
in appendix
any state
state predicate
modification is
output relation
resets the
computing v
subsystem is
processes or
that starting
and distributed
parallel and
process to
a module
a spanning
to reset
has propagated
systems self
wave that
adjacency graph
father of
resetting the
proof presented
2005 mehmet
that self
distributed systems
system to
journal of
we exhibit
the up
may 2002
a completion
given distributed
from normal
tolerate the
propagates the
a distributed reset
reach a state
the wave layer
read write atomicity
guaranteed to reach
the tree layer
the root process
appl i module
state in gd
appl i modules
module wave i
is guaranteed to
a state in
the spanning tree
our reset subsystem
wave i module
each appl i
an arbitrary state
the reset wave
system is guaranteed
the adjacency relation
process p i
wave layer is
processes and channels
the reset subsystem
of up processes
each wave i
to reach a
starting at an
the application layer
tree i module
given global state
wave of the
reset is in
the completion wave
each tree i
i module maintains
the request wave
st i from
distributed reset is
layer is guaranteed
some appl i
the system is
in the adjacency
guaranteed to eventually
the state of
a steady state
distributed computing v
a self stabilizing
computing v 62
in the system
is in progress
reset subsystem is
maintains a variable
i sn i
and wave i
state in g
increment operation in
wave reaches the
tree i and
the predefined global
fail stop failures
reaches the root
repairs of processes
resets the state
closed under system
8i sn i
arbitrary state in
updates st i
state of its
the up processes
i 6 reset
st i 6
any state the
set of up
wave i modules
each l such
rooted spanning tree
under system execution
a diffusing computation
n st i
state of appl
of each appl
the initial graph
at any state
its local appl
i n st
module maintains a
that 0 l
starting at any
i and wave
up processes in
a reset wave
that starting at
distributed system to
root i to
to eventually reach
tree i modules
a state satisfying
the tree i
at an arbitrary
each process p
of the system
processes in the
of parallel and
stop failures and
62 n 5
of the wave
sn i n
eventually reach a
in the spanning
masking fault tolerance
journal of parallel
and distributed computing
a global state
a distributed system
input output relation
of its local
0 l k
show in appendix
parallel and distributed
v 62 n
principles of distributed
the distributed system
in a steady
process p j
of distributed computing
state of the
of processes and
normal to initiate
from normal to
i has propagated
mehmet hakan karaata
is reachable by
value denotes the
a reset subsystem
state the wave
diffusing computation and
initiates a reset
mohamed g gouda
local wave i
reachable by some
wave wave i
i root i
has propagated the
tree layer is
up processes and
to propagate a
arbitrary state the
module tree i
global state detection
a rooted spanning
franck petit vincent
variable st i
stabilizing global state
whose value denotes
x j i
steady state where
predefined global state
given distributed system
local appl i
a given global
reset wave reaches
root process p
diffusing computation is
sn i j
the appl i
in gd where
wave i has
petit vincent villain
i from normal
layer discussed in
and is waiting
failures and repairs
root i j
the proof presented
proof presented in
when faults occur
of appl i
sn i sn
the state predicate
self stabilizing global
nonmasking fault tolerant
2005 mehmet hakan
a completion wave
appl i is
of a module
on principles of
i in the
a spanning tree
symposium on principles
from the given
for each l
self stabilization of
computation and is
of the spanning
the adjacency graph
process p k
can tolerate the
i whose value

corpus/krapavin2000-test/626974.txt
decoupled
ep
caches
cache
ap
uniprocessors
strcpy
latency
saxpy
locality
architectures
slip
instruction
queues
zs
uniprocessor
queue
instructions
deap
processor
eod
memories
memory
execute
astronautics
livermore
interleaved
bandwidth
pipe
sensitivity
benchmarks
convolution
fetch
architecture
insensitivity
r2000
unequal
unbalance
llls
noninterleaved
operands
benchmark
traces
lawrence
fetched
cycles
correlation
decoupling
speedup
loops
processors
mips
bottleneck
tokens
access
pipelined
wm
studies
bus
spatial
streams
token
parallelism
computers
temporal
effects
load
string
cray
block
ahead
unrolling
simulation
cycle
fom
uniproc
handcoded
slow
miss
trace
exhibit
significance
simulations
fig
dae
3100
chip
sma
furnishes
contentions
slower
instr
deposited
hide
cached
register
vlsi
limitations
count
deposit
linpack
flushed
bytes
organizations
grain
alleviate
concluded
exhibits
module
calculation
speed
compiler
increments
interleaving
simulators
width
peak
20000
bits
capturing
array
waiting
hides
organization
dec
architectural
delay
benefit
demand
past
bottlenecks
evident
stand
read
microprocessor
ibm
loaded
6000
routine
attained
offs
assembly
12022
strcmp
porpodas
6001
interlocks
lll3
5cycles
heel
unrealistically
30580
11083
6600
20065
25435
24497
tripling
parcerisa
19524
15cycles
nonpipelined
crago
milidonis
12253
lll1
noncached
1938
espasa
alachiotis
31560
whereupon
wulf
lll11
furnishing
gaudiot
1094
goutis
2251
1070
5926
sdp
kakarountas
mask
baseline
rs
busy
conduct
accessing
consume
superior
ratio
strong
controller
computations
buffering
achilles
fifos
3975
writeback
decoupled architectures
the ep
the ap
memory latency
decoupled architecture
the decoupled
of decoupled
in decoupled
execute processor
a decoupled
with caches
access processor
memory access
the memory
decoupled systems
decoupled system
the execute
access time
decoupled computers
latency effects
and decoupled
zs 1
the access
uniprocessors with
the cache
temporal locality
execution time
cache based
to memory
with cache
the uniprocessor
spatial locality
data memory
ap and
data cache
address calculation
astronautics zs
access execute
the queues
without caches
read queue
lawrence livermore
main memory
and execute
data caches
memory speed
from caches
the astronautics
livermore loops
decoupled access
of memory
block size
uniprocessor with
the benchmarks
instructions are
memory bandwidth
architecture performance
caches and
locality and
sensitivity of
uniprocessors and
architectures can
saxpy unequal
cray 1
that decoupled
write queue
instruction streams
memory unit
the lawrence
strong temporal
in saxpy
the queue
cache in
a bottleneck
cache memories
bandwidth requirement
caches in
memory module
total bandwidth
access and
in fig
an access
effects in
architectures with
slow memory
and ep
memories the
performed simulations
two processors
performance advantage
larger block
memory cycle
simulation study
latency and
memory is
total execution
execute architectures
ap has
the deap
latency sensitivity
structured memory
the slip
the strcpy
certain latency
calculation instructions
cached uniprocessors
memory path
its section
the zs
once memory
eod token
data operands
execute processors
pipelined memory
to uniprocessors
ep stand
wm architecture
ap instructions
cache organizations
the llls
cache decoupled
the saxpy
deap architecture
alone execution
data fetch
both uniprocessors
the wm
the eod
ap ep
complete its
tokens to
the sensitivity
in execution
memory system
the bus
data elements
a cache
the data
on chip
this benchmark
bus width
demand by
by capturing
caches can
ep can
mips r2000
interleaved memories
15 cycles
limitations associated
single processors
that caches
significance of
the performance
the speedup
the read
and cache
of demand
pipe a
convolution and
ep and
ap can
24 8
computer program
interleaved memory
single cycle
insensitivity to
performance to
sensitivity to
section of
cache is
the mips
caches is
a miss
grain parallelism
32 bits
instruction caches
and correlation
the pipe
a data
benefit from
simulation results
increase in
queue and
the code
systems we
of cache
are fetched
queues in
bandwidth requirements
not benefit
time the
the significance
the effects
be concluded
in problems
96 1
processor would
system with
the write
the total
a decoupled architecture
the execute processor
the decoupled system
in decoupled architectures
a data cache
the memory latency
the access processor
access and execute
of memory latency
memory access time
latency effects in
astronautics zs 1
memory latency effects
in a decoupled
effects in decoupled
to memory access
the main memory
the astronautics zs
the ap and
the read queue
memory latency and
decoupled access execute
lawrence livermore loops
benefit from caches
decoupled architectures with
effects of memory
simulation study of
the data memory
uniprocessor with cache
to memory latency
ap and ep
data cache in
of decoupled computers
decoupled architectures can
as the memory
the access and
performance of decoupled
and decoupled systems
by the execute
and decoupled architectures
by the ap
to the ep
uniprocessors and decoupled
uniprocessors with caches
and the astronautics
cache based systems
the uniprocessor with
decoupled architecture performance
caches and decoupled
the write queue
for the decoupled
cache in a
strong temporal locality
the total bandwidth
and without caches
the two processors
to complete its
in execution time
the total execution
total execution time
a simulation study
the memory access
effect of memory
demand by the
the address calculation
structured memory access
decoupled systems with
stand alone execution
time the ep
data caches in
its section of
and execute processors
do not benefit
the zs 1
study of decoupled
complete its section
of demand by
ep stand alone
the ap has
decoupled system the
ahead of demand
of decoupled systems
with cache decoupled
fine grain parallelism
the ap can
we performed simulations
the lawrence livermore
the deap architecture
associated with caches
an access processor
the ep can
sensitivity to memory
memory latency sensitivity
the decoupled architecture
in saxpy unequal
address calculation instructions
of the wm
access execute architectures
alone execution time
significance of a
of the decoupled
of decoupled architectures
in problems with
uniprocessors with and
convolution and correlation
between the access
the wm architecture
section of the
with and without
and the ep
of the pipe
spatial locality and
a computer program
limitations associated with
reported in 24
0 96 1
the time the
of the cache
performance evaluation of
execution time the
the sensitivity of
of the code
in fig 2
beyond a certain
memory cycle time
evident in the
the significance of
token to the
the memory system
not benefit from
the execution time
of the memory
access time of
increase in execution
the cache is
be concluded that
the performance of
can reduce the
can be observed
when the memory
main memory is
of a computer
of a data
the effects of
of the string
execute processor would
other decoupled architectures
that decoupled architectures
the cray 1
choice for cpu
instruction buffering techniques
can run ahead
performed simulations to
of performance to
correlation and strcpy
than spatial locality
a certain latency
without caches and
decoupled architecture is
total memory access
unequal increments the
also once memory
memory poses a
saxpy do not
the access process
decoupled architectures and
eod token to
that temporal locality
for microprocessor cache
of each benchmark
caches can reduce
on chip instruction
data memory unit
the fast memory
of instruction buffering
these benchmarks the
uniprocessors without caches
buffering techniques memory
decoupled architectures exhibit
architecture a simulation
if the ap
the slip that
different instruction streams
access related instructions
register and cache
decoupled architecture the
a miss and
zs 1 central
performed simulations with
the data fetch
computations the access
limitations of decoupled
offs for microprocessor
in speed up
of memory speed
decoupled architecture in
only spatial locality
from caches if
requirement but not
6000 and the

corpus/krapavin2000-test/626977.txt
tmr
rshw
rhwr
permanent
faults
voting
fault
failure
voter
redundancy
unsuccessful
faulty
probabilities
reconfiguration
rshws
voters
module
spares
modules
retry
nominal
recovery
failures
transient
phi
mnr
likelihoods
comparator
disappearance
modular
detection
fs
ovrs
ovr
occurrence
pdf
transition
km
policy
disagreement
ftmp
retries
switching
recover
triple
rollback
tolerant
vmp
microcomputer
votings
merger
markov
reliability
coincident
hardware
hours
inducing
omega
renewed
evolved
prior
fig
figs
8g
oe
sm
transitions
spare
ij
disappear
checkpointing
chain
detected
resynchronizing
koren
watchdog
i2f2
hagbae
pmn
task
recovers
detectors
bayes
kim
shin
multiprocessor
successful
nonfaulty
healthy
purging
effects
simplified
processor
simplex
replacement
caused
resynchronization
i2f0
comparators
upon
restart
reload
eq
instruction
adaptive
reconfigure
resetting
overhead
buses
estimating
frequent
costs
simulations
execution
self
probability
spatial
infrequent
laplace
persistence
majority
manifest
4g
rates
redundant
accurately
arrival
units
diagnosis
unlimited
occurrences
detecting
merged
kang
masks
likewise
tasks
allowable
occurred
estimated
prob
effective
mismatch
minimizing
ccoincident
redun
kolmogrov
kook
tfa
recoverying
jpl
rhwrs
chuck
dancy
collectors
naresh
triplicated
currence
metra
intercheckpoint
meissner
demerit
oereconfiguration
hasty
mmp
nonpermanent
byonghyo
shanbhag
cazeaux
transited
byung
1217
mask
paths
tolerate
shift
tolerance
star
recovering
controller
recovered
erroneous
persistency
1337
fij
hfa
1225
daniele
rollbacks
cecilia
rail
standby
sojourn
1331
hypercube
chip
hybrid
priori
update
gammaf
a tmr
tmr failure
tmr system
permanent faults
non permanent
permanent fault
of permanent
the tmr
possible states
tmr failures
upon detection
rshw and
of rshw
task execution
and rhwr
of rhwr
unsuccessful rshw
time x
phi phi
system state
i f
faulty module
modular redundancy
x f
triple modular
probabilities of
fault state
system reconfiguration
detection of
the fault
chain model
prior state
execution time
t i
between rshw
re execution
nominal task
the probabilities
faults and
expected cost
recover from
fault s
transition probabilities
in fig
fault states
most tmr
tmr systems
spatial redundancy
switching operation
two voters
retry policy
or rhwr
rshw is
of spares
the rshw
of tmr
the occurrence
likelihoods of
omega omega
method 1
the probability
faulty modules
time overhead
markov chain
of voting
a voter
probability of
occurrence of
the transition
from s
all possible
a task
multiple module
voting policy
rshw or
occurrence rate
ovrs of
rshw becomes
voting failure
simplified markov
tmr structure
the mnr
voting interval
of unsuccessful
frequent voting
with rshw
time redundancy
adaptive method
fault parameters
nominal execution
the ovrs
voter fault
rhwr based
transient faults
the prior
at time
a permanent
the likelihoods
an unsuccessful
the pdf
voters and
optimal recovery
possible fault
during x
c ij
the nominal
states at
prior probabilities
faults is
state model
back off
the task
oe oe
faults are
method 2
increases with
transition matrix
voting and
bayes theorem
cost of
the expected
the system
fault tolerant
failure detection
state probabilities
pdf of
from most
rhwr the
for tmr
c vmp
recovers from
module replacement
rshw upon
general rollback
unsuccessful rshws
module faults
x increases
one rshw
voting time
off time
rhwr is
instruction retry
either until
optimal voting
failure possible
having caused
of rshws
path j
th voting
model fs
rshw will
rshw which
without estimating
failure increases
fault modules
shift out
to recover
of non
an optimal
in figs
evolved from
faults can
the bayes
s 5
fault detection
s 8
coincident faults
fs 1
the comparator
failure during
fs 0
error s
sub paths
re executed
prior states
fault occurrence
fig 3
states which
the simplified
type ii
the faulty
the effects
the time
self checking
transient fault
processing modules
expected costs
eq 3
p n
s i
failure is
time of
overhead of
failure the
voting in
and restart
in method
hardware cost
detecting a
e gamma
a tmr failure
of a tmr
of permanent faults
a tmr system
t i f
upon detection of
all possible states
rshw and rhwr
non permanent faults
the system state
detection of a
of non permanent
task execution time
phi phi phi
the tmr system
the tmr failure
time x f
cost of rshw
non permanent fault
the probabilities of
markov chain model
nominal task execution
between rshw and
occurrence of permanent
execution time x
the expected cost
expected cost of
probabilities of all
of all possible
triple modular redundancy
the probability of
most tmr failures
of permanent fault
permanent fault s
that of rhwr
at time x
an unsuccessful rshw
from s i
a permanent fault
the likelihoods of
the occurrence of
omega omega omega
time overhead of
of the task
the time overhead
possible fault states
voters and a
behavior of non
estimating the system
simplified markov chain
the nominal task
likelihoods of all
a non permanent
tmr failure the
model in fig
f t i
number of unsuccessful
tmr system with
the bayes theorem
the ovrs of
time of voting
a voter fault
possible states at
nominal execution time
permanent faults and
rhwr based on
rshw or rhwr
number of spares
tmr failure is
from most tmr
the time of
to recover from
states at time
i f and
the transition probabilities
larger than that
probability of a
time t i
due to multiple
in fig 3
the prior probabilities
at the time
faults and the
gamma 1 th
multiple module faults
of rshw and
caused the tmr
chain model in
number of rshws
having caused the
2 n t
e gamma 2
increases with x
back off time
detecting a tmr
when a tmr
two voters and
of an unsuccessful
one faulty module
the faulty module
of unsuccessful rshws
of one faulty
gamma 2 n
as x increases
failure possible states
the optimal voting
tmr failure during
tmr failure or
becomes larger than
during x f
until the expected
the hardware cost
permanent fault modules
state model fs
tmr failure increases
rshw becomes larger
the fault parameters
of tmr failures
tmr failure detection
without estimating the
the effects of
of a task
a transient fault
possible states and
the prior state
because the probability
the transition matrix
to the occurrence
the pdf of
can recover from
of t i
faults can be
oe oe oe
or until the
n t a
at time t
t i j
units of time
state at the
p and r
is derived by
2 i n
than that of
the behavior of
during the execution
be the time
the comparator can
5 or s
x i2f2 5
x without estimating
and the bayes
detected and recovered
x f evolved
same hardware rshw
the next rshw
using triple modular
cost of rhwr
i2f0 1 4g
modular tmr multiprocessor
tmr system can
p n s
5 8g i2f0
rshw increases with
is made while
optimal checkpointing of
time and hardware
multi voting policy
and a comparator
the simplified markov
type ii failure
with the nominal
the optimal recovery
c 1 k
th and i
prior state i
ii and type
failure increases with
probability of permanent
1 k x
re executed without
tmr system is
each unsuccessful rshw
of rshw becomes
on their expected
of system states
and rhwr based
to eq 3
bayes theorem the
faults in different
vs x for
tmr failure and
failure or until
an optimal retry
in a tmr
costs of rshw
to type i
transitions over the
of one rshw
modular redundancy fault
on fault classification

corpus/krapavin2000-test/626980.txt
fbdd
obdd
hwb
omega
ae
boolean
psi
bdd
deltaff
au
synthesis
red
bdds
sink
algebraical
circuit
diagrams
bryant
manipulation
bry91
representations
merging
bry86
phwb
theta
deletion
tp
isa
sy
branching
gm92a
verification
equivalence
ib
v0
succinct
hwbfbdd
brb90
satisfiability
quantification
drechsler
wegener
canonical
gamma
hidden
efficiently
00
gm92b
bcw80
jawahar
algebraically
weighted
orderings
decision
tautology
sinks
bn
sangiovanni
vincentelli
jose
labeled
aided
gnther
jain
circuits
pc
signals
cited
wt
equ
eliminate
quadratic
successor
exponential
rolf
nonterminal
ingo
subtype
restrictions
binary
united
wm
congruent
testability
mention
kbs93
sw92
fhs78
bollig
brace
sieling
nobdd
bry92
bbbn
400111
beate
darwiche
thetafl
rudell
mei89
ake78
labelled
bit
tasks
compose
remark
hash
ordering
congruence
4n
rule
quantifications
narayan
sentations
gamma1
symbolic
california
packages
shannon
san
wolfgang
adnan
fujita
segmented
switch
redirect
dags
succinctness
v1
z
package
polynomial
np
vlsi
transistor
merged
tested
internal
logic
became
gammai
amit
uniquely
ist
henrik
multiplication
decomposable
repre
combinational
logn
236
automation
223
indirect
merely
reductions
alberto
quantify
proposition
source
predecessors
son
going
heuristics
label
deleting
read
cubic
probabilistically
minimization
programs
containment
frontiers
ordered
altogether
reducible
inputs
working
woelfel
allmost
perkowski
1209
mwbs88
bjaaf92
ffk88
bcm90
gm93b
brkm91
thathachar
jphs91
mdd
fbdds
probabilistical
occure
bhr90
bhr91
falkowski
meinel
brayton
fs90
fbdd s
ae ae
obdd s
omega omega
z z
an fbdd
of fbdd
gamma psi
omega ae
boolean functions
theta theta
a au
of obdd
the fbdd
fbdd p
red a
boolean synthesis
merging rule
binary decision
bit function
weighted bit
hidden weighted
deletion rule
r gamma
decision diagrams
reduced fbdd
x k
a a
of boolean
of type
the merging
boolean manipulation
basic tasks
complete type
branching programs
type hwb
p 00
variable ordering
boolean function
psi r
fbdd of
ae j
function hwb
for boolean
the deletion
the obdd
binary boolean
synthesis steps
tp p
synthesis step
of hwb
the hidden
an obdd
p 0
ae a
equivalence test
psi a
red p
au deltaff
fbdd representations
2 ib
variable orderings
in bry91
labeled by
size p
j omega
circuit design
sink path
to sink
read once
psi gamma
s of
j x
the circuit
o size
z ae
a type
obdd representations
sy n
to fbdd
fbdd size
deltaff gamma
size obdd
with obdd
tasks of
ordered binary
by means
in terms
us mention
source to
type 0
manipulation of
the type
as obdd
hwb for
fbdd phwb
size fbdd
n fbdd
phwb for
succinct and
deltaff theta
deltaff a
two fbdd
bn deltaff
fbdd type
of synthesis
an algebraical
for fbdd
au omega
fbdd concept
equivalent nodes
algebraically reduced
hwb can
au bn
path each
hwb is
for obdd
important functions
with fbdd
merging and
internal variables
manipulation with
terms of
k 3
means of
let us
a bdd
cited in
3 x
x n
integer multiplication
circuit verification
au r
efficient manipulation
ae theta
bdd based
work with
the equivalence
the verification
space efficient
and manipulation
design p
for f
0 and
ae omega
exponential size
by bryant
california united
labelled by
p or
jose california
each variable
by x
of ones
efficient solutions
sometimes even
data structure
and p
f k
representations of
ae r
p of
computer aided
efficiently in
united states
graph driven
type tp
v0 and
input fbdd
type cited
equ fbdd
hwbfbdd for
fbdd is
algebraical congruent
variable quantification
obdd size
once branching
function isa
to obdd
apply procedure
hence efficient
since fbdd
by red
sinks of
external signals
more sometimes
most 4n
fbdd pc
fixed type
ingo wegener
fbdd we
congruence relation
art data
storage access
or tautology
ib n
satisfiability or
n hwb
hwb and
algebraical reduced
ae ae ae
z z z
omega omega omega
of fbdd s
omega omega ae
a a au
a a a
terms of fbdd
r gamma psi
of obdd s
an fbdd p
theta theta theta
the merging rule
hidden weighted bit
weighted bit function
binary decision diagrams
the hidden weighted
the deletion rule
fbdd s of
omega ae j
gamma psi r
for boolean functions
of boolean functions
and p 00
ae a a
bit function hwb
of an fbdd
omega ae a
of the fbdd
obdd s are
of the merging
x k 3
0 and p
of boolean manipulation
of type hwb
basic tasks of
a complete type
gamma psi a
fbdd of type
terms of obdd
tasks of boolean
boolean synthesis steps
in terms of
for the hidden
x k 2
p 0 and
j omega omega
psi r gamma
psi a a
the basic tasks
boolean synthesis step
fbdd p of
a au deltaff
ae j omega
red a p
z z ae
k 3 x
j x k
to sink path
x k 1
z ae ae
3 x k
psi gamma psi
gamma psi gamma
by means of
deltaff gamma psi
obdd s of
the equivalence test
boolean functions in
to fbdd s
h 1 n
cited in figure
is an fbdd
with obdd s
means of the
ordered binary decision
source to sink
structure for boolean
r r gamma
let us mention
boolean manipulation with
can be performed
and manipulation of
boolean functions with
reduced fbdd s
au omega omega
efficient solutions of
k 2 x
two fbdd s
functions in terms
the circuit design
ae ae r
a au omega
deltaff theta theta
each source to
fbdd s for
with fbdd s
an fbdd of
obdd s for
s of type
as obdd s
the merging and
ae theta theta
fbdd s p
binary boolean synthesis
a au bn
on each source
obdd s in
for fbdd s
labelled by x
fbdd s is
o size p
on level l
hwb can be
a au r
sy n fbdd
p of type
the fbdd concept
efficiently in terms
bn deltaff theta
deltaff a a
au bn deltaff
to work with
jose california united
aided design p
h i j
on computer aided
a type 0
number of ones
labeled by x
representations of boolean
f j x
ae omega omega
u and v
california united states
ieee acm international
of the circuit
san jose california
data structure for
r a a
s p 0
us mention that
g 1 n
x n and
2 x k
nodes u and
omega ae omega
size obdd s
type tp p
z z x
fbdd s let
variable is tested
for obdd s
indirect storage access
1 n hwb
fbdd phwb for
path each variable
the sinks of
the fbdd s
storage access function
fbdd s similarly
read once only
efficient manipulation of
fixed variable ordering
that the verification
binary boolean operation
wolfgang gnther rolf
more sometimes even
once branching programs
time o size
applying the merging
that red a
based data structures
r ae ae
to obdd s
bdd based data
a reduced fbdd
type 0 such
over x n
ae r gamma
even exponentially more
a fixed variable
a congruence relation
as result an
au r ae
any variable ordering
analysis and manipulation
gnther rolf drechsler
case of obdd
labeled by 0
size p 0
fbdd s the
or red a
satisfiability or tautology
remark only that
single boolean synthesis
type cited in
obdd s to
2 ib n
f 2 ib

corpus/krapavin2000-test/627003.txt
bank
banks
subbank
subbanks
queue
buffering
cycle
port
logical
mp
lbr
unbuffered
streams
efficiency
cray
interconnection
processor
reference
stride
ports
conflicts
bailey
register
processors
references
stream
strides
loading
buffered
latency
writes
simulation
slots
arbitration
dram
conflict
intraprocessor
return
memory
simulations
memories
latch
cycles
queues
pipeline
reads
throughput
load
read
doubling
physical
ae
bandwidth
interreference
skewing
multiprocessor
pipelined
registers
subsection
predicted
eight
priority
drams
reserved
initiate
sram
sohi
agreement
vector
busy
moderate
initiation
256
taylor
degradation
vectorized
vii
designs
probability
successful
varied
arrived
predictions
attempts
cessors
smith
2l
freed
slot
cached
handshaking
seznec
jegou
9957
initi
llaberia
quadrupled
saturation
buffers
effective
scaling
relationships
predicts
issued
held
interleaved
chip
requests
delayed
briggs
corral
67
probable
robin
queuing
slower
rate
947
chained
club
reordering
network
plotted
drops
estimated
superscalar
drop
unpredictable
circuitry
blocked
bus
efficiencies
arrive
feedback
ated
compensated
excellent
loads
analytical
probabilities
increased
la
2048
del
contention
hit
thrown
filled
ram
sub
succession
conservation
chips
scalar
caching
unsuccessful
viii
doubled
examined
initiated
1024
subdivided
juan
instruction
vectors
request
dramatically
explores
routed
attempt
runs
dramatic
versus
pro
tag
hardware
ili
maximumlength
9731
equalizing
ister
dspa
0118
subishi
toni
hotspot
bitration
rambus
temam
ganization
0950407
multivector
borderline
diffi
terization
simulta
fourths
fan
benchmarks
substituted
logical bank
bank cycle
cycle time
logical banks
reference streams
the bank
bank model
the logical
y mp
cray y
the efficiency
queue size
of banks
the lbr
the unbuffered
efficiency is
the cray
the subbank
a reference
interconnection network
the processor
successful reference
unbuffered case
per logical
vector simulation
a queue
the vector
vector register
lbr is
the interconnection
reference is
the queue
independent reference
banks are
banks is
the effective
efficiency in
the return
sub bank
bailey model
port line
scaling relationships
subbank cycle
the bailey
return conflicts
probability that
the memory
e l
the probability
of stride
read latency
latency is
reference stream
banks in
mp architecture
bank level
physical bank
stride one
bank is
vector element
vector registers
without buffering
return ports
subbanks per
effective efficiency
reference rate
the port
at 5
memory efficiency
random reference
the buffered
the simulation
a bank
memory systems
the reference
a vector
is free
of logical
for reads
memory banks
of return
banks the
is making
reference on
of reference
a logical
t c
of processors
infinite queue
port is
each port
physical banks
buffering at
banks and
initiation rate
vector references
return port
each subbank
of attempts
taylor 20
eight processors
interconnection costs
one vectors
of subbanks
register feedback
the latch
output buffering
moderate loading
plotted versus
of memory
memory cycle
and taylor
memory operations
smith and
t l
design parameters
an efficiency
simulation study
the physical
a successful
of four
bank the
interconnection cost
memory performance
efficiency of
constant at
a memory
efficiency the
time is
fixed at
per processor
reads and
reserved for
for writes
priority scheme
streams is
between reads
memory bank
stream is
and writes
processors and
the simulations
vector operation
queue for
a conflict
four the
one reference
efficiency will
the load
simulation model
element latency
maximal loading
bank register
bank can
vector simulations
t la
ports per
by smith
stride distributions
port on
return interconnection
path simulation
vector read
additional lines
bailey 1
64 processor
three ports
of 67
design criteria
under moderate
queue case
bank hit
reference attempt
without logical
latch is
register lbr
x mp
port for
by bailey
same efficiency
cray x
data path
doubling the
physical memory
access time
cycles and
is varied
of load
a simulation
streams are
processor can
for random
in efficiency
agreement between
register is
probability of
is plotted
analytical model
throughput is
shared memory
bank cycle time
the logical bank
the bank cycle
logical bank model
cray y mp
number of banks
the cray y
the efficiency is
cycle time is
a logical bank
queue size of
a queue size
per logical bank
cycle time and
of reference streams
the unbuffered case
a successful reference
independent reference streams
with a queue
number of reference
the number of
size of four
the bailey model
of logical banks
cycle time the
the efficiency in
cycle time of
the lbr is
subbanks per logical
smith and taylor
in the unbuffered
subbank cycle time
y mp architecture
the probability that
number of logical
number of processors
in the queue
at the processor
an efficiency of
size of two
memory cycle time
logical bank cycle
between reads and
read latency is
logical banks is
when the bank
the logical banks
constant at 5
of stride one
buffering at the
bank model is
and taylor 20
the vector register
the vector simulation
number of subbanks
stride one vectors
number of attempts
the infinite queue
is making a
is plotted versus
the effective efficiency
the physical memory
probability that a
reads and writes
probability that the
queue size is
the interconnection network
is fixed at
cycles and the
the reference is
the queue size
of the logical
to the processor
a simulation study
the processor in
the vector registers
reference streams and
plotted versus the
infinite queue case
logical banks are
reference streams is
by smith and
stream is making
number of return
logical banks the
logical bank hit
percentage of stride
the sub bank
the same efficiency
data path simulation
is free it
cray x mp
efficiency is plotted
making a successful
the cray x
it is reserved
the read latency
to estimate e
vector simulation model
reference probability that
as the bank
the latch is
a reference attempt
per processor interconnection
cycle time when
when a reference
banks in the
a 64 processor
a bank cycle
logical banks to
that a queue
logical bank register
on the return
reference streams are
at the bank
three ports per
logical bank is
bank register lbr
ports per processor
the bank level
reserved for t
type of load
held constant at
return port for
bank hit is
of banks and
the return interconnection
for each subbank
a reference on
of banks is
vector memory operations
a vector read
simulation study by
the physical bank
eight processors and
initiate a reference
element latency is
without logical banks
logical bank can
of return ports
the interconnection costs
in the simulation
in section vii
efficiency in the
of the vector
reference on the
for a vector
of four is
the memory cycle
attempt to access
reduce the effective
of the banks
that the stream
on each cycle
of four the
in the cray
and the number
the probability of
the throughput is
the agreement between
doubling the number
the buffers and
is the physical
is reserved for
state in which
probability of a
predicted by the
free it is
buffers and the
and the logical
efficiency will be
each processor can
the stream is
maintain the same
the next cycle
design is to
agreement between the
time and the
e l is
on the cray
the state in
is not full
is assumed that
it is assumed
be estimated as
the load is
over a range
are assumed to
as predicted by
of a logical
assumed to be
on the next
additional interconnection cost
availability of that
condition ffl 1
that a free
design criteria are
logical bank design
ae 5 the
each logical bank

corpus/krapavin2000-test/627005.txt
dbmin
buffers
mg
allocation
buffer
looping
marginal
adaptable
tp
references
mix
throughput
queries
disk
faults
ref
edu
reference
query
page
ud
policy
predictors
admission
yao
allocate
pages
utilization
allocations
waiting
gains
mini
mru
mixes
gain
policies
throughputs
queueing
predictor
allocated
pessimistic
load
noh
chou
queue
jobs
manager
flexible
yookun
jongmoo
dewitt
loads
cho
replacement
allocating
lyul
activate
accesses
sequential
td
loop
sharing
sang
optimistic
concurrent
management
database
choi
cpu
availability
tc
kim
clustered
simulation
runtime
admitted
pool
workload
25simulation
r30
avoidable
random
comparably
predictive
instantaneous
pass
sam
relational
min
051
flexibly
formulas
hot
accessed
pf
activated
50
lru
selectivity
idle
850
951
locality
resident
150
100
fluctuation
allocates
50number
beneficial
harmonic
msec
switching
hits
effective
symbols
multiprogramming
cur
opt
inflexibility
fluctuate
151
weakness
predictions
750
extra
wasted
001
ef
t0
degenerates
201
package
estimate
join
ingres
benefited
demand
effectiveness
patterns
workloads
recurrence
exceeds
activating
adopting
summarizes
cornell
adaptability
chong
referenced
head
exhibited
401
fewest
cf
activation
pp
85
jong
unified
70
301
cycle
job
gamma
cycles
decisions
sub
response
utility
101
usenix
sigmetrics
161
averages
situations
diversity
quantification
usable
simulations
portion
kept
scan
transaction
milliseconds
opearting
schkolnick
r100
ecomonics
junho
hun
oblivion
ssequential
fcfs
16405060708090number
asad
donghee
30number
luxury
admissions
mg x
buffer allocation
of buffers
marginal gain
mg 50
random reference
gain values
random references
marginal gains
the adaptable
of mg
looping reference
page faults
buffers to
allocation algorithms
looping references
concurrent queries
a looping
mg 100
adaptable algorithms
tp o
disk utilization
of queries
load control
x y
data sharing
the reference
waiting queue
sequential reference
the waiting
optimal allocation
yao estimate
available buffers
y algorithms
the mg
the marginal
the buffers
buffer management
s min
o edu
of dbmin
flexible buffer
of marginal
2 pass
adaptable buffer
many buffers
the throughput
allocation policy
ref i
admission policy
effective disk
queueing model
clustered index
edu o
dbmin mg
of page
the disk
a reference
the loop
buffer manager
the pessimistic
gains and
a query
than dbmin
local replacement
and edu
tp and
to allocate
waiting time
allocation policies
edu 2
the allocation
of concurrent
allocation is
mix of
the buffer
s buffers
allocated buffers
extra buffers
the yao
more buffers
buffer utilization
of buffer
simulation results
reference is
on marginal
locality set
dbmin and
with dbmin
throughputs of
allocations to
chou and
h noh
this mix
mini cycle
a buffer
buffer pool
d e
buffers are
buffers that
relative throughput
50 12
and mg
sub optimal
relational database
expected number
buffers at
of available
to looping
two predictors
query mixes
yookun cho
mini cycles
reference l
noh sang
50 y
gain value
queries r
reference ref
total marginal
jongmoo choi
dbmin the
sam h
optimal allocations
k n
the page
access patterns
of allocated
the query
the optimistic
a random
and dewitt
s max
disk load
sang lyul
f faults
r 30
lyul min
non clustered
hot set
in throughput
k t
length k
allocation algorithm
query type
number s
in buffer
c d
f k
our algorithms
to random
100 1
predictors tp
b yao
mix 4
buffers assigned
reference as
e mg
for dbmin
for mg
ud i
may allocate
mix 1
buffers where
page hits
50 18
buffers s
utilization ud
sequential references
dynamic workload
dbmin in
min yookun
adaptable allocation
disk loads
resident pages
total buffers
this reference
throughput of
references in
state f
buffer to
policy is
buffers and
e a
the jobs
references are
references and
b c
reference s
query mix
class model
allocate to
y s
l k
the system
a sequential
at runtime
buffers is
for buffer
2 mg
mg x y
number of buffers
marginal gain values
the marginal gain
a looping reference
a random reference
of mg x
gain values of
of concurrent queries
the waiting queue
buffers to the
the adaptable algorithms
buffer allocation algorithms
effective disk utilization
of available buffers
the mg x
mix of queries
adaptable buffer allocation
flexible buffer allocation
number of page
e a b
x y algorithms
marginal gains and
l k t
d e a
of page faults
number of concurrent
a sequential reference
availability of buffers
of the loop
c d e
the optimal allocation
mg 100 1
of marginal gains
a buffer allocation
buffers at runtime
the 2 pass
on marginal gains
based on marginal
notion of marginal
mg 50 12
of allocated buffers
tp and edu
the yao estimate
tp o edu
in the buffers
expected number of
r k n
s k n
b c d
the expected number
of the waiting
patterns of queries
to random references
and the adaptable
of buffer management
o edu o
sam h noh
concurrent queries r
queries r a
many buffers to
to looping references
throughputs of dbmin
non clustered index
noh sang lyul
buffer allocation algorithm
y s and
chou and dewitt
h noh sang
looping reference l
of buffers that
marginal gain value
reference l k
sub optimal allocation
mg 50 y
in the waiting
number of available
of length k
of random references
the number s
the random reference
for a looping
sang lyul min
number s of
to the reference
of the system
access patterns of
of queries of
formulas for computing
the access patterns
simulation results show
a b c
to a reference
no data sharing
mg 50 18
buffer utilization and
and s max
lyul min yookun
of buffers assigned
sequential reference is
allocation algorithms based
f faults in
s min a
adaptable allocation algorithms
dbmin mg x
predictors tp and
of buffer allocation
buffers assigned to
s of allocated
of queries with
more buffers to
state f k
min yookun cho
extra buffers to
allocations to looping
in buffer allocation
disk utilization ud
of buffers at
sub optimal allocations
i e mg
min and s
the effective disk
of dbmin mg
types of references
50 y s
queries of type
of the reference
in 2 3
the hot set
for buffer allocation
a buffer manager
the buffer pool
the performance of
at the head
when compared with
t a n
s min and
to a relation
the disk utilization
a sub optimal
x and y
the number of
number of pages
the throughput of
the disk is
the locality set
performance of mg
of data sharing
of ref i
random queries are
151 25simulation time
allocation policies are
allocating extra buffers
relation of size
and 2 pass
reference of length
optimal allocations to
ref can be
buffer allocation in
that of mg
reference at the
random reference as
shown as path
algorithms mg x
come first serve
compared with dbmin
local replacement policies
yao estimate of
2 pass policy
sequential reference s
the adaptable ones
to ref i
buffers are available
the dynamic workload
the x parameter
faults in k
marginal gains which
total marginal gain
in k accesses
o edu 2
portion of avoidable
the looping reference
s min is
the accessed relation
the y parameter
x y scheme
001 101 201
and random references
850 951 051
edu o edu
waiting time and
relative throughput mix
choi sam h
perform comparably to
pages kept in
allocation algorithms are
the pessimistic approach
adaptable algorithms running
looping references and
y becomes 15

corpus/krapavin2000-test/627029.txt
arf
inspector
exchanger
array
processor
dereference
executor
parti
irregular
hashed
translation
fortran
compiler
yold
hash
mesh
processors
arrays
primitives
gather
scheduler
fluxroe
loop
irregularly
860
n1
schedule
unstructured
references
meshes
ia
scatter
accumulations
indices
ipsc
s5
runtime
exchangers
off
subscript
ib
template
strips
cache
nmsgs
flux
kernels
sparse
carry
preprocessing
align
fluxes
jagged
s6
partitioned
loops
kernel
multiply
partition
optimizations
sd
synthetic
dino
partitioning
cols
block
exchange
striped
send
la
euler
blocked
irreg
ms
s3
calls
s1
n2
decomposition
proc
compile
accesses
receive
sweep
costs
strip
efficiencies
nonlocal
vb
tables
map
procedures
codes
assignments
copies
dissection
dereferencing
s2
compilers
baden
aerodynamic
hpff
nprocs
ncols
executors
iterations
pa
endif
solver
accessed
s4
targeting
temp
statements
ffl
communications
index
gagan
lux
statement
descriptors
messages
carried
parallelized
initialization
coded
numbered
setup
carries
s8
ranged
intel
accumulation
referenced
descriptor
va
multigrid
reference
accumulate
foreach
s7
blocks
indirect
multiprocessors
interprocessor
supercomputing
id
extensions
ttable
pan2
iva
inspectors
pan1
ivb
gflops
iiia
gammapartition
stodghill
ivc
icase
gammaprocessor
ivd
stored
locations
fetches
nasa
contiguous
temporary
gathered
clause
mapping
matrix
dimension
dependencies
whitaker
kali
dereferences
iib
672
oak
indirections
pingali
cdrom
reg
count
primitive
williams
owner
communication
compiling
pointer
nest
750
subtract
accumulates
memory
agrawal
iia
idiom
riemann
translation table
distributed array
off processor
the inspector
the arf
hashed cache
arf compiler
distributed translation
hash table
gather exchanger
array elements
each processor
the parti
local array
fortran d
the executor
of off
array references
carry out
the scheduler
ipsc 860
point template
local indices
distributed arrays
table h
vector multiply
irregularly distributed
distributed memory
to carry
global indices
parti primitives
block matrix
data exchange
the distributed
matrix vector
fluxroe kernel
sparse block
build translation
schedule s
the translation
local index
using schedule
distributed irregular
processor data
non local
loop iterations
the hash
the hashed
unstructured meshes
processor p
the loop
translation tables
executor time
accumulations to
language extensions
inspector and
synthetic mesh
array element
the compiler
time required
the array
and receive
and local
5 point
processor assignments
array a
the processor
arrays x
distributed do
scatter exchanger
template synthetic
irregular using
the dereference
mesh partitioned
ia and
array y
the fluxroe
table initialization
executor phase
irregular array
parti procedures
processor distributed
send and
time ms
do i
of distributed
primitives can
processor elements
and ib
call to
processor and
and executor
n proc
s descriptors
k n1
array partition
dereference to
inspector phase
d block
blocked translation
count p
exchanger using
cross processor
on clause
mapping array
to dereference
setup hashed
a hash
in statement
runtime support
of irregular
the scatter
hash tables
the gather
receive calls
n1 and
processor references
the arrays
compile time
a decomposition
mesh a
carries out
primitives that
scheduler and
the subscript
references to
the ipsc
out the
array is
1 4
ms time
time primitives
processor map
k n2
unstructured euler
arrays ia
table hashed
find processor
yold k
both kernels
array map
processor loop
the parallelized
multiply kernel
by dereference
from arf
is irregularly
with map
binary dissection
align x
call dereference
call gather
in arf
euler solver
exchange primitives
cache hashed
insert code
s n1
of yold
arf for
partitioned between
s descriptor
h n1
synthetic meshes
a compiler
local data
copies of
figure 13
loop l
these primitives
for irregular
an irregular
data from
on processor
to processor
processors p
carried out
of array
in hash
ffl generate
irregular patterns
single sweep
match match
edge partition
irregular problems
call setup
d blocks
statements s1
support irregular
a distributed
at runtime
processor the
the communications
a loop
between processors
array reference
the reference
into strips
mesh b
assignments for
the arf compiler
of off processor
the translation table
distributed array elements
distributed translation table
hash table h
of distributed array
to carry out
matrix vector multiply
block matrix vector
off processor data
the distributed translation
the hash table
build translation table
sparse block matrix
required to carry
processor and local
off processor distributed
5 point template
processor distributed array
time required to
send and receive
do i 1
the time required
carry out the
on each processor
distributed translation tables
local array a
copies of off
off processor elements
the parti primitives
template synthetic mesh
point template synthetic
q 0 4
the inspector and
distributed irregular using
ia and ib
the fluxroe kernel
mesh partitioned into
during the inspector
synthetic mesh partitioned
using schedule s
and local indices
a hash table
the gather exchanger
the hashed cache
off processor references
irregularly distributed arrays
arrays x and
the inspector phase
and receive calls
count p then
setup hashed cache
exchanger using schedule
distributed array references
translation table initialization
and local index
the ipsc 860
distributed array element
by the arf
the parti procedures
2 d block
the off processor
processor elements of
inspector and executor
hash table to
non local data
the data exchange
call to the
each processor the
vector multiply kernel
example loop the
call setup hashed
translation table is
hashed cache hashed
table h n1
distributed arrays in
data exchange primitives
irregular patterns of
the executor phase
to find processor
align x y
elements of yold
to processor map
ms time ms
cross processor loop
run time primitives
into 2 d
table initialization and
processors p 3
time ms time
the distributed array
array a 0
arrays ia and
blocked translation table
table hashed cache
irregular array references
hash table hashed
partitioned into strips
call gather exchanger
from arf for
in hash table
each distributed array
the local array
generated from arf
the arrays ia
the scatter exchanger
to each processor
carry out a
the example loop
sparse matrix vector
of non local
array elements to
to support irregular
2 d blocks
ffl generate a
the processor and
to y k
in fortran d
the loop index
a factor of
in a regular
in the hash
fortran d language
a blocked translation
the reference x
array references that
initialization and dereference
array elements in
p then else
of the executor
k 1 4
loop carried dependencies
1 4 from
in an irregular
data from needs
an s descriptor
hashed gamma cache
and computational work
parti run time
the same schedule
call to dereference
finite difference template
intel ipsc 860
y k n1
arf compiler is
array partition is
data in hash
generate the inspector
the on clause
distributed array y
for loop iterations
p 3 figure
local index assignments
flux 1 4
call scheduler id
orthogonal binary dissection
the communications costs
exchanger is generated
the parti run
index assignments for
dereference to find
meshes a and
local indices la
find processor assignments
gather exchanger places
the executor time
that distributed array
map array using
gather exchanger using
patterns of distributed
processor assignments pa
using a mapping
executor for a
for sparse block
id n hashed
scheduler id n
partitioned between processors
call dereference to
of the ipsc
of map array
schedule s n1
partitioned into 2
a distributed translation
parti primitives in
set values of
to off processor
values of map
support irregular patterns
the data arrays
translation table using
f lux k
block sparse matrix
is irregularly distributed
loop to ffl
processor assignments and
scheduler and data
data and computational
needs data from
irregularly distributed array

corpus/krapavin2000-test/627083.txt
transaction
lock
slowdowns
vf
locking
vv
blocking
occ
thomasian
ryu
concurrency
slowdown
permanent
commit
conflict
concurrent
transient
silent
snapshot
queue
commits
optimistic
aborted
herlihy
locks
analytical
conflicts
committing
calculate
aborts
numa
predictions
gammafl
processors
nonblocking
synchronization
processor
object
shared
residence
utilization
contention
executes
ana
throughput
slow
granule
abort
broadcast
enqueue
spin
my
response
cns
executing
priority
multiprocessors
utilizations
execute
faults
executions
stage
pointer
phi
enqueues
lazowska
architectures
items
ticket
fl
approx
conflicting
uma
prakash
atomic
instruction
protocol
static
validation
dequeue
goodman
multitasking
unsuccessful
rate
processes
formulae
bus
simulation
swap
multiprocessor
spends
proportion
atomically
accesses
jobs
queues
dequeues
valois
plj
backoff
zahoran
51
cache
anderson
discrimination
45
probability
calculates
execution
blocked
kills
avl
turek
spinning
unconditional
read
ff
old
calculated
ss
exponentially
exclusive
shasha
mellor
crummey
experience
heterogeneous
restart
seconds
protocols
instructions
queuing
free
switch
cleanup
mf
temporarily
closed
analyzing
stages
composite
compete
56
access
59
dt
agreement
plot
58
database
johnson
formula
poisson
calculations
spite
accurate
service
restarts
stone
workspace
eager
occupancy
validate
kernel
trees
interfering
reserve
ran
considerable
thread
distributions
resource
objects
failed
accessed
permits
idle
enters
researchers
simultaneous
bias
mimd
agrawal
update
permitting
record
poor
frontiers
1e
page
analyses
variety
executed
pessimistic
mechanisms
phenomenon
randomly
6366
regains
9700
lock free
c transaction
non blocking
free algorithms
concurrency control
a transaction
the vf
ryu and
and thomasian
class c
locking algorithms
the vv
non locking
conflict rate
vv model
execution time
a class
per class
structure algorithms
k transaction
vf model
permanent slowdowns
concurrent data
blocking algorithm
permanent slowdown
blocking algorithms
transaction is
optimistic concurrency
closed system
the lock
slowdown model
fl c
silent static
the transaction
calculate the
p c
class k
of lock
the per
an operation
response times
slowdowns are
transaction class
transient slowdowns
transient slowdown
probability that
c t
lock based
system utilization
the operation
transaction model
transaction commits
the permanent
the locking
the v
transaction aborts
gammafl c
slow processors
the ryu
variable time
a lock
conflicts with
shared memory
the ff
the conflict
object instance
the object
performance of
the probability
the performance
data items
concurrent objects
a process
can calculate
in code
shared object
calculate p
transaction conflicts
fixed fixed
dynamic broadcast
commit its
blocking queue
slowdowns can
f model
committing transactions
locking algorithm
class utilizations
fixed class
the silent
time fixed
vf approx
the snapshot
to commit
test and
stage i
lock is
data structure
to calculate
c i
uniformly randomly
residence time
object protocol
numa architectures
its commit
time of
execution times
predictions of
f c
the analytical
a committing
the transient
processor models
aborted transaction
phi k
processor slowdowns
occ in
small slowdowns
object pointer
line faults
code 4
ff model
vf models
composite snapshot
data granule
dynamic concurrency
vv transaction
numa architecture
aborts at
slow operations
slowdown processor
broadcast occ
of slowdowns
old object
of committing
the slowdowns
occ and
operation execution
open system
occur due
response time
algorithms have
a shared
cache line
that lock
b f
a conflict
v f
b c
validation study
atomic snapshot
and swap
e gammafl
will commit
data conflicts
architectures or
the execution
model the
memory multiprocessors
analytical models
shared data
the system
locking protocols
code 2
model makes
of occ
and permanent
snapshot is
transaction processing
is aborted
r c
and set
resource contention
time distributions
in stage
expected execution
context switch
1 class
the closed
executing a
the proportion
to execute
of concurrency
2 variable
t seconds
1 fixed
contention for
transient and
than others
of synchronization
exponentially distributed
contention page
my a
use formula
variable fixed
point old
operation executes
makes poor
transaction executes
executes for
poor predictions
lock free algorithms
class c transaction
a class c
ryu and thomasian
the per class
a class k
class k transaction
optimistic concurrency control
non blocking algorithm
the vv model
the vf model
non locking algorithms
data structure algorithms
probability that a
a non blocking
the probability that
c transaction is
non blocking algorithms
the conflict rate
the performance of
that a class
of lock free
executing a class
free algorithms have
the permanent slowdown
performance of lock
the system utilization
the transient slowdown
calculate p c
the v f
transaction conflicts with
test and set
a transaction aborts
we can calculate
that a transaction
with a class
the closed system
b f c
concurrent data structure
that the vf
free algorithms are
vf model is
the non blocking
that lock free
per class utilizations
the silent static
time fixed class
can occur due
non blocking queue
to commit its
gammafl c t
execution time of
b c t
the ff and
been done to
can calculate the
the v v
residence time of
dynamic concurrency control
calculate the per
c transaction with
cache line faults
slowdowns can occur
the ff model
closed system model
the variable time
and permanent slowdowns
the object pointer
in the silent
the ryu and
1 class 2
class 1 class
phi k c
performance of concurrent
if the slowdowns
permanent slowdown model
the slowdowns are
calculate the conflict
the locking algorithm
transient slowdown model
the transaction is
occur due to
the lock is
shared memory multiprocessors
the execution time
compare and swap
in stage i
transient and permanent
b s c
a closed system
and b f
the snapshot is
to calculate the
if a transaction
time of a
predictions of the
calculate the probability
conflicts with a
in the system
the proportion of
an open system
expected execution time
of a class
has been done
time to execute
of concurrent data
memory and bus
the locking queue
stage ends when
that non locking
committing transaction conflicts
page faults context
in code 2
26 to calculate
faults memory and
2 class 1
formula 26 to
the analytical tools
vv model we
the nonblocking queue
free algorithms in
architectures heterogeneous architectures
and test and
the vf approx
1 fixed fixed
large object protocol
transaction aborts at
conflict rate we
variable time fixed
support lock free
transaction in stage
that the vv
e gammafl c
in the vf
the transaction processing
for the v
vv model is
slowdown processor model
a shared object
in code 4
of lock based
architectures or differences
locking algorithms in
concurrent data structures
response times but
poor predictions of
of processor slowdowns
and the vf
in operation execution
of ryu and
contention page faults
a context switch
b k seconds
in the permanent
conflict rate for
heterogeneous architectures or
2 variable fixed
than locking algorithms
a permanent slowdown
and set lock
of slowdowns on
c transaction in
class 2 class
slowdown model the
aborts at stage
non blocking data
the operation tries
bus contention page
faults context switching
v f model
model is too
static concurrency control
makes poor predictions
permanent slowdowns in
lock based concurrent
differences in operation
operation execution time
vv transaction model
due to cache
line faults memory
two transaction classes
that a committing
numa architectures heterogeneous
that support lock
from the per
to cache line
p c i
and thomasian 51
for the vv
than the locking
time that a
transaction is aborted
in the variable
access to a
p c and
at stage i
close agreement between
a new transaction
and the v
calculated by taking

corpus/krapavin2000-test/627095.txt
polynomials
irreducible
jhj
primitive
aliasing
degree
misr
jhjn
lfsr
jhju
polynomial
faults
feedback
lcm
log
factors
gcd
gf
compacting
register
division
circuit
jhjd
bist
ra
pg
prime
in5
primitivity
2te
in7
lfsrs
exhaustive
ras
08
pgs
factoring
factor
response
ep
signature
divisors
delta
procedures
erroneous
deg
irreducibility
fault
jhjm
ljj
worst
sift
2j
tried
candidate
bounds
lemma
product
cut
circuits
degrees
drawing
modeled
flops
iff
complexities
ttm
1086
jhjl
candidates
000
conducted
fields
dominant
finding
reconfigurable
flip
responses
ranged
jm
divisor
compacted
chakrabarty
smallest
outputs
variance
es
divides
rj
gammaj
took
200
draw
distinct
da
divide
hayes
284
sequences
53
registers
fh
multiplication
roots
compaction
cell
phases
shift
collapsing
dlog
mapped
selections
stuck
experiments
ran
looking
mm
1024
md
operands
try
millions
selecting
aforementioned
tens
ascending
bits
configured
novk
hlawiczka
jhjt
sifts
nosek
uber
1092
onhage
charakteristik
5is
tlog
1we
compactor
zassenhaus
gcds
dalog
minfbd
multiplikation
adleman
99jh
remaindering
6543
ierardi
lcms
schnelle
jhjn2
ljm
plva
1187
jhje
pomeranz
50637
polynomen
garbolino
9280
gucwa
99jhj
orpern
1171
6530
jmd
logarithmic
seconds
referred
tm
pre
logarithm
logic
factorization
160
ob
stage
1210
abstractwhen
misrs
2dlog
breuer
lengthen
dividend
cantor
566
alently
premium
sifting
5j
redundant
oe
saved
mod
error
thousands
expected
non factor
of degree
zero aliasing
o jhj
primitive polynomials
polynomials of
irreducible primitive
feedback polynomial
least degree
degree j
factors of
g i
the polynomials
log log
polynomials g
primitive case
degree non
d a
the expected
08 log
jhj log
degree less
expected bounds
jhj 2
an irreducible
expected complexity
all irreducible
the primitive
primitive polynomial
irreducible factors
primitive non
irreducible polynomials
2 08
the irreducible
i j
factor of
good response
error polynomials
procedure distinct
irreducible case
of h
h i
the degree
the product
d h
is o
2 m
distinct factors
o jhju
jhju 2
factor with
distinct irreducible
gf 2
polynomial of
of polynomials
log s
m d
a primitive
work required
degree of
product of
degree t
finding a
a non
s log
specified degree
smallest degree
aliasing misr
the compacting
log jhj
aliasing polynomial
modeled faults
random polynomials
s d
a zero
less than
factors is
the feedback
worst case
log q
t log
the lcm
expected bound
of irreducible
m n
find a
polynomial for
exhaustive search
a pg
are factors
degree 11
log jhjn
non factors
error sequences
the least
degree d
complexity of
polynomials in
the good
log d
log t
delta log
our expected
test sequence
a m
to find
d i
the circuit
or equal
3 m
irreducible and
log jhjd
feedback polynomials
lcm method
primitive feedback
aliasing lfsr
primitive candidate
primitive zero
expected work
primitive factors
polynomial is
degree at
log n
of faults
2 j
of procedure
over gf
the worst
the complexity
an exhaustive
and o
o u
polynomial that
all primitive
expected degree
than or
p d
u 2
relatively prime
case complexity
a feedback
factor we
polynomials are
the distinct
pre specified
is less
expected number
a polynomial
degree 9
effective polynomial
es h
jhj polynomials
degree irreducible
log 2te
m jhjn
degree m
gcd method
ep h
compacting function
experiments found
than jhj
jhj delta
case bounds
minimum degree
same degree
procedures for
of finding
by o
finite fields
case and
than 1
degree for
j s
for irreducibility
shift register
polynomial division
prime to
a ra
u log
least integer
jhj and
polynomials h
polynomials with
and primitive
the gcd
the effective
the register
is bounded
bounds on
the g
h is
for finding
dominant term
practical test
degree l
complexity is
all distinct
corollary 11
200 000
polynomials we
a non factor
non factor of
polynomials of degree
g i j
primitive polynomials of
polynomials g i
of degree j
degree non factor
least degree non
a zero aliasing
the primitive case
the least degree
of degree less
the polynomials g
2 08 log
2 m n
degree less than
for the primitive
product of all
o jhj log
m d a
finding a non
08 log log
the expected complexity
o jhj 2
is o jhj
primitive non factor
a m d
the irreducible case
non factor with
factors of degree
the good response
factor of degree
irreducible factors of
irreducible primitive polynomials
an irreducible primitive
the product of
the degree of
of h i
factors of h
find a non
and o jhj
irreducible polynomials of
for the irreducible
log log q
factor of h
jhju 2 m
irreducible case and
the feedback polynomial
set of polynomials
degree of the
of degree t
s d h
the expected bounds
d a for
feedback polynomial of
zero aliasing polynomial
all irreducible primitive
of procedure distinct
jhj 2 n
o jhju 2
zero aliasing misr
irreducible primitive polynomial
a primitive non
the error polynomials
degree d a
pre specified degree
number of faults
i 2 j
to find a
polynomial of degree
is less than
i j s
s log s
all primitive polynomials
log d a
of all irreducible
number of irreducible
non factor we
a least degree
case and o
factor with the
u 2 m
the worst case
or equal to
the work required
an exhaustive search
less than or
expected complexity of
of degree at
of the polynomials
the complexity of
factor of a
of finding a
a pre specified
work required to
of a pre
than or equal
irreducible and primitive
the expected work
jhj log jhjd
non factor is
complexity of procedure
the expected bound
u 3 m
log log d
distinct irreducible factors
procedure distinct factors
a feedback polynomial
find a zero
primitive zero aliasing
feedback polynomial for
zero aliasing lfsr
the lcm method
find an irreducible
q 2 08
d i j
worst case complexity
for finding a
the g i
complexity of finding
the expected number
number of primitive
the expected degree
all the polynomials
expected number of
degree of a
degree at most
2 n 2
on the least
of a primitive
over gf 2
on the degree
a for the
the same degree
worst case bounds
the compacting function
h is bounded
j is less
the effective polynomial
of degree 11
polynomial for a
is o jhju
all practical test
the smallest degree
the distinct irreducible
and primitive zero
expected work required
our expected bounds
of degree m
n 2 u
distinct factors is
degree l where
primitive feedback polynomial
degree for a
o u 2
are factors of
the non factor
log log 2te
with a primitive
was a non
the primitive polynomials
expected complexity is
t log n
all irreducible polynomials
distinct factors of
factors of g
a primitive feedback
the gcd method
primitive factors of
g i t
bounds on the
upper bounds on
is bounded by
of all distinct
2 the expected
of the good
phase is o
bounded by o
of degree d
p d h
expected degree of
the least integer
least integer such
work required for
the polynomials in
number of polynomials
relatively prime to
all the primitive
is greater than
the number of
of g i
of degree l
the factors of
a log log
the dominant term
the set h
d i t
m n for
1 the complexity

corpus/krapavin2000-test/627097.txt
unfolded
ff
gammafi
separation
events
unfoldings
timing
dasdan
asynchronous
maximization
automation
event
rajesh
occurrence
startup
synthesis
microprocessor
delta
root
synchronize
anmol
cutsets
ali
omega
occurrences
segment
circuits
delay
pipelines
gupta
pipeline
mathur
edges
todaes
cycle
composition
cutset
marculescu
mmu
caltech
kondratyev
concurrent
acyclic
repetitive
graphs
vk
synchronizations
repeat
decomposition
myers
repetition
annotated
closure
36th
matrix
circuit
vertices
bounds
symbolic
tightest
max
infinite
mip
separations
louisiana
segments
offset
rt
orleans
period
topologically
relate
cycles
award
labelled
tight
scalar
inexact
unspecified
fi
1997
synchronizing
removal
cyclic
ig
optimum
ae
interior
timed
wn
strongest
relating
coupled
edge
ratio
sparc
functional
synchronous
yielding
alex
gamma
haynal
b522
unfoldedprocess
sangyun
xiaoping
mcgee
pyi
0ig
tod
croprocessor
annihilator
root411
dill
borriello
perfromance
csto
jiwen
nowick
abstractdetermining
froot
8858782
sunan
ratan
cortadella
4041
kishinevsky
repetitively
beerel
0110100
davare
lwin
9257987
wig
brewer
zamora
sandy
amon
tugsinavisut
fhl
taokuan
ranges
algebra
electronic
steven
hu
united
delays
formalization
jejurikar
coffman
gaetano
unfortu
transistors
nonexpansive
composi
abhijit
gunawardena
vincentelli
peggy
yokohama
mcmillan
ravindra
rooting
sangiovanni
irani
41st
579
nandi
forrest
hulgaard
madisetti
verification
ring
infinitely
concern
singleton
decompose
incident
steady
interface
denmark
408
presburger
havior
clocked
repeatable
nately
kelvin
matroids
multiplica
34th
1000
exploration
shifted
structural
co
inefficiencies
gammaff
b0
process graph
m values
unfolded process
ff gammafi
s ff
delta ff
the m
t ff
m root
function maximization
the unfolded
v k
design automation
on design
occurrence index
time separation
maximum ratio
maximum separation
separation in
the process
k gupta
ali dasdan
rajesh k
function composition
root to
event occurrences
bounds on
events in
s segment
ff values
asynchronous circuits
timing verification
delay ranges
asynchronous microprocessor
startup rules
d values
the separation
automation p
ff we
7 gamma
relate m
graph for
the occurrence
5 20
separation between
cycle c
index offset
anmol mathur
structural decomposition
compute delta
f synchronize
unfoldings of
occurrence period
ratio cycles
finite acyclic
k gamma
to m
two events
a ff
synthesis and
r 0
repeat f
rate analysis
4 10
u k
graph in
ff for
m t
of event
graph algorithm
0 fi
the vertices
concurrent systems
of events
the delay
all ff
co design
embedded systems
a process
the events
ae oe
20 5
the functions
todaes v
electronic systems
systems todaes
the maximum
the graph
10 10
of asynchronous
graph into
max 0
of timing
graph that
infinite unfolded
initial startup
conditional behavior
june 21
synchronizing at
consecutive a
pipeline choosing
possible bounds
graph he
without conditional
wn ig
maximization and
compute repeat
synchronizations and
finite unfolded
synchronous component
the pipelines
gammafi omega
in occurrence
represents two
symbolic timing
analysis synthesis
initial occurrences
36th acm
repetitive system
he r
the caltech
unfoldings relative
23 edges
synchronize a
values repeat
relating m
gammafi and
of unfoldings
gammafi the
unspecified delay
two startup
the microprocessor
ratio cycle
caltech asynchronous
graph relative
synchronize b
alex kondratyev
relates m
represent events
offset 2
processes synchronizing
delay information
topologically left
1999 new
infinitely unfolded
all unspecified
the cutsets
optimum cycle
coupled pipelines
is yielding
tightest possible
award mip
event v
mathur ali
function relating
ff omega
microprocessor 6
hardware software
annotated with
the edges
graphs that
automation of
labelled with
d c
the infinite
graphs and
the delta
in figure
the removal
optimization of
occurrences at
edges using
matrix product
into segments
that synchronize
with functions
separation problem
ff max
dasdan rajesh
th occurrence
25 1999
in concurrent
unfolded graphs
sparc 2
compute s
circuit this
management unit
software co
enables it
ff such
arbitrary process
finite graph
semi ring
gupta rate
all event
of electronic
annual conference
fundamental problem
for embedded
time of
the process graph
the m values
unfolded process graph
s ff gammafi
the unfolded process
m root to
process graph for
on design automation
the maximum separation
separation in time
on the separation
the occurrence index
u k gamma
m t ff
process graph in
root to m
conference on design
rajesh k gupta
a process graph
3 3 3
process graph that
from s ff
m values of
the time separation
m values are
graph in figure
design automation p
the separation in
to m t
bounds on the
example in figure
of the process
for the process
the events in
in time of
of the events
delta ff values
structural decomposition of
separation of events
repeat f synchronize
10 4 10
time separation of
t ff we
5 20 5
20 5 20
to s ff
max 0 fi
4 10 4
the delta ff
delta ff for
occurrence index offset
m b 0
unfoldings of the
the d values
maximum ratio cycles
for all ff
6 1 6
of the unfolded
graph for the
ff we can
compute the maximum
for embedded systems
s and t
behavior of the
and optimization of
in figure 1
the example in
systems todaes v
transactions on design
electronic systems todaes
automation of electronic
design automation of
of electronic systems
of the m
d c c
fundamental problem in
proceedings of the
the edges are
of events in
a fundamental problem
an s segment
delay ranges are
the 36th acm
a structural decomposition
relates m root
process graph corresponding
maximization and composition
a repetitive system
and t ff
represents two coupled
adding an s
all event occurrences
synchronize b compute
th occurrence of
infinitely unfolded process
process graph is
occurrences at zero
time separation between
edge u k
the analysis synthesis
on a structural
all unspecified delay
occurrence period of
relating m root
function relating m
d values and
events is a
k th occurrence
function maximization and
arbitrary process graph
removal of six
graph he r
the tightest possible
by d values
10 10 10
optimization of asynchronous
the circuit this
an unfolded process
maximum ratio cycle
36th acm ieee
the matrix product
gammafi and t
right by omega
process graph without
the initial occurrences
m values repeat
finite graph algorithm
that represents two
m v k
7 gamma a
index offset 2
choosing the delay
he r i
gupta rate analysis
events in concurrent
processes synchronizing at
anmol mathur ali
in concurrent systems
ff gammafi and
unfoldings relative to
each edge the
two coupled pipelines
symbolic timing verification
the caltech asynchronous
june 21 25
m values at
events in y
the occurrence period
k gamma in
process graph the
cpu seconds on
v k we
caltech asynchronous microprocessor
tightest possible bounds
asynchronous microprocessor 6
ff gammafi the
s as being
maps the m
pipeline choosing the
occurrence of event
analysis synthesis and
m values obtained
since the m
rate analysis for
unspecified delay ranges
the finite graph
the initial startup
m values for
dasdan rajesh k
graph relative to
maximum separation in
part of 1
events in x
synchronize a compute
ratio cycle c
optimization of concurrent
process graph relative
process graph into
acyclic graphs and
mathur ali dasdan
initial occurrences at
relative to s
1999 new orleans
of event v
finite acyclic graph
number of unfoldings
separation between a
25 1999 new
21 25 1999
delay between consecutive
that relates m
single function relating
to compute delta
compute repeat f
a sparc 2
to compute s
ff gammafi omega
topologically left of
relate m root
f synchronize a

corpus/krapavin2000-test/627126.txt
edt
sn
broadcasting
star
subtree
fault
spanning
multinode
spg
tolerant
necklace
spt
transmissions
scattering
node
subtrees
parent
messages
disjoint
message
tolerance
children
mx
rooted
hypercube
rotation
edge
port
edth
interconnection
wishes
symbol
trees
mxn
necklaces
misplaced
exchange
rotations
receives
adjacent
translation
shortest
network
i4
cyclically
gamma1
4123
neighbor
broadcast
unfolded
nodes
edges
dimension
packets
pancake
pipelined
symbols
ng
dimensions
paths
transmitted
abderezak
touzene
cn
communication
gamma2
transmit
cycle
degree
belongs
destined
consequence
hypercubes
source
ports
incident
cube
gamma
13254
specificly
2143
minimumnumber
f2
transmits
forwards
controlling
faulty
1i
transmission
lemma
lengths
neighbors
connected
fujita
satoshi
diameter
simultaneously
processors
depth
routing
breadth
excluding
performances
asymptotically
ll
operate
shuffle
send
grouped
networks
root
subsection
f1
butterfly
permutation
topology
tree
conflicts
sends
net
fourier
cycles
election
221
acknowledgement
communicated
multicomputers
occupies
pipelining
dim
graphs
computers
bidirectional
k1
spans
enclosed
destination
3142
4through
3124
1396
1423
2413
12435
15432
abstractdata
rectangulars
lih
1366
rescigno
allport
substar
whishes
1370
calligraphic
1287
1202
laceability
341526
carlson
1243
jianer
1277
reliability
avoidance
soon
li
child
position
originating
bounds
analytically
3421
biing
1384
1126
schematical
fkg
monien
1123
1362
burkhard
sublogarithmic
1357
factorials
chyun
sth
transposing
distance
ae
utilized
kuan
12345
1196
hsing
tsai
hamiltonians
666
1324
bradley
of sn
edge disjoint
edt i
node broadcasting
single node
disjoint spanning
i n
t edt
spanning trees
the star
fault tolerant
multiple edge
subtree t
m messages
node scattering
star network
multinode broadcasting
broadcasting algorithm
node i
message transmissions
tolerant single
source node
node receives
transmissions required
sn is
fault tolerance
all port
edt in
total exchange
each node
node h
receives each
to subtree
rooted at
through neighbor
node wishes
spg i
tolerant algorithms
on sn
in subtree
adjacent to
the fault
of message
nodes of
n gamma
tolerant multinode
the edt
communication algorithms
a necklace
subtrees t
n gamma1
nodes adjacent
of fault
trees structure
spg in
port assumption
spt in
d mx
the source
wishes to
the multiple
and children
message through
translation with
the all
gamma 1
disjoint subtrees
broadcasting d
cycle notation
pipelined down
parallel paths
communication assumption
t edth
parent edt
n l
star graph
a node
the hypercube
other node
is connected
symbol 1
children nodes
to h
interconnection network
connected to
port communication
required is
hypercube network
o mxn
t spg
edt h
its parent
optimal single
shortest path
spanning tree
messages to
degree of
optimal since
the subtrees
i l
with symbol
path tree
example node
m fault
different edge
scattering and
star graphs
n through
optimal communication
complete is
h of
tolerance is
t h
to broadcast
the network
the nodes
misplaced symbol
necklace of
tolerant total
tolerant communication
spt i
sn o
broadcast m
h rooted
children edt
broadcasting single
time required
other nodes
trees on
r k
a consequence
problems under
of dimension
of rotation
all nodes
dimension k
lower bounds
required for
same message
the m
m n
star interconnection
scattering algorithm
time step
for message
d m
the single
the degree
from i
in i
gamma2 i
k gamma2
distinct messages
2 k
l i
parent and
rotations of
and fault
is m
to i
the rotation
transmissions single
cn o
consequence each
necklace that
through paths
is pipelined
mx 2
through subtrees
disjoint subtree
rotation operation
symbol cyclically
parent spg
separately 1
first misplaced
of transmissions
exchange problems
gamma1 fault
children spt
prove each
cyclically to
in rooted
broadcasting multinode
different dimensions
in star
node and
the cycle
of translation
to nodes
the parent
each message
message transmission
at node
each one
data communication
edge of
with degree
destined to
respectively through
part separately
single node broadcasting
disjoint spanning trees
edge disjoint spanning
t edt i
multiple edge disjoint
edt i n
single node scattering
subtree t edt
the star network
of message transmissions
nodes of sn
on the star
tolerant single node
fault tolerant single
the multiple edge
message transmissions required
number of message
the source node
each node receives
degree of fault
node broadcasting algorithm
the all port
under the all
node receives each
i n l
the fault tolerant
of fault tolerance
the m messages
of sn is
to subtree t
node wishes to
l i n
n gamma 1
the single node
fault tolerant algorithms
nodes adjacent to
the nodes adjacent
i l i
translation with respect
fault tolerant multinode
node h of
tolerant multinode broadcasting
transmissions required is
in subtree t
to i n
node i n
m n gamma
edt i l
receives each of
h of sn
adjacent to i
all port assumption
spanning trees structure
rooted at the
the star graph
respect to h
is connected to
communication and fault
edge disjoint subtrees
connected to subtree
b 3 n
optimal single node
subtrees t edt
algorithm to complete
time required for
spanning trees on
3 n gamma1
as a consequence
to complete is
all port communication
node scattering and
operation of translation
m fault tolerant
t spg i
port communication assumption
spg i n
cycle notation of
and total exchange
of dimension k
other node h
tolerant algorithms for
i n through
edge of dimension
the cycle notation
scattering and total
for example node
of translation with
rotations of each
i is connected
all nodes of
of the subtrees
at the nodes
fault tolerance is
required for this
is m n
nodes of s
shortest path tree
for message transmission
each of the
rooted at node
parent and children
wishes to broadcast
multinode broadcasting single
spt i i
subtree t edth
parent edt i
broadcast m messages
required is which
node scattering algorithm
node i 2
r k gamma2
transmissions required for
k gamma2 i
to broadcast m
node broadcasting d
of multiple edge
gamma2 i 2
wishes to send
of m messages
through a different
h rooted at
children nodes in
a different edge
edt i 4
fault tolerant communication
fault tolerant total
node receives a
the edge disjoint
the edt in
to a necklace
tolerant total exchange
broadcasting single node
each node wishes
the degree of
that each node
2 i n
node i is
at each time
for the single
each time step
messages to each
the same message
of the star
of a node
from the source
symbol 1 in
to each one
controlling the degree
the problem where
at any other
2 k n
wishes to transmit
i 2 k
the other nodes
of the multiple
any other node
of the network
is the problem
for this algorithm
to the source
each one of
connected to its
of different dimensions
edt h rooted
node and as
respectively through subtrees
different edge disjoint
root of multiple
k n respectively
the hypercube network
part separately 1
a consequence each
a necklace that
n of sn
first misplaced symbol
on an interconnection
spg i l
all of different
n respectively through
the rotation operation
each source node
number of transmissions
cyclically to the
tolerant communication algorithms
through subtrees t
in rooted at
the star interconnection
and to subtree
n l l
m messages are
using the operation
each message through
broadcasting multinode broadcasting
edge in dimension
nodes r k
message through paths
prove each part
right of symbol
is pipelined down
node of sn

corpus/krapavin2000-test/627189.txt
primitive
garbage
symbolic
milliseconds
calculated
reversal
conditionals
cache
2001000
500500
me
ecient
optimizations
recursions
4004000
1002000
40400
nontermination
inputs
eciently
sort
heap
eects
cbleast
2003001
10200
transformations
91
accurate
bounds
1000
unknown
chez
alpa
20100
501501
insertion
2000
underestimation
ca
programs
measured
loops
yanhong
500
accurately
93
symbolically
worst
allocated
merge
200
automatic
append
rosendahl
251000
16008000
160800
cleast
car
else
transformation
program
partially
summations
analyses
constructor
cons
paths
300
lifting
constructors
disabled
timing
enabled
loop
compiler
inx
synthesizer
language
sums
conditional
inlining
languages
1001
branches
arguments
dierent
measurements
pipelining
bindings
92
incremental
97
terminate
counts
recursive
251001
xxxxxx
90600
4004001
2003000
ibonacci
8006001
501500
vcbleast
incrementalization
19953
125250
1002001
1999000
varref
499500
4000000
167mhz
40401
rst
depths
simplifying
440
analyzing
instruction
functional
inability
calls
bytes
liu
46
transformed
89
2600
stony
sunysb
20301
brook
recurses
conservatively
live
dicult
source
merging
50
subcomputation
ssl
lub
631
stoller
1000000
86
binding
union
37
lisp
measuring
85
optimizing
64mb
670
inecient
16000
structs
ultra
annotations
collection
terminates
96
cdr
app
40000
nonrecursive
95
meant
inaccurate
632
87
branch
conservative
41
optimized
sorting
94
evaluator
400
220
microseconds
1600
syntax
automatically
tried
calculate
caching
accuracy
88
constructs
accommodate
schema
53
n00014
nil
8000
cost bound
primitive cost
bound function
cost parameters
symbolic evaluation
bound functions
cost bounds
input size
bound analysis
known input
calculated time
partially known
garbage collection
me ca
the cost
calculated measured
time milliseconds
measured me
milliseconds input
size parameters
input structures
with cache
heap space
insertion sort
accurate cost
ca calculated
measured worst
original program
loop bounds
the calculated
execution paths
worst case
collection times
cache enabled
list reversal
selection sort
cost function
if else
the symbolic
language based
direct evaluation
set union
in if
reversal w
collection time
sort calculated
space bounds
direct symbolic
time bound
of primitive
merge sort
partial evaluation
cost parameter
allocated for
the source
inputs of
of cost
case times
union list
measuring primitive
sort selection
merging paths
for constructors
symbolic direct
cache disabled
eciently and
evaluation takes
source program
cost analysis
the analysis
variable reference
for time
automatic and
or execution
incremental computation
and accurately
and optimizations
analysis for
time analysis
closed forms
automatically and
and transformation
function calls
on inputs
and measured
else if
v then
resulting function
ca 50
size calculated
constructing cost
simplifying conditionals
46 37
lifting conditions
chez scheme
approximate time
reversal reversal
w append
include garbage
if v
constructors in
cost functions
yanhong a
a liu
measured time
primitive operation
sort merge
as arguments
actual running
or approximately
each constructor
and accurate
the heap
example programs
bounds or
for inputs
more ecient
or space
given values
and techniques
parameters and
evaluation and
programs on
our method
not terminate
input structure
of sizes
program analysis
then e
function terminates
dierent operations
small inputs
sort set
synthesizer generator
system alpa
size insertion
36 28
paths automatically
97 4
value unknown
recursion depths
bytes allocated
accurate conservative
1001 500500
optimized symbolic
50 26
input sizes
else e
conservatively or
2001 2001000
bounds automatically
cache eects
recursions or
the synthesizer
measured conservatively
level languages
source level
language level
language implementation
these transformations
more accurate
of experiments
complexity analysis
for analyzing
and transformations
source programs
each primitive
transformations are
source language
13 19
and primitive
a cost
analyses and
case execution
on input
and space
of size
recursive function
conditionals and
and scheme
on unknown
resulting cost
symbol c
algorithm analysis
conservative or
ecient and
car x
space allocated
when inputs
28 14
sizes 10
this transformation
e 1
analysis with
analysis results
optimizations to
calculated and
of input
the measured
inputs are
cost bound function
primitive cost parameters
the cost bound
cost bound functions
partially known input
input size parameters
milliseconds input size
calculated measured me
measured me ca
time milliseconds input
known input structures
the symbolic evaluation
of primitive cost
calculated time milliseconds
cost bound analysis
me ca calculated
in if else
ca calculated measured
if v then
if else if
measured worst case
the original program
else if v
with cache enabled
garbage collection times
primitive cost parameter
time bound analysis
accurate cost bound
of cost bound
or execution paths
and measured worst
sort calculated time
garbage collection time
the source program
on inputs of
of input size
worst case times
methods and techniques
symbolic evaluation of
the cost function
analysis and transformation
direct symbolic direct
insertion sort selection
v then e
symbolic direct symbolic
language based approach
sort merge sort
analysis with cache
inputs of sizes
measuring primitive cost
with cache disabled
for time bound
set union list
size parameters and
bound analysis with
selection sort merge
sort selection sort
allocated for constructors
for constructors in
union list reversal
of the cost
on the heap
the calculated time
reversal w append
inputs of size
bound functions in
calculated and measured
source language level
the language implementation
bounds or execution
values of input
list reversal reversal
a cost bound
cost parameters for
and primitive cost
size calculated measured
include garbage collection
reversal reversal w
loop bounds or
bound function for
me ca 50
at the source
constructors in the
yanhong a liu
the heap space
input of size
time or space
a language based
on the language
high level languages
the source language
dierent operations performed
cost parameters and
2 end in
the primitive cost
execution paths automatically
conservative or approximate
the cost bounds
allocated for each
the synthesizer generator
3 13 19
prototype system alpa
10 to 2000
space allocated for
of dierent operations
optimized symbolic evaluation
subset of scheme
the resulting function
in algorithm analysis
accurate cost bounds
1 else e
for time analysis
approximate time or
fully automatic and
13 19 21
e 2 end
automatic and accurate
heap space allocated
on small inputs
paths automatically and
sort set union
inputs are very
cache disabled the
merge sort set
conservatively or approximately
up the symbolic
consists of transformations
given values of
measured conservatively or
e 1 else
machine with cache
or approximate time
programs on inputs
accurate conservative or
for a machine
known input structure
might not terminate
then e 1
symbolic evaluation takes
values of primitive
of bytes allocated
cost parameters as
or space bounds
more accurate cost
sizes 10 to
automatically and accurately
and space bounds
and accurate cost
bytes allocated for
of sizes 10
be measured conservatively
else e 2
evaluation and optimizations
symbolic evaluation and
size insertion sort
eciently and accurately
worst case execution
the cost of
in the cost
the resulting cost
the source programs
terms of primitive
when inputs are
of experiments for
language implementation or
the measured time
analyses and transformations
bound analysis for
for inputs of
evaluation of cost
for each constructor
time and space
bounds on the
takes as arguments
in the programs
be obtained based
for high level
evaluation of the
the worst case
on input of
program analysis and
a future work
speed up the
obtained based on
number of experiments
a machine with
are very small
number of bytes
cost of the
of the analysis
a sun ultra
running time and
in terms of
have been studied
based approach for
a cost function
the numbers in
we use function
as 67 higher
to 2000 these

corpus/krapavin2000-test/627209.txt
dear
lru
oo
seq
cscope
sublists
sublist
replacement
oeo
freebsd
cpp
detection
block
referenced
buffer
scm
postgres2
glimpse
os
backward
blocks
cache
oof
reference
loop
gnuplot
period
looping
prob
deardear
gli
postgres1
disk
caching
oos
hei
file
temporally
fd
response
lfu
lrulru
undetect
5mb
policy
pattern
forward
attribute
link
6mb
policies
acfc
oeoe
distance
frequency
bd
mru
hints
73
sort
500
mo
percent
files
clustered
sequential
virtual
optopt
qpqp
twohundredthoustup
snu
upup
acfcacfc
hmbi
hmbiso
qppqpp
74
wc
controlled
probabilistic
detects
postgres
cs
kr
executions
schemes
4500
victim
hs
prefetching
periods
139
3500
seoul
112
avg
qrppp
ssrnet
fivehundredup
vfs
qpppp
qtppp
bwrite
getnewbuf
ioo
hundredthoustup
twothoustup
unix
91
patterns
2500
utility
216
66
qv
ps1
ps2
87
management
70
scheme
accessed
1500
monitoring
116
text
cf
traces
8kb
bread
allocation
4000
3000
kernel
preprocessor
comparably
gnu
61
ac
77
invoked
deduced
72
79
bp
1mb
1000
distances
logical
5000
adaptive
references
71
lists
68
cp
222
media
manager
korea
fr
51
seconds
database
early
plotting
driven
41
gap
88
attributes
detect
compiler
detected
request
measurements
89
interactive
header
informed
81
incurs
132
qvpqvp
multithread
hongik
loop50015002500
postgressql
dandelion
choijm
vfs_strategy
wpwp
qppppqpppp
acms
qrpppqrppp
qtpqtp
qtpppqtppp
vnode
loop1003005000
166mhz
dear scheme
the dear
reference pattern
detection period
backward distance
o oo
the lru
buffer cache
the detection
loop loop
forward distance
block attribute
of sublists
in freebsd
i os
response time
block reference
application controlled
controlled file
by up
fd sublist
file caching
the block
reference patterns
disk i
replacement policy
oeo oof
prob prob
a oeo
detection results
oof o
of disk
dear dear
probabilistic reference
logical block
seq loop
multiple application
oo r
virtual time
replacement policies
sequential reference
average forward
temporally clustered
number virtual
lru dear
blocks referenced
the buffer
block replacement
oeo oo
distinct blocks
lru lru
lru scheme
different replacement
lru seq
the scm
seq 3
detection result
dear lru
and frequency
an average
average of
the response
single application
block number
looping reference
mo oo
caching 8
sublist bd
attribute types
oo hei
appropriate replacement
b cf
seq seq
to oo
oos b
3 loop
scheme in
the blocks
blocks are
level hints
a looping
application case
application executions
distance and
buffer space
period is
of blocks
pattern the
ordered lists
overall response
scheme with
referenced between
freebsd 2
the lfu
result seq
proposed dear
oo oeo
backward backward
lrulru deardear
forward distances
applications show
cs sort
sublist sublist
detection periods
freebsd the
detected reference
link application
block with
loop 8
oo a
referenced in
time seconds
cache sizes
multiple applications
early detection
file system
pattern a
blocks in
ac kr
and postgres2
frequency block
adaptive replacement
forward average
scheme reduces
hs f
avg fd
cscope sort
text files
oo hs
sublists in
distance distance
smaller forward
sort link
percent with
8 seq
the cscope
r o
the forward
attribute values
of 12
different applications
loop 5
os by
to 51
os is
monitoring process
new buffer
pattern is
each block
cache size
based adaptive
block into
reference behavior
lru and
application performance
period on
application with
a detection
scheme performs
lru replacement
buffer allocation
user level
pattern has
the detected
for block
detection based
at m
disk blocks
a block
an application
block attributes
were referenced
snu ac
5000 logical
66 61
seq scheme
called dear
with early
distance therefore
lfu replacement
cf hmbiso
so oos
scheme detection
5 seq
2 undetect
loop 6
sublist fr
if fd
sublists of
5 loop
various buffer
hmbi mo
loop 16
1 loop
dear detection
looping temporally
gli link
detection rule
victim block
acm is
the dear scheme
of the dear
disk i os
the detection period
loop loop loop
of disk i
by up to
number of sublists
controlled file caching
application controlled file
the buffer cache
number of disk
scheme in freebsd
with an average
oeo oof o
a oeo oof
backward distance and
oof o oo
an average of
dear scheme with
probabilistic reference pattern
the response time
number virtual time
dear scheme in
reference pattern the
lru lru dear
block number virtual
distance and frequency
logical block number
lru dear dear
average of 12
dear lru lru
dear dear lru
block attribute values
detection period is
the lru seq
seq 3 loop
the forward distance
the lru scheme
prob prob prob
sequential reference pattern
seq loop loop
reference pattern is
of the detection
mo oo r
forward distance of
file caching 8
time by up
r o oo
a probabilistic reference
oos b cf
r to oo
of distinct blocks
response time seconds
different replacement policies
block attribute types
o oo hei
oo r o
the detection results
looping reference pattern
the reference pattern
referenced in the
reference pattern of
a looping reference
overall response time
fd sublist bd
freebsd 2 2
user level hints
that the dear
the multiple application
the blocks referenced
o oo a
detection result seq
oo a oeo
seq seq loop
a reference pattern
oo oeo oo
the link application
oeo oo oeo
the proposed dear
block reference patterns
an appropriate replacement
for the dear
in the buffer
response time by
and the response
blocks in the
the overall response
in the response
attribute values and
and the lru
backward backward backward
of single application
detection period on
result seq seq
the backward distance
in freebsd 2
of sublists in
between the lru
that of application
appropriate replacement policy
detected reference pattern
multiple application case
for the lru
blocks referenced between
oo hs f
os by up
at m i
the block reference
for the cscope
blocks referenced in
up to 35
of application controlled
single application executions
average of 8
detection results of
percent with an
the detected reference
avg fd sublist
up to 51
reference pattern has
place the block
sublists in the
replacement policies to
in freebsd the
frequency block attribute
forward average forward
smaller forward distance
scheme with that
the block attribute
the ordered lists
dear scheme for
period on the
hs f i
scheme reduces the
block reference pattern
application executions the
is by up
proposed dear scheme
and frequency block
dear scheme performs
average of 23
loop 8 seq
therefore a reference
to oo hs
reduction in the
of blocks in
2 2 5
the number of
of the blocks
the block into
to different applications
q r t
i os by
in the ordered
i os is
detection based adaptive
r t x
a sequential reference
i os and
and the forward
case of single
in the number
number of distinct
the reduction in
response time is
to place the
oo hei lrulru
called dear detection
loop detection result
pattern has the
temporally clustered or
policies to different
o oo r
current detection period
hmbiso oos b
lrulru deardear acfcacfc
hei lrulru deardear
5 loop 16
period is too
m i gamma1
on the detected
block attributes of
of 23 and
clustered reference pattern
forward distance therefore
distance therefore a
patterns of applications
a detection period
block with a
buffer cache sizes
the average forward
4500 5000 logical
hmbi mo oo
detection period of
update the block
the lfu replacement
so oos b
scheme called dear
proposed scheme reduces

corpus/krapavin2000-test/627222.txt
subtask
rba
oba
dasa
deadline
mndw
subtasks
ramp
rba_analyzeresponse
replicas
ke
overload
benefit
arrival
replica
deadlines
aggregate
workload
missed
heap
scheduling
processor
allocation
timeliness
lbesa
oba_overloadcheck
response
anticipated
adaptation
_determinereplicasprocessors
resource
ravindran
workloads
proactive
rhd
accrued
tasks
period
invoking
hegazy
processors
task
amortized
_algorithm
red
ke2
oba_
eqf
ke3
kelog
asynchronous
aperiodic
message
window
slack
underloaded
invokes
fig
arrivals
scheduler
triggering
edf
oba_algorithm
eex
oba_determinereplicasprocessors
k2
resources
deallocate
pseudocode
vol
ratio
predecessor
schedulers
periodic
const
stk
p2m4n4dw
rba_analyze
ke4
replicasprocessors
m3n3dw
binoy
p2m2n2dw
arrivaltime
mdndw
oba_determine
dl
messages
nd
load
allocations
computationally
mines
qos
arrive
analyzes
deallocates
delays
baseline
queue
log
benefits
sti
overloads
maximize
deter
determines
allocates
analyzeresponse
p2m3n3dw
overloadcheck
responsetime
determinereplicasprocessors
m2n2dw
mk
decisions
subsections
constructs
feasibility
event
n3
effort
51
xm
allocate
p2
constructing
assignment
peng
allocated
detected
miss
switch
4p
rj
overloaded
arrives
kth
incurs
worst
ready
executing
considers
triggered
benchmark
repeats
earliest
rationale
computers
invoked
packet
events
determining
a5
uncertainties
naval
cj
parent
decreasing
a4
heuristically
periods
instants
n2
extract
sender
extracted
ti
nents
counterpart
replication
packets
replicating
numerator
compo
ethernet
incrementing
replicated
examines
ordered
er
affect
subproblems
a3
jensen
xn
extracting
middleware
n00014
highest
situations
list
plots
executions
execution
experiment
percentage
processes
expensive
abstraction
the subtask
of rba
a subtask
mndw ke
deadline ratio
resource allocation
missed deadline
benefit tasks
aggregate benefit
subtask response
rba and
and oba
arrival list
subtask deadline
subtask arrival
higher benefit
rba under
asynchronous real
of replicas
adaptation functions
response time
the arrival
the task
each subtask
amortized complexity
benefit and
real time
the rba
log mndw
aggregate task
overload test
subtask or
ramp ramp
subtasks and
application benefit
replicas and
all subtasks
subtask on
the overload
arrival time
subtask and
the procedure
a task
the processor
response times
rba _determinereplicasprocessors
for proactive
dasa nd
under dasa
of subtask
underlying scheduling
proactive resource
of subtasks
ramp workloads
timeliness of
cost of
in asynchronous
benefit for
time distributed
the aggregate
scheduling algorithm
the response
using application
subtask replicas
the anticipated
increasing ramp
subtask execution
procedure rba_analyzeresponse
task benefit
subtask of
dasa and
scheduling algorithms
the heap
arrival times
complexity of
subtasks of
time window
the cost
hegazy and
that rba
of oba
their processors
of rba_analyzeresponse
oba s
accrued benefit
no 8
computers vol
vol 51
ravindran using
higher aggregate
51 no
aggregate accrued
an overload
workload of
future time
its deadline
processor assignment
8 august
and ravindran
the timeliness
the replicas
a processor
time of
allocation in
each task
n tasks
rba _algorithm
lbesa and
subtask s
their processor
lower benefit
task deadline
and rhd
rba_analyzeresponse procedure
task period
task benefits
the amortized
processor q
their deadlines
the workload
the scheduling
replicas for
the adaptation
and messages
the deadline
periodic task
const ramp
rba performs
subtask is
o mndw
overload on
scheduling events
procedure rba
no overload
the subtasks
anticipated workload
kelog mndw
second replica
thus rba
lower missed
task missed
by rba
how rba
than rba
anticipated workloads
single replica
benefit task
load error
triggering periodic
best effort
time analysis
execution times
overload is
pseudocode of
august 2002
times of
the scheduler
and minimize
constructing the
effort real
replica for
the algorithm
resources for
performance of
the pseudocode
of invoking
log n
relative load
the replica
determines the
times and
processor is
and message
than oba
rba dasa
b missed
rba_analyzeresponse is
adaptation period
the rba_analyzeresponse
the missed
current processor
subsections that
task adaptation
maximize aggregate
rba algorithm
available slack
invoking dasa
the subsections
baseline ramp
higher will
subtask deadlines
parent task
under error
to rba
subtask arrivals
n subtask
rba s
produces higher
ke log
minimize aggregate
missed deadline ratio
performance of rba
of a subtask
rba and oba
number of replicas
of the subtask
the subtask deadline
asynchronous real time
of rba under
in asynchronous real
higher benefit tasks
the subtask response
log mndw ke
resource allocation in
arrival time of
on the processor
the arrival time
the cost of
real time distributed
proactive resource allocation
for each subtask
subtask response time
allocation in asynchronous
for a subtask
time distributed systems
the underlying scheduling
amortized complexity of
response time of
time of a
of rba and
application benefit for
satisfy the subtask
aggregate benefit and
of higher benefit
the amortized complexity
the overload test
benefit for proactive
using application benefit
the response time
and ravindran using
ravindran using application
number of subtask
on computers vol
no 8 august
51 no 8
hegazy and ravindran
higher aggregate benefit
timeliness of higher
during the future
subtasks and messages
vol 51 no
the aggregate task
computers vol 51
aggregate accrued benefit
for the subtask
underlying scheduling algorithm
for proactive resource
subtask response times
of subtask replicas
response time analysis
8 august 2002
the timeliness of
of a task
or the message
the arrival list
and their processor
benefit and minimize
of replicas for
subtask replicas and
aggregate task benefit
the task deadline
their processor assignment
and their processors
the future time
overload is detected
complexity of rba_analyzeresponse
future time window
on a processor
the pseudocode of
response times of
of the task
cost of the
as the underlying
under dasa and
rba under dasa
const ramp workloads
benefit and lower
the aggregate benefit
cost of invoking
replicas and their
task missed deadline
aggregate task missed
kelog mndw ke
of the rba
that of rba
lower benefit tasks
and lower missed
at the switch
lower missed deadline
complexity of rba
a subtask or
increasing ramp ramp
each subtask of
no overload is
determines the number
workload of the
sum of the
the workload of
decreasing order of
best effort real
effort real time
the complexity of
the algorithm considers
log n k
the arrival times
total available slack
the higher will
the subtask on
the adaptation functions
of oba s
the subsections that
accrued benefit b
ramp ramp workloads
the subtask arrival
the missed deadline
of all subtasks
subtask execution times
a aggregate accrued
the procedure rba_analyzeresponse
ke log mndw
determine the subtask
subsections that follow
aggregate missed deadline
ramp workloads a
workloads a aggregate
order of task
higher will be
deadline ratio than
triggering periodic task
replica for the
to maximize aggregate
benefit b missed
relative load error
produces higher aggregate
time scheduling algorithms
the rba_analyzeresponse procedure
of the replicas
in the subsections
the rba algorithm
ke thus the
such as dasa
the procedure rba
a subtask and
observe that rba
the scheduling events
of replicas needed
baseline ramp ramp
b missed deadline
subtask on a
and minimize aggregate
subtask and their
in aggregate benefit
mndw kelog mndw
minimize aggregate missed
and the missed
subtask of each
replicas needed for
affect the timeliness
subtask or the
constructing the subtask
mndw ke log
of task benefits
as key values
dasa and red
shown in fig
transactions on computers
the scheduling algorithm
for a task
of the cost
in decreasing order
real time scheduling
that will satisfy
times of all
from the task
will satisfy the
deadline of a
a processor q
change in aggregate
is detected on
the total available
from the heap
possible number of
a maximum of
the worst case
cost of constructing
resources for a
resource allocation for
the performance of
the sum of
of the adaptation

corpus/krapavin2000-test/627258.txt
token
visit
visits
ttrt
timed
synchronous
sevcik
elapse
protocol
trt
transmission
arrival
johnson
rotation
deadlines
inclusive
mac
tighter
node
fddi
successive
ring
asynchronous
message
arrivals
downstream
han
messages
bandwidth
elapsed
chen
burns
early
late
rotations
overheads
arrives
timing
delta
lc
deadline
destination
unavailable
transmit
generalized
guaranteeing
cycle
tht
neighbor
timer
derivations
exclusive
judged
generalised
ending
transmitting
sba
allocated
pm
zhang
expires
th
fiber
allocation
findings
frames
departure
transmitted
unbroken
traffic
incurred
totally
exceed
stream
bandwidths
timely
imaginary
chance
delivery
till
forwarded
tight
theorems
dc
reset
spent
guaranteed
arrive
neighboring
network
calculated
media
generalizes
communications
externally
expression
relaxed
delay
failing
adaptable
report
medium
convenience
realizing
grow
nodes
subsequent
enabled
holding
constraint
internally
ps
sent
reinitialized
hsrb
enbedded
safenet
nonperiodic
misjudged
sijing
otain
hsdb
transmits
misses
notations
ffl
et
interval
concise
consumed
accounted
gamma
bus
receives
leftover
circulates
deltan
ulm
survivable
glossary
contending
inherent
buffer
worst
subscripts
grows
supposed
arrived
bounded
lemma
counter
departs
fibre
unallocated
c1
visited
instant
wrongly
integers
published
removal
possibly
responsiveness
minf
supposing
optic
quoted
conversions
negotiate
deferring
period
calculate
calculation
upstream
summations
negotiated
tightest
timers
expired
analyzed
schemes
lth
counts
group
immediately
units
simplify
happens
fall
271
duration
studies
802
jing
stewart
upper
voice
periodic
initialized
waiting
the token
timed token
node i
token s
the timed
token protocol
arrival at
token rotation
and sevcik
visit l
upper bound
c i
johnson and
by chen
synchronous bandwidth
successive token
c th
han et
th arrival
elapse time
th visit
chen et
bound expression
generalized upper
at node
remaining visits
n successive
early visit
by johnson
time properties
cycle time
protocol constraint
generalized result
token mac
visit c
synchronous messages
the elapse
theorem 5
trt i
successive visits
by han
visit x
visit to
rotation time
synchronous message
mac protocol
node k
downstream neighbor
token is
complete token
message deadlines
token arrivals
n visits
constraint 1
delta n
with theorem
asynchronous messages
l i
to node
token arrives
possibly elapsed
token rotations
sevcik s
and burns
by ttrt
derived by
real time
visits in
this report
message transmission
time possibly
unavailable for
l th
immediately subsequent
various overheads
on visit
i inclusive
ttrt and
inclusive to
et al
tighter upper
destination node
x y
any node
of successive
zhang and
one complete
the protocol
lc i
e node
token ring
the visit
timing properties
ending with
the generalized
a tighter
group 1
and visit
that visit
time communication
theorem 4
between visit
their generalized
guaranteeing synchronous
visits is
these visits
asynchronous transmission
pm q
token visits
y pm
judged with
visits i
generalised johnson
bound on
the cycle
tighter than
particular node
hard real
in theorem
transmission of
between any
arrivals to
synchronous transmission
that derived
its synchronous
elapsed during
visits from
e above
time communications
t l
of synchronous
al 17
s c
of node
arrivals at
new generalized
its c
source node
the time
s l
s downstream
no asynchronous
s arrivals
delta ttrt
findings on
derived upper
early visits
r remaining
any visit
the ttrt
sevcik and
tht i
when judged
late visit
than visit
visit p
subsequent arrival
overheads possibly
token makes
elapsed in
l exclusive
previous findings
whole message
of shown
h i
for message
the ring
for transmission
the destination
bandwidth allocation
bounded by
to visit
i and
ffl based
for guaranteeing
deadlines with
a late
q s
in group
for hard
q m
a c
time between
the synchronous
transmission between
makes its
delta b
sum total
bound derived
neighbor i
the upper
above definitions
bound given
the node
transmit its
previous results
i n
early on
calculated with
is unavailable
the timed token
timed token protocol
the token s
johnson and sevcik
of the timed
at node i
arrival at node
by chen et
generalized upper bound
han et al
th arrival at
chen et al
upper bound expression
by johnson and
cycle time properties
visit to node
the elapse time
th visit to
timed token mac
token mac protocol
token rotation time
protocol constraint 1
visit c i
by han et
visit l i
the protocol constraint
a c i
visit x y
node i and
on the cycle
s c th
token s c
on the elapse
when the token
c th visit
to node i
time properties of
the cycle time
complete token rotation
with the timed
of successive token
t l i
n successive visits
token s l
node i 1
the token is
number of successive
s l th
and sevcik s
unavailable for message
between the token
the generalized upper
derived by chen
zhang and burns
the token arrives
c th arrival
the time possibly
time possibly elapsed
any node i
for message transmission
upper bound on
i e node
l i inclusive
successive token arrivals
under the protocol
and the token
one complete token
destination node k
arrival at any
derived by han
sevcik s theorem
tighter upper bound
of node i
the destination node
a particular node
bound on the
of the token
real time communication
node i i
a tighter upper
with theorem 5
in theorem 5
at any node
means that visit
visits i e
synchronous message deadlines
its c th
y pm q
time t l
that visit x
since the token
x y pm
tighter than that
arrivals at a
l th arrival
elapse time between
pm q m
judged with theorem
i inclusive to
that derived by
e node i
token arrivals to
generalised johnson and
i i e
in this report
properties of the
hard real time
the upper bound
with theorem 4
arrivals to a
real time communications
c i the
q m 1
i the time
for hard real
above definitions a
the previous findings
derived upper bound
results by johnson
c i i
and by chen
generalized result on
arrival at the
timed token ring
b i l
al 1 6
s arrivals at
visits in group
elapse time during
token makes its
a late visit
of n successive
of various overheads
the synchronous bandwidth
deadlines with the
subsequent arrival at
i s downstream
various overheads possibly
the remaining visits
downstream neighbor i
message deadlines with
produce a tighter
the token makes
delta b i
which is unavailable
there are totally
r remaining visits
source node i
bounded by ttrt
findings on the
definition of shown
than visit c
message from s
synchronous bandwidth allocation
message transmission between
s downstream neighbor
token s arrivals
to the timed
immediately subsequent arrival
when judged with
receives the token
is unavailable for
is bounded by
shown in theorem
1 i n
the time when
et al 17
if the token
neighbor i e
node i s
previous results by
ending with the
transmission between the
that the token
i l c
h c i
upper bound derived
lc i is
sum total of
theorems 4 and
node i can
an upper bound
the previous results
the above definitions
to the definition
given in theorem
the sum total
timing properties of
for transmission of
better than any
upper bound given
the node corresponding
is more general
i and its
the time elapsed
bound given in
et al 1
node corresponding to
result on the
x y is

corpus/krapavin2000-test/627400.txt
ldl
prolog
query
manager
pcg
fixpoint
anc
deductive
marc
database
recursive
optimizer
predicate
relational
logic
pipelined
recursion
horn
compile
materialized
ull
declarative
salad
tuples
compilation
rewriting
lazy
compiler
fad
queries
p2
backtracking
cliques
databases
language
rule
magic
existential
sg
dredging
backtrackable
enhancer
rpcg
experience
datalog
tuple
safety
p1
semantics
rules
grandma
unification
navigational
constructs
join
pushing
dbmss
employee
education
compiled
predicates
languages
executions
b2
clique
sql
shtz
admin
rp2
llo
externals
saz2
divesh
rigel
modules
intelligent
negation
updates
arguments
execution
nats
leon
harvard
segev
coral
raghu
procedural
expressive
sigmod
naive
unnecessary
backtrack
exit
bases
adornment
reentrant
srivastava
unsafe
goals
sudarshan
usability
ease
college
schema
idempotence
zaniolo
greedily
arie
recast
programmer
record
counting
parents
migrated
translator
fm
responsible
efficiently
superfluous
ramakrishnan
materialization
1991
prototype
annotations
keot
saz3
stonebraker
krza
peephole
veko
bnst
nakr
cgk89b
seasons
recounts
seshadri
parent
pushed
generator
elimination
joe
optimizing
duplicates
relations
selection
functionality
stratification
chaining
1993
convoy
educe
sld
seminaive
carol
domenico
kms
mengchi
amateur
universality
harnessing
poulovassilis
bmsu
ambriola
alexandra
commutativity
prototyping
rapid
occurrence
descriptor
antonella
praveen
conducive
enumerative
1967
adorned
safe
school
ancestor
binding
grouping
strategies
zhao
management
annealing
migration
nested
intensive
1971
jiawei
vincenzo
evaluable
determinism
clauses
calculus
termination
interface
external
committed
founded
cyclic
the ldl
fact manager
query form
in ldl
the rule
of ldl
pipelined execution
the query
same generation
the optimizer
intelligent backtracking
compile time
deductive databases
run time
ldl compiler
data language
bound arguments
ldl has
lazy pipelined
materialized execution
for ldl
predicate occurrence
set terms
unique representation
counting method
get next
recursive clique
rule set
a logic
ldl system
anc x
lazy materialized
anc marc
logic data
in p2
at run
manager the
recursive cliques
recursive query
semi naive
the rules
execution is
at compile
logic based
the compiler
declarative semantics
execution strategy
of prolog
rule based
in prolog
logic programs
rule for
execution space
single fixpoint
data dredging
z anc
generalized counting
ldl and
complex terms
the pcg
fm get
form manager
prolog and
an execution
efficient execution
non recursive
relational databases
the predicate
knowledge and
the database
prolog in
language ldl
recursive queries
code generator
rule rewriting
of rules
and logic
expressive power
language for
language and
logic programming
complex objects
semantics of
and knowledge
database system
data engineering
rules and
fixpoint computation
the magic
magic set
recursive rules
relational algebra
of selection
of recursion
of recursive
the language
on knowledge
database systems
employee name
the compilation
the recursive
a recursive
updates in
query optimization
programmer must
horn clause
the experience
recursive rule
data bases
a database
j leon
enhancer is
ldl queries
leon zhao
ldl is
manager provides
be greedily
srivastava s
constant migration
ldl implementation
derived relations
superfluous work
as recursion
college harvard
segev j
for b2
connection graph
ldl s
non horn
rule transformation
marc and
next tuple
domain calculus
and idempotence
horn constructs
divesh srivastava
ramakrishnan divesh
predicate connection
sg up
arie segev
backtrack point
ldl this
p2 that
execution strategies
of marc
answer justification
the backtrackable
naive fixpoint
name joe
module types
on very
ease of
compilation techniques
deductive database
is responsible
horn clauses
manager to
execution model
the ease
the expressive
user interface
query language
record v
sigmod record
of use
implementation of
data intensive
intensive applications
bottom up
the program
engineering v
a deductive
responsible for
logic queries
relational dbmss
processing strategies
get first
logic database
application language
raghu ramakrishnan
rule manager
binding pattern
of p2
this experience
ldl programs
the translator
s sudarshan
various execution
and portable
generation as
of relational
and data
a pipelined
to support
database query
based language
mapped into
constructs for
programming language
the cost
the fact manager
the query form
the ldl compiler
the same generation
in a logic
at run time
logic data language
knowledge and data
at compile time
the unique representation
of the ldl
ease of use
generalized counting method
lazy materialized execution
data language ldl
query form manager
lazy pipelined execution
rule for p
the generalized counting
a single fixpoint
the user interface
data engineering v
and data engineering
on knowledge and
transactions on knowledge
the rule for
the magic set
large data bases
data and knowledge
the rule set
the ease of
very large data
on very large
is responsible for
from the query
data intensive applications
such as recursion
run time 3
tuples in p2
same generation as
use of ldl
semi naive fixpoint
rule transformation techniques
employee name joe
the next tuple
fact manager the
magic set method
query form the
rule for r
fact manager to
non horn constructs
of bound arguments
segev j leon
j leon zhao
ramakrishnan divesh srivastava
constants from the
commutativity and idempotence
can be greedily
materialized execution is
the code generator
set terms in
the rule manager
fact manager provides
raghu ramakrishnan divesh
divesh srivastava s
a logic data
predicate connection graph
rules and goals
by the translator
arie segev j
anc x z
srivastava s sudarshan
the expressive power
a logic based
sigmod record v
acm sigmod record
to the rule
n 2 p
and updates in
to recursive query
pipelined execution is
propagation of selection
the given query
of selection into
query processing strategies
recursive query processing
the recursive rule
a database query
the ldl system
logic based language
engineering v 7
database query language
data bases p
of the query
in the rule
conference on very
on the propagation
based language for
a bottom up
for the given
ieee transactions on
from the user
performed at the
a rule based
the first rule
bulk of the
predicate in the
of the language
of the rule
the bulk of
used by the
in a relational
for instance the
the formulation of
minimum cost execution
compiled query form
of recursive queries
rule to ensure
base and derived
towards a real
the pre enhancer
in prolog and
horn clause language
pushed into recursion
sg marc x
the schema manager
recursively defined relations
optimizing existential datalog
more complex rewriting
abstraction views and
at the success
z anc x
in the ldl
in rules and
as is compilation
the enhancer is
in virtual memory
harvard bs math
counting method for
similarly the fact
containing set terms
language ldl system
answer justification capability
the ldl implementation
of use that
updates in rigel
query form is
smalltalk a database
the coral deductive
that guarantees efficient
language for all
ldl is more
for set terms
views and updates
the execution space
of data retrieval
a fixpoint computation
carol small a
prolog a database
manager section 3
june 1 1993
z anc marc
modules and externals
appropriate execution strategy
rules are compiled
has been pushed
the translator to
the rule data
for all seasons
marc z anc
safe and efficient
for the formulation
of large join
existential datalog queries
greedily chosen for
tuple in p2
on values such
s sudarshan praveen
and derived relations
anc marc z
again compile time
data abstraction views
the constant migration
next tuple from
marc and then
set grouping and
a recursive predicate
constant migration step
of recursively defined
in logic pro
relation say rp2
bs math 1971
of intelligent backtracking
efficient and portable
coupling prolog with
an answer justification
the logic data
next backtrack point
the prolog cut
easy to develop

corpus/krapavin2000-test/627416.txt
articulator
meta
agent
agents
software
organizational
mary
joe
behavioral
collective
team
tasks
resources
spsl
articulation
trajectory
company
resource
action
skill
agenda
follower
accommodation
foo
task
query
development
actions
ms89
gar89
web
prescriptive
simulation
history
activities
workplace
processes
manager
queries
schema
prescription
specification
entity
managers
acquisition
fugini
hk89
hew86
bellettini
scacchi
sfg85
wil86
rights
teams
simulator
developers
slot
conflicts
situations
plans
project
peter
consumed
infrastructure
skills
controller
attributes
hierarchy
period
finish
simulating
manipulate
ost87
bs87
fifs
wil88
gs86
lamppost
ks82
sca88
timen
str88
peiwei
object
entities
organizations
settings
users
negotiation
engineering
strategic
empirical
tosem
efforts
metamodel
walt
faceted
condensed
unexpected
operators
document
slots
preconditions
architecture
mi
modeling
interactions
offices
spec
procedural
developer
possession
performers
infrastructures
force
linking
legend
interrelated
production
a2
deductive
symbolic
synchronization
circles
plan
relations
subtask
articulated
authorized
people
instantiation
reasoning
stores
recorded
mechanism
interface
conflict
ie
facilities
emerges
manipulation
mechanisms
chaining
behaviors
products
resolved
individual
subclass
planned
customized
status
assigned
super
objects
social
idle
planning
querying
simulated
manipulated
a3
retrieve
1993
projects
exchange
validating
schematic
primary
schedule
subsystems
assist
automating
toronto
strategy
kb
configured
selects
minable
ste81
damiani
parameter1
articulate
conceptualized
kai88
madhavji
oivo
bs89
prototyped
886
reiterates
ishys
explorerii
teamwork
statics
wileden
osterweil
affiliated
hl88
molgen
toubache
software process
the articulator
meta model
task performance
articulator meta
process models
meta knowledge
company f
query mechanism
process model
software processes
behavioral simulation
software development
of software
agent s
web of
and situations
of resources
an agent
the task
task space
define object
the web
task execution
of task
a software
a task
the software
resources and
the behavioral
software engineering
design foo
domain space
architecture design
the meta
of agents
the agents
process modeling
collective agent
performance skill
a meta
engineering processes
knowledge acquisition
task force
and joe
many many
history query
process meta
team a
mary and
the agent
tasks and
the knowledge
the simulation
knowledge base
space are
acquisition manager
in spsl
strategy space
information query
develop data
rights of
development activities
mary joe
behavioral simulator
detail design
to mary
by agents
a knowledge
at time
s task
symbolic execution
on software
the query
agents in
schema name
two agents
task decomposition
knowledge query
to peter
current action
task specification
new state
trajectory of
of meta
open systems
a resource
assigned to
their instances
model of
a period
the outside
multi agent
outside world
one many
organizational settings
articulator to
project managers
members mary
manipulation power
space stores
many 1
history queries
acquisition query
of organizational
primary tasks
its agenda
meta actions
information queries
relations linking
in company
chain task
agent task
accommodation strategy
of team
instantiation manager
g fugini
work assignment
and articulation
p model
meta reasoning
articulator and
q relation
collective tasks
task hierarchy
collective task
force assigned
instance schema
c slot
behavior simulator
meta tasks
process researchers
c bellettini
organizational work
perform tasks
agent controller
joe define
knowledge representation
data representation
what if
a development
operators in
the trajectory
time n
resource is
a state
entity in
agent may
and relations
development projects
force has
in collective
unexpected events
task chain
and organizational
a history
simulation is
software design
simulation of
for software
agents are
these agents
individual task
mechanism the
an action
object based
a collective
system interface
and tasks
another task
and simulating
individual in
in task
processes and
the tasks
problem solving
model and
a team
task has
information access
an object
types of
and resource
a plan
to agent
agents and
of tasks
their own
and knowledge
the resource
resource requirements
and procedures
period of
tasks in
design is
the strategy
the domain
an spsl
through continuous
subsystem interface
articulator meta model
the articulator meta
software process models
of the articulator
the software process
software process model
resources and situations
web of resources
the meta model
the web of
the query mechanism
the task space
of resources and
of task performance
a software process
the domain space
in the articulator
of software processes
software process modeling
task performance skill
software engineering processes
model of software
an agent s
software process meta
process meta model
mary and joe
meta model of
agent s task
the behavioral simulation
meta model the
in the task
of a software
a software development
a meta model
of the software
of software development
the knowledge base
the agent s
process models and
knowledge acquisition manager
a meta knowledge
s task performance
of software process
the behavioral simulator
assigned to mary
meta knowledge query
the strategy space
of the web
process model and
is a task
and their instances
the task execution
a new state
an object based
the outside world
over a period
chain task force
of meta knowledge
query mechanism the
task force has
in collective agent
software processes and
task space are
of task decomposition
with the outside
of team a
force assigned to
joe define object
company f is
file to peter
knowledge acquisition query
an information query
in company f
and joe define
task chain task
develop data representation
the articulator to
a history query
models and their
for software process
definition of meta
is a team
task force assigned
modeling and simulating
meta model is
software development projects
s p model
the articulator and
acquisition query mechanism
to mary and
company f and
behavioral simulation is
the instantiation manager
individual task performance
individual in collective
assigned to agent
a knowledge representation
during the performance
model the software
instance schema name
a period of
period of time
the simulation of
of a task
operators in the
the task specification
a task chain
the knowledge acquisition
system architecture of
agent s ability
of software engineering
in the web
agent s behavior
symbolic execution of
on software engineering
in the domain
types of software
of the task
in the strategy
an agent may
software development process
the system architecture
transactions on software
agents in the
methodology tosem v
and methodology tosem
engineering and methodology
rights of task
and situations is
hierarchy of task
and rights of
information access and
to infer to
a behavioral approach
behavioral simulator the
organizational work and
for querying the
domain space are
finish one fifs
approach to faceted
work structures and
task design foo
of organizational work
under the lamppost
a software production
of information access
software processes are
consumed or produced
specification an object
modeling a behavioral
rights of information
by two agents
process modeling a
meta model consists
prescription and the
methods and procedures
by the articulator
of operators according
meta model in
simulator the query
on software process
has three members
through continuous application
aware approach to
to perform tasks
environment for modeling
a field study
members mary joe
agents an agent
agent software processes
multi agent process
workplace offices are
agents and tasks
task performance such
outside world is
software maintenance work
continuous application of
software process researchers
slots c slot
fugini c bellettini
processes are software
define object meta
types of agents
meta model individual
case words reserved
force has follower
mary joe and
agents tasks and
new value agent
in the workplace
to faceted classification
oriented components acm
are open systems
task performance skills
knowledge engineering environment
query mechanism knowledge
the workplace offices
understanding software maintenance
its current action
state through continuous

corpus/krapavin2000-test/627506.txt
backpropagation
learning
neural
stochastic
cooling
configuration
annealing
boltzman
weights
configurations
generalization
training
eq
recognition
network
markov
temperature
acceptance
metropolis
weight
monotonic
convergence
lit
trained
stationary
minima
module
simulated
opt
trial
commands
outcome
samples
chain
backprop
backpropogation
outputs
i0
globally
explorations
probabilities
descent
connectionist
gradient
fit
irreducible
derivatives
forall
exp
aperiodic
error
backpropogation2epoch
transition
transitions
matrices
networks
memorization
psuedo
federation
microstructure
aperiodicity
schedule
adjustments
handwriting
inputs
neighboring
homogeneous
simulator
np
cognition
trigonometric
epochs
discover
perturbation
symbolic
perturb
lk
frozen
routines
criteria
probability
learn
brain
abilities
stuck
shallow
slowly
reproduce
neurons
conditional
fig
tune
curve
lm
constructive
converges
ch
jt
boolean
hidden
sd
outcomes
yielded
massively
outer_iteration_count
interactability
walkthrough
stop_criterion
crooked
w36
equilibrium_is_approached_sufficiently_closely
behaviorial
variablesby
forallj
mchines
datafiles
expotential
neurocomputer
8199
limq
feller
outpputs
finat
numeral
urop
minimas
reimplement
stisfaction
confi
______________________________________________________________________________
xmp
2o
train
comprises
sample
trials
testing
validation
analytical
organizing
pascal
regression
38
accepting
fitting
matrix
surface
modules
loading
dies
guration
hopfield
plateaus
teria
1090
historic
1073
prediction
il
square
squared
propagation
aims
formulation
associating
layered
numeric
randomly
neighbors
implements
inset
stu
cri
memorizing
handwritten
hereinafter
artificial
output
expert
discovering
setup
changed
schedules
bond
irreducibility
1o
seminar
emergent
inhomogeneous
package
formalism
reuse
contingent
sinusoidal
sitions
shekhar
recognize
derivative
net
signal
stochastic backpropagation
generalization problems
neural network
it l
for generalization
backpropagation algorithm
simulated annealing
eq c
the learning
backpropagation the
the backpropagation
learning algorithm
markov chain
the network
stationary distribution
of learning
the boltzman
monotonic functions
of stochastic
current configuration
output pairs
control parameter
globally optimal
neural networks
input output
chain is
weight space
optimal configurations
learning samples
1 lit
boltzman machine
total square
cooling schedule
optimal weights
the error
g t
configuration j
trained network
generalization problem
t l
the weights
l t
per pattern
i n
cooling rate
th trial
metropolis criteria
learning sample
neighboring configuration
r opt
by eq
recognition problems
the outcome
the stationary
the stochastic
the cooling
annealing in
square error
outcome of
non monotonic
explorations in
of fit
error function
network simulator
configuration i
desired output
a t
error of
the neural
gradient descent
of neural
the configuration
g it
constructive function
homogeneous markov
a i0
error derivatives
boltzman distribution
stochastic backpropogation
function learning
symbolic meaning
lit s
new configuration
lower error
acceptance probabilities
corresponding markov
pattern error
testing module
weight adjustments
chosen weight
backpropagation and
network is
domain i
of generalization
the convergence
the commands
the trained
input i
and generalization
the globally
distributed processing
learning algorithms
configuration is
for neural
s r
in generalization
c 12
global minima
from configuration
learning examples
learning module
configuration w
i0 i
the configurations
of input
in fig
the acceptance
error surface
signal detection
minimum error
conditional probabilities
1 o
conditions on
the weight
probability distribution
j c
functions over
hidden nodes
detection problem
during learning
entire domain
configurations with
parallel distributed
of weights
l 1
weights for
i t
within 5
training example
output o
commands to
e over
convergence of
convergence to
np complete
each weight
a stochastic
n o
matrices a
o 2
in error
the temperature
the output
the matrices
data collection
real numbers
problems the
outputs for
is irreducible
exp de
recognition 2
loading shallow
federation of
in weight
38 thus
de k
creating artificial
samples out
learning translation
backpropogation2epoch figure
function neurons
and boltzman
analysis module
get stuck
backpropagation network
symbolic semantic
plots statistics
node neural
generalization ch
in massively
initial stochastic
the metropolis
neurons structure
th training
yields per
il t
package 41
logarithmic and
trial is
backpropagation package
node functions
backpropogation backpropogation2epoch
cooling schedules
forall i
brain style
that forall
psuedo pascal
epochs of
lit jt
network yielded
it l t
of stochastic backpropagation
for generalization problems
stochastic backpropagation the
markov chain is
g it l
the stochastic backpropagation
input output pairs
l 1 lit
the control parameter
total square error
of input output
the backpropagation algorithm
error of fit
the outcome of
learning algorithm for
the current configuration
the stationary distribution
matrices a t
globally optimal configurations
algorithm for generalization
neural network simulator
i n o
simulated annealing in
and g t
2 i n
the neural network
the globally optimal
the weight space
parallel distributed processing
outcome of the
t and g
n o n
1 i 2
l t l
shown in fig
a t and
t l 1
case of stochastic
r g it
of generalization problems
the boltzman machine
non monotonic functions
a it l
globally optimal weights
by eq c
the new configuration
network is expected
t g it
randomly chosen weight
lit s r
new configuration is
in generalization problems
stochastic backpropagation algorithm
l t g
o 2 i
a i0 i
corresponding markov chain
constructive function learning
the corresponding markov
signal detection problem
weight space is
k b t
k th trial
eq c 5
per pattern error
i0 i t
optimal weights for
1 lit s
eq c 4
from configuration i
given by eq
s r a
r a it
1 o 2
the simulated annealing
s r g
the trained network
the learning algorithm
set of input
functions over the
a i k
of neural network
within 5 of
o 1 o
the matrices a
that the outcome
of the control
the change in
i 1 i
the network is
a markov chain
the state of
the error of
space f 1
of e over
expected to reproduce
yields per pattern
stationary distribution for
on the configurations
c refers to
function neurons structure
c th training
out of 50
convergence properties and
in error function
parameter l 0
i 2 o
a neighborhood structure
recognition in massively
neural network with
control parameter l
well as during
can fit the
connectionist learning with
implementation of stochastic
th training example
exp de k
fit the learning
the learning examples
as a federation
the network trained
homogeneous markov chain
compute an output
for generalization problem
generalization problem is
existence of stationary
handwriting recognition 2
the acceptance probabilities
initial stochastic backpropogation
trained network yielded
input i n
learning translation invariant
1 lit jt
a neighboring configuration
samples out of
convergence to global
in total square
3 stochastic backpropagation
trained network is
symbolic semantic network
design of intelligent
t the stochastic
backpropogation backpropogation2epoch figure
data set generator
the constructive function
conditions on matrix
j c refers
configuration w i
y j c
the output o
backpropagation package 41
lit jt s
of algorithm during
jt s r
learning the weights
of connectionist learning
generalization problems are
entire domain i
chain is aperiodic
set of learning
that forall i
error function e
backpropagation learning algorithm
the metropolis criteria
of the backpropagation
th trial is
generalization problems it
neurons structure and
training a 3
remember the outputs
50 within 5
federation of geometric
n e d
of adaptive pattern
alternative learning algorithms
a federation of
of 50 within
in weight space
t l of
of stationary distribution
of loading shallow
brain style computation
learning with various
examine and modify
the learning samples
stochastic backpropogation backpropogation2epoch
annealing in weight
change in total
for optimal annealing
backpropagation trained network
art of adaptive
the error derivatives
represent the possibly
stochastic backpropagation learning
current configuration w
the cooling rate
complexity of loading
the sequence t
shows the change

corpus/krapavin2000-test/627540.txt
stale
propagator
restart
bdb
recovery
transaction
pages
page
committed
fresh
logging
checkpointing
mmdbs
records
marking
backup
database
crash
pdb
flushing
dirty
redo
log
backups
incremental
buffer
undo
updates
manager
logger
flush
resident
checkpoint
loser
accumulator
ru
stable
flushed
fetch
steal
flushes
date
mmdb
locking
activities
driven
secondary
concurrency
aries
disk
lev91
mhl
whbm90
recovered
commit
locks
activity
lc87
lsn
redone
volatile
image
sgm87b
dko
atomicity
safe
memories
brought
winner
memory
rs
lock
tail
persistence
lush
ckks89
ls90
redoing
recs
eic86
paging
rus
decoupling
management
propagation
uncommitted
resumed
storage
ffl
underlie
undone
clean
granularity
record
fetched
triggers
post
checkpoints
raid
commitment
databases
status
quiescent
propagating
policy
transactions
pipeline
restoration
issuing
aborted
aborts
transitions
keeping
undoing
fuzzy
delayed
suffix
updating
thereby
items
hr83
rrh
wei88
ln88
writeset
hag86
eic87
wal
ram
propagated
physical
update
logged
invariant
committing
recovering
trade
interrupted
updated
falsifying
tei
precluding
hsien
lin80
read
enforcing
emphasize
grouped
deferred
architecture
principle
cache
demands
fetching
featuring
capitalizes
interchangeable
crux
bringing
segmented
processed
discarding
consistent
disaster
intolerable
flash
compatibility
affect
accommodate
atomic
idempotence
freshness
reflects
concurrently
forwards
commute
vacuously
amortize
db2
gbytes
semiconductor
facilitate
event
atomically
subtransactions
correctness
traditional
finer
sweeps
active
improvements
marked
book
principles
conventional
item
deficiencies
enforced
triggering
contemporary
log records
the propagator
the bdb
stable memory
the log
transaction processing
incremental restart
log driven
a page
stale fresh
page x
buffer manager
level recovery
fresh marking
main memory
driven backups
memory database
the pdb
operation logging
x stale
restart processing
high level
the database
page is
the buffer
a stale
the backup
a crash
to date
the page
the marking
database pages
post crash
safe fetch
the stale
level undo
base recovery
a recovery
committed transactions
updates to
i o
the committed
transactions are
log record
memory resident
secondary storage
restart procedure
page based
bdb is
the logger
log tail
no steal
recovery processing
stale page
database systems
the accumulator
pages are
records to
recovery management
recovery techniques
flushing a
a transaction
the high
restart is
backup image
an ru
dirty stale
propagator and
backup database
committed image
crash transactions
in stable
processing is
pages that
level log
database recovery
of pages
the invariant
resident database
brought up
flush fresh
single propagation
flushing of
logging is
steal policy
stale holds
bdb by
large main
loser transactions
redo only
page flushes
restart algorithm
stale pages
of transaction
x is
updates of
level operations
the recovery
on secondary
recovery scheme
the incremental
of log
of committed
multi level
database cache
crash recovery
restart in
are recovered
concurrency control
records of
records are
of recovery
an incremental
transactions and
only log
to recovery
buffer management
database on
the base
fast restart
x dirty
redo log
no transactions
crash transaction
the restart
standard restart
backup x
recovery activities
database page
down time
restart transaction
recovery manager
for mmdbs
recovery related
operation consistent
log is
invariant holds
with transaction
image of
consistent state
a log
the updates
transaction execution
restart the
at restart
only committed
propagating updates
entire database
in main
up to
recovery for
this principle
in database
current image
is stale
restart and
the commit
data items
is up
the pipeline
crash the
t 12
and restart
to undo
of transactions
updated by
on disk
records that
base level
steal buffer
pdb are
f lush
forward transaction
ffl page
which pages
a loser
missing updates
entry logging
o activity
fresh after
checkpointing algorithms
corresponding updates
fresh stale
normal transaction
grouped on
the aries
fuzzy algorithms
log recs
transaction rates
resident databases
stale marking
page basis
reflect updates
dirty pages
large buffer
to bdb
single pages
backups technique
in lc87
propagator applies
to the bdb
by the propagator
stale fresh marking
up to date
log driven backups
the buffer manager
main memory database
the high level
the log driven
high level recovery
the stale fresh
of log records
in stable memory
of the database
in the pdb
that the propagator
page x is
log records to
log records of
high level undo
the base recovery
a stale page
the bdb is
brought up to
the log tail
high level log
the log records
post crash transactions
log records are
the propagator and
memory database systems
a page is
pages that are
to the log
the page is
the incremental restart
image of x
bdb by the
the backup image
multi level recovery
the committed image
a page x
following a crash
the bdb by
updates to the
of committed transactions
on secondary storage
in the log
records to the
after a crash
high level operations
in database systems
the invariant holds
records of committed
to the backup
the backup database
no transactions are
no steal policy
log records that
incremental restart algorithm
operation consistent state
memory resident database
transaction processing the
transaction processing is
restart processing is
memory database recovery
database on secondary
x is stale
of large main
an operation consistent
x stale holds
flushing a page
in main memory
the entire database
resident database system
by the buffer
written to the
approach to recovery
of a recovery
of the log
operation logging and
for propagating updates
the database pages
page is brought
a log record
driven backups technique
the pdb are
fresh stale marking
to secondary storage
fresh marking of
the pdb and
page is recovered
the no steal
x is fresh
a page based
single i o
the corresponding updates
transactions are processed
i o activity
of stable memory
log records as
log on disk
high transaction rates
crash recovery for
steal buffer management
system is up
the propagator applies
the logger and
based on operation
ffl page x
of loser transactions
of incremental restart
down time of
for memory resident
updates to bdb
x is dirty
on operation logging
which pages are
database recovery a
large main memories
the down time
operation logging is
parallel with transaction
post crash transaction
propagator and the
reflect updates of
normal transaction processing
a crash the
redo only log
redo log records
committed image of
only log records
approach to restart
the database cache
stable memory and
at restart the
backup image of
no steal buffer
of the page
propagated to the
the database is
of a page
as the system
database systems a
of transaction processing
buffer management policy
of data pages
high level action
with transaction processing
recovery scheme for
for main memory
and t 21
the log disk
is brought up
a single i
flushed to the
a quiescent state
the demands of
the database on
x is denoted
the traditional approach
we emphasize that
of main memory
transaction processing systems
t 11 and
say that x
11 and t
i o the
delayed until the
in the pipeline
suffix of the
based concurrency control
if the page
prior to the
read and write
if x is
to access a
is referred to
transactions in the
the trade off
the propagator can
single propagation the
pages a b
recovery processing and
techniques for main
level recovery management
mmdbs without precluding
crash recovery scheme
recovery algorithm for
page together so
the bdb up
enforcing safe fetch
the log on
backup database on
the variables we
page i o
redo only bdb
li pin chang
initialization and crash
the recovery manager

corpus/krapavin2000-test/627561.txt
ldbs
ticket
ldbss
multidatabase
subtransactions
tickets
otm
transaction
serialization
subtransaction
mdbs
serializability
commit
ctm
prepared
cascadeless
concurrency
schedules
serializable
autonomy
commitment
conflicts
schedulers
gsg
itm
optimistic
participating
rigorous
rigorousness
committed
restarts
database
georgakopoulos
sheth
aborted
conflict
timeout
recoverability
abort
2pl
mdbss
validation
dbmss
management
serialized
cascadelessness
2pc
scheduler
enforcing
orders
rusinkiewicz
recoverable
aborts
indirect
transactions
enter
timestamp
site
wfg
submission
visible
strictness
schedule
heterogeneous
ticketing
commits
conservative
deadlock
altruistic
analogous
trans
submits
locks
mixed
unilaterally
expires
sql
locking
interleave
enforce
dbms
lock
global
violate
issued
strict
enters
datacycle
gte
sybase
arpinar
restarted
resolve
increments
bellcore
sagas
breitbart
recovery
vendor
implicit
timeouts
serial
cas
consistency
cycle
precedes
oe
semi
deadlocks
submitted
g2
occ
houston
blocking
reads
databases
sites
disallow
executions
caused
entered
mechanisms
rda
wt1
channeled
sangkeun
younger
hornick
halici
hurson
logar
cadeless
action
globally
ae
execution
interfaces
violated
heterogeneity
laboratories
read
rollback
correctness
ensure
sub
certification
simulated
agent
superdatabases
multidatabases
finished
increment
updates
participate
edges
strongly
decentralized
g1
federated
dimitrios
interbase
larson
refinements
reflect
prepare
autonomous
handshake
transac
pu
allowed
permits
eliminates
removal
controlling
difficulties
trol
nevada
successfully
preventing
reflects
writes
scheduling
environments
uncommitted
expired
permit
ts
preferred
incoming
theta
1997
hwang
chong
op
conflicting
blocked
affecting
ensures
undirected
erations
global transactions
prepared to
subtransactions of
the subtransactions
to commit
global serializability
the mdbs
commit state
serialization order
their tickets
global transaction
multidatabase transactions
concurrency control
the ldbss
a ticket
transaction management
g 1
take their
of multidatabase
of g
the ticket
relative serialization
subtransaction of
g 2
its ticket
before g
multidatabase transaction
their prepared
participating ldbss
serialization orders
and serialization
a subtransaction
each ldbs
of global
local serialization
transaction g
the subtransaction
ldbss that
the ldbs
take tickets
visible prepared
at ldbs
ldbs 2
enter their
a ldbs
g j
the local
to take
g i
ticket state
tickets before
ticket method
global restarts
a multidatabase
all subtransactions
each subtransaction
local transactions
the participating
in ldbs
its prepared
local concurrency
of otm
site graph
the serialization
the take
database systems
in multidatabase
a transaction
schedules in
corresponding ldbss
ticket value
local serializability
analogous execution
transactions g
the serializability
execution and
take a
serializability in
multidatabase systems
each global
a visible
distributed database
local systems
commitment order
ticket before
tickets and
cascadeless otm
each multidatabase
ticket conflicts
its tickets
ticket and
multi database
and g
takes its
orders are
sub transactions
subtransactions to
take its
serializability of
tickets in
the multidatabase
the commitment
their relative
sheth enforcing
tickets to
rusinkiewicz sheth
ldbss ensure
ticket operations
become prepared
ticket methods
mdbs can
georgakopoulos rusinkiewicz
the prepared
the cascadeless
local schedules
strongly recoverable
g c
local transaction
conflicts between
transaction execution
transactions are
the global
the site
all participating
local database
serialization graph
its subtransactions
indirect conflicts
multidatabase environment
schedules that
simulated prepared
in mdbss
semi rigorousness
guarantees global
rigorous schedules
enforce global
ensure local
subtransaction has
ldbs and
becomes prepared
and restarts
in ldbss
ldbs 1
implicit tickets
strong recoverability
implicit ticket
ldbss the
tickets at
transactions in
oe oe
same relative
sub transaction
serializability and
non serializable
management mechanism
multidatabase system
transactions to
enters its
transactions have
order in
for multidatabase
all ldbss
aborts and
the transaction
control of
enforcing the
execution order
a global
serializable schedules
serializable and
local autonomy
or abort
ldbs that
some ldbs
ticket operation
ldbs autonomy
optimistic schedulers
indirect conflict
are cascadeless
a gsg
ldbss to
direct conflict
otm and
mdbs has
of ctm
conservative ticket
ae ae
order of
commitment of
relative order
they enter
autonomy and
timeout for
are allowed
is aborted
the transactions
the control
trans action
recently committed
g become
prepared to commit
to commit state
the subtransactions of
subtransactions of g
take their tickets
take a ticket
prepared to take
subtransaction of g
of global transactions
relative serialization order
of multidatabase transactions
their prepared to
execution and serialization
at each ldbs
and serialization orders
enter their prepared
visible prepared to
serialization order of
their relative serialization
a visible prepared
the subtransaction of
a ticket state
the take a
of the ldbss
a global transaction
its prepared to
the site graph
the serializability of
the local serialization
the participating ldbss
local serialization order
global transaction g
all subtransactions of
and g 2
g 1 and
under the control
1 and g
global serializability in
to take their
enforcing the serializability
local concurrency control
serialization orders are
each multidatabase transaction
transaction execution and
takes its ticket
analogous execution and
subtransactions of global
of g 2
to take a
in a multidatabase
the control of
serializability of multidatabase
subtransactions of each
each global transaction
multidatabase transaction management
the prepared to
enters its prepared
become prepared to
its ticket before
sheth enforcing the
to take tickets
rusinkiewicz sheth enforcing
georgakopoulos rusinkiewicz sheth
schedules in which
in ldbs 2
before the subtransactions
and g j
the serialization order
in multidatabase systems
transaction management mechanism
transaction management in
g i and
i and g
guarantees global serializability
aborts and restarts
local transaction t
the ldbss ensure
until they enter
its tickets before
the ticket value
tickets before g
in all participating
they enter their
global transactions g
before g 2
to take its
all participating ldbss
a subtransaction of
their corresponding ldbss
becomes prepared to
after all subtransactions
a transaction management
enforce global serializability
simulated prepared to
the same relative
of g 1
distributed database systems
oe oe oe
g 1 is
order in which
order of global
global transactions are
a multidatabase environment
the local transaction
the global transaction
of g k
transactions at each
the commitment of
transaction t 1
the mdbs can
the implicit ticket
for local concurrency
g become prepared
by the mdbs
their tickets at
management mechanism is
transactions g 1
at some ldbs
a timeout for
conflicts can be
sets a timeout
ldbss that use
in a ldbs
submits its subtransactions
allowed to interleave
its subtransactions to
ldbss ensure local
which transaction execution
take its tickets
the mdbs has
commit or abort
ensure local serializability
at ldbs 2
ldbss that allow
to enforce global
global serializability by
global transactions to
which the subtransactions
are allowed to
ae ae ae
global transactions in
in which transaction
a set g
of g c
of each global
local database systems
heterogeneous distributed database
database management systems
by the local
the serialization graph
the order in
of g 3
z z z
a ldbs that
control mechanisms of
of generality suppose
control of ctm
implicit ticket method
generality suppose that
transaction g as
global transactions at
2 each multidatabase
sub transactions of
each subtransaction has
conflicts between multidatabase
state after all
conflict between g
the global transactions
the relative serialization
interleave under the
allowed to commit
orders are analogous
mdbs has no
ticket value before
ticket method itm
autonomy of the
by the ldbs
preferred ticketing in
enforcing global serializability
site graph method
before g 1
multidatabase transaction has
management in multidatabase
commit state is
serialization order theorem
subtransactions to the
a ticket operation
reflects their relative
their local serialization
the local concurrency
relative order in
sub transaction at
the sub transactions
the ldbss until
subtransactions at each
otm and ctm
order theorem 1
that global serializability
subtransactions of multidatabase
2pc agent method

corpus/krapavin2000-test/627595.txt
atbe
trees
pa
edit
query
dist
distwithcut
rna
subtrees
tree
file
matching
distwithprune
umbrellas
cuttings
editing
prunings
retrieve
manager
subtree
marks
bars
distance
someroots
retrieval
pattern
expr
database
match
screen
display
boy
umbrella
book
lexical
lql
donnell
users
delete
children
queries
distances
pop
matched
parses
parse
verbs
apt
bar
inexact
bool
node
hoffmann
relabeling
dictionary
rooted
displayed
foo
window
comparator
instantiation
contents
linguists
insert
pictorial
triangle
retrieving
cut
mark
molecular
sequenced
shasha
approximate
fl
processor
editor
keyed
unimportant
strings
string
unordered
farther
vp
reads
label
jt
ancestor
substitutions
alfredo
jason
windows
labeled
touched
ffl
rosalba
nonprocedural
kaizhong
byrd
wyk
chodorow
rnas
xifeng
giugno
dennis
philip
biology
extract
command
graphical
secondary
inputing
psql
menus
formats
mapping
sigmod
fig
eliminate
displays
var
pruning
tense
tsong
fingerprint
oql
extraction
files
structural
substitution
retrieves
inequality
correction
iter
jiawei
entered
name
language
semantic
customizable
tailor
verb
ingres
nouns
typing
sentence
transform
locate
grammar
sub
recognition
dissimilar
dissimilarity
wishes
op
locating
menu
deleted
routines
braces
wisconsin
nodes
template
newly
picking
serial
consideration
comparing
searching
preorder
repositories
closest
drawings
custom
yan
interpreters
manipulates
instantiating
seriously
dotted
operators
stages
siblings
ancestors
lowest
height
descendants
prefixes
det
querying
highlighted
shorthand
42
databases
extracting
stores
matches
format
portions
instantiate
text
edit operations
dist pa
the pattern
tree matching
display manager
the query
pa t
t 0
tree t
of edit
retrieve tree
between trees
editing distance
data trees
approximate tree
query processor
the editing
atbe is
tree comparison
trees in
from t
by example
file name
data tree
matched with
pattern tree
distwithcut pa
atbe query
node contents
the display
sub tree
pa and
labeled trees
the tree
query language
trees t
between pa
in pa
of atbe
atbe system
match retrieval
bool expr
pattern pa
the atbe
in t
distance between
to t
t from
the distance
pop up
ordered labeled
the screen
a pattern
of trees
would match
someroots t
the boy
eliminate trees
from f
for tree
is matched
t to
a tree
rooted at
tree type
given pattern
file f
ffl in
children of
label and
from consideration
t i
triangle inequality
from file
best match
is tree
computing distances
s pa
comparing trees
lowest node
o donnell
rna secondary
pa to
hoffmann and
allowing zero
solution tree
the file
subtree rooted
distances between
the subtree
trees and
tree is
linear form
query optimization
nodes in
trees have
string matching
the user
users may
to tree
the subtrees
the trees
a query
a label
screen and
the triangle
information retrieval
at nodes
the children
sub trees
trees from
approximate string
trees that
the system
a file
can eliminate
the bar
right order
without marks
that transform
computing dist
dictionary definitions
the umbrella
tree comparator
an atbe
worst match
mark substitutions
distance would
boy reads
atbe provides
distwithprune pa
distance operators
unordered labeled
node formats
in atbe
cuttings or
the marks
subtrees from
between unordered
newly sequenced
inexact matching
atbe s
book is
horizontal normal
or prunings
umbrella is
may edit
sequenced rna
extract information
query processing
matching and
tree that
language processing
those for
allows users
two trees
users to
keyed in
47 the
from tree
dist t
pa is
edit operation
consecutive sequence
instantiation the
to pa
dennis shasha
underlying algorithms
such trees
not touched
matching tree
resulting distance
transform t
queries containing
secondary structures
at node
query the
information from
matching in
the node
zero or
trees the
and t
the book
the database
trees are
nodes from
query by
using tree
user wishes
exactly match
command is
i fig
i than
distance metrics
where dist
entire tree
node l
removed when
match their
the display manager
of edit operations
to t 0
the editing distance
t to t
editing distance between
the query processor
is matched with
t from f
retrieve tree t
dist pa t
tree t from
approximate tree matching
a label and
between pa and
pa and t
nodes in t
from t to
distances between trees
the atbe system
for tree comparison
pa t s
on the screen
matched with the
has a label
subtree rooted at
distance between trees
eliminate trees t
hoffmann and o
nodes from t
and o donnell
allowing zero or
mapping from t
best match retrieval
computing distances between
sequence of edit
from f where
can eliminate trees
the pattern pa
at nodes from
distance between pa
atbe query for
the lowest node
from file name
the triangle inequality
the children of
ordered labeled trees
query language for
the subtree rooted
of the pattern
to right order
the distance between
zero or more
in t 0
approximate string matching
the pattern and
set of algorithms
natural language processing
to the pattern
the tree comparator
newly sequenced rna
in computing dist
where dist pa
resulting distance would
pa to t
that exactly match
file f that
their corresponding nodes
among the children
to tree t
the edit operations
unordered labeled trees
for approximate tree
linear form of
pa t i
edit operations that
distance between unordered
would match their
dist t t
the boy reads
distance would be
cuttings or prunings
t i than
data trees that
transform t to
between unordered labeled
an atbe query
match their corresponding
best matching tree
approximate tree by
a data tree
ffl in computing
operations that transform
removed when comparing
from tree t
for computing distances
tree by example
away from t
we can eliminate
a query language
allows users to
tree of f
farther away from
right order of
the user wishes
trees in which
t i gamma1
the resulting distance
query processor when
be removed when
t 0 j
the entire tree
a given pattern
is an ancestor
the screen and
if u 6
user wishes to
t 0 the
query by example
the sub tree
the data tree
corresponding nodes in
trees that are
f that are
left to right
the linear form
in a file
the current best
in the pattern
trees in a
extract information from
an ancestor of
in the window
don t care
a mapping from
and related problems
the left to
compute the distance
this type of
each node in
of nodes in
t t 0
to be removed
node has a
of t 0
tree in the
and t 0
shown in figure
tree matching i
query the pattern
type of file
information from trees
a tree system
spatial data modeling
o jt 1
which is matched
t means removing
inexact tree matching
display manager is
yu jiawei han
is no cost
iter var is
from repositories of
system for psql
jason tsong li
book is the
data trees are
var from file
the given pattern
t cf section
trees in some
via pop up
parses the query
in file f
of algorithms was
distwithprune respectively between
an efficient pictorial
atbe is implemented
has any is
of siblings among
a newly sequenced
oql a query
have many applications
trees and related
the umbrella is
data tree that
database and information
nodes black dots
current best matching
he would type
triangle inequality to
for fingerprint pattern
jt 1 j
var is tree
the pattern 3
tree t 0
against those in
nonprocedural programming languages
trees t that
when comparing strings

corpus/krapavin2000-test/627641.txt
girl
conceptual
sue
eat
pie
eating
hierarchy
graphs
predecessors
parents
agent
levinson
c3
query
c7
subsumption
canonical
ip
immediate
person
formation
fig
generalization
referent
generalizations
act
instructions
subhierarchies
c8
c5
kitchen
garner
tsui
specializations
fuse
c4
conforms
successors
marker
food
piece
differences
specialization
subtype
woods
x9
mappings
animate
sentences
database
topological
adjacent
x10
compressed
subgraph
b2
breadth
markers
uds
chess
compilation
restrict
arcs
r2
b3
concept
c1
subhierarchy
insert
cat
supertype
entity
labels
morph
canon
coatoms
restrictref
r4
parent
object
children
files
concepts
dog
conformity
traversal
absurd
arc
redundant
instruction
traversing
storing
file
sentence
join
b1
morphisms
subtypes
x3
specialized
compression
linked
conform
queue
rules
manner
acgs
queensland
colomb
whitepawn
fritz
kayed
q1g
unifiable
oev
oddprime
compiled
taxonomy
searching
inserting
attribute
search
predecessor
lempel
c6
referents
ffg
morphism
joining
ith
kl
ffl
examine
answers
matching
neighbourhood
ziv
falsity
compresses
canonically
lehmann
fast
mapping
reconstructed
wn
indexing
prime
derivable
hierarchies
duplicate
enqueue
ahmad
incomparable
stored
relations
linking
ontologies
x7
retrieval
intersection
derivations
chy
compressing
traversed
existential
phase
acyclic
copy
duplicates
classification
x5
addressable
priority
c2
hierar
x6
levin
walking
ordering
effected
generic
x4
denotation
read
chemical
maps
largest
match
unification
lattice
depth
son
removal
mode
querying
traverse
schemas
figs
column
robert
conceptual graphs
generalization hierarchy
girl sue
agent eat
is eating
the query
conceptual graph
formation rules
the generalization
all parents
immediate predecessors
the hierarchy
graphs in
a girl
query graph
of conceptual
in fig
canonical formation
adjacent graphs
manner fast
query u
eat object
the graph
eating fast
type labels
sue is
object pie
piece piece
graph u
the graphs
eating pie
u in
the immediate
parents method
generalization space
immediate successors
the canonical
of u
a generalization
canonical graphs
hierarchy in
database graphs
girl is
a conceptual
immediate generalizations
eat manner
largest parent
sue agent
insert u
and tsui
individual marker
the subhierarchies
garner and
topological search
conforms to
the differences
hierarchy the
the database
instructions which
predecessors of
person sue
act object
pie girl
pie fast
graphs u
over conceptual
levinson 6
pie object
subhierarchies of
in u
a concept
generalizations of
a graph
graphs are
object agent
c3 girl
tsui s
c3 r2
conceptual relations
object entity
database graph
maximal common
girl eat
eat person
immediate specializations
between graphs
woods 16
c7 girl
marker conforms
breadth first
first search
concept c
graph to
hierarchy this
the formation
as differences
agent act
between adjacent
the search
graphs the
each w
order over
fig 7
the mapping
u c
u v
graph v
generalizations and
specializations of
graph d
of ip
graphs and
the adjacent
first phase
generalization of
are conceptual
eat agent
r2 c4
individual markers
identical concepts
specialized cases
c c3
conformity relation
referent c
eat pie
predecessors are
conceptual relation
ith arc
the girl
act agent
sue d
specialization space
location kitchen
kitchen agent
person is
compressed using
u and
of v
ip is
hierarchy is
v is
partial order
graph is
u the
knowledge base
linked to
a person
to u
the files
the specialization
second phase
b u
graphs b
fast is
subsumption test
graph f
by sharing
common subtype
of graphs
d u
s method
graph in
to type
u is
of immediate
mappings between
the all
2 ip
predecessors and
differences between
the mappings
graphs into
arc of
and immediate
the column
graphs as
the concept
redundant data
hierarchy by
type c
a specialization
search the
predecessors match
match v
a pie
when compressed
processing between
c5 c8
entity manner
function immediate
performing matching
graph differences
manner act
common computation
eat girl
fast girl
simple instructions
u ip
subgraph morphism
ip u
the generalization hierarchy
the query graph
of conceptual graphs
canonical formation rules
the query u
the canonical formation
graphs in the
hierarchy in fig
a conceptual graph
in the hierarchy
conceptual graphs in
piece piece piece
the generalization space
sue is eating
is eating fast
eat object pie
of the query
in the generalization
girl sue is
is eating pie
generalization of u
all parents method
the immediate predecessors
the formation rules
a girl is
a girl sue
girl is eating
agent eat object
garner and tsui
the hierarchy in
the all parents
conceptual graphs and
conceptual graphs the
partial order over
the subhierarchies of
over conceptual graphs
the adjacent graphs
eat manner fast
between adjacent graphs
graphs u and
is a generalization
each w 2
for each w
a generalization of
and tsui s
sue agent eat
act object entity
concept c in
girl sue agent
eating pie fast
agent eat manner
adjacent graphs in
generalization hierarchy in
the graph d
agent eat person
graphs in a
query u in
conceptual graphs are
marker conforms to
u in fig
a generalization hierarchy
tsui s method
of u in
u in the
of the canonical
to the query
the first phase
in fig 7
the graphs in
the hierarchy the
generalizations of the
of the graphs
the knowledge base
individual marker conforms
the ith arc
c3 r2 c4
in a generalization
generalization hierarchy the
immediate predecessors and
are conceptual graphs
the graph u
u is identical
conceptual graphs u
formation rules are
maximal common subtype
the database graphs
person is eating
kitchen agent eat
c in u
compilation of conceptual
an individual marker
location kitchen agent
order over conceptual
subhierarchies of the
ith arc of
differences between adjacent
the second phase
the hierarchy is
w 2 is
breadth first search
of the immediate
immediate predecessors of
into the query
set of immediate
begin for each
graph in the
the hierarchy this
graph to be
u and v
in fig 9
set of sentences
predecessors match v
girl eat agent
and immediate successors
be linked to
conceptual graph theory
girl sue eating
entity manner act
graphs in fig
eat agent eat
girl sue pie
a graph u
conforms to type
u ip is
immediate successors ip
immediate predecessors u
ways removal of
of database graphs
manner act attribute
the girl sue
query graph u
act agent act
matching and by
s immediate predecessors
immediate generalizations and
generalization space the
the graph v
the immediate successors
of redundant data
common processing between
simple instructions which
the graph b
must be linked
the identical concepts
manner fast girl
is v do
the concept c3
the largest parent
the conformity relation
graphs as differences
procedure insert u
the mapping b
eat person object
by sharing common
performing matching and
the mappings of
data use of
object entity manner
sue girl sue
labels in t
redundant checks when
processing between graphs
agent act object
traversing the hierarchy
r2 c4 agent
when performing matching
immediate specializations of
minimal common supertype
the maximal common
subgraph of u
when compressed using
the database graph
graph d is
shows the size
acyclic graph representing
redundant data use
of the subhierarchies
query graph in
immediate generalizations in
the immediate generalizations
be read a
fast girl eat
pie object agent
agent person sue
all type labels
a manner fast
c c3 r2
elements of ip
three ways removal
of simple instructions
2 is v
is a predecessor
pie girl sue
immediate predecessors from
graph u in
set of conceptual
ignore redundant checks
conceptual graphs a
v 2 ip
conceptual graphs we

corpus/krapavin2000-test/627645.txt
connectionist
neuronal
microfeature
connectionism
inferences
reasoning
neural
plausible
vague
structuring
fuzzy
expert
massively
mundane
athematics
neurally
echanical
athematical
ghalwash
similarity
defence
pdp
analogical
possibilistic
chunking
inference
recency
desiderata
samuel
commonsense
skill
robotic
feedforward
backpropagation
ind
multilayer
logic
brain
marker
facilitated
integrating
replica
domains
sensible
abstractin
society
discrete
215
chan
engines
linguistic
201
157
parsing
175
memories
inheritance
deduced
learning
logics
coming
acquisition
associative
satisfaction
theories
semantically
similarities
utility
conceptual
incorporating
engine
concepts
inspired
mixed
networks
connecting
incorrect
primitives
rules
refinement
encoded
intelligent
universal
core
evidence
symbolic
recognition
bases
plays
intelligence
designing
frame
interaction
links
accordingly
passing
enable
proving
1998
probabilistic
adaptive
matching
2001
principle
december
carried
network
continuous
beyond
levels
approximate
rule
selection
dependent
role
produces
november
nodes
modeling
concept
constraint
march
engineering
features
illustrate
propose
representing
explicitly
group
account
ieee
transactions
representation
conclusions
domain
scheme
z
the
are
to
by
t
be
with
for
in
an
one
r
and
introduction
of
tr
this
on
b
is
not
can
2
a
3
which
via
parallel
theorem
knowledge
examples
context
able
w
models
theory
consists
useful
research
sets
take
level
application
applied
presented
up
important
k
ctr
data
system
several
out
13
many
first
paper
9
will
between
we
where
v
neuronal models
discrete neuronal
structuring knowledge
a connectionist
plausible reasoning
in vague
connectionist model
and connectionism
and microfeature
of plausible
reasoning a
the discrete
expert systems
massively parallel
knowledge based
concepts and
knowledge in
associative memories
parsing fuzzy
satisfaction an
context symbolic
201 215
dependent representation
chunking and
and echanical
connectionism neurally
universal backpropagation
connecting concepts
recency inference
logic marker
defence of
integrating linguistic
the athematics
inferences to
bases applied
a recency
accordingly examples
fuzzy logics
multilayer feedforward
175 march
parallel parsing
modeling context
microfeature based
model rules
157 175
z ghalwash
model principle
a athematical
beyond associative
in defence
knowledge recognition
integrating knowledge
chan integrating
important desiderata
where similarity
microfeature nodes
mundane reasoning
conceptual knowledge
networks features
systems integrating
sensible conclusions
samuel w
conclusions accordingly
networks frame
connectionism the
parallel constraint
incorrect rules
enable useful
pdp research
a microfeature
similarity plays
inheritance refinement
produces sensible
inference network
links representing
theory mundane
similarity matching
marker passing
rules connectionist
plausible inferences
adaptive brain
microfeature multilayer
athematical theory
similarities beyond
evidence designing
linguistic primitives
rules connecting
designing inference
expert networks
vague domains
possibilistic and
for robotic
vague and
athematics of
1998 samuel
echanical theorem
models chunking
frame selection
desiderata of
ghalwash a
representing rules
neurally inspired
representing concepts
deduced via
model inferences
connectionist knowledge
to possibilistic
inspired massively
reasoning incorporating
robotic skill
symbolic logic
useful inferences
facilitated and
ind probabilistic
reasoning massively
logics neural
are facilitated
connectionist scheme
discrete neural
skill acquisition
via mixed
core theory
concept nodes
incorporating rules
sets fuzzy
neural networks
t structuring
for connectionist
connectionist expert
based replica
and analogical
brain in
acquisition the
approximate domain
inferences the
analogical reasoning
of ind
learning context
knowledge not
domains b
and similarities
are universal
mixed similarity
based neural
explicitly encoded
similarity similarity
k chan
the society
the pdp
215 november
inference engines
neural representation
with plausible
in structuring
the model
rules and
context dependent
by knowledge
memories the
semantically incorrect
coming up
levels one
representation ieee
to expert
commonsense reasoning
ctr z
backpropagation learning
parallel model
level based
an introduction
in coming
domain theories
in expert
november december
of semantically
domains a
society of
of commonsense
feedforward networks
inferences are
continuous domains
of conceptual
applied intelligence
engines based
several domains
p 201
and fuzzy
december 1998
examples will
rule application
theories by
based reasoning
inference engine
logic an
of evidence
probabilistic reasoning
many important
reasoning the
replica of
nodes representing
discrete neuronal models
the discrete neuronal
of plausible reasoning
structuring knowledge in
knowledge in vague
a connectionist model
enable useful inferences
many important desiderata
a recency inference
expert networks frame
chan integrating linguistic
175 march 2001
are universal backpropagation
and microfeature multilayer
mundane reasoning by
model rules and
for structuring knowledge
two levels one
neurally inspired massively
p 157 175
integrating linguistic primitives
of two levels
reasoning incorporating rules
logic an introduction
recognition of semantically
the model inferences
and produces sensible
dependent representation ieee
the athematics of
model principle of
research group a
parallel constraint satisfaction
model for structuring
t structuring knowledge
recency inference engine
neuronal models the
nodes and microfeature
memories the athematics
symbolic logic and
reasoning massively parallel
theory of evidence
primitives in learning
reasoning the society
to enable useful
accordingly examples will
in expert networks
satisfaction an introduction
intelligence v 9
integrating knowledge based
concepts and links
connectionist knowledge bases
inferences are facilitated
microfeature multilayer feedforward
bases applied intelligence
model of rule
vague and continuous
systems integrating knowledge
157 175 march
analogical reasoning massively
logic marker passing
sets fuzzy logic
possibilistic and fuzzy
intelligent systems the
and echanical theorem
to possibilistic and
society of ind
rules and similarities
of evidence designing
matching and rule
adaptive brain in
in coming up
learning in expert
skill acquisition the
levels one of
facilitated and knowledge
networks features of
via mixed similarity
ind probabilistic reasoning
november december 1998
parsing fuzzy sets
neuronal models chunking
group a athematical
brain in defence
rules and connectionism
semantically incorrect rules
for modeling context
similarity plays a
core theory mundane
mixed similarity matching
athematical theory of
multilayer feedforward networks
networks are universal
with plausible inferences
theory mundane reasoning
inferences to be
and microfeature nodes
are facilitated and
inferences the model
the concept nodes
of conceptual knowledge
not explicitly encoded
robotic skill acquisition
linguistic primitives in
of many important
similarity similarity and
by parallel constraint
domains where similarity
neuronal models and
networks frame selection
inference engines based
domains a abstractin
of commonsense reasoning
application the model
and links representing
vague domains a
scheme for modeling
useful inferences to
based replica of
systems and neural
and knowledge not
in structuring knowledge
conclusions accordingly examples
a athematical theory
and connectionism neurally
logics neural representation
important desiderata of
beyond associative memories
incorrect rules connectionist
where similarity plays
parallel parsing fuzzy
similarity and analogical
is a microfeature
a discrete neural
athematics of inheritance
logic of plausible
december 1998 samuel
microfeature based replica
model in structuring
of logic marker
ctr z ghalwash
be deduced via
discrete neural network
neural networks features
of ind probabilistic
massively parallel model
universal backpropagation learning
frame selection in
samuel w k
knowledge bases applied
commonsense reasoning incorporating
pdp research group
echanical theorem proving
representing rules connecting
learning context dependent
feedforward networks are
desiderata of plausible
introduction to expert
connectionism the discrete
plausible reasoning and
structuring knowledge to
based reasoning a
reasoning and produces
designing inference engines
evidence designing inference
of reasoning the
context dependent representation
and analogical reasoning
for connectionist knowledge
model of commonsense
models chunking and
incorporating rules and
in learning context
inspired massively parallel
produces sensible conclusions
in vague and
proving the logic
r a connectionist
passing and microfeature
knowledge to enable
deduced via mixed
role in coming
and fuzzy logics
in vague domains
an inference network
fuzzy logic an
parallel model of
modeling context symbolic
and rule application
out in several
a core theory
rules connecting concepts
similarity matching and
connecting concepts and
logic and echanical
sensible conclusions accordingly
networks for robotic
and connectionism the
p 201 215
representing concepts and
domains b r

corpus/krapavin2000-test/627655.txt
chain
buffered
evaluable
recursions
split
cons
recursion
bbf
zs
predicate
query
binding
predicates
finiteness
magic
ffb
adorned
exit
compiled
finitely
isort
qsort
edb
evaluability
bf
portion
xxs
propagation
append
deductive
xbs
rectified
recursive
xs
fare
functional
dtime
bbff
xls
country
merged
bs
derives
parent
idb
parents
ls
insert
join
littles
scsg
bigs
normalized
bindings
logicbase
generating
departure
nonlinear
evaluated
subchains
atime
portions
evaluation
rule
nonrecursive
bb
bff
body
deduction
chains
pushing
termination
600
birth
logic
x0y0
arr
dep
bbb
nested
selective
travel
database
relatives
flights
infinitely
judgement
linkages
ottawa
adornment
counting
instantiated
rules
rationale
expansion
linkage
uninstantiated
patching
proceeds
instantiation
buffering
fb
hx
ffl
partition
delayed
nw
fbfff
fno
fbb
xy
compilation
pushed
plan
efficiency
intermediate
datalog
programs
quantitative
weak
vancouver
fi
path
linearly
nonlinearly
fbf
fraser
patched
subchain
adorn
primitive
constraint
transitive
relations
instantiations
horn
fff
splits
demonstrates
propagated
subgoal
terminates
derivation
cyclic
closure
naive
plans
threshold
ldl
000
sg
examined
finite
passed
facilitates
ff
answers
transformation
nx
attribute
ratio
evaluator
databases
iterative
shares
iteration
constants
gamma
efficiently
tuples
arguments
executes
intensive
unification
selectivity
examine
confined
expanded
transformed
computability
highly
cross
simon
forms
head
instantiate
constructors
shared
connected
monotonicity
nonfinitely
lex
bfb
nqueens
thetaff
gammaisort
fnolist
terminable
aditi
aaai
chain split
split evaluation
chain generating
generating path
the buffered
the chain
the evaluation
chain recursion
finitely evaluable
binding propagation
a chain
evaluation should
magic sets
the exit
query evaluation
exit portion
linear recursion
evaluation of
buffered portion
buffered chain
n chain
the binding
chain following
based chain
finite evaluability
y s
bbf x
buffered values
exit rule
rule set
recursive rule
cons x
that chain
functional predicate
evaluation techniques
single chain
the recursion
partial evaluation
evaluation technique
the query
the join
same country
logic programs
expansion ratio
efficiency based
cons ffb
cons bbf
nested linear
merged parents
join expansion
linear recursions
a compiled
recursion is
the compiled
partition bbff
bf x
y zs
append u
linearly recursive
compiled chain
be performed
rule 4
two portions
function free
the adorned
not finitely
a recursion
portion and
being evaluated
of recursions
query constraints
propagation rules
insert bbf
cons cons
ffb x
1 zs
nonlinear recursions
chain level
multi chain
deduction level
on chain
finiteness constraint
chain recursions
infinitely evaluable
deductive database
the magic
evaluation is
a query
the rule
the body
buffered and
in deductive
adorned with
recursive query
compiled form
x parent
evaluation plan
of chain
y y
the finiteness
portion the
predicates in
evaluation in
functional recursions
finiteness constraints
parent bf
recursion input
connected predicates
split partial
same deduction
xxs y
compiled functional
chain predicate
level finite
functional predicates
which derives
query gamma
zs cons
xs xxs
query binding
finiteness based
gamma append
split is
of predicates
is finitely
query analysis
deductive databases
of connected
compiled into
evaluated first
intermediate relations
ff w
of buffered
portions in
chain is
a functional
algorithm 2
rule is
predicate is
body of
a predicate
the departure
evaluation efficiency
functional recursion
zs y
evaluated portion
rectified into
parent fb
bb y
highly selective
fb y
2 chain
finite evaluation
evaluable portion
level idb
edb predicate
a finiteness
y xls
split magic
an edb
following evaluation
departure end
construction function
u predicate
nonlinear recursion
hx y
evaluation may
regular chain
sub chain
b portion
functional single
qsort bf
merged cons
isort bf
the logicbase
chain based
sets evaluation
recursive predicate
the merged
x xs
be evaluated
x 1
is finite
efficient query
should be
be compiled
based query
into two
s y
an n
evaluability of
evaluable predicates
possibly some
chain forms
semi naive
highly regular
list construction
the normalized
cross product
of query
chain split evaluation
chain generating path
the evaluation of
in the evaluation
evaluation should be
split evaluation should
the exit portion
a chain generating
the chain split
the binding propagation
based chain split
buffered chain split
should be performed
the chain generating
the buffered portion
n chain recursion
that chain split
single chain recursion
an n chain
split evaluation is
the exit rule
join expansion ratio
not finitely evaluable
efficiency based chain
the join expansion
the buffered chain
of the exit
into two portions
chain split is
in the chain
evaluation of the
a recursion is
is finitely evaluable
bbf x y
cons ffb x
after the evaluation
adorned with b
y s y
cons bbf x
y y s
the rule set
evaluation of a
predicates in the
in the body
in deductive databases
the body of
is not finitely
body of the
level finite evaluability
the buffered values
the same deduction
split partial evaluation
chain level finite
two portions in
chain split partial
split evaluation techniques
finiteness based chain
the compiled form
insert bbf x
same deduction level
of chain split
parent bf x
a chain split
x xs xxs
should be split
be performed on
in the compiled
y y 1
portions in the
recursive query evaluation
split evaluation in
query evaluation technique
the magic sets
be compiled into
split into two
one or a
a single chain
or a set
split magic sets
the query binding
functional single chain
evaluation technique for
s y zs
being evaluated portion
bf x parent
of buffered values
chain split and
a nonlinear recursion
split evaluation of
nested linear recursions
parent fb y
a compiled functional
of the buffered
chain recursion input
an edb predicate
set of connected
list construction function
generating path is
append u v
cons x 1
evaluated first and
finite evaluability of
query evaluation plan
compiled functional single
a functional predicate
semi naive evaluation
binding propagation rules
the departure end
threshold the binding
hx y i
query is finitely
rule set f
based on chain
chain split magic
the chain following
demonstrates that chain
exit portion the
the u predicate
fb y y
the finite evaluability
ffb x xs
magic sets evaluation
ffl the evaluation
efficient query evaluation
performed on the
of a chain
example 1 2
algorithm 2 1
should be applied
at the departure
in the adorned
exit rule is
in the normalized
a function free
if the chain
on the chain
and possibly some
shown in 1
v a b
of logic programs
evaluation is a
recursion can be
every variable in
be performed if
the chain is
set of predicates
a set of
can be performed
of the chain
in the processing
evaluation can be
proceeds as follows
based on the
evaluation in the
the cross product
kinds of recursions
linearly recursive rule
by chain split
level idb predicates
chain split should
the functional predicate
x bb y
the being evaluated
a linear recursion
query binding propagation
nested linearly recursive
evaluation of query
in the recursion
chain following threshold
partition bbff xxs
immediately evaluable portion
evaluation on the
query constraints and
the w predicate
x parent fb
of connected predicates
zs y s
expansion ratio is
the compiled chain
the finiteness bindings
parent i x
into two subchains
lower level idb
predicate cons x
same generation relatives
detailed quantitative analysis
2 chain split
query evaluation plans
function free linear
query instantiation information
littles ls qsort
is the join
splits a chain
highly regular chain
split evaluation may
recursion at each
rules a recursion
functional predicate for
the instantiated values
y i pairs

corpus/krapavin2000-test/627662.txt
neuron
automaton
recurrent
learning
latching
phoneme
speech
subnet
numa
neural
neurons
word
recognition
nk
nets
connectionist
inumano
lexicons
iwr
conceived
nl
weights
automata
fsa
net
discrimination
nasals
codification
vowels
transition
equilibrium
italian
phonetic
injected
rules
uncertain
duration
isolated
transient
dictionary
intelligent
nw
explicit
network
tabula
rasa
minima
mentioning
spherical
coding
lexicon
subnets
nondeterministic
activation
repetitions
priori
latched
acoustic
fed
networks
fig
boolean
integrating
perceptual
learned
weight
devoted
cooperating
connections
stability
feedforward
perceptron
speaker
backpropagation
mainly
switching
realization
composed
hyperplanes
paradigm
chain
layered
giles
unified
discovering
inspecting
5b
221
cascade
status
symbolic
string
worth
discover
sphere
classifiers
quantization
remember
trajectory
gradient
supervised
inputs
4796363
nnuuummaaa
nnmnuumummaaa
foggia
telex
thatf
4796265
unfing
suchthatji
ct01
vento
bps
sistemi
codifications
pearlmutter
firenze
zation
genna
cleeremans
sandiway
i2no
degeneration
01530
580681
descent
symbol
trajectories
iv
initialized
basically
automatic
transitions
outputs
refinement
equations
tasks
integration
relieved
dipartimento
resurgence
berthold
immanent
deltav
gammaw
nervous
063
informatica
tacitly
ji
preliminary
relying
henceforth
considerations
lyapunov
493
quanti
inject
omlin
pasquale
arisen
coded
accomplished
hidden
adopted
fong
latches
tel
1897
perceptrons
fax
emulating
resentation
grammatical
1929
eq
permits
murst
kremer
tio
elman
skips
637
feeding
universit
conveyed
hammer
realized
stable
284
188
gammai
cnr
008
6a
spatiotemporal
176
hypotheses
configurations
learning by
by example
explicit knowledge
w ii
automaton rules
neuron i
word numa
the automaton
speech recognition
automatic speech
information latching
recurrent networks
proposed model
isolated word
word recognition
i i
i r
in recurrent
recurrent network
the word
example paradigm
connectionist models
of learning
full connected
uncertain information
and learning
for integrating
the learning
the weights
i t
state transition
neural networks
equations 12
of neuron
ii 2
explicit rules
weight space
recurrent neural
knowledge and
x b
each neuron
large lexicons
chain like
latching occurs
high transition
the latching
transient duration
numa when
integrating explicit
automaton states
conceived for
intelligent behavior
first subnet
numa the
of automatic
a i
the words
low to
input i
the network
problems of
boolean state
nondeterministic automaton
priori knowledge
mentioning that
equilibrium point
nw i
worth mentioning
is mainly
the weight
linear programming
the explicit
the neuron
multi layered
w i
local minima
of isolated
the recurrent
for speech
k l
learning algorithm
the proposed
injected into
composed of
stability of
rules can
the input
transition in
the dictionary
the transient
r i
connections of
the subnet
example approach
neural realization
latching condition
on presentation
generic neuron
switching rules
italian word
iwr in
perceptual tasks
network 1
nk and
rule representation
learning scheme
the lexicon
neuron switching
speech pattern
conceived as
connected recurrent
word inumano
any intelligent
of vowels
cooperating subnets
like nets
ordinary gradient
s neurons
duration l
curve f
and nasals
for iwr
neuron input
was devoted
subnet nk
feedforward nets
and learned
from tabula
continuous signal
up very
vowels and
speaker independent
a phoneme
word prediction
neuron receives
nets nw
tabula rasa
phoneme outputs
automaton 19
two cooperating
codification of
learning sequences
fsa the
fig 5b
only composed
to high
n p
unified approach
on learning
for problems
their application
us consider
state transitions
in nk
fed with
mainly responsible
activation a
hypothesis w
39 55
when fed
transition occurs
local feedback
feedback multi
for feedforward
net n
phase any
these words
nl s
and nl
equilibrium points
such automaton
the fsa
learning from
rule r
devoted to
4 13
of steps
least for
the activation
a learning
let us
second statement
discrimination between
input information
criterion was
with recurrent
input line
ji i
layered networks
first factor
the discrimination
unlike many
network inputs
lee giles
in connectionist
network composed
iii which
learned rules
when increasing
is worth
learning by example
knowledge and learning
automatic speech recognition
the proposed model
of automatic speech
the word numa
explicit knowledge and
isolated word recognition
by example paradigm
and learning by
i i r
w ii 2
a full connected
the learning by
x b i
problems of automatic
the automaton rules
example in recurrent
by example in
low to high
in recurrent networks
the weight space
state transition in
4 13 17
integrating explicit knowledge
the explicit knowledge
for problems of
word numa when
approach for integrating
of isolated word
for integrating explicit
to high transition
the first subnet
connections of a
recurrent neural networks
worth mentioning that
is worth mentioning
the recurrent network
neuron i the
with the word
of local minima
unified approach for
a i t
injected into the
their application to
r i i
which were not
a state transition
number of steps
let us consider
a nondeterministic automaton
b i t
increasing the lexicon
nl s neurons
well when increasing
feedback multi layered
when increasing the
on learning by
the curve f
of explicit knowledge
an intelligent behavior
word numa the
speech recognition in
b the network
of learning sequences
to large lexicons
explicit and learned
automaton rules can
transient duration l
multi layered networks
in connectionist models
the italian word
least for feedforward
two cooperating subnets
ii 2 it
for feedforward nets
curve f a
into the connections
on presentation of
nk and nl
by example approach
section iii which
the neural realization
the transient duration
example paradigm for
neuron switching rules
full connected recurrent
of w ii
vowels and nasals
ordinary gradient descent
with learning by
models the word
neural networks ieee
the hypothesis w
the latching condition
nondeterministic automaton 19
only composed of
automaton rules are
framework of linear
between these words
neuron input i
a phoneme outputs
learning by examples
the automaton states
each neuron i
hypothesis w ii
local feedback multi
net n p
the word inumano
up very well
a continuous signal
refinement process and
composed of vowels
conceived as a
how such automaton
chain like nets
in problems of
recurrent network 1
nets nw i
presentation of examples
input i i
generic neuron i
was devoted to
practice we want
state of neuron
boolean state of
of vowels and
numa when fed
italian word numa
from tabula rasa
the input line
phoneme outputs for
information latching occurs
discrimination between these
devoted to detect
vector of weights
of information latching
codification of the
uncertain information the
state transition occurs
when fed with
i r i
because of the
the stability of
it is worth
if i i
for each neuron
that the explicit
theorem 1 s
f a i
likely to scale
proposed model is
network which models
fed with the
the input information
first factor is
is mainly responsible
is quite difficult
integration of explicit
section v the
a refinement process
preliminary results for
network composed of
for the word
the connections of
therefore a i
likely to fail
of linear programming
has the task
presence of local
rely on learning
the other words
the more the
at least for
similar proof can
very well when
used for modeling
of the neurons
a because of
c lee giles
with recurrent neural
in recurrent neural
b i r
of neuron i
a recurrent network
for modeling the
the first factor
the k l
rules can be
in order to
in the framework
in section iii
test based on
outputs for the
in the weight
were not included
on the weights
as a refinement
to scale up
i t of

corpus/krapavin2000-test/627680.txt
magic
auxiliary
ff
pasttl
fol
sql
evaluable
formula
dbms
temporal
allgen
starburst
formulas
integrity
9x
fv
ranf
subformulas
commit
ingres
atoms
atom
subformula
toman
chomicki
relational
database
conversion
tables
rematerialization
tl2fol
simplified
transition
constraint
sideways
polyadic
rules
algebra
converted
enforcement
active
transaction
delete
rule
create
relations
rematerialized
insert
precedes
connective
oe
contents
convert
attribs
fol2sql
transformation
approx
quantifier
translation
safe
dml
fi
attributes
history
logic
agrees
quantifiers
tinserted
ralg2sql
sips
tdeleted
old
triggered
generator
compiler
inserted
specification
enforce
occurrence
conjuncts
traverse
transformations
employee
constraints
flow
rollback
disjunctions
language
compilation
leaf
salary
mula
3t
past
module
3b
disjunction
occurrences
views
passed
rejected
ffl
constructors
leaves
tuples
negation
optimizations
implementing
docommit
readmitted
fol2ralg
annotated
syntax
materialized
converts
converting
constructor
committing
superscripts
updated
update
reformulations
vi
preserve
statements
checking
top
induction
eval
monitor
3p
adornments
deleted
aborted
ordering
false
algebraic
4t
cleanup
triggers
queries
sub
conjunctions
connectives
arity
execute
clause
restrictions
restricting
inductive
truth
union
overhead
body
rela
conjunction
maintained
optimization
architecture
saving
referenced
gen
references
careful
negations
databases
del
triggering
anomaly
stored
null
she
join
benchmarking
unsafe
i2i
languages
modules
safely
clauses
outcome
ideal
select
tods
query
schema
encoding
5a
violations
contexts
referring
violate
guard
declare
attribute
subsystems
arrangement
agreement
maintain
propagate
r ff
magic condition
auxiliary relations
the magic
the auxiliary
auxiliary relation
active dbms
create rule
simplified formula
level constraint
relational algebra
fol formula
temporal integrity
to sql
integrity constraints
9x a
the database
to relational
top level
t sub
insert into
transition tables
the formula
a magic
fol formulas
magic conditions
the rule
t add
m r
auxiliary atoms
rule generator
pasttl formula
allgen property
subformulas of
a fol
the allgen
transition information
implementing temporal
delete from
the rules
temporal constraints
formula to
is evaluable
chomicki and
auxiliary atom
active rules
constraints using
the constraint
the evaluable
rule systems
select from
ff be
condition for
the fv
set transformation
rematerialization of
toman implementing
evaluable property
and toman
execute procedure
sql statements
a formula
flow of
table t
original formula
of r
ff 1
converted to
formula is
of temporal
algorithm 25
the transition
ff is
r fi
the constraints
ff 2
algebra normal
create procedure
the tl2fol
auxiliary tables
temporal logic
the simplified
magic set
the flow
the top
an auxiliary
relation r
rule system
subformula of
specification language
for r
contents of
the starburst
fv a
when inserted
create table
state n
the quantifier
the sql
formula and
into r
free variables
optimization techniques
an active
constraint checking
on commit
fv 0
when commit
pasttl formulas
old t
auxiliary transition
ff false
overall magic
of pasttl
corollary 29
of fol
tables are
the temporal
the contents
ff the
atom r
input formula
constraint enforcement
temporal constraint
ff in
leaf of
the conversion
state of
fv and
update r
occurrence of
constraint specification
the pasttl
procedure c
original pasttl
evaluation property
additional auxiliary
safe evaluation
precedes c
attributes create
inserted then
pasttl the
passed sideways
0 sets
dbms itself
t execute
past temporal
to fol
conversion to
rule c
atoms are
formulas the
be passed
of active
this transformation
translation of
constraints is
the table
the fol
agrees with
starburst and
and fv
allows easy
rule ff
relations are
true in
of time
from t
a simplified
is converted
normal form
formula we
the integrity
rule language
algorithm 16
a subformula
space overhead
conversion of
formula f
with temporal
induction on
the dbms
given formula
formula this
commit then
formula i
of auxiliary
rules that
on t
ff we
the formulas
the leaves
the future
first order
free in
ff oe
general architecture
0 ff
structure of
constraint c
of r ff
the auxiliary relations
magic condition for
of the auxiliary
top level constraint
m r ff
the magic condition
flow of time
temporal integrity constraints
to relational algebra
for r ff
of the database
the top level
r ff is
with the flow
the transition information
an active dbms
integrity constraints using
implementing temporal integrity
occurrence of r
a fol formula
a magic condition
r ff 1
the allgen property
r ff be
condition for r
using an active
constraints using an
insert into r
an auxiliary relation
auxiliary relation r
r ff 2
r ff the
the flow of
of the formula
r ff in
toman implementing temporal
auxiliary relations are
chomicki and toman
subformulas of the
the auxiliary relation
magic set transformation
the rule generator
the evaluable property
and toman implementing
the magic conditions
into r ff
the original formula
relation r ff
the constraint checking
algebra normal form
relational algebra normal
rematerialization of the
a simplified formula
of the rule
be a formula
the contents of
true in d
of fol formulas
overall magic condition
the simplified formula
atom r ff
the state n
the auxiliary tables
auxiliary transition tables
converted to relational
create rule c
occurrences of r
r ff we
delete from r
from r ff
update r ff
we need to
can be passed
the input formula
agrees with the
contents of the
the magic set
set of active
let r ff
insert into t
on t execute
t execute procedure
r 0 ff
create rule ff
0 ff false
formula i e
be a fol
formula to a
level constraint is
and fv 0
delete from t
when inserted then
fv 0 sets
magic conditions for
the overall magic
the original pasttl
safe evaluation property
and r ff
the fv and
create table t
when commit then
the auxiliary atoms
fv and fv
state of the
of the original
by induction on
a leaf of
n a o
relational algebra and
transition tables are
the rule system
by the dbms
of active rules
is true in
previous state of
as a leaf
of the constraints
structure of the
the previous state
history of the
induction on the
the conversion of
ff be the
that the magic
t on t
level constraint c
be a simplified
auxiliary atom r
ff 2 insert
and corollary 29
preserve the simplified
inserted then delete
an equivalent simplified
by the tl2fol
the dbms itself
a o and
that maintain the
r ff this
past temporal logic
x c g
after insert on
transition information is
auxiliary relations to
the simplified property
relations r ff
2 insert into
fol formula and
has the allgen
o and e
to r ff
of the rematerialization
the rematerialization of
r fi for
is not evaluable
from t add
of temporal constraints
tables r ff
r ff for
the fol formulas
maintain the contents
active dbms the
t add and
on commit execute
commit then update
the auxiliary atom
original pasttl formula
and t sub
formula to relational
and eventually to
add and t
the constraint specification
commit when inserted
active dbms rules
select from t
the fv set
attribs create rule
commit execute procedure
top level fol
constraint specification language
the fol2sql module
a subformula of
r ff let
from t sub
restrict the contents
c create rule
then update r
formula is converted
of m r
a since b
relations are introduced
auxiliary relations r
set of fol
then rollback work
propagate the allgen
magic condition is
auxiliary tables r
auxiliary relations introduced
of a fol
the active dbms

corpus/krapavin2000-test/627693.txt
critics
kbds
critic
designs
ds
cables
joints
pillar
cable
critiquing
experts
polygon
sa
intersections
expert
redesign
worstparts
engineers
telephone
district
designjoint
tutoring
expertise
od
acquisition
kbdss
critique
consistency
diff
acquiring
street
intersection
redesigns
systemdesign
pits
adequacy
heuristics
sys
streets
engineer
houses
furthest
inconsistent
kb
routes
setinitial
correctnesscheck
incorrectness
incorrect
human
polygons
uphill
reorganize
subjectivity
inconsistency
inter
correctness
requests
misconceptions
pipes
facts
judgment
joint
costs
completion
telecommunications
automatic
consistencycheck
workability
updateod
choosepoly
expertexamine
modifykb
underground
design1
dendral
assignjoint
numofdesign
refining
manually
pipe
resets
connect
codify
network
heuristic
refine
errors
manual
critiques
suggest
118
assist
annealing
intensive
null
elicit
laying
assisting
opinion
service
responsible
proper
optimum
wrong
insert
optima
enrich
unsatisfied
clues
served
building
examination
inference
reset
checking
fischer
contextual
house
theories
employed
lay
crossings
closest
away
base
provision
missing
intelligent
examines
rules
decision
designers
suggested
bring
subjective
alternative
verification
try
methodologies
beforehand
critical
usable
tries
modify
graphically
robin
temperature
finds
customers
meanings
missed
costly
allocates
grey
satisficing
leastod
generatedesign
mastered
nurtured
assigncable
consultation
objectivity
abstractexpert
iscs
scrutinize
reporterror
calculateod
d118
objectively
fdesign1g
design2
cadastre
liuh
codifying
furthestinter
tutors
fdesign2g
autoredesign
alternatives
minima
boundary
located
systematically
suggestions
engineering
calculates
impractical
computationally
terminated
0511
downhill
equipping
unserved
taper
pragmatically
10e
parks
complaints
hereby
a kbds
critics are
the pillar
of critics
a design
these critics
knowledge based
knowledge engineers
a knowledge
critic is
design system
knowledge base
the kbds
the critics
the knowledge
knowledge acquisition
domain theory
ds is
d t
of joints
kbds is
network design
engineering design
expertise completion
s incorrect
critics is
solution critic
of ds
decision points
problem description
alternative solution
critics in
s inconsistent
the cable
kbds and
sys p
a district
completion critic
proper knowledge
an intersection
based design
of designs
consistency checking
the designs
in algorithm
cost function
by experts
knowledge engineer
of knowledge
automatic redesign
independent system
designs produced
the critic
a critic
by ds
tutoring systems
ds s
two critics
knowledge is
a domain
cable network
a cable
service requests
and consistency
a polygon
correctness and
sufficient knowledge
intelligent tutoring
adequacy problem
knowledge used
to critique
expert critics
good designs
pillar is
in critiquing
designs generated
cables are
systemdesign sys
critics have
telecommunications network
four problems
incorrect and
design generation
furthest away
of cables
new design
figure a
design in
the design
by human
alternative designs
and sa
system construction
insert figure
experts and
strong model
acquisition and
domain experts
design is
algorithm 5
j c
design problem
human experts
all inter
design d
for ds
knowledge for
the adequacy
designs and
building and
design b
designs with
p do
the alternative
in knowledge
a joint
sa is
designs by
experts are
cable routes
or inconsistency
few known
critics the
checking critics
critics can
ds generates
telephone network
known cases
ds p
kbds produces
kbds in
design experts
various designs
cables and
od s
optimal parts
the expertise
kbds to
1 acquiring
ds does
produce designs
cable sizes
in design
designs are
designs a
t j
a cost
designs the
in building
the heuristics
experts in
applying knowledge
way intersection
in ds
polygon has
critical decision
better design
problem descriptions
in telephone
designs can
based engineering
test cases
algorithm 4
of design
design can
heuristics used
intersections and
and joints
ds and
strategies at
based systems
inference rules
an independent
domain theories
to knowledge
an expert
the system
sub optimal
automatic and
the domain
for knowledge
routes are
computationally intensive
facts and
theories and
parts of
knowledge and
each p
the intersections
that implement
knowledge in
the polygon
a system
time constraint
intersection grey
this critic
worstparts a
engineers to
incorrectness or
kbds for
knowledge based design
of a design
alternative solution critic
correctness and consistency
number of joints
t j c
the domain theory
set of critics
in figure a
expertise completion critic
a problem description
the knowledge base
and consistency checking
a kbds is
a knowledge engineer
the alternative solution
of critics is
to the pillar
a domain theory
of these critics
in knowledge acquisition
version of ds
designs produced by
from the pillar
a knowledge based
in algorithm 5
a knowledge base
telecommunications network design
based design system
use of critics
by human experts
by a kbds
of a district
a strong model
designs generated by
of a kbds
2 p do
systemdesign sys p
knowledge acquisition and
at an intersection
the adequacy problem
each p 2
in d t
completion critic is
a few known
kbds is a
the critics are
a design can
two critics are
the critics in
the pillar is
a design is
incorrect and s
critics are used
s incorrect and
proper knowledge to
in building and
the expertise completion
furthest away from
on a cost
critics have been
and s inconsistent
the cable network
strategies at the
used in critiquing
consistency checking critics
a better design
designs can be
ds does not
sub optimal parts
for a kbds
intelligent tutoring systems
the kbds and
based engineering design
critical decision points
an independent system
domain theories and
knowledge based engineering
knowledge based systems
for each p
p 2 p
algorithms that implement
design can be
a cost function
the knowledge in
the time constraint
a new design
design is a
knowledge base of
for knowledge based
of the design
of t j
d d and
minimum number of
number of cases
away from the
knowledge engineers to
resets the strategy
if we manually
fischer et al
in a district
apply sys p
of critics should
apply ds p
intersection grey one
inconsistent systemdesign sys
alternative solution critics
a desirable system
the kbds produces
consistencycheck d t
building and applying
correct and consistent
kbds called ds
polygon has some
assist 1 acquiring
knowledge used in
previous polygon has
few known cases
sys p is
sufficient knowledge for
every service request
the proposed critics
kbds is not
necessity of critics
the design problem
to the designs
design will be
or ds does
and reports any
subjectivity in knowledge
least od s
knowledge to generating
a design there
in a design
service request should
in ds is
reorganize and generalize
new design will
checking critics these
implement the critics
generates the design
along the streets
chooses an intersection
middle intersection grey
strong model is
critics should be
a kbds to
produce designs with
the critic uses
design system is
for all inter
a design d
knowledge for a
these critics have
way intersection od
this critic is
rules in t
the designs generated
design system the
t or ds
the four problems
cables at an
acquiring sufficient knowledge
theories and problem
knowledge base modification
reports any errors
by critiquing designs
the least od
knowledge engineer reorganize
1 acquiring sufficient
based design systems
lay cables at
these two critics
help a knowledge
of the critics
to lay cables
system and 2
desirable system and
telephone cable network
improve ds s
incorrectness or inconsistency
service requests are
errors to s
not produce designs
and applying knowledge
any new design
all routes in
a design system
by experts in
to reset some
survey of expert
a kbds and
base of a
towards the pillar
some strategies at
and problem descriptions
the sub optimal
ds is that
a design and
modifykb kb diff

corpus/krapavin2000-test/627698.txt
hypernode
hypernodes
hd
hnql
digraph
computable
database
hypertext
arc
hfds
passenger
compound
label
digraphs
fds
ao
labels
pass3
hag
pass1
passengers
isomorphism
null
relational
updates
exe
gare79
buck90
niel90
ullm88
hfd
update
operators
defining
genericity
fig
strings
axiom
attributes
for_predicate
abit90
pass2
graphlog
arcs
attribute
integrity
h2
isomorphic
query
r4
att
databases
sound
airline
levene
referential
primitive
hags
leve90
airlines
pare89
pap1
lvalue
leve92
deterministic
declarative
member
id
determinism
dependencies
hypersets
r6
cond
turing
returned
text
bridge
title
flies
returns
statement
ex
h1
se
anchor
herein
ea121
rvalue
conk87
pass4
ldm
pass5
vang88
insert_node
pfds
ullm91
codd79
thom86
kim90
abit89
vard88
acze88
chan80
ba212
incident
atomic
prim
h3
modelling
hyper
london
encapsulated
r1
loop
out1
adj
dbmss
formalism
expressive
nested
te
firstly
semantics
cater
flying
utilise
seat
comprising
untyped
encode
ea
walks
entities
x1
querying
elimination
inferences
flight
g3
facilities
browsing
object
enhanced
inference
identifiers
expressiveness
destination
generic
uppercase
prog
gap
lien82
delete_node
out3
ise
chan88
gyss90
poul92
naqv89
dero89
barw91
for_all
wc1e
wedd92
formalising
browsed
ucl
codd70
formalisms
formalise
letter
entity
reservation
looping
functional
e1
ba
av
language
copies
referenced
e3
poulovassilis
alexandra
node
e2
college
det
termed
schemas
domains
bases
loizou
journals
adjacent
locally
textual
asserts
readers
copy
the hypernode
hypernode model
based data
computable updates
data models
a hypernode
defining label
graph based
of hnql
e hd
deterministic operators
computable update
hd and
hypernode database
compound statement
database hd
set based
ao computable
hypernodes in
of hypernodes
in hnql
a digraph
relational model
the database
in hd
hypernodes are
primitive nodes
the digraph
non deterministic
data model
hnql program
f a
the arc
in fig
label g
hd is
update language
strings beginning
digraph of
the hypernodes
hag of
defining labels
two hypernodes
hypernode with
axiom system
the defining
whose defining
the hag
hypertext database
null is
locally isomorphic
generic computable
that ex
an arc
of hd
of attributes
copy elimination
by strings
we note
the compound
is returned
hypernode in
returned returns
att hd
hypernode is
otherwise null
n e
a computable
atomic values
assumption a
the relational
returns an
member s
between graph
while loop
a b
a database
for hfds
system comprising
declarative querying
arc dependent
hypernodes can
of digraphs
labels hd
turing computable
passenger hypernodes
computable mapping
hypernode databases
hypernode whose
hnql we
hd we
is sound
and update
current state
label is
query and
the expressive
beginning with
statement is
computing t
data modelling
the passenger
incident with
a hypertext
the said
with defining
section ii
we observe
an arbitrary
of p
non determinism
nested relational
bridge the
node set
choice of
expressive power
hnql s
arbitrary member
database satisfying
of pass1
enhanced database
hypernodes which
genericity requirement
condition h1
of hfds
digraphs of
hypernode defined
of hypernode
hd returns
prim hd
hd a
an hnql
that exe
value null
hd be
the genericity
hd the
hnql is
name dependent
order computable
object identifiers
arc set
g log
to bridge
for loop
a label
side effect
of relationship
isomorphism of
object identity
false is
returns true
semantics of
a side
a query
the semantics
are that
we next
of computable
arbitrary order
from databases
database language
operators of
single underlying
ex f
title of
adjacent from
condition h2
basic set
are untyped
fds can
a passenger
an ao
s non
or simply
functional dependencies
if e
observe that
isomorphic to
based and
underlying data
complex objects
a compound
oriented data
arc is
for graph
universal relation
to databases
to labels
query language
the class
databases to
query or
and set
the gap
g 1
updates which
it follows
model to
object oriented
the hypernode model
based data models
graph based data
of the hypernode
non deterministic operators
set based data
e hd and
choice of p
f a b
based data model
in the hypernode
of a hypernode
a hypernode database
returns an arbitrary
query and update
strings beginning with
the hypernode with
compound statement is
a computable update
if e hd
and update language
hd and v
ao computable updates
we note that
the database hd
the digraph of
based and set
the compound statement
null is returned
the hag of
graph based and
and set based
defining label is
whose defining label
the relational model
shown in fig
if f a
between graph based
operators of hnql
hypernodes in hd
hypernode model to
gap between graph
is returned returns
state of hd
for the hypernode
locally isomorphic to
current state of
we observe that
that f a
the defining labels
otherwise null is
power of hnql
deterministic operators of
from databases to
when computing t
digraph of a
hypernode model in
true if e
of computable updates
by strings beginning
hypernode with defining
the defining label
data models in
ao computable update
a compound statement
underlying data structure
generic computable updates
a hypertext database
for graph based
the arc dependent
with defining label
axiom system comprising
the passenger hypernodes
the hypernode whose
hypernode whose defining
turing computable mapping
is a digraph
data models and
the expressive power
the current state
isomorphic to the
a side effect
bridge the gap
as a side
false is returned
data models such
it can easily
set of attributes
in section ii
the semantics of
to bridge the
returns true if
in the database
the class of
easily be verified
expressive power of
and v n
hag of g
the genericity requirement
label g such
from the hypernode
hypernode defined by
the hypernode defined
that ex f
single underlying data
a while loop
simulated in hnql
s non deterministic
the title of
an hnql program
to the hypernode
hnql s non
defining label of
databases to databases
class of hypernode
hypernode database hd
an arbitrary member
defining labels of
system for hfds
returned returns true
arbitrary order computable
of hypernode databases
hypernode model as
an ao computable
other graph based
used when computing
n e is
of member s
on the current
fds can be
query or update
axiom system for
with the defining
of a computable
the arc set
object oriented data
statement is executed
defined by g
the axiom system
the three components
can easily be
the gap between
be verified that
n i e
section ii c
set of operators
three components of
the definition of
and as a
models such as
proof see appendix
be simulated in
sets of attributes
a graph based
it follows that
of the database
follows that f
and v 1
of the arc
hd i e
null from the
simple airline reservation
the hypernode which
semantics of restriction
well founded sets
as the hypernode
and labels to
a database hd
the traditional business
denote pairwise disjoint
a member from
hypernodes can be
strings to strings
general an open
null and the
t from databases
then f a
hnql with respect
a hypernode in
arc dependent null
hd the set
hypernodes in the
a referential relationship
new data models
denoted by strings
the label g
a hypernode e
the node null
member from a
good g log
for isomorphism of
that e hd
side effect is
while changes do
hnql program shown
the create operator
with node set
g 1 maps
declarative querying and
let hd be

corpus/krapavin2000-test/627706.txt
risk
sel
fragment
overspending
query
selectivity
ptu
tuples
ovsp
pts
db
selp
fragments
itr
quota
ff
furnaces
dbms
operator
op
ra
parse
complement
2fsp
estimatedtime
fragmentation
selectivities
fi
qs
queries
costq
availabletime
fsp
operationg
relations
join
subquery
temperatures
monotone
union
selection
risks
overspent
10sec
relational
iteration
nonmonotone
999
aggregate
knapsack
chains
frag
20sec
heuristicchoose
basetime
qm
transformations
operators
200
iterations
150
algebra
attribute
unions
selectfragments
lesstimelowrisk
choosefragment
fop
operand
iterative
variance
constrained
please
np
status
transaction
disjoint
ozsoyoglu
u2u
evaluated
percentage
evaluating
comp
transformation
modification
fif
strata
indexed
projection
preferred
intersection
monotonicity
estimators
selectedrelation
eram
fname
minuend
timeleft
qsg
subq
seconds
succeeding
revise
disk
lists
guidance
revised
relation
subqueries
gultekin
fnumber
interrupt
c2
formulations
heuristic
module
son
scenario
priority
database
stankovic
jjf
iri
001
modified
100
linearly
kyoung
sampling
lattice
costs
thereby
controlling
selected
formula
endwhile
dangerous
file
specifies
estimated
chooses
guides
dictionaries
008
evaluate
listed
0s
endfor
insufficient
evaluations
evaluates
prefers
begin
choosing
expensive
involved
sang
response
estimations
jf
deadlines
management
revision
timer
priori
databases
completed
2nd
kang
variances
critical
tree
rel
page
constants
commands
temperature
formulas
keyword
aggressive
commerce
answers
prototype
chain
deadline
abstractcase
62901
projectcost
9008632
30sec
fstandard
nonaggregate
fsolves
cleveland
responseg
fchooses
relationg
100sec
qiven
lesstimehighrisk
case db
the risk
the fragment
of overspending
of tuples
complement fragment
itr ptu
pts ovsp
tuples selected
ptu pts
sel i
the query
fragment size
selp itr
fragment selection
query evaluation
risk of
time quota
available time
of risk
input tuples
the selectivity
fragment list
time cost
f i
difference operator
ovsp selp
tuples used
risk factor
parse tree
selection problem
selectivity of
query modification
a fragment
ff i
the dbms
fragment lists
relation fragmentation
time constrained
the parse
no of
q f
of sel
operator queries
modification technique
evaluation step
risk is
selected for
the fragments
for processing
modified query
figure effect
natural join
iterative query
a relation
the relation
list f
relational algebra
risk fi
ovsp 3
overspending for
non aggregate
fragmentation chains
constrained query
algebra queries
2fsp ff
involved with
the relations
real time
fragments in
the available
risk on
the selection
of input
in case
critical status
operationg estimatedtime
join operator
single operator
table effect
risk 100
200 selp
multi operator
second attribute
fragment risk
in complement
fi op
ff gamma
tuples in
query q
effect of
operator op
set difference
input relations
expected time
the time
f j
i op
disjoint union
ff 2
selection operator
ra query
sel 1
query is
increase in
each relation
100 150
a risk
cost formula
an operator
required fragment
relation involved
risk taken
output tuples
complement fragments
used time
risk ff
fragment sizes
fragment f
monotone queries
time 10sec
3 sel
an increase
1 knapsack
gamma ff
of time
of case
in q
relation r
a query
of selectivity
query with
union operation
relation if
please note
transformations for
time costs
evaluation time
an ra
operator the
o p
the percentage
time constraint
np complete
the complement
the evaluation
20sec table
or involved
aggregate relational
aggregate queries
status furnaces
ff risk
relation based
risk 5
q previous
time 20sec
basetime and
200 tuples
overspending in
the subquery
to 2fsp
user dbms
operation no
risk given
risk value
time left
furnaces and
risk control
operator query
overspending the
case basetime
given risk
knapsack problem
of fragments
the expected
150 200
ff ff
first iteration
evaluated with
step i
operator in
the user
u 0
percentage of
q 0
increase the
modified versions
op in
risk to
output size
step s
of q
th step
time on
single user
operator with
heuristic approach
second iteration
module which
are constants
ptu pts ovsp
itr ptu pts
risk of overspending
of tuples selected
in case db
selp itr ptu
number of tuples
the risk of
the time cost
tuples selected for
fragment selection problem
the available time
fragment size of
effect of risk
the fragment selection
ovsp selp itr
of input tuples
pts ovsp selp
the parse tree
the time quota
the fragment size
the selectivity of
percentage of tuples
complement fragment size
selected for processing
for the risk
query modification technique
query evaluation step
increase the fragment
no of input
in the parse
figure effect of
effect of time
a fragment list
iterative query evaluation
input tuples used
of tuples in
pts ovsp 3
relational algebra queries
and the risk
the risk fi
sel i op
of risk on
the risk is
of case db
list f i
a time constrained
the complement fragment
fragment list f
when the risk
time constrained query
the expected time
of the query
with an increase
of time on
relation if it
ff gamma ff
available time is
no of tuples
in complement fragment
of overspending for
tuples in complement
risk 100 150
relation fragmentation chains
fragment risk 100
selectivity of an
the relation fragmentation
tuples used in
table effect of
200 selp itr
of sel i
150 200 selp
time cost formula
the modified query
complement fragment risk
of a relation
a relation if
on a single
tuples used time
the risk taken
the risk ff
3 sel 1
the second attribute
ovsp 3 sel
set difference operator
the query modification
the difference operator
risk of 7
time figure effect
in the fragment
increase in the
the number of
time on a
0 1 knapsack
the percentage of
used in the
q f i
the selection operator
an increase in
please note that
selected for the
the relations are
for the relation
100 150 200
selectivity of the
1 knapsack problem
the output size
of the relation
the first iteration
risk ff i
relation based on
used time figure
for the fragment
the given risk
of tuples used
or involved with
priority and critical
evaluate the query
q 0 s
case db the
fragments in the
risk on single
and critical status
risk taken is
relation involved in
and ff gamma
risk to be
choosing a relation
multi operator queries
critical status furnaces
operation no of
the required fragment
basetime and fi
single operator queries
time 20sec table
to 2fsp ff
from table 5
of output tuples
the ff risk
a complement fragment
20sec table effect
risk given by
performance of case
case basetime and
a relation based
f j r
available time increases
at step i
time cost of
the selection of
f i with
in the query
at the i
and fi 1
high priority and
within the available
e i 1
when q is
query is evaluated
of an operator
the query with
the second iteration
i th step
the query q
amount of time
the current step
number of output
the query evaluation
ff and ff
be seen that
that the query
we increase the
real time databases
for choosing a
lower in the
number of iterations
natural join operator
single user dbms
of finding f
the dbms in
difference operator in
operationg estimatedtime case
case db is
each operator op
overspending did not
the fragments in
lists in x
iteration where overspending
all the relations
the fragment list
seen that with
parse tree or
queries in case
for processing increases
each f j
output relations of
fi 1 case
tuples no of
of selectivity on
an ra query

corpus/krapavin2000-test/627715.txt
inconsistency
esr
sr
cesr
import
query
serializability
ets
transaction
preconditions
imported
precondition
read
2committed
cut
item
export
serializable
epsilon
sdb
queries
tp
monotonic
commit
update
limit
committed
updates
consistency
serialization
concurrency
aborts
conflicts
database
accounts
000
balance
limits
history
steady
acta
escrow
acc
inconsistent
unilateral
conflict
safe
classic
begin
aborted
items
concurrently
monotonically
orderings
metric
tight
imposed
progress
optimistic
banking
begins
writes
interval
uncommitted
molina
ffl
percolate
byproducts
chrysanthis
debited
wiederhold
reads
maintain
lock
garcia
spaces
triangle
savings
inequality
4999
pessimism
tei
qsr
sagas
980
lok
invoked
distance
management
kuo
expressions
70
quasi
atomicity
invariant
variation
dollars
credited
locks
bank
write
asynchronous
demarcation
deposits
correctness
divergence
imports
transactions
inconsistencies
violate
compensating
semantics
events
lie
executions
exported
wolfe
tighter
iff
money
interdependent
protocol
concurrent
reservation
010
derivation
et
autonomy
designer
invariants
relaxed
cycles
lend
imposes
maintained
produced
checking
exceeded
max
histories
asynchronously
millions
bounds
informally
215
induced
begun
wei
consistent
predicate
prabhu
lyman
abstractepsilon
fcurrent
shavit
aloysius
tamma
yunsheng
debit
deltaf
evaggelia
depeng
serlialized
totok
saga
deltaj
896
percolates
touitou
pitoura
polarized
wlca
speegle
lagging
indexeddata
obliterated
pamela
juen
old
preventing
taxonomy
philip
final
barbara
tolerate
brevity
maintaining
intervals
null
avoided
execute
intersects
characterization
account
databases
bounded
violates
5000
saw
korth
cut q
the inconsistency
c sr
import limit
result inconsistency
a query
q x
inconsistency in
change t
of inconsistency
limit q
data item
query et
the query
begin read
t current
t i
read q
update transaction
inconsistency q
x import
t x
read by
final change
2committed cut
for begin
begin write
write t
an update
inconsistency of
esr is
update transactions
current x
following precondition
account balance
current change
query q
epsilon serializability
of esr
imported by
sr and
by esr
update ets
import inconsistency
write interval
i initial
inconsistency imported
update et
bounded variation
in cut
in progress
of x
x read
the preconditions
classic serializability
x current
initial initial
query ets
inconsistency limit
esr and
imported inconsistency
to esr
q final
import limits
esr in
read interval
data items
of queries
x i
the checking
transactions t
by q
export limit
q initial
x operations
inconsistency that
database state
concurrency control
values read
preconditions on
history h
precondition for
transaction management
item x
inconsistency can
initial is
a cesr
inconsistency x
and cesr
inconsistency when
inconsistency due
conflict based
write intervals
inconsistency bound
tp system
max change
cesr relations
q begins
data inconsistency
et t
inconsistent data
and export
the amount
state space
balance is
the import
transactions in
the precondition
transaction t
ffl 0
f i
viewed by
export inconsistency
ets that
q reads
checking account
amount of
data read
of bounded
x q
i x
5 000
limits are
lock based
monotonic functions
a serializable
the distance
a history
concurrently with
metric spaces
to maintain
metric space
a data
state s
s write
triangle inequality
esr can
inconsistency caused
cesr edge
and 70
et queries
on result
end write
concurrent updates
invariant corresponding
distance u
safe q
input inconsistency
et q
inconsistency limits
monotonic queries
distributed tp
ets may
bounded functions
current account
committed cut
and esr
inconsistency only
stronger invariant
sr relation
under esr
inconsistency bounds
steady functions
in inconsistency
et has
accounts have
each et
sr relationship
inconsistency on
monotonic the
how esr
checking accounts
max inconsistency
unilateral commit
h x
t j
the database
query is
produced by
data values
the history
value of
limit on
its read
the result
query and
distance function
old state
transaction executions
et is
is 70
70 is
item while
sr t
consistent update
large ffl
esr we
application designer
divergence control
of et
amount of inconsistency
inconsistency in the
limit q x
by a query
value of x
import limit q
write t x
the inconsistency in
read q x
inconsistency q x
x import limit
2committed cut q
t i x
begin read q
change t current
the following precondition
change t i
begin write t
final change t
a data item
of a query
a query q
a query et
read by q
current change t
in cut q
on the inconsistency
an update transaction
of the query
the inconsistency of
read by a
precondition for begin
x read by
c sr and
of bounded variation
the c sr
the query et
t current x
account balance is
current x import
for begin write
x q initial
inconsistency imported by
q final change
cut q final
result inconsistency limit
of x read
q x import
the result inconsistency
in the result
data item x
data read by
the amount of
the value of
results of a
sr and cesr
the inconsistency imported
imported by a
of inconsistency in
inconsistency due to
an update et
the checking account
max change t
initial initial initial
import inconsistency q
inconsistency limit q
of inconsistency that
to the inconsistency
inconsistency when it
for begin read
the results of
on the results
of x i
than 5 000
t x j
of the inconsistency
the result of
a query and
the precondition for
transactions t i
the distance between
1 to t
for the amount
q x and
a metric space
the data read
query can lie
an import limit
the import limit
following precondition on
i initial is
and 70 is
the current account
invariant corresponding to
a cesr edge
database state space
transactions in cut
checking account balance
individual data items
q x this
increase in inconsistency
inconsistency in a
a history h
update transaction t
x i initial
current account balance
inconsistency x i
of c sr
t i initial
import limit and
interval with respect
c sr relation
on result inconsistency
t current change
q reads x
its read interval
c sr relationship
committed cut q
inconsistency caused by
large ffl 0
to begin its
of data inconsistency
cut q begins
initial is the
inconsistency that can
its write interval
safe q x
limit on the
types of queries
t 1 to
result of the
distance between the
t i s
viewed by a
to execute concurrently
data item while
if an update
inconsistency of the
the values read
limit t x
are in progress
t i gamma1
can lie between
the old state
and export limit
inconsistency t x
x i read
and the old
definition of esr
read and write
by the query
is in progress
of a data
in the value
new state and
a database state
largest value of
class of queries
respect to x
different types of
of f i
to the c
degrees of consistency
state and the
the query can
the following invariant
the manner in
transaction t i
we derive the
greater than 5
between the new
f i s
query q is
by t i
to t i
manner in which
that a query
value of f
the new state
i and t
the data values
a t i
to maintain the
the data item
a generalization of
the distance function
a query in
on the result
query et sums
q x i
credited the distance
consistent database states
show how esr
x begin read
interval intersects with
et for example
serializability is defined
of classic serializability
practical meaning of
state on disk

corpus/krapavin2000-test/627724.txt
authorizations
authorization
tab
tabext
administrative
inst
derivation
ext
temporal
privilege
administer
instant
revoke
sam
am
csd
instants
ha
tmax
rules
endfor
hobjecti
hsubjecti
sdel
granted
aslongas
dred
friends
hopi
revokee
ptab
insertion
parametric
materialization
grantor
samarati
discretionary
whenevernot
pn
mode
privileges
endcase
hl
bertino
materialized
pierangela
haccess
modei
ins
appearing
deletion
endif
object
denials
matt
interval
jim
hx
lev
intervals
gig
atluri
auth
levels
negation
access
critical
rule
ferrari
request
dependency
elisa
deny
elena
chris
te
tissec
inserted
bob
sins
vijayalakshmi
sandhu
bettini
arity
negative
semantics
ground
ap
operator
logic
o1
ticket
requests
authorized
catalogs
security
deleted
modes
maintenance
recomputing
permissions
revocation
exercise
ti
valid
priority
gammag
sushil
granting
jajodia
xml
delete
grant
dbms
endwhile
symbol
validity
symbols
users
uniqueness
max
ffl
mesiti
2jjohn
mizuho
revokeref
hpastopi
parisi
refi
revoking
hgrant
presicce
autho
xinwen
admi
iwaihara
jaehong
hrevoke
revoker
somchai
silvana
grantadm
revokeadm
chatvichienchai
hopian
chutiporn
anutariya
absence
administration
john
gi
castano
wuwongse
versioned
revoked
vilas
expires
read
ann
interpretation
inferences
subject
relevancy
subrahmanian
securing
avigdor
yorktown
explicit
fn
spans
gal
disjoint
technologies
returned
dependencies
specifying
deductive
updated
capabilities
update
repeat
own
op
affecting
adam
francesco
returns
claudio
stating
false
else
predicate
denial
policies
initialized
60
whom
stratification
00
specification
derivation rules
the authorization
authorizations and
an authorization
inst tab
the authorizations
access control
authorization is
authorization a
temporal authorization
temporal authorizations
t b
instant t
tab u
in inst
privilege on
access mode
and derivation
of authorizations
derivation rule
authorizations in
derived authorizations
authorization model
critical set
t e
b t
the tab
valid authorizations
u ext
csd algorithm
a tab
negative authorizations
time interval
the csd
positive authorization
authorizations are
negative authorization
parametric derivation
in tab
administrative operations
administer privilege
tab and
interval associated
level i
authorization for
on hobjecti
positive authorizations
explicit authorizations
ha t
the own
the object
and rules
insertion of
a temporal
mode on
authorizations on
authorizations can
authorization an
read sam
s ins
the administer
the revokee
dred ext
tab is
authorization base
authorizations appearing
each authorization
sam friends
s o
an instant
ground derivation
the insertion
the deletion
an access
check levels
function dred
authorization t
in tabext
authorizations for
for instant
administrative privileges
from tab
set detection
administrative authorizations
materialized authorizations
unique model
discretionary access
pairs ha
max level
refer privilege
top level
time instants
to grant
access modes
an object
each instant
deletion of
the temporal
of derivation
granted to
t 0
the materialized
o m
of valid
granted by
materialization approach
haccess modei
authorizations that
pierangela samarati
authorizations the
authorization rule
for tabext
administrative authorization
among authorizations
temporal capabilities
new authorizations
rules r
a subject
t 00
unique set
instants in
of derived
rule r
level l
in t
b te
authorization and
authorization at
if pn
of administrative
appearing at
t max
time intervals
40 60
valid at
presence or
rule t
evaluation order
access request
an t
a negative
a 1
need of
in level
be derived
rules in
the access
access authorizations
the revoke
hobjecti from
john o
o1 read
own or
temporal dependency
am at
pn g
modei on
tab i
sequence hx
tab the
m pn
authorization am
to hsubjecti
e am
hx t
ext the
and technologies
a materialization
authorization can
hobjecti to
authorizations to
authorizations from
function update
from hsubjecti
inserted authorization
te am
authorizations is
authorizations upon
strict dependency
authorization pattern
at instant
all authorizations
for authorizations
intervals representing
definition 2
the time
a critical
logic program
with temporal
o 1
tuple s
semantics of
r 3
of temporal
the levels
with t
a unique
derive a
to exercise
case op
t b t
b t e
in inst tab
and derivation rules
authorizations and derivation
tab u ext
the csd algorithm
s o m
of the authorization
authorizations and rules
on an object
an instant t
administer privilege on
the authorization is
interval associated with
time interval associated
ha t i
of authorizations and
which the authorization
temporal authorizations and
access mode on
set of valid
t e a
for each instant
appearing in inst
of derived authorizations
parametric derivation rules
a critical set
privilege on an
authorizations can be
of derivation rules
of valid authorizations
in t b
the administer privilege
the insertion of
the time interval
on the object
the deletion of
instant t 0
a temporal authorization
function dred ext
a negative authorization
of the authorizations
the derivation rules
derive a 1
by the csd
critical set detection
t n l
for instant t
refer privilege on
discretionary access control
a unique model
to a subject
privilege on the
a unique set
unique set of
rule t b
mode on an
the materialized authorizations
authorization t b
the authorization at
ground derivation rules
derivation rules and
an access mode
of temporal authorizations
an authorization model
is in level
authorization is granted
authorization at the
from tab u
either the own
authorizations appearing in
t b te
inst tab and
a 2 is
set of time
the time at
the presence or
rules r 1
the access mode
in the authorization
object to a
time at which
absence of other
e a k
an object to
follows definition 2
of time intervals
the valid authorizations
o m pn
an authorization a
function check levels
the refer privilege
and negative authorizations
a positive authorization
for critical set
the inserted authorization
states that user
execution of administrative
authorization a is
access control model
t 00 t
tuple s o
t e am
o 1 read
the own or
case op of
modei on hobjecti
authorizations in tab
s ins and
models and technologies
derivation rules can
hobjecti from hsubjecti
for each authorization
of administrative operations
temporal authorization base
o1 read sam
i in tabext
m pn g
set of authorizations
from t b
algorithm for critical
hobjecti to hsubjecti
b te am
at instant t
authorization for the
to that interpretation
haccess modei on
on hobjecti from
parametric derivation rule
of pairs ha
given a tab
symposium on access
control models and
a subject it
a derivation rule
authorizations on the
valid at time
a strict dependency
derivation rules in
authorization model for
instant t in
on hobjecti to
the formal semantics
from the time
of the operator
the set of
on access control
on object o
algorithm 6 1
time interval the
true in an
repeat for each
x t b
access control models
in an interpretation
the evaluation order
insertion of t
is the user
access control policies
at which the
a time interval
basis of the
on the basis
right of the
to refer to
based access control
in level i
transactions on information
at the right
the need of
at time t
information and system
t 0 with
security tissec v
the time instants
and rules in
of t b
system security tissec
and system security
t i in
in our model
according to that
t in t
0 with t
at the left
set of derived
access control and
a 1 for
mode m on
read sam from
a materialization approach
m on object
are requests for
object appears in
derivation rules where
a rule t
pairs ha ti
authorization can be
an t a

corpus/krapavin2000-test/627737.txt
bayesian
learning
likelihood
probabilistic
networks
sample
fitting
priors
graphical
neural
expert
causal
elicitation
mcmc
symptoms
hidden
causality
mdl
belief
network
buntine
latent
sm
statistics
statistical
markov
artificial
tables
bic
parametric
undirected
gibbs
intelligence
uncertainty
disease
missing
fig
probabilities
feed
conditional
posterior
prior
gaussian
net
mixture
identification
em
tutorial
probability
sigmoid
121
age
exponential
bayes
methodologies
mining
inference
bivariate
resampling
gaussians
introductions
thinkbank
clim
posteriors
ipf
independencies
146
valued
occ
heckerman
independence
equivalence
111
entropy
family
communities
learn
regression
chickering
maxwell
herskovits
tetrad
acquisition
hypothesis
trees
samples
assessment
biases
guide
classification
intelligent
104
arc
chain
37
medical
subjective
diagnosis
david
monte
multivariate
forth
russell
rich
pitfalls
pain
stomach
greiner
cart
samplejsm
wermuth
wray
rubric
cjb
weiru
haider
symptomsjdisease
dogma
likelihoods
review
methodology
joint
discovery
selection
78
medium
carlo
laplace
js
maximization
informative
sampling
diagnostics
phonemes
climate
confounded
spirtes
sajjad
experts
forward
discrete
literature
distributions
moments
social
functional
smoking
whittaker
neat
lauritzen
ovals
stochastic
intervention
classifiers
sparse
68
parents
maximizing
decision
clustering
lem
144
incomplete
empirical
greedy
causation
cancer
methodological
casual
agnostic
approximations
popular
arcs
147
criteria
occupation
nielsen
worked
predictive
nov
directed
training
variety
truth
earliest
56
scientists
summations
richness
developments
estimate
hybrid
press
prob
1997
fit
forecasting
oxford
decomposable
reproduced
bayesian networks
probabilistic networks
sample likelihood
maximum likelihood
learning bayesian
of bayesian
graphical models
probabilistic network
the sample
bayesian network
for learning
probability tables
of probabilistic
the bayesian
from data
bayesian methods
parameter fitting
a bayesian
model selection
large sample
on learning
networks from
expert systems
artificial intelligence
likelihood approach
for bayesian
of learning
latent variables
exponential family
network structures
in artificial
neural networks
this review
buntine a
measure zero
learning graphical
belief networks
networks is
learning of
feed forward
for instance
over fitting
structure sm
models from
machine learning
conditional probability
hidden variables
complete data
forward neural
in statistics
in fig
structure learning
data assumption
mcmc methods
hypothesis testing
uncertainty in
a guide
guide to
learning probabilistic
net work
literature on
the exponential
the network
a learning
statistical methodology
networks in
real valued
knowledge acquisition
structure s
for probabilistic
the prior
learning and
bayesian approach
the maximum
likelihood is
bayesian net
true model
networks on
sample size
the true
information complexity
medium sample
the bic
learning structure
sample phase
bayesian method
priors can
likelihood and
fig 6
networks the
the likelihood
missing values
sample complexity
information theory
the probabilistic
probability distribution
likelihood for
network structure
data mining
the probability
fitting in
probabilistic expert
have equivalent
parameters m
gibbs sampling
classification trees
discrete variables
instance consider
small sample
computational learning
networks are
table ii
variables are
em algorithm
binary variables
the literature
intelligent systems
learning theory
p case
chain monte
learning algorithm
networks with
three variables
variables and
of machine
to learning
in learning
an introduction
missing data
prior and
likelihood estimate
probability models
probability table
knowledge discovery
hidden markov
to bayesian
single best
a feed
a causal
chain graphs
sample learning
identification methods
maxwell chickering
with latent
represent causality
review is
js d
121 37
david maxwell
general probabilistic
identification algorithms
equivalent probability
sigmoid sigmoid
bivariate gaussian
minimum cross
hypothesis space
of mcmc
networks d
greedy search
decision analysis
observe i
approximate moments
real values
in probabilistic
quality measure
in bayesian
networks and
to sample
a probability
the structure
and bayesian
algorithms exist
of measure
learning problem
the expert
the hidden
the variables
variety of
of networks
so forth
the em
sample from
learning v
the parameters
exist for
data analysis
in social
undirected arcs
and uncertainty
bayes optimal
informative priors
for structure
nov dec
to probabilistic
undirected networks
a variety
a rich
a tutorial
learning research
neural network
the sample likelihood
the maximum likelihood
learning bayesian networks
of probabilistic networks
maximum likelihood approach
for bayesian networks
of bayesian networks
in artificial intelligence
networks from data
literature on learning
in this review
learning graphical models
for learning bayesian
graphical models from
buntine a guide
on learning graphical
the exponential family
bayesian networks is
to the literature
the literature on
the bayesian network
feed forward neural
uncertainty in artificial
a guide to
the probabilistic network
for probabilistic networks
bayesian methods for
the probability tables
learning probabilistic networks
complete data assumption
probabilistic networks is
guide to the
a bayesian network
bayesian networks the
bayesian networks from
methods for learning
the true model
conditional probability tables
computational learning theory
a learning problem
forward neural networks
probabilistic networks from
of measure zero
a probabilistic network
bayesian networks on
learning of bayesian
a bayesian method
probability table for
for the bayesian
of machine learning
given in fig
for instance consider
probabilistic expert systems
latent variables and
bayesian networks with
of over fitting
from data an
learning of probabilistic
to sample from
for an introduction
chain monte carlo
the complete data
in bayesian networks
markov chain monte
a feed forward
maximum likelihood estimate
a variety of
bayesian networks d
results from computational
nov dec 1997
the hypothesis space
with latent variables
priors for bayesian
sample likelihood is
probabilistic networks the
more general probabilistic
for parameter fitting
network structures from
the large sample
induction of probabilistic
sample likelihood the
a statistical methodology
in probabilistic expert
probabilistic networks in
single best model
equivalent probability models
minimum cross entropy
graphical models for
networks d and
bayesian network structures
maximum likelihood and
set of measure
learning v 29
from data and
bayes optimal error
sample likelihood for
over fitting in
tables for p
measure zero in
general probabilistic networks
structure learning was
from data a
has measure zero
e have equivalent
from computational learning
and large sample
large sample phase
david maxwell chickering
in the probability
instance consider the
a probability distribution
and knowledge discovery
and so forth
mining and knowledge
machine learning v
journal of machine
machine learning research
learning the structure
structure from data
bayesian net work
from data the
probability tables for
on bayesian networks
s d and
the bayesian networks
problem of over
the prior and
a learning algorithm
exponential number of
the sample size
in table ii
in the data
feed forward network
the sample complexity
of bayesian network
and e have
the quality measure
the conditional probability
of the sample
data mining and
hidden markov model
of fig 6
bayesian networks and
29 n 2
a single best
of the exponential
a large sample
problem of learning
the em algorithm
of the network
in fig 6
networks in the
for the variable
the journal of
an exponential number
a real valued
the data and
be found in
for instance in
equivalence classes of
under the general
probabilistic networks are
thomas d nielsen
on learning structure
data is related
sample p new
a missing value
gamma1 2 different
bayesian networks which
and bound technique
introduces bayesian networks
optimal error rate
variables machine learning
standard results for
manual knowledge acquisition
probabilistic networks with
real valued variable
area not considered
become familiar with
the truth this
sample and large
averaging over multiple
provide a rich
small sample medium
use of mcmc
intelligence uncertainty in
find the structure
networks appears in
structure learn ing
parameter fitting to
distribution for network
bell weiru liu
the best l
11 data points
true model is
where every two
and casual networks
structures s d
every two variables
sample medium sample

corpus/krapavin2000-test/627752.txt
sensor
monitoring
sensors
monitor
event
buffer
monitored
query
delay
inference
deductive
switch
network
attributes
driven
installation
route
object
obj
primitive
qos
throughput
subclass
collected
activation
status
measurement
magnet
outof
statistical
objectives
activate
broadband
database
perf
traffic
dataspace
activated
configuration
objective
installed
operators
queries
packet
attribute
aggr
vckt
creation
jn
activates
station
sample
var
frame
processor
buffers
identified
submitted
abstraction
generic
declared
j1
management
instances
interface
id
association
specification
monitors
aggregation
activating
configured
senor
selectively
objects
aggregating
events
collect
aggregate
establishes
specifies
metropolitan
duration
networks
subsystems
deactivated
sampling
delays
created
arrival
relationship
operator
engine
message
relational
links
lans
j2
recorded
switching
architecture
count
measures
samples
occupancy
sent
manage
resources
servers
deduction
entity
processed
managing
integrated
inherits
associate
service
interconnected
stopping
requested
transport
j1j2
instrument
senosr
nemos
automatcally
nbs
arpanet
21402
fabrics
create
reporting
specifying
transmits
questions
sees
identification
met
answered
debugging
responsible
tasks
gatani
codasyl
abstractan
gaglio
urso
dataspaces
hou
deactivates
history
experimentation
procedures
operate
decompose
indication
emphasis
lan
name
multiplexers
stamped
specialists
characterizes
terminal
hardware
send
measurements
switches
calling
disabling
observation
conceptual
abstractions
maintains
identify
quality
achievement
cdr
alfonso
persistently
configure
ownership
established
period
average
selected
negotiated
nu
sensory
st
ment
answers
entities
manual
initiator
geographically
methodology
identifies
center
users
derived sensor
time delay
event variables
the monitor
and event
switch buffer
the network
objective driven
driven monitoring
performance parameter
performance parameters
the sensor
state variables
inference processor
object class
primitive sensors
deductive inference
state and
the sensors
monitoring the
event variable
observation frame
statistical inference
state variable
the derived
sensor is
for monitoring
obj view
monitoring of
the deductive
of sensor
be monitored
route of
or event
buffer 0
status sensor
the route
sensor and
delay of
the object
the state
sensor database
monitor the
average time
sensor configuration
broadband networks
knowledge database
component object
the call
the monitoring
sensors in
the interface
of sensors
instance of
to monitor
the knowledge
a call
derived sensors
event sensor
delay call
configuration database
selected objects
activate sensors
a derived
sample path
the statistical
of state
the query
network the
the instances
subclass of
to monitoring
new object
an object
the selected
attributes of
simple queries
measurement points
packet outof
driven measurement
collected information
perf parameter
measurement strategy
primitive sensor
outof buffer
magnet ii
evaluation operators
statistical operators
sensor installation
network station
integrated networks
maximum time
the collected
of derived
a subclass
real time
monitoring and
monitoring system
installed in
the attributes
qos parameters
time delays
sensors for
based monitoring
sample count
the performance
state or
object and
instances of
the throughput
data space
the event
sensor the
a state
of primitive
object specific
relationship type
monitoring scheme
attribute sample
throughput time
state var
analysis specification
sensor switch
sensors installed
selected performance
query analysis
call a
activation of
knowledge based
the specific
class name
a query
the attribute
an event
the buffer
the relationship
dynamic database
variables associated
of obj
the qos
data query
generic object
an instance
the configuration
architecture of
call is
associated with
sensors are
network is
sample on
by monitoring
user id
collect information
monitoring a
of creation
variables of
variables that
sensors the
of integrated
establishes the
inference engine
delay at
specific instance
the information
time data
status monitoring
for objective
various performance
vckt route
variable specific
specific generic
traffic class
operator submitted
access points
buffer switch
generic sensors
derived object
creation indicates
data transformation
delay condition
has vckt
variable packet
the dataspace
sensor for
appropriate sensors
sensor operations
buffer jn
aggr perf
network monitoring
monitoring generic
statistical abstraction
monitor and
the average
is created
performance measures
aggregation of
creation of
is identified
interface between
is collected
state and event
and event variables
time delay of
objective driven monitoring
the derived sensor
the object class
average time delay
in the network
buffer 0 1
the route of
the state and
of the call
along the route
of a call
route of the
the deductive inference
deductive inference processor
derived sensor is
sensors in the
the performance parameter
switch buffer 0
the network the
of the network
0 1 i
to be monitored
the performance parameters
of derived sensor
the sensor database
the time delay
delay of a
the instances of
a state variable
maximum time delay
the selected objects
a derived sensor
the knowledge database
the configuration database
the statistical inference
time delay call
call a b
the average time
the new object
in the knowledge
the state variables
to monitor the
installed in the
statistical inference processor
performance parameters and
driven measurement strategy
sample path and
packet outof buffer
derived sensor and
the collected information
knowledge based monitoring
objective driven measurement
performance evaluation operators
event variables of
the maximum time
a subclass of
the attributes of
of the object
of the monitor
a b i
order to monitor
of state variables
new object and
throughput time delay
of obj view
an objective driven
state or event
the selected performance
a state or
event variables and
query analysis specification
identify the instances
the objective driven
an event variable
sensors installed in
time of creation
driven monitoring the
the relationship type
sensor switch buffer
to be configured
the monitor and
the dynamic database
of primitive sensors
time delay at
time data query
monitoring of distributed
status sensor and
of integrated networks
selected performance parameters
or event variables
the observation frame
monitor the state
of the performance
architecture of the
in the sensor
an instance of
of the sensor
of a state
attributes of the
instances of the
delay of the
a set of
to be collected
event variables the
the event variable
variables associated with
of the monitoring
the sensors in
of the deductive
to the monitor
the network is
of the derived
real time data
associated with the
object and the
creation of the
the knowledge base
set of state
of the sensors
with the selected
about the network
of the state
the association between
the interface between
of state and
the instance of
based on the
of an object
interface between the
specific instance of
of distributed systems
in the configuration
of the interface
shown in figure
variable packet outof
questions of interest
path and performance
relationship type has
simple queries and
the measurement points
class name of
describes the attributes
monitor and the
operator submitted queries
submitted queries the
variable specific generic
to activate sensors
driven monitoring scheme
has vckt route
activation of sensors
control and management
the attribute sample
inference processor is
specific generic sensors
and or event
the monitor the
approach to monitoring
the component object
processor is to
time delay condition
primitive sensors are
for objective driven
the status sensor
state or an
and derived sensor
sensor is created
switch buffer jn
monitoring of integrated
event variables that
an observation frame
based monitoring of
performance parameters are
aggr perf parameter
establishes the association
various performance measures
event variables associated
a data space
event driven monitoring
of creation indicates
outof buffer switch
and event variable
parameters and the
quality of service
of the knowledge
the sample path
database contains the
the sensors the
or an event
real time traffic
the specific instance
state variable is
the monitoring of
measure the time
is a subclass
system architecture of
total average time
variables that are

corpus/krapavin2000-test/627754.txt
join
bushy
gmc
query
gmr
joins
processors
sgd
allocation
se
sopt
processor
parallelism
heuristics
cardinalities
gopt
multiprocessor
te
heuristic
fragmentation
operational
st
mt
rrr
dependency
synchronous
sequences
scheduling
pipelining
execution
rr
7a
allocated
profile
efficiency
7b
relations
intra
queries
database
curve
termed
sequential
proc
deallocation
inter
hash
operands
cumulative
execute
operator
tree
fs
child
skew
schemes
simulation
xprs
5b
cardinality
merge
bottom
5a
jv
attributes
exploiting
2a
outperformed
costs
jr
relational
joining
3a
internal
dbs3
20828
allotted
interoperator
9041
7135
6284
5990
resulted
51
efficiencies
syan
sort
trees
ongoing
attribute
composite
eased
bubba
2b
exploit
prob
light
minimize
exploitable
grace
131
scheduler
shall
minimal
alleviate
despite
outperform
excessive
employed
evaluated
exe
8a
disks
pipelined
selection
concept
opportunity
opt
trend
dominating
prevalent
dealt
emerges
categorized
106
suffer
nowadays
down
ming
tuples
mc
effectiveness
completion
greedy
workload
pn
incurred
1a
absent
118
1b
resort
poor
node
multi
parallelizing
efficiently
objective
reasonably
300
top
me
deemed
allocates
constraintssuch
cross8
decomposer
7pm
1195
3639
rrrrr
reallocating
rrrrrrrrrrrrrr
nonequal
rrrr
intraoperator
hc16
multiquery
inners
mediocre
7695
gammah
1026n
jjej
fragmentationthan
uopn
ullmann
idleness
rrrrrrrrrrrrrrr
rrrrrrrrrrr
3678
1182
102
allocating
mentioning
mobile
factors
avoided
evaluate
explore
rdbms
softwares
alleviating
nonstop
lengthen
958
informix
1299
shrunken
tially
join sequence
processor allocation
bushy tree
join sequences
the join
the bushy
operator parallelism
execution time
general join
each join
execution dependency
of processors
sequential join
multi join
a join
synchronous execution
operational point
st se
inter operator
the query
system fragmentation
sequence scheduling
the execution
join query
cardinalities of
sequence efficiency
operational curve
a bushy
r 5
minimal cost
intra operator
efficiency point
query graph
execution costs
the processor
of relations
r i
r 4
by sgd
sequence heuristics
resulting relation
cumulative execution
dependency and
query execution
5 r
multiprocessor system
a multiprocessor
of synchronous
processors allocated
the operational
join queries
point selection
join is
bushy trees
next join
cost join
to execute
join operation
bottom up
the heuristics
top down
and processor
join in
internal node
the cardinalities
query in
r r
merge join
r 6
child nodes
a query
sgd and
optimal sequential
by gmc
seen that
by simulation
join to
se is
of joins
sort merge
allocated to
execution of
r j
average execution
6 r
different join
tree in
time point
scheduling and
the profile
4 r
sequence heuristic
gmr is
gmc and
best efficiency
and gmr
heuristic se
heuristics proposed
resulting join
proc no
execution cost
join and
is termed
the minimal
of join
parallel execution
be seen
joins in
figure 7a
r 2
the optimal
and evaluate
processors to
join r
data skew
sequences obtained
by st
processors are
minimum time
execute the
r y
simulation results
join can
the heuristic
allocation heuristics
and sopt
resulted by
fs mt
se fs
by te
exploiting inter
by se
by sopt
schemes evaluated
built bottom
resulting r
sequence proc
no starting
sopt and
two child
figure 7b
the concept
figure 2a
processors for
the schemes
in figure
for processor
sequence for
a multi
determine the
h p
r 3
the cumulative
processor system
joins are
for join
concept of
allocation for
down approaches
allocation efficiency
join methods
hash joins
r 8
all joins
join method
time end
allocation it
execution tree
single processor
2 r
this heuristic
join the
3 r
and system
minimize the
propose and
parallelism is
up approach
the joins
outperformed by
scheduling schemes
se and
and r
execution sequence
relations is
i r
o jv
their simplicity
starting time
to exploit
p b
heuristic to
time of
the resulting
costs of
join with
time resulting
query complexity
join operations
several heuristics
the bushy tree
the join sequence
number of processors
synchronous execution time
the processor allocation
inter operator parallelism
concept of synchronous
of synchronous execution
join sequence scheduling
general join sequences
the query execution
multi join query
join sequence efficiency
a multi join
a bushy tree
query execution time
execution dependency and
number of relations
and processor allocation
sequential join sequence
general join sequence
intra operator parallelism
query in figure
operational point selection
r 5 r
sequence scheduling and
r 4 r
dependency and system
join sequence heuristics
scheduling and processor
4 r 5
sequential join sequences
be seen that
of a join
the minimal cost
the execution time
r 6 r
for each join
the operational point
minimal cost join
and system fragmentation
bushy tree in
the cumulative execution
the next join
of each join
minimum time point
r 2 r
processors allocated to
a multiprocessor system
sort merge join
execution time of
the cardinalities of
of processors allocated
can be seen
the execution of
r i r
the general join
bushy tree is
the resulting relation
optimal sequential join
in figure 7a
bushy tree and
the optimal sequential
multi join queries
in the bushy
execution costs of
2 r 4
the average execution
tree in figure
to execute the
r r r
in a multiprocessor
the number of
r i and
the query in
when the number
join sequence for
the operational curve
in figure 7b
single processor system
join sequences obtained
r 3 r
join sequence heuristic
gmc and gmr
of multi join
for processor allocation
a join sequence
minimize the query
cardinalities of relations
execution of multi
best efficiency point
for parallel execution
to determine the
and r j
for the execution
processor allocation for
in figure 2a
execution time to
time of a
the concept of
i and r
for the query
of the join
sequence of joins
the sort merge
of a multi
two child nodes
it can be
despite their simplicity
the synchronous execution
processor allocation efficiency
processor allocation heuristics
processor allocation it
built bottom up
sgd and sopt
sequences obtained by
6 r 8
proc no starting
within a query
cumulative execution cost
time end time
join sequence in
minimize the execution
5 r 6
resulting r i
se fs mt
the best efficiency
cumulative execution costs
resulting relation of
no starting time
h p j
several heuristics to
a general join
sequence proc no
5 r r
the heuristics proposed
each join in
execute the join
the join r
join sequence proc
database operations in
time efficiency point
processors to execute
the resulting join
by sgd and
starting time end
cardinalities of attributes
time resulting r
end time resulting
exploiting inter operator
join sequences are
execution dependency is
determine the next
propose and evaluate
to minimize the
light of the
the execution sequence
join to be
top down approaches
under a single
execution cost of
of processor allocation
bottom up approach
the minimum time
evaluated by simulation
i r j
a join operation
its child nodes
join in the
used to execute
join can be
an internal node
execution of each
section 3 3
i r r
seen that the
determine the number
of processors is
internal node in
execution time is
in light of
r 1 r
top down approach
that the join
this heuristic is
with the minimal
of processors for
join sequence and
relations attribute a
se and st
and general join
form of parallelism
a final scheduler
the heuristic st
by st se
as if under
processor allocation heuristic
join in a
the time efficiency
execute each join

corpus/krapavin2000-test/627765.txt
tah
ventricle
lateral
image
tumor
brain
protrusion
spatial
tahs
query
relaxation
sr
images
contours
conceptual
mdisc
shape
features
bordering
content
semantic
contour
retrieval
pressed
matched
tumors
lesion
ur
nearby
relationships
ul
patient
lv
target
surround
operators
lr
similarity
protrusions
patientwithimage
ksim
obj
profile
feature
retrieve
sl
retrieving
lobe
subclause
relationship
ranges
height
objects
predicates
finalized
circumjacent
mtah
midline
ventricles
patients
tips
ll
rl
object
screen
width
surgeon
descriptors
frontal
layer
answers
ranking
segmentation
policy
extracted
mandatorily
srtl
kl
queries
database
occupied
medical
retrieved
joined
pt
clustering
precision
midpoint
centroids
resonance
qbic
answering
touching
matching
coverage
abstraction
engulfed
kmed
visualworks
invading
delineation
extremely_
p000
centrally
bronchial
surgeons
radiologists
protursions
roundness
cobase
santini
hierarchies
menu
pull
magnetic
angle
classified
composite
hacid
mohand
gemstone
sad
intelligent
decomposed
multimedia
hierarchy
attributes
symmetry
her
p1
lined
simone
ct
i1
literal
mr
attribute
intended
constructs
divides
display
directory
margins
alfonso
databases
ranked
layers
classify
textually
bnf
staged
specialization
ramesh
select
interpretation
customize
gui
location
ext
perimeter
raw
fuzzy
layered
cooperative
topological
jain
selected
relaxed
representative
chu
classification
axis
thick
centroid
users
highlighted
representations
extracting
segmented
001
certainty
semantics
locate
chih
retrieves
assist
shaped
vision
prototype
avinash
petraglia
projectional
wasfi
xcordofcentroids
lowerlrheightratio
arteries
sebillo
ison
tucci
ycordofcentroids
lateral ventricle
spatial relationship
the tah
spatial relationships
target image
conceptual terms
knowledge based
the lateral
tah nodes
user model
image objects
sr t
and spatial
value ranges
the relaxation
features and
the query
the brain
relaxation policy
tah for
tah node
right protrusion
query processing
based query
the image
left protrusion
sr l
pressed to
semantic spatial
semantic operators
relaxation error
object contours
shape features
the knowledge
similar images
the target
protrusion height
tumor and
user profile
image content
image features
the features
relationship operators
for tah
brain tumor
image object
l lv
relationship features
tah s
tumor size
the spatial
query 4
brain tumors
image retrieval
the shape
matched objects
upper protrusion
shape feature
ur ll
protrusion pressed
query relaxation
the selected
selected features
the matched
query constraints
user type
shape model
description table
image semantics
retrieving images
to retrieve
type abstraction
of upper
of features
feature values
the feature
ventricle is
ventricle and
selected tah
ventricle the
tahs for
frontal lobe
knowledge layer
on subclause
the sl
1 sr
obj feature
matched user
lesion lateral
and lateral
t l
value range
multi attribute
the semantic
the screen
content based
with conceptual
width of
images by
o c
for retrieving
the user
clustering algorithm
image similarity
height of
of lower
objects in
of image
relevant answers
two contours
the tahs
large tumor
finalized tah
brain midline
patientwithimage patient
brain contour
ll lr
tumor nearby
image representations
2 brain
fully surround
ventricle 1
select patientwithimage
query context
lateral ventricles
the finalized
right symmetry
content matching
protrusion width
to operator
lower right
operators e
relationship model
shape descriptors
by content
two objects
brain surgeon
ul ur
based content
abstraction hierarchy
g large
the tumor
retrieve images
of coverage
upper left
query query
image from
the similar
and user
the images
a knowledge
upper right
and image
the tips
image feature
features are
an image
lower left
queries with
terms e
target data
query analysis
features such
the intended
operators and
shape description
features used
image databases
in specifying
image model
to predicates
for processing
features of
features in
srtl lesion
appropriate tahs
of brain
subclause is
spatial image
layer kl
a tah
nearby far
object spatial
mandatorily matched
no based
composite feature
ventricle into
conceptual query
these value
with bordering
policy provided
matched tah
tahs are
tah the
extracted image
raw images
bordering fully
the rl
available conceptual
relaxation process
the target image
the lateral ventricle
knowledge based query
features and spatial
and spatial relationships
sr t l
of the lateral
based query processing
semantic spatial relationship
pressed to the
protrusion height of
the user model
and spatial relationship
the knowledge based
sr l lv
spatial relationship operators
spatial relationship features
the spatial relationship
the relaxation policy
the tah node
the tah nodes
protrusion pressed to
the selected features
the value ranges
of the target
on the screen
the query constraints
lesion lateral ventricle
matched user profile
upper right protrusion
tumor and lateral
the shape model
upper left protrusion
in the sl
lower right protrusion
lateral ventricle is
lateral ventricle the
lateral ventricle and
the selected tah
angle of coverage
based on subclause
and lateral ventricle
spatial relationship model
set of features
based on the
similar to operator
operators e g
a knowledge based
objects in the
of the retrieval
context and user
with conceptual terms
right protrusion height
select patientwithimage patient
protrusion width of
the matched user
width of lower
of upper left
the semantic spatial
upper protrusion pressed
the relaxation error
lateral ventricle 1
of upper right
height of lower
the finalized tah
the image objects
left protrusion height
based content matching
knowledge based spatial
similar to predicates
tumor size and
the knowledge layer
ventricle 1 sr
ur ll lr
lower left protrusion
query query query
a multi attribute
e g large
ul ur ll
knowledge based content
width of upper
the target data
height of upper
value ranges of
of the brain
to right symmetry
of lower right
of lower left
target data values
conceptual terms e
the two contours
1 sr l
of the tah
image semantics and
of features used
terms e g
to retrieve images
the similar to
for retrieving images
the features and
retrieving images by
type abstraction hierarchy
to the right
in the database
images by content
the spatial relationships
of the image
are used to
in the query
knowledge based approach
midpoint of the
specified in the
the midpoint of
images in the
these value ranges
tumor srtl lesion
a pull down
mandatorily matched objects
semantic operators e
tah nodes to
shape model and
the appropriate tahs
similarity based on
lv 2 brain
spatial relationship predicates
available conceptual terms
image content interpretation
or conceptual terms
relaxation policy provided
image model ksim
in the finalized
target image condition
l lv 2
chain code of
conceptual terms for
the tah s
knowledge layer kl
g large small
for similar to
type abstraction hierarchies
conceptual terms are
from the tah
relaxation error of
model and spatial
feature description table
the object contours
shape feature description
sr t f
features and content
content interpretation knowledge
on subclause is
description table table
the query relaxation
tumor nearby the
d s r
spatial image model
value ranges are
nearby far away
the query context
between tumor and
in the tah
tah for sr
pull down menu
of sr t
query context and
based spatial image
bordering fully surround
the shape features
srtl lesion lateral
retrieve similar images
queries with semantic
no based on
the image content
in the rl
the image representations
nearby the lateral
semantic operators and
and or conceptual
lateral ventricle into
surround with bordering
of image objects
the query processing
distance of the
features such as
of the knowledge
analysis and feature
image features and
in specifying the
a similar to
value ranges in
features used to
and feature selection
the feature value
content based retrieval
spatial relationship between
query processing is
by the generated
query analysis and
features e g
the chain code

corpus/krapavin2000-test/627767.txt
trie
agrep
sistrings
text
string
subtrie
dp
character
dictionary
edit
enface
characters
ukkonen
rantee
sublinear
strings
spelling
mismatches
sistring
enfold
texts
searches
searching
h3a
suffix
approximate
substrings
pm
subtries
kleen
ech
sigmaj
match
cutoff
prefix
word
tries
enf
insertions
phonetic
soundex
editdist
matching
checkers
secondary
ram
baeza
compression
echo
keywords
patricia
levenshtein
exsample
damerau
dfsearch
search
column
disallow
yates
matches
substitutions
postal
regular
else
deletions
codes
storage
entries
letter
truly
star
evaluates
errors
file
pattern
kn
preproc
adfd
abbbc
rienode
abbc
subt
sattler
typographic
childnode
saake
eike
gunter
rie
schallehn
unix
ga
ab
index
telephone
depth
license
morrison
2a7
pointerless
sane
letters
searched
uwe
wildcard
stop
substitution
allowable
insensitivity
lawler
sigma
retrieved
english
ij
exact
137
target
standards
suffixes
transpositions
boyer
document
storing
pages
distances
costs
alphabet
insensitive
ld
digit
dna
preprocess
bs
evaluating
anchor
kai
symbol
2a
deletion
transposition
blank
digits
correction
mistakes
abc
pat
borrowed
columns
pointers
sample
ce
prefixes
moore
ref
traverse
scans
five
insertion
tells
sa
expression
counters
elapsed
transpose
leaf
walk
sought
inverted
correcting
bits
checker
keyboard
304b
snet
ogp0004365
perlberg
fho
garantee
cac
gollapudi
panigrahy
1059
merrett
musical
theta4
sinary
aeiou
anode
lambdap
trondheim
workable
2a4
acdfbdf
bbc
rieroot
28mb
acdfb
shakespeare
1047
matchsimile
the trie
the text
trie search
a trie
regular expression
approximate string
dp table
our trie
approximate match
exact match
string matching
the pattern
the subtrie
enface same
trie methods
spelling checkers
secondary storage
same example
approximate search
j sigmaj
trie and
sample enface
ukkonen s
trie structure
kleen star
truly sublinear
index trie
else else
search time
a dictionary
the dp
a text
o m
words with
w j
expression matching
k approximate
dictionary trie
trie algorithm
tries for
trie method
sigmaj k
enfold sample
search path
dictionary search
search algorithm
and approximate
p i
approximate searches
baeza yates
target string
pattern string
searches we
edit operations
text searching
o n
d pm
1 w
text and
d p
on secondary
o kn
the index
for approximate
after evaluating
all sistrings
trie the
column up
these sistrings
echo enfold
agrep 28
large texts
suffix rantee
same prefix
approximate trie
approximate regular
sublinear in
five texts
h3a 2a
pm w
full regular
trie based
match algorithms
ga rantee
postal codes
proportional only
sistrings we
english words
when searching
depth first
o k
log n
entries of
the search
table entries
text size
row c
k mismatches
ram size
target word
string search
for text
matching in
regular expressions
return if
no word
of edit
text as
string searching
file names
to disallow
column of
only to
need only
suffix tree
column are
max of
edit distance
to row
in strings
of allowable
ab c
to search
get c
or 7
2 w
table for
evaluates the
c j
cut off
that tries
it evaluates
can stop
of words
words in
alphabet sigma
exact and
character in
string in
the string
the dictionary
third column
or o
best match
trie is
the patricia
kn o
checkers case
since agrep
that edit
tries have
if editdist
substitutions only
anchor symbol
stop evaluation
text w
ample x
entries ukkonen
limited approximate
a cutoff
texts which
soundex codes
characters i
ld ample
allowable characters
evaluate one
retrieved character
agrep scans
uwe sattler
let function
c ce
entry value
the kleen
word say
trie in
t rienode
levenshtein dp
space ref
time extra
editdist j
do retrieve
sublinear expected
traverse we
text searches
ukkonen 24
many subtries
pattern character
with agrep
insensitivity and
morrison 19
patricia trie
experimentally with
damerau levenshtein
dictionary searches
unix standards
says there
string being
those keywords
two letters
with mismatches
approximate string matching
enface same example
sample enface same
in the text
regular expression matching
enfold sample enface
j sigmaj k
in a trie
trie search algorithm
ukkonen s algorithm
w 2 w
1 w 2
of the text
w j 1
column up to
k j sigmaj
trie methods for
dp table for
the suffix rantee
proportional only to
the same prefix
the trie method
search time is
to get c
k approximate string
o k j
the trie search
d pm w
it evaluates the
a trie structure
echo enfold sample
in the subtrie
our trie algorithm
the text as
up to row
to row c
and approximate searches
very large texts
we need only
w 1 w
of the pattern
exact and approximate
the text size
to the text
for approximate string
an exact match
the text and
character in the
need only to
or o n
on secondary storage
m log n
entries of the
be a predicate
we can stop
o m log
all entries of
the third column
approximate regular expression
insensitivity and limited
approximate search algorithm
expression matching and
sistrings start at
column is at
o kn o
a prefix shared
matching and k
the dp table
means that target
retrieved character find
a target word
1 w j
c ce ld
pattern ab c
our approximate search
the retrieved character
for words with
sigmaj k expected
the trie representation
in a dictionary
find a target
with the pattern
deleted for free
2 w j
wildcard can be
and lawler 7
2 it sets
target string w
and else else
0 max of
down the subtrie
column to get
the index trie
stop the evaluation
exact match algorithms
text w n
dictionary search by
our trie search
string being sought
as a trie
after evaluating d
2 w x
and k approximate
sattler gunter saake
whether p i
rantee means that
level the retrieved
sublinear expected time
1 return if
trie in figure
the pattern string
the string being
and target string
this column is
some intermediate results
k approximate match
3 or 7
max of integer
the kleen star
case insensitivity and
run preproc time
array 0 max
distances to each
string matching solve
place wildcard can
checkers case insensitivity
word w with
string searching algorithms
borrowed from unix
only to modify
target word output
the search string
uses two bits
trie representation of
w level the
that target strings
one place wildcard
of allowable characters
in subt rie
to evaluate every
a one place
bits per node
when searching a
the largest entry
says there is
and then set
which uses two
the word boundary
case run preproc
full regular expression
approximate match with
no word w
can appear between
either 1 3
agrep 28 and
to walk down
need to walk
the full regular
appear between a
the pattern character
entry value of
subt rie c
a complete trie
time proportional only
the trie in
time extra space
trie depth first
return if editdist
which says there
a kleen star
time is independent
damerau levenshtein dp
searches we set
dictionary trie we
subtrie for the
uwe sattler gunter
schallehn kai uwe
pattern character p
kai uwe sattler
j 1 return
insertions at the
node do retrieve
eike schallehn kai
0 k mismatches
but the trie
since the largest
character find a
largest entry value
tries have been
extra space ref
evaluated only once
and limited approximate
approximate trie search
ld ample x
limited approximate regular
may search for
trie based method
character p i
five texts and
the linear methods

corpus/krapavin2000-test/627771.txt
starburst
rule
triggered
ruleset
transaction
transition
triggering
command
rules
attachment
privilege
authorization
database
commands
emp
employees
privileges
salary
deleted
alter
inserted
sql
extensibility
active
tuple
updated
actions
delete
cascade
transitions
tuples
chimera
deactivate
production
ops5
creator
rollback
ariel
sal
procedures
employee
invoked
deletes
deactivated
module
semantics
tables
relational
commit
catalog
precedes
trigger
consistency
postgres
integrity
almaden
action
drop
concurrency
locks
clause
triggers
language
dept
mary
departments
priority
dbms
jane
sue
modifies
ffl
composite
ordering
activate
executed
hipac
paradiser
rete
ceri
priorities
net
bill
deductive
eligible
queue
create
jim
prepare
stefano
query
logged
registered
registering
mgr
old
dropped
occurred
oriented
executes
lock
revoke
attachments
insert
clauses
maintenance
issuing
sam
commits
specifies
event
execution
arrows
exclusive
loosely
select
altered
facility
databases
rpl
goce
rdl
heraclitus
trajcevski
salaries
creation
modification
log
syntax
automatically
heterogeneity
transitively
attach
references
integrating
name
depict
enforcing
coupled
management
stamp
statement
prototype
descriptor
implementing
serial
maintaining
scheuermann
subsuming
queues
expert
rolled
retrospective
unrestricted
precede
locking
processor
incremental
executing
sees
arrow
ibm
orderings
schedule
option
invokes
debugging
deriving
features
authorized
enforce
issued
referenced
obtains
materialized
integrated
identifier
rejected
upgraded
enforced
manipulating
semantic
flexible
handling
update
manipulation
creates
considers
undo
contents
created
shared
records
recovery
maintained
implied
deferred
processed
project
denotational
rule processing
the starburst
rule system
starburst rule
the rule
a rule
rule execution
rule language
transition log
active database
rule set
process ruleset
of rule
rule definition
triggering operations
rule sets
transition table
transition tables
triggered by
rule s
execution module
is triggered
rule r
in starburst
transaction rule
a transaction
transaction x
process rules
rule command
triggered rules
starburst s
of starburst
a table
are triggered
the transition
rules are
table t
s rule
command is
database system
net effect
create rule
on table
rule is
process rule
extensibility features
potential rules
rule conditions
privilege on
during rule
new updated
of transaction
rule catalog
rule cascade
rule list
and actions
state s
be triggered
s condition
old updated
rule condition
updated and
concurrency control
and rule
definition command
sal control
database rule
drop rule
list rule
rules process
ruleset command
emp no
production rules
tuple level
active rule
the net
rules may
also is
since rule
query processor
actions are
database systems
for rule
object oriented
rule name
ffl rule
event queue
consistency if
composite transition
deleted employees
execution semantics
control privilege
commands for
an attachment
rule attachment
control authorization
triggered at
rule management
alter rule
name on
sql select
one rule
which rules
the transaction
active rules
rules or
precedes and
starburst is
processing information
condition evaluation
privileges on
starburst rules
table function
the attachment
clause specifies
arbitrary database
select statement
action execution
no from
of rules
rule has
database state
to commit
for consideration
its triggering
database rules
in active
a transition
condition is
the composite
r 2
suppose a
s creator
postgres rule
in select
updated tuples
level rule
eligible to
operations occurred
rule actions
global rule
table functions
attachment type
attachment procedures
ruleset or
ruleset s
rule triggering
select emp
average salary
almaden research
ibm almaden
dept no
data modification
rule information
the inserted
error handling
insert delete
statement level
conditions and
prepare to
are executed
integrity constraints
effect of
log the
the database
on t
end of
or statement
rule creation
delete or
follows clauses
transition information
triggered and
the postgres
authorization and
be logged
the extensibility
other active
or rule
x 1
each rule
and follows
be invoked
the semantics
2 rule
its condition
of sql
all aspects
to starburst
r 1
x 2
and action
by issuing
on rule
and old
the create
to rules
execution of
processing is
the specified
the starburst rule
starburst rule system
the rule system
of the starburst
the transition log
starburst rule language
transaction rule processing
of rule processing
on a table
rule is triggered
end of transaction
rule execution module
of transaction rule
the net effect
active database systems
of rule execution
the rule execution
rules are triggered
conditions and actions
semantics of rule
during rule processing
a transaction x
actions are executed
a rule s
a rule r
is triggered by
the rule s
net effect of
a rule is
new updated and
process rules process
extensibility features of
rules process ruleset
rule processing is
the rule catalog
a table t
rule conditions and
rule definition command
list rule list
effect of x
of a rule
within a transaction
a rule set
of the rule
name on table
control privilege on
rule s condition
be triggered by
rule processing information
a process rules
s condition is
concurrency control authorization
rule language is
rule name on
rule set s
its triggering operations
when a rule
which rules are
and actions are
precedes and follows
in the starburst
in state s
to be invoked
prepare to commit
a tuple is
active database rules
if a tuple
rules may be
emp no from
features of starburst
the postgres rule
its condition is
process ruleset command
rules or rule
process ruleset or
consistency if x
ibm almaden research
ruleset or process
the ibm almaden
a rule condition
the extensibility features
or process rule
no in select
active database rule
global rule information
triggering operations occurred
select emp no
rule processing in
or statement level
other active database
on table t
updated and old
control authorization and
clause specifies a
process ruleset s
eligible to be
considered and executed
or rule sets
and action execution
least one rule
operations occurred in
the composite transition
rule system an
process rule command
the rule processing
and old updated
database state transitions
rule list rule
almaden research center
to the transition
condition is true
of the transaction
at the ibm
are triggered by
suppose a transaction
of its triggering
if a rule
and follows clauses
to the starburst
x 1 s
would have been
rule r is
procedures to be
all aspects of
more of its
production rules for
execution of a
to be executed
and error handling
of each transaction
ffl if a
state s 1
if one or
if the rule
x 2 s
rule command the
r s condition
the global rule
respect to rules
invoked when an
process rules command
triggered if one
tuples must be
state s 3
rule system can
and revoke privileges
the process ruleset
s rule processing
transition table references
evaluation and action
in select emp
rule s triggering
to end of
the starburst prototype
ffl suppose a
postgres rule system
selected for consideration
transition since the
automatically at the
the inserted transition
procedure to be
transaction x executes
employees and departments
command is rejected
delete or update
inserted transition table
rule processing with
r is triggered
privileges on it
in active database
uses the changes
starburst query processor
the create rule
management and rule
starburst s rule
must be logged
revoke privileges on
behavior of rule
rule catalog and
composite transition since
considers every change
rule execution in
level rule processing
sql select statement
set of deleted
the changes since
on arbitrary database
create rule command
execution module to
rule system must
2 s rule
arbitrary database state
command invokes rule
a table function
of updated tuples
database system at
sam and sue
sees the effect
how the starburst
triggered by updated

corpus/krapavin2000-test/627784.txt
slg
win
stable
ground
founded
ai
literals
atoms
clause
literal
truth
tabled
atom
irene
residual
prolog
cse5381
semantics
query
color
gm
psm
sean
diff
logic
body
answers
teach
valued
chaining
anss
fixpoint
chris
program
undefined
delayed
interpretation
sldnf
clauses
negation
programs
propagation
herbrand
branch
negative
alternating
false
predicates
xoldtnf
loops
abductive
backward
xsb
forest
stall
und
di
os
backtracking
predicate
ilkka
5381
niemel
simplification
definite
delaying
2100
coincides
conditional
resolution
forward
pfeifer
faber
mary
disjunctive
nonmonotonic
head
move
subgoal
decstation
credulous
delete
db
cse
leone
lifschitz
skeptical
disjunction
simplified
autoepistemic
gelfond
teaches
mgtp
psm0
stselect
gma
derives
gerald
francesco
nicola
timing
guessing
neg
deductive
beliefs
loop
answer
evaluated
pgm
diffchoice
modularly
calimeri
reasoning
fp
declarative
john
stratified
wolfgang
falsity
dlv
subrahmanian
links
quantification
calling
eiter
edge
complements
occurring
kripke
calls
deleting
universe
inconsistent
processed
warren
gelder
versatile
kleene
prototype
queries
pa
reduction
proposals
normal
oriented
derivation
vg
clark
stratification
annals
covered
instances
universal
intelligent
facts
pl
integrate
integration
bodies
enumerating
artificial
contexts
intelligence
portion
safety
renaming
interface
returned
selects
tabling
patrik
9212074
compacts
seas
furbach
1413
gml
smu
giannella
no5
pgml
95766
timo
builtin
hyperresolution
9431
eshghi
elkhatib
yahya
simons
atms
bry
balduccini
noby
pontelli
bonatti
9102159
stnot
resolving
student
stable models
stable model
win a
founded semantics
well founded
win b
valued stable
residual program
ground atoms
of stable
the well
logic programs
ground program
query evaluation
a stable
two valued
reduce algorithm
of ground
ground atom
finite ground
p gm
sean ai
truth values
assume and
evaluation under
assumed truth
model computation
negative literals
a ground
program p
irene ai
chris ai
ai diff
ai choose
the assume
b win
a win
t win
delayed literals
ai di
interpretation i
the residual
the body
truth value
of p
color a
backward propagation
answers of
of slg
win c
alternating fixpoint
negative loops
three valued
forward chaining
and reduce
the clause
normal logic
is true
in p
an interpretation
ground programs
for win
choose sean
all ground
general logic
the program
goal oriented
negative loop
for stable
literals in
fixpoint logic
chaining links
founded partial
color b
in slg
x win
tabled predicates
and bound
a program
clause for
the truth
p be
model of
negative context
total interpretation
branch and
be true
anss psm
undefined instances
choose irene
call win
conditional answers
bound method
move b
p os
a residual
partial model
literals that
a query
the alternating
atom a
the herbrand
a clause
edge a
m p
be false
logic program
program and
models of
the assumed
os i
partial interpretation
p und
john cse5381
ai take
diff chris
diff irene
the slg
conditional answer
forest for
color d
through negation
teach john
computing stable
move a
let p
true in
a is
true or
oriented query
programs with
following program
ground negative
all stable
color c
propagation of
atoms a
negative literal
body literal
every clause
model semantics
search space
computation of
p is
a tabled
diff sean
teach mary
mary cse5381
prolog execution
query win
tabled predicate
62 di
atoms whose
slg for
y color
c win
choose chris
ground literals
ai and
p if
is false
p a
in i
interpretation and
evaluation with
choose x
body of
the head
semantics is
true and
a negative
a move
simplification of
for query
base i
i coincides
false according
of assumed
win x
di p
definite program
t move
assumed to
the simplification
data complexity
is assumed
original program
an atom
if i
the branch
the stable
are true
program for
logic programming
or false
under the
positive literal
clauses with
literal l
for color
the well founded
well founded semantics
a stable model
of stable models
stable model of
two valued stable
model of p
is a stable
valued stable models
and reduce algorithm
assume and reduce
the residual program
under the well
query evaluation under
stable models of
truth values of
of ground atoms
stable model computation
win b win
win a win
the assume and
evaluation under the
values of ground
a is true
finite ground program
a ground atom
assumed truth values
a finite ground
in the body
computation of stable
a win a
choose sean ai
the assumed truth
truth value of
general logic programs
branch and bound
to be true
the alternating fixpoint
three valued stable
valued stable model
well founded partial
forward chaining links
alternating fixpoint logic
founded partial model
a residual program
of all ground
be a ground
let p be
a program p
stable models and
p be a
stable models the
ground atom a
p if and
b win b
founded semantics is
sean ai diff
ground atoms a
oriented query evaluation
for win a
for stable model
reduced to an
goal oriented query
and bound method
the clause for
to an interpretation
p os i
of general logic
win a t
of the well
i is a
literals in the
normal logic programs
an interpretation i
a total interpretation
or a is
set of ground
of p if
is true in
only if i
literals that are
stable models are
all ground atoms
the truth values
true in i
the clause of
teach john cse5381
ground program and
edge a y
computing stable models
chris ai choose
a partial interpretation
founded semantics and
diff chris ai
occurs in p
diff irene ai
query evaluation of
definition of stable
the truth value
assumed to be
the following program
a or a
the body of
b win a
occurring in p
with a in
for query evaluation
all stable models
to be false
stable model semantics
is assumed to
m p i
of normal logic
in the head
the branch and
of delayed literals
ai di p
teach mary cse5381
win c t
color a color
a tabled predicate
number of stable
choose irene ai
reduce algorithm for
win c win
logic of general
a 62 di
for stable models
finite ground programs
time data complexity
query win a
backward propagation of
either a is
assumed truth value
move a x
x win x
ai diff chris
of p gm
fixpoint logic of
of assumed truth
propagation of assumed
used to delete
a x win
ai choose sean
a conditional answer
the negative context
ai choose irene
for computing stable
ai diff irene
derived to be
choose x y
interpretation i and
clause of s
for color a
polynomial time data
stable models in
a t win
produces a residual
diff sean ai
residual program for
win b t
a ground program
choose chris ai
t win a
of a query
j is a
if and only
and a program
and only if
of a program
the original program
true or false
the stable model
query evaluation with
i coincides with
false according to
clause in p
be a total
normal logic program
for some stable
to stable models
some stable model
residual program and
a negative literal
is true or
of the residual
in i and
the search space
a in the
models of p
the simplification of
a two valued
stable models for
of ground literals
founded semantics of
of a ground
of a clause
that are true
that p is
be a finite

corpus/krapavin2000-test/627792.txt
multimedia
sessions
disk
period
latency
bandwidth
session
buffer
equ
video
media
starvation
seek
ms
consumption
latencies
storage
file
audio
leftover
playout
device
ntsc
playback
mb
head
delivery
layout
buffering
transfer
streams
utilization
consumed
switching
timing
rate
allocation
intermedia
polimenis
track
rot
rotate
scheduling
switch
cylinder
compression
vbr
organization
interleaved
retrieval
files
rotating
block
raid
optical
rates
contiguous
unpredictable
disks
policy
interleaving
mbyte
bytes
throughput
recording
cbr
schedule
robin
theta
subtitles
rangan
mpeg
compressed
magnetic
requirements
dt
acceptance
conventional
tasks
khz
arm
cross
physical
transfers
fig
shares
round
uncompressed
miodrag
potkonjak
duration
comprised
heterogeneous
tracks
min
accept
server
013
tt
jpeg
striping
mth
meet
retrieved
placement
uncommon
667
lightly
qu
accepted
consume
discipline
synchronization
recorded
normalize
pt
sweeping
text
arrive
service
variance
gang
continuous
refined
dependent
requirement
layouts
availability
frame
surface
cylinders
positioning
demand
park
mbytes
doubly
admission
medium
rotational
devices
blocks
object
streaming
request
oe
insertions
163
permitting
rotation
loaded
enormous
plus
retrieves
subsystems
ith
synthesis
bits
kb
starves
malena
st41650n
steams
abstractmultimedia
kandlur
heon
reserviced
equs
length481216200
kiessling
1407
gss
gemmell
11172
weikum
mesarina
shortages
yeom
timedia
kyungoh
spects
enveloped
aerts
subsys
nerjes
tucson
joep
wren
multizone
probabilistic
heads
organizations
differing
drive
busy
read
177
byte
max
originating
chose
multimedia sessions
t period
disk bandwidth
multimedia data
of multimedia
period t
the disk
file system
latency i
non multimedia
seek latency
r c
the period
min period
of sessions
multimedia object
t latency
session i
for multimedia
a multimedia
t min
the buffer
multimedia session
buffer requirement
the multimedia
the file
period is
consumption rate
dependent multimedia
a disk
c i
storage organization
period length
multimedia processes
each multimedia
a period
mb s
of disk
multimedia file
non real
time dependent
buffer space
e t
other non
working period
layout model
different media
multimedia objects
starvation rate
consumption rates
the bandwidth
real time
by equ
the starvation
for session
system must
all multimedia
n head
ms e
sessions plus
rotating disk
multimedia tasks
max period
task switching
sessions supported
switching latencies
i latency
i shares
disk seek
the seek
period for
period in
bandwidth requirement
each session
disk storage
organization for
between sessions
period ms
the leftover
ms 2
compression ratio
the consumption
period the
a rate
bandwidth and
and buffer
sessions is
latency between
refined model
disk latency
bandwidth for
theta r
buffer requirements
bound t
buffer allocation
lower bound
disk access
of period
bandwidth utilization
disk for
latencies and
disk array
bandwidth requirements
video and
sessions m
period period
the contiguous
media objects
session switching
additional multimedia
polimenis 14
access schedule
period must
compressed ntsc
equ 10
audio data
hard requirements
mb frame
equ 8
of starvation
ms buffer
allocation bytes
mbyte s
quality video
dt theta
sessions can
intermedia synchronization
support multimedia
sessions 4
media data
t max
continuous media
be accepted
a physical
period to
theta t
meet the
data transfer
for disk
transfer rate
to transfer
rate r
consumed by
in equ
equ 7
of supported
sessions in
physical data
optical disks
physical storage
seek latencies
robin scheduling
probabilistic model
to support
multimedia applications
the acceptance
and audio
of audio
free memory
storage device
latency and
i r
t i
during data
bandwidth consumed
disk head
system synthesis
transfer data
to disk
round robin
accept a
the heterogeneous
data organization
timing requirements
and latency
time tasks
head to
in fig
a block
upper bound
to meet
on demand
data at
for non
system cannot
memory for
the lower
buffer constraints
r latency
continuous retrieval
quality audio
that multimedia
period be
next track
conventional rotating
system transfers
delivery requirements
buffer consumption
value units
required buffering
of multimedia sessions
period t period
r c i
set of multimedia
the file system
t min period
number of multimedia
the period t
number of sessions
the buffer requirement
time dependent multimedia
of disk bandwidth
other non real
non real time
dependent multimedia data
the starvation rate
a multimedia file
for non multimedia
non multimedia processes
each multimedia session
file system must
multimedia file system
for multimedia data
at a rate
the seek latency
bandwidth and buffer
for other non
session i shares
for multimedia sessions
i latency i
all multimedia sessions
the period length
ms e t
t max period
t period in
the lower bound
for session i
can be accepted
from the disk
a period t
for a set
of multimedia data
r c r
of time dependent
data at a
multimedia sessions plus
period must be
accept a set
of period t
non multimedia tasks
to support multimedia
sessions m is
dt theta n
additional multimedia sessions
bandwidth consumed by
disk bandwidth and
disk seek latency
a physical data
sessions plus the
a multimedia object
min period is
storage organization for
a working period
t latency i
requirements of multimedia
ms buffer allocation
period is chosen
t period to
period ms buffer
bound t max
within a block
consumption rate for
ms 2 oe
organization for multimedia
theta n head
multimedia sessions can
for a multimedia
t period is
physical data organization
of sessions supported
free memory for
multimedia sessions m
buffer allocation bytes
multimedia data we
working period t
e t latency
a rate of
on the disk
to meet the
each session i
for time dependent
the disk for
period in order
rate r c
round robin scheduling
data transfer rate
the multimedia data
multimedia data are
acceptance of a
upper bound t
the bandwidth requirement
on a disk
to transfer data
period for a
to accept a
c i r
from a disk
i r c
the disk head
a set of
arrive at the
time requirements of
head to the
of a period
real time tasks
the acceptance of
real time requirements
to the amount
amount of data
must be greater
in fig 2
sessions including bandwidth
the consumption rates
of supported sessions
latency r c
layout model a
the multimedia object
buffer requirement is
disk access schedule
the lightly loaded
file system cannot
that the starvation
switching latency between
latency i period
video audio text
the mth session
placement of audio
sessions originating from
physical storage organizations
theta t min
7 we know
max period is
i busy until
seek latency and
period is then
seek latencies and
equ 7 we
a rate r
are five multimedia
latency between sessions
t period must
quality video uncompressed
t period for
i r period
parallel disk array
multimedia data delivery
data arrive at
equ 11 we
5 mb s
i theta t
a disk it
as a physical
increase the period
multimedia sessions and
file system can
task switching latencies
data from or
data read from
availability of sufficient
amount consumed during
1 4 mb
that multimedia data
file system transfers
from equ 11
requirement is minimized
multimedia object as
consumption rates for
average seek latency
potkonjak system synthesis
gamma r c
additional disk bandwidth
compressed ntsc video
period otherwise the
period length t
multimedia sessions originating
the next track
of the multimedia
sessions is the
choosing the length
a single device
be recorded at
4 mb s
disk bandwidth r
number of supported
to its consumption
period be the
grouped sweeping scheme
for each multimedia
for the acceptance
period to meet

corpus/krapavin2000-test/627797.txt
dma
itemsets
site
polling
candidate
mining
association
cd
sites
pruning
counts
itemset
apriori
ch
db
heavy
skewness
database
sup
count
locally
dhp
ll
maxsup
partitions
globally
databases
broadcast
candidates
bed
gen
exchange
scan
rules
t10
hl
discovery
hash
bc
pdm
i4
partition
thresholds
message
500k
messages
secondary
iteration
ratios
minsup
ab
clifton
900k
75
threshold
requests
experiment
broadcasts
collect
reduction
prune
shichao
kubat
buckets
items
hashing
primary
zaki
lp
transaction
vaidya
fef
fefg
d500k0
fbc
adaptation
request
mohammed
plotted
scanning
pruned
sequential
away
jaideep
fab
ranges
ling
centralized
horizontally
273
broadcasted
hongjun
xindong
pvm
synthesizing
sigkdd
sent
chris
zhang
feng
miroslav
chengqi
100k
jiawei
synthetic
acts
partitioned
broadcasting
vipin
parthasarathy
sp2
deduced
picked
han
subsets
gg
1000
transmitted
finds
lemma
privacy
chart
srinivasan
sizes
against
multidimensional
synchronization
scans
vertically
receive
evolutionary
ac
6000
clustering
jeffrey
tutorial
ef
ninth
wei
popular
centers
reply
recorded
send
kantarcioglu
cdg
dbminer
1037
hbc
0026
gudes
065
jingkai
silvestre
pendharkar
como
literatures
wthrich
ycel
d500k11
parag
fbcg
sap
d500k501502
bcg
jianning
acg
databasess
sanseverino
d500k40012002
unfavourable
perrizo
rgc
700k
netweaver
saygin
12100k
legler
bar
sends
rs
originating
kumar
gamma
effective
responsible
communication
lu
workstations
receives
300k
murat
2400
masaru
rozenberg
1534
kargupta
morinaga
1387
lekkala
candidate sets
site s
support counts
locally large
association rules
at site
large itemsets
of candidate
local pruning
polling site
candidate set
globally large
x sup
local support
s i
large at
support count
count exchange
in dma
global pruning
dma is
dma and
mining of
counts of
itemsets in
of association
the candidate
each site
apriori gen
every site
other sites
mining association
itemset x
dma cd
ch k
heavy at
and cd
the support
the apriori
the polling
the sites
k itemsets
a site
minimum support
ch i
db i
heavy itemsets
the heavy
an itemset
sets generated
in db
a polling
in ch
rules in
polling requests
of dma
message size
support threshold
i k
the local
data mining
global support
itemsets at
sets at
ll i
cd figure
the database
distributed database
apriori algorithm
0 75
association rule
of mining
secondary range
against cd
primary range
dma against
75 minimum
polling sites
heavy k
maxsup x
s 1
sets in
itemsets are
itemsets found
are locally
for mining
the mining
is heavy
distributed databases
a candidate
x is
the partitions
t10 i4
distributed mining
total message
message communication
test bed
these candidate
partition db
algorithm dma
in ll
dma has
between dma
data skewness
of sites
the ratios
l k
each candidate
the large
the partition
parallel mining
for count
the itemsets
site of
sup i
for support
gen function
prune away
2 candidate
large k
sites in
sites the
transactions in
knowledge discovery
not locally
all large
hash tree
k itemset
partitions are
s j
messages for
to collect
execution time
on knowledge
is locally
polling request
sets ch
that dma
hl i
sites s
the dma
than cd
5 databases
secondary ranges
cd are
its subsets
remaining candidate
counts and
parallel environment
s 3
size 2
first experiment
50 1
1 50
the reduction
candidates in
s 2
of apriori
site for
of message
experiment is
experiment the
and secondary
the globally
th iteration
k to
rule mining
direct application
database db
set generation
sets per
1 itemsets
lp i
away some
set x
x must
subsets are
at s
database is
a distributed
of items
and data
scan on
database mining
generalized association
be locally
rules from
adaptation of
iteration the
reduction in
of transactions
exchange for
large 2
the counts
message sizes
itemsets for
pruned away
size reduction
average number
sizes in
site s i
of candidate sets
at site s
locally large at
support counts of
local support counts
the local support
the candidate sets
number of candidate
set of candidate
mining of association
the support counts
candidate sets in
association rules in
of association rules
large at site
dma and cd
the other sites
mining association rules
candidate sets generated
a site s
at each site
candidate sets at
the local pruning
a candidate set
an itemset x
the large itemsets
each candidate set
are locally large
candidate sets and
heavy at site
ch i k
each site s
counts of the
site s 1
large itemsets in
a polling site
x sup i
the heavy itemsets
is locally large
dma cd figure
globally large itemsets
support count exchange
the polling site
candidate set x
all the sites
of mining association
a distributed database
for each candidate
75 minimum support
is heavy at
rules in distributed
1 0 75
itemset x is
dma against cd
0 75 minimum
these candidate sets
heavy k itemsets
number of sites
candidate sets are
50 1 0
the apriori algorithm
at a site
1 50 1
the mining of
x is locally
not locally large
its subsets are
of large itemsets
polling site of
the apriori gen
for support count
x is heavy
for count exchange
applying the apriori
between dma and
sets in ch
local support count
be locally large
the globally large
apriori gen function
large k itemsets
at every site
ch k is
support counts and
large itemsets are
rules in a
in distributed databases
for mining association
must be locally
minimum support threshold
all its subsets
size 2 candidate
counts of all
the support threshold
the first experiment
distributed mining of
of the candidate
k th iteration
if an itemset
problem of mining
gen function on
and cd are
x is globally
2 candidate sets
in ll i
itemsets at each
exists a site
ll i k
large itemsets found
as a polling
remaining candidate sets
globally large k
of support counts
candidate set generation
candidate sets per
global support counts
the heavy k
k itemsets at
global support count
the secondary range
in ch i
the global support
count exchange for
partition db i
local pruning and
candidate sets ch
transactions in db
candidate sets by
prune away some
in ch k
and secondary ranges
support count of
site s 3
the primary range
performance of dma
message size reduction
is globally large
x must be
k the set
the set of
of the apriori
to prune away
site s 2
set of large
direct application of
association rule mining
of the itemsets
all the candidate
s i then
the total message
a direct application
o n messages
the number of
data engineering v
of transactions in
knowledge and data
and data engineering
average number of
on knowledge and
the remaining candidate
the candidate set
l k gamma1
parallel mining of
itemsets in the
generalized association rules
transactions on knowledge
in a distributed
the ratios of
k to denote
i k to
i k the
primary and secondary
on the partition
cd t10 i4
the dma algorithm
candidate set at
sites s j
sets per site
the partition db
candidate set where
for every candidate
large at s
ratios between them
globally large then
large in s
of message communication
heavy itemsets at
their support counts
is pruned away
sets at every
5 databases for
i acts as
some candidate sets
itemsets in db
sets generated at
x large sites
the size 2
of dma and
all the 5

corpus/krapavin2000-test/627803.txt
itemsets
mining
association
itemset
frequent
apriori
count
processors
processor
candidate
candidates
sizeup
pass
hash
counts
serial
redistribution
sp2
scaleup
datasets
zaki
rules
transaction
response
mohammed
database
filter
apriorihybrid
jiawei
prune
pruning
han
discovery
100mb
parthasarathy
abcd
partitioning
multiprocessor
disks
asynchronously
gamma1
gregory
communication
items
offs
srinivasan
buehrer
riedel
powerparallel
subproblem
databases
ck
aggregate
sigkdd
kitsuregawa
repartitioning
laks
lakshmanan
schuster
masaru
assaf
keng
synchronize
speedup
dataset
sigmod
carson
pdm
wei
disk
discovering
kubat
chiu
choudhary
yen
wolff
leung
ab
passes
agrawal
raymond
liao
newsletter
counting
broadcast
karypis
vipin
alok
faloutsos
mb
christos
5g
f1
shaowei
ghoting
xiaohua
ff1
repartitioned
daehyun
25mb
24rd
shiby
cheung
explorations
workloads
parallelization
hu
kai
chen
generation
trade
288
4g
ogihara
kan
ruoming
gagan
eui
amol
abcde
ganger
vanneschi
nagle
mitsunori
balancing
sang
ling
jm
mpi
25th
synchronization
273
bases
794
sarawagi
hongjun
kurc
coppola
sunita
tahsin
shichao
2gb
confidence
counted
associations
prefix
feng
intensive
massimo
mahmut
rakesh
miroslav
scalable
record
2000
xia
kandemir
kuang
saltz
gmbh
physica
li
develops
jin
yu
steve
ibm
rule
lk
1998
kim
exploits
configurations
node
engineering
heidelberg
kumar
dr
smart
david
conscious
shih
343
nothing
george
ng
winner
heuristically
exchanged
zhang
anthony
southeast
nguyen
join
446
song
partition
tuples
ning
337
association rules
frequent itemsets
distribution algorithm
candidate distribution
data mining
each processor
mining association
hash filter
the count
the candidate
processor p
count distribution
other processors
data distribution
for mining
l k
candidate generation
mining of
the apriori
the serial
k gamma1
local data
response time
serial algorithm
aggregate memory
the prune
distribution algorithms
prune step
association rule
rule mining
parallel algorithms
candidates in
p i
the response
candidate set
an itemset
the frequent
c k
apriori algorithm
the database
the itemsets
and data
the itemset
c i
response times
all frequent
three parallel
apriori candidate
the processors
minimum support
on knowledge
parallel mining
itemsets are
i k
the candidates
support counts
problem specific
mining and
engineering v
data engineering
of association
per node
knowledge discovery
count algorithm
frequent itemset
count and
processors to
knowledge and
every pass
candidate algorithm
redistribution pass
srinivasan parthasarathy
jiawei han
the pass
of mining
j zaki
mohammed j
pattern mining
of candidates
parallel data
of processors
generating rules
rules data
support count
rules acm
of transactions
itemsets in
of frequent
mining on
trade offs
next pass
rule generation
distributed mining
distributed association
record v
sigmod record
mining algorithms
large databases
in parallel
processor has
candidate sets
generation procedure
the multiprocessor
shared nothing
of data
2 p
data bases
its local
the rule
and asynchronously
steve c
time normalized
kai sang
candidate itemset
alok n
c chiu
32 node
larger datasets
six datasets
mb per
k counts
distributed smart
usage synchronization
dr i
carson kai
n choudhary
raymond t
complete l
local candidate
sang leung
smart disks
global c
ran wolff
chiu wei
gregory buehrer
schuster ran
subproblem the
on very
items in
acm sigmod
3 p
acm sigkdd
first pass
discovery v
large data
to synchronize
the hash
association mining
mining with
proceedings of
a hash
database size
data tuples
communication memory
assaf schuster
of apriori
o intensive
pass 1
entire dataset
liao alok
s lakshmanan
christos faloutsos
wei keng
w cheung
an sp2
intensive workloads
generating c
keng liao
of trade
join step
t ng
masaru kitsuregawa
laks v
ling feng
k from
a processor
for association
single pass
all other
rules from
and knowledge
the processor
rules on
counts for
ieee transactions
transactions on
i o
i generates
and candidate
pass is
candidate itemsets
k itemsets
whose support
hash tree
l j
15 n
v 15
k using
the items
this algorithm
mining association rules
processor p i
the count distribution
l k gamma1
count distribution algorithm
for mining association
data distribution algorithm
candidate distribution algorithm
the candidate distribution
the prune step
the serial algorithm
association rule mining
c i k
the frequent itemsets
all other processors
the response time
count and data
apriori candidate generation
the apriori candidate
the count algorithm
three parallel algorithms
of association rules
data engineering v
knowledge and data
and data engineering
on knowledge and
transactions on knowledge
of mining association
n 2 p
number of processors
each processor p
of the serial
l i k
the apriori algorithm
to the response
parallel data mining
algorithm for mining
mining of association
parallel mining of
problem of mining
proceedings of the
a hash filter
prune step of
candidates in c
distribution algorithm is
the candidate algorithm
data distribution algorithms
and data distribution
mohammed j zaki
as the database
the data distribution
data mining and
all frequent itemsets
association rules data
candidate generation procedure
for the count
and knowledge discovery
mining and knowledge
sigmod record v
acm sigmod record
n 3 p
of the candidate
engineering v 15
the next pass
its local data
distributed mining of
large data bases
a shared nothing
the candidate set
response times for
amount of data
very large data
on very large
ieee transactions on
from all other
the first pass
association rules on
knowledge discovery v
the response times
c k counts
next pass the
steve c chiu
kai sang leung
k from c
schuster ran wolff
chiu wei keng
use of aggregate
david w cheung
the hash filter
smart disks for
pattern mining on
time normalized with
of candidate generation
offs between computation
between computation communication
memory usage synchronization
usage synchronization and
the six datasets
use of problem
computation communication memory
communication memory usage
the complete l
of trade offs
of problem specific
carson kai sang
of aggregate memory
step of candidate
response time normalized
in every pass
2 processor p
o intensive workloads
i k sets
complete l k
subproblem the problem
disks for i
every other processor
liao alok n
the join step
with minimum support
alok n choudhary
c chiu wei
rules acm sigmod
raymond t ng
assaf schuster ran
spectrum of trade
distributed smart disks
problem specific information
number of candidates
k using the
association rules in
in large databases
i o intensive
serial algorithm the
association rules acm
laks v s
synchronization and the
support counts for
processors to synchronize
wei keng liao
keng liao alok
rules data mining
record v 27
the entire dataset
of the itemset
rules on a
v s lakshmanan
v 15 n
international conference on
parallel algorithms for
this set has
of all frequent
the database size
of data per
processor has the
mining of frequent
parallel algorithms are
processors is increased
p i generates
mining for association
distributed association rule
the count and
rules in parallel
and the use
data bases p
conference on very
mining proceedings of
association rules the
is the response
each processor can
sigkdd explorations newsletter
for i o
normalized with respect
explorations newsletter v
the processor p
trade offs between
acm sigkdd explorations
a spectrum of
times for the
of the count
other processors in
the exact same
data mining for
at the end
that each processor
for association rules
intelligent data analysis
27 n 2
data analysis v
a single pass
memory of the
n 4 p
parallel databases v
in l k
and parallel databases
n 1 p
to every other
the items in
parallel and distributed
the end of
on a shared

corpus/krapavin2000-test/627813.txt
propagation
schema
print
document
dictionary
wrapper
trip
refinement
behavioral
reprogramming
print_itinerary
itinerary
directive
void
daytrip
ff
alternation
reuse
pattern
patterns
adaptiveness
pd
demeter
g_print
doc
prefix
annotation
fi
polymorphic
date
annotations
departure
oriented
printing
fragments
page
hooks
suffix
operational
reachable
specifications
wrappers
database
object
vertex
annotate
evolution
ffi
fg
arrival
specification
modifications
binding
directives
legal
scope
body
bypassing
seamless
modification
fl
reused
itineraries
ident
daytrips
structural
ma
sig
mechanisms
pp
pages
clause
vertices
ps
queries
polymorphism
manually
ea
promotes
compatible
compatibility
nextloc
locationlist_iterator
eachloc
locationlist
article
query
title
classes
locations
encourage
signature
reusability
refined
abstraction
avoided
9u
oql
incremental
traversed
adaptation
schemas
cooperating
gamma
text
syntactically
programs
navigational
checker
semantics
nextday
daytriplist
seamlessness
lpa
eachday
9ffi
daytriplist_iterator
writers
ec
prints
contracts
activity
string
consistency
hk
character
inheritance
designers
proposition
avoiding
invalid
edges
objects
injected
travel
affiliate
scopes
propagations
location
city
iff
differently
specialized
anticipation
suf
rip
hook
content
code
salient
identifies
modified
robustness
triple
compile
reusable
8j
repetition
effort
adaptive
attached
seamlessly
specifying
old
tm
persistent
transitivity
enhancing
languages
verified
reorganization
contract
mechanism
day
interface
executed
paths
conformance
formal
concept
raising
semantically
writing
emphasizes
visited
argue
nonempty
ling
traversal
minimized
restructuring
redefine
target
dbms
agency
path
motivating
alberta
requirement
frontiers
propagation pattern
propagation patterns
of propagation
class dictionary
dictionary graph
the propagation
pattern refinement
print document
behavioral refinement
a propagation
pattern print
propagation directive
pattern ff
object oriented
schema modifications
schema modification
doc body
reuse mechanisms
of schema
propagation scope
refinement of
the schema
print itinerary
a behavioral
schema evolution
polymorphic reuse
g print
class vertex
oriented database
this propagation
the trip
to schema
pattern fi
reprogramming of
method annotations
a class
alternation reachable
pattern defined
over g
the demeter
application programs
propagation time
gamma w
from document
patterns and
wrapper of
requirement changes
operational requirement
trip schema
propagation constraints
operation void
refinement mechanism
directive refinement
class structure
given propagation
the wrapper
reachable from
sig m
wrapper order
pd ff
schema changes
dictionary graphs
refined propagation
using propagation
at propagation
is alternation
methods and
to page
code fragments
schema in
reuse of
and queries
2 pd
fi is
the class
construction reachable
hooks of
void print
ps ff
ma ff
class schema
signature refinement
document schema
wrappers of
propagation directives
of print
of methods
evolution in
m fi
and propagation
of class
m ff
u gamma
ffi 1
a schema
demeter system
incremental design
the adaptiveness
adaptiveness of
patterns are
of pattern
and definition
binding of
schema of
specification of
behavioral abstraction
pp refinement
existing propagation
pages page
oriented schema
activity model
operational specifications
manually reprogramming
trip object
print_itinerary void
database specifications
propagation constraint
date g
avoiding or
modified schema
that propagation
ma fi
the reprogramming
ffi 2
of object
the specification
u 0
the polymorphic
to classes
or query
definition 3
pattern is
an object
the prefix
or minimizing
queries due
departure arrival
method interface
definition 11
the behavioral
for propagation
refinement is
the binding
in object
the structural
document to
ff is
be reused
3 ii
classes at
in figure
vertex u
the modified
trip location
g_print daytrips
prefix date
towards schema
suffix wrapper
printing trip
propagation paths
pattern given
target vertices
legal path
construction edges
if propagation
adaptiveness and
method print
operation propagation
print article
database programs
trip itineraries
component pages
detailed itinerary
location departure
alternation edges
body components
print figure
document doc
prefix wrapper
pd fi
body doc
time trip
print detailed
v gamma
code generated
the method
a document
defined over
u v
of operational
path expressions
the existing
compatibility of
defined in
program adaptation
specifications against
query specifications
consistency checker
the hooks
a trip
of propagation patterns
class dictionary graph
the propagation pattern
propagation pattern refinement
a class dictionary
propagation pattern print
behavioral refinement of
a propagation pattern
of propagation pattern
propagation patterns and
refinement of propagation
propagation pattern ff
this propagation pattern
pattern print document
object oriented database
polymorphic reuse mechanisms
a behavioral refinement
methods and queries
of a propagation
propagation patterns are
the class dictionary
due to schema
propagation pattern defined
propagation pattern is
is a behavioral
propagation directive refinement
a propagation directive
propagation pattern fi
alternation reachable from
an object oriented
defined in figure
concept of propagation
using propagation patterns
schema of figure
at propagation time
schema evolution in
the propagation scope
class dictionary graphs
is alternation reachable
fi is a
be a class
of methods and
refined propagation pattern
schema in figure
the wrapper order
wrapper order of
pattern refinement is
pattern fi is
pattern print itinerary
and propagation pattern
operation void print
in an object
of this propagation
the demeter system
the specification of
avoiding or minimizing
to classes at
reprogramming of methods
to schema modification
operational requirement changes
the modified schema
dictionary graph a
construction reachable from
3 ii we
dictionary graph of
a schema modification
propagation patterns can
definition 3 ii
a class vertex
object oriented schema
pattern defined in
propagation scope of
the trip schema
of the propagation
to schema modifications
existing propagation patterns
methods to classes
of print itinerary
the binding of
dictionary graph and
patterns and propagation
in object oriented
in the propagation
of object oriented
queries due to
the adaptiveness of
and the propagation
in the modified
print detailed itinerary
set of propagation
of target vertices
the class structure
the suffix wrapper
doc body components
pattern ff then
with the clause
pattern ff is
reuse mechanisms in
document doc body
v gamma w
prefix date g
directive refinement of
u is executed
over the class
of pattern ff
pattern given in
suffix wrapper of
u gamma w
printing trip itineraries
of ffi 1
g print figure
date g print
the hooks of
wrapper of v
oriented database specifications
propagation patterns with
mechanism for propagation
defined over g
prefix wrapper of
signature refinement of
classes at propagation
propagation pattern given
by using propagation
and queries due
component pages page
the method interface
body doc body
the prefix wrapper
time trip location
propagation pattern the
when a schema
wrapper of u
path from document
if propagation pattern
location departure arrival
a refined propagation
of class dictionary
given propagation pattern
a signature refinement
doc body doc
the code generated
according to definition
the concept of
oriented database system
is a signature
evolution in an
and reuse of
existing object oriented
of the schema
is a propagation
by a triple
figure 7 and
set of class
object oriented systems
the following conditions
incremental design and
propagation patterns to
more specialized propagation
2 pd ff
void this g_print
d doc body
void city print_itinerary
behavioral refinement mechanism
refinement ff fi
above propagation pattern
hooks of this
daytrip prefix date
void locationlist_iterator nextloc
trip print_itinerary departure
dictionary graph for
and database queries
reference object model
of schema evolution
the incremental design
number location departure
ff sig m
location eachloc while
then the prefix
u is alternation
specification of propagation
the above propagation
graph of schema
schema modifications and
from document through
for propagation patterns
to the schema
given class dictionary
the method print
m ff sig
legal paths from
the polymorphic reuse
trip schema with
of schema updates
from document to
propagation patterns we
pattern defined over
of printing trip
print_itinerary departure g_print
trip itineraries in
schema and thus

corpus/krapavin2000-test/627818.txt
imprecision
impamt
lock
locking
updatespeed
compatibility
semantic
transaction
invocation
req
consistency
esr
concurrency
serializability
submarine
rtsorac
safety
locks
request
ot
attribute
import
osition
temporal
object
invocations
la
preconditions
spec
export
oesr
accumulation
granted
database
epsilon
exportimp
getspeed
speed
requested
priority
precondition
readaffected
arguments
item
requests
cf
restrictions
attributes
logical
rtdbms
enforcement
accumulated
temporally
importimp
r2b
writeaffected
returnargs
return
writes
serializable
queue
oriented
interleavings
jz
released
exported
imprecise
affected
mechanism
timing
execute
interleaving
limit
inter
getp
valuej
r2a
incp
locked
endif
restore
commutativity
schedule
amounts
arg
r1
act
simultaneous
concurrently
correctness
sensor
wj
bearing
databases
argument
evaluates
old
read
objects
limits
ffl
invoked
invariant
bounding
deadline
threatened
impamts
incposition
activelocks
riteaffected
sstate
getposition
reads
update
active
enforcing
increment
updates
tracking
differs
maintains
country
queued
lc
mi
manager
conjunctive
restored
designer
semantically
2pl
ships
safe
meets
semantics
retried
combat
enqueue
inconsistency
trade
amount
restriction
clause
yes
maintain
executes
sufficiency
traded
restores
specifies
relaxing
scheduling
items
held
metric
exec
imported
transactions
precise
releasing
contact
meeting
specify
prototype
constraint
blocking
gamma
violated
management
predicate
restricted
js
lb
solaris
updated
allowed
accumulates
synchronizing
protocol
considerations
accumulate
releases
involving
computes
constrains
frontiers
criterion
allowable
concentrates
constraints
air
compatible
enforce
offs
relationships
ensures
returned
architechture
hpr
getcountry
semantic locking
compatibility function
of imprecision
semantic lock
temporal consistency
m req
method invocation
imprecision that
locking technique
the imprecision
locking mechanism
the compatibility
r impamt
the semantic
concurrency control
step la
imprecision in
logical consistency
data ffl
a impamt
speed attribute
ffl spec
return argument
a transaction
invocation request
inter object
a semantic
control technique
ot safety
return arguments
lock request
real time
transaction t
method invocations
import limit
object type
restricted semantic
lock is
la 2
limit r
initial imprecision
object oriented
write affected
the object
data item
epsilon serializability
spec a
m 1
the rtsorac
imprecision amount
affected set
updatespeed 10
cf m
future method
time object
impamt new
amount of
lock for
of updatespeed
m act
object safety
an object
step c
the amount
written to
t x
and transactions
bounded imprecision
the method
the preconditions
the speed
item x
the restricted
submarine object
rtsorac model
the submarine
imprecision accumulation
imprecision t
imprecision procedure
la 1
impamt old
data safety
priority queue
oriented database
t read
the database
the lock
a method
our semantic
an attribute
input argument
general restrictions
export limit
for cf
remains invariant
safety remains
lock requests
a lock
after step
object s
timing constraints
s return
imprecision limits
active lock
logical imprecision
safety t
updatespeed 2
amount for
imprecision for
updatespeed 1
invariant after
is accumulated
and imprecision
safety thus
object constraint
invocation of
attribute a
consistency constraints
time concurrency
our technique
the transaction
object o
request for
for method
10 6
the value
data temporal
be accumulated
m 2
a simultaneous
in step
technique is
the mechanism
of esr
exported by
a future
oriented databases
is requested
active locks
compatibility between
potential increase
1 updatespeed
impamt is
importimp r
introduce imprecision
simultaneous method
bound imprecision
speed value
writeaffected m
readaffected m
enforcement rule
exportimp a
technique under
imprecision to
p osition
imprecision amounts
argument r
invocation m
for ot
control work
imprecision into
affected sets
cf updatespeed
by updatespeed
imprecision is
technique maintains
for m
time databases
of method
r using
metric space
of methods
transaction s
correctness criterion
true only
the return
for compatibility
t update
value time
may return
precise data
of epsilon
input arguments
to true
introduced into
value written
transaction is
consistency for
is released
request a
in priority
database manager
limit t
its return
requested for
objects and
the write
of attributes
the concurrency
for object
amount of imprecision
the semantic locking
the compatibility function
semantic locking mechanism
semantic locking technique
a semantic lock
of imprecision that
data ffl spec
concurrency control technique
method invocation request
the speed attribute
restricted semantic locking
the restricted semantic
semantic lock request
ffl spec a
import limit r
a method invocation
imprecision in the
step la 2
in step la
locking technique is
future method invocation
time object oriented
real time object
the amount of
our semantic locking
the imprecision amount
a future method
semantic lock is
data item x
object oriented database
the method invocation
the object type
initial imprecision procedure
compatibility function for
semantic lock for
safety remains invariant
step la 1
updatespeed 10 6
imprecision t x
write affected set
the semantic lock
the rtsorac model
for cf m
of r using
the object s
the value of
time concurrency control
of the object
the imprecision that
remains invariant after
to data item
imprecision that m
r impamt new
for a simultaneous
imprecision that is
data temporal consistency
inter object constraint
after step la
the write affected
imprecision amount for
and temporal consistency
real time concurrency
true only if
lock is released
lock request for
of the semantic
technique is used
is the requirement
the data item
object oriented databases
methods of the
for the speed
temporal consistency constraints
s return argument
of m req
if the restricted
a data ffl
return true only
may return true
for ot safety
imprecision that may
method invocation m
of updatespeed 10
transaction t with
that m req
an object type
cf updatespeed 1
invariant for every
function for cf
1 updatespeed 2
invocation of updatespeed
the initial imprecision
updatespeed 1 updatespeed
an inter object
la 1 for
concurrency control work
transaction t update
of imprecision in
locking technique maintains
invariant after step
imprecision that could
return argument r
transaction t read
of imprecision for
potential increase in
two general restrictions
imprecision is accumulated
a potential increase
r impamt old
lock for m
a return argument
objects and transactions
affected set of
its return arguments
of a transaction
real time databases
in the write
in the database
value of r
general restrictions on
written to a
of epsilon serializability
limit t x
lock request is
an input argument
lock is requested
and a semantic
value written to
the requirement for
t with respect
restrictions on the
a transaction is
the concurrency control
of the attribute
it differs from
for a future
in the value
on the amount
to a by
of an object
a metric space
based concurrency control
the priority queue
the value written
an object o
the imprecision amounts
amount for the
time and imprecision
temporal consistency of
impamt new yields
a 2 writeaffected
is a future
the update takes
write affected sets
s 2 value
the conjunctive clause
cf m 1
original r impamt
in imprecision equal
submarine object type
accumulation must specify
increase in imprecision
method invocation that
combining this relation
ffl spec speed
computes the amount
r 2 returnargs
logical and temporal
and data safety
compatibility function cf
the database manager
if the preconditions
compatibility function evaluation
value of speed
and logical consistency
invocation request m
safety thus ot
on speed is
compatibility function the
export imprecision t
associated imprecision accumulation
limit r gamma
value time and
locking mechanism executes
the return arguments
the return argument
function evaluation in
maintain temporal consistency
m req will
2 returnargs m
argument s 1
safety t o
guaranteed if and
m req exportimp
m req with
if it includes
2 writeaffected m
requirement for ot
t read is

corpus/krapavin2000-test/627837.txt
analogical
reuse
specifications
matching
doublelist
analogies
matches
dbllist
analogy
stack
specification
subproblems
spec
match
query
reusable
expr
similarity
ospl
software
modifies
old
hierarchy
commutative
matchable
cg
expressions
cbr
sort
branch
modification
retrieved
tiered
reqcoll
armp
arguments
equivalence
library
faceted
container
reasoning
reusing
phi
program
schemas
retrieval
distance
candidate
predicate
topelement
addattail
telos
caret
heuristic
connectives
fi
postconditions
lists
operators
ff
pred
push
symbols
matchability
conceptual
theta
clause
reusability
ensures
formal
dershowitz
heuristics
amenable
graphical
similarities
descriptions
cgs
attribution
od
subproblem
projects
universally
associations
postcondition
transformational
permuted
sorted
automated
gg
analogous
sorts
incorporated
minflevel
skolemized
fopl
maiden
trashed
sutcliffe
fms
lassie
conflict
quantified
component
investigations
destructor
carol
widgets
tailorable
scoring
classification
oe
destroy
synthesis
predicates
modifying
retrieving
facilitate
matched
thesaurus
unmatched
atc
cas
distances
relationships
grained
prolog
hierarchies
tail
overviews
precondition
arcs
determination
schema
subsort
pairings
rose
isa
programmer
retrieve
templates
cardinality
frames
development
facilitates
head
facet
customize
attribute
identifier
subsumption
displays
conflicts
pursued
supplied
synthesize
bijective
queue
commutativity
entity
sigma
designs
emphasized
documentation
abstractions
target
logic
t1
effort
browsing
inherit
ancestor
classify
artifacts
return
developer
division
sought
keyword
paradigm
operator
semantic
old_program
old_spec
newelement
bhansali
addathead
algorithsm
didactic
guifa
ail
domainsort
derivational
singlelist
abstractusing
query_spec
xiaodong
query_program
jurisica
spanoudakis
detachattail
matching process
analogical matching
analogical matches
the analogical
matching two
query specification
software reuse
software components
branch subproblems
an analogical
of analogical
the matching
query spec
old program
algorithm match
formal specifications
two terms
sort hierarchy
analogical match
match expr
old spec
two expressions
match term
the query
or branch
based heuristic
distance between
matching algorithm
equivalence class
reusable software
the sort
analogical reasoning
modification process
partial matches
program modification
existing components
the distance
the specification
on analogy
return match
modifies dbllist
method doublelist
case matching
of reusable
order sorted
subproblems are
an existing
specification of
the specifications
analogies between
query specifications
matches two
components that
of software
matches between
specifications the
and query
query component
matches theta
tiered hierarchy
stack ensures
old cases
dbllist ensures
input expressions
between two
of matches
similarity between
an analogy
and branch
two input
the analogies
two tiered
query program
the reuse
the modification
reusable components
components based
the existing
software component
of arguments
specifications of
candidate specifications
reuse system
of analogy
component specification
analogy based
ff 7
reuse framework
dbllist element
existing component
modifies stack
existing specification
argument order
automated reasoning
matching algorithms
domain specific
for matching
of candidate
process generates
match is
for reuse
of specifications
hierarchy of
spec and
input terms
commutative operators
term case
method specification
case based
the software
the method
in algorithm
two operators
similarity based
case 6
component the
formal methods
same equivalence
reuse based
existing program
of graphical
t 2
specification and
od end
specifications is
the matches
begin while
two lists
specification for
based reasoning
reasoning systems
design schemas
top stack
ensures top
requires clause
design family
determine software
program synthesis
projects that
sorted predicate
analogical relationships
identical associations
program old
given component
equivalence based
matches phi
doublelist modifies
match oe
are matchable
e matching
design library
two specifications
7 gg
name identifier
on analogies
candidate components
new subproblems
match else
ensures method
specification level
stack modifies
of doublelist
lists case
predicate connectives
implementation old
existing set
implementation query
method destroy
the similarity
while s
formally specified
square root
domain knowledge
a software
e do
of domain
of similarity
reuse in
operators with
predicate logic
of lists
the or
of partial
between existing
specifications can
conceptual distance
domain analysis
found between
computing similarity
modifying an
specification query
scoring function
sorted specifications
knowledge base
incorporated into
t 1
a query
amenable to
specifications for
two methods
the query specification
analogical matching process
the matching process
the analogical matching
of analogical matches
set of analogical
or branch subproblems
distance between two
an analogical matching
the sort hierarchy
algorithm match term
matching two terms
analogical matches between
of partial matches
based on analogy
case matching two
the analogical matches
in algorithm match
set of matches
branch subproblems are
the distance between
set of partial
for matching two
between two methods
tiered hierarchy of
and query spec
subproblems are generated
an analogical match
matching process generates
algorithm match expr
modifies dbllist ensures
two tiered hierarchy
algorithm for matching
reusable software components
a set of
of reusable software
in the sort
and query specifications
the matching algorithm
components based on
the specification of
let the distance
for software reuse
of software components
components to satisfy
matching two expressions
query specification and
2 be denoted
of matches theta
and branch subproblems
a query specification
the existing components
s e do
while s e
modifies stack ensures
analogical match is
begin while s
specification and the
is used to
between the query
reuse based on
between two components
the modification process
case based reasoning
call this approach
same equivalence class
software components the
components that are
denoted by d
two input expressions
determine software reuse
numbers of arguments
this component the
based on analogies
domain specific information
stack ensures top
the existing specification
method doublelist modifies
order sorted predicate
to determine software
the formal specifications
do od end
old spec and
specifications is used
into the matching
existing set of
program old program
matches two operators
between two expressions
sorted predicate logic
e do od
based heuristic is
a query component
ff 7 gg
an existing set
of candidate components
match else return
ensures top stack
the two tiered
specification query spec
e ff fi
existing and query
spec and query
software reuse a
doublelist modifies dbllist
a given component
the reuse framework
analogical relationships between
match term case
implementation query program
an analogy based
the or branch
d e ff
pair of lists
the predicate connectives
similarity based techniques
a match can
old program to
3 in algorithm
in the modification
stack modifies stack
on the analogical
relationships between the
be denoted by
used to determine
formal specifications of
program that satisfies
match can be
the current problem
an existing program
case 3 in
between the specifications
order sorted specifications
between two terms
components that have
method of a
software reuse based
the matching algorithms
of two input
to software reuse
specifications can be
formal methods to
set of candidate
in order to
incorporated into the
based on the
of the software
the specifications of
satisfy the query
process generates a
generates a set
of software reuse
to satisfy the
the similarity between
we call this
based on similarity
given in figure
to the query
and t 2
1 and t
of similarity between
used to guide
the algorithm for
of the matching
t 1 and
similarity between the
a means for
then the distance
order to increase
specification of the
that gives the
a pair of
applied to the
specification of a
in terms of
matches between old
empty lists case
projects that use
query specification are
the design library
else return case
proposed an analogy
that satisfies query
are generated whenever
head dbllist element
old cases to
generated whenever the
determination of reusable
term g f
sought between the
grained determination of
structure based heuristic
match input two
software reuse the
applying formal methods
a software library
program modification model
be universally quantified
match oe is
question when are

corpus/krapavin2000-test/627843.txt
rp
bucket
dp
overflow
aggregation
tuples
dp2
partitioning
gridfile
partitions
ov
canmerge
overflows
cuts
grid
cfd
sw
utilization
rectilinear
utilizations
nw
buckets
directory
bulk
g1
loading
01
skewed
dimension
gridfiles
94e
tuple
se
000
merge
bin
ne
li
tov
26e
blocksover
89e
quadrants
plot
bins
subranges
aggregate
files
cut
precalculated
3959
subdirectory
00e
precalculation
page
bytes
attribute
mega
unstructured
1034
seconds
partition
session
directories
sparse
blocks
164
headed
column
theta
fit
strip
coordinates
axis
multiattribute
subdirectories
maxfp
overflowed
sorting
aggregating
occupancy
lowerbound
uninterested
buddy
square
hours
file
spaced
post
discovered
nicol
uniformly
disk
columns
horizontal
8j
orders
sampling
plotted
seeks
seek
varied
byte
attributes
creating
capacity
spent
tg
indexing
coordinate
faster
indexed
106
magnitude
lacking
phase
40
physical
synthetic
pairing
g2
highly
minimizes
optimality
poor
megabytes
reals
created
qualified
fluid
fetch
runtime
versus
finds
significantly
quickly
unchanging
effectual
1672
37e
24e
6070
31e
1419
15895
22e
30e
expermental
2958
airflows
probalistic
43e
26600
unstructure
pmr
multikey
12e
expend
aydt
40e
precalculating
symetric
81e
ruth
retrivial
2370
positionally
reword
77200
gisli
5629
logarithmic
rectangle
regions
pre
exposition
conduct
94
vertical
recursion
majority
groups
conversely
irregular
5000
unravel
wings
rotem
subrange
20e
hjaltason
lization
27e
neglects
uti
59e
dora
rundensteiner
geoinformatica
presume
the dp
rp algorithm
the rp
dp algorithm
of partitions
bucket utilization
data sets
total overflow
li et
of tuples
data set
cfd data
ov 1
bulk loading
rectilinear partitioning
bucket utilizations
aggregation phase
grid directory
the gridfile
se j
fixed partitioning
dp dp2
partitioning algorithm
cuts in
dp2 algorithm
o p
each dimension
per page
average bucket
of li
overflow is
tuple size
grid files
000 tuples
dynamic programming
the aggregation
the bucket
tuples per
40 000
of unique
aggregation post
01 7
pre aggregation
overflow free
01 8
post aggregation
call merge
ne se
if canmerge
partitioning session
nw ne
partitions pre
highly skewed
then call
the grid
of cuts
the data
aggregation algorithm
bucket capacity
94e 01
unique attribute
ne j
rp algorithms
maximum domain
our aggregation
physical partitioning
the partitioning
1 j
grid file
algorithm is
sw j
and rp
loading of
dp and
partitions in
computation time
algorithm required
nw sw
8 89e
dp2 and
sw se
26e 01
algorithm dp
89e 01
tuple data
canmerge nw
the dp2
8 26e
tuples fit
dp2 algorithms
merge nw
and dp2
sparse relative
u 2
plot the
r k
tuples in
we plot
a bucket
partitions is
skewed data
the run
a partitioning
domain value
our partitioning
for 40
fit per
more computation
one dimension
sorting the
sets are
utilizations for
the tuple
uniformly distributed
the buckets
other dimension
mega bytes
t log
two phase
run time
faster than
partitioning is
the dynamic
to partition
utilization is
directory is
of subranges
g1 a
the ov
g1 b
four orders
phase bulk
seconds versus
cut set
new blocks
utilization bucket
50 tuples
overflow equals
columns headed
6 94e
the utilizations
no bucket
which overflow
a gridfile
grid cfd
aggregation partitions
byte tuples
our cfd
g1 c
logical partitioning
tov 1
partitions needed
00e 01
precalculation of
8 00e
overflow blocks
et al
present results
distributed data
n theta
for highly
tuples the
the tuples
dimension we
p time
2 i
c 1
attribute values
for bulk
in li
one bucket
aggregation is
overflow and
1 aggregate
unique values
log u
no overflows
phase algorithm
partitioning given
partitions p
the li
bucket overflows
j then
creating the
orders of
tuples and
the overflow
unstructured grid
algorithm as
size increases
we present
versus the
of buckets
an overflow
programming solution
are sparse
theta n
our algorithm
in each
i j
the rp algorithm
number of partitions
the dp algorithm
rp algorithm is
number of tuples
li et al
the data set
in each dimension
the dp dp2
cfd data sets
number of unique
the grid directory
the total overflow
than the dp
ov 1 i
of the dp
the number of
pre aggregation post
j then call
aggregation post aggregation
of li et
partitions in each
bulk loading of
then call merge
tuples per page
the aggregation phase
partitions pre aggregation
k 1 j
the dynamic programming
of partitions in
run time of
data sets are
total overflow is
of unique attribute
the dp and
and rp algorithms
the bucket utilization
unique attribute values
r k 1
o p 2
we plot the
of the rp
of cuts in
cuts in the
the run time
1 i j
the data sets
uniformly distributed data
call merge nw
plot the computation
dp and dp2
for 40 000
set of cuts
rp algorithm dp
for the dp
dp dp2 algorithm
for highly skewed
and dp2 algorithms
our partitioning algorithm
nw sw j
rectilinear partitioning algorithm
40 000 tuples
of tuples per
dp dp2 and
that of li
8 26e 01
average bucket utilizations
tuples fit per
nw ne j
sparse relative to
of partitions is
sw se j
to n theta
the average bucket
of the gridfile
the dp2 algorithm
dp2 and rp
8 89e 01
a fixed partitioning
tuple size increases
maximum domain value
if canmerge nw
se j then
1 1 j
ne se j
relative to n
dp algorithm is
faster than the
the r k
the other dimension
the tuple size
of tuples in
is o p
time of the
in one dimension
we present results
2 u 2
in the other
the computation time
given a fixed
bucket utilization bucket
fit per page
an overflow free
number of subranges
in seconds versus
average bucket utilization
axis is logarithmic
94e 01 7
j 1 aggregate
the maximum domain
present the utilizations
seconds versus the
unstructured grid cfd
o p time
theta 2 i
highly skewed data
aggregation phase is
of partitions needed
sorting the tuples
algorithm for bulk
100 000 tuples
for bulk loading
grid directory is
no bucket overflows
bucket utilization is
the li et
are sparse relative
2 i theta
post aggregation partitions
of unique values
two phase bulk
utilization bucket utilization
the utilizations for
tuple data set
of the aggregation
precalculation of the
8 00e 01
into one bucket
cuts in one
tov 1 1
6 94e 01
the bucket capacity
the ov 1
a partitioning session
of partitions p
algorithm dp algorithm
i theta 2
four orders of
aggregation partitions pre
n theta n
side of figure
orders of magnitude
1 j and
utilizations for the
in li et
two phase algorithm
size increases the
the grid file
and 100 000
dynamic programming solution
the y axis
attribute values in
algorithm is used
find the smallest
which the total
synthetic data sets
computation time in
versus the number
we present the
of the data
and y coordinates
to be created
data set for
magnitude faster than
present results for
a 2 are
y axis is
tuples in the
a binary search
of magnitude faster
data sets in
00e 01 8
each chosen from
000 tuples respectively
000 the rp
define the first
set into r
01 8 89e
algorithm of li
times more computation
consider how the
find c 2
retrieval of subsets
loading data sets
note there is
nw ne se
rp algorithm for
22 8 26e
maxfp 2 u
in bucket utilization

corpus/krapavin2000-test/627846.txt
dql
default
query
defaults
datalog
companies
credulous
queries
barilla
valuation
expressive
saiwa
company
eiter
logic
qdql
cadoli
database
stable
recognizable
boolean
skeptical
strategic
rst
eter
gottlob
ice
diagnostic
cf
tuple
propositional
semantics
mary
relational
melts
frutto
fuses
hd
electric
trust
facts
abductive
oce
normal
np
theories
tuples
bulb
diagnosis
circuit
predicates
eects
troubleshooting
explanation
denable
prog
comp
ground
denes
computable
strat
databases
jw
expressiveness
specic
languages
sentence
sue
producers
sold
mgr
denition
existential
extensional
language
polynomial
fragment
resistors
pacist
mbd
nmr
resistor
seminormal
fbarilla
recognizability
aul
relations
formula
inst
leone
disjunctive
schemata
sell
xed
semi
fragments
instantiation
rules
reasoning
products
monotonic
deciding
melting
wine
brave
background
nite
nicola
atom
wrt
belongs
dened
answer
predicate
negation
pfeifer
atoms
vi
extension
explanations
subclass
intensional
causes
paul
married
battery
light
yes
schema
cautious
oracle
collapse
expressible
rela
satised
nc
entailment
cont
fuse
saiwag
nies
melted
ew
quaker
oces
compa
fbulb
adults
amperage
pasta
noncollapsing
formalisms
arity
gerald
reiter
quantier
agreements
resistance
gd
power
prerequisite
voltage
pspace
universe
captures
98
extensions
managers
nonmonotonic
satises
formulas
informatica
symptom
observa
melt
conjectured
express
hypotheses
false
broken
exp
meaning
intuitive
continued
remark
exceptional
dlv
faber
republican
scarcello
malfunctioning
perri
simona
greco
roma
capture
ex
symbols
inclusion
observations
default logic
of dql
default theory
dql queries
query language
o query
dql is
expressive power
boolean dql
the query
q dql
datalog stable
in dql
normal dql
database instance
dql in
semi normal
a query
that dql
p recognizable
dql i
instance w
the defaults
the expressive
boolean query
default rules
query languages
hd w
dql and
dql query
a dql
query is
i o
normal default
open defaults
p eter
a default
in datalog
the default
eiter and
default theories
query q
gottlob default
queries precisely
default query
precisely capture
maximal trust
cadoli eiter
o ice
rst order
q q
of companies
class p
order logic
relational databases
extension of
an extension
o queries
small o
and gottlob
the database
background knowledge
queries computable
so 98
defaults in
is p
the credulous
q w
can not
logic as
boolean queries
intuitive meaning
polynomial time
power of
the rst
s i
rst tuple
all products
the class
database query
valuation of
produce all
of default
electric circuit
barilla and
is strategic
comp w
dql as
and saiwa
language dql
credulous default
dql by
complexity class
an explanation
a database
from q
order queries
fact f
tuple in
p 2
second order
database instances
default in
last tuple
credulous semantics
i jw
logic programming
of second
causes and
in polynomial
the queries
2 e
and semi
belongs to
be expressed
denes a
a valuation
the valuation
minimal sets
skeptical semantics
of q
r i
the boolean
non monotonic
fragment of
the answer
logic programs
query qdql
dql we
under credulous
abductive diagnosis
companies is
ground formula
existential universal
credulous dql
queries denable
strategic companies
control light
so 9
p dql
relation instance
default semantics
relation schemata
companies that
the fuses
propositional default
the existential
the intuitive
b 0
a specic
meaning of
the background
datalog with
polynomial hierarchy
complexity classes
each tuple
a boolean
z 0
b d
notice that
stable models
output relation
a company
instantiation of
of stable
relevant facts
defaults of
to sell
on default
database w
diagnostic problem
one extension
schema r
extensional relations
q 00
combined complexity
cf 23
possible causes
data complexity
section vi
function free
thomas eiter
of hd
the diagnostic
in 0
in d
all queries
formula in
q is
theorem 1
tuples t
normal i
output relations
nicola leone
q p
denition of
w i
semantics of
query can
computable in
i o query
a query language
q q dql
expressive power of
extension of q
the expressive power
hd w i
capture the class
dql i o
default logic as
the default theory
dql queries precisely
cadoli eiter and
queries precisely capture
gottlob default logic
precisely capture the
the class p
small o ice
i o queries
and gottlob default
second order logic
an extension of
a 2 e
as a query
logic as a
fragment of second
eiter and gottlob
expressed in dql
produce all products
and semi normal
intuitive meaning of
the intuitive meaning
is an extension
of second order
a default theory
of default logic
the rst tuple
the query is
can be expressed
barilla and saiwa
class p 2
that dql is
in datalog stable
default in d
query language dql
boolean dql queries
boolean dql query
normal dql queries
power of dql
of dql in
database instance w
queries computable in
the background knowledge
in polynomial time
the last tuple
last tuple in
e is an
z a b
a b 0
that a 2
a default query
the minimal sets
instance w of
normal default theories
o query q
of hd w
relational database query
s i jw
based on default
default query language
the credulous default
queries denable in
normal and semi
fragments of default
complexity of dql
of the fuses
sets of companies
that produce all
credulous default semantics
the existential universal
follows from q
q p dql
tuple in 0
the boolean dql
companies that produce
of companies that
the relevant facts
semi normal default
the control light
is p recognizable
meaning of the
of the query
of a query
of the default
deciding whether a
be expressed in
the set of
boolean query is
of predicate symbols
can not be
we have that
minimal sets of
a database query
first order queries
of q q
a boolean query
the data complexity
instantiation of the
the polynomial hierarchy
s i t
0 is true
database query languages
s i 2
the denition of
a set of
as an example
in section vi
the query can
t belongs to
computable in polynomial
for each tuple
an i o
of the database
a company is
queries first order
if a specic
expressive as so
a dql i
concludes the part
under credulous semantics
rst tuple in
p recognizable queries
ex p eter
all queries computable
and what not
p eter ex
ice p eter
denition of extension
of theoretical importance
a maximal trust
q is dened
dql in the
theoretical importance we
pair b d
causes and eects
query q q
semantics of dql
is as expressive
open defaults d
company is strategic
plus a set
companies barilla and
of the diagnostic
query is p
captures the class
the queries denable
of p recognizable
the kind 1
a boolean dql
existential universal fragment
battery s voltage
in dql as
order logic this
background knowledge b
follows the background
model based diagnosis
rst order formulas
belongs to an
defaults in d
eter ex p
theory hd w
polynomial time queries
under the credulous
w of r
fixed point queries
p eter the
o ice p
only of theoretical
dql is p
a small oce
universal fragment of
1 electric circuit
logic this result
the s predicates
dql in this
the i o
query q is
to show that
is true i
can be implemented
i 2 s
that s i
default theory hd
which relations can
as expressive as
to a maximal
class of p
of w to
for boolean queries
be an extension

corpus/krapavin2000-test/627861.txt
4381
microcode
libraries
faults
9370
ibm
db1
bookkeeping
library
word
confidence
db3
functional
fuzzy
records
comment
cfev
development
db2
database
team
historical
tool
definite
manual
errors
extrapolated
teams
relevant
hardware
databases
testing
pertinent
puts
entries
answering
comments
failure
relevancy
percentages
fev
accuracy
fault
separability
dilemma
ffl
attributed
bug
error
regarding
responses
representative
manufacturing
established
processes
severity
avizienis
wfev
category
establishing
defects
put
command
confuse
liable
laprie
attributing
routine
constitutes
irrelevant
646
disposition
manifestation
validations
intervention
expert
generator
logic
commands
874
proceeded
promoted
attribution
deviation
percentage
opinion
phi
human
changes
file
failures
responsibilities
assessments
841
tracking
closeness
examination
record
service
evaluator
validation
entry
composition
09
responsible
prediction
researchers
resolution
anticipated
investigation
bugs
reflect
breakdown
attribute
developers
days
individuals
report
accesses
patches
answer
experimentations
inapplicability
trackable
readiness
82
reporting
aspects
absence
discovered
participants
assessment
questions
diverse
concluded
files
maintaining
suggesting
extracted
faulty
findings
erroneous
extrapolations
phenomenological
disagreement
expedient
misunderstanding
misinterpret
reluctance
016
97
population
history
methodology
entire
exclude
words
clusters
specifications
45
811
plurality
spoken
radiation
pertains
contributor
alphabetically
memberships
today
frequencies
track
row
cycle
question
resolve
validate
clustering
99
supply
correction
promotes
extrapolation
grades
cluster
outcome
indicating
processor
commonly
confidences
packaging
logging
cooling
categorize
473
arena
occasions
95
membership
retrieve
synonyms
relevant words
ibm 4381
functional testing
the ibm
the tool
bookkeeping libraries
relevant word
confidence value
error data
ibm 9370
4381 hardware
the comments
4381 microcode
functional changes
manual evaluation
answering system
the library
a comment
question answering
and microcode
9370 microcode
microcode and
experimental databases
the development
the bookkeeping
the manual
to functional
an error
libraries are
development processes
historical data
the libraries
of faults
word table
words relevant
the microcode
zero relevant
logic design
possible changes
we considered
each word
and definite
the confidence
and db3
fuzzy expected
library entries
the cfev
4381 and
two relevant
definite changes
the database
errors and
tool and
the error
microcode development
tracking libraries
change category
routine accesses
entire record
error tracking
the replace
tool accuracy
bookkeeping library
modified database
databases db1
comment with
db1 db2
possible change
db2 and
definite change
replace table
changes changes
system test
computer systems
the functional
a confidence
words in
establishing the
unique word
development of
records in
and hardware
a failure
the words
of confidence
different development
hardware and
of relevant
considered to
regarding the
expected value
development process
word in
development cycle
the intervention
the puts
and 9370
9370 computer
tool changes
intervention of
component test
word generator
cfev value
put records
all put
microcode possible
entire development
confidence associated
errors faults
development bookkeeping
database question
words changes
category include
extrapolated from
comments with
pertinent to
the databases
attributed to
the relevant
testing in
accuracy of
data file
a fuzzy
libraries the
error fault
design faults
test phase
confidence values
error prediction
relevancy of
computer implementations
libraries to
the dilemma
words i
the relevancy
the accuracy
one relevant
comment is
three databases
as error
unique words
issues related
the entire
mean of
of error
computer system
to report
library for
of records
the experimental
given that
of functional
constitutes an
a library
an entry
the fuzzy
comments in
the different
high degree
ffl the
the percentages
of errors
testing of
representative of
of changes
a fault
a bug
to separate
a computer
is established
the percentage
the faults
system state
possible and
the opinion
than satisfactory
record was
put command
96 09
changes tool
diverse aspects
a avizienis
dilemma of
45 12
word relevant
particular team
defined specifications
puts which
possible words
expected service
confidence vector
population sizes
fev processor
is liable
faults ffl
as patches
entire ibm
laprie 3
the manifestation
reasoning database
the ibm 4381
of the ibm
ibm 4381 hardware
ibm 4381 microcode
question answering system
the bookkeeping libraries
the error data
the functional testing
the manual evaluation
the ibm 9370
the relevant word
relevant words relevant
ibm 9370 microcode
microcode and hardware
to the functional
the tool and
ibm 4381 and
the experimental databases
functional testing in
fuzzy expected value
of relevant words
relevant word table
for a comment
and the manual
to functional testing
and the ibm
zero relevant words
confidence value of
that the tool
in the relevant
each word in
the confidence value
to the library
of the tool
word in the
the development of
words relevant words
the entire record
bookkeeping libraries are
the different development
the replace table
to functional changes
a confidence value
the question answering
possible and definite
different development processes
error tracking libraries
4381 microcode and
db1 db2 and
for the ibm
and definite changes
databases db1 db2
a comment with
libraries are usually
the modified database
db2 and db3
then the confidence
tool and the
development of a
library for the
of the bookkeeping
accuracy of the
words in the
to the different
of the entire
a computer system
degree of confidence
of the development
of an error
of two of
records in the
the intervention of
two relevant words
the tool accuracy
functional testing of
cfev value of
ffl we considered
the possible change
answering system 2
hardware and the
words i and
database question answering
development bookkeeping library
system test phase
confidence associated with
between the tool
hardware and microcode
error data in
possible change category
of functional testing
comment is assumed
an error fault
the entire development
the system test
relevant words in
bookkeeping library for
the cfev value
unique word generator
4381 and 9370
design and microcode
the logic design
4381 hardware and
testing of computer
9370 computer systems
relevant words the
an error is
representative of the
percentage of records
the relevancy of
the records in
subject of interest
and hardware and
issues related to
in the ibm
a data file
of computer systems
of the databases
the accuracy of
for each word
in the library
of a system
the mean of
high degree of
considered to be
the percentage of
during the development
the words that
the tool is
given that the
number of changes
the development process
of the error
of a computer
to answer the
of the database
we should be
for the development
a high degree
4381 and the
error prediction models
processes involved with
is liable to
contains the words
in error when
error fault can
w r l
three experimental databases
defects and track
establishing the relevancy
faults to the
relevant two relevant
entire ibm 4381
findings indicate that
system to report
set ffl step
the component test
the error tracking
value present in
frequencies of relevant
in the irrelevant
were promoted from
the expected service
avizienis and j
category include all
and their separability
and software products
of multiple faults
the development cycle
test phase in
which is liable
resulting in multiple
the microcode and
definition of faults
days or less
all pairs is
separability of errors
with functional testing
the libraries are
correction of faults
the opinion of
development processes ffl
r l are
as error tracking
comments containing zero
usually established during
processes the dilemma
one relevant word
relevant word relevant
failures and their
the errors faults
library entries are
no relevant words
containing zero relevant
and j laprie
of error prediction
functional changes by
phase in three
the microcode development
threshold value ae
identified as patches

corpus/krapavin2000-test/627878.txt
descriptors
phi
cdnf
boolean
descriptor
server
servers
directory
similarity
query
atomic
rdnfs
documents
radecki
rdnf
rb
cisi
ra
distributive
spearman
queries
compact
homer
descriptions
indie
cdnfs
danzig
coefficient
services
ranking
usc
law
tq
jaccard
discovery
expressions
confidence
gloss
subtree
subtrees
rankings
measures
rank
retrieval
wais
parse
complexities
resource
calculate
proportion
rc
internet
archie
database
fig
binary
ranks
disjunctive
normalization
cluster
tied
negated
broker
filter
closer
smith
document
keyword
duplicated
trees
expression
1460
tq2
similarities
tree
manually
searching
rs
superior
relevant
expansion
administrators
crs
users
client
hit
qj
representatives
parents
child
author
keywords
operators
transformed
experiment
rooted
height
expanded
logical
interval
southern
li
ranked
nfs
transforming
content
head
responses
indexing
expanding
formulations
dataset
centralized
normalized
transform
n2
file
expand
filters
relevance
95
submit
figs
collect
theta
overlap
root
node
attribute
measure
cd
correlation
2n
nested
operator
conjunctions
0052
klusch
jianguo
da52194
ilarities
p20
vanced
outperfroms
sufyan
demote
matchmaking
abstractas
eariler
trb
mcleod
nia
9457518
reformed
rashid
hbp
sycara
califor
cyberspace
90089
nyi
demoted
dice
overwhelms
widoff
cormack
01a1
5492
larks
9216321
minus
sends
parent
generates
descending
spend
nn
generator
feedback
leaves
duplicates
vii
therefor
nih
ffis
brokers
novice
lup
bison
fil
katia
disjunction
managed
collaborative
requests
agents
negation
ests
quantile
ily
s phi
compact atomic
atomic descriptor
atomic descriptors
server descriptions
descriptors in
boolean expressions
directory of
reduced atomic
similarity measures
s s
boolean expression
resource discovery
r s
or or
relevant servers
the distributive
binary tree
distributive law
of services
of descriptors
server description
boolean similarity
user query
similarity measure
and rb
phi s
the directory
the similarity
or and
confidence interval
usc homer
each compact
user queries
complete binary
q 2
boolean queries
measures for
binary trees
phi computation
and danzig
the cisi
s coefficient
danzig boolean
calculate s
radecki s
time s
and or
of documents
the descriptors
q 1
descriptor in
measure s
two boolean
theta s
ra and
n node
for resource
logical operators
rdnfs of
directory server
ranking closer
client directory
jaccard s
the cdnf
p descriptors
measures s
cdnf to
each reduced
binary parse
query q
space complexity
documents in
and r
li and
descriptor of
phi is
the confidence
the theta
s for
and space
spearman coefficient
author smith
internet resource
determine relevant
rb are
descriptors the
rank servers
original boolean
descriptors that
tq tr
node binary
phi generates
rs s
the rdnfs
homer database
100 server
expression to
for boolean
the server
server model
each query
query and
the boolean
server called
the usc
in boolean
a ranking
a server
q and
95 confidence
space complexities
above zero
the binary
phi and
each server
interval for
is superior
a boolean
the query
of servers
and s
s and
s above
similarity values
linear binary
of boolean
to calculate
similarity between
of reduced
the expansion
transformed to
space s
phi we
descriptors are
the rankings
to rank
complexities of
descriptor contains
spearman rank
complicated boolean
between boolean
1 descriptors
to rdnfs
to rdnf
are descriptors
whose parents
query pair
than rb
include 0
rb 2
query 100
to cdnf
compact disjunctive
2 descriptors
our similarity
cisi database
the cdnfs
nested boolean
description rc
n server
node complete
confidence that
servers for
and server
information retrieval
is transformed
superior to
the user
and node
the subtrees
than s
disjunctive normal
the space
more relevant
tq and
from boolean
associated query
individual similarity
servers based
to query
queries and
of q
an and
the compact
o n
with 95
interval r
cluster representatives
user sends
measure can
n servers
interval does
query to
the proportion
expressions to
the servers
the client
retrieval systems
queries as
r s s
directory of services
compact atomic descriptor
s phi s
s s phi
the directory of
reduced atomic descriptors
the distributive law
similarity measures for
compact atomic descriptors
boolean similarity measures
or or or
time s phi
s phi is
for resource discovery
and s phi
measures for resource
q and r
number of descriptors
atomic descriptors in
s s for
complete binary tree
of r s
s s s
or and or
danzig boolean similarity
li and danzig
phi is superior
and danzig boolean
of descriptors in
two boolean expressions
atomic descriptor of
boolean expression to
similarity measure s
s phi computation
ra and rb
superior to s
reduced atomic descriptor
the theta s
each compact atomic
phi s and
the confidence interval
the user query
s and s
descriptors in the
directory server model
the client directory
client directory server
a ranking closer
generates a ranking
each reduced atomic
user query and
of reduced atomic
jaccard s coefficient
s phi and
ranking closer to
time and space
and and or
that s phi
a complete binary
of documents in
number of documents
that of s
confidence interval for
boolean expression is
determine relevant servers
linear binary tree
the descriptors in
the compact atomic
s phi generates
measure s phi
than r s
s above zero
sets of descriptors
the server descriptions
n node binary
phi generates a
a compact atomic
phi and s
for the proportion
boolean expressions to
similarity measures s
internet resource discovery
s phi we
confidence that s
original boolean expression
the server description
all the descriptors
the usc homer
descriptors that appear
100 server descriptions
theta s above
the binary parse
and or and
an n node
the boolean expression
and r s
is superior to
user queries and
to the directory
and or or
is more relevant
q 2 and
the number of
documents in the
of q 2
closer to that
to query q
q 1 and
s and r
interval for the
disjunctive normal form
of compact atomic
server description is
times the theta
calculate s phi
descriptors in each
and server descriptions
the rdnfs of
descriptor in the
distributive law is
confidence interval does
between boolean expressions
similarity between boolean
a directory of
queries and server
tq and tr
n node complete
usc homer database
s phi for
more relevant to
the original boolean
and rb are
parents are or
of server descriptions
server descriptions are
1 query 100
r j v
to calculate s
measures s and
node complete binary
of s phi
relevant to query
value s between
similarity value s
not include 0
for user queries
can say with
include 0 5
query 100 server
whose parents are
the relevant servers
ra is more
of descriptors that
to determine relevant
the cisi database
complexities of s
say with 95
expressions to rdnfs
confidence interval r
server description rc
n server descriptions
similarity measure can
n 1 descriptors
rdnfs of q
our similarity measure
atomic descriptor in
descriptor of q
binary parse tree
boolean expressions the
atomic descriptor contains
the space complexity
all the nodes
the similarity measure
the individual similarity
a linear binary
in its database
the similarity measures
the similarity values
95 confidence that
servers based on
for boolean queries
in the directory
the similarity value
number of common
or or and
number of reduced
boolean expressions and
list of relevant
binary tree is
a boolean expression
query and the
of q and
query q 1
and space complexities
interval does not
with 95 confidence
is transformed to
the r s
of boolean expressions

corpus/krapavin2000-test/627899.txt
pi
justified
wrt
revision
negatively
literals
coherence
skeptical
fixpoint
cj
positively
sem
founded
semantics
dole
conservatism
negations
literal
notb
notl
credulous
scs
revised
shadow
justification
ccs
clause
removal
argumentation
cumulativity
relevance
contradiction
semantical
derivable
clauses
logic
priority
pres
rn
ht
nota
program
alternating
negation
maximal
belief
ci
interpretation
honest
problematic
preservation
light
complementary
presidential
politicians
notc
politician
fujitsu
valued
head
partial
newly
switch
contradictory
iff
conflict
fn
programs
semi
deleting
republican
inconsistent
liberal
body
dung
abnormal
tw
isis
deleted
doubling
conflicting
truth
rel
lights
consistent
inconsistency
prioritized
gardenfors
notlm
pnew
notdg
frn
notbroken
notbg
ljnot
numazu
fnotl
przymusinski
alferes
notd
resolve
ag
stable
normal
lg
tractable
trn
dg
np
yuan
lemma
negative
dix
fnot
demonstrates
characterized
contradicts
believed
atom
retains
behaved
removing
normalized
fixpoints
grounded
abductive
tn
autoepistemic
gl
pereira
interpretations
violates
tg
you
revise
candidate
said
labs
resolves
favors
minimality
derives
interchangeably
monotonic
coincides
abuse
characteristic
satisfies
mr
coincide
advocated
transformation
notable
classical
establishes
conservative
normalization
parties
anti
characterize
fyuan
troublemaker
flict
inoue
chiaki
counterattack
revising
dgi
srs
flj
ngi
lrel
104442
isomorphy
katsumi
19e
youg
sakama
liberals
preserva
notbthe
removalapproach
witteveen
fnotlj
servative
notf
uergen
coherenceapproach
labora
candidates
expressive
imply
heads
japan
atoms
fg
false
proposition
simplicity
favor
of pi
pi r
justified wrt
partial model
wrt m
justified model
positively justified
is negatively
cj partial
negatively justified
is positively
fixpoint of
program pi
from pi
in pi
l is
coherence semantics
well founded
the skeptical
the coherence
shadow justified
negatively shadow
revised program
model of
a justified
revision semantics
assumption removal
let pi
l 2
founded model
coherence approach
negative justification
pi if
pi is
justified partial
sem pi
removal approach
assumed negations
argumentation semantics
pi n
extended program
pi and
pi be
if l
a fixpoint
program revision
alternating fixpoint
pi then
pi such
and pi
the credulous
a cj
logic programs
pi rn
complementary literals
of complementary
the justified
l pi
if pi
semantics of
belief revision
assume l
the revised
the well
three valued
founded semantics
pi 2
contradiction free
ht f
ci n
maximal fixpoint
skeptical partial
n cumulativity
normal alternating
pi f
light on
the revision
l maximal
clause with
valued interpretation
the contradiction
derivable from
a literal
semi normalized
least justified
extended programs
semantical properties
maximal cj
partial models
credulous argumentation
justified models
program of
in t
pi the
every clause
literal l
not l
an extended
a maximal
6 l
that l
priority relation
logic programming
newly introduced
pi by
a clause
if and
only if
lemma 9
logic program
by 9
m 3
pi m
is semi
ccs satisfies
justified with
assumption set
problematic assumptions
coherence theory
credulous coherence
sub interpretation
and justified
pres candidate
literals in
2 f
and relevance
1 l
clause in
the head
the program
2 l
of assumed
pi s
switch on
are derivable
pi iff
with l
of literals
that pi
all clauses
classical negation
simply because
stable model
and only
m and
an interpretation
be derived
l 62
pi not
revision the
skeptical coherence
rel pi
cumulativity negative
maximal justified
scs does
contradiction problem
a notb
justified literals
if sem
2 fn
skeptical revision
honest dole
assumed false
revision is
derived under
program obtained
extended logic
l by
given program
and l
n is
l as
the assumption
literals and
to logic
literal is
deleted from
m 4
consistent and
an l
for logic
for pi
and credulous
maximal consistent
consider pi
2 sem
semantics 6
the literals
skeptical and
regular model
as pi
f pi
a program
program then
therefore l
a priority
deleting all
of logic
any program
semantics for
model of pi
justified wrt m
partial model of
of pi r
fixpoint of pi
l is negatively
cj partial model
is positively justified
positively justified wrt
negatively justified wrt
is negatively justified
the well founded
negatively shadow justified
l is positively
justified model of
well founded model
wrt m and
is negatively shadow
the assumption removal
assumption removal approach
of pi if
the revised program
shadow justified wrt
justified partial model
a fixpoint of
of pi and
founded model of
l 2 f
semantics of pi
the coherence approach
pi such that
is a fixpoint
only if l
let pi be
if l is
a justified model
of pi then
of complementary literals
a cj partial
pair of complementary
ht f i
is a justified
an extended program
l is in
well founded semantics
program of pi
pi r and
clause with l
deleted from pi
obtained from pi
clause in pi
l maximal fixpoint
with l as
skeptical partial model
normal alternating fixpoint
pi r n
if and only
and only if
only if pi
l 2 t
l as the
if l 2
as the head
credulous argumentation semantics
maximal fixpoint of
revised program of
least justified model
of pi 2
let pi r
maximal cj partial
three valued interpretation
in pi r
pi r is
assume l is
the credulous argumentation
is in t
2 l is
is a maximal
of pi such
alternating fixpoint of
n is a
founded semantics of
pi be a
from pi n
a justified partial
sub interpretation of
credulous coherence semantics
if pi r
is semi normalized
from pi by
is a cj
the justified model
the coherence theory
logic program revision
m and pi
a sub interpretation
approach to logic
an l maximal
from pi rn
pi r be
justified with respect
a maximal cj
to logic program
pi if and
m is a
every clause with
1 l is
the program obtained
m 3 and
of logic programs
only if it
is an l
of pi is
a three valued
a normal alternating
on the coherence
of assumed negations
2 let pi
pi is defined
coherence approach to
the contradiction problem
argumentation semantics 6
l 2 fn
head in pi
pi iff it
justified model and
cumulativity negative justification
be the revised
program pi r
deleting all clauses
argumentation semantics of
of pi iff
of pi the
cj partial models
derivable from pi
it is positively
6 l by
2 sem pi
the skeptical coherence
maximal justified model
given program pi
1 let pi
consistent and justified
wrt m then
rel pi s
exists a clause
set of assumed
pi be an
n cumulativity negative
wrt m 3
the skeptical partial
and credulous coherence
while the coherence
a maximal justified
skeptical coherence semantics
a and a
for logic programming
f i is
the skeptical and
be an extended
n 6 l
and belief revision
skeptical and credulous
3 and m
2 case 3
and 2 l
a priority relation
case 2 case
cannot be derived
program obtained from
if it is
lemma 2 3
a cannot be
such that l
is said to
and l is
has a least
be a program
m and therefore
the head in
since l is
by lemma 9
f if and
case 1 case
is a sub
only those clauses
ci n is
the argumentation semantics
extended program has
a notb a
f 6 l
is assumed false
positively justified and
2 f pi
light on switch
sem pi for
that are derivable
a least justified
ccs satisfies preservation
are derivable from

corpus/krapavin2000-test/627906.txt
ss
mining
traversal
fs
references
reference
web
scans
sequences
scan
database
forward
mf
maximal
dhp
fanout
height
association
syan
itemsets
internal
theta
hung
patterns
chen
backward
candidate
hashing
child
ming
zipf
frequent
joshi
traveling
garofalakis
jumps
transaction
p0
browsing
cpu
selective
jump
trimmed
sales
subsequences
abegh
posters
hxpy
discovery
string
sensitivity
disk
rastogi
pruning
nanopoulos
anupam
option
chang
lee
conducted
logs
alexandros
lin
customer
sigkdd
chih
sec
manolopoulos
jc
leaf
meaningful
items
node
karuna
trimming
d200k
holmquist
phoha
subroot
vir
illustrative
cheng
hypertext
parent
mclean
ru
hash
subsequence
yannis
scanned
www
pass
varied
damon
yesha
rajeev
narayanan
minos
yelena
shing
authoring
prominent
14th
tree
utilizing
comparatively
decreases
chiba
peng
fu
paths
linked
interactive
referencing
null
yen
url
synthetic
passes
ho
2002
bar
virginia
rules
log
shao
hari
newsletter
convert
services
outperforms
advantageous
nodes
wic
362
hw
shim
marketing
devise
shall
sliding
utilizes
poisson
shih
bremen
itemset
explorations
educational
batch
world
logged
databases
management
determining
devised
hua
75
consecutive
edmonton
proxy
eleventh
hsu
shin
seconds
jp
liang
discrepancy
stock
ali
73
documents
sequential
ease
152
25th
explored
users
prefetching
lm
varies
collect
path
yu
178
tightly
alberta
weight
germany
sessions
tracks
clustering
superset
georgia
environments
navigation
hot
flag
september
probabilities
wen
large reference
reference sequences
maximal forward
forward references
traversal patterns
theta theta
reference sequence
forward reference
fs and
traversal tree
internal nodes
a traversal
determining large
algorithm mf
mining traversal
database scans
association rules
k references
information providing
algorithm ss
c c
and ss
data mining
the height
of large
height of
string y
sequences when
algorithm fs
l k
internal node
user access
the traversal
selective scan
traversal path
c ss
maximal reference
minimum support
i o
the database
c k
ming syan
syan chen
of candidate
for mining
ss theta
k reference
internal jumps
support c
d f
of maximal
child nodes
transaction database
sec minimum
o time
of internal
for fs
frequent traversal
of traveling
reference path
p0 0
ss is
zipf like
reference paths
the option
database size
patterns in
option of
time sec
wide web
mining association
large k
world wide
disk i
log data
the fanout
of ss
like distribution
references for
various parameters
o cost
fs algorithm
path traversal
scan ss
providing environment
ss algorithm
candidate references
traversal paths
determine large
traversal log
backward references
references obtained
candidate reference
internal jump
traversal pattern
log database
sequences decreases
of traversal
meaningful user
hashing and
sensitivity analysis
of child
database is
each pass
of database
database scan
mining web
ss when
with internal
parent node
and pruning
c 0
candidate itemsets
finding frequent
sales data
tree increases
hung lee
sequential patterns
scan to
chang hung
fs is
references in
a maximal
conference on
determined from
an internal
full scan
finding large
large itemsets
of sales
international conference
from l
of finding
cpu and
two methods
child node
linked together
o times
on mining
pattern mining
and knowledge
access patterns
batch so
interactive access
sequences second
facilitate interactive
for ss
original log
outperforms fs
mainly made
original sequence
access sequences
1 references
fs to
scans required
mining meaningful
anupam joshi
scan fs
traversal sequence
determine maximal
mining capability
involves mining
of selective
properly utilizing
between traversal
comparatively analyzed
advantageous and
backward reference
analyzed it
sequences figure
mf to
sequences from
leaf nodes
is varied
pruning techniques
sufficient number
on knowledge
cpu time
sequences in
environment where
l 2
n j
two algorithms
the frequent
very advantageous
references i
a zipf
by fs
web logs
ss to
ss in
both cpu
knowledge discovery
knowledge management
node is
mining for
proceedings of
the transaction
execution time
on web
large reference sequences
maximal forward references
theta theta theta
of large reference
number of large
fs and ss
c c c
mining traversal patterns
determining large reference
of maximal forward
the height of
height of a
reference sequences when
a large reference
a traversal tree
c c ss
of internal nodes
set of maximal
ming syan chen
support c c
minimum support c
sequences when the
c ss theta
for determining large
maximal forward reference
ss theta theta
i o time
sec minimum support
time sec minimum
internal nodes and
the option of
reference sequences in
forward reference path
of a traversal
a maximal forward
for mining traversal
zipf like distribution
of child nodes
large reference sequence
forward references for
world wide web
disk i o
mining association rules
the transaction database
number of child
in each pass
hashing and pruning
i o cost
providing environment where
analysis on various
the traversal tree
a reference sequence
reference sequences from
internal nodes with
determine large reference
meaningful user access
selective scan ss
reference sequence is
frequent traversal patterns
information providing environment
as to reduce
nodes with internal
path traversal patterns
with internal jumps
reference sequences decreases
forward references obtained
objects are linked
maximal reference sequences
large k references
the large reference
the maximal forward
on various parameters
of finding large
to d f
a traversal path
is determined from
these two methods
international conference on
proceedings of the
the number of
when the height
sensitivity analysis on
of finding frequent
determined from a
number of internal
the database is
chang hung lee
i o times
as the height
an internal node
set of candidate
time to find
are linked together
into a set
cpu and i
of a tree
is noted that
a sufficient number
environment where documents
generated from c
scan to determine
in a sufficient
for fs and
or objects are
on mining meaningful
batch so as
by algorithm mf
between traversal patterns
reference sequences the
convert the original
scan is very
of candidate references
written to d
cpu time sec
in batch so
that the option
scan ss algorithm
facilitate interactive access
both cpu and
linked together to
traversal patterns and
traversal path is
database scans in
itemsets for association
patterns and association
of sales data
mainly made for
of log data
o time sec
by properly utilizing
and pruning techniques
theta i o
of selective scan
data mining capability
analyzed it is
sequences in batch
the traversal log
algorithm mf to
reference sequences are
option of selective
an information providing
the original sequence
access sequences second
all maximal forward
large k reference
reference sequence that
to determine large
traversal patterns in
database d f
to facilitate interactive
comparatively analyzed it
made for ease
the frequent traversal
out the effect
original sequence of
is very advantageous
documents or objects
full scan fs
information providing services
user access sequences
properly utilizing the
our solution procedure
reference sequences figure
ease of traveling
of determining large
very advantageous and
log data into
option of determining
sequences second we
selective scan is
a zipf like
the original log
where documents or
database scans required
of reference paths
maximal reference sequence
a database scan
mining meaningful user
together to facilitate
sufficient number of
number of candidate
the minimum support
it is noted
and knowledge management
information and knowledge
conference on information
references i e
new data mining
of database scans
user access patterns
database size increases
with the option
nodes the number
1 r k
theta theta i
improved with the
and association rules
sequence of log
set of large
on information and

corpus/krapavin2000-test/627922.txt
inverted
documents
document
hhnl
c2
hvnl
vvm
c1
file
collections
similarities
vvs
hhs
os
textual
collection
join
simulation
wsj
hvs
entries
increment
theta
multidatabase
job
backward
pages
hvr
resumes
read
scan
held
resume
similarity
applicants
attributes
doe
bhhs
d2
joins
query
50000
outer
descr
d1
scanned
fr
entry
intermediate
files
memory
estimated
retrieval
incurs
5000
bhvs
fcompute
10000
title
formula
performer
accommodate
simulations
integrity
fif
4kb
binghamton
hhs1
hhr
hvs2
subcollection
ds
ir
queries
unprocessed
storing
scans
x1
processed
minfg
ssn
batch
participate
ascending
cell
ff
dsm
save
t2
reading
engineer
r1
lets
sequentially
schema
selectivities
obligations
text
inner
observations
d3
festimate
obiav
fd1
hhs2
vvr
hvs1
cells
sequential
verifying
email
group
relational
outperform
accumulating
r2
descriptions
bytes
selections
smart
impact
zsoyolu
forward
collected
buffer
integrated
packed
accumulated
frequency
accessed
page
occupies
t1
statistics
database
vocabularies
consecutive
motivating
tightly
storage
definitely
reviewers
ucla
formulas
me
sql
cpu
unlikely
entirely
likely
brought
outperforms
lowest
originally
comparator
scanning
fraction
000
edu
former
occurrences
track
reaches
largest
np
random
positions
counterpart
accommodated
reserve
records
none
disadvantage
policy
pq
noticeable
submitted
iri
sm
accumulate
fewer
automating
chicago
selection
norms
b2
department
avg
comparing
tread
selma
90024
9309225
d2g
25152
226087
aye
sengr
1579
33199
inverted file
file entries
documents in
in c2
algorithm hhnl
theta theta
algorithm hvnl
algorithm vvm
the inverted
the memory
in c1
file entry
of documents
document in
read in
document collections
each document
backward order
i os
document collection
memory space
intermediate similarities
of simulation
an increment
o cost
random i
increment of
the join
on c1
two collections
i o
outer collection
changes from
textual attributes
real collections
the backward
in collection
collection c2
inverted files
a document
two document
the documents
held in
to process
entries on
in simulation
be read
terms in
forward order
c2 will
one collection
file on
collection i
this group
the document
collections are
from 10000
hhnl is
10000 to
term numbers
each inverted
50000 with
collection is
b tree
using formula
an inverted
c1 and
be held
of algorithm
to 50000
simulation results
real collection
corresponding inverted
5000 simulation
all inverted
simulation 13
reading in
for processing
the similarities
of 5000
distinct terms
m documents
sequential i
c1 will
theta vvs
cost hhs
both collections
vvm is
on collection
largest similarities
job descriptions
inner collection
hhs 3
two inverted
hvnl is
intermediate similarity
simulation 8
vvm can
be estimated
optimal order
one scan
total i
similarity values
of inverted
processing joins
most similar
similarities between
estimated as
similarities for
x documents
collection use
collections is
in wsj
simulation 7
job descr
job description
vvs 4
ir systems
collection c1
integrated algorithm
joins between
same term
os are
multidatabase system
in pages
available memory
all documents
memory is
process the
three algorithms
collection and
much memory
c2 are
other collection
collection to
also appears
large enough
of terms
the outer
consecutive retrieval
storing intermediate
simulation 19
entirely held
3 hvr
global schema
50 with
c1 that
p title
textual type
compute hvs
hvr theta
hhs using
zero similarities
compute bhhs
the forward
all intermediate
and c2
c2 is
similar observations
is likely
entries are
the cost
documents and
memory when
memory buffer
one document
cost of
the b
collection as
collections but
of textual
a resume
mapping structure
new collection
for algorithm
whose corresponding
three real
for simulation
made from
scan of
observations can
that algorithm
the terms
for storing
term t
term matrix
collections with
be entirely
a multidatabase
c2 can
document d
each algorithm
term in
be scanned
attributes of
non zero
size of
new inverted
all resumes
ascending term
inverted file entries
the inverted file
theta theta theta
in the memory
documents in c2
inverted file entry
result of simulation
number of documents
the backward order
of documents in
documents in c1
with an increment
an increment of
i o cost
the two collections
document in c2
be read in
held in the
each document in
in this group
random i os
file entries on
process the join
two document collections
entries on c1
inverted file on
for each document
the outer collection
the two document
the forward order
of algorithm vvm
be held in
can be held
an inverted file
of the inverted
changes from 10000
10000 to 50000
file entries are
algorithm hhnl is
to 50000 with
from 10000 to
increment of 5000
50000 with an
each inverted file
to process the
documents in the
can be estimated
the memory is
all inverted file
of 5000 simulation
corresponding inverted file
the documents in
the b tree
of terms in
the total i
total i o
large enough to
theta theta vvs
o cost hhs
the largest similarities
intermediate similarity values
algorithm vvm can
algorithm hvnl is
algorithm vvm is
the intermediate similarities
the m documents
cost hhs 3
the memory space
to be read
be estimated as
all documents in
number of terms
reading in the
also appears in
the number of
space as possible
all intermediate similarities
as much memory
processing joins between
changes from 5
theta vvs 4
the other collection
vvs 4 figure
will be read
random i o
three real collections
much memory space
sequential i os
c2 will be
in collection i
increment of 5
collection use as
the i os
use as much
o cost of
enough to hold
one scan of
the same term
i os are
of distinct terms
a document collection
memory space as
compute the similarities
when the memory
most similar to
of the two
a document in
c1 and c2
the available memory
in each document
following observations can
hhs using formula
that algorithm vvm
attributes of textual
results in group
the inner collection
non zero similarities
of textual type
an integrated algorithm
document collections are
to 50 with
using the inverted
be entirely held
entirely held in
50 with an
distinct terms in
the global schema
vvm can be
collection i in
c1 will be
of inverted file
file entry of
the memory buffer
5 to 50
as the outer
3 hvr theta
a real collection
the memory when
hhs 3 hvr
inverted files on
for processing joins
hvr theta theta
of algorithm hvnl
for storing intermediate
file entries that
i in pages
the memory in
the result of
likely to perform
the size of
the i o
needed to process
can be entirely
document term matrix
an optimal order
inverted file is
are most similar
to the terms
observations can be
is large enough
is likely to
as a result
currently in the
from 5 to
of the documents
document in the
c2 can be
be made from
algorithms for processing
enough to accommodate
terms in each
memory space is
to hold all
performance of algorithm
made from the
are three real
on c1 corresponding
bhhs compute hvs
appears in c1
x documents in
from one collection
not large enough
whose corresponding inverted
c1 can be
p job descr
between textual attributes
documents in one
input document collections
the consecutive retrieval
two inverted file
1 algorithm hhnl
c1 corresponding to
hvnl can be
of reading in
backward order can
ascending term numbers
in ascending term
in c1 that
documents from one
every document in

corpus/krapavin2000-test/627933.txt
declustering
dlb
load
gis
polygons
polygon
spatial
llb
processor
query
processors
grr
speedups
pool
hpgis
balancing
4x
queries
sigma
arr
static
extent
balance
pbm
pdb
chunks
window
declustered
terrain
ids
chunk
polygonization
75
partitioning
bounding
map
donor
axis
2x
sim
transferring
filtering
idling
parallelizing
hilbert
box
similarity
t_s
proceccors
clipped
t3d
intersection
imbalance
polygonal
idle
objects
speedup
geographic
avg
metric
decluster
pidset
transferred
overlay
cray
003
edges
alternatives
graphics
transfer
clipping
maps
engine
iv
1x
004
pw
population
boxes
visualization
killeen
wsg
apprx
0454
viewport
006
chains
object
robin
options
peer
secondary
daah04
preprocessing
division
100
parallelization
army
segments
granularity
mimd
density
transfers
grid
008
leader
sp
iii
otal
lldb
ramachandran
ool
creek
150hz
llb_edge_box
s_p
apprxfil
481216
0518
bbox
41162
s_1
82324
9667
8kmx8km
s_2
experimentally
sequential
estimator
sample
trends
parallelizable
dividing
ferhatosmanoglu
678
imposed
ith
overhead
experiment
finish
subsets
estimating
cells
collections
chunking
overestimates
imbalances
approximator
unpacking
aravind
minimization
increased
files
texas
experimental
achieving
replicated
007
distributions
join
np
mismatch
approximated
averaged
partition
allocating
hakan
raster
pid
distribute
varied
approximate
requesting
188
intersects
round
drawback
uniform
disk
expensive
sec
duplicating
dynamic
grids
formulations
allocation
generator
issues
minnesota
adequate
sends
dp
bb
storage
replication
scheduling
statically
8x
systematic
dotted
range query
work load
range queries
spatial extent
the gis
declustering methods
extended spatial
similarity graph
gis range
query problem
static declustering
declustering method
load balance
sigma 0
load balancing
load metric
spatial objects
the declustering
the spatial
75 range
dynamic load
spatial data
speedups for
for declustering
dlb methods
the work
axis gives
the dlb
of polygons
of processors
the load
the polygon
declustering problem
the static
idle processor
bounding box
of extended
extent of
declustering and
extended objects
the pool
graphics engine
load density
declustering of
processors and
each processor
data partitioning
different processors
of range
alternatives for
for polygon
of work
over 75
cost t
in declustering
terrain visualization
clipped load
each range
polygonal data
sample window
pool size
polygons in
of edges
more work
the data
the bounding
object ids
an idle
load distribution
the range
declustering spatial
polygon data
polygonization of
4x map
llb method
processor idling
gis declustering
intersection computation
of declustering
local load
x axis
the polygons
intersection points
among different
local data
load imbalance
issues in
minimization function
main memory
transferring the
and similarity
methods for
the graphics
cray t3d
ith processor
per chunk
different declustering
map overlay
of proceccors
0 003
the hpgis
query operation
density over
of dlb
the llb
declustered into
is declustered
dlb method
approximate filtering
gives the
total work
data from
between processors
t s
of spatial
y axis
data is
16 processors
chunks of
distribution based
cost of
extent is
be uniform
balancing methods
work transfer
average speedups
the processors
good load
by transferring
based method
in increased
static load
over 16
static part
set s
line segments
trends observed
declustering the
filtering computation
and polygons
static gives
75 queries
max static
polygon pw
dlb phase
003 0
based declustering
pool based
dlb issues
25 75
systematic declustering
map 4x
polygon ids
time terrain
declustering extended
static execution
population distribution
donor processor
2x map
sim 100
100 llb
main trends
avg static
gis operations
leader processor
polygon level
approximated with
iv schemes
balancing techniques
of intersection
type ii
p processors
the cost
run time
for parallelizing
chains of
the x
point data
mapping function
local processing
the y
processor for
the filtering
a polygon
processors the
bounding boxes
work required
spatial object
in gis
work transfers
0 004
declustering for
p subsets
s b
geographic information
the cray
a sample
high performance
for extended
this experiment
the work load
range query problem
the range query
gis range query
the spatial extent
the gis range
work load metric
dynamic load balancing
75 range queries
number of processors
axis gives the
extended spatial objects
spatial extent of
the static declustering
extended spatial data
of extended spatial
among different processors
of the work
an idle processor
static declustering methods
the graphics engine
extent of the
the bounding box
number of edges
work load distribution
issues in declustering
and similarity graph
each range query
x axis gives
the x axis
the load balance
y axis gives
declustering methods for
the load density
the gis declustering
of extended objects
chains of line
over the spatial
the declustering method
polygons in the
polygonization of the
similarity graph and
alternatives for each
gis declustering problem
for the gis
range query and
gives the average
of range queries
of processors and
the y axis
at each processor
the minimization function
and the y
to the static
good load balance
for more work
a range query
declustering problem is
of the gis
number of proceccors
set of polygons
and dynamic load
sigma 0 003
load density over
a good load
different declustering methods
extent is assumed
declustering spatial data
local load balance
spatial extent is
range queries the
over 16 processors
over 75 range
for each range
range queries in
the cost of
the number of
of line segments
processors and the
speedups for different
load balancing methods
spatial data in
the average speedups
of the minimization
improved by using
the static part
method with a
of the result
load balancing techniques
the cray t3d
collections of extended
since the declustering
population distribution based
is approximated with
the polygon ids
between processors during
main trends observed
declustering and load
objects from this
time terrain visualization
the ith processor
of intersection points
for extended spatial
trends observed from
methods for parallelizing
the llb method
static declustering of
a sample window
of dlb methods
the main trends
segments and polygons
the dlb method
and an idle
time over 16
range query q
the polygon data
as the declustering
the dlb phase
to be uniform
the pool size
real time terrain
static execution time
declustering extended spatial
static load imbalance
static gives the
pool based method
0 003 0
a is approximated
granularity of work
range query operation
density over the
sigma 0 004
the spatial data
range query is
sets of extended
load metric the
sigma 0 006
cost t t
and load balancing
in the case
of edges and
used as the
gives the number
amount of work
the case of
that the static
to 16 and
of range query
load balance and
the polygons in
by transferring the
intersection points of
is assumed to
and the load
is used as
paper we focus
of the total
due to the
of the data
shown in figure
a b figure
we compare the
provide a framework
for the spatial
of the range
the set s
assumed to be
the main memory
be the number
the local data
number of polygons
line segments and
in estimating the
in addition we
be improved by
problem is np
the total work
with a sample
declustered into p
query problem the
metric the spatial
in increased total
30 sim 30
work load over
be transferred during
the hpgis component
sigma 0 008
similarity graph 100
sim 100 llb
work is transferred
of different declustering
a donor processor
and iv schemes
cost t s
declustering method is
ask for more
proceccors hilbert sim
the declustering problem
0454 sigma 0
as the work

corpus/krapavin2000-test/627934.txt
te
temporal
oid
instant
chimera
dom
salary
nontemporal
instants
attribute
employee
expressions
expression
manager
lifespan
inst
dole
navigational
legal
path
division
terminal
object
ar
attributes
intervals
query
relational
oriented
mary
correctness
denoting
40k
static
assignment
immutable
dependents
proposition
fh
equality
ins
valued
slice
ig
status
30k
weak
languages
formalized
database
accesses
interpretation
qualifier
official
printers
joins
boolean
implicitly
semantics
undefined
shorthand
name
join
identifiers
history
gadia
15k
daplex
statically
lesser
referring
subclass
string
symbolically
declared
oi
quel
belongs
interval
50
ensuring
historical
notions
sql
formalism
correct
car
superclasses
typing
consistency
strong
identifier
employees
instantaneously
databases
existed
objects
instances
modality
querying
signature
language
frontiers
restriction
composing
evaluated
multimedia
corollary
belonged
hsql
lif
appendixes
tsql2
tquel
defintion
ootempsql
croker
valuedness
espan
rules2
hrdm
ttype
reviseted
temporality
weakly
equalities
item
member
inheritance
names
deduced
interpretations
investigate
navigations
oids
lifespans
snodgrass
nair
sapino
adali
members
imposed
record
specification
verified
vals
postulated
earned
postfix
clifford
ascribed
dering
subrahmanian
notion
checked
instantiated
satisfied
recursively
dangling
2and
50k
explicitly
disjoint
101
predefined
syntax
stated
sublanguage
20k
headed
gove
inductive
devoted
navigates
bnf
migrated
abstracta
referential
presentations
pointer
recorded
characterizing
classes
aiming
flavors
rules
implicit
specified
assignments
evaluates
qualify
230
salvatore
peculiar
distinction
classical
collapsed
appearing
managers
premises
path expression
path expressions
temporal expression
te te
oid assignment
a temporal
dom e
time instants
expression is
an oid
object oriented
instant valued
a te
temporal expressions
temporal object
two path
a path
50 now
te e
simple path
e e
time intervals
e a
terminal path
mary dole
temporal path
a e
expression if
first instant
static attribute
dom a
of temporal
the oid
of chimera
expression then
t te
temporal value
temporal attributes
correct only
temporal context
if is
is correct
query languages
time instant
the temporal
of path
a dom
a t
of example
an attribute
instant te
e dom
last interval
te dom
the path
attribute name
of time
an instant
the object
let be
correctness conditions
type e
type correct
salary mary
valued temporal
fh ig
salary 40k
temporal interpretation
ar e
expression equality
at time
an object
current time
specific class
be be
the correctness
oriented query
data model
expressions denoting
most specific
boolean expressions
correct path
then is
correct for
formalized by
oriented data
e t
expressions are
expression and
navigational approach
class history
static attributes
manager employee
attribute whose
temporal values
inst slice
navigational accesses
now manager
last instant
50 division
temporal types
manager 50
slice te
temporal t
e te
declared for
te first
object belongs
employee temporal
legal oid
attribute access
inst inst
te last
te n
attribute accesses
dole salary
either explicitly
any legal
or implicitly
a static
value equal
attribute is
data models
instant in
of type
expressions and
correctness of
expression denotes
dom dom
attribute then
in chimera
x last
temporal query
conditions ensuring
a all
temporal data
expressions of
assignment is
v a
query language
relational data
instants in
it denotes
a terminal
by contrast
of equality
of attribute
denoting a
for path
o v
value denoted
e ar
belongs at
implicit joins
history lifespan
structured types
ig fh
te type
last te
valued r
legal values
now employee
now now
object denoting
interval first
official car
te t
value equality
a nontemporal
division salary
status full
temporal type
now 30k
temporal relational
first te
te inst
legal assignment
weak value
strong interpretation
symbolically denote
full time
ar ar
assignment two
oriented model
lifespan class
division 20
name and
oriented database
boolean expression
notion of
t now
expression the
the relational
are examples
recursively defined
oriented databases
thus denoting
equal there
oid to
t type
a path expression
path expression is
set of time
the path expression
a temporal expression
simple path expression
e a e
a e a
two path expressions
temporal object oriented
e a te
te te te
an oid assignment
of time instants
a simple path
a te e
type e a
dom a t
e e e
of time intervals
path expression if
path expressions are
a static attribute
correct only if
is correct only
a temporal context
in a temporal
of a path
is an attribute
most specific class
be an oid
path expressions and
terminal path expression
te e a
expression if is
if is a
is correct for
expression is an
an attribute name
let be a
of path expressions
a time instant
be be be
the temporal interpretation
e dom e
of path expression
temporal path expression
salary mary dole
temporal interpretation of
a terminal path
path expressions of
path expression equality
e a dom
instant valued temporal
e a all
object oriented query
the current time
is a temporal
object oriented data
of a temporal
formalized by the
of example 2
is a simple
for any legal
set of chimera
a t te
correct path expression
valued temporal expression
temporal path expressions
attribute whose value
path expressions in
simply a shorthand
notion of temporal
an instant valued
e v a
static attribute then
path expression denotes
o v a
path expressions denoting
path expression then
path expressions the
path expression and
a dom e
mary dole salary
is an instant
dom e dom
e e te
x last interval
attribute then is
the oid assignment
now a a
oriented query languages
for path expressions
e te te
then is correct
a set of
is a static
then is a
the correctness of
attribute name and
the value denoted
classes of example
of the path
by the following
be a path
expression is evaluated
following are examples
value denoted by
object oriented database
defined as follows
is formalized by
recursively defined as
the most specific
of example 1
temporal expression and
a temporal object
of temporal expression
expression is correct
time intervals the
t te dom
to symbolically denote
expressions and are
status full time
denoted as is
an attribute whose
expressions of example
te te t
temporal expression then
lifespan class history
by the oid
a e e
fh ig fh
history lifespan class
interval first instant
assignment two path
class history lifespan
legal assignment is
of attribute accesses
legal oid assignment
if is correct
a t type
object oriented model
first instant te
te dom e
terminal path expressions
a dom a
t te type
dom e t
te type e
class the object
value equal there
a temporal value
last instant te
3 above hold
t type e
temporal expression is
inst slice te
te dom a
to path expressions
oid assignment two
oid assignment is
above hold with
name and is
temporal expression the
last interval first
dom e e
te inst slice
navigational accesses in
type correct path
ig fh ig
instant te inst
a te dom
instant valued r
the correctness conditions
a o v
dom dom dom
any legal assignment
te first instant
analysis of path
assignment is correct
slice te n
manager 50 division
conditions ensuring that
assignment is legal
notions of equality
te e v
temporal expression if
are examples of
let be an
the notion of
a a t
the set of
the following we
object oriented databases
a shorthand for
1 3 above
the path expressions
if then if
if and is
time instants in

corpus/krapavin2000-test/627971.txt
video
retrieval
color
texture
image
visual
images
shot
multimedia
indexing
captions
shots
content
recognition
scenes
shape
segmentation
colors
spatial
videos
query
scene
features
retrieve
informix
wordnet
blue
querying
histogram
frames
text
dct
rgb
skin
extenders
semcog
blades
virage
aty
sc96b
visualseek
lchh97
excalibur
pixels
regions
similarity
compressed
motion
histograms
mpeg
descriptions
object
media
database
annotations
transform
web
http
queries
textures
attributes
human
detection
automatic
www
green
jacob
layout
relationships
ym98
hsi
ca96
wdg95
srihari
souza
cypress
photobook
csw95
cveps
shb93
rohini
webseer
retrievalware
pps94
csm96
sq96
relational
person
shapes
tv
yellow
brain
trees
objects
face
red
rectangles
sand
zooming
tumors
blade
traina
gif
os95
caption
intensity
digital
pixel
fabric
canvas
databases
browsing
fourier
dimensionality
keywords
ocr
dictionary
compression
extracted
feature
detect
episodes
qbic
clips
iconic
demand
commercial
dimensions
com
users
db2
yahoo
camera
temporal
institutions
border
fractal
news
preprocessed
facial
retrieving
anchor
streams
specifies
hierarchy
registration
spectra
storage
illumination
beach
date
manually
bounding
xml
world
multidimensional
moments
movements
detector
placement
signature
detected
challenges
consequent
fields
sketch
pyramid
modal
tracking
structural
url
people
recorded
wavelet
perceived
semantic
varlamis
ruofei
commercials
iraklis
lamarque
sam89
isurf
mar97
hcp95
killer
pzm96
hca95
vazirgiannis
dublin
gisele
hct96
jzl96
lie96
jma79
ztsg95
zks93
hck90
vectorial
loong
image retrieval
visual features
video retrieval
of video
retrieve images
and retrieval
and video
indexing and
texture and
based image
image and
example retrieve
content based
for image
video indexing
motion vectors
shot change
of multimedia
spatial relationships
images and
closed captions
texture elements
a shot
for video
color and
and color
multimedia on
visual content
shape retrieval
non visual
the user
wide web
world wide
retrieval system
the image
as color
images which
features and
an image
a scene
the video
the object
the world
color regions
and videos
structured descriptions
placement rules
color in
data blades
shot changes
and shape
object recognition
and texture
detection and
based retrieval
user specifies
systems for
human face
compressed domain
retrieving images
their attributes
features such
r trees
feature based
http www
a video
these features
methods such
images based
multimedia database
object detection
user defined
to detect
retrieval systems
database systems
local features
annotations are
for content
retrieval is
query the
a texture
and querying
bounding rectangles
minimum bounding
in image
features for
multimedia data
on demand
objects and
relational database
of images
captions and
feature query
as shots
data blade
feature layout
defined attributes
multimedia has
content modeling
key term
detect objects
term dictionary
significant colors
compressed video
camera operations
texture regions
and srihari
people michael
shape moments
automatic feature
blades for
sample multimedia
full motion
video segmentation
in compressed
the semcog
consequent frames
wordnet to
text recognition
motion video
localized feature
shots scenes
video are
detect shot
in mpeg
video extenders
dct transform
modeling indexing
descriptions may
significant color
relevant images
sketch retrieval
and episodes
efficient image
their visual
media type
texture element
semcog system
histogram comparison
color j
features play
texture window
system lchh97
color texture
each shot
demand system
shape color
visual retrievalware
rohini and
and wordnet
1 visual
images similarity
for instance
for indexing
the images
n dimensional
such systems
text retrieval
of service
semi automatic
retrieval a
web based
and systems
of pixels
on user
such as
change is
color histograms
commercial systems
and annotations
color indexing
date time
pyramid technique
automatic video
shots and
media streams
content analysis
and locations
may describe
brain tumors
retrieval methods
the media
image video
transform coefficients
color i
specify properties
image may
their placement
video as
visual query
on color
dictionary is
involving one
and spatial
retrieval and
the regions
fields such
frames or
level concepts
imaging systems
example retrieve images
and video retrieval
image and video
based image retrieval
for image retrieval
indexing and retrieval
non visual features
texture and shape
query the user
world wide web
for image and
such as color
systems for image
multimedia on demand
visual features such
the world wide
video retrieval systems
a shot change
retrieve images which
color and texture
for video indexing
shot change is
images and videos
the user specifies
features such as
methods such as
techniques and systems
in an image
objects of interest
and systems for
relationships among them
images based on
on the world
quality of service
for content based
minimum bounding rectangles
content based image
based on user
of these features
of the video
as well as
used to detect
feature based object
change is detected
dct transform coefficients
as shots scenes
model based segmentation
data blades for
sample multimedia on
efficient image retrieval
content modeling indexing
key term dictionary
colors in order
transform methods such
feature query the
of minimum bounding
key frames or
and their attributes
available for certain
and shape retrieval
image retrieval is
full motion video
on visual features
images and video
the semcog system
significant color regions
as color and
of multimedia has
motion vectors of
images which contain
a sample multimedia
user defined attributes
i and color
to index and
and color j
buffering and disk
dimensions are independent
modeling indexing and
the motion vectors
similarity based retrieval
texture and color
video as well
once the object
term dictionary is
shots scenes and
scenes and episodes
locations are recorded
retrieve images where
of full motion
visual features for
to detect shot
multimedia storage and
semcog system lchh97
dictionary is built
retrieve images with
a texture window
a left of
contents and wordnet
in image retrieval
index and retrieve
is a scene
their placement rules
object detection and
segments such as
on their visual
model of video
on color and
left of c
the texture elements
detect shot changes
on demand system
rohini and srihari
such as shots
and annotations are
the image and
number of dimensions
features for instance
color i and
based on color
specify properties of
and local features
of multimedia database
are extracted and
the retrieval system
spatial relationships such
the pyramid technique
to specify properties
operators to specify
image retrieval system
detection and recognition
based on visual
multimedia database systems
involving one or
for the world
fields such as
for images and
objects in it
n dimensional space
a common approach
based object recognition
signatures can be
the same scene
such as k
video compression standard
can be used
for instance a
a hierarchy of
object as a
detection and tracking
level are the
and spatial relationships
we first look
and whether they
in the image
objects and their
relationships such as
to detect and
shape can be
storage and retrieval
object in an
analysis is used
and retrieval of
attributes such as
a web based
first look at
can be combined
based on their
of service in
of pixels in
number of pixels
is to detect
one or more
relational database systems
a knowledge based
of the object
engineering v 16
be combined to
of an object
are used for
be used for
of interest is
at different levels
measures such as
of such systems
the user may
whether they are
can be compared
in order to
be characterized by
2 1 1
to be stored
an object in
where there are
may need to
serves as a
can be characterized
as a whole
such as the
methods can be
of the image

corpus/krapavin2000-test/627982.txt
generalizability
subdomains
baseline
learning
hypotheses
credit
pwin
timberwolf
subdomain
hypothesis
generalization
anomalies
normalization
temperature
normalized
win
training
learner
intensive
learned
assignment
vc
pac
concept
circuits
median
breadth
explanation
teacher
benchmarks
variance
sample
across
genetics
temporal
orderings
feedforward
statistically
pw
population
s420
apportioning
primary1
s298
statistical
placement
neural
default
genetic
feedback
reinforcement
ordering
samples
acceptance
ratios
measures
heuristics
sa
haussler
normalize
circuit
seed
aggregated
concepts
decision
routing
categorizes
mappings
seeds
subspace
quality
signals
probabilities
entails
stimuli
chervonenkis
improvement
degradations
vapnik
speedups
strategies
finishing
driven
brigade
operationality
classifier
dimension
package
learnability
decisions
learn
vlsi
symmetric
trained
theoretic
changed
lean
anns
mitchell
feedbacks
baum
fitness
generalized
artificial
geometric
testing
estimation
depth
annealing
incorrectly
averaged
cpu
learnable
dichotomy
inductive
meant
aggregate
classify
freedom
benchmark
markovian
ratio
sigmoidal
anomalous
medians
consistent
units
ten
infinity
evaluate
tested
raw
generalizing
realizable
discrimination
tendency
generalizations
rules
rank
signal
happen
systematic
schedules
worse
silicon
ffl
tests
ann
attributes
speedup
evaluating
generalize
partitioning
asymptotically
confidence
structural
subspaces
bucket
rule
hidden
improvements
prob
search
trial1
backer
dichotomization
devia
subexponentially
subvector
primary2
encyclopaedia
blumer
gammadistributed
incumbent
indus
waterman
regressing
quate
erated
32316
limiter
mcnc
ade
eralizability
harmonic
student
ranges
likelihood
guided
cell
distributions
negative
mean
probability
measuring
modifies
respond
past
classified
125
credit assignment
the baseline
performance values
parameter set
baseline hypothesis
across subdomains
h 0
anomalies in
fast n
of win
median performance
explanation based
improvement ratio
test cases
hypothesis is
a subdomain
than h
symmetric improvement
in timberwolf
normalized performance
generalizability measures
improvement ratios
and generalization
a hypothesis
baseline is
average normalized
a learning
vc dimension
all subdomains
generalized parameter
problem space
learned concept
temporal credit
normalization methods
performance ordering
generalization strategies
default parameter
sample mean
a concept
data intensive
based learning
the learner
in generalization
intensive methods
learning and
of hypotheses
domain knowledge
the learning
the hypotheses
decision theoretic
training examples
learning algorithm
evaluate generalizability
feedback signals
genetics based
random seed
rule space
pwin of
breadth first
test case
better than
a baseline
hypotheses are
the median
geometric mean
in learning
is better
new parameter
knowledge intensive
the sample
one hypothesis
in evaluating
learning of
depth first
baseline and
goal concept
in explanation
subdomain j
different subdomains
for normalization
when hypotheses
probabilities of
concept class
training example
the ordering
the performance
negative examples
of generalization
to evaluate
first search
performance across
subdomain to
different ranges
acceptance region
that generalization
loss function
is changed
placement and
data driven
the default
in performance
across all
of h
be aggregated
pw in
generalization as
learning example
genetic algorithms
of samples
learning in
of heuristics
hypothesis h
a learned
two hypotheses
parameter sets
version space
hypothesis that
the quality
concept learning
approximately correct
h i
are consistent
the variance
learner categorizes
ordering may
temporal scope
general hypothesis
finishing point
mean performance
performance normalization
win are
categorizes a
pwin is
multiple circuits
cell placement
examples needed
temperature finishing
and generalizability
different normalization
temperature schedules
three benchmarks
called probability
generalizability across
feedback signal
generalization procedure
mitchell 25
measuring generalizability
four computers
of timberwolf
example incorrectly
average symmetric
class c
and negative
neural networks
performance is
performance measures
hypothesis testing
hypotheses in
with fast
estimation error
performance of
assignment is
the generalization
a decision
generalization and
may depend
that measures
performance value
population mean
classifier systems
such hypotheses
generalization problem
mean i
o bound
when performance
win and
generalization based
aggregate performance
best hypothesis
algorithm l
positive training
in subdomain
ordering when
in reinforcement
normalization method
instance space
asymptotically to
is normalized
parameter values
trained on
statistical methods
the evaluation
average performance
hypothesis in
loss when
valid generalization
different ordering
subdomains we
scope is
presented some
than h 0
the performance values
better than h
performance values of
the median performance
learning and generalization
the baseline is
hypothesis is better
the baseline hypothesis
anomalies in performance
probabilities of win
of the baseline
in a subdomain
is better than
baseline is changed
when the baseline
generalized parameter set
the default parameter
temporal credit assignment
fast n of
default parameter set
as the baseline
credit assignment is
to evaluate generalizability
the sample mean
h 0 in
of a hypothesis
placement and routing
when hypotheses are
in explanation based
the goal concept
probability of win
symmetric improvement ratio
pwin of h
parameter set and
a learned concept
the baseline and
of the hypotheses
explanation based learning
with fast n
in performance ordering
performance is normalized
the average normalized
performance with respect
concept class c
the geometric mean
a hypothesis is
a learning algorithm
the learning of
in the ordering
a concept class
and negative examples
hypothesis h 0
with respect to
number of samples
of h i
test cases and
may be difficult
are consistent with
domain knowledge and
to h 0
a test case
positive training examples
the generalized parameter
the learner categorizes
generalizability across subdomains
baseline hypothesis h
of win are
performance across subdomains
by a learning
asymptotically to the
knowledge intensive methods
credit assignment in
average normalized performance
temperature finishing point
genetics based learning
approaches in generalization
whether a hypothesis
the problem space
median performance of
instance in evaluating
in each subdomain
categorizes a learning
of examples needed
learning algorithm l
data intensive methods
i in subdomain
rely on domain
in measuring generalizability
a learning example
learning example incorrectly
a hypothesis in
temporal scope is
called probability of
performance value of
learner categorizes a
the rule space
a baseline hypothesis
generalization based on
across all subdomains
the symmetric improvement
different ranges and
symmetric improvement ratios
a problem space
all the subdomains
in subdomain j
methods to evaluate
in all subdomains
when the learner
of win and
baseline for normalization
n of 10
may depend on
that measures the
that are consistent
used to evaluate
of a concept
quality and cost
the acceptance region
in reinforcement learning
to a decision
the generalization problem
loss when the
hypothesis that is
performance of h
anomalies in the
i o bound
positive and negative
the vc dimension
0 in all
h 0 we
to evaluate whether
domain knowledge to
average performance of
of test cases
the baseline for
the range between
zero and one
than the baseline
and cost of
respect to the
the variance of
variance of the
a hybrid of
h i in
each test case
to the baseline
the ordering of
the average performance
breadth first search
between zero and
consistent with the
to normalize the
test cases in
of positive and
of h 0
respect to that
depth first search
artificial neural networks
on the size
for instance in
the number of
h 0 and
quality of a
hypotheses in a
decision theoretic techniques
one performance measure
the apportioning of
achieved generalizability measures
cpu times of
generalization and generalizability
a computer one
form z 0
anomalous orderings of
sa will run
function 1 0
values places another
credit assignment entails
define a problem
values of hypotheses
solutions in measuring
learned concept may
the bucket brigade
to a baseline
credit assignment can
an explanation based
the loss when
vc dimension named
the concept to
attributes to classify
generalization strategies can
some solutions in
25 defines generalization
parameter set that
ffl we assume
data driven generalization
the credit assignment
and state changes
normalized speedups using
in general hypothesis

corpus/krapavin2000-test/628000.txt
extracted
iris
cancer
trained
neurorule
bio
extraction
rules
neural
breast
rule
extracts
5rules
premises
kt
certainty
c4
extract
binarized
discretization
alarm
hidden
versicolor
training
mlp
dedec
mofn
malignant
virginica
extracting
connectionist
network
completeness
anns
lre
cont
fuzzy
soundness
default
kbnn
setosa
consequent
networks
comprehensibility
ann
150
inputs
activation
binarizing
feedforward
342
683
mlps
fired
rulex
recurrent
links
re
cf
fire
hybrid
pruning
dfa
engine
pruned
format
lp
fireable
chi2
flnn
rulenet
conjuncted
discretized
artificial
combinations
symbolic
node
bin
bre
inference
61
binary
false
espresso
comprehensive
features
decisions
capability
architectures
yes
fidelity
measures
classification
benign
96
learning
comprehensible
boundaries
normalized
petal
binarization
linus
howes
promoter
neurofuzzy
kbann
misfired
crook
cebp
backpropagation
attributes
architecture
47
predetermined
testing
cover
measure
sigmoid
degrade
norm
attached
alleviating
97
50
link
incoming
acquisition
continuous
numeric
category
diagnosis
qualitative
body
med
retrained
partial
active
paradigms
decision
factors
logic
notable
six
adjustable
discretizing
supervised
delta
boolean
feature
gamma
refinement
refining
intelligent
95
layer
444
firing
dt
intermediate
localized
output
diagnostic
medical
weighted
ji
mitra
ordering
mimic
suitability
dna
weight
ranking
refine
explanatory
activate
automata
samples
00
expert
black
experts
feasible
examining
unseen
outputs
module
water
embedded
mapping
rewriting
correctly
explanation
patterns
118
regardless
truth
criteria
transparency
nodes
clustering
extracted rules
full re
rule extraction
rules extracted
extracted by
partial re
the extracted
bio re
breast cancer
rules from
input features
extract rules
trained network
extracted rule
default rule
node j
neural networks
of premises
c4 5rules
the trained
from trained
extraction techniques
neural network
measure measure
false alarm
by full
of extracted
extracts rules
extracting rules
iris and
the iris
trained neural
then iris
output nodes
to extract
re is
a rule
input feature
rule evaluation
of rules
the rule
hidden and
and breast
the breast
each extracted
certainty factors
soundness completeness
trained networks
corresponding trained
re and
i 4
l t
the rules
rules are
gamma o
per rule
trained with
completeness false
by bio
discretization boundaries
iris problem
output decisions
inference engine
i 3
input nodes
evaluation procedure
a trained
original rules
premises in
completeness measure
certainty factor
this rule
network architectures
output node
rules with
training network
re technique
re algorithm
network testing
embedded knowledge
cf gamma
and cancer
no body
47 50
alarm no
technique rule
body class
data sets
if i
from network
rule based
networks trained
output mapping
cancer data
three rule
rule is
of input
l h
and i
rule 3
extracted from
the certainty
each hidden
premises are
extraction approaches
iris versicolor
re are
rule iris
the bio
cancer cont
consequent j
incoming links
neurorule and
conditions per
extraction approach
intermediate rule
binary rules
iris virginica
of neurorule
iris cont
cancer problem
final rules
rule rule
rules based
original input
x i
rules in
three performance
hybrid systems
three techniques
hidden nodes
domain knowledge
performance measures
a default
knowledge based
4 input
from networks
all rules
available data
input patterns
input x
connectionist architecture
rule ordering
lp problem
ordering algorithm
rule 4
rule 2
rules that
data set
weighted links
ratio match
premises per
soundness measure
by neurorule
class factor
gamma consequent
hidden output
150 4
fuzzy rules
box rule
network iris
certainty soundness
from feedforward
corresponding networks
iris setosa
if rule
hidden node
activation values
binary inputs
and c4
be active
the network
input output
extraction algorithm
c4 5
yes yes
rule 1
based system
simple boolean
output decision
corresponding rules
the lre
rules is
combinations of
training and
of extracting
the discretization
rules and
rule base
premises of
extraction technique
default rules
boundaries of
rules a
artificial neural
the three
re the
3 rules
3 if
finite state
rules extracted by
the extracted rules
of the extracted
the rules extracted
rule extraction techniques
extract rules from
to extract rules
by full re
of extracted rules
number of premises
and i 4
i 4 1
extracted by the
extracting rules from
rules extracted from
the trained network
and breast cancer
the rule extraction
iris and breast
the breast cancer
each extracted rule
rules from trained
the full re
a default rule
if i 3
completeness false alarm
extracted by full
of premises in
by bio re
extracted from network
extracted rules are
rule evaluation procedure
of the trained
trained neural network
re technique rule
three performance measures
alarm no body
bio re and
measure measure measure
full re is
three rule extraction
no body class
the iris problem
training network testing
technique rule rule
discretization boundaries of
the iris and
soundness completeness false
false alarm no
by the full
rules from the
used to extract
for the iris
input output mapping
breast cancer data
to be active
set of rules
input x i
rule 2 if
rule based system
for the breast
and partial re
rules from networks
the bio re
rule extraction approaches
breast cancer problem
the corresponding trained
rule ordering algorithm
of rules extracted
re and partial
extracts rules from
rules based on
rule 1 if
rule 3 if
and i 3
from trained neural
networks trained with
3 if i
trained neural networks
the inference engine
training and testing
4 1 6
a trained network
simple boolean expression
premises per rule
the three techniques
rules in l
extracted rules a
available data set
body class factor
black box rule
rule extraction technique
original input features
rule extraction algorithm
of extracting rules
the corresponding rules
embedded knowledge in
box rule extraction
the extracted rule
computed by equation
from l t
from network iris
gamma consequent j
i 1 5
extracted rules is
and c4 5rules
of premises per
extraction techniques the
set of extracted
extracted by bio
partial re is
the partial re
8 and i
rules from feedforward
conditions per rule
certainty soundness completeness
6 then iris
then iris versicolor
rule extraction approach
extracted rules and
corresponding rules extracted
4 1 2
of the rule
the original input
hidden and output
in l t
the original rules
knowledge based and
1 6 then
1 5 8
i 2 3
capability of the
the available data
rule extraction from
5 8 and
if i 1
node j is
yes yes yes
the performance of
0 and i
extracted rules can
6 hidden and
rule extraction process
rules from any
47 50 47
rule rule b
cont by full
7 gamma o
sets extracted by
rules and their
initial domain knowledge
then iris setosa
rule b cancer
a rule if
breast cancer databases
and 2 output
all rules extracted
4 input 6
final rules extracted
from trained anns
the certainty factor
the embedded knowledge
re algorithm is
by c4 5rules
certainty factor attached
their corresponding trained
rule with zero
intermediate rule and
corresponding trained networks
and full re
versicolor rule 3
iris setosa rule
extracted rules based
extracted rules to
other two techniques
extracted by both
for each extracted
between hidden and
d 0 7
input nodes for
of l h
of input x
re and full
the three rule
they were extracted
partial re algorithm
gamma node j
the application nature
of input features
bio re algorithm
iris cont and
full re are
and cancer cont
hidden nodes activation
an input feature
from network cancer
act j is
rule extraction module
hidden or output
those extracted by

corpus/krapavin2000-test/628007.txt
leases
lease
volume
clients
server
client
callback
invalidation
stale
renew
poll
consistency
unreachable
timeout
invalidations
servers
writes
messages
cached
expire
delayed
object
cache
files
renewal
web
polling
alidate
reads
workload
expired
timeouts
delay
teapot
coda
inactive
contact
epoch
gwertzman
renews
invalidates
load
read
day
seltzer
expires
expirei
renewlist
renewing
seconds
bursts
trace
workloads
inv
caching
notify
simulator
dahlin
driven
volumes
protocols
murphi
periods
contacting
file
invalidate
alvisi
prashant
amortize
effort
id
send
bytes
caches
protocol
wait
cao
wan
objects
volid
leaseset
renewrecvd
hclient
renewals
invallist
objid
1x10
recieve
deltat
iyengar
disconnected
shenoy
sending
mutable
traces
strong
ack
rees
callbacks
amortizing
currenttime
bursty
arun
traffic
browsers
randal
darrell
valid
failures
reconnection
accesses
expects
10000
news
delays
peak
pending
expiration
longest
vnum
9734185
renewall
renu
invalidating
purushottam
awards
inval
tewari
validlease
renewlease
spawar
hobjid
9624082
recoverunreachableclient
9733842
volepoch
receive
short
krithi
indefinitely
ramamritham
network
accessing
maintaining
message
mike
crashes
burns
tolerance
sent
article
http
100
loaded
8911
gifts
cheriton
unknowingly
farm
cise
n66001
fault
axis
novell
renewed
tot
minutes
browser
dissemination
modified
copies
reboot
bayou
bestavros
kulkarni
popular
examine
amortized
abort
old
sends
ccr
modifying
heavily
requests
000
write
request
microsystems
rises
discard
track
career
synthetically
lorenzo
weak
coherence
frequency
overhead
tolerable
volume leases
volume lease
the server
object leases
delay volume
volume t
stale data
invalidation messages
the client
a client
object lease
a server
leases on
the lease
the volume
cache consistency
strong consistency
clients that
best effort
a volume
server driven
delayed invalidations
unreachable set
client poll
per day
the object
lease algorithms
inv alidate
lease expires
all clients
an object
t v
of clients
server load
leases for
leases with
valid object
leases to
to contact
the unreachable
server state
a lease
t 100
client s
to clients
to renew
hold valid
gwertzman and
poll each
lease t
long object
lease algorithm
lease renewal
the files
with delayed
v id
the write
cached objects
driven protocols
of writes
consistency algorithms
and volume
messages to
distributed file
bursts of
volume v
client polling
writes per
volume algorithms
client reads
object invalidation
short leases
leases reduce
have expired
notify clients
see stale
valid leases
the teapot
t timeout
leases algorithm
stale time
leases have
and seltzer
callback and
effort volume
callback algorithm
each read
t 10
server can
server to
clients to
effort algorithms
clients whose
the trace
this workload
network failure
timeout in
whose volume
of volume
cost of
servers to
cached object
day change
r deltat
lease for
arun iyengar
000 seconds
o version
o volume
clients read
inactive clients
disconnected clients
o id
write frequency
wait delay
renew a
epoch number
poll and
ack inv
vs timeout
server writes
of renewing
lease on
short volume
for inactive
long leases
teapot version
the cost
our simulator
cached data
weak consistency
files a
o be
a write
object for
that hold
cached copies
day of
driven consistency
modifying an
fewer messages
prashant shenoy
before modifying
the cached
of messages
consistency in
wide web
let o
world wide
server and
from server
all reads
a news
100 seconds
server from
loaded server
client and
indicates how
object o
file systems
consistency protocols
which clients
a valid
the servers
object a
writes to
most heavily
clients with
of reads
are modified
the leases
when popular
1x10 7
expires a
must contact
leases provide
write workload
default workload
poll algorithm
change probability
inactive set
consistency state
that servers
read cost
v unreachable
same volume
renews the
darrell d
delayed invalidation
writes until
lease the
randal c
renew lease
writes when
leases when
sending invalidations
recieve times
invalidations algorithm
receive renew
front page
delay volume t
the volume lease
volume leases with
volume t 100
the volume leases
t t v
poll each read
clients that hold
leases with delayed
all clients that
invalidation messages to
volume t 10
of volume leases
number of clients
gwertzman and seltzer
best effort volume
writes per day
see stale data
to the unreachable
the unreachable set
timeout in seconds
the cost of
of the files
best effort algorithms
o be the
the client s
number of messages
let o be
be the object
if a client
number of writes
before modifying an
client poll and
object is modified
valid leases on
for inactive clients
server driven consistency
whose volume leases
the teapot version
callback and volume
volume leases for
of writes per
leases reduce the
long object leases
t timeout in
ack inv alidate
modifying an object
volume lease algorithms
that hold valid
the best effort
object a server
leases on the
volume leases algorithm
clients whose volume
to all clients
per day change
object for which
objects are modified
object invalidation messages
the lease algorithms
hold valid object
effort volume leases
per day of
with delayed invalidations
day of 0
in the trace
world wide web
the server to
for distributed file
heavily loaded server
distributed file systems
cache consistency protocols
most heavily loaded
an object a
files in the
an expected number
load on the
on the server
the server can
of all files
10 delay volume
unreachable set and
to cached data
object lease t
burns robert m
notify clients of
10000 delay volume
liu and cao
a network failure
the callback algorithm
day change probability
recieve times out
indicates how long
leases have expired
a volume lease
volume leases have
volume leases to
the same volume
the volume algorithms
invalidation messages and
volume lease the
note if any
abort the read
volume lease timeouts
contact to contact
stale data to
be the longest
when popular objects
a news service
delay volume 1x10
change probability of
popular objects are
inv alidate o
t 10 delay
lease renewal over
dahlin arun iyengar
a server can
a cached object
100 000 seconds
c burns robert
to contact to
randal c burns
min t t
darrell d e
alidate o id
client driven protocols
if any recieve
a valid object
robert m rees
and object lease
holds a valid
out abort the
volume 1x10 7
and seltzer 10
server driven protocols
the lease expires
t delay volume
leases volume leases
and volume leases
of object leases
valid object lease
poll and object
a per day
server to renew
mike dahlin arun
files a per
fewer messages than
delayed invalidations algorithm
cost of renewing
volume lease expires
any recieve times
times out abort
d e long
the write cost
unreachable set it
have an expected
expires a client
renew a volume
valid object leases
short volume leases
strong consistency in
of clients with
a server from
the object s
on world wide
conference on world
and the server
t v to
the files a
cache consistency algorithms
differences among the
of all reads
on stable storage
for this workload
in large scale
is modified the
a client has
amount of state
amortize the cost
objects from the
workload for the
if the client
clients that have
large scale systems
the object for
the client may
the x axis
of the algorithms
when a client
messages to all
the client to
wide web may
the client and
when an object
by the server
of messages sent
clients with lease
lease expires at
each algorithm discussed
clients never see

corpus/krapavin2000-test/628018.txt
ant
ants
grasp
qap
colony
trace
tabu
nugent
dorigo
activity
permutation
colonies
facility
coupling
assignment
couplings
burkard
gilmore
gl
offices
stagnation
88900
pheromone
floors
maniezzo
autocatalytic
location
lawler
ij
population
quadratic
activities
1994
aco
middendorf
725522
metaheuristics
buildings
optimum
evolutionary
krarup
facilities
tsp
floor
man
ching
layout
minutes
pardalos
6156
end_test
schmeck
boryczka
68360
merkle
elshafei
qaplib
locations
heuristic
persistence
matrices
ih
probl
1968
taillard
intensity
permutations
agents
heuristics
probabilistically
artificial
units
hartmut
vittorio
hospital
substance
company
life
indices
solutions
marco
tentatively
desirability
passage
li
genetic
dimension
inspired
salesman
week
unassigned
00
assigning
tower
quantity
assign
sec
sciencesinformatics
bk
employees
percentage
assigned
datum
managers
numbered
martin
objective
coefficient
logistic
liang
reconfigurable
166
emergence
accumulation
1984
matrix
hybrid
flow
norwell
traveling
neighborhood
arrangement
allocation
goodness
avg
coeteris
8120
evaporation
1740
vitorino
wenbing
6124
58993040
quali
wade
iasme
solnon
pronged
rosa
agostinho
ste36a
conveyance
9698
dragon
testcase
walkways
maxiter
alimohammadi
esc32d
rou20
599948
gonzales
shxyong
milan
rizzi
mckendall
fenet
zomaya
shiyan
hospitals
gambardella
6298
footpaths
problema
assegnamento
17212548
565541
colorni
abbasi
438114
11971900
dras
shyang
desirabilities
multinational
uffici
fernandes
1957
1289
formiche
applicato
kra30a
9526
liman
vrat
quadratico
chr22a
solimanpur
salhi
7124
denebourg
carbonaro
339416
134641
hossam
koopmans
reischle
urszula
4539
subrata
the ant
ant system
the ants
quadratic assignment
an ant
assignment problem
to location
the trace
ant colony
th ant
coupling i
colony optimization
al 1994
of ants
the qap
ant colonies
activity j
location i
the tabu
tabu list
0 00
the quadratic
best solution
local search
10 minutes
by grasp
trace matrix
by ant
t best
each ant
dorigo et
the offices
the best
over 5
best solutions
5 runs
solution found
the permutation
k th
of trace
artificial life
good solutions
best known
objective function
or best
li et
of dimension
et al
ants which
ant is
constructed their
ant population
man sec
martin middendorf
ant algorithm
ants have
best permutation
marco dorigo
facility to
al 1996
the coupling
known solution
location 1
burkard et
system applied
system algorithm
percentage error
already assigned
and lawler
partial assignment
search procedure
research v
the objective
s k
the indices
operations research
the population
colony system
best best
ij of
therefore z
location 2
life v
the k
the already
solutions the
runs of
the assignment
lower bound
of activity
its best
of order
numbered from
results obtained
the optimum
have constructed
quantity of
a facility
indices of
and operations
a permutation
the problems
n 3
and flow
coupling is
evolutionary heuristics
1994 the
error percentage
vittorio maniezzo
trace level
floor numbered
subsets 1
ant in
pheromone which
permutation found
goodness ij
for grasp
qap of
ant s
experience acquired
lawler bound
possibilities remain
ant chooses
the traveling
flow matrices
the qaplib
maniezzo et
hartmut schmeck
hospital layout
tabu k
nugent et
the gilmore
ants on
percentage distance
ant and
d ih
autocatalytic process
dimension 20
taillard 1990
produce its
trace intensity
optimum or
computer decision
trace persistence
gl bound
location h
change true
all 45
opt bk
choosing probabilistically
choice goes
yet assigned
complete permutation
distributed heuristic
m ants
potential goodness
logistic situation
z gl
88900 0
assigning facility
colonies and
making kluwer
sub optimum
substance called
burkard 1984
ant has
ant algorithms
725522 0
of aco
gilmore lawler
solution computed
trace left
nugent nugent
daniel merkle
al 1968
of ant
45 problems
ih f
minutes each
whose costs
lawler lower
metaheuristics computer
man hours
this datum
in dorigo
n locations
three units
still unassigned
floors of
merkle martin
a substance
trace the
as z
dimension n
the units
the location
inspired by
lower bounds
computers and
assign to
the ant system
quadratic assignment problem
the quadratic assignment
k th ant
by the ant
coupling i j
all the ants
ant colony optimization
et al 1994
to location i
the tabu list
the best solution
the objective function
j to location
of the ant
dorigo et al
5 runs of
or best known
the trace matrix
over 5 runs
activity j to
the k th
local search procedure
to the indices
of the objective
best solution found
li et al
for the quadratic
of the trace
the local search
computers and operations
and operations research
operations research v
bounds are therefore
ants have constructed
on the coupling
facility to assign
the coupling i
ant system algorithm
the best permutation
of 10 minutes
quantity of trace
have constructed their
are therefore z
obtained by grasp
to location 1
number of ants
to location 2
ant system applied
for the qap
the ant population
the ants have
et al 1996
lower bound to
system applied to
burkard et al
a partial assignment
best known solution
indices of the
by the k
artificial life v
ant colony system
the indices of
obtained by the
bound to the
to the quadratic
the quantity of
according to equation
results obtained by
of the best
lower bounds are
n 3 p
of trace left
of activity j
two subsets 1
to produce its
gilmore and lawler
by ant colonies
by the ants
of the ij
et al 1968
n 3 as
optimum or best
dimension n n
z the choice
location 3 the
166 mhz machine
define the assignment
ant system in
an ant algorithm
the ant is
location i is
location i and
best average over
the choice goes
optimal or best
best known results
floor numbered from
best best result
solution s k
by choosing probabilistically
to assigning facility
traveling salesman problem
nugent et al
produce its best
of ant colonies
assignment to location
therefore z the
the optimum or
of a coupling
distributed heuristic algorithm
best result obtained
percentage distance from
an ant chooses
tabu list for
the still unassigned
best permutation found
qap of order
making kluwer academic
ant chooses a
tabu list is
metaheuristics computer decision
88900 0 00
d ih f
best error t
experience acquired by
to the completion
the trace intensity
the flows between
200 0 00
percentage error of
in dorigo et
computer decision making
solution computed over
the traveling salesman
goodness ij of
ant colonies and
3 as it
choice goes to
and lawler bound
for the ant
subsets 1 and
seconds needed by
the experience acquired
a substance called
called the ant
maniezzo et al
a distributed heuristic
not yet assigned
the facility to
decision making kluwer
average over 5
in the ant
its best solutions
distance and flow
the potential goodness
all 45 problems
725522 0 00
on 5 different
whose costs are
assign to location
lawler lower bound
daniel merkle martin
best known solutions
t best average
behavior of ant
goes to assigning
one must thus
and flow matrices
from the optimum
gilmore lawler lower
of the offices
10 minutes each
known solution computed
level one needs
error t best
potential goodness ij
costs are the
3 p 155
the already assigned
f s k
over all 45
merkle martin middendorf
error percentage error
inspired by the
the algorithm s
problem of dimension
m n 3
on a maximum
journal of heuristics
the assignment to
of the still
in li et
result obtained by
a new heuristic
best solution obtained
search procedure is
the best solutions
the permutation is
assignment problem the

corpus/krapavin2000-test/628025.txt
interestingness
actionable
patterns
p_age
discovered
unexpected
yes
attribute
ranking
subjective
consequent
fuzzy
her
unexpectedness
discovery
confirming
matching
attr
mining
pattern
match
action
ranked
a1
rank
actionability
consequents
beliefs
killed
she
kefir
feelings
actions
contradictory
unanticipated
bing
conditional
second_action
first_action
injury
database
discover
belief
names
propositions
a3
measures
act
sigkdd
his
novelty
uninteresting
rankings
c4
contradicting
finding
linguistic
expectations
saroj
wynne
bad_accident
educate
kaidi
re_a1
benkler
bad_visibility
opu
junct
0explanation
a4
universe
cut
proposition
membership
weimin
semantic
degrees
degree
expects
interests
specified
huge
he
philadelphia
comprehend
ops
formulas
him
objective
association
asking
significance
grade
old
confirm
intuitive
deviations
a7
overwhelmed
accident
conformity
oxford
findings
poor
12th
soft
health
continuous
install
confidentiality
cameras
user
useless
liu
hsu
coverage
experts
50
25th
something
slow
listed
xiao
expectation
production
name
databases
explanation
parts
zhao
ranks
visibility
recommended
interactive
jeffrey
meanings
people
49
kth
explora
sugato
susumu
horiguchi
underweight
good_visibility
conformities
joydeep
actionabilities
hwee
health_con
pasupuleti
discoverable
krupakar
disocvery
discourse
angeline
liqiang
phan
pa
rules
operators
classification
b1
off
discrete
handbook
press
age
mooney
evidences
shekar
geng
modifiable
a10
talip
quintuple
fashions
bends
minh
healthcare
inoguchi
pazzani
inconclusive
bao
abstractone
65
insufficient
apart
asian
xindong
bharadwaj
niall
hurricane
hamilton
413
shichao
leng
hierachical
confidence
against
class yes
discovered patterns
unexpected patterns
the discovered
the user
finding unexpected
if p_age
user specified
actionable patterns
specified pattern
q d
his her
expected patterns
of match
the patterns
finding actionable
p_age 50
confirming user
subjective interestingness
w i
of patterns
patterns are
discovered pattern
conditional parts
b i
i j
knowledge discovery
the interestingness
patterns in
pattern 1
pattern 2
user s
e j
attribute names
of interestingness
expected pattern
act q
the attribute
i q
those patterns
interestingness of
user expected
matching values
data mining
patterns according
b q
match of
s knowledge
he she
the degree
proposed technique
r z
attribute values
for finding
actionable according
off because
low matching
class no
yes 1
yes actionable
2 class
objective measures
interesting patterns
the subjective
1 class
a fuzzy
subjective measures
their low
consequent parts
0 yes
degree of
patterns and
the consequent
the matching
rank the
are cut
classification patterns
the consequents
yes pattern
specified action
z a
patterns that
interestingness in
match well
patterns discovered
matching technique
interestingness measures
her expected
fuzzy matching
cut off
no 0
the fuzzy
for ranking
a discovered
action 2
the proposed
the conditional
yes no
measures are
contradicting user
semantic rule
ranked higher
higher a
action pattern
a explanation
discrete attribute
previous knowledge
action patterns
intuitive feelings
interestingness problem
bing liu
action 1
patterns it
patterns the
a r
attribute name
knowledge or
the database
patterns e
user to
to user
be ranked
to discover
8 11
two propositions
this ranking
of b
patterns with
j k
fuzzy set
attribute value
z i
a pattern
v i
of attribute
find those
pattern is
patterns for
to rank
killed 3
value match
p_age 65
for confirming
matching attribute
name match
a1 49
universe or
denote w
65 killed
specified expected
yes class
computing w
action y
yes contradicting
if killed
higher w
their interestingness
yes confirming
1 confirming
computed as
discovery and
sigkdd international
acm sigkdd
c4 5
2 finding
domain knowledge
matching of
technique is
the semantic
huge number
patterns 3
patterns is
proposed method
then rank
user patterns
pattern e
pattern b
j value
user 4
him her
by asking
unexpected consequent
asking the
interestingness is
to him
are unexpected
or intuitive
to his
degrees of
ranking the
matching algorithm
discovered by
a a
to their
of ranking
ranking results
test example
50 this
names of
and e
the discovered patterns
user specified pattern
finding unexpected patterns
if p_age 50
finding actionable patterns
i q d
degree of match
b q d
the conditional parts
specified pattern 1
b i and
of b i
r z a
user s knowledge
for finding unexpected
a r z
and e j
the degree of
w i j
of the patterns
patterns according to
the user s
v i j
i and e
parts of b
the user specified
to the user
patterns are cut
the attribute names
no 0 yes
according to user
the patterns are
yes actionable according
low matching values
class yes actionable
1 class yes
cut off because
actionable according to
their low matching
of their low
0 yes 1
of match of
specified pattern 2
for finding actionable
class yes no
pattern 1 class
off because of
to user specified
a i j
the proposed technique
the patterns in
yes no 0
rank the discovered
the subjective interestingness
according to their
are cut off
set of patterns
confirming user specified
class yes pattern
his her expected
a discovered pattern
2 class yes
confirming user s
user specified action
conditional parts of
i j k
number of patterns
match of the
computed as follows
is computed as
the user to
and z i
z i j
the interestingness problem
3 if p_age
attribute names of
specified action pattern
discovered patterns according
user expected patterns
ranked higher a
be ranked higher
those patterns that
1 if p_age
of interesting patterns
contradicting user specified
find those patterns
set of interesting
semantic rule for
will be ranked
a fuzzy matching
e j are
her expected patterns
and the user
proposed technique is
the interestingness of
of the discovered
8 11 12
to his her
the consequent parts
4 8 11
to find those
because of their
a a a
k and z
in b q
w i is
of patterns in
discovery and data
knowledge discovery and
and data mining
the set of
conference on knowledge
sigkdd international conference
acm sigkdd international
i j is
on knowledge discovery
j k and
i is computed
attribute name match
higher w i
the universe or
by asking the
of expected patterns
universe or domain
2 class no
p_age 65 killed
method for ranking
of match between
asking the user
each action y
of user expected
discovered by q
pattern b i
interesting to him
i j value
p_age 50 this
pattern 1 the
or intuitive feelings
b i whose
matching values 6
yes contradicting user
killed 3 if
2 if killed
of match for
denote w i
j value for
to their interestingness
if p_age 65
q on d
unexpected patterns for
run the focus
this ranking is
patterns in i
one user specified
the semantic rule
or domain of
pattern 2 class
computing w i
previous knowledge or
of membership of
the discovered pattern
class yes contradicting
yes confirming user
in i q
a test example
we denote w
yes class yes
types of ranking
patterns in b
action y q
degree of membership
user specified expected
unexpected patterns and
class yes class
is listed below
degrees of match
1 confirming user
user expected pattern
g 4 8
value for b
to him her
fuzzy matching technique
the fuzzy set
the user 4
a a explanation
class yes confirming
since this ranking
interested in different
ranking is to
those patterns whose
actionable patterns the
knowledge or intuitive
set of expected
the proposed method
huge number of
to be taken
patterns in the
in the database
degrees of interestingness
subjective measures are

corpus/krapavin2000-test/628028.txt
categorization
document
category
retrieval
hersh
corpus
documents
text
categories
avgp
ohsumed
query
c35
scores
mesh
score
medline
c0
training
vocabulary
automatic
c50
learning
perspective
metric
manually
baseline
manual
b2
advanced
na
docs
l0
micro
exemplars
l35
l50
upsilon
vocabularies
collection
selection
psi
yang
extraction
frequency
categorized
conducted
statistically
exemplar
rtt
feedback
precision
perspectives
b1
lewis
te
disease
stems
collections
phrases
ranked
weight
classifiers
wilcoxon
cat
diff
representations
wrt
tuning
queries
trec
strategies
experiment
heart
smart
medical
word
pool
learned
runs
1987
combinations
rarity
5619
masand
4326
atn
gammatext
586
metrics
retrieved
tested
rank
tf
vectors
assigned
headings
hoff
hsin
widrow
strategy
758
stories
relevance
signed
quality
worse
row
expert
baselines
stemmed
controlled
classifier
decision
43
descending
conduct
asterisk
1990
weighting
summary
classifying
focal
options
operates
judged
stemming
481
75
automatically
1991
decisions
differences
experts
phrase
96
tables
vector
assessed
ki
significantly
adopt
title
articles
1989
inverse
investigate
231
183
chung
yielded
normalized
rocchio
catego
5080
4789
5526
lame
guiraude
5448
selamat
5083
goren
6098
newswire
5402
omatu
tayfun
tically
5106
okapi
comprehended
5456
evren
tsvi
llsf
karaca
kucukyilmaz
kuflik
sigeru
padmini
saphire
innovating
5754
matched
statistical
classification
similarity
assignments
indexing
theta
web
free
organizing
extracted
barla
thematic
gamma7
rization
604
automatic categorization
parameter selection
hersh corpus
the hersh
the category
free text
the categorization
query design
perspective metric
retrieval performance
text retrieval
category vector
selection process
the document
categorization approach
advanced query
category perspective
text vector
training collection
text categorization
a document
category learning
the retrieval
mesh category
category extraction
11 avgp
learning model
the automatic
test collection
the parameter
the ohsumed
retrieval feedback
document perspective
1 score
1 scores
parameter combinations
mean f
ohsumed corpus
categorization process
f 1
categories for
documents in
manually assigned
extraction process
selection mean
mesh categories
vocabulary differences
10 avgp
the categories
scores for
each document
of categories
simple query
document collection
the training
the free
categories are
of documents
the mesh
the c0
decision perspective
quality metric
docs table
manual categorization
c35 and
baseline 1
part i
categorization is
for text
document in
the baseline
parameter values
by query
the manual
the query
instance based
micro f
tuning set
word stems
training document
runs based
our categorization
baseline 2
and c50
category vectors
categorization evaluation
query analysis
the advanced
document frequency
were tested
the weight
documents from
assigned categories
the medline
categorization performance
query by
vector is
query s
the documents
to text
document is
technique known
based learning
categories associated
automatic strategy
categories assigned
run docs
mean micro
quality metrics
heart disease
in psi
retrieval experiment
of exemplars
na na
categorization strategies
c0 c35
categories f
retrieval strategies
automatic text
inverse document
each category
design the
term frequency
score for
performance using
document s
selection based
retrieval experiments
document representations
categorization to
a query
a category
ranked in
automatic method
performance achieved
metric as
our retrieval
significantly better
categorization and
the 11
new document
all categories
metric this
evaluation based
the rtt
the term
avgp score
set psi
test query
medline test
document instances
category pool
586 documents
tr collection
rtt collection
combinations tested
corpus 4
categories may
c50 runs
appropriate categories
l0 0
assigned mesh
test collections
and l50
from 1987
precision scores
rank test
corpus in
avgp 11
c0 run
run parameter
m categories
query representations
medline database
1987 to
point average
the tr
text portion
differences controlled
trec 3
advanced queries
a categorization
l35 and
documents assigned
96 parameter
wilcoxon signed
process table
best strategies
using manual
different automatic
signed rank
learned categories
l0 l35
no categorization
based categorization
mesh phrases
perspective results
collection were
perspective hersh
43 0
the hersh corpus
parameter selection process
the parameter selection
the free text
free text vector
the retrieval performance
advanced query design
the training collection
category learning model
for the hersh
f 1 scores
f 1 score
category extraction process
the category extraction
mean f 1
category perspective metric
the automatic categorization
the ohsumed corpus
scores for the
query by query
parameter selection mean
1 scores for
the category perspective
the mesh category
the advanced query
simple query design
number of documents
by query analysis
the category learning
the test collection
instance based learning
mesh category vector
to text retrieval
category vector is
selection process the
the query s
in part i
runs based on
a free text
free text and
vector is derived
the categorization process
automatic categorization is
query design the
document perspective metric
automatic categorization approach
c35 and c50
the category vector
the categorization performance
technique known as
automatic text categorization
in the parameter
respectively for the
for each category
categories for a
investigate the application
for the ohsumed
that the automatic
a quality metric
micro f 1
text vector is
mean micro f
text vector and
parameter selection based
selection mean f
automatic categorization strategies
categories f 1
of the categorization
run docs table
the baseline 1
the categorization approach
manually assigned categories
set of exemplars
decision perspective metric
categories associated with
the document perspective
the simple query
c0 c35 and
on the hersh
summary of runs
the mean f
mesh category vectors
the automatic strategy
of the document
inverse document frequency
in the training
to the category
automatic method is
for text retrieval
the automatic method
is the weight
to the document
and the category
a query by
method is significantly
documents in the
the weight of
is significantly better
evaluation based on
on the tr
described in part
metric as described
performance compared with
automatically the number
known as instance
our categorization approach
perspective metric the
as instance based
vocabulary differences controlled
the medline database
categories assigned to
perspective metric as
to a document
the heart disease
perspective results on
with no categorization
retrieval performance compared
that automatic categorization
the category pool
selection based categorization
different parameter combinations
the appropriate categories
the mesh phrases
documents assigned to
signed rank test
perspective hersh corpus
documents in psi
known as retrieval
performance achieved using
evaluate the categorization
the learned categories
l0 l35 and
metric this evaluation
the tr collection
free text portion
run parameter selection
from 1987 to
the 10 avgp
training document collection
of runs based
documents from 1987
hersh corpus in
automatic categorization based
the 11 avgp
manually assigned mesh
derived by automatic
categorization evaluation based
using manual categorization
the tuning set
categorization approach is
appropriate categories for
compared with no
previous work 16
by automatic categorization
retrieval performance achieved
the categories for
the rtt collection
using a quality
of documents assigned
point average precision
l35 and l50
perspective metric this
categories may be
categorization to text
that the manual
measure the categorization
different automatic categorization
96 parameter combinations
as retrieval feedback
wilcoxon signed rank
retrieval technique known
selection mean micro
of automatic categorization
and c50 runs
11 avgp score
individual test query
based categorization evaluation
the decision perspective
parameter combinations tested
in a document
document in the
the documents in
of documents in
and m are
categorization based on
set of categories
score for the
categories in our
are ranked in
each individual test
text retrieval for
based learning and
values for n
n and m
significantly better than
was used as
on the document
the term i
text categorization and
15 and 20

corpus/krapavin2000-test/628030.txt
weak
transaction
strict
copies
ias
quasi
cluster
reconciliation
schedule
consistency
writes
mobile
core
intracluster
wt
iasg
item
read
copy
serializability
ww
clusters
sw
disconnections
intercluster
sr
updates
reads
ies
replication
iesg
disconnected
hot
st
cold
items
op
coherency
schema
inconsistency
disconnection
wr
connectivity
bandwidth
quorum
transactions
serial
lock
conflicts
integrity
cl
serialization
committed
sites
database
conflict
divergence
weakly
1c
commit
permanent
networking
messages
correctness
abort
rowa
locality
divergent
throughput
bayou
acyclic
allowable
vacation
replicated
clients
nl
response
currency
aborted
sg
eventual
client
concurrency
ignorant
initiated
commitment
200bps
iots
consistent
contention
translation
wireless
reconciling
intermittent
projection
adaptivity
locally
criterion
host
tentative
granule
esr
2mbps
inconsistent
availability
roll
server
update
rolled
reconciled
replica
trans
hosts
latency
operate
ranges
arrival
coda
file
middleware
locks
strongly
sec
immediate
adaptability
acyclicity
conservative
compatibility
cached
tuned
semantics
bellavista
stefanelli
hotspots
corradi
dependency
conditionally
undone
serializable
rate
duration
050
queries
edge
modes
environments
managers
wired
protocols
optimistic
plugged
cesare
roncancio
alvarado
montanari
date
management
wrote
propagate
service
aware
probability
synchronizing
iff
located
intervals
globally
laptops
claudia
030
intermittently
users
attain
projections
session
write
network
belong
prevailing
serrano
extremes
percentage
frequently
effort
depicts
accesses
3000
interface
barriers
gamma4
rebecca
transmission
imposed
databases
accepted
precedence
portable
requirements
ignorance
connected
weak transactions
strict transactions
core copies
quasi copies
and strict
data item
strict transaction
weak transaction
consistency factor
of weak
weak and
schedule s
s ias
intracluster schedule
a strict
one copy
strict read
a weak
data items
weak read
core copy
weak connectivity
weak operations
copy serializability
the transaction
only transactions
serial schedule
quasi copy
strict write
networking conditions
weak writes
transactions that
among copies
transactions in
a transaction
same cluster
read only
each cluster
transactions at
transactions are
for strict
of transactions
a cluster
and weak
copies of
copies and
the iasg
st j
hot data
reads x
serialization graph
a data
core and
copies at
and quasi
of messages
in mobile
response time
strict operations
the iesg
weak write
sw x
s 1c
an intracluster
ias schedule
data copies
bounded inconsistency
database state
consistency requirements
disconnected operation
translation function
data copy
read operation
since weak
connected sites
intercluster schedule
s ies
replication schema
between weak
cold data
wr ww
ww sr
input rate
transaction wt
sr sw
of abort
cluster cl
only weak
the consistency
mobile computing
transactions is
operations on
different clusters
integrity constraints
st i
copies are
from relationship
transaction and
available bandwidth
correctness criterion
a mobile
for mobile
in s
allowable input
divergent copies
disconnection intervals
coherency control
copy serial
on strict
strongly correct
d consistency
only core
cluster and
read and
write operations
cl i
copy at
strict and
item x
the database
written by
a core
is acyclic
copies that
conflict equivalent
ias is
system throughput
a read
for weak
best effort
read operations
maximum allowable
j reads
transactions read
value read
x from
copies the
transaction that
in cases
copies located
currency requirements
data contention
of disconnections
an ias
other weak
locally available
the reconciliation
abort times
transaction st
access hot
x reads
the coherency
the intracluster
weakly correct
dependency edge
since strict
local quasi
iesg we
same copy
transactions do
they access
transactions can
a serial
ranges from
on data
the probability
q r
probability that
of strict
reads from
the response
is conflict
projection on
a replication
write operation
transactions the
at different
factor c
the quasi
serializability of
all copies
processing time
arrival rate
the ias
read quorum
at cluster
strict consistency
database interface
of cold
per cluster
mobile file
each weak
that st
of data
per data
consistency in
s s
sites are
transactions have
conflicts between
weak and strict
and strict transactions
a strict transaction
a data item
a weak transaction
of weak transactions
at each cluster
one copy serializability
weak transactions at
the same cluster
the consistency factor
number of messages
on a data
for strict transactions
reads x from
core and quasi
read only transactions
at different clusters
of weak and
in cases of
copies of x
number of weak
and weak transactions
serial schedule s
a core copy
an intracluster schedule
operations on data
quasi copies of
weak transactions that
weak transaction wt
weak transactions in
intracluster schedule s
a data copy
and quasi copies
wr ww sr
at a cluster
probability of abort
ww sr sw
strict transactions is
transactions in s
of data items
on strict transactions
a quasi copy
one copy serial
core copies of
a one copy
st j reads
j reads x
weak transactions are
copy serial schedule
only core copies
consistency factor c
quasi copies at
allowable input rate
since weak transactions
of strict transactions
copy at a
in s ias
a serial schedule
the available bandwidth
data item x
order of transactions
of transactions in
reads from relationship
the value read
is conflict equivalent
transactions can be
the response time
and best effort
the probability that
operation on a
copies of a
in s s
the database state
transactions do not
transactions in the
its projection on
in s 1c
is strongly correct
if a strict
strict transaction st
sw x x
transactions at different
core copy at
the same copy
the iesg we
to a serial
in the iasg
copy of x
conflicts between weak
has a core
copies located at
weak read only
copy serializability of
translation function that
rate for updates
of abort times
transaction of type
core copies are
serializability of the
at cluster cl
strongly connected sites
on data copies
for weak transactions
sr sw x
and a strict
maximum allowable input
other weak transactions
per data item
a strict write
the quasi copies
a dependency edge
strict and weak
schedule s ias
weak transactions do
core copies and
percentage of weak
consistency factor figure
ranges from 0
of x and
read and write
be the probability
up to date
of a data
the projection of
of the transaction
the most up
degree of divergence
conflict equivalent to
values written by
on data items
of read operations
into a number
for various values
and write operations
that a transaction
various values of
most up to
the database management
the serialization graph
schedule s is
cluster cl i
projection of s
maximum number of
as the value
by the transaction
of s on
of the consistency
same cluster and
transactions at the
data has a
0 to 1
belong to the
number of read
equivalent to a
of a strict
that a weak
and perform permanent
types of translation
and strict operations
transactions at other
core copy is
strict transactions the
a strict read
s ias is
an ias schedule
weak write ww
a path whose
data located at
be effectively tuned
duration of disconnections
local quasi copies
among copies located
of cold core
data items per
by strict transactions
input rate for
data item have
connected sites belong
s ias and
copies and weak
first edge is
items per cluster
that st j
copies that have
at the cluster
available bandwidth and
divergence among copies
on core copies
weak connectivity in
strict write operation
weak transactions the
strict write sw
weak and a
an intercluster schedule
all quasi copies
strict read sr
strict transactions and
database state x
values of bandwidth

corpus/krapavin2000-test/628040.txt
spatial
rectangles
queries
query
eq
join
da
workspace
analytical
yufei
papadias
kf93
sj
density
na
dimitris
buffer
tree
formulae
intsect
n5
accesses
indexes
pstw93
lbeach
tao
trees
window
disk
height
skewed
fsr87
tss98
buffering
joins
rectangle
rel
uniformity
leaf
mbr
indexing
estimations
entries
er1
oid
multidimensional
node
bur91
readpage
x_y
3_1
3_3
na_total
3_2
1_3
1_2
ll98
mgcounty
2_1
2_2
2_3
hits
countries
uniform
lb
selection
gut84
spatio
overlap
synthetic
gis
tods
intersected
mg
r1
database
e1
ptr
bkss90
fk94
sdbms
gun93
1_1
estimation
fanout
faloutsos
representative
surface
tiger
formula
parent
proposals
populated
databases
distributions
cardinality
projections
lru
samet
packed
selectivity
geographical
overlaps
subsection
directional
sams
rect
skyline
fklog
srf87
shuirupdqfh
ohyho
rl85
bugra
bkss94
uhodwlyh
qrgh
motorways
ts96
distanced
gunther
jimeng
brinkhoff
hjr97
r_node
pagel
gedik
pams
gg95
fractal
geometry
eqs
perimeter
h1
child
capacity
experimental
index
lsd
traina
pt97
er2
bang
ps96
o5
guttman
80k
cad
average
dimensional
management
e2
multimedia
ss
dbms
seeger
tpr
roads
bureau
jun
dotted
hanan
encloses
enclosure
centers
plotted
d2
prediction
census
20k
fd
objects
hardly
_
b1
entry
dimension
r2
shu
histograms
2003
north
temporal
bernhard
plays
costs
kamel
sigmod
object
a1
estimate
yannis
nodes
extent
affects
extracted
greg
28th
grouping
gain
l r
r tree
tree r
r l
r trees
join queries
level l
r r
r 1
data sets
at level
r d
the r
path buffer
selection queries
query window
node rectangles
range queries
data set
node accesses
uniform like
dimitris papadias
yufei tao
cost models
for selection
of node
non uniform
data properties
density d
d l
data rectangles
disk accesses
real data
of spatial
spatial data
window q
for join
r 2
join query
using r
algorithm sj
spatial queries
uniform data
average size
the density
the workspace
spatial joins
for spatial
the analytical
tree indexes
density surface
r da
1 r
tree index
and join
r s
l l
the average
r h
s s
da r
s intsect
representative points
analytical formulae
entries of
queries on
formulae for
na and
relative error
the query
r i
of r
rectangles at
tao dimitris
an r
access methods
average number
the cost
spatial query
uniformity assumption
eq 14
analytical estimations
da l
non point
node disk
rel 1
with average
r n
node capacity
tree performance
two r
r total
that overlap
access cost
skewed data
experimental results
1 l
data distributions
the tree
density of
like data
and da
spatial objects
joins using
properties only
a query
dimensional data
k l
two dimensional
analytical model
point or
of data
2_1 2_2
3_1 3_2
2_2 2_3
kf93 pstw93
3_3 representative
x_y node
papadias yufei
points x_y
query between
proposed analytical
na_total r
corresponding r
1_2 1_3
actual density
average extent
false hits
1_3 2_1
2_3 3_1
density l
3_2 3_3
per axis
buffering scheme
by eq
tree based
query processing
d of
of disk
cost of
that plays
point queries
d r
analytical results
for r
the data
cost model
spatio temporal
synthetic and
tree node
cost estimation
systems tods
query optimization
tods v
of nodes
the proposed
buffering mechanism
cost formulae
average density
n rectangles
database systems
eq 12
of entries
spatial databases
cost analysis
a leaf
a join
on database
queries using
accesses for
indexing methods
around 10
spatial selection
selection query
and density
refinement step
on dimension
queries proceedings
relation rel
dimension k
in spatial
a spatial
eq 17
wide set
overlaps with
a skewed
lru buffer
spatial join
illustrated in
size s
the height
tree structure
models for
the experimental
height of
cardinality n
rectangles with
random data
leaf level
leaf node
r l r
l r l
the r tree
d l r
at level l
l r r
l r s
r tree r
tree r 1
l r d
r r r
tree r i
of node accesses
for selection queries
using r trees
a path buffer
query window q
for join queries
non uniform data
l l r
r d l
of the r
an r tree
r r l
r d of
r 1 and
cost models for
k l r
the data set
node rectangles at
r r da
join queries on
of data rectangles
and join queries
of the workspace
of the data
number of node
1 l r
tao dimitris papadias
r i at
r tree index
yufei tao dimitris
of spatial joins
r tree indexes
dimensional data sets
with average size
a query window
a join query
r s s
of r tree
the average number
r l l
selection and join
r da l
uniform like data
rectangles at level
da l r
of node rectangles
1 at level
tree r 2
the tree r
analytical formulae for
i at level
average size s
the query window
na and da
r tree based
of r 1
of disk accesses
average number of
r 1 q
r tree node
1 r d
l r n
r tree performance
of the density
real data sets
given by eq
cost of a
illustrated in figure
data set is
level l i
that plays the
spatial joins using
the relative error
and r 2
entries of r
the access cost
points x_y node
the analytical estimations
density l r
of node disk
spatial data sets
papadias yufei tao
r 1 at
1_2 1_3 2_1
na_total r 1
simple path buffer
dimitris papadias yufei
1_3 2_1 2_2
3_3 representative points
the data properties
node accesses is
the average density
data properties only
on dimension k
node disk accesses
2_1 2_2 2_3
3_1 3_2 3_3
2_2 2_3 3_1
2_3 3_1 3_2
representative points x_y
the corresponding r
estimate the cost
3_2 3_3 representative
1 and r
two dimensional data
in spatial databases
synthetic and real
and real data
transactions on database
database systems tods
is a leaf
systems tods v
is given by
a cost model
on database systems
role of the
l r is
node and disk
formulae for the
l r of
of n rectangles
queries using r
joins using r
level l l
spatial query processing
for spatial queries
and 1 r
at each level
of the query
disk accesses for
and disk accesses
level l 1
queries proceedings of
of a join
of r trees
a function of
the role of
of the tree
plays the role
wide set of
processing and optimization
a wide set
a simple path
the cost of
in order to
d of the
r 1 r
cost in terms
cost model for
down to its
trees r 1
uniform distributions of
a skewed data
underlying r tree
the proposed analytical
the actual density
and cost models
relative error being
density d of
the two indexes
r 2 respectively
tree structure s
comparison for selection
are plotted with
d s s
or non uniform
tree that plays
point and range
the cost formulae
size in of
rectangles with average
if r1 is
selection queries on
r of tree
point or range
join query between
the query tree
due to entry
proposed analytical model
the density surface
around 10 15
point data sets
tree based structures
query rectangle q
performance comparison for
b real data
the density l
on uniform like

corpus/krapavin2000-test/628041.txt
rectangles
buffer
pinning
pinned
rectangle
query
queries
pages
faloutsos
mbrs
kamel
disk
ij
accesses
region
trees
mbr
tree
lru
packing
nx
loading
tat
hs
accessed
000
buffering
leaf
theodoridis
guttman
levels
hit
simul
hilbert
retrieved
accessing
warm
plot
bhide
visited
dif
intersect
uniformly
theta
tiger
sellis
square
bounding
steady
corner
upright
databases
probability
node
versus
spatial
policy
nodes
extents
top
root
predicted
structured
pool
fractal
pins
perimeter
shaded
yannis
resulted
beach
metric
simulation
packed
enclosing
plotted
confidence
insertion
resident
jun
3a
plots
page
area
300
inside
2682
2275
1627
2336
bufsize
computen
replacemtn
5892
2060
modestly
6862
1194
byunggu
6288
3120
8720
1172
chakka
xinran
6166
8710
abstractpast
7008
gting
edgington
5807
insight
ignoring
replacement
scenarios
file
indexing
trajectories
validation
analytical
benefit
quantitative
bottom
policies
500
fit
dr
bigger
vassilakopoulos
subqueries
1651
rishe
jignesh
geoinformatica
yufei
1599
prasad
naphtali
irrevocable
papadias
underscoring
methodology
pointed
internal
performing
predict
fits
reside
curves
53
qualitative
knee
ralf
tpr
bufferless
1668
fractals
bureau
corral
gains
poorly
numbered
studies
experimentally
250
ne
hartmut
purposely
sevcik
bailey
keyed
box
synthetic
rectangular
inserting
querying
splitting
almeida
census
accrued
capitalize
teixeira
retrieve
tuple
intervals
patel
dimitris
shu
experiencing
manolopoulos
multiversion
halving
spatio
ching
weiss
ith
emphasize
placed
touched
r tree
the buffer
r trees
disk accesses
region queries
buffer size
buffer model
point queries
r ij
a buffer
kamel and
of disk
and faloutsos
the r
q tr
unit square
all rectangles
of kamel
loading algorithms
000 rectangles
leaf level
rectangles are
point query
the rectangles
theta q
buffer hit
hit probability
size q
for point
theta 0
region query
of rectangles
q y
query q
of pages
of r
x theta
for region
a query
be pinned
query performance
ij is
of accessing
of nodes
an r
the unit
rectangle r
accesses required
tree nodes
our buffer
buffer effects
pinning the
more linear
the hs
top levels
pinned is
the top
q x
our model
expected number
minimum bounding
well structured
top right
n queries
the probability
data set
query region
nodes accessed
nodes visited
query of
a q
area of
accesses for
uniformly distributed
while performing
a rectangle
buffer sizes
total area
lru buffer
the model
rectangles is
pages at
the area
buffer is
packing algorithm
accessing r
buffer impact
guttman 3
nx algorithm
rectangles into
simul model
pages pinned
rectangles within
model dif
accesses versus
input rectangles
mbrs in
of size
per query
bounding rectangles
the lru
that intersect
model to
u 0
level 1
of buffer
n rectangles
all mbrs
packing algorithms
state buffer
new buffer
data size
queries the
queries of
and region
query model
within 2
many levels
q ij
buffer pool
level r
the nx
a ij
buffer of
size 0
the mbr
mbrs of
rectangles the
rectangles and
warm up
tuple at
rectangles of
rectangles in
plot is
the tree
probability that
0 3
steady state
probability is
in disk
by query
probability of
the query
pointed to
a point
queries using
analytical model
data file
right corner
upright rectangle
cluster rectangles
faloutsos 4
dr ne
rectangles so
tr must
of guttman
pinned pages
versus buffer
rectangles per
fewer disk
access within
theodoridis and
buffer warm
three loading
100 rectangles
first becomes
into nodes
tree packing
dif simul
64 rectangles
ignoring buffer
rectangles internal
pinned in
querying an
inside u
buffer resident
of pinning
retrieved rectangles
structured r
considered versus
tree update
hs algorithm
linear improvement
nodes per
root level
and sellis
rectangles stored
nodes retrieved
accessing rectangle
accessed while
sellis 10
poorly structured
node 17
bhide et
t sum
structured trees
the tat
insertion algorithms
pinning a
tat algorithm
the r tree
of disk accesses
number of disk
kamel and faloutsos
for point queries
the unit square
in the buffer
of the r
q x theta
x theta q
theta q y
size q x
of kamel and
for a buffer
of size q
for region queries
an r tree
the buffer size
area of r
number of nodes
probability of accessing
buffer hit probability
a buffer size
number of pages
buffer size of
query of size
a point query
disk accesses required
model of kamel
of r ij
the minimum bounding
disk accesses for
our buffer model
the rectangles are
should be pinned
point queries the
expected number of
of nodes visited
of r tree
the area of
of the buffer
r ij is
r tree nodes
the total area
a query of
buffer size is
the top right
minimum bounding rectangles
the buffer is
the number of
simul model dif
3 theta 0
that r ij
level of t
state buffer hit
theta 0 3
the buffer hit
all mbrs in
the query region
within the unit
of accessing r
size 0 3
steady state buffer
plot is for
disk accesses versus
a q ij
pages pinned is
of pages pinned
new buffer model
the top levels
the region query
rectangles within the
mbrs in t
in disk accesses
0 3 theta
the nx algorithm
of all mbrs
the probability of
levels of the
0 3 is
r trees and
tuple at a
of nodes accessed
while performing a
bounding rectangles of
performing a query
the buffer pool
of size 0
probability that r
plots the number
the expected number
of r trees
the node is
of a buffer
the leaf level
pointed to by
r trees a
our model we
a buffer of
the probability that
the steady state
query is a
of r 0
point out that
a fixed size
to satisfy a
we point out
a buffer model
be pinned in
bhide et al
top few levels
theodoridis and sellis
more linear improvement
250 000 rectangles
top levels of
loading algorithms in
and loading algorithms
tree structure the
ith level of
data file so
three loading algorithms
buffer model to
r tree update
and sellis 10
1 theta 0
of the rectangles
buffer warm up
per query for
into the nodes
the buffer model
r tree using
rectangle r ij
total area and
a rectangle of
not that intersect
the hs algorithm
in n queries
b a figure
of guttman 3
nodes retrieved as
region queries consider
and faloutsos 4
in t sum
queries consider the
how many levels
all rectangles stored
queries of size
to fit within
versus buffer size
retrieved as derived
left plot is
q ij is
q tr must
and region queries
rectangles per node
dif simul model
pinned is less
rectangles are sorted
accesses required per
the ith level
required to retrieve
reduction in disk
accessed in n
region query q
first two levels
amounts of buffer
by query performance
structure the more
pinned is within
of accessing rectangle
accesses versus buffer
buffer effects in
querying an r
pinning the first
of nodes retrieved
r tree packing
few levels of
nodes per level
of figure 3a
small buffer sizes
region query model
buffer for point
buffer model in
access within each
hit probability is
point query q
must be retrieved
for small buffer
inside u 0
query q tr
that for region
extents of all
model dif simul
accessed while performing
300 000 rectangles
be bigger than
a more linear
first becomes full
cluster rectangles so
to by p

corpus/krapavin2000-test/628045.txt
epa
soft
gryphon
thread
dqm
vpr
cpu
resource
deadline
negotiation
deadlines
pcip
policy
orb
manager
dve
rt
threads
resources
qos
dm
levels
managers
wcet
benefit
policies
usage
caching
admission
pipeline
missed
corba
traffic
000
principles
confidence
schedulability
video
scheduling
scenarios
service
pipe
rialto
object
2x
scenario
centralized
allocation
operating
kernel
location
device
period
wireframe
hints
execution
bandwidth
1x
dynamically
misses
overload
app
consistency
host
floaters
528
betty
negotiated
fair
utility
filter
skip
stream
availability
weather
termination
avatar
underutilization
oversubscribed
damage
fidelity
management
movement
allocations
miss
principle
assurance
steady
response
frames
joe
request
vrml
option
priorities
objects
multimedia
priority
reliability
mach
admitted
synthetic
placement
clip
998
negotiate
periodic
quadruples
modules
mechanism
os
responsibility
brandt
dves
mmoss
negotation
softening
softorterm
054
faction
scheduler
parametrically
effort
duration
network
monotonic
quality
virtual
eq
render
devices
interface
centric
conventional
smart
supports
units
tapp
avatars
satis
fluctuate
nutt
pipelines
graphic
estimates
meet
clients
workstation
runtime
requirements
module
room
moving
satisfaction
overshoot
unoccupied
facility
transparency
students
importance
intensive
proportional
supplementary
004
timeliness
engaged
760
smooth
processes
schedulable
directing
executing
frame
diverse
explains
mechanisms
polygons
multiprogrammed
lowers
527
reserves
max
interact
remote
client
requests
adjustment
hosts
update
opt
laboratory
adjust
workstations
entities
lowering
frequently
deliver
reliable
controlled
allocate
execution levels
soft real
the epa
real time
cpu usage
the dqm
the vpr
execution level
the gryphon
rt pcip
the application
resource manager
of soft
the resource
resource managers
epa dm
dynamic negotiation
the principles
this policy
d soft
negotiation mechanism
the applications
location best
best location
hard real
time applications
c low
the negotiation
000 system
d term
epa rt
thread thread
a dve
resource management
object manager
in kernel
thread 1
gryphon system
scenario c
network bandwidth
of cpu
the cpu
each application
operating system
distributed object
maximum benefit
c high
of thread
application execution
execution time
scenario a
per second
resource allocation
network traffic
applications are
levels to
application s
location caching
an application
confidence and
the deadline
missed deadlines
dm scheduling
thread 2
usage 0
thread i
app directed
scenario b
available cpu
cpu benefit
skip value
deadline misses
resource availability
level cpu
object placement
best effort
2 application
all applications
of resource
resource usage
the execution
directed caching
update rate
soft and
their resource
application knowledge
the object
the user
strong consistency
a resource
support for
frames per
data movement
application 3
application 2
principle 3
high i
of execution
principles the
the distributed
applications can
frame update
max cpu
distributed policy
distributed corba
the orb
host y
and betty
application 1
thread application
termination deadlines
synthetic applications
location strong
gryphon distributed
desired response
object managers
fair proportional
message traffic
using execution
applications in
of applications
000 000
the pipeline
the video
the operating
of resources
user satisfaction
resource needs
centralized and
1 soft
principle 2
with location
and benefit
joe and
running applications
principle 1
of missed
uses execution
maximum amount
usage for
the system
normal distribution
time systems
system 2
levels for
term i
of service
applications and
deadline monotonic
time application
resource types
deadline miss
levels are
steady state
and termination
operating systems
quality of
level abstraction
or high
a thread
benefit and
user space
and execution
to dynamically
the level
these applications
application 4
i max
applications to
amount of
kernel pipe
resource requests
weather modeling
conventional thread
0 system
vpr processes
planning room
application provides
follows principle
9 000
of principles
levels 6
caching app
video clip
manager dqm
termination deadline
qos manager
pcip facility
parametrically controlled
reliable service
between devices
proportional option
1 998
cpu overload
mechanism execution
vpr is
a gryphon
dqm dynamically
b scenario
the threads
soft real time
of soft real
location best location
hard real time
real time applications
the negotiation mechanism
epa rt pcip
of the application
the execution level
of execution levels
the epa dm
the epa rt
the resource manager
000 000 system
execution levels to
the principles the
in the vpr
app directed caching
epa dm scheduling
cpu usage 0
the execution levels
cpu usage for
level cpu benefit
set of applications
the available cpu
the cpu usage
frames per second
the operating system
joe and betty
uses execution levels
no of levels
best location caching
distributed object manager
soft and termination
location strong consistency
and resource managers
thread thread thread
gryphon distributed object
confidence and reliability
of thread i
max cpu usage
1 soft real
the gryphon distributed
and termination deadlines
the distributed policy
thread thread application
execution levels are
low or high
using execution levels
fraction of cpu
execution level abstraction
of the epa
real time systems
maximum amount of
the object manager
for soft real
usage for the
amount of resources
real time application
applications in the
that the application
resources will be
for the application
of the cpu
units of the
move data from
available cpu cycles
2 application knowledge
skip value of
number of missed
the gryphon system
principle 1 soft
as follows principle
the frame update
overall cpu usage
rt pcip mechanism
set of principles
application 3 application
application execution levels
scenario a scenario
scenarios a and
b scenario c
applications and resource
mechanism execution levels
gryphon with location
scenario b scenario
execution levels can
the gryphon approach
4 1 998
3 application 4
how execution levels
principle 3 dynamic
in kernel pipe
their resource needs
0 system 4
virtual planning room
conventional thread thread
in a dve
time application execution
d soft or
execution levels for
the dqm dynamically
location and caching
the synthetic applications
mechanism for implementing
host x and
form of soft
soft or term
000 system 3
and the dqm
or high i
follows principle 1
dynamic qos manager
application knowledge the
caching app directed
application 2 application
knowledge the application
principle 2 application
the running applications
i d soft
application 1 application
a scenario b
of the principles
deadline confidence and
the rt pcip
a soft real
low d soft
the application provides
000 system 5
or term i
frame update rate
rt pcip facility
3 execution levels
1 application 2
2 application 3
scenario c system
running the applications
the vpr is
52 5 fraction
quality of service
this aspect of
the maximum amount
the application s
aspect of the
the application and
a normal distribution
different set of
resource management for
in messages per
shows the cpu
and execution time
messages per second
to move data
levels can be
object is stored
level abstraction is
real time support
the user space
that each application
5 fraction of
the applications and
applications and the
the application to
of the user
the level of
number of objects
the user s
of the work
a best effort
applications with the
system 4 1
51 52 5
the principles and
e g see
data from one
will be available
the application that
provides a means
on the application
relative importance of
system support for
real time scheduling
needs of the
the relative importance
should be designed
level of the
to the application
if an object
provide a mechanism
according to the
for each level
application and the
for the duration
x and is
a different set
of the applications
to implement the
of the resource
to interact with
admission test then

corpus/krapavin2000-test/628048.txt
recurrent
elman
training
neural
weight
grammatical
grammar
fgs
learning
zipser
automata
dfa
epoch
ungrammatical
sentence
networks
english
nmse
backpropagation
grammars
japanese
eager
annealing
verb
williams
surface
stochastic
network
descent
batch
hidden
gradient
dfas
innate
n4
window
connectionist
narendra
gori
soda
frasconi
extraction
stubborn
linguists
bptt
speakers
train
minima
native
john
verbs
parthasarathy
noun
logistic
chomsky
plot
gb
discriminatory
1weight
sectioning
am
activation
sentences
extracted
trained
sigmoid
tagging
v2
architectures
representational
learned
610
plots
dev
talk
judgments
convergence
adjectives
prepositions
std
word
simulated
590
investigated
contradictory
adv
language
sentential
government
speaker
rate
learn
speech
entropy
inference
update
tanh
weights
inputs
nouns
turing
investigates
quadratic
linguistic
binding
684
0weight
phonology
sincerely
innateness
4351
4992
grammaticality
obligatorily
4251
equalized
complementizer
resulted
classifications
feedforward
classification
giles
685
035
sharply
neurons
updates
schedule
languages
dataset
layer
categorization
58
dimensions
688
activations
competence
adjective
686
parsimoniously
feedback
schedules
overt
destruction
error
deviation
center
syntactic
parsing
74
65
sleep
epochs
alter
mary
dynamical
phenomena
difficulty
a2
consisted
symbolic
quicker
228
acceptability
encoding
connections
outputs
crossed
630
decreased
lectures
digraph
simulations
105
converge
strings
principles
67
281
neuron
escape
serial
symbol
million
terminal
compactly
recognizes
faculty
221
phrase
spots
encoded
flat
randomly
updating
capability
locally
categories
244
temporal
learning rate
recurrent neural
neural networks
error surface
w z
2 weight
recurrent network
recurrent networks
6 5
the elman
elman network
1 weight
williams zipser
the training
am eager
be here
input window
5 4
finite state
the grammar
neural network
john to
the networks
natural language
7 6
gradient descent
simulated annealing
stochastic update
backpropagation through
8 7
batch update
elman and
z network
through time
i am
weight weight
the error
the fgs
talk to
the williams
epoch epoch
gori soda
state automata
cost function
grammatical inference
4 3
frasconi gori
training set
the recurrent
the network
9 8
after training
24 1
during training
weight 0
chosen dimensions
n4 v2
fgs network
locally recurrent
extracted automata
parameters after
rate schedule
narendra parthasarathy
word inputs
surface plots
plot corresponds
to train
hidden nodes
the w
13 12
network architectures
of recurrent
the dfa
two randomly
elman networks
native speakers
10 9
a recurrent
1 24
test set
training data
11 10
deterministic finite
each plot
the learning
local minima
12 11
to talk
networks are
partition state
entropy cost
too stubborn
z networks
shown fully
100 correct
two word
grammatical ungrammatical
turing equivalent
2 1weight
discriminatory power
eager for
rate schedules
zipser network
5 weight
the logistic
quadratic cost
john is
the extracted
1 26
n p
activation function
here i
the neural
network not
government and
std dev
26 1
training algorithm
of speech
3 2
hidden layer
14 13
networks the
order recurrent
for john
15 14
networks and
the plot
by context
correct classification
grammars and
a grammar
simple recurrent
plots for
the sentence
dimensions in
plot is
all connections
and binding
elman narendra
here n4
by elman
590 610
vs innate
descent based
by chomsky
or government
4 weight
non contradictory
dfa is
stochastic updates
weight 81
innate components
the nmse
judgments as
extracted dfas
or ungrammatical
same judgments
gb theory
sub categorization
japanese data
as grammatical
million stochastic
eager john
learned vs
speakers on
grammar g
of discriminatory
into learned
components assumed
to john
fully figure
appropriate grammar
28 weight
the japanese
sharply grammatical
v2 a2
gb linguists
v2 adv
automata extraction
weight initialization
as native
noun class
network is
negative examples
network each
network has
connections are
27 1
the extraction
second order
induction of
native speaker
i believe
grammatical or
initial learning
sentences as
framework or
formal grammars
relative entropy
5 4 3
4 3 2
6 5 4
7 6 5
recurrent neural networks
the error surface
8 7 6
3 2 weight
2 1 weight
to be here
i am eager
the w z
9 8 7
backpropagation through time
3 2 1
w z network
elman and w
10 9 8
finite state automata
and w z
of the plot
the williams zipser
to talk to
12 11 10
the elman network
1 24 1
11 10 9
13 12 11
john to be
frasconi gori soda
the learning rate
recurrent neural network
neural network architectures
case the center
the plot corresponds
randomly chosen dimensions
error surface plots
be here i
chosen dimensions in
quadratic cost function
weight 0 3
parameters after training
learning rate schedule
the fgs network
the parameters after
plot corresponds to
deterministic finite state
the training data
14 13 12
two randomly chosen
dimensions in each
the quadratic cost
of the error
the gradient descent
neural networks are
plot is with
recurrent network not
network not all
connections are shown
network each plot
two word inputs
am eager for
not all connections
to two randomly
williams zipser network
epoch epoch epoch
are shown fully
learning rate schedules
all connections are
surface plots for
john is too
w z networks
the extracted automata
for john to
government and binding
the input window
6 5 weight
is too stubborn
1 26 1
is with respect
of the networks
the recurrent network
each plot is
of the grammar
respect to two
described by context
15 14 13
for the w
extraction of rules
use of simulated
each case the
plots for the
of simulated annealing
able to learn
a recurrent network
in each case
26 1 27
n4 v2 a2
native speakers on
here n4 v2
an appropriate grammar
million stochastic updates
gradient descent based
same judgments as
judgments as native
input window is
learn an appropriate
introduction to formal
vs innate components
here i believe
shown fully figure
elman narendra parthasarathy
sentences as grammatical
innate components assumed
language sentences as
27 1 28
and williams zipser
3 2 1weight
relative entropy cost
hidden nodes the
25 1 26
of discriminatory power
kind of discriminatory
eager for john
as native speakers
the dfa is
grammatical or ungrammatical
framework or government
components assumed by
24 1 25
eager john to
talk to john
learned vs innate
the elman and
beginning to the
principles and parameters
assumed by chomsky
the same judgments
as grammatical or
entropy cost function
sharply grammatical ungrammatical
be here n4
am eager john
used by elman
or government and
into learned vs
to the values
center of the
the standard deviation
nature of the
shown in table
comparison of recurrent
1 27 1
order recurrent networks
the n p
the beginning to
initial learning rate
1 25 1
1 28 1
performance as shown
to learn an
the networks and
form of deterministic
operation of the
is expected that
of the parameters
the center of
been shown to
simple recurrent networks
part of speech
subject of the
cost function the
natural language sentences
the neural networks
set consisted of
of deterministic finite
the principles and
of recurrent neural
with recurrent neural
second order recurrent
it is expected
the extraction of
the operation of
neural network models
number of hidden
and negative examples
the training set
in table 4
values of q
of rules in
of finite state
to improve performance
produce the same
same kind of
training and test
set of strings
the network is
the neural network
neural computation v
of the predicate

corpus/krapavin2000-test/628059.txt
inds
fds
bcnf
sigma
chase
noncircular
schema
ind
anomalies
database
idnf
vrfnf
superkey
ftg
integrity
redundancy
insertion
fd
tuple
circular
arfnf
lect
entity
rfnf
generalised
implication
ull88
stud
violation
6j
mai83
enrol
aa93
vin94
cfp84
mr92
relational
mit83
vin98
boyce
redundant
proj
interact
normal
dependencies
codd
inclusion
interaction
dependency
head
attribute
emp
compatible
modification
schemas
nontrivial
employee
anomaly
proper
attributes
normalisation
zeros
verified
formalise
tuples
pullback
axiom
libkin
ck86
ckv90
satisfaction
formalised
characterise
insertions
lecturer
leonid
id
department
student
arenas
understood
stands
implied
xml
keys
functional
violated
unary
update
inference
logically
referential
marcelo
lg92
mr86
cod74
sci86
bb79
arm74
imi91
noncircularity
cod79
addressg
bg80
junhu
cv85
vin92
fag81
ld
nonempty
justification
hd
pairwise
enforcement
databases
project
fug
armstrong
stating
said
fr
deletion
contrary
typed
relation
elimination
presence
ab
undecidable
projection
firstly
petit
wb
forms
multivalued
proposition
relations
sigart
departments
enforcing
arise
sigmod
employees
fag
generalise
semantic
subclasses
sigact
satisfies
free
uniqueness
bg
secondly
twenty
propagation
va
title
marc
theoretic
propagate
normalization
man84
ctf88
jk84
dat86
cha89
5nf
fhead
kolahi
disagrees
snowflake
enrolg
noninteraction
bd93
fag79
overr
marchi
nonredundant
ll95
nameg
femp
cosmadakis
fenrol
ca84
fstud
abstractfunctional
cv83
solmaz
redudnancy
initialise
ferraggine
ename
casanova
millist
chengfei
jixue
concluding
rule
violating
consistency
and inds
of fds
fds and
over r
of inds
database schema
in bcnf
schema r
r i
chase d
a database
inds i
the chase
entity integrity
bcnf with
free of
r is
chase procedure
inds over
implication problem
r j
modification anomalies
proper circular
sigma is
to f
insertion anomalies
normal form
ind r
generalised entity
database d
relation schema
of insertion
fds f
in vrfnf
d over
database design
in d
noncircular inds
inds is
d ftg
key based
a superkey
of modification
d sigma
update anomalies
an ind
to sigma
relation r
and noncircular
inclusion dependency
an fd
the ind
a relation
d 0
i over
with respect
respect to
a tuple
the relation
the database
tuple t
database over
being free
ftg i
superkey for
the inds
stud id
vrfnf with
x r
current state
normal forms
the implication
is free
f i
single tuple
is redundant
2 r
inds and
superkey based
in idnf
dependency normal
satisfies generalised
insertion violation
inds in
an insertion
f and
anomalies and
or simply
j y
verified that
understood from
that sigma
for fds
that d
ind rule
in arfnf
mai83 ull88
redundancy free
between fds
is noncircular
free normal
for r
d be
the fd
not interact
if sigma
reduced and
r 2
relation over
is compatible
definition 2
of entity
be verified
schema and
is circular
the fds
i x
r then
compatible with
if part
is reduced
context if
not in
inds a
circular inds
inds we
inds have
relation schemas
nontrivial ind
ull88 aa93
0 6j
inds being
in rfnf
attribute redundancy
codd normal
6j sigma
distinct value
boyce codd
inds are
from context
to r
let r
of redundancy
is understood
then r
r given
axiom system
sigma of
state of
relation in
if r
schema with
inclusion dependencies
set sigma
being in
with d
and i
a nontrivial
the presence
r and
not reduced
redundant with
inference rule
schema is
i is
redundancy problems
student stud
inds the
but chase
based update
is superkey
ind is
inds if
pairwise consistency
for inds
was formalised
anomalies or
nonempty relation
that chase
pullback inference
presence of
zeros and
is proper
from r
let d
is said
a set
y r
of r
anomalies if
non interaction
being reduced
bcnf and
redundant since
fds over
f j
relational database
problem for
i be
2 d
fds and inds
set of fds
of fds and
a database schema
respect to f
set of inds
database schema r
bcnf with respect
r is in
in bcnf with
the chase procedure
is in bcnf
with respect to
free of insertion
of insertion anomalies
respect to sigma
i over r
generalised entity integrity
of fds f
x r j
the implication problem
presence of fds
i x r
r i x
r is free
schema r is
over r i
r is not
over a database
is free of
r j y
d over r
of modification anomalies
and inds i
implication problem for
chase d sigma
sigma is reduced
of inds i
free of modification
chase d ftg
a database d
state of r
a relation schema
relation in d
inds over r
database over r
in d over
inds i over
ind r i
to f i
is not in
over r and
current state of
a database over
for r i
r i with
the database schema
vrfnf with respect
fds and noncircular
being free of
and noncircular inds
a superkey for
compatible with d
not in bcnf
superkey for r
a set of
be a database
the relation in
the current state
be verified that
schema r then
an insertion violation
inds over a
inclusion dependency normal
d ftg i
satisfies generalised entity
sigma of fds
of entity integrity
f and inds
inds i is
fds f and
not in vrfnf
in vrfnf with
of inds over
f and i
is understood from
when the set
to a set
be a tuple
the relation r
be a set
database schema and
relation schema r
has an insertion
i with respect
r i 2
if sigma is
from context if
being in bcnf
redundancy free normal
and inds and
database d over
between fds and
sigma is understood
noncircular inds over
dependency normal form
understood from context
that sigma is
over r is
is compatible with
respect to a
the set of
in the presence
d be a
of r i
in d 0
state of d
to f j
database schema is
over r if
then r is
the database d
i be a
do not interact
a single tuple
the presence of
an ind r
is proper circular
of inds is
codd normal form
i is circular
over r which
a set sigma
boyce codd normal
mai83 ull88 aa93
y 2 i
free normal form
the ind rule
problem for fds
set sigma of
for fds and
over r such
d 0 6j
proper circular inds
a distinct value
over r given
database d 0
r given by
that d 0
easily be verified
if r is
is reduced and
i 2 r
let i be
g it can
r 2 d
by a distinct
r j with
redundant with respect
j with respect
schema and a
schema is in
definition 2 10
is a superkey
if there does
it can easily
let d be
relation over r
is not reduced
to the set
d with respect
is a proper
key based update
f over r
is in idnf
schema with attributes
inds a set
is superkey based
i to r
of database design
ind r x
with d but
normal form or
over r j
verified that sigma
d but chase
a nonempty relation
t over r
t is compatible
not a superkey
relation schema with
and inds if
the relation over
the relation schema
schema r 2
update anomalies and
that chase d
a nontrivial ind
violation of entity
to f then

corpus/krapavin2000-test/628066.txt
itemsets
frequent
tid
itemset
clique
eclat
lattice
maxclique
mining
maxeclat
atoms
prex
association
actw
apriori
cliques
maximal
aprclique
topdown
partition3
database
intersections
lattices
infrequent
items
acw
pseudo
scans
equivalence
acdtw
hybrid
item
transaction
acd
aw
acdt
acdw
partition10
atw
t30
bottom
enumerates
ecient
atom
ac
i16
t20
adt
partition
lists
semilattice
intersecting
discovery
ad
pruning
subsets
condent
powerset
t40
bookstore
cdw
rst
hash
join
search
sub
goethals
enumerated
condence
vertical
act
scan
dierent
_
datasets
cd
bart
denition
cdt
d400k
i12
i8
13480771
candidates
databases
karypis
enumeration
ct
enumerating
classes
lexicographic
horizontal
sublattice
layout
longest
rules
counts
induced
decomposition
scanned
identier
covering
doesn
zaki
skew
partitions
breadth
eciently
specied
min
ctw
michihiro
purdom
toon
yudho
adtw
kuramochi
maxclique10010000
sucahyo
gopalan
13564
calders
dtw
bierstone
cliqlist
giri
sup
discovering
top
gure
mohammed
exive
candidate
enumerate
books
sec
tids
freq
dlg
hcmac
austen
mukund
gucht
boolean
george
buy
memory
intersection
cw
raj
sublattices
customer
sigkdd
conf
intersect
deshpande
t10
sampling
meet
customers
identied
counting
dense
75
dirk
cov
jrj
newsletter
down
outperform
lemma
cardinality
format
wg
inversion
circles
locally
list
suer
i4
globally
discovered
jane
dong
bought
deng
explorations
lowered
identies
signicant
fewer
benets
phase
distributive
quickly
nding
usage
density
personalized
australasian
frequent itemsets
tid list
maximal clique
tid lists
clique based
frequent itemset
the tid
maximal frequent
hybrid search
the frequent
sub lattices
of frequent
all frequent
maximal cliques
up search
sub lattice
prex based
the maximal
bottom up
the atoms
new algorithms
itemsets are
association rules
pseudo equivalence
eclat clique
equivalence relation
down search
association graph
clique maxeclat
database scans
transaction size
itemsets and
the database
smaller classes
boolean lattice
topdown eclat
minimum support
top down
2 itemsets
the support
list intersections
partition3 aprclique
support partition3
aprclique topdown
of items
an itemset
apriori and
relation k
relation 1
by intersecting
main memory
support of
the hybrid
atoms of
the prex
sec minimum
frequent items
association mining
of transactions
powerset lattice
it enumerates
act acd
lattice p
at ad
locally frequent
covering set
itemsets of
up phase
class x
intersecting the
itemsets the
of atoms
data mining
the lattice
based pseudo
and partition
each class
itemset is
minimal infrequent
intermediate tid
clique generation
k association
25 support
t30 i16
pseudo class
frequent 2
the itemsets
is frequent
0 25
equivalence class
equivalence classes
in main
mining of
each item
time sec
a lattice
the association
d t
edge density
0 time
increasing transaction
intersections for
min sup
itemset the
search it
p i
the bottom
of association
pseudo code
1 along
hash tree
top element
search space
a a
each sub
maxeclat maxclique
length prex
itemsets figure
horizontal database
each pseudo
at aw
algorithms scale
itemset mining
based equivalence
subsets at
cliques for
maxclique figure
uses maximal
hybrid phase
adt atw
long itemsets
acw adt
min support
longest frequent
maximal itemsets
acdw acdt
vertical tid
its tid
non maximal
of tid
reverse lexicographic
maximal elements
for frequent
75 1
previous level
for association
a join
induced by
the equivalence
given as
the powerset
mining association
the dierent
the search
lattice of
t w
lists of
of database
of itemsets
database scan
potentially frequent
fast discovery
support counting
bart goethals
support values
itemsets in
the clique
0 75
lattice with
memory we
generate all
user specied
the top
lists for
the covering
list for
its support
mining task
the apriori
lexicographic order
the item
it uses
into smaller
dierent algorithms
george karypis
of intersections
prex of
itemsets for
item i
breadth rst
search the
for mining
support is
in memory
two itemsets
infrequent itemset
itemset search
ct cd
k subset
sup then
bottom up search
maximal clique based
all frequent itemsets
maximal frequent itemsets
pseudo equivalence relation
top down search
eclat clique maxeclat
of frequent itemsets
the frequent itemsets
equivalence relation 1
the tid lists
a a a
number of frequent
the tid list
the maximal clique
topdown eclat clique
the maximal frequent
apriori and partition
frequent itemsets and
the support of
tid lists of
bottom up phase
c d t
a boolean lattice
minimum support partition3
aprclique topdown eclat
frequent itemsets are
the bottom up
sec minimum support
time sec minimum
by intersecting the
based pseudo equivalence
the hybrid search
lattice p i
tid list intersections
each sub lattice
support partition3 aprclique
intersecting the tid
partition3 aprclique topdown
clique based pseudo
our new algorithms
set of atoms
number of transactions
tid list for
frequent 2 itemsets
the powerset lattice
increasing transaction size
the prex based
d t w
the covering set
0 25 support
0 time sec
tid lists for
relation 1 along
1 along with
1 0 time
k association graph
search it enumerates
equivalence relation k
5 0 75
in main memory
the top element
all the frequent
75 1 0
the edge density
set of frequent
the new algorithms
the maximal elements
for each item
number of database
set of items
of association rules
the previous level
0 75 1
a c d
pseudo code for
mining association rules
longest frequent itemset
its tid list
a sub lattice
based equivalence relation
the association graph
for frequent itemsets
intermediate tid lists
prex based equivalence
for the atoms
reverse lexicographic order
the clique based
each pseudo class
it uses maximal
locally frequent itemsets
w a c
tid list of
the frequent items
acw adt atw
the maximal cliques
powerset lattice p
the longest frequent
maximal cliques for
uses maximal clique
atoms of a
the k association
maxeclat maxclique figure
clique maxeclat maxclique
l is called
edge density of
an itemset is
t in memory
number of intersections
of all frequent
implies that u
of atoms of
of the atoms
the number of
2 p i
new algorithms for
element of p
a factor of
0 5 0
x 2 p
at the previous
an ordered set
smaller sub lattices
association mining task
independently in main
non maximal ones
ad at aw
new algorithms against
boolean lattice with
in reverse lexicographic
computing f 2
frequent itemsets figure
at ad acw
be an ordered
ac ad at
acdtw cdt act
with increasing transaction
acdw acdt acdtw
atw acdw acdt
ct cd at
few database scans
min sup then
is exive x
the dierent algorithms
vertical tid list
binary relation such
adt atw acdw
a few database
itemsets within each
r min sup
frequent itemsets within
some non maximal
the minimal infrequent
exive x x
the long maximal
frequent itemsets the
lattice with the
cliques can be
association graph increases
support 0 25
itemsets and their
cdt act acd
out of virtual
item tid lists
subsets at the
long maximal frequent
cd at ad
t w ct
relation k is
the sub lattices
relation is exive
it enumerates the
the frequent itemset
frequent itemsets this
t30 i16 d400k
w ct cd
the atoms of
within each sub
ad acw adt
25 0 5
frequent itemset mining
class x induced
if r min
frequent itemsets of
acdt acdtw cdt
enumerates all frequent
enumerates the long
frequent itemsets which
min support 0
of maximal cliques
the top down
main memory we
the equivalence class
of the lattice
the equivalence relation
engineering v 17
the set of
data engineering v
knowledge and data
and data engineering

corpus/krapavin2000-test/628075.txt
diseases
lcpt
disease
findings
specificity
lcpts
leak
diagnostic
diagnosis
bayesian
jpd
overconfident
specificities
unmodeled
reversal
gate
probabilities
cardiac
conditional
sensitivity
sensitivities
posterior
arrhythmias
link
causal
conditionally
inversion
net
medical
netica
mi
noisy
marginally
inverted
independence
dag
parents
tamponade
breathing
nor97a
pathophysiological
std
network
confidence
diagnostics
ill
finding
joint
statistics
probabilistic
posed
qualitative
myocardial
diagnosing
subnetwork
entries
belief
probability
truth
fig
designer
expert
arrythmias
wsb97
physicians
sinus
arrhythmia
diagnoses
yhl
pea88
djf
nor97b
breathlessness
dyspnea
depression
atrial
jpt
dependency
likelihoods
corrected
reasoning
intermediate
dependence
links
blanket
cpts
bns
infarction
dja
extremal
propositional
gates
constructing
leaky
symptoms
prevalence
tables
bn
antecedents
subnetworks
patient
jh
2n
networks
odds
st
rarely
estimates
node
api
medicine
corrections
employed
filled
logical
numerator
instantiating
pl
combinations
priors
influences
inverting
imprecise
incidence
generative
boolean
nodes
marginal
behaved
anti
yavuz
etin
breath
iliad
df79
epidemiological
ajd
ferat
breathless
adolescence
ajc
hhb78a
inhalations
jpts
bradycardia
cozman
unwarranted
junctional
wel90
coronary
gagliardi
rd98
electrocardiogram
sri93
polpo
arnavut
cassio
diffidence
afb
bjd
sahin
internist
sho93
swarm
dh93
fibrillation
ziya
uluyol
shinsuke
hb94
tachycardia
flutter
nder
spi87
hhb78b
overconfidence
supplemental
dealing
parent
predictive
denominator
factorization
introducing
entry
jr
artery
influencing
afl
tuberculosis
impairs
jaime
inconclusive
qmr
bronchitis
makers
986
rhythm
experiential
djh
ca
the lcpt
the finding
the disease
two findings
lcpt of
and specificity
over confidence
noisy or
the leak
leak probability
the lcpts
link reversal
sensitivity and
link probabilities
bayesian networks
finding nodes
a disease
and specificities
disease node
sensitivities and
conditional dependence
findings are
disease d
for medical
lcpts of
reversal algorithm
between findings
the posterior
probability tables
conditionally independent
in fig
or gate
the findings
conditional independence
a bayesian
of conditional
bayesian net
the sensitivity
be present
the jpd
other diseases
unmodeled conditional
marginally independent
partial statistics
conditional probability
net is
designer of
the dag
ill posed
dag of
the specificity
diagnosis is
probabilistic networks
joint probability
intermediate nodes
intermediate node
diagnosis and
an ill
posed problem
probabilities of
a finding
those numbers
problem domain
or model
this network
medical diagnostics
of diseases
overconfident diagnosis
finding will
original network
cardiac tamponade
two diseases
qualitative probabilistic
diseases are
node ca
unmodeled diseases
the subnetwork
2n sensitivities
leak term
number ffl
to findings
diagnostic systems
from diseases
diseases the
finding node
link probability
type shown
diseases to
d i
parents of
the designer
fig 4
bayesian network
finding is
a network
posterior probability
specificity of
specificities of
findings the
and sensitivity
the inversion
by means
the noisy
probabilities in
finding f
from partial
local conditional
net in
p i
or and
the network
expert systems
the net
an or
gate is
posterior probabilities
i l
the causal
means of
links between
f 2
the intermediate
node d
or rule
f 1
network is
probabilities p
a noisy
simple or
probability distribution
entries in
of constructing
knowledge engineering
the nodes
specificity data
marginally dependent
finding indicates
numeric information
diseases on
disease is
anti causal
conditional dependency
leak probabilities
partially correct
diseases d
posterior odds
findings with
causal independence
odds o
disease regardless
determining those
tamponade d
generative direction
jpd is
diagnosis of
second finding
each disease
bayesian subnetworks
usually available
diagnostic direction
several diseases
dja b
indirect statistics
marginal probabilities
pathophysiological states
infarction mi
n diseases
myocardial infarction
diseases we
o dja
several cardiac
lcpt however
boolean clusters
constructing bayesian
propositional rules
re inverted
cardiac arrhythmias
independent finding
particular disease
following lcpt
reliable methods
p djf
f jh
extremal values
yhl 88
reversal algorithms
found link
but conditionally
specificity for
inverted net
belief updating
in diagnosis
one leak
net that
more diseases
lcpt entries
markov blanket
with marginally
finding with
overconfident network
of the finding
the lcpt of
of the disease
the two findings
sensitivity and specificity
the leak probability
in the lcpt
sensitivities and specificities
lcpt of the
the lcpts of
the finding nodes
the sensitivity and
two findings are
in fig 4
of conditional independence
p i l
designer of the
the designer of
the noisy or
present the posterior
noisy or model
of the lcpt
link reversal algorithm
the dag of
the disease node
disease d i
ill posed problem
an ill posed
a bayesian network
conditional probability tables
probabilities of the
the intermediate node
shown in fig
probabilities in the
networks for medical
in the lcpts
dag of a
the original network
a noisy or
diseases to findings
the finding will
for medical diagnostics
of the findings
times the prior
lcpts of the
and specificities of
from partial statistics
the type shown
findings are not
2n sensitivities and
estimate the leak
that the finding
unmodeled conditional dependence
from diseases to
type shown in
by means of
d i is
the problem domain
is an ill
noisy or gate
represents the same
is by means
entries in the
fig 4 a
and f 2
of the network
step is to
a bayesian net
local conditional probability
of the noisy
probabilities p i
conditional probability distribution
to be present
fig 4 c
bayesian networks and
of a bayesian
the first step
the posterior probability
all possible combinations
possible combinations of
a network with
first step is
is not present
are only 2n
the disease d
only 2n sensitivities
distribution p djf
most often however
and anti causal
of several diseases
causal and anti
leak probability for
cardiac tamponade d
intermediate node ca
the finding node
3 are marginally
several diseases on
be present the
parents of f
for the finding
link probabilities of
the posterior odds
with marginally independent
the jpd is
specificities of the
leak term p
the following numerical
numbers have to
2 n entries
bayesian net is
two findings in
the proposed bayesian
between the findings
we fail to
found link probabilities
combinations of diseases
specificity of the
the finding indicates
the already found
for the lcpt
proposed bayesian subnetworks
of the diseases
the or rule
the markov blanket
finding node has
network represents the
a disease node
already found link
the link probabilities
of that node
cause the finding
node d and
in the diagnostic
following numerical example
lcpts of all
dealing with conditional
and the net
link probabilities p
over confidence in
is re inverted
not conditionally independent
what is usually
the lcpt entries
assumptions of conditional
the second inversion
for over confidence
and specificity of
specificity and sensitivity
the finding with
and specificity data
all link probabilities
finding will be
net in fig
marginally independent finding
diseases on a
no links between
the following lcpt
or gate is
odds o dja
2 n numbers
the lcpt is
qualitative probabilistic networks
myocardial infarction mi
leaky noisy or
finding indicates the
posterior odds o
is usually available
for medical diagnosis
number of probabilities
the marginal probabilities
if we fail
findings in addition
marginal probabilities of
links between findings
a net that
o dja b
a particular disease
resulting network represents
network with marginally
of over confidence
is always present
the second finding
inverted net in
markov blanket of
independent finding nodes
are not conditionally
those numbers are
of conditional dependence
the diagnostic direction
constructing bayesian networks
the disease is
the inverted net
will be present
node ca is
over confidence can
finding is present
avoid over confidence
disease regardless of
is to estimate
is exponential in

corpus/krapavin2000-test/628087.txt
trigger
triggers
sting
sub
region
cells
spatial
cell
attribute
mining
leaf
insertion
updates
deletion
nmin
expand
density
shrink
tq
attr
query
composite
dist
miles
attr2
cellular
monitor
shr
wan97
phones
squared
update
regions
tqmax
mile
boundary
event
clause
phone
insertions
subtriggers
events
database
suspended
hierarchy
neighbors
conf
ffi
accumulated
exp
geominer
reallocation
statistical
incremental
recalculated
area
triggered
children
obsolete
nu
active
deletions
location
shade
posted
period
evolved
suspend
bandwidth
distance
neighborhood
pyramid
qualified
bold
cpu
forwarded
warehousing
clusters
est98b
time1
est98a
wid96
kno96a
hor97
han97
est97
kno96b
qmax
objects
calculated
handling
adjacent
ts
proximity
consumed
del
grid
market
employs
databases
interior
cluster
action
ffin
outside
satisfied
predicates
attributes
shaded
satisfaction
cause
theta
smin
recalculate
erage
confidence
joins
evolves
outstanding
placed
removed
deadline
root
enters
granularity
hierarchical
threshold
deleting
primitive
contour
dimension
aggregate
cycles
incrementally
mined
gammat
intermediate
normal
efficiently
fired
upgrade
prototype
queries
decreased
emergency
awareness
clustering
ahead
continues
overhead
users
focused
variance
notified
scenario
shape
func
actions
predicate
phase
select
av
ins
pk
k2
calculate
100
nb
status
levels
evolving
bottom
accommodate
facilitate
000
specified
dark
track
44
movement
complicated
k1
fourth
adjust
iff
consumes
deemed
updated
expensive
fulfillment
whenselect
zai98
kno97
gru98
usting
dedale
kop96
zan97
ng94
eighteen
sub triggers
sub trigger
the trigger
leaf level
triggers are
trigger is
trigger condition
insertion sub
expand sub
deletion sub
spatial data
level sub
in sting
data mining
level cell
level cells
shrink sub
density sub
composite event
region s
e s
this cell
of leaf
triggers and
set on
trigger on
of sub
trigger evaluation
ffi trigger
the region
of updates
triggers on
to monitor
statistical information
area at
a trigger
composite events
the attribute
attribute ffi
attribute sub
attribute condition
original region
trigger and
the density
triggers for
phones are
attribute trigger
cellular phones
squared miles
an insertion
become true
a region
an update
in range
intermediate level
region is
result r
a exp
miles with
select clause
per squared
boundary distance
conf l
sting is
squared mile
a shr
accumulated amount
of sting
use per
distribution type
least 10
the hierarchy
within r
triggers in
time t
a leaf
t q
total area
and attribute
the query
of triggers
non spatial
the condition
in spatial
insertion deletion
condition is
are set
dist i
triggers set
sting employs
triggers can
active spatial
10 cellular
level insertion
sting and
size region
some composite
triggers is
interior boundary
c 44
of trigger
density condition
a composite
attribute values
c t
the area
event in
and area
cellular phone
and expand
of objects
this region
hierarchical structure
with total
monitor the
a spatial
at level
cpu cycles
query processing
the database
t u
these sub
cells are
at time
cell is
a cell
of spatial
the boundary
mining triggers
fixed region
trigger trigger
level deletion
on cellular
children cells
u attr2
defined triggers
active period
calls distance
to sting
fourth phase
tq to
attribute conditions
defined trigger
updates occur
children at
r ts
mile and
100 miles
region trigger
range 100
handling a
where at
user defined
region and
example 3
of composite
s occurs
condition to
the average
the user
area of
placed on
of attribute
adjacent to
events that
attr is
and shrink
cells within
distance calls
update occurs
on cells
on leaf
query result
the select
spatial databases
until t
average number
is set
area in
density and
if dist
distance larger
region query
specified in
in use
cells in
updates on
updates to
the leaf
higher levels
might cause
with density
bottom level
active data
parameters of
the root
its neighbors
t r
and deletion
of region
sub triggers are
the trigger condition
spatial data mining
of sub triggers
sub trigger is
insertion sub trigger
level sub triggers
of leaf level
expand sub triggers
deletion sub trigger
leaf level sub
density sub triggers
a leaf level
sub triggers and
leaf level cell
leaf level cells
number of leaf
in this cell
area at least
deletion sub triggers
sub trigger on
expand sub trigger
triggers are set
insertion sub triggers
a composite event
the original region
attribute sub triggers
shrink sub triggers
sub triggers on
an insertion sub
amount of updates
number of objects
trigger is set
composite event in
attribute ffi trigger
are set on
cellular phones are
in e s
at least 10
with total area
per squared mile
total area at
these sub triggers
use per squared
and expand sub
intermediate level sub
shrink sub trigger
phones are in
sub triggers for
accumulated amount of
sub trigger and
in use per
sub triggers in
to become true
number of sub
to monitor the
sub triggers set
area in range
and area in
active spatial data
make the trigger
10 cellular phones
a sub trigger
to higher levels
in the trigger
the attribute condition
triggers for a
the select clause
condition to become
trigger condition is
the insertion sub
and deletion sub
least 10 cellular
the distribution type
where at least
are in use
the leaf level
in the hierarchy
of composite events
used to monitor
condition is satisfied
event in e
at time t
the area of
of spatial data
user defined trigger
sub triggers can
distribution type is
leaf level deletion
than 100 miles
e s occurs
the density condition
set on those
sting employs a
calls distance larger
user defined triggers
on a cell
level sub trigger
them are long
distance calls distance
leaf level insertion
leaves the region
squared mile and
on leaf level
are long distance
100 miles with
and shrink sub
some composite event
triggers can be
categories of triggers
sub triggers is
the fourth phase
until t u
the boundary distance
t u attr2
level insertion sub
fixed region s
triggers are used
the active period
level cell is
larger than 100
density and attribute
active data mining
1 and area
trigger condition to
cause the trigger
triggers set on
in range 100
the trigger is
range 100 1
set of composite
level deletion sub
data mining triggers
the sub trigger
condition on certain
on cellular phone
miles with total
number of updates
the attribute in
attribute in this
types of sub
of updates on
long distance calls
distance larger than
for each update
the number of
time t 1
average number of
the condition is
in spatial databases
the boundary of
at least c
before the trigger
with confidence 0
statistical information associated
statistical information grid
the average update
trigger is defined
once the condition
an expand sub
procedure continues until
clause example 3
the accumulated amount
children at level
evaluate the trigger
and with confidence
trigger will be
sub triggers expand
on this cell
sub triggers associated
condition specified in
triggers are placed
range 50 1
of a shr
region query in
most t r
handling a sub
m s min
set on cells
in range 50
triggers and expand
triggers and deletion
four categories of
cause c t
t q time
with cells in
which the trigger
ffi trigger is
n m s
joins the region
cells within r
original region and
composite events that
43 c 44
the trigger evaluation
in sting and
least 10 squared
and attribute conditions
non spatial attributes
updates on attr

corpus/krapavin2000-test/628088.txt
video
query
content
entities
declarative
interval
objects
querying
intervals
generalized
database
retrieval
att
object
attributes
visual
concatenation
semantic
oid
constructive
language
multimedia
entailment
hacid
mohand
sad
mpeg
dense
attribute
indexing
predicate
queries
semistructured
relationships
languages
constraint
symbol
databases
frame
frames
media
sql
audiovisual
satisfiability
sequencing
identities
compression
toumani
farouk
atomic
primitive
exploitation
pred
rule
concatenations
paradigms
textual
sequences
elmagarmid
atom
image
conjunctions
audio
arity
movies
editing
ffl
id
layer
countably
temporal
ahmed
elisa
bertino
videos
expressive
pictorial
interpreted
tv
disjunctions
manipulations
facts
events
constraints
relations
storing
inequality
management
g2
g1
concatenating
integrates
literal
infer
omega
head
mining
tive
vari
modeling
constants
logical
pictures
arithmetic
annotations
maier
scholarly
arslan
digitize
openness
hjelsvold
bilvideo
ovid
rupert
enced
videostar
nonnega
panagiotis
chrisa
polydoros
iller
abstractindexing
oomoto
ediz
aykol
gintervals
midtstraum
meghini
palenichka
tsinaraki
violone
videosql
dexptime
gdkbay
stavros
kazasis
dnderler
pods
styled
fotis
citizen
duration
web
dom
virtual
body
names
fragments
unary
ary
uur
christodoulakis
thematic
disciplinary
worldwide
tanaka
descriptional
umut
zobel
emin
advent
trieval
rokia
avis
hoad
adali
inherent
concrete
periods
template
retrieving
relational
negation
television
brandon
ulusoy
missaoui
bibliographic
anytime
declara
ptime
8e
puter
exploration
advanced
symbols
proposal
semantics
beautiful
attr
mehmet
sigmm
zgr
fcg
evaluable
unsatisfiable
shapes
pairwise
spatial
human
video data
generalized interval
a video
generalized intervals
query language
data model
video sequence
constraint query
of video
order constraints
interval objects
rule based
semantic objects
query languages
set order
video object
based constraint
the query
based query
g entities
querying video
video information
declarative and
the video
and querying
language has
dense order
declarative rule
order inequality
for video
objects and
predicate symbol
video frames
all generalized
video objects
query list
a declarative
time interval
video content
object identities
among objects
the concatenation
video database
of interest
relationships among
a rule
in video
generalized time
content indexing
video query
pred d
given video
extended active
frame sequences
objects of
a generalized
more declarative
interval can
mohand sad
range restricted
sad hacid
video databases
dense linear
set constraints
interest in
the content
language that
a constructive
video in
active domain
modeling and
of set
database systems
video sequences
frames which
type d
inherent to
of frame
concrete domain
model and
arity n
constraints involving
list all
by content
be expressed
i 2
database technology
inequality constraints
concatenation of
object and
and video
the language
restricted form
with g
our language
entities the
linear order
natural way
their negation
o att
g duration
valued attribute
like video
new sequences
simple sql
constraint paradigms
clear declarative
video visual
view video
infer relationships
att 0
new relationships
set functions
content dimension
atomic constraints
primitive atomic
support video
content layer
feature content
primitive constraint
constructive term
special unary
virtual editing
letters stand
important direction
constructive rule
formal rule
hacid farouk
constraint g
interpreted function
interval object
constructive interval
content of
objects are
and relationships
content based
new techniques
a database
entities and
and retrieval
first class
identities for
to video
an interpreted
as semantic
variables called
farouk toumani
dom d
concatenation operator
relation contains
relation names
value o
semistructured data
build new
atom if
are entities
satisfiability of
for pictorial
called object
two generalized
ahmed k
k elmagarmid
query involves
involving 2
query answers
and entailment
declarative graphical
expressed as
an interval
of generalized
the object
query we
following rule
interval is
frame sequence
2 semantic
fix point
semantic layer
new generalized
retrieval by
objects other
o 0
body literal
entailment of
framework presented
interval associated
symbol we
video is
information represented
video applications
to infer
among others
associated with
of attributes
o 2
by means
an object
queries can
no set
objects it
video data model
a video sequence
based constraint query
generalized interval objects
constraint query language
rule based constraint
of a video
set order constraints
the query language
data model and
objects of interest
query language that
based query language
modeling and querying
a video object
in a video
associated with g
and querying video
declarative rule based
querying video data
and i 2
a generalized interval
interest in a
rule based query
relationships among objects
the query list
1 and i
of interest in
of video data
the data model
concatenation of i
of frame sequences
within a video
a declarative rule
generalized time interval
linear order inequality
order inequality constraints
of type d
of set constraints
extended active domain
much more declarative
a given video
query list all
can be expressed
domain of a
i 1 and
and relationships among
interval can be
mohand sad hacid
dense linear order
our language has
language that can
expressed as g
the concatenation of
a restricted form
the video data
is a constant
be expressed as
used to infer
restricted form of
of the video
query language for
a constant and
and the query
are entities of
involving 2 and
new sequences from
entailment of conjunctions
compute the answer
and but no
objects and constraints
ffl a special
and query languages
a generalized time
interpreted function symbol
more declarative and
content of frame
this query involves
but no set
generalized intervals as
set functions such
formal rule based
2 and but
information represented in
object and constraint
sad hacid farouk
to image data
as g entities
has an interpreted
interval is a
video information in
linear constraint query
declarative and operational
or their negation
a simple sql
all generalized intervals
generalized intervals where
of time associated
simple sql like
generalized interval object
declarative and natural
a video database
of generalized intervals
a formal rule
as semantic objects
video frames which
clear declarative and
to support video
a body literal
e information of
function symbol for
letters stand for
a special unary
the relation contains
no set functions
answer set to
in a body
like video query
of or their
to infer relationships
list all generalized
special unary predicate
language has an
build new sequences
a constructive term
semantic objects and
generalized interval is
pred d is
a clear declarative
constraint query languages
entities of interest
and constraint paradigms
video database management
well as semantic
video query language
fix point semantics
primitive atomic constraints
framework presented here
models and query
feature content layer
constraints involving 2
inherent to video
object identities for
to video data
power and complexity
an interpreted function
nature of video
sql like video
hacid farouk toumani
entities the query
all generalized interval
are values then
g entities the
set constraints involving
the extended active
one of or
form of set
given video sequence
unary predicate symbol
systems have been
model and the
by means of
to build new
constant and is
developed a simple
dimension i e
if the constraint
constraints that is
of variables called
ahmed k elmagarmid
objects within a
time interval associated
the concatenation operator
model theoretic and
intervals as well
approach to represent
the following rule
a much more
based approach to
the content of
query we need
the framework presented
the answer set
time associated with
and natural way
and operational semantics
interval associated with
the language has
expressive power and
to a generalized
of video sequences
objects other than
from a video
o denotes the
most natural way
values of attributes
with g 2
as first class
and is one
contributions 1 we

corpus/krapavin2000-test/628095.txt
datalog
lp
disjunctive
sch
stable
brave
abduction
weak
courses
phi
abductive
ground
ts
incompatible
priorities
negation
disjunction
semantics
literal
qbfs
vee
hcf
prioritization
clique
delta
logic
reasoning
cardinality
qbf
notgreater
sigma
slots
strong
oracle
stratified
neg
net
oe
lpap
sm
hyp
hardness
constraints
programs
resp
rm
maxh
count1
literals
col
eiter
obs
cliques
lexicographically
fragments
atom
expressive
explanations
pr
violated
prioritized
francesco
greco
disallowed
truth
program
hypotheses
persons
skills
married
desiderata
propositional
fragment
tronger
unstratified
3dnf
deciding
cautious
atoms
guess
encoding
constraint
np
integrity
head
coloring
expressiveness
planning
employees
assign
polynomial
minimality
deductive
guesses
priority
incompatibilities
gottlob
leone
commonsense
joined
explanation
scheduling
instances
express
cont
relevance
colors
slot
tompits
appendixb
fink
exams
pdeciding
weakly
language
nicola
admit
expresses
existential
succ
satisfied
databases
membership
cliq
appendixa
garro
ricca
overlappings
preferred
vertices
candidate
classical
proj
palopoli
scarcello
pfeifer
perri
simona
assignment
odd
strongest
hx
fbg
46
supposing
luigi
lifschitz
mildly
circumscription
unusable
skeptical
infers
hierarchy
strongly
preference
preferable
disallow
alfredo
skill
sergio
gelfond
understand
interestingly
gramming
constructible
georg
overlapping
iff
interpretation
gerald
fulfills
preferably
declarative
employee
herbrand
p2
programming
foundations
agents
gi
p1
appearing
minimize
ai
completeness
turns
jp
discards
encode
thomas
normal
mm
coincides
syntactical
log
clause
minimal
off
approx
offline
datalog c
weak constraints
stable model
delta p
stable models
of lp
strong constraints
of datalog
lp phi
brave reasoning
in datalog
the stable
a sch
incompatible courses
weak constraint
disjunctive datalog
logic programming
a datalog
model semantics
strong constraint
p sch
sigma p
minimum cardinality
c program
p net
pr p
program lp
time slots
some stable
the complexity
of violated
rm datalog
for lp
vee neg
ts 1
ts 2
datalog vee
ground semantics
disjunctive logic
of disjunctive
the datalog
program p
ts 3
is delta
of weak
assign x
the language
lp is
w r
model m
models of
of p
semantics for
v lp
strongly incompatible
true w
hcf disjunction
x ts
sm v
abduction with
violated instances
in w
with priorities
datalog programs
literal q
constraints in
a ground
rule r
logic programs
is true
h p
datalog program
oe x
r t
c 0
complexity of
clique c
for disjunctive
of logic
truth assignment
knowledge representation
true in
semantics of
a stable
than w
lp i
to datalog
on datalog
positive program
neg c
satisfying s
1 ts
of brave
lp a
complexity results
o log
w 3
c programs
disjunction and
constraint w
p 3
instances of
complete problems
log n
p m
polynomial hierarchy
for datalog
constraints do
different priorities
lp 2
stratified negation
reasoning on
the weak
in sigma
courses to
p o
the semantics
w 1
expressive power
lp net
phi oe
priorities among
datalog by
ground s
minimum truth
ground lp
candidate model
sch of
lp sch
where lp
lexicographically minimum
lp satisfying
maxh p
see lines
input deciding
by constraints
3 o
theorem 19
optimization problems
following program
deciding whether
off line
graph theory
model of
that datalog
based problems
the abductive
interpretation m
max clique
propositional case
assignment oe
disjunctive programs
under stable
m of
in polynomial
that phi
abductive logic
thomas eiter
and disjunctive
constraint s
ground instances
whether q
theorem 17
each stable
polynomial time
an oracle
p is
for p
q is
the oracle
logic program
we next
problems that
assigned with
overlapping between
the lexicographically
joined by
on complexity
x n
programs with
p 0
practice of
an explanation
r 0
and negation
p complete
theorem 21
not c
w 2
1 guesses
3 course
lp p
sch and
know each
2 assign
sch are
input facts
the guess
cardinality criterion
col x
of datalog c
stable models of
datalog c program
the stable models
stable model of
delta p 3
in datalog c
a datalog c
of weak constraints
some stable model
is delta p
number of violated
stable model semantics
q is true
stable model m
a stable model
models of lp
datalog vee neg
rm datalog vee
h p m
the datalog c
w r t
model of p
true in some
weak constraints in
constraints in w
datalog c programs
of the language
the complexity of
in some stable
of logic programming
is true in
r t i
o log n
model m of
sm v lp
of violated instances
p a sch
violated instances of
true w r
v lp phi
delta p o
m of lp
weak constraint w
model of lp
assign x ts
given a datalog
p o log
the stable model
models of p
of the stable
to time slots
q as input
sigma p 2
p 3 o
brave reasoning on
datalog c is
ts 1 ts
vee neg c
literal q as
the weak constraint
a weak constraint
3 o log
r t m
is true w
the polynomial hierarchy
minimize the number
the program p
such that phi
the following program
1 ts 2
complexity of datalog
under stable model
lp a sch
of lp satisfying
sch of section
knowledge based problems
same time slot
semantics for disjunctive
deciding whether q
exists a stable
lp satisfying s
as input deciding
delta p complete
of brave reasoning
and strong constraints
lexicographically minimum truth
model for lp
on datalog c
constraint w 1
the strong constraint
for datalog c
truth assignment oe
of strong constraints
datalog by constraints
complexity of brave
input deciding whether
datalog c can
instances of weak
the weak constraints
of lp phi
in sigma p
courses to time
strong constraint s
reasoning on datalog
instances of w
minimum truth assignment
the semantics of
is a stable
of p is
joined by an
solutions of p
whether q is
ground instances of
each stable model
constraints do not
logic programming v
practice of logic
and practice of
in w 0
that h p
in polynomial time
w 2 and
the complexity results
disjunctive logic programming
of section 1
t i if
rule r 1
for knowledge representation
knowledge representation and
with minimum cardinality
planning graph theory
depth discussion on
of p net
the positive program
of theorem 19
complexity of reasoning
lp is a
of pr p
sch are the
satisfying s such
ts 3 course
a brave consequence
strongly incompatible courses
to delta p
ts 3 ts
between strongly incompatible
p is delta
program literal q
46 47 48
false w r
abductive logic programming
disjunctive logic pro
datalog program lp
and among these
that datalog c
minimum cardinality criterion
1 assign x
47 48 51
are the stable
a strong constraint
lp p sch
brave reasoning is
weak constraints the
p 3 complete
ts 1 assign
x ts 2
c program literal
know each other
finally the weak
in delta p
oe x n
the lexicographically minimum
3 course x
col x i
to brave reasoning
ts 2 assign
reasoning is delta
20 40 46
2 assign x
a ground semantics
40 46 47
datalog c while
among these those
of lp 2
theoretic semantics for
semantics of disjunctive
datalog c in
program p sch
x ts 3
lp phi is
neg c is
p is a
expressive power of
easy to understand
on the complexity
theory and practice
number of calls
of calls to
complexity of the

corpus/krapavin2000-test/628097.txt
covert
transaction
lock
secure
security
channel
aborted
mutual
miss
priority
deadline
2pl
submits
commits
channels
concurrency
percentage
locking
commit
arrival
purge
tick
interference
holders
deadlock
abort
aborts
actions
timeliness
vwl
database
conflicting
multilevel
arrives
protocol
releases
tl
cputime
dba
schedule
fidelity
aborting
scheduler
requester
offs
option
noise
disk
sang
deadlines
son
waits
entropy
lapadula
violations
timing
feedback
surprise
granted
blocked
transmitter
quanta
clearance
cognizance
ddmp
disktime
action
rl
conflicts
serialization
subcases
delta
request
trade
subjects
mls
submitted
virtual
violation
upgraded
transactions
probability
committed
release
priorities
capacity
scheduling
prior
cpu
uncertainty
collaborating
kyoung
read
item
bell
malicious
arrivals
degrading
multiversion
delayed
recovery
transmit
ax
transmission
enforce
receiver
probabilities
bufprob
dmp
vql
readlock
transize
4122
arrirate
unlocked
4121
minslack
conflict
th
randomness
msec
subject
interfere
transferred
hp
schedulers
databases
slack
holding
delay
hline
vrbsky
covertly
scheduled
submit
policy
page
cache
designer
noiseless
stankovic
cnt
vw
locks
kang
resultant
vs
requirements
arrive
allowable
classification
schedules
rolled
collaborate
permissible
access
interferes
conveyed
421
lesser
factors
held
submitting
sent
requests
maintained
queueing
phase
reads
prob
422
ahmed
610
dbmss
arise
duration
arrived
violated
firm
compromised
signaling
thereby
rate
enforcement
intends
contention
sends
alternately
serializability
send
rates
object
event
correctness
restarted
locked
quantum
pl
deadlocks
trans
covert channel
mutual information
miss percentage
the covert
covert channels
low user
real time
access class
high user
concurrency control
the mutual
level transaction
low transaction
a transaction
the low
the lock
deadline miss
aborted by
at t
probability q
transaction t
a lock
t i
high priority
locking protocol
lock on
other transactions
the secure
secure concurrency
secure 2pl
secure two
lower access
a covert
phase locking
a secure
t l
security and
with probability
commits at
two phase
low priority
t 2
security is
t 1
transactions in
the high
the channel
the transaction
high transaction
time database
on x
priority is
the miss
submits a
non interference
by th
a tick
higher access
control mechanism
information i
to t
channel analysis
secure real
desired miss
virtual lock
abort commit
delay security
feedback control
secure database
channel is
commit a
prior to
be aborted
a subject
level actions
i vs
transaction at
transaction is
the system
multilevel secure
the deadline
level transactions
of th
and commits
the arrival
user aborts
purge p
priority transaction
transaction submits
tick the
which security
secure option
subject at
basic two
time secure
through p
arrival of
t delta
of q
h son
sang h
time requirements
a higher
information of
of mutual
is aborted
of transactions
th at
lock holding
data operation
channels that
aborted for
lock holders
low level
for secure
offs between
database systems
high level
submits its
this channel
a deadlock
following cases
the transactions
trade offs
commits prior
i releases
2pl hp
always aborted
transferred through
aborts considering
error bit
r capacity
it submits
considering it
value security
output schedule
rl 1
recovery security
th with
earlier deadline
real lock
higher level
no interference
arrival rates
write lock
data item
1 through
p 6
an action
a real
by t
time databases
data object
2 x
transactions that
t 3
a conflicting
1 x
s priority
bell lapadula
the bell
is upgraded
vs r
lock prior
of covert
w 2
l with
serialization order
lock is
t 4
q or
aborted when
in multilevel
user sends
information transferred
a virtual
lock and
x at
time out
a low
security requirements
time concurrency
read lock
lock request
waits for
priority of
a lower
a write
i x
disk access
granted the
correctness criteria
is allowed
arrival rate
the feedback
conflicting lock
multiversion locking
the holders
greater priority
percentage and
the mutual information
the covert channel
the low user
prior to t
deadline miss percentage
a covert channel
mutual information of
the low transaction
two phase locking
secure two phase
at t l
lower access class
lock on x
secure concurrency control
phase locking protocol
mutual information i
value of q
with probability q
of other transactions
a lower access
the high transaction
higher access class
low level transaction
t l with
commits at t
the miss percentage
p 1 through
through p 6
aborted by th
real time database
1 through p
a transaction at
the deadline miss
of mutual information
of a tick
secure real time
high level transaction
the high user
covert channel analysis
desired miss percentage
real time requirements
a lock on
that the mutual
transaction at a
a higher access
on the arrival
to the low
transaction t 1
l with probability
at a higher
covert channel is
purge p l
to t l
at t delta
in a secure
low user aborts
basic two phase
submits a read
real time secure
subject at a
through the covert
probability q or
the desired miss
security and real
information i vs
aborted for high
a real time
at a lower
sang h son
trade offs between
w 2 x
if the high
the following cases
information of the
the arrival of
covert channels that
s priority is
high level transactions
is upgraded to
th with probability
the secure two
time secure concurrency
t i releases
an earlier deadline
a subject at
upgraded to a
always aborted for
rl 1 x
of the covert
following cases a
commits prior to
low priority is
considering it as
low transaction submits
x at t
aborts considering it
which security is
high user sends
feedback control mechanism
a real lock
user aborts considering
and commits at
to which security
high priority transaction
by th with
information transferred through
a virtual lock
the secure 2pl
amount of mutual
a tick the
an error bit
i vs r
access class to
other transactions in
releases the lock
mutual information transferred
t 2 and
on a data
start of a
real time databases
time database systems
concurrency control mechanism
for real time
by t i
a low priority
the bell lapadula
a feedback control
lock prior to
no interference from
a write on
then the low
r 1 x
correctness criteria for
q and r
time concurrency control
and p 1
transactions in the
a data item
and real time
p i x
real time concurrency
studied in section
as an error
value of r
the value of
real time and
a high priority
for secure schedulers
allowed to set
a commit a
r 1 0
levels l in
time and security
transferred through the
secure database systems
transaction t 4
a read on
lock holding transaction
by th at
the output schedule
user sends 0
subject classification levels
the transmitter can
for mutual information
active transactions that
mutual information to
level transaction in
a subject is
for the mutual
the resultant covert
multiversion locking protocol
purge s l
time database system
criteria for secure
deadline than the
following subcases arise
resultant covert channel
concurrency control approaches
transaction submits a
th at t
event when the
high user has
1 x r
vwl 2 x
the lock holders
r when low
security and timeliness
when low priority
between real time
lock and commits
after t i
earlier deadline than
abort commit a
or t i
the event when
channel studied in
arrival rates the
higher level actions
tick the low
does not arrive

corpus/krapavin2000-test/628100.txt
semijoin
locational
qt
rt
spatial
join
site
keys
approximations
100r
mbrs
joins
kbytes
mbr
theta
50r
10r
transmission
100s
bandwidth
descriptions
parcels
50s
10s
transmitting
drops
cpu
records
transmitted
lis
semijoins
comm
sec
indexes
gis
land
100k
bytes
compaction
objects
naive
databases
tree
10k
record
false
merge
rectangles
50k
joining
relations
database
quadrants
indexed
query
outperforms
conducted
uniprocessor
polygons
trees
bounding
costs
attributes
saving
relationships
dimensional
families
filter
object
communication
weaker
intersection
linearized
ffl
2kbytes
childptr
transmits
rectangle
outperform
adjacency
io
incurred
selections
final
buffering
cardinality
agencies
soil
mbytes
e2
cheaper
fetching
compacted
filters
rotated
containment
sorted
sparc
leaf
thirds
employ
conventional
os
polygonal
incurs
expensive
oid
sites
strategies
s4
sheer
varying
index
r1
duplicates
varies
approximation
sweeping
saved
participate
nested
sort
indexing
speeds
populated
entirety
100000
cut
effective
50000
microseconds
e1
transmit
dominates
geographic
quad
operator
middle
mapping
region
inexpensive
attribute
adopted
breadth
figures
scan
costly
relationship
milliseconds
monitored
jacox
geodetic
6666
237000
762000
23175
115484
23k
legislative
morton
assets
15100total
5861
3253
1415
eastward
96200
reread
5156
patition
2759
245000
100r60150qt
2838
33319
csiro
100kbytes
115904
23189
exporting
13096
3334
shipping
100s102
231426
1410
kilometer
unviersity
cost10
55151
4kbytes
2829
280000
equijoin
51117
232169
refetching
northward
17112
south
theta theta
the semijoin
locational keys
spatial descriptions
r tree
spatial join
s site
distributed spatial
r site
locational key
final join
rt n
transmission cost
rt l
rt i
the spatial
the locational
semijoin based
spatial semijoin
false drops
the approximations
qt n
based algorithms
join processing
communication bandwidth
spatial joins
processing cost
semijoin and
of spatial
join algorithms
of locational
algorithm qt
qt c
single dimensional
the join
o cost
algorithm rt
local processing
qt 4
of mbrs
the r
site and
cpu cost
spatial databases
kbytes sec
comm bandwidth
100r s
spatial description
dimensional approximations
r 0
site to
total time
two spatial
in kbytes
key based
spatial relations
of false
records of
i o
multi dimensional
spatial objects
at s
r and
the transmission
a spatial
and s
a semijoin
join strategies
object mapping
semijoin algorithms
based joins
r trees
tree based
of r
at r
transmitting the
spatial database
bandwidth in
n theta
ffl algorithm
time comm
data sets
the final
the mbrs
bandwidth varies
semijoin operator
lis applications
weaker relationship
keys based
and locational
outperforms rt
distributed join
approximations obtained
qt is
large spatial
join is
of s
the naive
communication cost
of approximations
s 0
spatial relationships
the communication
l rt
100 kbytes
of transmitting
join operation
minimum bounding
of objects
cost for
approximations to
sort merge
joins using
tree index
the objects
keys of
s total
descriptions of
approximations of
to s
semijoin is
semijoin at
n rt
dimensional locational
4 qt
key algorithms
small spatial
semijoin result
c qt
kbytes rt
10k 50k
kbytes qt
record total
mbr of
the cpu
the records
cost and
two families
joins with
merge join
the joining
objects in
at site
approximations and
each object
50k 100k
its mbr
dimensional approximation
transmitted for
several spatial
relation sizes
approximations is
approximation based
different relation
1 mapping
keys are
to r
in distributed
cost in
for spatial
query processing
spatial data
as approximations
large s
dimensional object
spatial query
transmitted to
time sec
the cost
the algorithms
spatial indexes
each record
gis applications
join at
both relations
cut down
sec figure
an r
cost of
b f
algorithms that
relations r
cpu speed
that qt
semijoin of
approximation functions
conventional semijoin
region represented
parcels the
based semijoin
that rt
qt rt
total processing
50r 50s
two polygons
merge like
transmits r
for semijoin
land information
descriptions rt
theta theta theta
the final join
the r tree
distributed spatial join
semijoin based algorithms
r and s
the spatial semijoin
to s site
n theta theta
of false drops
i o cost
at s site
the semijoin based
the spatial descriptions
to r site
the semijoin and
the locational key
of locational keys
the locational keys
number of mbrs
comm bandwidth in
at r site
the transmission cost
distributed spatial databases
r site and
bandwidth in kbytes
spatial join processing
locational key based
number of false
spatial join algorithms
spatial descriptions of
approximations of s
r tree based
of the approximations
records of r
time comm bandwidth
r site to
of the semijoin
in distributed spatial
rt n theta
for the semijoin
s total time
number of approximations
key based algorithms
local processing cost
of the spatial
total time comm
the communication bandwidth
two spatial relations
of the r
approximations obtained from
qt n theta
of spatial descriptions
large spatial descriptions
communication bandwidth varies
a distributed spatial
rt l rt
multi dimensional approximations
the approximations to
for distributed spatial
processing cost for
spatial description is
locational keys based
100 kbytes sec
transmission cost and
locational keys of
s site and
length of spatial
site and the
the approximations of
r tree index
an r tree
and i o
of r that
spatial joins using
for the final
two families of
kbytes qt n
the spatial description
a weaker relationship
4 qt c
theta theta b
cost of transmitting
record total time
kbytes rt n
based joins with
number of locational
records of s
multi dimensional approximation
joins with varying
r that will
spatial database system
from r site
final join at
small spatial descriptions
dimensional approximation based
rt n rt
bandwidth varies from
c qt n
different relation sizes
algorithm qt n
join algorithms that
qt c qt
in kbytes rt
single dimensional locational
the semijoin at
kbytes sec to
tree for s
semijoin and final
transmitted to r
a spatial semijoin
s site to
single dimensional object
and final join
locational key algorithms
in kbytes qt
dimensional object mapping
processing cost in
time sec figure
10k 50k 100k
site s site
the communication cost
join algorithms in
the minimum bounding
at site s
to cut down
to the spatial
theta theta a
objects in s
satisfy the join
the i o
to be transmitted
of the records
total time sec
theta theta c
relations r and
when the communication
s 0 at
of r and
we note that
sort merge join
number of objects
cost for the
the data sets
that are based
r tree and
each object has
the cost of
this is because
cost i o
qt 4 qt
site and s
from s site
site to s
perform the semijoin
and local processing
spatial semijoin operator
dimensional approximations obtained
algorithm rt l
multiple records of
descriptions of objects
n qt 4
locational keys in
based spatial join
spatial join can
several spatial join
cost transmission cost
the semijoin result
to approximate s
dimensional locational keys
local processing costs
in the pair
semijoin and the
the joining attribute
region represented by
ffl algorithm rt
spatial descriptions the
based semijoin algorithms
algorithm qt c
spatial join strategies
qt n qt
for lis applications
joins of different
0 at r
a merge like
algorithm rt n
and locational key
join processing we
for large spatial
for large s
total processing cost
site to r
algorithm qt 4
keys based joins
o cost saved
evaluate the semijoin
lists of locational
locational key values
varying communication bandwidth
families of algorithms

corpus/krapavin2000-test/628111.txt
lsh
hash
mh
negatives
positives
columns
hashing
similarity
sig
column
false
rows
min
association
mining
sun
jsig
bucket
cutoff
signature
estimator
fraction
pruning
candidates
sec
confidence
km
signatures
threshold
row
hamming
candidate
priori
basket
1s
agree
ksm
counter
cohen
market
haim
pairs
rules
running
motwani
densities
biased
indyk
kaplan
edith
increments
sparse
histogram
news
articles
counters
amongst
peer
matrix
subtable
hashed
synthetic
scanning
varied
tuples
screened
jm
items
nearest
extremely
associations
jc
fiat
amos
recommender
url
extracted
directional
count
cheng
quality
permute
phase
density
locality
collision
attributes
identifying
curve
fc
dissimilar
sliding
filtering
increment
chess
devising
mk
ks
pass
discovery
collaborative
permutation
matrices
unbiased
indexes
500
sparsity
exceeding
disadvantage
phrases
buckets
documents
neighbor
jian
schemes
correlated
sensitive
brute
agrawal
highly
really
227
client
ip
clustering
decreases
causal
plot
reachability
cystic
1861
masao
thetajc
darth
wingyan
fibrosis
satanic
bertolt
nakada
kjc
gras
hors
personalities
nostra
hirohito
stymied
diapers
soviet
kirpal
yishan
avant
beluga
brecht
meryl
ketel
oceania
ivanchuk
meseo
vader
feigenbaum
bucked
venkatasubramanian
misc
efjsig
subodh
dalai
cosa
caviar
krishnan
15559
mardi
polger
presse
jatin
vodka
papier
yuko
agence
karpov
chhugani
lama
5680120160200value
carinii
pneumocystis
streep
palshikar
oeuvres
ahad
hossain
timman
9518
emperor
zahid
garde
cacm
11568
objections
showcase
osana
discovered
min hash
hash values
false negatives
of false
false positives
sun data
h lsh
k mh
m lsh
min hashing
c i
each column
column c
hash value
column pairs
c j
sig i
running time
on sun
of columns
k min
the min
pairs found
columns c
data set
total running
found performance
column pair
mh on
lsh on
of rows
association rules
the hash
the rows
negative threshold
similar columns
lsh algorithm
the similarity
time sec
lsh m
mh h
priori algorithm
mh k
hash count
sec running
o km
two columns
low support
hashing scheme
of pairs
positives and
fraction of
that column
high confidence
c m
total time
same bucket
false negative
highly similar
similar pairs
mh algorithm
similarity cutoff
pass over
of min
high support
they agree
of mh
support requirement
similarity of
a priori
matrix m
columns and
similarity s
and false
of sig
vs false
similar column
biased estimator
lsh and
positives is
k 500
sec sec
negatives mh
b fraction
f 80
are varied
of column
single pass
the k
matrix c
candidate generation
the matrix
the false
the running
each row
while scanning
locality sensitive
sensitive hashing
that columns
high similarity
with similarity
market basket
values for
the column
hash table
the signature
m i
the expected
mh and
the news
data mining
news articles
similarity the
hashing schemes
synthetic data
columns are
columns that
negatives is
negatives by
counter increments
o ksm
more false
will hash
ksm 2
1s in
client ip
lsh algorithms
lsh scheme
mh algorithms
columns we
a column
rules of
time for
pairs of
o k
main memory
s c
of similar
in m
the columns
first row
algorithm as
h c
values extracted
sig j
edith cohen
k smallest
bucket we
candidate pairs
agree in
any support
support pruning
small hamming
haim kaplan
columns with
column we
negatives we
time of
hamming distance
d figure
second phase
probability that
rows in
a 1
and l
rows of
and c
k rows
and motwani
of schemes
set k
association rule
of candidates
i j
of k
column is
j c
scanning the
agree on
real data
the biased
collaborative filtering
of 1s
for column
row with
l times
pruning phase
indyk and
for similar
column in
the probability
each algorithm
and total
of interest
phase we
the tuples
is o
of counter
all columns
k sets
min hash values
number of false
for each column
sun data set
on sun data
column c i
of false positives
of false negatives
hash values for
the min hash
k min hash
of pairs found
pairs of columns
columns c i
and c j
total running time
c i and
mh on sun
min hash value
found performance of
pairs found performance
lsh on sun
i and c
fraction of pairs
a 1 in
sec running time
mh h lsh
mh k mh
min hashing scheme
in that column
k mh h
the min hashing
false negative threshold
time sec running
of min hash
lsh m lsh
of h lsh
a priori algorithm
sig i j
total time sec
running time of
the number of
r and l
false positives and
each column c
and false negatives
the hash values
positives and false
number of rows
values for each
the same bucket
of m lsh
h lsh m
the k min
pass over the
of the min
the total running
c j c
for each row
single pass over
data set k
data set f
m lsh on
of mh on
k min hashing
of column pairs
and total running
false positives is
output and total
false negatives mh
the m lsh
pair of columns
b fraction of
set k 500
a b fraction
k mh on
vs false negatives
quality of output
negatives mh k
the hash value
of k mh
set f 80
similar column pairs
h lsh on
the a priori
the running time
running time for
a single pass
the matrix c
of output and
hash values in
while scanning the
locality sensitive hashing
c i is
the matrix m
c j 0
c d figure
i c j
c i c
1 in that
hash value for
for k mh
for c i
in column c
column pairs in
and k mh
of low support
k mh algorithms
of counter increments
hash values of
1 in column
similarity of column
o ksm 2
k mh algorithm
rules of interest
number of counter
hash values extracted
m lsh algorithm
synthetic data and
small hamming distance
mh algorithm as
the biased estimator
column in a
rows in which
each column pair
over the table
false negatives by
columns that have
sec sec sec
probability that columns
hash values the
h lsh algorithm
that columns c
family of schemes
c i implies
of similar columns
mh and k
without any support
false negatives is
the news articles
the similarity of
the first row
the second phase
c i we
the hash table
of columns with
value of parameter
could be as
probability that they
h c i
the k smallest
the support requirement
matrix m i
column c j
false negatives we
in c m
they agree on
values in c
number of 1s
of c i
the probability that
j c j
indyk and motwani
each column in
the fraction of
are identical for
c j in
set of rows
to identify all
time for each
that c i
of a column
we repeat the
of the hash
m i 1
sets of attributes
for association rules
of the tuples
in main memory
k the number
number of columns
number of pairs
the signature of
all pairs of
in the running
is o k
running time and
values of r
the expected number
of the output
this scheme is
time sec false
amos fiat haim
o km 2
an idea due
cohen amos fiat
of each column
having a 1
j are identical
two columns c

corpus/krapavin2000-test/628118.txt
rnn
mealy
sma
dfsta
neural
tlu
sigmoid
analog
nite
encoding
sperduti
moore
nx
weights
activation
automata
exclusive
recurrent
biases
transducer
neuron
encodings
eqs
rst
transducers
prescription
biasless
rank
recursive
bias
discrete
biased
hot
inputs
dtrnn
dierent
undened
fsm
neurons
encode
networks
tree
simulate
dened
starita
sima
mnx
saturation
stable
trees
scaling
alternate
nets
realized
conversion
jm
growing
symbols
gori
frasconi
jg
jj
ik
grow
elman
hammer
nu
formalizations
uppercase
deterministic
alphabet
units
label
su
forbidden
threshold
slower
giles
tolerance
machines
logistic
dimensionality
outputs
layer
strategies
splitting
cient
constructive
ports
simulation
appling
safest
679686
tecnologa
1061
world7
carrasco
ndfsta
prescriptions
reestimates
tic97
rederive
unaccepted
spanish
nxk
comision
strickert
transducing
playing
mn
cult
gain
monotonically
ranked
children
barbara
network
accepting
weight
counterparts
inordinately
alessio
0941
micheli
classies
interministerial
ciencia
valence
jacobsson
vectors
dene
enlarging
duced
1085
1223
omlin
abstractrecently
minimization
counterpart
1263
1897
intro
tanh
designate
restatement
1929
adaptive
kremer
tio
aj
arena
symbol
net
transition
limits
frontier
hyperbolic
comma
unaware
schemes
constructions
acyclic
architecture
architectures
accordingly
explore
learning
laid
henrik
collection
widespread
strictly
split
f0
tolerances
fullled
1g
node
max
struc
jw
mapping
style
bj
alessandro
classication
incrementing
operating
letters
classi
ce
tures
kg
syntactical
explored
di
string
marc
ig
shorthand
discrete state
recursive neural
sma s
order mealy
nite state
high order
state tree
state rnn
neural networks
order moore
exclusive encoding
sigmoid rnn
activation function
tree automata
rnn using
rst order
encoding of
an analog
one hot
mealy rnn
analog neuron
analog unit
s construction
tree transducer
rank m
recurrent neural
output function
in discrete
next state
moore rnn
deterministic nite
threshold linear
stable simulation
sma 16
the biased
a sigmoid
zero otherwise
neural network
rnn in
dfsta in
hot encoding
linear unit
using tlu
by sma
analog rnn
time recurrent
activation functions
the bias
realized as
exist q
in sigmoid
nx and
and sperduti
the weights
the analog
scaling factor
output functions
than log
and zero
weights and
to encode
discrete time
dened as
lower saturation
growing activation
sigmoid recursive
rnn described
the rnn
the biasless
sperduti 17
input tolerance
mealy encoding
rnn a
rnn with
a dfsta
biased construction
eqs 23
possible rank
automata dfsta
conversion into
strictly growing
tree transducers
of sma
of nx
biased high
order discrete
neural nets
the rst
for stable
of rank
of h
state units
dierent schemes
of exclusive
neuron with
single layer
weights obtained
strategies to
state function
state functions
weight values
with 1
schemes to
computational power
function g
input vector
the constructive
binary input
adaptive processing
binary inputs
w 0
a nite
weights in
q 0
constructive proof
works at
input vectors
to simulate
state machines
a rst
may easily
two dierent
simulation of
w m
with where
the input
trees or
weights are
minimum value
any value
processing of
directed ordered
fsm in
jm such
hot or
as undened
dfsta a
a tlu
stable encoding
that uppercase
smaller weight
rnn into
eqs 29
moore recursive
unit tlu
notation has
sperduti and
biasless high
simulate dfsta
as rnn
alternative scheme
state vectors
rnn and
state high
0 jm
monotonically growing
language theoretical
s prescription
no biases
state splitting
the dfsta
sperduti 5
unit using
neural architectures
encoding using
tlu is
of dfsta
encoding tree
by sperduti
all biases
suitable minimization
counterparts and
theoretical formalizations
undened otherwise
minimum h
state recursive
mealy nite
nite automata
bias has
log mnx
alternate encoding
state version
using sma
rnn that
22 holds
transducers are
order rnn
saturation level
and starita
accordingly weights
rnn for
elman style
section tree
order sigmoid
nx slower
jg x
therefore works
if biases
accepting states
rnn encodings
high order mealy
nite state tree
discrete state rnn
rst order moore
sma s construction
recursive neural networks
in discrete state
exclusive encoding of
together with 1
a sigmoid rnn
state tree transducer
order mealy rnn
into a sigmoid
recursive neural network
order moore rnn
and zero otherwise
encoding of the
the next state
a high order
recurrent neural networks
discrete time recurrent
time recurrent neural
rnn using tlu
strategies to encode
for stable simulation
hot encoding of
one hot encoding
exist q 0
by sma 16
slower than log
threshold linear unit
there exist q
i and zero
for the biased
nite state machines
the output function
value of h
any value in
analog neuron with
order mealy encoding
rnn described in
stable simulation of
recursive neural nets
next state function
the adaptive processing
the biased high
an analog unit
next state functions
tree automata dfsta
sigmoid recursive neural
order discrete time
discrete state units
an analog neuron
the biased construction
rank m and
activation function g
sma s theorem
state rnn using
of recursive neural
of rank m
the discrete state
biased high order
conversion into a
state tree automata
by an analog
deterministic nite state
weights and all
the rst order
may easily be
the weights obtained
the constructive proof
tree automata in
the subset of
a rst order
realized as a
scaling factor for
activation function and
collection of m
be realized as
adaptive processing of
of nite state
such that 0
gain of the
the gain of
shown in table
the minimum value
the computational power
computational power of
is the subset
simulation of a
minimum value of
0 and zero
that of deterministic
the biasless high
tlu is a
accordingly weights are
be within of
1 a high
by sperduti 17
of accepting states
theoretical formalizations of
unit using a
we choose w
weights obtained by
nets rnn for
the bias in
or exclusive encoding
a continuous activation
and bounded real
and sperduti 5
conditions are shown
and therefore works
sma s result
minimum h satisfying
tree transducers are
are obviously identical
a lower saturation
language theoretical formalizations
deterministic nite automata
tolerance such that
that yields smaller
nite value of
most important language
or tree like
analog unit are
application of sma
of transition functions
using discrete state
single layer neural
apply our alternate
nx slower than
state version of
a recent result
mealy nite state
set to any
result by sma
in sigmoid recursive
state rnn into
order mealy recursive
recent result by
conditions and max
the analog neuron
eqs 23 25
dierent schemes to
state high order
otherwise there exist
therefore works at
values of h
reported for second
a mealy nite
moore recursive neural
to exclusive encoding
for conversion into
a discrete state
our alternate encoding
weights in discrete
nx and the
rnn using discrete
for are obviously
function is realized
state machines fsm
a nite value
rnn for the
of sma s
grow with m
biasless high order
bounded real inputs
obviously identical to
component x i
rnn that is
mealy recursive neural
on binary inputs
each possible rank
and accordingly weights
automata and recursive
jm such that
binary input vector
of deterministic nite
hot or exclusive
discrete state high
minimization of h
dened as undened
output function is
operating on binary
the same scaling
the nite state
second order discrete
grow slower than
explore the application
than log mn
function and bounded
section tree automata
gori and sperduti
as undened otherwise
realized as rnn
input vectors in
one hot or
using no biases
machines fsm in
sigmoid rnn 3

corpus/krapavin2000-test/628121.txt
folding
shattering
uced
fat
learning
activation
vc
neurons
lraam
feed
learnability
recurrent
luckiness
height
empirical
trees
sigmoidal
pseudodimension
neural
inputs
neuron
lucky
ffi
concrete
training
dm
dimension
architecture
shatters
unlimited
networks
forward
shattered
raam
kff
oe
generalization
perceptron
bounds
trained
argumentation
encoding
connectionistic
weights
pac
hm
dynamics
deviation
outputs
deltal
sgd
recursive
finiteness
dealing
ln
quantity
regularity
architectures
phi
ffl
error
permutations
decoding
smoothness
g2f
swappings
unluckiness
digit
backpropagation
tree
ff
jx
unfolded
jd
learned
structured
stratification
inequality
hoeffding
biases
encoded
labels
probability
swap
priori
network
combinatorial
recursively
polynomial
mapping
bits
ij
responsible
descent
xy
hammer
subtrees
layer
mj
mappings
possesses
answered
equipped
substitute
gradient
classification
restricted
capacity
units
ae
sample
lists
pseudo
summand
automata
valid
chemical
sup
vanishing
differs
coincides
valued
differentiable
covering
wn
quantization
deals
ps
pseudometric
sitao
chebychef
maxfheight
unlucki
rahman
1406
512e
jfgjx
gammamj
gammaun
3ffl
arity
subtracting
quantities
infinite
fulfilled
generalizes
barbara
learn
scratch
smooth
alphabet
contained
tommy
decodes
1424
alessio
trains
dichotomies
superpositions
1159
1109
prefixed
micheli
fits
propagation
principle
fix
induced
computes
estimating
capable
sperduti
ensembles
convergence
characterizes
unknown
risk
coefficient
nonempty
sequences
hidden
adjustable
1897
descend
affirmative
007
1929
analogy
indices
concerning
mutually
tio
chervonenkis
dichotomy
prohibited
elman
learnable
svm
identity
derivative
folding networks
empirical error
fat shattering
uced property
shattering dimension
feed forward
function class
learning algorithm
of folding
initial context
folding architecture
real error
the lraam
the uced
activation function
the empirical
the vc
valid generalization
small empirical
a folding
distribution independent
bounds on
any learning
concrete learning
the sigmoidal
the feed
the luckiness
the fat
dm f
activation functions
the deviation
forward networks
with inputs
vc dimension
of examples
function oe
and fat
forward part
high trees
input height
folding network
context y
maximum input
information theoretical
input trees
standard feed
inputs in
deviation of
r l
input tree
derive bounds
height of
a concrete
structured data
of height
the encoding
f jx
via g
recursive part
vc pseudo
underlying regularity
folding architectures
latter probability
independent uced
theoretical learnability
f ffi
and folding
sigmoidal case
a learning
the activation
neural networks
x t
the real
0 1
trees of
the generalization
generalization error
on x
the recursive
hm f
computation units
architecture is
x f
the trees
the probability
input space
weights and
the architecture
in x
a finite
p f
1 ffi
maximum height
an architecture
with small
dealing with
the weights
be learned
of neurons
learnability of
l 0
the function
of structured
luckiness function
w ln
lraam is
fat ffl
finite fat
concrete training
luckiness framework
two feed
processing dynamics
f hm
perceptron activation
combinatorial quantity
to bounds
the raam
connectionistic methods
distribution dependent
pseudo and
29 theorem
context neuron
the pseudodimension
first bits
sigmoidal function
ffi ff
context neurons
jd p
jx t
unlimited size
learning of
the bounds
t ij
the concrete
of trees
finiteness of
y 0
x 0
of dealing
real vector
smooth with
the perceptron
for valid
height at
guarantee valid
covering number
class f
recurrent and
phi m
different length
recurrent neural
error is
dimension of
for learning
0 x
of learning
is trained
ffl and
f for
the input
neurons are
recursive nature
ffi for
the folding
all binary
input neurons
from learning
is answered
cannot exist
explicit bounds
vector space
error and
networks for
allows us
g y
the labels
limited by
f is
valued function
oe is
y y
processing of
function classes
error from
o w
which guarantee
neuron in
and inputs
distributed representation
adaptive processing
are trained
the situation
this purpose
y 2
inputs and
be limited
of functions
r m
trees with
dimension if
fat shattering dimension
the empirical error
the real error
the uced property
bounds on the
of folding networks
small empirical error
the function class
any learning algorithm
the feed forward
activation function oe
the initial context
number of examples
the deviation of
trees of height
the fat shattering
with small empirical
l 0 x
0 x f
feed forward networks
maximum input height
feed forward part
for any learning
a concrete learning
of high trees
probability of high
of the empirical
deviation of the
the activation function
on the deviation
standard feed forward
algorithm with small
the maximum input
us to derive
the vc dimension
height of the
of structured data
the generalization error
a learning algorithm
information theoretical learnability
initial context y
and folding networks
the sigmoidal case
the distribution independent
independent uced property
inputs in x
the latter probability
empirical error and
of a folding
the recursive part
the underlying regularity
in the sigmoidal
a folding network
distribution independent uced
a folding architecture
x f ffi
and fat shattering
in a concrete
0 and y
to be learned
x 0 and
on the vc
a real vector
to derive bounds
and y 0
y y y
the maximum height
number of functions
maximum height of
is to be
f is a
and the real
of a learning
error and the
f hm f
a concrete training
two feed forward
the first bits
the perceptron activation
theoretical learnability of
finite fat shattering
empirical error is
stratification of the
hm f x
the vc pseudo
vc pseudo and
from learning theory
the lraam is
recurrent and folding
dimension if f
of height at
the luckiness framework
of the lraam
function class with
jd p f
pseudo and fat
phi m l
of examples which
concrete learning algorithm
the folding architecture
the input neurons
valued function class
f jx t
guarantee valid generalization
folding networks a
weights and inputs
is smooth with
shattering dimension of
smooth with respect
learnability of folding
a finite fat
m l 0
and 1 ffi
of folding architectures
by at most
allows us to
on the generalization
can be bounded
recurrent neural networks
the input trees
derive bounds on
y 2 r
explicit bounds on
the input tree
ffl and 1
the weights and
p on x
for valid generalization
height at most
with inputs in
into a real
on the activation
in 1 ffl
for this purpose
bounds for the
in x and
the probability of
t is chosen
1 ffl and
on the concrete
vc dimension of
adaptive processing of
a function class
learning algorithm with
can be limited
are identified with
finiteness of the
error from the
of the architecture
it allows us
finite set of
theorem 5 7
polynomial in 1
the architecture is
the number of
real vector space
as to whether
learning algorithm is
a finite set
of the labels
is chosen such
of the trees
the input space
be limited by
of dealing with
probability can be
a tree is
in the recursive
is a probability
on the number
be bounded by
bounds can be
at most t
the first half
of x 0
which is to
of the inputs
linear neuron in
back propagation through
derive explicit bounds
k deltal r
concrete training set
distribution into account
error generalizes well
4 or 0
function l 0
most 0 1
f g2f jd
any binary mapping
real error of
to folding networks
in 14 theorem
error cannot exist
feed forward architectures
is encoded recursively
a small empirical
14 theorem 11
tree structured inputs
time series prediction
g2f jd p

corpus/krapavin2000-test/628123.txt
pulsing
ssn
constituents
stm
constituent
ssns
parse
sentence
connectionist
tsvb
parent
units
word
corpus
tag
sentences
activation
grandparent
parsing
parser
srn
noun
period
generalise
synchrony
tags
henderson
verb
generalisations
phases
learning
vbd
outputs
sibling
generalisation
training
syntactic
srns
susanne
article
pcfg
relationships
recurrent
structural
grammars
parsers
mary
loves
network
child
vvd
trainingepochs
bpts
percentagecorrect
dependency
layer
precision
phrase
265
trained
neural
systematicity
outputting
linguistic
occurring
text
grammatical
entity
learn
vp
lengths
statistical
networks
bptt
regularities
representations
phrases
toy
grammar
activations
trainable
structured
phase
ability
preparsed
incremental
train
language
binding
queue
dependencies
linguistically
entities
backpropagation
output
english
architectures
layers
across
inputs
naturally
holistic
unit
pulses
symbol
periods
temporal
np
chased
hayward
hadley
i2inputs
constituency
leeds
lancaster
pcfgs
corpora
gps
nn
unfolded
linguistics
learned
preorder
incrementally
hebbian
65
constructions
cross
james
john
encoding
adjustments
adjective
died
rat
neuroscience
bank
unbounded
encode
confluent
percentage
jj
97
manifested
learnt
specifies
letter
learns
dog
verbs
grounds
representational
tree
rectangles
cat
cognitive
label
71
feed
target
68
correlates
drawn
probabilities
architecture
parsed
forgotten
70
specify
net
sigmoid
abilities
experiments
coverage
80
link
siblings
banks
clauses
association
74
mechanism
occupies
hierarchical
38
explores
fundamentally
uk
head
broad
weights
green
92
72
decoding
thereby
degrades
fernand
unmotivated
psycholinguistic
the ssn
word tag
non pulsing
pulsing units
occurring text
the network
the pulsing
time period
pulsing input
the stm
of constituents
word tags
parse tree
naturally occurring
to generalise
natural language
structural relationships
to parse
the constituent
the sentence
the parent
output units
synchrony networks
simple synchrony
parent child
language learning
of naturally
in period
pulsing unit
noun phrase
a connectionist
corpus of
input units
o n
a corpus
child relationships
of words
the word
the srn
of tsvb
structural constituents
this article
precision recall
units in
term memory
each word
the susanne
tag s
of constituent
generalise across
constituent which
pulsing inputs
ssn to
ssn s
basic ssn
tsvb networks
of stm
ssn architectures
ssns to
structured output
of phases
syntactic parsing
the grandparent
the constituents
the parse
a sentence
parent of
short term
in phase
output activation
output representations
james henderson
being input
of pulsing
trainingepochs percentagecorrect
ssn architecture
phase p
generalisation ability
connectionist network
current word
networks ssns
one constituent
sentences drawn
the o
unit j
to output
output unit
average precision
the verb
and recall
the experiments
the corpus
connectionist architecture
constituents and
constituents as
constituents which
generalise over
correct constituents
ssn parser
words fit
representing how
period so
parent output
statistical parsers
stm length
activation from
a stm
constituent 2
constituent structure
stm mechanism
output specifies
standard connectionist
ssns for
temporal synchrony
constituent level
susanne corpus
sibling output
noun phrases
each constituent
between constituents
of ssns
constituent 3
layer train
connectionist language
distributed representation
activation is
word and
activation of
of correct
each layer
of unit
of output
input unit
period 1
context free
learning to
output representation
syntactic structures
corpus used
the sibling
s parent
of dependency
output the
learn to
the words
the activation
ability to
new phase
connectionist networks
fit together
tag is
same phase
the noun
sentences with
these outputs
to learn
each phase
relationships between
be output
statistical language
phases to
a parse
simple recurrent
the sentences
units are
for learning
unit in
precision and
this output
parse trees
parent is
structure representing
period 5
grandparent parent
average sentence
this generalisation
sentence s
stm lengths
across syntactic
pulsing pulsing
generalise in
synchrony variable
the gps
stm the
memory stm
simple srn
265 24
parse in
constituents for
dependency length
text this
context unit
pulsing output
parsing natural
constituents that
dependency lengths
form constituents
language parsing
test units
standard task
naturally occurring text
non pulsing units
simple synchrony networks
of naturally occurring
the word tag
corpus of naturally
pulsing input units
the non pulsing
a corpus of
short term memory
parent child relationships
ability to generalise
the o n
number of words
from a corpus
word tag s
learning to parse
the ssn s
the ssn to
to the ssn
the basic ssn
average precision recall
number of constituents
of the ssn
the parse tree
the parent of
child relationships between
with each word
is the parent
the constituent which
units in each
sentences drawn from
the current word
tag s parent
each word tag
of the stm
the pulsing units
to generalise across
to the network
in each layer
each time period
of output units
o n 2
the constituent level
synchrony networks ssns
a short term
of correct constituents
set of constituents
non pulsing unit
word tag is
learn to parse
in time period
the susanne corpus
in phase p
basic ssn architecture
is the constituent
structure representing how
words fit together
non pulsing input
hierarchical structure representing
of non pulsing
allows the ssn
fit together to
of stm length
connectionist language learning
of simple synchrony
each layer train
precision and recall
for learning to
time period and
activation of a
statistical language learning
in the sentence
discussed below we
the pattern for
to learn to
drawn from a
of the network
the same phase
a parse tree
in the experiments
the number of
number of correct
together to form
unit in the
that the network
period and phase
the simple srn
n 2 speed
to generalise over
to naturally occurring
networks ssns for
the gps representation
g p s
of tsvb networks
generalise over constituents
word tags in
the corpus used
a parent child
enables the ssn
phase p at
the sentence mary
n 2 structural
those words fit
the noun phrase
in period 5
to linear time
parsing natural language
sentence length of
natural language parsing
the sentence s
synchrony variable binding
how those words
parent of constituent
across structural constituents
pulsing units in
the ssn parser
current word tag
constituent 2 is
parent child relationship
english sentences drawn
effects of stm
output activation of
average sentence length
2 structural relationships
to parse in
the parent output
of phases to
the sibling output
sequence of input
occurring text this
that the ssn
would receive the
shows the activation
representing how those
ssn architecture to
phases to represent
the pulsing input
type of unit
in the stm
term memory stm
temporal synchrony variable
a connectionist network
a non pulsing
test units in
experiments discussed below
input output representation
use of phases
p at time
architecture to linear
during each period
pattern for symbol
a standard task
occurring text the
ssns for learning
a noun phrase
pulsing unit j
receive the pattern
units in every
length of dependency
word tag as
non pulsing pulsing
to form constituents
structured output representations
for connectionist language
ssn s performance
a hierarchical structure
presented to the
in this article
with the standard
by the network
the same parent
the experiments discussed
for computational linguistics
association for computational
type b and
parsing of natural
into a distributed
the output activation
the parent child
a connectionist architecture
syntactic parsing of
2 speed of
a new phase
of the basic
input to the
of the queue
its ability to
a bounded number
a distributed representation
of the parse
context free grammars
the output units
parent of the
natural language sentences
of the sentence
of a sentence
introduced to the
for natural language
for each phase

corpus/krapavin2000-test/628124.txt
triplets
lre
triplet
training
colin
aunt
vectors
learning
hinton
family
learn
matrices
modular
goodness
learned
gradient
person
conjugate
concepts
units
giannina
person1
aunts
charlotte
italian
people
modied
dots
relational
ascent
english
1986
pietro
multiplication
principal
hidden
person2
mariemma
dimensions
eq
neural
answers
layer
trained
scaled
0g
rst
squared
discriminative
gure
christopher
specied
tried
dynamics
margaret
iterations
temperature
embedding
kr
penelope
aurelio
nephew
giulio
jennifer
alberto
father
dynamical
correctly
sibling
recurrent
christine
answer
spouse
annealed
644
brother
representations
144
tree
112
relations
rotation
108
lsa
omitted
concept
matrix
camera
spiral
married
degrees
son
semantic
stars
met
omitting
pca
330
430
coded
nipote
pollack
uncle
niece
nephews
2050
diering
grazia
autoencoder
roweis
landauer
nationality
doralice
zii
pose
backpropagation
word
dierent
persons
errors
nd
1990
nds
andrew
freedom
females
raam
dayan
got
intensity
noise
diagrams
exp
arriving
randomly
encoding
latent
images
victoria
penultimate
males
anticipates
marcello
wife
14a
convergence
activity
sensible
parents
maximizing
450
optimizing
generalization
unobserved
726
sign
crosses
linearity
242
weights
multiplying
families
350
exponents
xed
hundred
dissimilarity
arthur
limitation
marked
connects
90
criteria
ought
multilayer
generalizing
distance
encodes
endpoints
converged
origin
specic
regularities
missing
multidimensional
row
maria
isomorphic
correct
sam
solid
generalize
perfect
vector
conguration
motions
separable
discrete
held
trick
family tree
number problem
triplets were
tree problem
numbers operations
with numbers
modular number
after learning
each triplet
the family
non modular
multiplication r
goodness function
the triplets
scaled conjugate
linear relational
relational embedding
triplet c
6 units
r c
concept vectors
the vectors
principal components
to learn
conjugate gradient
using scaled
hinton 1986
lre is
the training
the hidden
and relations
during training
a c
triplets in
the dots
the multiplication
eq 3
hidden state
semantic features
operations f
convergence criteria
triplets randomly
chosen out
of principal
of triplets
dots are
c a
distributed representations
correct answer
squared distance
linear dynamical
complete all
training set
concepts and
the squared
algorithm met
english people
lre was
criteria after
triplets which
tree task
the correct
problem with
correct answers
notice how
of concepts
vectors obtained
a triplet
the modied
and matrices
the modular
the 90
third term
the system
matrices and
of arriving
person belongs
of colin
solution shown
colin and
dimensions lre
second layer
112 triplets
output model
relation aunt
4 0g
lre on
gradient ascent
vectors and
met the
3 dimensions
data set
for training
number 10
intensity images
the temperature
using gradient
the dynamics
representations of
were used
was able
specied by
randomly chosen
vectors in
the numbers
the rst
each concept
new matrix
training the
the matrices
2 dimensions
input units
same family
the triplet
binary relations
output units
information about
b c
encoding of
tried to
ascent to
learned distributed
with stars
operations 0g
correctly complete
line connects
vector endpoints
ones representing
colin aunt
learning distributed
discriminative goodness
lre to
modied goodness
held out
24 input
distributed encoding
that person
correctly completed
350 triplets
kr a
generation has
obtained optimizing
exp kr
multidimensional scaling
crosses are
using lre
families are
local encoding
hidden space
units learned
number problems
threshold distance
triplets from
644 triplets
lre could
relational term
representing consecutive
result of
in g
system had
diagrams of
the vector
obtained after
we tried
the convergence
the activity
during testing
two dimensions
system was
was obtained
each vector
of 6
stars and
function while
between concepts
concepts as
components number
father of
lines were
the crosses
of freedom
the solution
learn the
recurrent neural
omitted from
the ones
dynamical systems
consecutive numbers
new concepts
gradient for
when tested
married to
t know
components analysis
data consists
generalization performance
the father
of person
learn a
the goodness
the family tree
family tree problem
r c a
c a c
with numbers operations
for each triplet
number problem with
the number problem
modular number problem
problem with numbers
scaled conjugate gradient
linear relational embedding
the multiplication r
each triplet c
multiplication r c
using scaled conjugate
of the multiplication
from the training
the dots are
all the triplets
the non modular
concepts and relations
of principal components
dots are the
are the result
non modular number
on the family
operations f 1
the convergence criteria
number of triplets
the squared distance
randomly chosen out
the hidden state
chosen out of
triplets randomly chosen
a c for
the training set
the correct answer
the result of
algorithm met the
met the convergence
the concept vectors
triplets in the
numbers operations f
distributed representations of
family tree task
of 6 units
using gradient ascent
convergence criteria after
vectors and matrices
were used for
result of the
in the hidden
c for each
with real data
number of principal
of arriving at
vectors obtained after
after learning the
triplets were used
allowed to learn
shown in g
the second layer
eq 3 using
the modular number
lre was able
complete all the
in 3 dimensions
the solution shown
4 4 0g
obtained after learning
the goodness function
3 using scaled
tree problem in
the third term
in two dimensions
of the 90
linear dynamical systems
all the vectors
used for training
was able to
specied by the
of the family
of the vectors
the system was
the vectors in
the system had
omitted from the
the same family
in eq 3
training set and
local encoding of
and a solid
distributed encoding of
representations of concepts
optimization algorithm met
of triplets which
diagrams of the
function eq 3
line connects the
6 units learned
lre on the
the ones representing
held out during
solid line connects
numbers the dots
modied goodness function
in the dynamics
probability of arriving
obtained optimizing the
marked with stars
in a triplet
the semantic features
350 triplets randomly
solution was obtained
this solution was
able to nd
the hidden space
encoding of relation
principal components number
connects the ones
with stars and
lines were obtained
units learned distributed
conjugate gradient for
out during training
correctly complete all
new concepts and
triplet c the
ascent to optimize
optimize the modied
encoding of person
goodness function eq
matrices and vectors
the modied goodness
optimizing the goodness
gradient ascent to
triplets which were
using lre on
discriminative goodness function
representing consecutive numbers
learned distributed encoding
result of multiplying
person belongs to
same family tree
squared distance between
minimize the squared
numbers operations 0g
exp kr a
vector endpoints are
the english people
goodness function while
endpoints are marked
ones representing consecutive
operation is outside
stars and a
consecutive numbers the
was obtained optimizing
learning distributed representations
the crosses are
rst two terms
number problem and
of the correct
3 4 4
f 1 1
to learn a
learn a new
6 units in
components number of
component of each
of concepts and
units on the
vs the number
the father of
when tested on
the optimization algorithm
modied to include
concept as a
of each vector
3 3 4
in the family
the data set
a new matrix
data consists of
the vector representing
don t know
able to learn
are marked with
principal components analysis
a solid line
missing from the
shown in gure
all the information
to learn the
are represented by
latent semantic analysis
connected to each
matrices and the
in 2 dimensions
some information about

corpus/krapavin2000-test/628132.txt
images
image
xi
query
display
coecients
database
visual
distance
voronoi
nin
metric
sa
color
emergent
feature
xj
similarity
polygons
interface
interaction
va
endowed
operators
l2
el
gd
tensor
yi
meaning
exploration
operator
concept
car
quantization
wavelet
medieval
modigliani
crucifixion
weyl
spaces
multimedia
labels
databases
sb
transform
exploratory
coecient
screen
heisenberg
cultural
asa
retrieval
ane
icon
placed
displayed
fig
subjects
dierent
distances
subgroup
keywords
colors
gosselin
irn
ir6
giang
painting
matthieu
cbir
semiotics
paintings
creation
metadata
sk
centroids
jd
homomorphism
manifold
dieomorphic
pentagonal
latin
eco
worring
portrait
oer
ecient
projection
grayscale
mediated
cord
hexagon
rahul
vb
schematically
anchored
riemann
invariance
browsing
interfaces
concepts
textual
regularization
tensors
manipulation
indices
angular
algebra
stars
marcel
art
gabor
endow
hessian
histograms
semantics
ramesh
closeness
dissimilarity
circle
cars
configuration
media
raw
front
semantic
paris
nguyen
mother
position
manipulate
viz
jain
origin
attached
philippe
transforms
dimensionality
triangular
sake
multidimensional
queries
social
determination
production
interacts
unitary
group
linguistic
box
terminals
singh
spring
filtering
enforce
300
vision
deemed
interpretation
knickmeyer
evocative
takama
rodrguez
celmar
altman
tihonov
aristotelean
isq
havementioned
torres
lookig
derik
steji
similerity
saussurean
bosque
cuv
archtecure
matism
vademecum
yasufumi
wihch
artistic
kanagasabai
purport
signifie
gij
octagonal
tversky
rajaraman
verbocentric
measure3
pilho
restrepo
fotouhi
contributer
lina
sreenath
portait
feature space
display space
the feature
query space
the display
the query
the database
the images
of images
visual concept
an image
images that
the image
images in
the distance
voronoi polygons
the user
el nin
natural distance
nin o
the interface
xi yi
image databases
distance function
the metric
the meaning
image is
of image
space is
distance between
endowed with
image representation
of coecients
query operator
visual concepts
emergent semantics
xi xj
l2 x
yi are
similarity measure
meaning of
a metric
of labels
space f
a concept
space the
a visual
polygons of
image data
metric tensor
interface is
the space
our database
two coecients
e xi
similarity criteria
vector quantization
a distance
the operators
user interaction
and placed
is endowed
of sa
image in
optimization problem
the interaction
sa and
xi and
query the
whole database
ane group
weyl heisenberg
a modigliani
car image
heisenberg group
the weyl
va and
of va
images around
sa sa
an icon
dimensional display
some images
i jd
f xi
of fig
image space
in fig
on multimedia
distance functions
image database
can t
and sb
three spaces
art and
a query
the screen
function f
the color
operators that
the transform
distance from
metric of
two images
image with
display the
and yi
current database
our interface
of el
of voronoi
configuration of
for image
of distances
user the
space and
the concept
are looking
of operators
space in
concept can
space q
the voronoi
database but
the textual
a feature
we will
concept is
database the
placed in
interaction with
of distance
traditional databases
coecients of
sa is
color image
of parameters
these operators
color of
feature sets
the tensor
of keywords
f is
a configuration
in image
transform of
exploration of
the natural
the subjects
the exploration
images and
the parameters
f f
of indices
fig 3
the coecients
of color
its distance
dimensional feature
multimedia october
projection operator
wavelet transform
possible to
user and
manipulation of
the operator
low dimensional
a color
interface for
x y
distance in
visual queries
the cultural
tensors g
operator q
of gd
not metric
sa then
concept will
discrete transform
place operator
france giang
exploration interface
features xi
coecients between
raw feature
vb i
the tensors
meaning but
images closest
few images
stars are
tensor to
interaction involving
graphical front
o 18
xj in
null only
guided exploration
apply vector
the feature space
the display space
the query space
in the display
images in the
el nin o
of an image
the distance between
of the database
endowed with a
feature space is
of images in
of the images
the natural distance
of the image
a visual concept
in the feature
the meaning of
of images that
an image is
meaning of an
set of labels
the image data
the metric tensor
voronoi polygons of
display space is
xi yi are
of the query
images that are
of the feature
the images in
the set of
with a metric
in image databases
feature space f
to the query
set of images
feature space the
is endowed with
distance function in
is possible to
of the interaction
the images that
g and c
of the display
the image space
of the user
the metric of
the whole database
of our database
visual concept can
the query operator
in traditional databases
e xi xj
query space is
the user interaction
the weyl heisenberg
number of coecients
sa and sb
query space the
weyl heisenberg group
of el nin
of voronoi polygons
image is represented
the voronoi polygons
display space the
it is possible
distance between the
in fig 3
the user the
image in the
the distance function
a distance function
and the circle
of distance functions
and the images
representation of g
x y 0
is the metric
class of distances
distribution of images
xi and yi
as the action
a configuration of
distance between two
are looking for
to the image
set of keywords
feature space for
the current database
feature space in
its distance from
the user and
a function f
space for the
of the distance
can t be
an image with
a low dimensional
the database the
a representation of
to the concept
dimensional feature space
metric of the
on the screen
to the user
in the database
by the user
the creation of
a set of
distance in the
in the interface
distance from the
user and the
on multimedia october
determination of the
is the set
in the query
a number of
conference on multimedia
possible to define
annual acm international
space of distance
the display operator
two dimensional display
nin o 18
the textual query
display the whole
a concept box
philippe h gosselin
that of va
france giang p
concept will be
of color images
a measure on
topological but not
the user interacts
the images to
images x and
features xi yi
space is dieomorphic
the discrete transform
triangular stars are
three spaces the
the k images
an image can
context that suggests
between two coecients
visual concept is
a visual query
vector quantization an
tensor to be
the tensors g
j c e
model of interface
images that will
voronoi polygons that
polygons of image
by moving images
are linear features
given feature space
in which meaning
interface of el
interfaces for emergent
space from the
query space q
coecient in the
space is endowed
the place operator
c e xi
quantization an image
let sa and
and the triangular
moving images around
sa sa is
space d is
of coecients between
of sa sa
of visual concepts
display space as
case of color
the raw feature
tensors g and
then the metric
yi are angular
that of fig
that the voronoi
null only at
h gosselin matthieu
image is a
images closest to
hexagon in fig
vector quantization to
be non null
dieomorphic to ir6
apply vector quantization
paris france giang
database the query
raw feature space
class of images

corpus/krapavin2000-test/628133.txt
metadata
segments
news
video
unstructured
transitive
keywords
transcripts
query
segment
retrieval
retrieved
item
annotated
retrieve
composition
keyword
qs
similarity
clinton
universe
maxfd
content
items
cluster
reno
cut
transcript
structural
clustering
precision
semi
caption
fund
interview
weighting
hybrid
newscast
visuals
cuba
pope
newscasts
iraq
counsel
matched
belonging
clips
indexing
baby
foci
structured
annotation
cosine
event
match
raising
off
threshold
cl
comprised
ids
scene
search
clusters
leary
oprah
alabama
controversy
knife
gondola
isreal
clustered
eq
stemming
east
acquired
netanyahu
police
informedia
intern
janet
id
sibling
517
stories
sq
clinic
salton
cnn
union
eddie
digital
scenes
audio
frequency
matching
wild
relationships
automatic
chinese
border
creation
story
extraction
you
theme
witnesses
house
corpus
tf
scripts
visual
diagram
fig
siblings
structurally
queries
son
piece
object
organize
weight
candidate
text
isolate
trial
composing
him
indices
returned
varadero
kaczynski
captioned
karla
captioning
reporter
caffeine
15533
mexican
raiser
nbc
genocide
elway
louise
bombing
guatemala
daryn
arrest
gay
democratic
faye
excavation
headline
awaited
okay
sights
tuker
enactment
posses
winfrey
stalemate
wachman
donated
queryable
narrative
chabot
videofile
lebanon
arafat
standoff
50471
engaging
thematically
gore
paducah
58237
camerawork
woodword
04180
iraqi
sailor
9502702
50603
johnny
d65
santiago
kentucky
competency
officials
comedies
campaign
cbs
31821
albright
preassembled
weapons
justice
hostage
rotorua
falcon
unstructured metadata
transitive search
news item
news items
video data
semi structured
video segments
off threshold
a news
of segments
structural metadata
the transitive
cut off
the segments
metadata the
structured metadata
annotated metadata
a query
of metadata
metadata and
segments belonging
content metadata
related segments
the unstructured
four step
query cut
news event
same news
the query
a transitive
similarity distance
of keywords
metadata sets
metadata to
metadata in
video composition
step hybrid
recall of
the recall
segments are
to retrieve
s a
similarity value
a segment
of video
q s
maxfd s
news video
segments s
segments in
union operation
the similarity
retrieval technique
object id
segments that
s q
metadata annotated
universe s
fund raising
binary relationship
automatic composition
segment weighting
more keywords
query match
metadata we
closed caption
process diagram
structured objects
belonging to
digital video
and retrieval
metadata of
composition system
object ids
the keywords
candidate set
retrieved as
the news
of news
a video
retrieve all
the content
segments with
all segments
keyword vector
potential news
transitive cut
transcript metadata
within video
video piece
theta maxfd
metadata for
metadata can
segments related
independent counsel
distinct news
time relationships
increase recall
from video
metadata based
hybrid retrieval
retrieval techniques
the retrieval
query q
of unstructured
indexing and
segment s
search technique
initial segment
weight assigned
for transitive
of annotated
value retrieved
keywords of
initial retrieval
improve recall
query matching
search and
the video
proposed hybrid
with video
keywords in
concept i
precision of
s b
d s
query processing
in video
comprised of
cl i
keywords are
the universe
the segment
in recall
a concept
item the
hybrid approach
matched against
returned as
s t
q g
considered similar
of content
creation time
and structural
the union
term i
the cluster
composition of
search is
two segments
data set
objects clustered
clustered object
metadata associated
isolate video
into potential
final weight
a newscast
hybrid metadata
no independent
matched object
o leary
match final
complete unstructured
broadcast news
introduction field
caption data
associated unstructured
video based
for annotation
a theme
scene interview
caption metadata
transcripts and
metadata object
transitive retrieval
janet reno
related segment
all keywords
objects retrieve
about clinton
extended cluster
segment vectors
retrieve related
highest match
retrieve additional
qs loop
corresponding semi
metadata matched
2 qs
eddie price
newscast composition
segment transcripts
metadata organize
results clustering
each news
clustered semi
newscasts based
retrieved segments
the transitive search
cut off threshold
a news item
semi structured metadata
the unstructured metadata
a transitive search
segments belonging to
the same news
unstructured metadata the
query cut off
of a news
set of segments
four step hybrid
semi structured objects
recall of the
the similarity distance
number of segments
initial segment weighting
retrieved as a
of unstructured metadata
metadata in the
the query cut
of video segments
unstructured metadata of
a result of
of a query
the four step
among the segments
the recall of
query q s
result of a
belonging to a
of a segment
s a s
within video data
creation time relationships
set of video
hybrid retrieval technique
increase in recall
a concept i
number of keywords
the news items
automatic composition of
transitive search we
the content metadata
theta maxfd s
process diagram for
a binary relationship
transitive search and
associated with video
video composition system
the transitive cut
news item the
news video data
transitive cut off
same news item
concept i for
maxfd s q
for transitive search
same news event
to a news
and structural metadata
similarity distance of
returned as a
s q g
of annotated metadata
as a result
of the highest
candidate set of
techniques for video
d s a
the similarity value
weight assigned to
from the content
t q s
s t q
the proposed hybrid
to retrieve all
a query q
the two segments
the union operation
segments that are
to a concept
technique is based
of the video
precision of the
belonging to the
no independent counsel
matched semi structured
to retrieve additional
towards a theme
segment in a
a cut off
d theta maxfd
information within video
different metadata sets
unstructured metadata and
metadata associated with
final video piece
of segments with
such as free
of related segments
structured metadata matched
content metadata and
structured objects retrieve
complete unstructured metadata
clustered semi structured
all the segments
proposed by salton
a newscast composition
of metadata and
to isolate video
the complete unstructured
if more keywords
matching a query
retrieval technique is
composition of news
segments are considered
retrieve corresponding semi
a query therefore
transitive search technique
query match final
value retrieved as
closed caption metadata
the structural metadata
closed caption data
of segments that
off threshold for
maxfd s t
step hybrid approach
q s g
of our observations
structured metadata object
potential news items
keyword based search
retrieve all segments
2 qs loop
transitive search the
segments related to
final weight assigned
corresponding semi structured
off threshold is
qs loop on
binary relationship on
the white house
of segments s
news items with
metadata and structural
a news event
single news item
each news item
news item to
with video segments
video data retrieval
query or 0
off threshold t
field scene interview
introduction field scene
structurally related to
item to retrieve
newscasts based on
i for query
retrieval and composition
the proposed query
the segments belonging
relationship on s
different retrieval techniques
on the transitive
of different retrieval
match final weight
the intern controversy
metadata for the
clustered object id
the initial retrieval
matched object ids
annotated metadata and
metadata and the
free form text
similarity value with
theta max s
unstructured metadata we
metadata to retrieve
into potential news
step hybrid retrieval
associated unstructured metadata
to improve recall
the universe s
define a binary
transcripts and the
metadata that are
are structurally related
for query match
segments of a
structural metadata to
metadata of each
highest value retrieved
transitive search is
cluster resulting from
the highest match
a video segment

corpus/krapavin2000-test/628140.txt
subtransactions
subtransaction
transaction
serialization
rpo
flexible
hddbs
compensating
cascading
sseg
committed
compensation
compensatable
ct
commit
retriable
serializability
ip
aborts
serializable
1p
oe
ls
serialized
rpos
atomicity
concurrency
gtm
database
commits
site
jp
multidatabase
schedule
compensated
abort
commitment
compensations
2p
jq
dependencies
surplus
znbb94
retrial
schedules
items
invalid
pivot
ldbs
unilaterally
interference
mrb
serialize
aborted
insertion
consistency
alternate
switching
transactions
integrity
grs91
lks91a
gm83
globally
bank
submitted
criterion
ldbss
precede
termed
protocol
scheduling
sites
reads
mrks92
conflict
execute
executed
submission
1j
deposit
deleted
heterogeneous
preference
precedence
ticket
edge
prefix
trans
executes
blocking
avoids
manager
global
ds
execution
avoiding
deletion
effects
executions
unambiguous
priority
retried
item
enforcing
2j
conflicts
preferred
semi
committable
kls90
resubmitted
refundable
autonomous
alternatives
gd
regain
inserted
delete
autonomy
preservation
edges
databases
conflicting
bhg87
workflows
bs88
multidatabases
retry
consistent
semantic
scheduled
attempted
enforced
traditional
serial
fare
withdrawal
isolation
prepare
scheduler
contradicts
ft
concurrent
inconsistency
delays
maintains
wc
preserve
precedes
successors
formed
management
forced
uncommitted
action
inconsistent
observations
fails
resilience
travel
ld
rc
undone
transfers
backtrack
submits
avoided
her
centric
transactional
sub
unavoidable
unaffected
ensures
maintained
insert
i2
predecessors
submit
ffl
plane
issuing
rule
flow
i1
integrates
violate
preserves
resilient
decision
accesses
ellr90
pu88
limo
sks91
uncompleted
bds
bz94
schek
flexible transaction
flexible transactions
serialization point
oe rpo
global transaction
t ip
t i
local site
its serialization
of flexible
the sseg
global transactions
subtransaction t
a subtransaction
the hddbs
concurrency control
t j
local transactions
transaction t
cascading aborts
subtransactions of
the serialization
compensating subtransaction
t 1p
ls p
a flexible
of subtransactions
local database
compensating subtransactions
hddbs environment
compensation interference
global serializability
of t
t 2p
committed oe
oe rpos
execution of
the committed
t jp
serialization order
ct i
subtransactions in
data items
global schedule
the flexible
interference free
the execution
f serializability
f serializable
site ls
edge insertion
schedule s
transactions in
globally serializable
serializable schedules
global concurrency
semi atomicity
its compensating
t jq
database state
a global
to commit
the subtransactions
subtransaction is
m ip
of global
serialized between
avoiding cascading
a hddbs
ct ip
t 1
database consistency
distributed database
transaction model
before t
global subtransactions
local sites
at local
subtransactions which
account a
subtransaction ct
insertion rule
avoids cascading
sseg algorithm
and ct
invalid subtransactions
their compensating
at ls
switching set
for flexible
t oe
t 2
executes its
subtransaction of
global database
that t
ip is
control criterion
point until
bank b
cascading compensations
global subtransaction
is compensatable
the global
all subtransactions
sub transaction
scheduling protocol
global decision
and t
commitment of
consistent database
each subtransaction
subtransactions at
conflict equivalent
subtransactions that
if t
heterogeneous distributed
execute its
local transaction
have committed
flexible and
between t
transaction may
local databases
each global
serialized before
subtransactions and
surplus transactions
in znbb94
two subtransactions
rpo of
must serialize
executed its
rpos of
ct 1p
operation submission
subtransaction at
local flexible
of compensation
cascading abort
submission rule
1p s
ip must
the local
integrity constraints
transactions and
transactions are
database systems
global consistency
a committed
the commitment
transactions t
decision to
and local
value dependencies
the gtm
one subtransaction
semantic atomicity
edge t
a compensating
in bank
and commit
ip and
on global
order t
a oe
transaction is
t m
well formed
transaction management
are compensated
committed subtransactions
the cascading
committed flexible
flexible trans
retriable subtransactions
compensation or
serialize before
is compensation
or retrial
serialization points
these subtransactions
ct m
serializability on
two flexible
avoid cascading
formed flexible
the compensating
no subtransaction
compensatable subtransaction
subtransactions is
compensating transaction
maintains global
alternate oe
1p which
is retriable
ip in
transaction manager
subtransactions are
is serialized
a flexible transaction
flexible transaction t
its serialization point
in the hddbs
of flexible transactions
of a flexible
the execution of
execution of flexible
compensation interference free
the serialization point
local site ls
the hddbs environment
a global transaction
of global transactions
global concurrency control
the flexible transaction
committed oe rpo
global schedule s
executes its serialization
of t i
and local transactions
a subtransaction t
the committed oe
subtransaction t i
avoiding cascading aborts
t i and
the serialization order
of flexible transaction
decision to commit
a local site
compensating subtransaction ct
flexible and local
execute its serialization
makes a global
flexible transactions in
and its compensating
serialization point of
global decision to
the sseg algorithm
of a subtransaction
transaction t j
heterogeneous distributed database
consistent database state
edge insertion rule
a oe rpo
t m ip
concurrency control criterion
serialization point until
site ls p
flexible transactions t
in the sseg
a global decision
at a local
globally serializable schedules
the local database
of flexible and
and t jp
oe rpo of
in bank b
for flexible transactions
oe rpos of
a global schedule
subtransactions in the
subtransactions which are
executed its serialization
their compensating subtransactions
flexible transaction may
in the committed
an f serializable
t 1p s
that the sseg
t 0 oe
t ip and
point until all
1p s t
for avoiding cascading
s t 2p
operation submission rule
a compensating subtransaction
of t oe
at ls p
avoids cascading aborts
ip and t
t 1 and
transactions in the
transaction t i
subtransactions of a
global transactions in
conflict equivalent to
each global transaction
at local sites
is conflict equivalent
the global transaction
on the execution
t j can
t i such
0 oe 0
the commitment of
for t i
written by t
schedule s is
transaction t 1
of data items
t ip is
j can execute
set of subtransactions
checking account a
compensation or retrial
two flexible transactions
subtransaction t j
its compensating transaction
global database consistency
condition for avoiding
a committed flexible
one subtransaction at
ct i in
serialize before t
its compensating subtransaction
global transaction manager
in global schedule
global data items
among the subtransactions
f serializable schedules
t ip in
committed flexible transaction
of f serializable
of globally serializable
avoid cascading aborts
subtransaction of flexible
well formed flexible
is serialized between
is compensation interference
must serialize before
to avoid cascading
in a hddbs
serialized between a
no subtransaction of
flexible transaction model
t ip must
that a flexible
of t ip
ip in the
for flexible transaction
alternate oe rpo
for the execution
t i t
of t j
and t j
execution of a
concurrency control protocol
a concurrency control
t i is
such that t
if t i
an edge t
of the serialization
execution of global
the local site
is globally serializable
local database systems
can execute its
and flexible transactions
global transaction g
prefix of t
submitted to the
i and t
nodes and edges
set of data
the concurrency control
at the local
transactions t i
before t j
each local site
i t j
the effects of
are submitted to
of a global
criterion for the
t i of
the data items
serialization order of
partial order t
serialized between t
control criterion for
sseg algorithm maintains
is not compensatable
s is globally
t 2 at
enforcing t 1p
entire flexible transaction
serializability on the
bounded serialization point
each compensatable subtransaction
committed oe rpos
that ensures f
switching set of
effect of t
the node t
to commit executes
commit the oe

corpus/krapavin2000-test/628151.txt
raid
sid
slice
disk
video
disks
dispersal
s1
sds
fragments
layout
layouts
streams
s4
slices
s2
stream
parity
s3
striping
designs
seek
service
failure
cohort
reading
s5
bibd
movie
fi
buffer
designates
server
stripe
reconstruction
f1
fragment
degraded
p1
fault
mttdl
disk3
disk0
disk4
disk1
disk2
s6
cycle
redundancy
organization
circa
configuration
s8
rotational
wmin
declustering
s7
consumption
servers
kb
discontiguity
surviving
mpeg
organizations
kilobytes
storage
segmented
configurations
theta
movies
juxtaposed
mbits
sx
starvation
capacity
array
bytes
videos
contiguous
calculations
robin
actuator
latencies
jbod
ozden
inoperative
cylinders
latency
redundant
contiguously
arrays
accesses
burkhard
declustered
2fi
failed
clients
shaded
resides
rebuild
reliability
drives
compression
workload
utilizes
mode
cylinder
transfer
ms
rate
p6
p2
nine
failures
ka
tolerant
read
replenishment
berson
discontinuites
stored
f2
archive
diminish
ensemble
grain
track
1000
serviced
ave
buffering
contiguity
staggered
vbr
muntz
5j
balancing
costs
multimedia
offsets
utilize
mb
round
load
cohorts
dmax
f6
alvarez
percent
residing
sec
tolerance
tertiary
designate
display
overflow
gb
groups
technologies
accommodate
cristian
manufacturers
seeks
sized
workloads
cbr
materials
shenoy
impact
continuity
vastly
84
ten
eleven
width
list
utilized
concurrent
overlay
gracefully
evenly
pi
exclusive
4g
delivery
cycles
accommodated
slots
inevitable
sweep
700
timely
streaming
poor
portions
composing
migration
slot
049974
wichita
raid 5
service list
raid 3
reading cycle
the raid
data layout
per stream
dispersal factor
video server
s1 s1
the sid
list s3
sid data
fault free
and raid
size fi
data layouts
data fragments
disk failure
cost optimal
a slice
disk array
size per
for raid
sid design
video servers
data organization
the disk
under failure
information dispersal
without failure
the dispersal
the slice
slice is
cycle t
storage capacity
theta theta
segmented information
f1 1
sid designs
sds based
or sid
the buffer
single disk
disk 3
the reconstruction
this configuration
buffer size
with failure
disk2 service
disk1 service
movie x
based sid
failed disk
list s1
disk3 service
disk0 service
list s7
check data
2 disk3
ffl raid
s4 4
disk4 service
9 s4
degraded mode
for video
of disks
of streams
the video
video stream
disk arrays
consumption rate
designates the
sid q
f1 f1
q sid
dispersal sid
1 disk2
failure sid
streams per
5 sid
data fragment
of movie
of raid
sid based
each stream
slice size
slices are
parity groups
and sid
redundancy ratio
reading cycles
sid and
slice of
5 data
the slices
each slice
seek time
the check
redundant data
of slice
s1 1
a raid
data organizations
seek latency
s2 s1
video data
the disks
5 or
per disk
s1 s2
the reading
5 s1
the mttdl
slice y
3 sds
per reading
parity disk
surviving disks
s2 10
fi r
s2 11
sid the
video consumption
4 mbits
in degraded
configuration costs
stream raid
in raid
disk failures
s6 12
s1 0
optimal designs
sid without
list s2
stripe width
grain striping
3 disk4
check fragments
slice s
12 s1
sid with
video slice
system configuration
3 organization
the seek
slice the
buffer space
a disk
bit rate
capacity for
designs for
each disk
is read
the parity
fragments each
k bytes
mbits sec
round robin
disks in
row number
s2 1
of size
the redundancy
a video
the fragments
s1 2
rotational latencies
stored contiguously
s z
streams for
within the
5 s8
3 s3
shaded slice
contiguous data
4 s8
s5 6
s1 26
buffer starvation
sid ffl
s7 4
case seek
s7 3
s3 10
tolerant video
wmin ffl
11 s5
single failure
s3 7
five disks
concurrent streams
separated difference
12 streams
each cohort
14 s5
s3 9
s1 p1
continuity condition
s2 7
service list s3
the raid 5
buffer size per
size per stream
the raid 3
reading cycle t
and raid 5
raid 5 and
raid 5 or
the dispersal factor
theta theta theta
segmented information dispersal
5 or sid
service list s7
2 disk3 service
in this configuration
disk0 service list
s1 s1 s2
9 s4 4
raid 3 and
disk4 service list
disk1 service list
sds based sid
the reading cycle
disk2 service list
for raid 3
disk3 service list
service list s1
of size fi
raid 5 data
number of streams
a single disk
of movie x
slice is read
1 disk2 service
s2 s1 s1
5 and sid
sid and raid
storage capacity for
raid 3 organization
information dispersal sid
cycle t 1
single disk failure
ffl raid 5
the buffer space
5 data layout
4 mbits sec
s1 s2 s1
denotes the worst
sid with failure
f1 f1 1
a raid 5
service list s2
data layout the
slices are stored
12 s1 2
sid without failure
cost optimal designs
sid data layouts
per stream raid
slice y of
3 and raid
raid 3 data
slice s z
raid 5 with
within the raid
the sid data
3 disk4 service
s1 s1 s1
s1 2 disk3
parity groups of
that of raid
5 with failure
per reading cycle
for each stream
s6 12 s1
stream raid 5
y of movie
the disk array
run time performance
the data layout
of the disk
and rotational latencies
number of disks
for video data
each point is
groups of size
s3 9 s4
sid ffl raid
a slice the
12 s2 2
streams for a
s3 7 s4
5 s8 15
dispersal factor is
14 reading cycle
the slice size
list s1 0
data layout and
5 sid ffl
11 s5 6
slightly larger example
s4 3 disk4
list s2 7
failure theta sid
the continuity condition
25 disk1 service
fault free access
s8 14 reading
s4 5 s8
s7 4 s3
a single video
6 s1 26
10 s5 5
s5 9 s4
its storage capacity
fault free performance
14 s5 9
the redundancy ratio
higher dispersal factor
s3 14 s5
failure sid q
the shaded slice
s4 12 s2
raid 5 sid
s5 5 s1
t 1 figure
video server designs
consecutive slices are
one half the
and check data
a reading cycle
t disk0 service
s7 3 s3
the scheme utilizes
this configuration the
fault tolerant video
fault free operation
11 3 sds
s1 1 s2
worst case seek
contiguous data layout
fi r c
s1 0 s2
list s1 1
slice of data
11 s2 1
single video stream
s3 13 s5
service up to
list s7 3
track to track
list s3 10
list s7 4
s3 10 s4
s5 8 s4
s2 11 s5
n q sid
or sid without
is read for
s5 6 s1
s4 11 s2
of raid 3
single disk the
5 s1 25
percent of its
3 raid 5
s1 25 disk1
sid data layout
free access for
3 s3 13
cycle t disk0
list s3 6
sid data organization
f1 1 1
capacity for video
disk array declustering
8 s4 3
to constant bit
typical fault free
s2 7 s6
raid 3 or
10 s4 5
s2 1 disk2
sid designs for
list s3 9
13 s5 8
4 s8 14
s4 4 s8
1 s2 11
list s3 7
failure wmin ffl
4 s3 14
0 s2 10
s3 6 s4
7 s6 12
streams per disk
7 s4 12
s2 10 s5
6 s4 11

corpus/krapavin2000-test/628163.txt
client
skyscraper
bandwidth
server
multicast
hmsm
stream
patching
file
sslre
delivery
clients
request
tapping
streams
streaming
play
receive
segment
progression
rate
requests
service
arrivals
merging
video
transmission
demand
optimized
immediate
eafv99
segments
poisson
grace
derek
deliver
scheduled
arrival
broadcast
eave98
eavz99
buffer
logarithmically
listen
vernon
peer
gato99
eavz00
merges
eager
patch
rates
interactive
media
multimedia
multicasts
merge
hush97
sgrt99
calo97
hucs98
duration
transmissions
cluster
broadcasts
merged
mahanti
files
mary
broadcasting
unlimited
anirban
delivers
schedules
cable
scalable
agwy96a
cahv99
hierarchical
channels
earliest
partitioned
listens
listening
rewind
arrives
dyn
bursty
twice
sky
satellite
rearrangements
units
reasonably
piggybacking
policy
initiated
channel
dynamic
fold
receiving
policies
broadband
servers
pause
talo
juts98
891
xiaobo
golm95
yanping
lalg98
stealing
jussara
haonan
agwy96b
srgio
viim96
progressions
stukel
derives
caching
arrive
competitive
savings
anastasiadis
shudong
rocha
zongpeng
maia
cunha
stergios
nearly
controlled
ahead
requested
periods
transmitted
delivered
marcus
campos
nahrstedt
metropolitan
vod
sundaram
segmented
heterogeneous
storage
moderate
waiting
bestavros
azer
klara
cui
delivering
static
audio
ton
cheng
almeida
jin
tight
ca
period
threshold
portion
batching
hilton
progress
impact
served
interactivity
zhong
unicast
marcelo
buffering
disk
live
reviews
skip
fragmented
latest
achievable
principal
arrived
popular
13th
overload
minimally
appendix
family
62
considers
labelled
ni
networking
yi
bandwidths
altering
singapore
server bandwidth
required server
client request
play rate
dynamic skyscraper
receive bandwidth
client receive
bandwidth for
file play
the file
stream tapping
request rate
immediate service
multicast stream
delivery techniques
delivery technique
optimized stream
stream merging
tapping patching
on demand
service to
the client
the required
immediate real
client buffer
hierarchical multicast
request arrival
client requests
the play
bandwidth equal
on required
video on
buffer space
partitioned dynamic
provide immediate
provides immediate
segment size
each client
skyscraper technique
transmission cluster
bandwidth is
file i
request rates
progression 1
grace patching
skyscraper delivery
of client
to clients
lower bound
the hmsm
new practical
l eager
tapping grace
sslre 2
the sslre
derek l
sslre n
clients have
controlled multicast
time service
poisson arrivals
k vernon
size progression
for hmsm
practical delivery
full file
eager mary
mary k
a client
the server
twice the
the stream
to deliver
for client
to client
in units
the progression
the segment
to twice
multicast delivery
segment 1
client a
the optimized
hmsm 2
patching controlled
high client
client b
skyscraper system
broadcast techniques
for sslre
scalable on
request arrivals
optimized dynamic
skyscraper method
limited client
if client
have receive
interactive functions
listen to
logarithmically with
deliver the
for clients
delivery of
for optimized
real time
8 8
techniques that
given client
clients that
units of
bound on
rate i
minimum required
static broadcast
for required
hmsm technique
for delivery
patch streams
skyscraper systems
merging hmsm
multicast technique
original dynamic
stream and
bandwidth that
bandwidth used
requests the
that provides
average server
progress for
when client
for poisson
same file
rate for
and client
fast forward
with client
merge with
rate the
equal to
technique that
clients can
client is
the lower
optimized patching
sky 1
dyn sky
in required
any technique
bandwidth savings
greater server
patching and
in eavz00
arrive during
4 8
duration of
file the
for video
bandwidth as
streams that
for file
the partitioned
n r
of file
satellite or
anirban mahanti
new stream
clients c
providing immediate
total server
time delivery
or cable
request arrives
two times
client can
stream for
competitive with
rate and
4 4
when clients
has required
new client
bandwidth if
clients a
media streaming
requests for
equation 5
deliver a
times the
t x
any client
transmitted at
the interactive
network bandwidth
peer to
bandwidth to
to peer
derived in
constant factor
of multicast
scheduled to
required server bandwidth
server bandwidth for
the required server
client receive bandwidth
the file play
file play rate
client request rate
optimized stream tapping
stream tapping patching
on required server
immediate service to
immediate real time
client buffer space
multicast stream merging
hierarchical multicast stream
the client request
the play rate
bandwidth equal to
of the file
video on demand
bound on required
receive bandwidth equal
of client request
partitioned dynamic skyscraper
client request rates
server bandwidth is
that provides immediate
1 2 2
2 4 4
to each client
provide immediate service
dynamic skyscraper technique
client request arrival
4 4 8
dynamic skyscraper delivery
service to client
technique that provides
real time service
stream tapping grace
tapping grace patching
to client requests
4 8 8
derek l eager
times the file
the lower bound
2 2 4
1 1 2
at the file
service to clients
lower bound on
eager mary k
twice the file
progression 1 1
l eager mary
time service to
new practical delivery
service to each
sslre n r
segment size progression
the dynamic skyscraper
mary k vernon
in units of
equal to twice
to twice the
units of the
of the client
scalable on demand
play rate the
minimum required server
server bandwidth that
optimized dynamic skyscraper
sslre 2 1
hmsm 2 1
each client request
high client request
dynamic skyscraper system
have receive bandwidth
provides immediate real
patching controlled multicast
provides immediate service
server bandwidth as
request rate for
bandwidth for the
a given client
for the file
the file the
for file i
the server bandwidth
dynamic skyscraper method
average server bandwidth
the optimized stream
static broadcast techniques
bandwidth for hmsm
if client receive
receive bandwidth is
to provide immediate
the full file
original dynamic skyscraper
play rate i
stream merging hmsm
used to deliver
twice the play
two times the
server bandwidth to
for required server
the original dynamic
delivery techniques that
range of client
client request arrivals
delivery technique that
to deliver the
on the required
the average server
for video on
the same file
k and w
rate i e
rate for any
first two segments
for any technique
tapping patching controlled
the hmsm technique
real time delivery
the optimized dynamic
controlled multicast technique
bandwidth for delivery
bandwidth for any
server bandwidth used
satellite or cable
clients c and
greater server bandwidth
function of client
for poisson arrivals
sky 1 1
client request arrives
tapping patching and
techniques that provide
given client request
total server bandwidth
any technique that
clients have receive
limited client buffer
that provide immediate
in required server
for client receive
for optimized stream
has required server
the progression 1
play rate and
request arrival rate
dyn sky 1
the partitioned dynamic
when clients have
the sslre n
a new practical
for on demand
that the required
derived in section
bandwidth used to
measured in units
the minimum required
in equation 5
request rates and
of the interactive
peer to peer
as a function
the file that
listen to the
to the stream
new family of
simple to implement
duration of the
a function of
c and d
progress for clients
the required client
client is given
that for client
interactive client requests
and progress for
skyscraper delivery technique
bandwidth that is
that arrive during
hmsm delivery technique
the segment sizes
client who requests
on demand systems
lower bound derived
increases logarithmically with
for delivery of
rearrangements of scheduled
optimal rearrangements of
there is potential
on demand streaming
request rate n
the transmission cluster
be scheduled to
provide immediate real
server bandwidth if
poisson arrivals and

corpus/krapavin2000-test/628166.txt
datalog
stratified
xy
stable
fixpoint
iterated
stratification
diffchoice
stage
cliques
clique
ldl
st
atom
red
nondeterministic
8p
predicate
ord
atoms
ad
deductive
negation
sv
semantics
nonmonotonic
query
temporal
1s
template
sg
recursive
ut
programs
old
ar
translation
sp
exit
predicates
primed
databases
nondeterminism
dependency
aggregates
program
declarative
extensional
queries
topological
sales
stages
rules
8n
interpretation
reasoning
argument
expressiveness
tuples
thorough
forgetful
rule
datacube
subclique
aculty
8chosen
suffices
relational
coincidence
induction
translated
nondeterministically
faculty
syntactic
modularly
miller
aggregation
logic
fire
eval
semistructured
rels
disciplined
reconstructed
repeat
fb
rg
arguments
determinism
multiplicity
translate
tq
lifschitz
fd
sketch
inhibits
forget
gelfond
gray
optimizations
repertoire
db
deterministic
database
se
safe
sort
progression
magic
smith
iterative
aggregating
8i
symbol
useless
traversals
amenable
els
termination
language
abbreviate
brown
date
deduction
monotonic
delete
concrete
fragment
additions
hypothesis
perfect
justifies
literal
track
delta
modulo
aggregate
head
mining
gathering
induced
obey
init
relations
outcomes
copying
ordering
mechanisms
iff
department
unrestricted
rondogiannis
instanced
gergatsoulis
8exit
subcliques
minfi
turini
deduceable
nomikos
poral
inconveniences
inexpressible
1246
plified
stratifiable
giannotti
8diffchoice
undisciplined
fosca
expressing
saturation
deterministically
literals
approximating
admits
hierarchy
deduced
locally
sketched
tem
interpretations
constructs
approximable
manco
clarifying
seminaive
1232
sale
eig
i0
sql3
capitalized
operational
material
tailored
scott
answering
compromise
p2
stable model
stage argument
st ad
stable models
the stage
so p
iterated stable
of datalog
an xy
xy programs
the iterated
datalog programs
i i
sum r
8p defined
sg p
ord r
translation template
iterated fixpoint
q red
xy program
the stable
choice construct
interpretation i
datalog program
datalog is
stage i
xy stratification
model procedure
deductive databases
in q
q i
p i
program p
an iterated
sv p
clique q
a stable
stratified programs
topological sort
old all
chosen 0
old old
model semantics
r x
of xy
stable version
clique so
recursive cliques
stratified negation
fixpoint procedure
defined in
the program
of choice
models of
an interpretation
each stage
of sv
major st
temporal argument
diffchoice r
stage arguments
st area
ad major
xy stratified
ad st
ad area
of relation
for datalog
semantics for
h p
the query
locally stratified
template 3
the clique
in deductive
the predicates
of p
the atom
model of
in datalog
relation all
with choice
example 7
atom p
perfect model
semantics of
all 0
i x
temporal reasoning
of stable
chosen r
stratified and
last p
3 old
r root
choice atom
dependency relation
red i
n red
f smith
temporal arguments
stage only
choice safe
template 1
proposed optimizations
stratified program
sp i
forgetful fixpoint
predicate symbol
relation p
the tuples
the translation
program then
optimization techniques
the temporal
the dependency
reasoning by
nonmonotonic reasoning
copy rule
syntactic restriction
of sg
ut the
r defined
each clique
assigned using
0 all
a rule
by means
the choice
suffices to
of stratified
a datalog
the ldl
datalog as
exit rules
primed version
t n
s q
a thorough
base relation
total sum
so i
stratification and
non deterministic
that i
rule r
the predicate
a stage
recursive predicates
the rules
iterative procedure
possibly infinite
and nondeterministic
minimal model
means of
programs and
the language
previously computed
declarative semantics
of negation
the mentioned
i is
is translated
a choice
i 0
the expressiveness
the nondeterministic
4 j
negation in
basis of
s j
of r
choice is
the base
nondeterministic choice
non monotonic
relation r
se g
until 8p
ldl 2
stratification has
red the
programs augmented
gray miller
red red
its perfect
programs 22
choice fixpoint
realistic ldl
nondeterministically select
predicate stratified
2 chosen
iterated choice
cliques q
miller g
h sg
thorough account
aculty ad
stratified if
the stage argument
iterated stable model
defined in q
a stable model
8p defined in
stable models of
stable model of
an xy program
stable model procedure
h p i
the stable models
the choice construct
old old all
the iterated stable
i i i
model of p
stable model semantics
semantics of datalog
p i x
an interpretation i
datalog program p
clique so p
ad st ad
st ad st
old all 0
the stable version
all 0 all
reasoning by means
st ad major
of xy programs
major st area
translation template 3
of the iterated
sum r x
ad major st
in deductive databases
is a stable
to the purpose
s q i
at each stage
2 t n
a 2 t
of stable models
in q i
semantics of choice
the clique so
r x n
be an xy
of sg p
the stage arguments
program of example
ord r x
of sv p
the temporal argument
of relation p
the temporal arguments
the iterated fixpoint
stable version of
of choice is
use of choice
program then for
an iterated stable
multiplicity of stable
3 old old
t n red
4 j j
i proof sketch
stage argument in
r defined in
the proposed optimizations
of an xy
iterated fixpoint procedure
models of the
by means of
if a 2
of datalog programs
of negation in
the base relation
of the stage
definition of h
by definition of
then for each
induced by the
a topological sort
a datalog program
in example 7
is the language
a possibly infinite
minimal model of
the basis of
on the basis
the program of
a more concrete
for i 0
that i i
interpretation i is
repeat the process
of a stable
p i we
into a hierarchy
of the rules
the semantics of
i is a
the next stage
p be an
p in the
r x y
is assigned using
gray miller g
j 0 old
ad area chosen
local stable model
lemmas 1 2
until 8p defined
if the base
that fb h
example 7 is
of xy stratification
denotes the extension
0 st ad
an iterated fixpoint
area chosen st
f aculty ad
an atom p
we can i
such that fb
a stage argument
temporal reasoning by
each j 0
purpose of evaluating
total sum r
optimizations are for
of h p
readily checked that
aculty ad area
stage argument s
of so p
is an iterated
stratified datalog programs
by ord r
in o last
following translation template
the query delta
fragment p i
so p red
clique q i
by the tuples
datalog programs and
atoms which can
previous stage i
all 4 j
if 8p defined
interpretation i proof
the translation template
the dependency relation
if 3 old
the actual stage
n sum r
c chosen 0
area faculty ad
extension of relation
dependency relation of
iterated fixpoint semantics
fixpoint procedure which
8i 0 s
of datalog is
for datalog is
nonmonotonic and nondeterministic
i and analogously
h sg p
1 if 3
q red i
ldl programs i
the stratification induced
is the stage
is xy stratified
stratification induced by
red i i
stage argument and
a copy rule
a choice safe
the original relation
area f aculty
assigned using the
stage argument of
the minimal model
the interpretation i
with stage argument
efficient implementations and
approach of 13
closely related lemma
program fragment p
the given topological
having stage i
for each interpretation
repeat 8p defined
8chosen r defined
argument i in
each clique q
an xy stratified

corpus/krapavin2000-test/628189.txt
instantiations
instarray
curset
optimized
uninstantiated
minsup
association
confidence
optset
curloc
attributes
instantiation
numeric
confidences
conf
pruning
categorical
sup
intlist
optconfrange
dst
rectangle
mins
maxconf
france
minconf
maxs
instantiated
mining
intermediate
rules
w2
disjunctions
ny
attribute
maximized
supports
overlapping
naive
src
optconfpruneopt
finstarray
optsuprange
country
rectangles
telecom
prune
depth
w1
rule
overlap
extending
calls
provider
alg
constraint
permitted
weights
instar
starray
newlist
search
opt
city
periods
front
quantitative
promotion
cities
sensitivity
tuples
upto
corresponded
date
correlations
satisfying
marketing
dates
admissible
enumerate
invokes
pruned
enumerates
prior
sorted
discovery
decreasing
weight
regions
exhaustively
hui
atomic
intervals
arranging
items
exploring
sigkdd
permitting
track
exceed
stop
offering
customers
np
hye
1174
pruneopt
discounts
yesook
optconfnaive
optcon
instanti
tribute
ingful
confnaive
optsup
optconfcanprune
phil
enriching
frange
abstractmining
optconfpruneint
bari
00038
0038
narain
minweight
meric
500101000100000
sameep
kwei
kaya
candidates
deleted
intractable
eliminate
period
trends
incur
ray
korth
tiations
maxsup
gibbons
reda
instan
seasonal
gehani
minimumsupport
hank
wilfred
doo
andn
lack
extend
dealt
formulations
service
tribution
innovations
alhajj
promotions
unraveling
vitter
disproportionately
xiong
poorly
interval
subsection
discovering
park
effi
miroslav
shashi
stants
1185
hwan
kubat
yen
mehta
ya
silberschatz
rozsypal
nutshell
avi
yiping
taxonomies
antonin
unsatisfiable
mehmet
ffl
stored
ranges
toward
correlated
pearson
sizable
retail
lap
shekhar
optimized set
optimized confidence
association rules
the optimized
of instantiations
intermediate sets
optimized association
uninstantiated attributes
instantiations with
computing optimized
numeric attributes
confidence set
optimized support
minsup and
current optimized
in instarray
conf s
instantiations in
confidence sets
and conf
graph search
confidence of
instarray i
to france
least minsup
sup s
supports and
association rule
an instantiation
instantiation i
from ny
constraint 8
set s
for pruning
overlapping instantiations
of uninstantiated
extending curset
support of
depth first
for optimized
the instantiations
extend s
search space
the search
following constraint
to contain
curloc 1
curset s
high confidences
instantiations are
numeric attribute
mins maxs
optimized sets
extend curset
of instarray
conf optset
w instarray
the support
support and
and confidence
search algorithms
calls from
minconf and
and numeric
and sup
w 2
confidence and
for numeric
instantiations to
the confidence
minsup is
satisfying constraint
either categorical
rectangle for
s minsup
optset and
rules problem
categorical and
c satisfying
instantiations that
instantiations such
instantiations the
naive algorithm
s 1
minimum support
an optimized
the decreasing
s 2
support at
categorical attributes
each instantiation
if sup
and confidences
categorical or
to extend
search algorithm
rules are
non overlapping
is maximized
and support
rule u
i 2
pruning instantiations
uninstantiated conditions
contain uninstantiated
high supports
stop extending
instantiated rules
contain disjunctions
rule problem
confidence problem
telecom service
dst country
or numeric
procedure optconfrange
instantiations u
prior pruning
of curset
values for
the rectangle
the procedure
s that
attributes and
decreasing order
set with
the uninstantiated
sup r
that conf
for computing
attributes we
to result
given k
their weights
the rule
supports for
instantiations for
support set
of calls
first algorithm
permitted to
our search
s must
attributes can
for categorical
minimum confidence
support sets
our algorithms
all values
m dimensional
user specified
in 9
optimal instantiations
and uninstantiated
gamma w2
w2 s
and curloc
confidence rule
src city
uninstantiated attribute
every instantiation
atomic conditions
ny are
uninstantiated numeric
dst france
with instantiations
of supports
s rectangle
alg for
admissible regions
conf r
instantiated conditions
ny to
in intlist
instarray and
rule date
rules contain
france in
of optset
minsup values
intermediate set
single optimal
sup optset
m uninstantiated
optset is
instantiation in
confidences are
opt w2
next instantiation
instantiations however
uses intermediate
mining optimized
of minsup
over uninstantiated
low supports
u i
service provider
are permitted
can stop
rules to
the association
the optimized set
optimized confidence set
optimized association rules
the optimized confidence
the current optimized
number of instantiations
the optimized association
current optimized set
association rules are
at least minsup
optimized confidence sets
for computing optimized
optimized association rule
and conf s
minsup and conf
used to extend
the confidence of
the search space
in the decreasing
the decreasing order
the following constraint
to extend s
set of instantiations
number of uninstantiated
graph search algorithm
of uninstantiated attributes
and numeric attributes
w instarray i
computing optimized sets
for numeric attributes
calls from ny
support at least
for the optimized
the graph search
a set s
the depth first
instantiations such that
categorical and numeric
instantiations in instarray
of computing optimized
instantiations in s
an optimized set
permitted to contain
to extend curset
for optimized confidence
the rectangle for
least minsup and
association rules problem
minconf and sup
non overlapping instantiations
if sup s
either categorical or
be either categorical
computing optimized confidence
c satisfying constraint
satisfying constraint 8
depth first algorithm
the support of
association rules to
decreasing order of
of their weights
our search algorithms
supports and confidences
in the optimized
minimum support and
found in 9
association rules for
support and confidence
conditions of the
instarray i l
sup s minsup
uninstantiated attributes and
in m dimensional
stop extending curset
for s that
attribute a i
of intermediate sets
optimized confidence problem
given k and
categorical or numeric
s minsup and
optimized support set
with high confidences
association rule problem
extend s 2
of curset s
the optimized support
graph search algorithms
of c satisfying
to contain disjunctions
the intermediate sets
telecom service provider
can stop extending
rules are permitted
instantiation i i
values for s
instantiations with higher
for all values
of the optimized
the naive algorithm
of w 2
all values of
to result in
order of their
m dimensional space
of calls from
confidence and support
are permitted to
problem given k
has the form
number of tuples
of our algorithms
a set with
values of c
attributes can be
the front of
problem of computing
we can stop
s 2 to
values of w
range of values
of values for
the form a
be at least
the association rule
intermediate sets for
support and minimum
and uninstantiated attributes
contain disjunctions over
mining optimized association
ways 1 association
a numeric attribute
sorted by confidence
from ny are
and conf i
2 association rules
instantiation of u
instantiations with high
of instantiations to
alg for optimized
optimized confidence rule
and support at
instantiations are sorted
of supports for
confidence of curset
over uninstantiated attributes
s that satisfy
the telecom service
the procedure optconfrange
range of supports
instantiations to be
attributes 2 association
uninstantiated conditions of
uninstantiated attributes 2
l gamma w2
list of intermediate
such that conf
uninstantiated attributes can
s must satisfy
in the period
allowed to contain
conf optset and
gamma w2 s
from ny to
rules to contain
a single optimal
i l gamma
rules are allowed
optimized support sets
2 to result
ny to france
s of instantiations
two intermediate sets
when computing optimized
of an instantiation
the next instantiation
in i 2
intermediate sets s
disjunctions over uninstantiated
and minimum confidence
r is maximized
front of instarray
an instantiation i
that of optset
optimized support and
attributes and uninstantiated
high supports and
rectangle for i
the domain of
the range of
algorithms for computing
lack of space
1 and u
the user specified
number of calls
algorithm that uses
least that of
to contain an
the data file
contain an arbitrary

corpus/krapavin2000-test/628191.txt
itemsets
representatives
items
clusters
clustering
transaction
cluster
item
clasd
rock
itemset
correlations
meta
associations
poisonous
edible
aggregate
categorical
localized
ci
ai
ri
association
seeds
merge
discovered
basket
affinity
d100k
mushrooms
startsize
neighbors
market
nearest
mining
representative
t20
i6
similarity
unmarried
segments
database
marketing
discovering
mushroom
men
partitional
craft
neighbor
agglomerative
adult
correlation
sample
segmentation
attributes
corresponded
indian
tended
updatecriterion
cactus
eskimos
samplesizes
32562
samplesize
mergecount
initsamplesize
weight
synthetic
picked
transactions
databases
partitions
merged
0025
considerable
delta
concatenation
dataset
repair
grad
males
female
customer
dimensionality
ff
women
customers
percentage
species
census
noise
potentially
threshold
nn
segment
precompute
kill
random
population
recognized
lowering
synthetically
educational
bought
attribute
likelihood
lists
meaningless
finding
asymmetry
groups
grouping
sup
outliers
constituent
clustered
american
hs
links
assignment
scalability
correlated
assigning
helps
iteration
partitioning
discover
reported
option
weights
partition
expose
empirical
experiment
people
report
merging
spatial
parition
2155
wtm
gills
extraodinarily
doctorate
cutomers
apparel
jijg
atleast
currentsize
husbands
38626
56861
recomputations
eskimo
thereare
professions
disproportionate
farming
sandwiches
maintainance
professorships
orrelation
educated
whites
amer
respository
28983
5100030005000number
thr
odor
8124
clustersize
specialty
agglomerates
alaska
insight
running
correspondingly
dynamical
spend
notations
samples
closest
transformed
30k
male
indiscriminate
caps
jmj
tendencies
minfg
affinities
1123
spondingly
keke
medoid
optics
females
baskets
ran
meta transaction
2 item
ai s
item sets
ci s
of items
cluster representatives
of transactions
data set
ri s
2 itemsets
random sample
aggregate data
categorical data
two transactions
the transactions
clusters k
transaction m
cluster representative
output clusters
our clustering
the support
of clusters
a transaction
the aggregate
the data
clustering algorithm
basket data
potentially large
market basket
the clustering
association rules
of representatives
large itemsets
a meta
k clusters
running time
of cluster
the items
support relative
meta transactions
localized correlations
partition itemsets
itemset i
neighbor lists
itemsets ai
each merge
representatives m
data itemsets
localized associations
target marketing
items in
transactions is
large databases
associations in
be discovered
nearest neighbor
of 2
items i
the affinity
i6 d100k
each representative
with ai
support level
clustering method
transaction is
support of
clusters in
the similarity
maximal potentially
t20 i6
large itemset
k groups
the random
each item
discovered by
segments of
of links
m 0
item correlations
aggregate analysis
nn m
aggregate itemsets
log ff
itemsets ci
adult data
transaction was
by clasd
the mushroom
clustering categorical
common neighbors
clusters edible
representative m
overall dimensionality
craft repair
the clasd
the database
each cluster
entire database
threshold 0
o n
cluster c
clustering methods
for clustering
transactions in
links between
pass over
transaction in
s ci
among items
s aggregate
data which
two clusters
entire data
neighbors of
each iteration
assigned to
the partitions
empirical results
to cluster
the item
each itemset
such correlations
transaction data
data points
into k
nearest neighbors
transactions to
synthetic data
the weight
correlations in
of seeds
corresponded to
least s
the localized
categorical attributes
random partition
tended to
other clusters
significant percentage
in market
itemsets the
items a
item i
shall denote
transactions which
the entire
percentage of
helps us
clusters c
delta q
the size
relative to
requires o
large spatial
itemsets in
merge operation
clusters which
item a
similarity between
which cannot
such methods
of meta
spatial databases
likelihood of
the cluster
items is
the nearest
of startsize
find associations
aggregate support
the adult
0 0025
localized segments
rock on
the edible
of mushrooms
and aggregate
time finding
full database
sets discovered
best merge
clustered itemsets
distance computations
list becomes
american indian
final pass
resulting meta
final partitioning
startsize seeds
rock algorithm
transactions assigned
representatives which
seconds total
itemset to
d100k set
educational level
finding localized
hs grad
edible poisonous
2 item sets
of 2 item
number of 2
a meta transaction
the random sample
meta transaction m
number of clusters
market basket data
of clusters k
number of representatives
pair of items
of cluster representatives
of the data
the aggregate data
of links between
segments of the
set of items
number of links
our clustering method
support relative to
meta transaction is
ai s 0
nearest neighbor lists
data itemsets ai
with ai s
potentially large itemset
itemsets ai s
aggregate data itemsets
the number of
number of transactions
very large databases
potentially large itemsets
pairs of items
t20 i6 d100k
maximal potentially large
of the random
in each iteration
used in order
of the transactions
the data which
the clustering algorithm
entire data set
of common neighbors
two transactions is
overall dimensionality of
into a transaction
cluster representatives m
clustering categorical data
transaction m 0
set of cluster
s ci s
itemsets ci s
ai s ci
each itemset i
relative to at
the cluster representatives
the overall dimensionality
cluster representative m
the entire database
pass over the
data points in
in order to
number of items
the entire data
this data set
the size of
nearest neighbors of
into k groups
between two transactions
neighbors of each
number of common
the support of
and m 0
in the data
least one of
at least s
a transaction in
be discovered by
with each item
of items is
data set was
clustering algorithm for
random sample is
item i in
cannot be found
in market basket
shall denote the
m and m
size of the
which cannot be
a significant percentage
for each cluster
significant percentage of
large spatial databases
in large spatial
similarity between a
of the items
over the data
the similarity between
for very large
a data set
to at least
is denoted by
order to measure
we shall denote
the likelihood of
on this data
the first experiment
the initial set
at least one
of the population
segment of the
the data set
initial set of
transactions in the
mining association rules
partition itemsets ri
the mushroom data
resulting meta transaction
least s we
running time scalability
representatives m clusters
finding associations in
transactions is defined
clusters edible poisonous
i6 d100k dataset
not in family
likelihood of having
item a v
merge operation is
item sets that
set of seeds
representatives in each
itemsets the set
that ci s
associations in market
item sets aggregate
the original labels
above ai s
meaningless 2 itemsets
finding cluster representatives
the aggregate behavior
the corresponding item
from our clustering
and aggregate itemsets
scalability number of
the best merge
ff n k
clustered itemsets and
not present to
of each representative
2 itemsets with
denoted by ri
between clustered itemsets
n 2 delta
seconds total time
itemsets with enough
conclusions and summary
by our clustering
two meta transactions
adult data set
s aggregate data
rock on the
localized correlations in
lowering the support
comparison between clustered
m and nn
of startsize seeds
item sets reported
the t20 i6
largest k clusters
the generated clusters
list becomes empty
finding localized associations
sets aggregate data
ai s k
grouping of the
to find associations
useful for target
present to a
the aggregate support
with enough support
localized associations in
of localized correlations
cluster representatives figure
mushroom data set
item sets we
the rock algorithm
the 2 item
items i and
concept of meta
factor of ff
in seconds total
ai s figure
after each merge
transactions into k
a parameter specified
formally the similarity
transaction was chosen
by ri s

corpus/krapavin2000-test/628197.txt
sectors
cav
clv
qualifying
sector
disks
disk
zcav
proximal
tracks
cylinders
rotational
magnetic
zone
head
track
optical
seek
platter
settle
velocity
window
angular
transfer
proxw
spiral
zones
storage
command
technologies
ms
laser
concentric
revolution
cylinder
switch
comprehensive
zoned
devices
missed
analytical
delay
drive
lying
headswitch
platters
scanned
seeks
capacities
controller
capacity
beneath
retrieval
backward
cache
accesses
radial
device
qualifies
termed
beam
intersector
diversion
drives
tertiary
striping
successive
read
unifying
middle
rot
surface
format
velocities
target
admission
retrieved
distance
region
outer
innermost
recording
validated
multimedia
video
products
16x
champion
csb
forward
kb
paid
block
sy
rom
hp
workloads
modeled
pick
accessed
outermost
blocks
placement
optimizer
request
delays
rel
cs
access
gap
deltap
inforwards
jukeboxes
offness
diverted
plattered
x1000
csm
diverting
97560
recordable
c2240
diverts
technology
requests
brought
qualify
paying
indexed
reaching
const
surfaces
secondary
analytically
modeling
beginnings
hitachi
kz
retrieving
estimating
readable
average
spirals
resynchronization
7200
fundamental
contribute
departure
controllers
simulation
cd
queuing
inch
branched
traveled
gammaj
nc
offs
bypass
heads
rate
forwards
rates
mass
383
scanning
landing
rob
scan
jump
costs
underneath
query
reside
modern
speed
acceleration
characteristics
validation
positions
position
insights
switches
arm
servers
1st
reach
wait
mention
simulator
arrives
usenix
additionally
synchronization
hybrid
simulated
reads
verification
impacts
backwards
proximal window
qualifying sectors
head switch
the clv
zcav disk
rotational delay
seek cost
the disk
the zcav
optical disks
magnetic disks
of sectors
qualifying cylinders
the cav
clv cav
the proximal
angular velocity
window cost
the qualifying
command processing
switch cost
cav disk
the head
the rotational
the sectors
of qualifying
the seek
th zone
the track
cache missed
successive qualifying
settle cost
a sector
cost proxw
qualifying tracks
zone z
the laser
total average
cost for
clv disk
track capacity
qualifying sector
target track
disk technologies
comprehensive model
z i
transfer cost
transfer rate
read sector
zcav disks
sector is
cav and
sectors per
the settle
sectors n
the comprehensive
expected number
the command
the expected
track is
storage capacities
disk has
disks the
disks have
proxw in
and clv
missed qualifying
tracks of
seek operation
cav disks
forward access
n sectors
target sector
window access
sector time
per track
storage devices
is cost
at distance
disks and
cost is
ms number
been modeled
radial line
access region
cav clv
middle region
performance behavior
backward access
concentric tracks
linear velocity
sectors are
sectors scanned
clv disks
processing time
retrieval cost
distance j
disks with
a track
track in
disks are
of disk
the target
cost seek
the drive
spiral track
existing disk
disk products
a seek
seeks at
in zone
disk technology
rotational delays
zone the
admission controller
our comprehensive
beneath the
cav magnetic
the performance
of cylinders
the transfer
can pick
disk is
of tracks
sectors of
optical disk
clv optical
of cache
storage capacity
transfer rates
rotational speed
the tracks
delay rot
is lying
of zone
sector to
cav part
single spiral
a proximal
clv and
average rotational
laser beam
cylinders with
cost ms
sectors from
magnetic cav
first sector
z cost
sectors in
are termed
head is
tracks the
disk head
c i
two successive
linear phase
of magnetic
the sector
disk s
the middle
access cost
performance model
disk storage
randomly distributed
track of
possible future
head position
all disks
cylinders the
sector of
performance of
disk the
the read
backward accesses
average head
linear velocities
our unifying
n zcav
the zones
outer tracks
random workloads
average proximal
cost transfer
forward accesses
first qualifying
j qualifying
pick n
hybrid disk
window accesses
disk simulated
disk surface
cylinders is
be lying
device technologies
full revolution
the platter
multi spiral
line indexed
expected head
gap j
number of sectors
the proximal window
the zcav disk
proximal window cost
head switch cost
command processing time
the rotational delay
i th zone
the command processing
number of qualifying
of the sectors
the seek cost
the expected number
expected number of
of the qualifying
qualifying sectors n
the cav disk
the target track
cost proxw in
zone z i
read sector time
sectors per track
proximal window access
of qualifying cylinders
the qualifying sectors
missed qualifying sectors
cache missed qualifying
of cache missed
number of the
ms number of
the settle cost
for the clv
the clv disk
the clv cav
the target sector
the read sector
at distance j
number of cache
of the zcav
two successive qualifying
the track capacity
the middle region
the performance behavior
successive qualifying cylinders
number of cylinders
number of tracks
the transfer rate
ways we can
the performance of
to be retrieved
the disk head
performance behavior of
r p m
of successive qualifying
a proximal window
cav disk has
window cost is
the radial line
clv cav disk
cost ms number
magnetic disks and
the first sector
of the clv
our comprehensive model
cav magnetic disks
for the cav
seeks at distance
read a sector
storage capacities and
th zone the
for the zcav
the head switch
the comprehensive model
single spiral track
the laser beam
in zone z
and clv cav
of the disk
the disk s
we can pick
the angular velocity
constant or variable
the number of
of sectors per
proximal window size
radial line indexed
optical disks are
a single spiral
average rotational delay
j qualifying sectors
average seek cost
successive qualifying sectors
beneath the head
seek cost for
first qualifying sector
the qualifying tracks
track capacity of
pick n sectors
the seek operation
the first qualifying
sectors n zcav
rotational delay the
qualifying sector is
qualifying cylinders with
line indexed by
clv cav disks
access region is
sector to be
of qualifying tracks
of optical disks
of sectors scanned
forward access region
cost is cost
the forward access
for optical disks
of magnetic disks
the hybrid disk
of zone z
and the clv
not been modeled
average head switch
n sectors from
proximal window accesses
the rotational speed
can pick n
z cost proxw
average proximal window
n zcav disk
zcav disk simulated
of the head
the total average
the probability that
to read a
kb for the
track in the
the same track
rotational delay of
z i z
clv optical disks
the more the
on the disk
the transfer cost
of the radial
in number of
is c i
the query optimizer
z i is
of the hybrid
of z i
the head is
time to read
is the expected
cav and clv
a seek operation
clv and clv
pass beneath the
or variable angular
disks have the
an admission controller
number of head
sectors scanned during
expected retrieval cost
of a track
of concentric tracks
the clv part
magnetic cav and
of disk storage
if request is
zcav disk has
the backward access
scanned before reaching
rates and storage
gain insights into
cav and cav
first sector of
in this format
disks with respect
set of concentric
proxw in j
storage capacity sector
the n sectors
total average cost
the fundamental performance
and transfer rates
rotational delays and
mass storage systems
constant linear velocity
possible future technologies
sector of the
capacities and transfer
the head will
seek at distance
of disk devices
qualifying sectors are
track capacity in
constant angular velocity
window cost for
linear phase the
total average head
the qualifying sector

corpus/krapavin2000-test/628198.txt
kdb
join
leaf
tree
ffl
joins
dimensions
splitting
mbrs
bounding
similarity
rectangles
dimension
merge
sort
l1
epsilon
mbr
split
datasets
000
tv
subsequences
grid
indices
synthetic
neighboring
dimensional
spatial
regions
gaussian
distance
chunk
traversal
file
self
rectangle
children
node
gap
dataset
norms
dimen
index
images
metric
skewed
funds
overlap
sorted
l2
distribution101000100000
inadequacies
000s
hb
life
biased
screening
chunks
covered
cpu
buckets
internal
build
neighbors
stocks
ordering
mitigated
4096
screen
faster
multidimensional
directory
atomic
shortcomings
nodes
family
rationale
music
sequences
pages
reads
sliding
disk
emerging
laboratories
metrics
external
n1
n2
seeds
subtree
splits
neighbor
fit
enhancements
traverse
traversing
yes
overlaps
dramatically
varied
mining
sion
bucket
ith
broken
overlapping
narrowed
stitches
geomagnetic
root2
interbrain
unsplit
root1
fflc
10010000
distribution101000
distribution10010000
reinsert
fastmap
auroral
qbism
utilization
mapped
window
mit
d1
child
hyper
orderings
query
subsequence
uniform
databases
root
norm
gradually
medical
reinserted
screened
2ffl
sionality
grafted
joined
joining
01
execution
page
experimented
trees
mb
shaded
dip
narrows
deallocates
manhattan
prelude
scaleup
storage
around
ai
memory
ff
trie
d0
creases
l3
mf
seeded
suddenly
l4
rectangular
pointers
finding
algo
grow
solar
abstractmany
deterioration
daily
aries
qbic
ther
795
fanout
aix
bytes
sized
branches
interior
forced
converted
tance
sults
scales
lie
multimedia
image
experiment
ffl kdb
kdb tree
r tree
the ffl
similarity joins
the r
sort merge
high dimensional
leaf node
the join
dimensional points
ffl distance
leaf nodes
of dimensions
level sort
bounding regions
join x
similarity join
000 points
bounding rectangles
for splitting
neighboring leaf
self join
build time
dimensional similarity
tree family
within ffl
tree e
tv tree
merge r
performance gap
join test
2 level
of points
index structure
of ffl
dimensional space
distance metric
current indices
epsilon tree
traversal cost
local ordering
k d
tree for
multi dimensional
b tree
grid file
the epsilon
x tree
the bounding
execution time
tree was
k dimensions
split dimension
gap increasing
time sequences
splitting dimension
dimensions for
the tv
non self
for high
tree figure
join algorithm
e k
execution times
of neighboring
every dimension
the build
tree and
points in
d b
the grid
the sort
spatial similarity
self joins
space covered
extended bounding
tree gaussian
atomic subsequences
bounding rectangle
merge algorithm
for similarity
the split
tree we
on synthetic
points whose
the points
join time
global ordering
l1 norms
if leaf
increasing with
faster than
internal node
internal nodes
the dimensions
and l1
splitting in
the mbrs
than ffl
tree does
points this
nodes the
whose values
of finding
we split
merge join
tree is
gaussian distribution
ffl is
in memory
time epsilon
ff dimensions
neighbor leaf
sub images
external file
the kdb
ffl chunk
sort dimension
emerging data
hb tree
similar sub
epsilon 2
distance of
dimensional data
joins on
splitting a
skewed data
main memory
tree will
points and
dimensions are
times faster
the extended
real life
of bounding
finding all
first k
the index
all pairs
the space
o cost
splits that
similar time
rectangle of
nodes within
least ffl
join result
d tree
the performance
2 ffl
a leaf
covered by
every leaf
of neighbors
tree but
ffl and
tree 4
time dimension
by ffl
new index
joins we
i join
second dataset
node was
node becomes
data points
cost of
the datasets
synthetic data
each leaf
x i
l 2
the execution
two leaf
mbrs of
finding similar
join procedure
sorted on
pairs of
100 000
dimension are
cpu cost
for internal
mining applications
joins with
the node
node x
fit in
dimension 2
indices the
chunk of
minimum bounding
becomes full
synthetic and
points within
time for
the gaussian
ffl the
with current
ffl kdb tree
the ffl kdb
the r tree
number of dimensions
2 level sort
level sort merge
high dimensional points
within ffl distance
for the ffl
r tree e
e k d
tree e k
high dimensional similarity
sort merge r
dimensional similarity joins
neighboring leaf nodes
r tree family
merge r tree
for high dimensional
than the r
d b tree
the performance gap
k d b
ffl distance of
of neighboring leaf
the epsilon tree
join x i
kdb tree we
number of neighboring
number of points
the grid file
the sort merge
kdb tree for
b tree figure
gap increasing with
points whose values
performance gap increasing
the join test
the tv tree
the execution times
faster than the
the join algorithm
increasing with the
sort merge algorithm
the number of
for the r
with the number
of the ffl
r tree for
the split dimension
kdb tree and
used for splitting
of ffl kdb
similarity joins on
the bounding regions
for similarity joins
space covered by
the build time
the extended bounding
self join x
join time for
kdb tree is
the bounding rectangle
b tree gaussian
if leaf node
r tree and
a multi dimensional
whose values in
distance of each
dimensions are used
first k dimensions
the points in
tree does not
for the gaussian
multi dimensional space
time for the
the gaussian distribution
of the bounding
all pairs of
to the r
of high dimensional
problem of finding
times faster than
high dimensional data
number of neighbors
r tree the
i join x
chunk of the
bounding rectangle of
joins on high
epsilon 2 level
similar time sequences
for splitting in
2 and l1
of finding similar
splitting a node
time dimension 2
with current indices
r tree was
the space covered
kdb tree will
execution time epsilon
using the ffl
values of ffl
emerging data mining
for local ordering
kdb tree was
cost for internal
node becomes full
the x tree
time epsilon 2
execution time dimension
non self joins
the kdb tree
tree family of
100 000 points
bounding regions of
new index structure
dimensions for splitting
similarity joins we
leaf nodes within
4 to 28
r tree 4
nodes within ffl
x i join
the join time
r tree does
leaf node was
neighbor leaf nodes
gaussian distribution the
dimension 2 level
and real life
rectangle of each
performance on synthetic
tree and the
considered for the
pairs of points
a leaf node
the first k
i o cost
with the performance
execution times for
leaf node is
the leaf node
the join procedure
a r tree
k d tree
a sort merge
structure called the
for internal nodes
are within ffl
on high dimensional
fit in memory
the mbrs of
at least ffl
leaf nodes for
internal nodes the
3 dimensional space
performs the join
leaf node x
an internal node
in the r
of the dimensions
and a distance
on synthetic data
pairs of similar
in the split
and r tree
for the join
two leaf nodes
the second dataset
data mining applications
and performs the
leaf nodes and
value of ffl
sort merge join
tree and r
to 0 2
covered by the
points in a
for the l
that the r
for r tree
each leaf node
and the r
synthetic and real
every leaf node
leaf nodes the
as the length
the feature vector
of each other
from 4 to
the cost of
better than the
the algorithm then
point in a
points in each
1 l 2
on one of
l 2 and

corpus/krapavin2000-test/628213.txt
production
powder
negation
stratied
argumentation
gps
grounded
naf
failure
semantics
attacks
classical
pps
literal
atoms
atom
wash
washing
preferred
cond
denition
ps
tenure
sem
cl
actions
ict
stable
priorities
stratication
hyp
shops
hire
rules
priority
computations
rule
clothes
patient
achievable
assistant
mp
neighbor
nal
assert
sound
dierent
incomplete
defended
washed
hfnot
literals
arguments
coincide
defeasible
defend
hp
life
specication
logic
house
retract
borrow
borrowing
attacked
rst
founded
nd
prioritized
ann
satised
ground
cult
cardinality
eect
dened
nonmonotonic
declarative
strata
acceptable
acceptability
action
dene
shop
reasoning
doctor
hired
attack
logics
compiling
defeats
subcomputation
mary
acquire
resp
robot
defeated
applicable
imagine
away
nondeterminism
him
active
risky
cleang
bgi
prex
treatments
intuitive
fag
buying
acquiring
di
con
save
premises
agi
nondeterministic
ni
formalized
stratified
lives
fnot
terminologies
goals
compile
leader
intuition
foot
fbg
eorts
sequel
monotonic
leading
bottom
database
occurring
naive
disjunctive
ag
plausible
referring
advisor
hw
hypotheses
professors
revised
saving
head
course
nite
machine
c3
propositional
operator
you
io
cut
enjoy
treatment
understanding
minimality
meaning
team
nonempty
undesirable
artifact
world
person
polynomial
viewing
buy
prof
pg
deeper
worth
label
ancestor
professor
satisfying
empty
expressiveness
adopted
pm
renaming
opinion
faculties
ghter
fateful
peoples
frostbite
argumen
oering
attacksi
fneighbor
computationg
minimalg
bop
doctors
arar
as failure
negation as
production systems
production system
computation c
machine powder
classical production
general production
stratied gps
complete computation
stratied production
production rule
the grounded
p 0
cond r
a stratied
cl cond
production rules
argumentation systems
of actions
r l
course of
a gps
not l
a production
achievable from
a classical
a course
rule r
failure to
of atoms
with negation
possible computations
of argumentation
assumption not
not polynomial
gps p
ict free
hyp r
incomplete state
naf literal
the production
between rules
possible computation
stable semantics
of arguments
a computation
an argumentation
state s
con ict
complete computations
grounded preferred
nal c
stratied ps
of stratied
classical ps
logic programming
a state
in p
failure can
of p
l 0
a rule
c 0
of negation
hp i
stable set
preferred and
applicable in
no computation
hand wash
away negation
shops are
sound implementation
attacks c
compiling away
the neighbor
semantics for
semantics of
is achievable
classical negation
a sound
complete implementation
starting from
grounded semantics
partial computation
in house
not di
semantics coincide
real life
no machine
not machine
argumentation system
classical literal
empty computation
assert p
empty computations
gps s
powder in
incomplete states
using negation
output semantics
atoms of
l r
denition 5
0 r
nd a
c 2
base for
underlying assumptions
an incomplete
r a
that negation
life problems
neighbor is
the cardinality
to nd
cardinality of
active database
declarative semantics
system p
least solution
computation starting
set r
failure in
0 such
systems with
cult to
rule based
in logic
di cult
common sense
is clear
well founded
r 1
defended by
in production
argumentation based
not powder
borrow powder
a naf
possible course
gps and
assumptions hfnot
acquire machine
grounded well
hand washing
borrowing it
for stratied
no possible
is con
of production
and stable
no way
a base
the empty
clear that
of computations
example 3
current state
priorities between
a specication
systems where
the rule
that s
bottom up
is no
c 3
then hand
r 4
each rule
us rst
s 0
denition 3
from i
example 1
the semantics
c 1
the patient
be attacked
literal l
acceptability of
referring back
computations of
polynomial in
there exists
r r
neighbor in
to acquire
rules in
operator s
failure as
let us
s so
state where
for l
i i
of r
and negation
active databases
negation as failure
course of actions
as failure to
cl cond r
with negation as
stratied production systems
a course of
a stratied gps
production systems with
nd a course
a computation c
a production system
l 0 r
r l 0
is not polynomial
a classical production
as failure can
con ict free
computation c 0
failure to nd
p 0 such
number of atoms
not polynomial in
is achievable from
cardinality of r
computation c of
as failure in
classical production systems
the assumption not
production systems where
set r l
base for l
a base for
is no computation
there is no
set of arguments
failure can be
a state s
of p 0
r l r
achievable from i
an incomplete state
be a stratied
no computation c
of argumentation systems
computation c in
away negation as
sound implementation of
preferred and stable
is a sound
is not di
not di cult
the neighbor is
a possible computation
the set r
in logic programming
of atoms of
production rule if
as a specication
stable set of
the grounded semantics
not machine powder
is con ict
production system p
a complete computation
way to acquire
of stratied production
no machine powder
that negation as
using negation as
general production systems
classical production system
applicable in s
the production system
a general production
and complete implementation
complete computation c
a sound implementation
input output semantics
systems with negation
to nd a
in p 0
the cardinality of
is no way
example 1 1
0 such that
such that s
to see that
set of computations
production systems in
real life problems
computation starting from
of the equation
di cult to
in a state
cult to see
the current state
that the cardinality
r a i
a production rule
c of p
starting from s
it is clear
c 0 of
is applicable in
i in p
is clear that
a naf literal
programming with negation
0 is achievable
rule in p
of r l
and stable semantics
general production rules
is no possible
possible course of
class of stratied
grounded well founded
of negation as
assumption not machine
stratied gps s
applicable in a
an argumentation system
incomplete state i
c in c
production system the
then hand wash
a classical ps
of a gps
general production rule
machine powder in
powder in house
is no machine
grounded preferred and
to acquire machine
as failure as
underlying assumptions hfnot
borrowing it from
neighbor in then
a gps p
for l with
classical production rule
compiling away negation
in production systems
polynomial in the
such that l
example 3 3
c 0 2
a sound and
let us rst
j i is
back to example
and the neighbor
least solution of
and negation as
computation c 2
c p 0
implementation of p
the production rules
semantics of p
2 r l
exists a computation
state such that
priorities between rules
that if and
introduce the class
of a production
neighbor is in
l with respect
atoms of p
i is empty
sound and complete
if there is
p be a
in the head
of the production
for the action
in c p
from the neighbor
referring back to
the least solution
production rules in
0 of p
logic programming with
no way to
and c 3
to a state
it from the
that there is
of the world
rule based systems
from s 0
active database systems
respect to p
grounded preferred stable
as an argumentation
by applying standard
shops are open
no possible course
powder then hand

corpus/krapavin2000-test/628215.txt
nnf
mvds
mne96
mvd
oy87a
fds
oy89
aset
rk87
4nf
hobby
nested
1r
attributes
fd
matriculation
conflict
prof
descendent
bcnf
skiing
ancestor
acyclic
hiking
student
database
chair
1s
dependency
schemes
bfmy83
join
redundant
steve
seed
dept
violates
unmarked
redundancy
ru
equipment
tree
unnesting
tdc
yo92
lhs
pat
carter
normal
rm
xy
dance
ph
implied
t1s
1path
me98
pnf
kong
relational
ada
polya
dep
gamman
child
ordb
1fxy
rks88
ordbs
aef
me96
nontrivial
fk
2s
mai83
tableau
publication
forms
hong
toy
embedded
root
imply
jane
cde
rap
dependencies
keys
envelope
rn
transitive
relation
interestg
equipmentg
notationly
tabc
scheme
math
splits
dc
title
trees
turing
attribute
lemma
rb
generalizing
chase
node
flexibility
subtree
ag
flat
nonempty
ts
barker
hat
preserving
travel
wb
bottle
databases
ae
nesting
sm
multivalued
young
reducible
cs
notice
numerous
tru
oy87b
tss97
ly94
wordy
fag83
bk86
txz
costume
mmin
closed
decomposition
satisfies
subsection
pairwise
path
relations
fig
dp
article
shoe
dancing
squeeze
subcondition
ra
water
stating
contradiction
neighbors
intersection
caused
transferable
soccer
converses
xv
violations
free
zhuge
entered
sp
disjoint
edge
designers
atomic
adams
xz
neighbor
guides
vacuously
f3
wg
counterparts
induction
chess
gamma
lemmas
remove
marked
superior
generates
usa
4g
jsj
hai
tuples
shall
abbreviate
lee
tuple
of mvds
scheme tree
nested relation
nnf oy87a
nnf mne96
aset t
nnf oy89
and nnf
nnf rk87
oy89 and
conflict free
mvds and
of nnf
relation scheme
of attributes
relation schemes
oy87a nnf
and fds
in nnf
database scheme
in 4nf
mvd t
4nf with
an mvd
attributes let
that aset
r i
over u
a scheme
acyclic database
database schemes
of fds
normal forms
on aset
a nested
fds over
free sets
mvds over
scheme trees
u let
in j
redundant data
to m
the nested
mvd x
tree such
data values
fds in
ancestor v
join dependency
prof hobby
in mne96
mvds is
given set
join tree
t is
student interest
u be
attributes u
path t
nested relations
to d
normal form
hobby hobby
given fd
hobby equipment
to nnf
dept chair
tree t
algorithm 1
with respect
respect to
t u
matriculation student
mne96 with
descendent w
at step
let u
node n
free set
m 0
for nnf
nested normal
that nnf
fds that
oy87a with
the mvds
oy87a and
total unnesting
reducing redundant
redundancy caused
the given
scheme r
step 2
j 0
dependency preserving
scheme over
for t
rk87 are
extended conflict
in mvd
rk87 all
nested database
chair prof
unnesting of
gamman k
mvd in
node scheme
the normal
in t
fd in
intersection property
in ada
t be
e d
the root
of relation
condition 1
let t
fds are
path scheme
the fds
implied by
u if
be a
is conflict
let m
relation in
programming in
on u
the scheme
i 2s
ancestor n
violates condition
dep x
no given
fd t
satisfy nnf
generalizing 4nf
4nf decomposition
steve programming
4nf and
mne96 nnf
tr seed
cs turing
implies mvd
mne96 the
connected subtree
condition 2
embedded in
key of
hold for
a key
hong kong
r is
u gamma
d implies
d be
a conflict
an acyclic
is embedded
that hold
m be
by lemma
in bcnf
design flexibility
satisfies condition
scheme in
closed set
given database
notice that
is equivalent
of m
gamma xy
satisfies nnf
mne96 2
left reduced
1 rn
math polya
polya steve
v descendent
fundamental keys
mvds in
r seed
and bcnf
2 dep
jane skiing
in tdc
to 1r
article title
oy89 rk87
s carter
lhs m
publication location
turing jane
in oy89
1path t
single path
for nested
the join
set of mvds
a scheme tree
nnf oy89 and
and nnf rk87
oy89 and nnf
set of attributes
nnf oy87a nnf
of mvds and
mvds and fds
oy87a nnf oy89
respect to m
4nf with respect
in 4nf with
of attributes let
a nested relation
nested relation scheme
that aset t
nested relation schemes
such that aset
be a set
aset t u
of nnf oy87a
sets of mvds
the nested relation
redundant data values
is in 4nf
over u let
scheme tree t
respect to d
t is in
on aset t
is in nnf
scheme tree such
u be a
with respect to
in nnf mne96
tree such that
conflict free sets
free sets of
and fds over
the given set
the scheme tree
of nnf mne96
fds over u
of mvds over
let u be
a set of
be a scheme
given set of
step 2 2
nested relation in
of mvds is
u let t
conflict free set
in j 0
node n in
acyclic database schemes
t be a
the normal forms
set of fds
2 of nnf
attributes let m
mvds over u
of relation schemes
relation scheme in
of attributes u
2 2 1
condition 2 of
free set of
let t be
an mvd x
and nnf oy89
mne96 with respect
a relation scheme
nnf mne96 with
attributes let d
at step 2
a key of
hold for t
condition 1 of
relation in figure
acyclic database scheme
relation schemes in
nnf oy87a with
redundancy caused by
programming in ada
1 of nnf
reducing redundant data
mvd x y
matriculation student interest
t on aset
nnf oy87a and
hobby hobby equipment
t u if
a conflict free
2 2 2
embedded in a
holds for t
is conflict free
m be a
the given database
dept chair prof
aset t is
4 of nnf
extended conflict free
node scheme tree
oy87a with respect
in nnf oy87a
path t is
to d if
nnf rk87 are
total unnesting of
a database scheme
given database scheme
oy87a and nnf
gamman k 1
single path scheme
single node scheme
over a set
u if t
the intersection property
data values in
set of relation
that hold for
let m be
to m then
is a key
the fds in
is not conflict
not conflict free
closed set of
is equivalent to
d be a
is embedded in
mvds is not
relation scheme is
d is equivalent
implies mvd t
node in j
rk87 are all
3 of nnf
r i 2s
the join dependency
a join tree
also in 4nf
the total unnesting
no given fd
nnf mne96 nnf
z on u
nested normal forms
descendent w on
is no given
steve programming in
mvd t on
to nnf oy87a
implies an mvd
nnf rk87 all
for t with
d of mvds
w on aset
mne96 nnf oy87a
if r has
the nodes in
let d be
t with respect
is also in
the normal form
key of m
of t is
then t is
condition 3 of
of the normal
4nf and bcnf
mvds is conflict
satisfy nnf mne96
x u gamma
an acyclic database
condition 4 of
cs turing jane
ancestor v descendent
key x of
be r i
by an mvd
x z on
to d proof
s is closed
algorithm 1 generates
nnf mne96 the
has the intersection
fds that hold
database scheme over
v descendent w
math polya steve
nested database schemes
u gamma xy
path scheme tree
r 1 rn
generalizing 4nf and
nodes in j
r is acyclic

corpus/krapavin2000-test/628217.txt
ttl
adns
heterogeneity
web
prr2
hit
rr2
requests
server
client
overloaded
prr
drr2
load
request
rr
policies
utilization
dns
hits
sensitivity
servers
dispatching
heterogeneous
capacities
varttl
drr
capacity
scheduling
alarm
cgi
site
zipf
domains
node
adaptive
ip
dispatcher
mrl
dierent
clients
hostname
probabilistic
policy
hot
alarm2
dal
address
schemes
overloading
tier
cumulative
unevenly
alarms
coming
name
rates
skew
robin
strategies
collector
http
routing
6667
resolution
gateways
seconds
uneven
url
session
aected
rate
period
cooperative
reaching
monitor
assignment
specically
scheduler
page
req
homogeneous
prob
deterministic
workload
www
hetero
geneity
frequency
residual
gure
feedback
hidden
bin
mapping
rst
threshold
round
estimation
perturbation
nodes
tra
240
arrivals
authoritative
internet
conguration
modication
weight
aects
domain
mechanisms
rewalls
logle
alteon
ppr2
tilization
heaviest
systemmaxu
instant
selector
xed
caching
service
risks
overload
proximity
switch
arrival
default
levels
sites
cluster
popular
pure
percentage
busiest
disciplines
axis
sharing
accumulated
geographical
eectively
uniform
partition
skews
tracks
metrics
aect
visible
oered
eect
cached
originated
75
xes
loaded
condence
daemon
inadequate
dierence
dynamically
kwok
watson
rob
controls
distributions
assign
besides
scenarios
xing
geographically
jdj
imbalance
adopted
centralized
ve
utilized
robustness
normal
browsers
utilizations
org
addresses
versions
arriving
400
max
selects
bursts
schedulers
percentile
interval
60
excludes
fraction
probability
modications
65
proportional
the adns
ttl value
the ttl
web server
server system
adaptive ttl
ttl s
the web
constant ttl
heterogeneity level
hit rate
domain hit
name servers
ttl k
ttl schemes
distributed web
ttl values
prr2 ttl
ttl algorithms
drr2 ttl
node heterogeneity
address mapping
hit rates
web site
system heterogeneity
web node
web nodes
load weight
ttl 2
sensitivity to
maximum utilization
system maximum
the client
ip address
hidden load
variable ttl
address resolution
client requests
of hits
node capacities
address request
cumulative frequency
probabilistic routing
overloaded nodes
the hit
each domain
the node
s k
th domain
prob not
not overloaded
the requests
the heterogeneity
and ttl
adns control
and prr2
hits per
heterogeneity levels
adns scheduling
domain partition
hot domains
each address
server systems
the address
requests coming
coming from
minimum ttl
frequency system
relative capacity
mean ttl
ttl policies
tier domain
client distribution
system max
heterogeneous nodes
the load
the domain
the domains
two tier
page requests
a heterogeneous
global scheduling
node capacity
max utilization
rr2 based
ttl i
the prr2
k schemes
domain load
ttl period
web switch
the rr2
the adaptive
dns based
non cooperative
requests to
node selection
client request
the skew
name server
of overloaded
heterogeneous web
of ttl
pure zipf
each node
a dierent
control on
round robin
reaching the
zipf s
cooperative name
feedback alarm
address caching
dierent ttl
resolution request
to adns
cgi req
address requests
adns algorithm
page request
ttl interval
adns scheduler
algorithms heterogeneity
requests reaching
average ttl
estimation error
service time
scheduling algorithms
web page
load sharing
the performance
is overloaded
non uniform
the nodes
to address
the hidden
a web
unevenly distributed
ttl and
limited control
homogeneous web
the system
better than
the deterministic
the clients
to ttl
system capacity
avoid overloading
the probability
the sensitivity
heterogeneity is
client domain
request counter
of prr2
exponential mean
prr and
mapping requests
hit service
dispatching algorithms
www http
ttl base
adns of
load monitor
of rr2
i classes
connected domain
0 6667
conguration information
240 seconds
normal domains
prr2 alarm2
adns to
dynamic ttl
restricted rr2
web cluster
class threshold
probabilistic versions
client domains
overloaded level
cgi type
request assignment
load collector
heterogeneity of
node and
capacity of
scheduling policies
of domains
the probabilistic
of node
performance of
the hot
perform better
of client
level of
rr2 and
heterogeneity and
servers and
value for
value when
two classes
web server system
ttl s k
the web site
the ttl value
distributed web server
the web server
drr2 ttl s
the domain hit
domain hit rate
adaptive ttl schemes
the system maximum
heterogeneity level of
prr2 ttl k
system maximum utilization
of the web
the adaptive ttl
hidden load weight
to the adns
ttl value for
the ttl s
the constant ttl
adaptive ttl algorithms
ttl s 2
prob not overloaded
web server systems
the heterogeneity level
by the adns
the hit rate
the web nodes
server system is
the hidden load
requests coming from
domain hit rates
s k and
the minimum ttl
j th domain
the address mapping
tier domain partition
cumulative frequency system
system max utilization
two tier domain
constant ttl algorithms
frequency system max
number of hits
the name servers
hit rate of
load weight of
of the adns
heterogeneous web server
the node selection
name servers and
of overloaded nodes
a distributed web
minimum ttl value
to the web
the client request
reaching the web
cooperative name servers
of each domain
server system the
and ttl k
the web node
requests reaching the
non cooperative name
algorithms heterogeneity level
to system heterogeneity
the adns control
a dierent ttl
the feedback alarm
homogeneous web server
for each address
address resolution request
level of 20
sensitivity to system
each address request
web page requests
the variable ttl
a heterogeneous web
ttl value when
of the nodes
of non cooperative
number of overloaded
control on the
in a heterogeneous
of the domain
perform better than
coming from the
hit service time
of hits per
domain load collector
www http www
web site the
ttl value is
popular web sites
hits per second
the distributed web
rr2 based algorithms
not overloaded level
zipf s distribution
the prr2 ttl
among the domains
full control on
domain name server
ttl base is
constant ttl schemes
sensitivity to ttl
the average ttl
when the heterogeneity
probabilistic versions of
adns scheduling algorithms
system heterogeneity of
to a heterogeneous
the ttl period
ttl value to
adaptive ttl policies
the adns to
the node capacity
pure zipf s
each connected domain
k and ttl
for the ttl
levels of node
prr2 ttl 2
and prr2 ttl
of prr2 ttl
of node heterogeneity
the web switch
node is overloaded
dierent ttl value
http www http
ttl k schemes
with constant ttl
the requests coming
of the requests
ip address of
value for each
the ip address
of the ttl
from the j
the client requests
the performance of
the j th
better than the
sensitivity of the
from each domain
the estimation error
to avoid overloading
of the client
performance of the
at time t
by the name
axis is the
sensitivity to the
the sensitivity of
distribution of the
two classes of
of the system
s 2 and
each node and
rate of each
the requests reaching
inadequate to address
state and conguration
ttl 2 algorithms
the hot domains
ttl k algorithms
the domain load
ttl values that
and ttl 2
time t where
each node periodically
for homogeneous web
from hot domains
controls only a
the node heterogeneity
heterogeneity level is
address both node
of each web
mean ttl value
and conguration information
the class threshold
address request the
least loaded server
a pure zipf
node heterogeneity and
ttl s i
the adns scheduler
at the adns
address mapping requests
each address mapping
the address request
hits per page
ttl node capacities
dynamic ttl schemes
limited control of
of rr2 based
adns selects the
overloaded level figure
deterministic ttl s
ttl variable ttl

corpus/krapavin2000-test/628247.txt
clindex
cluster
ios
clusters
tsvq
cell
dataset
nn
cf
clustering
io
ep
nearest
query
golden
pac
cells
sr
outlier
similarity
indexing
disk
000
image
tree
centroid
id
elapsed
images
retrieved
neighboring
subregions
precision
spaces
objects
neighbor
neighbors
approximate
retrieval
wall
450
edward
outliers
search
stripes
adjacent
dimension
object
em
chang
blocks
ffl
directory
heap
schemes
index
sequential
ms
vase
resides
datasets
retrieving
retrieve
recalls
recall
multimedia
goh
cliff
crawled
queries
block
curse
dimensional
five
centroids
clock
cheng
indexes
theta
motwani
file
suffer
searches
cc
databases
dimensionality
90
versus
indyk
horizon
sequentially
height
ids
distances
pyramid
divide
communities
amsaleg
luminescence
gros
eamonn
kingshy
io0
tentacles
berrani
keogh
beitao
reclustering
heapfind
lonardi
pbir
ten
bulk
nearby
efficiency
populated
read
phi
baltimore
seek
objectives
feature
hashing
shy
hadjieleftheriou
tallies
marios
600mhz
keke
ciaccia
athitsos
fective
patella
lai
quality
grids
axis
ffi
regions
rotational
achieves
dimensions
accuracy
traditional
forming
finely
kollios
jessica
ottawa
vassilis
content
fi
near
clustered
divides
top
periments
kwang
subregion
lately
sclaroff
sid
bits
cutting
perception
shapes
database
closest
selectively
believe
king
clus
dram
trades
tenth
belongs
mining
returning
metric
contiguously
alfredo
contiguous
fraction
conducted
grouped
structures
stored
learning
stan
ineffective
ahmed
laurent
requested
vision
loading
exponentially
lookup
mbps
tois
boost
query object
r tree
the cluster
the cell
pac nn
similarity search
sr tree
000 image
clindex with
the clusters
high dimensional
the cf
30 000
the dataset
the recall
cf algorithm
of ios
outlier cluster
cluster size
golden results
m tree
with cf
cell id
image dataset
approximate similarity
the query
nearest neighbors
dimensional spaces
tsvq and
the outlier
a cluster
nearest neighbor
recall of
clustering algorithm
mapping table
the 30
the pac
recall than
r precision
of cf
450 000
nn scheme
that clindex
cell is
elapsed time
in high
the cells
a cell
one cluster
index structure
adjacent to
k nn
one io
relative distance
recall after
five ios
1 nn
20 nn
of clindex
cf r
cluster directory
of clusters
cluster the
on disk
d theta
tree structures
objects in
the search
000 images
io time
recall versus
neighboring blocks
tsvq ep
nn queries
nn query
is adjacent
top k
approximate nearest
of objects
search in
the neighboring
clusters the
the objects
the nearest
each dimension
wall clock
image retrieval
cluster is
the clustering
entire dataset
and sr
cf is
recall for
neighbor search
an outlier
and ep
ep and
top 20
tree like
io efficiency
edward chang
cell belongs
distance errors
ios are
cf tsvq
20 golden
centroid information
index structures
feature vector
clusters in
pre processing
we read
dataset is
like structures
based image
high recall
sequential file
after five
all schemes
after one
clustering algorithms
for approximate
clusters and
control parameters
dataset into
tree and
block size
each cluster
query time
recalls of
higher recall
20 nearest
x ios
clindex and
ep scheme
ios the
whose centroid
io and
sequential ios
objects retrieved
cluster id
cf and
dimension into
traditional index
target recall
clindex s
five schemes
ios and
clindex to
id of
for similarity
feature vectors
the top
the feature
each cell
a similarity
centroid is
which cluster
similarity query
cluster whose
recall when
new cluster
achieve a
spaces the
the data
clustering and
clock time
a dataset
indexing structure
after x
query point
the golden
the ep
recall we
given vector
more clusters
the wall
good clustering
not uniformly
their distances
large clusters
for indexing
dataset and
the heap
any cluster
recall in
cluster into
the disk
tree structure
search space
objects that
dimensional space
retrieve the
disk blocks
not adjacent
the elapsed
image set
the dimension
a query
o d
the query object
the cf algorithm
the pac nn
number of ios
clindex with cf
30 000 image
000 image dataset
high dimensional spaces
in high dimensional
the 30 000
the outlier cluster
approximate similarity search
pac nn scheme
if the cell
with cf r
the cell is
to the query
the cluster size
the objects in
r tree and
is adjacent to
tree and sr
neighboring blocks of
a cell id
mapping table is
and sr tree
the mapping table
and r tree
number of objects
nearest neighbor search
of the clusters
the entire dataset
the number of
number of clusters
tree like structures
approximate nearest neighbor
the recall of
than one cluster
20 golden results
the neighboring blocks
tsvq and ep
relative distance errors
cluster the cell
cell is adjacent
the cell belongs
tsvq ep and
of the cf
after five ios
ep and r
450 000 image
30 000 images
search in high
the top k
after we read
when the data
based image retrieval
the dataset into
cluster whose centroid
the given vector
which cluster the
the wall clock
on the 30
higher recall than
000 image set
into the outlier
the relative distance
top 20 golden
cf r tree
the ep scheme
adjacent to more
the cluster directory
a query object
whose centroid is
the m tree
after x ios
after one io
adjacent to any
an outlier cluster
a target recall
high dimensional space
their distances to
one io and
to the cluster
in the dataset
we believe that
similarity search in
wall clock time
dimensional spaces the
to any cluster
achieve a target
a sequential file
is not uniformly
for similarity search
the top 20
objects in the
in the feature
number of points
in the entire
clustering and indexing
not uniformly distributed
a high dimensional
conference on multimedia
objects that are
the elapsed time
cell to the
the cluster is
not adjacent to
the clustering algorithm
content based image
the feature space
high dimensional data
acm international conference
dataset into about
good clustering algorithm
dimension into 2
wei cheng lai
where am i
than tsvq ep
different cluster sizes
o d theta
a similarity query
query object to
more clusters the
compare clindex with
an exact similarity
20 1 nn
cluster size is
the golden results
ios clindex with
and motwani 27
the nearest objects
of ios clindex
recall than tsvq
recall when the
perception based image
cluster is stored
cf returns the
one cluster the
exact similarity search
cf clustering algorithm
five ios are
into an outlier
cell id of
show that clindex
n theta d
theta d theta
the index structure
a similarity search
on 30 000
20 nearest neighbors
the 450 000
query object is
that the recall
cf tsvq and
the nearest cluster
time versus recall
20 61 recall
r tree because
the point count
traditional index structures
clusters the recall
adjacent to only
20 nn on
takes o d
to which cluster
recall number of
r tree sr
elapsed time to
the query point
r sr tree
tree sr tree
the indexing structure
cf r sr
1 nn queries
of ios and
active learning for
top k golden
ios are performed
o n theta
1 nn query
sr tree figure
the cell ids
recall of cf
international conference on
of the top
to achieve a
of the dataset
a cell is
the search space
proceedings of the
quality of the
a good clustering
of nearest neighbors
meets databases june
of the 30
reading in the
workshop on computer
than r tree
the data dimension
vision meets databases

corpus/krapavin2000-test/628254.txt
oid
oids
pph
hashing
bucket
mvbt
alive
page
alh
buckets
pages
lifespan
overflows
ephemeral
lifespans
persistent
snapshot
query
acceptor
evolution
evolving
overflow
nt
ri
nb
additions
end_time
temporal
start_time
records
membership
lh
round
instants
copies
rehashing
workload
workloads
queries
rp
lb
array
mvas
tk95
partially
multiversion
ub
pid
update
avg
bgo
atemporal
split
record
2m
deletions
forest
deletion
poisson
tree
usefulness
deleted
ft
updating
maxtime
ls89
l80
tsb
object
history
transaction
appended
amortized
indexes
evolves
index
searched
rehashed
start_times
vv97
tsotras
logarithmic
created
timestamped
instant
occurred
file
searching
remapped
utilization
answering
copying
load
mapped
stores
splits
objects
buffer
ptr
create
sibling
answer
insertions
artificial
reconstructing
contents
pure
updated
115878
poisson1
rehashings
overflown
ktf98
evolutions
r97
clr90
tgh95
en94
dsst89
truncated
artificially
hashed
copied
sees
universe
persistence
stored
behaves
observes
merged
database
equivalently
copy
updates
exponential
balanced
entries
intervals
2mb
5m
histories
accessing
arrays
branched
5k
happens
queried
500
external
directory
96
list
zaniolo
deleting
maintained
traversed
store
proceeds
overlapping
pointer
uniform
05
locating
clustering
03
reconstruct
indexing
serially
uncontrolled
databases
entry
mb
existed
basics
join
added
const
efficiently
changes
ideally
traditional
falls
height
schemes
contradiction
splitting
access
insertion
interval
controlled
normal
conceptually
trees
answers
dept
had
possessed
bitemporal
sa85
rehashes
pph s
partially persistent
hashing scheme
linear hashing
persistent hashing
oid k
useful page
the mvbt
pph l
alive oids
snapshot index
b j
j t
bucket b
hashing function
of alive
i o
the snapshot
acceptor page
s pph
non useful
query performance
b tree
the hashing
useful pages
temporal membership
snapshot query
membership query
o s
bucket 0
alive records
l mvbt
alh pph
oids in
set s
the evolving
dynamic hashing
page a
the pph
evolving set
a page
the page
ephemeral hashing
oid additions
the oids
oid lifespan
time t
the bucket
membership queries
avg number
o per
lb j
the acceptor
range snapshot
to bucket
of bucket
s t
data pages
of buckets
first overflow
oids are
of lifespans
of oids
object additions
alive objects
lifespan at
the alive
evolving list
temporal hashing
at time
evolution of
time tree
per query
the ephemeral
transaction time
an oid
ft j
1 oid
the useful
r tree
at t
each bucket
time instants
a temporal
parameter u
nt a
of oid
new bucket
pure snapshot
mvbt and
lifespans per
per oid
space performance
the ri
usefulness parameter
ephemeral linear
the alh
access forest
lh file
this page
the evolution
b 1
the list
the oid
buckets are
the lh
page in
bucket 5
oids and
per change
distinct oids
oids of
s history
first useful
array h
now oid
given oid
oid is
data page
n b
round i
hashing in
the partially
pages of
in bucket
an evolving
of pages
of partially
page is
a bucket
the query
same bucket
last page
b total
update performance
next useful
oids at
for oid
temporal environment
real oid
with oid
oid and
bucket s
oid copies
oids from
mvbt is
bucket the
bgo 96
appropriate bucket
hashing problem
list page
multiversion b
exponential step
same oid
c space
the multiversion
nt array
ub alive
of page
buckets for
overflow occurs
page can
query time
o 1
update and
the space
s evolution
load factor
b update
page s
uniform workload
time proceeds
page after
the nt
new page
hashing the
an ephemeral
additions are
variable p
of set
b r
added in
of changes
page has
set approach
per update
the rp
query about
more space
h 0
object with
oid records
n overflows
than pph
temporal indexes
create at
real changes
oid was
lh t
of pph
partially persistent hashing
b j t
the snapshot index
i o s
bucket b j
pph s pph
s pph l
number of alive
pph l mvbt
alh pph s
the hashing scheme
i o per
of alive oids
avg number of
oid k is
oid lifespan at
the acceptor page
lb j t
at time t
number of i
of the snapshot
hashing scheme is
the evolving set
the pph s
the first overflow
the partially persistent
the range snapshot
range snapshot query
of partially persistent
number of lifespans
of i o
of set s
the useful pages
linear hashing scheme
b 1 oid
ephemeral linear hashing
temporal membership queries
temporal membership query
usefulness parameter u
the evolving list
the lh file
in the list
the evolution of
the hashing function
query performance of
number of changes
first useful page
the oids in
dynamic hashing scheme
the time tree
a temporal membership
ephemeral hashing scheme
the alive oids
the access forest
now oid lifespan
the pure snapshot
of page a
of lifespans per
of the mvbt
j t is
the query performance
the r tree
the same bucket
o n b
the number of
the same oid
evolution of set
with oid k
of bucket b
the first useful
evolving set approach
of distinct oids
useful pages at
space performance for
object with oid
multiversion b tree
c space performance
1 oid copies
and c space
the appropriate bucket
update and c
the data pages
a given oid
becomes non useful
b update and
pure snapshot query
lifespans per oid
for oid k
query b update
total number of
of the ephemeral
as time proceeds
a query b
number of real
the total number
the last page
is added in
number of buckets
in set s
set s and
than pph s
a temporal environment
0 avg number
as an evolving
o per query
the next useful
exponential step normal
the load factor
s s evolution
external dynamic hashing
oids in the
of pph s
to non useful
ephemeral dynamic hashing
ub alive records
the multiversion b
mvbt and ri
list lb j
snapshot index and
in the evolving
from bucket 0
in that bucket
next useful page
o per update
real oid additions
hashing function h
array ft j
bucket 0 and
k t now
the ephemeral hashing
temporal hashing problem
a new bucket
useful page in
o s per
the nt array
a membership query
create at most
the temporal hashing
real object additions
the usefulness parameter
evolution of bucket
number of pages
page in the
of the bucket
page a is
expected o 1
in the evolution
in s t
the most current
a a a
in i o
more space than
in a temporal
for each t
the second round
number of copies
this search is
the first round
time t a
for as long
number of queries
membership query for
l mvbt alh
k is deleted
as nb increases
can create at
the mvbt and
case query performance
pph s and
copy of page
for temporal membership
records in bucket
the useful page
and ri methods
hashing scheme at
lifespan at records
additions are needed
alive objects at
collection of buckets
addition of oid
at records in
its end_time is
of this oid
query for oid
answer a temporal
alive oids in
most current state
17 now oid
performance for alh
of temporal hashing
page becomes non
10 1 now
an artificial copy
the mvbt tree
the exponential step
time tree is
it partially persistent
a good ephemeral
1 real object
useful pages of

corpus/krapavin2000-test/628284.txt
toprof
profpage
coursepage
proflistpage
dname
pname
page
tocourse
navigational
pages
deptpage
web
professors
query
piproflist
proflist
cname
courses
site
nalg
navigations
pointer
join
attribute
relational
navigation
link
courselist
picourselist
plans
sessionpage
toses
todept
deptlistpage
navigate
adm
chasing
url
sessionlistpage
views
external
algebra
plan
piseslist
conferences
vldb
navigating
nested
profdept
pideptlist
sites
queries
chase
taught
joins
araneus
inclusion
attributes
html
hypertext
department
ses
professor
mono
selections
deptlist
courseinstructor
1cname
links
databases
session
1d
unnest
ull
rewritings
relations
gamma
querying
rewriting
pi
expressions
computable
optimizer
pushing
declarative
rank
tuple
extents
redundancies
navigates
accesses
dept
instructors
1pname
dcoursepage
1tocourse
monovalued
dprofpage
navigated
materialized
email
oriented
home
entry
rewrite
indices
downloads
atzeni
descr
paths
oe
bibliography
schemes
rule
hypertextual
2d
projections
valued
optimization
default
redundancy
teach
graduate
pointers
database
formalize
accessed
enrich
favor
departments
documented
push
excessively
text
joining
urls
radically
optimizing
name
network
contrary
tuples
object
expensive
documents
expression
translate
who
engine
constraints
projection
rules
constraint
remote
author
algebraic
sql
expands
answer
containments
listname
seslist
gem
tocoursed
tre
igations
nazionale
legenda
gammamail
ulixes
trier
delle
doni
instructor
fictional
weboql
1y
pia
ricerche
toprofd
materializes
dsessionpage
consiglio
todept6
masci
confer
ddprofpage
abstractlarge
materializing
auxiliary
fall
operators
pushed
virtual
rewritten
reached
ordinary
concentrate
access
issued
page scheme
navigational algebra
the web
external relation
page schemes
pointer join
toprof gamma
the site
r 1
proflistpage piproflist
query optimization
attribute l
piproflist toprof
relational views
inclusion constraints
the query
page relations
link constraint
gamma profpage
type link
cost model
pointer chasing
proflist toprof
pointer chase
link constraints
a page
a link
data model
the navigational
web sites
access structures
network accesses
external relations
pointer sets
gamma coursepage
courses taught
sessionlistpage piseslist
tocourse gamma
full professors
to navigate
science department
each external
link to
r 2
object oriented
entry points
navigate the
rule 8
of page
url is
oe ses
araneus data
mono valued
deptlistpage pideptlist
views over
relational view
pname dname
link attribute
web type
ses f
default navigations
piseslist toses
the araneus
join approach
taught by
toses gamma
constraint r
a nested
an attribute
and inclusion
oriented query
relations r
execution plans
all professors
page relation
external view
of pages
to r
oriented databases
rewriting rules
by full
nested relation
professors in
relational databases
f all
home page
rule 6
link and
path expressions
a query
the computer
deptpage proflist
dname deptpage
pideptlist todept
candidate execution
deptpage dname
three vldb
over web
web scheme
ull 0
dname profpage
deptpage piproflist
plan 2d
navigation plans
source relation
declarative queries
profpage pname
navigation of
professors and
profpage picourselist
dname pname
vldb conferences
plan 1d
rank email
dname address
department page
coursepage rule
coursepage in
courselist tocourse
valued web
inclusion constraint
to courses
proflistpage proflist
toprof proflistpage
picourselist tocourse
following links
profpage courselist
courselist cname
f ull
sessionpage picourselist
nested attribute
navigations in
graduate courses
a pointer
the home
join is
entry point
the join
a navigational
access paths
query engine
two pointer
query name
all courses
virtual views
r 3
the pages
in query
algebra and
by rule
web site
plan in
two page
rule 9
between pages
index html
all 0
with l
two relations
rule 1
attribute in
1 suppose
query plan
materialized views
one among
a relational
the fall
our cost
site we
suppose also
department and
to push
to pages
algebra is
the link
to formalize
constraints that
l of
the ones
selecting one
relational and
the relational
the page
of type
given two
links between
web and
network access
computer science
the external
rule 4
multi valued
suppose x
finding all
the cost
queries over
be reached
the department
a web
and courses
proflistpage piproflist toprof
piproflist toprof gamma
toprof gamma profpage
a link constraint
type link to
the navigational algebra
each external relation
an attribute l
a page scheme
link to r
of type link
relations r 1
attribute l of
associated with l
and inclusion constraints
tocourse gamma coursepage
l of type
computer science department
the computer science
r 1 such
object oriented query
that a link
araneus data model
courses taught by
ses f all
f all 0
oe ses f
the araneus data
given two relations
sessionlistpage piseslist toses
piseslist toses gamma
link constraint r
pointer join approach
the home page
link and inclusion
by full professors
taught by full
to r 2
of the web
to r 3
object oriented databases
in the site
two relations r
professors in the
the join is
in the web
the query engine
query name and
valued web type
with l then
constraint r 1
last three vldb
selecting one among
each page scheme
proflistpage proflist toprof
1 suppose also
candidate execution plans
f ull 0
navigate the site
navigational algebra and
picourselist tocourse gamma
a nested attribute
relational views over
of page scheme
two pointer sets
has an attribute
of network accesses
toprof proflistpage proflist
our cost model
a navigational algebra
r 2 suppose
of page schemes
page scheme is
gamma coursepage rule
deptlistpage pideptlist todept
the pointer join
a pointer join
the source relation
a pointer chase
and r 2
r 1 and
1 and r
scheme in figure
r 1 suppose
from the home
to navigate the
that r 1
the result on
of all professors
the external view
in the fall
is a page
in the computer
to the list
r 1 has
attributes of r
number of network
suppose x is
a nested relation
of the site
1 has an
the cost model
the scheme in
the web and
in order to
1 such that
page to the
attribute in the
to the web
result on the
suppose that a
and object oriented
the list of
p 1 and
the last three
of a page
relation one or
paths to reach
to reach data
holds if for
go directly from
cname tocourse courselist
gamma tocourse gamma
query in example
on link constraints
of candidate execution
many web sites
to relevant items
of navigations in
equals the value
home page to
both r 1
the web scheme
page scheme name
optimizing path expressions
consider the department
all 0 rank
lack of control
all pointers to
approaches to query
1 dept dname
different navigation paths
or more computable
access to relevant
dname deptpage dname
to courses taught
our navigational algebra
expands the source
over web views
name and e
professors and courses
nalg rewriting rules
is repeatedly rewritten
finding all links
links to courses
the relational view
all professors in
the two pointer
dname profpage dname
pname rank email
view as follows
corresponds to i
given relations r
rule 6 is
6 is used
between data are
which links between
external view as
full professors ii
e mail of
views over network
links between data
2 professor pname
attribute of p
to i finding
university web site
as follows proflistpage
toses gamma tocourse
access support relations
to restrict network
the underlying hypertext
mail of all
deptpage dname profpage
hand side path
plans corresponding to
has some points
follow the link
restrict network access
attribute a of
the link attribute
cname descr oe
url is the
web a number
gamma sessionpage picourselist
constraint r 2
science department page
we enrich the
a relational view
that lists all
gamma profpage picourselist

corpus/krapavin2000-test/628293.txt
documents
subrange
engines
engine
document
nodoc
query
weight
normalized
database
metasearch
mw
avgsim
mismatch
d1
similarity
weights
usefulness
d3
subranges
representatives
ggloss
similarities
estimation
percentile
representative
queries
databases
d2
weiyi
internet
deviation
byte
match
clement
estimated
quadruplets
mnw
combined
search
correlation
meng
threshold
wm1
sim
lup
king
median
retrieval
probability
yu
ft
ij
wm4
zonghuan
wm3
wm2
stanford
bytes
thresholds
estimating
234
text
cosine
est
useless
ith
substantially
inaccuracy
retrieved
probabilities
submitted
largest
761
broker
statistical
wu
ranking
collections
lazarsfeld
1511
zhuogang
wmj
usefulnesses
metadata
triplets
searching
occurrences
liu
j1
retrieve
estimate
dependencies
polynomial
percentage
accurate
bahadur
gloss
jk
bits
dot
phrases
web
tell
53
occupies
048
um
users
percentages
coefficient
474
estimates
disjoint
oe
rank
returned
generating
virginia
identify
incorporating
descending
deviations
downloaded
tables
identifying
adjacent
experimental
columns
medians
accuracy
searched
criteria
frequency
identification
mclean
352
average
98
moderately
phrase
proposal
meta
submit
ease
expanded
kong
polynomials
potentially
content
rg
ninth
norms
reasonably
normalization
nag5
0278
abstractsearching
kup
savvysearch
d2d
moshiri
wensheng
hrd
resulr
kazemian
crestani
maryam
majid
losee
santoso
gravano
hosein
1484
archies
000158
metasearching
webfusion
relatedness
inhomogeneity
9711582
invokable
prasoon
0049
restrictiveness
wmi
adrain
piroozmand
keyhanipour
webcrawler
aliweb
0013
naah04
zipfian
5095
9707076
netnews
roanoke
kthen
dependency
maximum normalized
normalized weight
search engine
search engines
term t
match mismatch
subrange based
mismatch d
combined term
documents in
of documents
weight of
the database
a document
database representative
term weight
estimation method
high correlation
document in
single term
the subrange
the term
d s
normalized weights
d n
n d
average weight
the query
metasearch engine
one byte
documents having
term weights
normalized term
similarity function
s table
all documents
in d
database d
standard deviation
a search
the documents
each term
useful documents
identify d1
d1 as
engines to
the combined
the probability
similar documents
documents containing
usefulness of
generating function
the usefulness
weights of
probability that
each number
s match
weight is
database representatives
subrange contains
mw 1
term queries
useful based
basic method
based method
weiyi meng
d2 and
documents are
d has
given query
of term
estimation methods
terms in
distinct terms
clement yu
weight and
engine is
t in
the weights
subrange is
has similarity
in ggloss
t i
as useful
a query
a database
metasearch engines
query term
the estimation
two terms
term in
with q
each search
t j
the internet
the maximum
the estimated
the search
previous method
u match
useful search
global similarity
true nodoc
byte for
first subrange
method t
query q
documents with
statistical method
the representative
similarities of
that identify
text databases
document d
weight for
the similarity
in ft
different estimation
our estimation
term query
the weight
experimental results
4 bits
the normalized
and d3
engine with
document has
new subrange
large sim
second subrange
and avgsim
correlation case
with similarities
a metasearch
term method
similarities greater
nodoc and
the true
the document
based estimation
representative of
each query
than t
the average
threshold t
the generating
potentially useful
query and
weights are
a term
each document
each probability
cosine function
document having
uniform weight
king lup
lup liu
of search
queries that
be combined
the high
engine for
information retrieval
term j
for term
containing t
that term
is 0
to estimate
similarities with
of terms
of t
the median
the threshold
estimate the
6 234
for d3
whose similarities
correlation approach
internet queries
highest subrange
database d1
234 queries
53 databases
mw 2
sim q
containing term
ith term
term should
mnw ij
estimated probability
the representatives
the terms
local search
term and
deviation of
and standard
m distinct
engine in
for database
the maximum normalized
maximum normalized weight
mismatch d n
n d s
match mismatch d
d n d
number of documents
the combined term
d s table
a search engine
the database representative
normalized weight of
the subrange based
subrange based method
in the database
that a document
document in d
the high correlation
the search engine
documents in the
normalized term weight
maximum normalized weights
of a search
of documents in
of the term
the probability that
identify d1 as
d1 as useful
s match mismatch
d s match
a document in
the usefulness of
weight of the
term t i
search engines to
single term queries
in d has
useful based on
weight of t
a given query
term t in
representative of a
usefulness of a
our previous method
the two terms
that identify d1
term weight is
documents having the
queries that identify
maximum normalized term
as useful based
for each term
search engine is
greater than t
for the term
document in the
the average weight
the representative of
each search engine
probability that a
the weights of
the weight of
estimation methods using
of different estimation
one byte for
the true nodoc
terms in ft
u match mismatch
weights of t
the first subrange
t u match
database d 1
subrange based estimation
the generating function
different estimation methods
global similarity function
using one byte
average weight and
search engine with
method t u
useful search engines
of search engines
of term t
the term t
in the internet
for each number
all documents in
in d i
the standard deviation
of t in
t in the
most similar documents
d2 and d3
the number of
of the database
weight of term
the basic method
a document has
high correlation case
documents with similarities
documents in d
combined term method
estimate the usefulness
the global similarity
a metasearch engine
of documents having
of useful documents
d has similarity
a single term
are single term
estimation method is
in database d
normalized weight is
statistical method to
for term t
uniform weight of
terms t i
our estimation method
the second subrange
m distinct terms
similarities greater than
having the term
with similarities greater
subrange contains the
the database representatives
normalized weight for
the term in
in a document
of the combined
of documents containing
in the documents
set of documents
in the query
comparison of different
of each term
should be combined
to estimate the
in all documents
king lup liu
term t j
similarity function is
documents containing t
standard deviation of
the terms in
is the probability
weight for the
of a database
search engine in
of the weights
the estimated probability
on the true
4 bits for
that the subrange
nodoc and avgsim
coefficient of x
sim q d
the polynomial for
that term t
database with m
estimating the usefulness
all documents containing
for all documents
product is over
database representative is
weight and standard
whose similarities with
single term query
subrange based approach
database has the
the highest subrange
the estimates produced
6 234 queries
probability that term
useful documents in
normalized weight and
uses one byte
weights from w
the ith term
d has exactly
local similarity function
high correlation approach
having the largest
average similarity of
term should be
based estimation method
exactly the terms
bits for each
1 to w
using 4 bits
average weight of
if the combined
the 53 databases
weights of the
number of useful
as a result
and standard deviation
weight of each
each term in
for a given
term in the

corpus/krapavin2000-test/628383.txt
epipolar
optical
motion
segmentation
affine
flow
scene
rotation
regions
rigid
depth
image
frame
camera
frames
recovered
matrix
rigidly
koenderink
discontinuities
motions
doorn
cube
axis
priors
jjq
perspective
constraint
correspondences
rotating
region
ave
fundamental
velocity
coordinates
statistic
angle
lec89
kvd91
planar
displacement
piecewise
kalman
moving
boundaries
geometry
perpendicular
unassigned
field
measurement
orthographic
segmented
measurements
plane
squares
growing
patches
soatto
bz87
0degrees
szb93
nsko94
wah93
tor93
rubik
bj94
web94
platen
tm94
pixel
foreground
functional
weighting
stereopsis
br87
dense
weak
axes
projection
covariance
undergoing
objects
fit
rank
tracked
projected
outliers
displacements
recovery
prediction
uncertainty
stochastic
viewing
estimate
object
estimation
filter
omega
van
visual
shape
pixels
occlusion
shapiro
szb94
sfp94
hadiashar
rcv92
sch89
ull79
lf94
ldfp93
mw86
cfchb89
adi85
sp93
oe
cubes
background
discontinuity
singular
views
differentiating
texture
bab
alireza
tracking
squared
descriptive
suter
scaled
3d
projections
weighted
imaged
arctan
partitioning
synthetic
explosion
segmenting
weng
train
merged
boundary
recover
separate
rotations
penalty
toy
translational
dr
saw
intensity
020
depths
delta
translating
translation
variance
centroids
labeled
calibration
differential
statistical
pure
noise
silicon
unity
estimating
multiplier
dictated
multiplying
lagrange
minimization
distances
fields
perturbed
transformation
relating
deformation
gradient
matrices
formed
vision
colored
smoothness
continuation
minimizing
hp74
hl89
gheissari
schunck
nxt93
niloofar
cernuschi
mitiche
su87
bel93
cyclorotation
ms85
optical flow
epipolar constraint
fundamental matrix
the optical
the epipolar
the scene
affine flow
motion parameters
cost functional
the fundamental
the motion
flow field
the image
velocity space
weak perspective
the segmentation
epipolar geometry
the rotation
in velocity
image coordinates
scene structure
region growing
moving objects
rigidly moving
independently moving
image plane
koenderink and
van doorn
segmentation and
flow is
rotation axis
affine camera
motion segmentation
an axis
initial segmentation
rigid motion
the affine
constraint line
scene partitioning
frame number
omega v
motion and
statistical test
rigid objects
scene into
error covariance
segmentation algorithm
rigid transformation
10 frames
kalman filter
an affine
into distinct
and van
rotation matrix
the measurement
and motion
least squares
rotation about
measurement matrix
under weak
the depth
objects the
a kalman
doorn kvd91
affine epipolar
separate regions
measured optical
recovered depth
rotation axes
axis angle
linear constraint
squares solution
viewing direction
the flow
segmentation of
moving object
of affine
in image
about an
point x
motion of
flow and
growing algorithm
be segmented
perspective effects
distinct regions
from optical
partitioning problem
depth map
perpendicular to
the matrix
depth of
frames the
single frame
constraint equation
priors on
from frame
the fit
regions of
flow the
the viewing
recovery of
matrix w
weighting factor
the statistic
rotation in
the estimate
a rigid
frame the
of motion
discontinuities in
in optical
the recovery
shapiro et
filter approach
scene can
by koenderink
undergoing pure
projected point
segmentation via
constraint exists
rotating platen
separate objects
z ave
perspective camera
0degrees rotation
statistic based
unique epipolar
unassigned regions
growing method
w gamma
example optical
and structure
the rigid
constraint is
the constraint
singular values
a rotation
the elements
axis in
two regions
scene is
to frame
the background
special form
rigid object
flow vectors
solution n
factor w
each independently
of epipolar
second frame
the unassigned
3d world
descriptive language
of correspondences
rotating about
epipolar line
visual scene
flow to
elements of
z i
the vector
the measured
image sequences
the displacement
constraint can
frame to
based region
piecewise continuous
new frame
multiple frames
is affine
and recovered
optical axis
gamma q
boundaries between
relative depth
the assumption
structure from
matrix can
the uncertainty
distances in
matrix in
three dimensional
with time
a prior
the solution
squared distances
flow are
of frame
the weighted
the singular
and shape
w i
the cost
can not
affine in
regions which
two frames
the optical flow
the fundamental matrix
the epipolar constraint
in velocity space
of the fundamental
the motion parameters
optical flow field
optical flow is
the image plane
and van doorn
koenderink and van
of the optical
the cost functional
about an axis
in image coordinates
fundamental matrix in
to the epipolar
rigidly moving objects
of affine flow
of the image
the initial segmentation
under weak perspective
the scene structure
in the image
optical flow and
the segmentation of
the viewing direction
least squares solution
a cost functional
a kalman filter
the segmentation algorithm
in optical flow
distances in velocity
scene partitioning problem
measured optical flow
scene into distinct
epipolar constraint is
van doorn kvd91
on the scene
recovered depth map
an affine camera
segmentation of the
the elements of
motion and structure
from optical flow
the scene into
region growing algorithm
of the scene
in the scene
a statistical test
the rotation matrix
a single frame
the region growing
to the optical
the measurement matrix
elements of the
perpendicular to the
special form of
the flow field
the recovery of
independently moving object
factor w i
shapiro et al
into distinct regions
motion parameters for
the rigid motion
velocity space between
about the viewing
the unassigned regions
a rotating platen
affine flow the
the epipolar line
of epipolar geometry
rotation in depth
affine in image
statistic based region
each independently moving
unique epipolar constraint
0degrees rotation axis
an axis in
function of frame
perspective effects are
epipolar constraint equation
fundamental matrix can
10 frames the
scene can be
kalman filter approach
weighting factor w
epipolar constraint line
example optical flow
w gamma q
flow is affine
and recovered depth
flow and recovered
by koenderink and
rotation about an
region growing method
weak perspective camera
based region growing
squared distances in
of frame number
rotation axis angle
of an affine
squares solution for
the measured optical
recovery of the
constraint can be
depth of each
motion segmentation using
motion of each
single frame of
the second frame
the error covariance
the weak perspective
the singular values
independently moving objects
weak perspective projection
on a rotating
for the fundamental
optical flow to
priors on the
can be segmented
and the measured
space between the
that the scene
matrix can be
the optical axis
of a cost
from frame to
parallel to the
regions of the
of the epipolar
the first class
frame to frame
discontinuities in the
a special form
assumption that the
form of the
axis in the
function of x
the scene is
on a line
value of delta
the assumption that
the least squares
the first frame
of the depth
the point x
of the measurement
in the direction
a line in
under the assumption
from the sequence
the motion of
linear function of
line and the
difficult to recover
the recovered value
using affine epipolar
a toy train
no depth information
new optical flow
weng et al
rigid objects the
described in web94
recovered value of
point matches using
depth map are
assumed model or
image plane this
perspective camera the
problem lec89 in
the scaled depth
frames the rotation
the rotation about
an example optical
representation for rotations
the solution n
the displacement field
combining information from
on points in
in both frames
subject to error
the visual scene
projected point x
flow under weak
an axis parallel
moving rigid objects
second frame is
texture mapped cubes
doorn kvd91 and
first 10 frames
z 0 ave
the affine case
the projected point
image sequences the
constraint on points
to an assumed
once the motion
between the epipolar

corpus/krapavin2000-test/628464.txt
polar
retinal
optical
sensor
velocity
fovea
motion
camera
ae
ccd
cortical
radial
flow
impact
sin
image
rotational
tracking
oe
plane
visual
retina
fl
images
translational
gaze
wz
variances
egomotion
cartesian
fixation
foe
log
vision
derivatives
coordinate
scene
mapping
derivative
obstacles
acquired
equations
pixels
resolution
focal
eccentricity
fig
sampling
navigation
field
angular
sandini
sensors
divergence
angles
velocities
raster
axis
variance
anthropomorphic
estimation
coordinates
hazard
wx
ego
conformal
periphery
motor
motors
depth
movements
moving
observer
rotation
cos
44a
retino
dialation
foveal
avaliable
foveated
receptors
usefulf
logarithmic
squares
sampled
rotations
attention
variant
effector
efficently
burlina
analysing
amplitude
sensing
256x256
concentric
rama
chellappa
fabrication
equation
hi
autonomous
monocular
abundance
conventional
scenes
devices
relate
performances
transformation
pointed
robot
recover
advantages
object
humans
geometry
centered
imaging
prototype
stabilized
animals
uncorrelated
neighbouring
feb
formulations
translation
noting
spatial
estimated
spherical
vital
cameras
circular
pixel
qualitative
position
straight
differentiating
rotates
driving
certainly
active
substituting
processed
recognition
conducted
worth
motions
mandatory
unitary
greatest
frames
formulation
trajectory
intelligence
expansion
stereo
filiberto
1548
capurro
dinates
analogic
buit
chalimbaud
0753
44b
30x64
pelegrn
foeva
boluda
778
fabin
prey
gratefull
ae3
undertaking
gerdes
8182
yehezkel
camacho
fixated
rosenfeld
ballard
altamirano
corridors
panerai
aeof
analitically
direcition
rotstein
parabola
konrad
donoghue
visuo
applyed
traver
meaurement
tagliasco
to impact
optical flow
the optical
log polar
the retinal
polar mapping
the polar
time to
the radial
the fovea
sin fl
oe sin
log e
polar and
retinal plane
the cortical
the camera
the rotational
ae ae
space variant
ccd sensor
radial component
the sensor
f oe
the motion
in fig
of gaze
the time
the variances
the image
of attention
w z
z log
the tracking
cortical plane
retinal sensor
retina like
the foe
the log
radial coordinate
focus of
the ccd
the translational
motion of
log a
z w
the fixation
impact from
rotational angles
polar transformation
retinal velocity
tracking egomotion
retinal image
sensor the
equation 25
the visual
and log
the focus
partial derivatives
the scene
ae z
the velocity
motion equations
optical axis
a polar
of polar
general motion
of velocity
visual navigation
impact as
derivatives of
e a
estimation of
focal length
z ae
cartesian coordinate
a cartesian
flow and
impact in
fixation point
fovea is
like sensor
visual field
visual sensor
polar representation
retinal ccd
polar images
fl log
the focal
variances of
the cartesian
oe t
velocity field
equation 31
coordinate system
tracking motion
equation 33
in space
as from
data reduction
the variance
the images
parameters involved
the retina
impact can
the estimation
of ae
a moving
the direction
the divergence
flow are
computation of
impact the
velocity is
sensor is
rotational velocity
and angular
cortical projection
flow equations
system centered
active tracking
sampling structure
polar or
a retina
z oe
inverse time
z wz
hi wx
sensitive elements
ae hi
variant sampling
ae plane
angular component
logarithmic mapping
wz z
coordinate ae
polar plane
translational flow
conventional raster
impact with
cartesian plane
translational component
direction of
mapping for
obtain z
position of
v t
a e
velocity and
component of
z f
of camera
computer vision
two equations
ae log
radial and
ae f
obtain ae
velocity can
variances oe
image velocity
impact is
camera is
order partial
the objects
derivative of
flow the
mapping in
image plane
the computation
least squares
from equation
high resolution
camera and
the position
independently moving
of tracking
active vision
variances in
of expansion
or log
or conversely
conducted for
f ae
the periphery
sensor are
conformal mapping
variance of
flow is
computed from
mapping of
along the
a gamma
angles are
object motion
mapping can
fl by
a ae
plane as
equation 27
time to impact
the optical flow
the time to
log e a
log polar mapping
of the optical
oe sin fl
the log polar
of the retinal
on the retinal
the retinal plane
of the camera
focus of attention
polar and log
f oe sin
and log polar
the radial component
z w z
z log e
the radial coordinate
of the time
the cortical plane
motion of the
optical flow and
the focus of
compute the time
log a e
to impact from
on the cortical
to impact in
direction of gaze
to a cartesian
of the sensor
of the focus
of polar and
the motion equations
log polar transformation
the retinal velocity
the retinal sensor
a f oe
the polar mapping
the retinal image
w z log
the rotational angles
to impact as
the polar and
partial derivatives of
of the visual
the variances of
e a f
radial component of
the focal length
variances of the
cartesian coordinate system
for the time
to the optical
to impact the
of the image
the motion of
estimation of the
ae ae ae
sin fl log
as from equation
of the foe
to impact of
from the fovea
along the radial
the visual field
the fixation point
impact can be
of the ccd
e a gamma
flow and its
to impact can
retina like sensor
retinal ccd sensor
the estimation of
position of the
the direction of
only the radial
the ccd sensor
optical flow are
optical flow is
of the scene
the computation of
the optical axis
the velocity field
impact in the
optical flow in
the partial derivatives
the position of
mapping of the
computation of the
to be processed
radial coordinate ae
the rotational velocity
z f oe
space variant sampling
polar mapping in
sin fl by
on the polar
or log polar
obtain z w
polar mapping for
we obtain ae
log polar images
impact from the
from the optical
the retinal ccd
the translational flow
to impact with
rotational angles are
component of velocity
to the divergence
of the polar
during the tracking
on the fovea
system centered on
to impact is
ae z oe
the variances oe
w z z
polar or log
case of tracking
radial coordinate of
optical flow equations
a retina like
radial and angular
the inverse time
ae oe sin
z oe sin
the fovea is
the space variant
inverse time to
a general motion
ae hi wx
flow in fig
the translational component
the least squares
the variance of
variance of the
a cartesian coordinate
optical flow the
the sensor the
variances in the
independently moving objects
computed by applying
the variances in
velocity can be
z ae ae
optical flow we
the tracking of
point on the
component of the
of the radial
parameters involved in
the data reduction
the motion parameters
field of view
the original images
estimate the time
selection of the
centered on the
term on the
pointed out the
in the cartesian
amount of information
the objects in
transactions on pattern
analysis and machine
pattern analysis and
on pattern analysis
and machine intelligence
machine intelligence v
point from the
the amplitude of
the first derivative
of the point
velocity of the
shown in fig
in the scene
to estimate the
is possible to
has to be
the image plane
also in this
equation for the
derivatives of the
coordinate of the
the case of
of the objects
of the images
and a are
related to the
t ae ae
sampling structure characterized
combining this equation
f oe cos
of the retina
abundance of equations

corpus/krapavin2000-test/628513.txt
hausdorff
image
translation
distance
rasterized
voronoi
fb
pixels
bk
nonzero
translations
vision
recognition
shapes
rotation
pixel
ranked
ruling
ruled
correlation
deltax
array
rigid
probe
norm
shape
overlaid
motion
surface
nearest
phi
intelligence
ive
matching
a2a
envelope
rasterization
versa
directed
vice
registration
circles
cone
transform
locations
portions
graphics
b2b
scan
pointwise
199
circle
multimedia
resemblance
farthest
euclidean
images
radius
daniela
gb
united
zezula
haikel
hlk
alhichri
closest
raster
rus
pattern
geometry
256
translated
jacobs
na
carton
buffer
metric
delta
1999
triangle
surfaces
l1
portion
fa
egg
distances
david
233
occluded
maximization
matches
video
rotations
fractions
lee
match
bitmap
probed
kyoung
pavel
letters
pq
annual
cones
min
sparcstation
salem
near
termination
obey
retrieval
dissimilar
nicolai
petkov
anarta
rasters
huttenlocher
breuel
doermann
workshops
amato
devika
savino
rabitti
1190
hoppenot
pradel
dec
kamel
curves
center
skipping
claim
location
camera
grid
arrays
face
mohamed
1998
slope
athitsos
ramin
zabih
davi
1181
olson
vita
talip
abidi
iannizzotto
philippe
360
thomas
sang
probing
mu
neighbor
similarity
invariant
signal
comparing
detection
neighbors
object
240
zheng
theta
january
ronen
gdalyahu
pasquale
luh
giancarlo
handwritten
asian
vassilis
rising
2000
ja
2008
zhu
uk
minimizing
fraction
symposium
measuring
inequality
park
analogously
subramanian
ghosh
gun
pan
fausto
basri
tyng
gammam
mismatched
fourteenth
hausdorff distance
the hausdorff
k l
x y
fb x
the image
directed hausdorff
d 0
b k
the directed
distance transform
the distance
of b
distance under
partial distance
voronoi surface
the model
nonzero pixel
0 x
machine intelligence
pattern analysis
on pattern
and machine
th ranked
f x
computer vision
b phi
h a
intelligence v
point of
test image
under translation
translation x
d x
pixel of
distance as
rigid motion
point sets
and bk
translation t
out circles
each translation
ranked value
near some
directed distance
ruled out
a k
distance to
a l
phi t
vision v
the nearest
z buffer
minimum hausdorff
of rotation
distance from
ruling out
nearest point
the rasterized
each point
l and
the translation
pattern recognition
international journal
distance for
binary correlation
some point
in b
and vice
under rigid
model pixels
distance h
scan termination
list t
gb x
early scan
object recognition
any point
points of
analysis and
distance is
vice versa
an image
the voronoi
image pixels
transactions on
f t
the array
fa x
nonzero pixels
the na
voronoi surfaces
image registration
be ruled
rasterized approximation
translation only
pointwise maximum
na ive
nonzero model
probe values
image the
set b
a 0
y is
ieee transactions
the minimum
portions of
of claim
recognition using
and image
b 0
k th
array d
maximum of
v 24
24 n
of translation
minimum value
image is
envelope of
points in
the locations
point b
united states
of d
graphics hardware
b and
the l
triangle inequality
recognition letters
farthest from
distance transforms
image and
delta k
k delta
journal of
point in
vision and
proceedings of
the nonzero
of points
computing the
possible relative
is farthest
upper envelope
possible translations
translated model
current translation
norm used
cone shapes
min a2a
min b2b
binary image
two shapes
within d
the computation
3 p
the points
the k
a b
relative positions
computational geometry
in equation
v 21
image understanding
21 n
the center
every point
the partial
pixels of
the translated
a model
of computer
center of
daniela rus
that fb
sets under
minimizes f
some nonzero
of fb
overlaid with
model set
euclidean motion
min k
l elements
metric properties
portion of
model at
letters v
y the
two sets
shape comparison
least l
x direction
the pointwise
geometry p
overlaid on
first test
increasing x
the triangle
the hausdorff distance
d 0 x
b k l
fb x y
a k l
directed hausdorff distance
the directed hausdorff
point of b
f x y
hausdorff distance under
the distance transform
0 x y
h a b
of b k
pattern analysis and
analysis and machine
transactions on pattern
on pattern analysis
and machine intelligence
machine intelligence v
point of a
of the hausdorff
hausdorff distance as
k th ranked
nonzero pixel of
d x y
of the model
of a k
computing the hausdorff
b phi t
x y is
of the image
the minimum hausdorff
a l and
computer vision v
to the nearest
center of rotation
hausdorff distance for
th ranked value
translation x y
distance under translation
of computer vision
distance to the
minimum hausdorff distance
the nearest point
distance as a
some point of
each point of
ruling out circles
l and bk
hausdorff distance is
international journal of
k l and
the distance to
of d 0
and vice versa
points of b
journal of computer
early scan termination
k l that
the voronoi surface
for each translation
function of translation
nearest point of
b and vice
ieee transactions on
of b and
proceedings of the
x y the
of a model
k delta k
distance transform of
x y of
from any point
the model is
the translation t
hausdorff distance h
fa x y
the directed distance
be ruled out
distance under rigid
the na ive
near some point
the list t
under rigid motion
a b phi
farthest from any
the partial distance
proof of claim
v 24 n
minimum value of
the set b
for the l
a z buffer
delta k is
hausdorff distance from
y of b
a 2 a
to the image
points of a
pattern recognition letters
recognition letters v
the k th
point in b
in b 0
n 1 p
the center of
point in a
v 21 n
sets a and
the increasing x
the model at
a 0 k
m t a
that is farthest
list t 0
voronoi surface of
using the hausdorff
min k l
is farthest from
point a 2
distance h a
array d 0
first test image
gb x y
d 0 b
point sets under
hausdorff distance between
nonzero model pixels
compute the hausdorff
pointwise maximum of
pixel of b
nonzero pixels of
the translation only
of fb x
possible relative positions
increasing x direction
each translation x
the norm used
that the hausdorff
the current translation
directed distance from
pixel of a
translation only case
distance for point
ranked value of
the minimum value
the triangle inequality
the image is
points in b
relative positions of
the l 1
as a function
of f x
n 2 p
distance from the
any point of
intelligence v 24
the maximum of
computer vision and
the distance from
portion of the
a function of
a and b
for the translation
y has been
for point sets
of a l
the array d
model and image
the first test
of fa x
in the increasing
defined in equation
function f t
circle of radius
v 23 n
the computation of
x y to
n 3 p
to the closest
of the translation
object recognition using
m x y
overlaid on the
computational geometry p
at least l
e x y
of a that
and d 0
and image understanding
image understanding v
vision and image
international conference on
in a 0
translation and rotation
to be compared
the image and
on the image
n 4 p

corpus/krapavin2000-test/628552.txt
deltaoe
amplitude
gabor
filters
contours
behaviour
phase
disparity
neighbourhoods
stability
filter
kernels
linearity
singularity
scale
modulated
noise
band
wave
spectra
signal
binocular
instantaneous
octaves
imaginary
octave
predictor
spatial
gaussian
deformations
disparities
velocity
perturbations
views
harmonics
neighbourhood
uncorrelated
frequency
quadrature
kernel
response
regions
white
deformation
wavelength
bandwidths
bandwidth
extent
image
scales
variation
fleet
deltak
vertical
oe
stable
signals
correlation
matching
frequencies
derivative
fourier
tuned
images
poorer
measurement
arg
optical
pass
vision
singularities
dilation
drift
variations
instability
bars
dilations
horizontal
detected
subsampled
sigma
windowed
residual
square
measurements
hilbert
deltax
jz
predicted
sensitivity
nonlinearities
instabilities
sinusoidally
transforms
survive
stereo
convergence
crossings
wavelets
differences
dc
shear
jepson
steerable
approximations
amounts
4b
specular
sinusoidal
ae
superimposed
11b
spatiotemporal
bernd
extents
constraint
tuning
scene
expansions
geometric
position
figures
valued
magnitude
centre
estimates
spectrum
filtered
contour
textured
motion
quantitative
shift
decreases
correlated
deviation
affine
expansion
gabors
scanlines
stereopsis
intensity
exhibited
responses
gradient
axes
windows
concerns
aliasing
passband
elliptical
5a
innermost
dependence
translations
occlusion
encloses
elongated
translation
crossing
wavelet
delta
surface
derivatives
appendix
7b
weng
evident
reliably
scalar
flow
reflects
justification
unstable
plane
dominated
shadows
tightest
11a
4c
predominantly
4a
7a
mean
modulation
centres
edges
exp
envelope
coincidence
9a
pixel
nearly
extracted
expect
log
gamma
maxima
predictors
differentiation
phase behaviour
scale space
z 1
of phase
the phase
level contours
phase stability
band pass
the filter
square wave
phase based
b z
of deltaoe
amplitude spectra
singularity neighbourhoods
spatial position
variation about
instantaneous frequency
phase difference
modulated square
the stability
the mean
the scale
and phase
gabor filters
phase contours
scale perturbations
filters with
the amplitude
stability constraint
filter output
phase information
imaginary parts
the filters
phase is
which phase
behaviour of
the expected
the modulated
mean phase
e deltaoe
expected phase
and imaginary
image velocity
white noise
gabor kernels
filter response
phase differences
phase linearity
space expansion
binocular disparity
space position
ae x
stability of
natural images
of scale
a gabor
gaussian noise
scale changes
for gabor
gabor scale
deltaoe about
quadrature pair
pass signal
through scale
phase singularities
the behaviour
behaviour in
the instantaneous
complex valued
input signal
amplitude and
pass filters
the complex
real and
based matching
contours in
the predictor
s 0
optical flow
of disparity
of white
gabor filter
different views
contours of
r 1
the response
p 0
small scale
two views
the input
magnitude of
dc sensitivity
geometric deformations
arg r
contours that
phase correlation
through space
space framework
deltaoe gamma
the neighbourhoods
wave kernel
k x
detected by
oe x
its level
the gabor
extent of
neighbourhood of
the extent
function of
of convergence
of spatial
the bandwidth
local phase
low frequencies
neighbourhoods of
white gaussian
perturbations of
contours are
on phase
spatial extent
the disparity
by 28
filter is
in space
the neighbourhood
that phase
s x
a wavelength
and linearity
disparity and
uncorrelated noise
space phase
regions detected
gabor kernel
geometric deformation
filters it
one octave
phase matching
input scale
phase drift
phase structure
amplitude spectrum
linearity through
filters tuned
amplitude derivative
deltaoe and
that survive
in octaves
correlation techniques
the kernels
tuned to
in phase
frequency of
for phase
bandwidth of
scale and
about the
stability and
of amplitude
flow techniques
disparity measurement
from phase
approximate mean
jz 1
phase values
response and
log scale
complex plane
fourier transforms
and horizontal
the real
vertical and
space time
a phase
the regions
phase with
to phase
from 21
stable with
phase of
27 30
measurement of
a function
image matching
survive the
of band
the contours
cross correlation
different scales
the signal
views of
as edges
0 x
of image
scalar z
scale variation
quantitative approximations
pass filtered
b z 1
about the mean
of the filter
modulated square wave
variation about the
the scale space
the filter output
which phase is
stability of phase
real and imaginary
z 1 is
the phase behaviour
and imaginary parts
z 1 for
the modulated square
domain of convergence
scale space expansion
level contours of
scale space position
phase behaviour in
phase based matching
the stability constraint
of scale space
1 s 0
a function of
the stability of
band pass filters
of the filters
function of scale
of phase based
deltaoe about the
z 1 s
function of spatial
the instantaneous frequency
its level contours
the filter response
of deltaoe about
of z 1
z 1 as
band pass signal
gabor scale space
of spatial position
as a function
imaginary parts of
of the input
the input signal
of b z
amplitude and phase
the behaviour of
the phase of
scale perturbations of
detected by 28
expected phase behaviour
scale space framework
instantaneous frequency of
small scale perturbations
the expected phase
in space time
behaviour of phase
the real and
white gaussian noise
extent of the
the spatial extent
parts of which
of the scale
of a wavelength
contours that survive
phase of s
the mean phase
for the modulated
spatial position and
that survive the
of phase information
phase contours that
of phase stability
contours of b
the phase contours
phase correlation techniques
square wave kernel
and phase linearity
for a gabor
between different views
the variation about
neighbourhood of p
of the amplitude
the neighbourhoods of
filters tuned to
mean phase behaviour
ae x x
arg r 1
in the neighbourhoods
regions detected by
e deltaoe and
filters with respect
phase stability and
scale space phase
the amplitude and
linearity through space
of natural images
and b z
of white noise
of phase singularities
in the neighbourhood
z 1 and
frequency of the
vertical and horizontal
the neighbourhood of
the complex plane
phase with respect
optical flow techniques
the cross correlation
of phase with
of band pass
with respect to
views of a
left and right
of the gabor
perturbations of the
stable with respect
0 x and
of p 0
in the complex
of the expected
a sample of
on the form
the two views
for gabor filters
between left and
variation in octaves
with a bandwidth
bound b z
mean phase difference
filtered versions of
oe x x
function of deltax
filters it is
the singularity neighbourhoods
deltaoe gamma z
through scale and
a bandwidth of
their frequency bandwidths
quadrature pair filters
phase based disparity
e j deltaoe
are hilbert transforms
phase based techniques
for phase based
phase contours in
the filters used
scale space in
image features such
the expected magnitude
measurement of image
windowed fourier transforms
mean b z
linear as a
band pass filtered
scale variation in
the band pass
shown to depend
on phase stability
of the kernels
to input scale
a gabor filter
sample of white
of disparities that
behaviour of deltaoe
jepson and fleet
hilbert transforms of
to a phase
between two views
spatial extent over
under small scale
of binocular disparity
local phase information
k 0 x
and phase correlation
a band pass
over which phase
expected magnitude of
gamma z 1
valued band pass
that the phase
of s x
geometric deformations of
translations and dilations
square wave filters
linearity of phase
residual term r
to which phase
and its level
extent over which
the initial filters
space phase behaviour
which the filter
for gabor kernels
of phase differences
figures 4b and
stability and phase
the phase structure

corpus/krapavin2000-test/628676.txt
segmentation
hypotheses
motion
image
scene
estimator
residual
dja
estimation
ekf
hypothesis
estimators
regions
robust
occlusion
motions
signal
dt
savings
eq
mdl
velocity
encoding
tracked
breakdown
vision
noise
segmentations
cooperative
outlier
estimates
maps
surface
maxima
occluding
estimate
frame
050
credit
object
djh
rigid
ds
homogeneous
map
norm
kalman
soccer
layers
discontinuity
dots
recovered
looming
contested
djy
husain
disconnected
estimated
surfaces
transparent
camera
squares
synthetic
contamination
regularization
images
windows
degenerate
region
estimating
populations
ball
chunks
shape
regression
priors
gaussian
transparency
covariance
bayesian
predicted
rotating
continuation
threshold
treue
8x8
kervrann
irls
frigui
flickering
trubuil
hichem
arch
llse
layer
representations
minima
measurement
optical
entropy
person
eqs
additive
plate
hypothesize
selection
occluded
feature
rotation
sfm
geman
garden
reweighting
gestalt
andersen
spurious
outliers
thresholding
piecewise
edge
grouped
shannon
field
pixel
body
predictability
plants
leclerc
stage
salient
track
heterogeneous
grouping
05
overlap
views
intelligence
covers
perceptually
jepson
alain
thin
majority
scenes
perception
error
human
corresponded
discount
deltat
coarsely
perceptual
despite
phenomena
recover
covariances
foreground
plant
complicated
gradient
perfect
features
observers
transparently
sitting
overlapping
fitting
ff
weighting
allan
rolling
feb
likelihood
squared
converge
coherent
sampling
undergoing
maximizes
house
spheres
filter
deviation
accounts
visual
planar
locked
tradition
constituent
deformable
euler
agreed
disjoint
polynomial
boundaries
reconstruction
orientation
fit
processes
cylinder
support maps
residual error
support map
the scene
the image
robust estimation
segmentation of
image sequence
of support
edge based
a support
the segmentation
of hypotheses
the residual
m estimator
hypothesis set
breakdown point
based segmentation
ds dja
description length
the support
initial set
initial hypotheses
encoding savings
050 05
feature track
one hypothesis
structure from
from motion
our method
the signal
rigid body
the breakdown
0 050
minimum description
initial support
dt dt
error norm
robust estimator
hypotheses were
m estimators
selected hypotheses
dja dt
the ekf
initial hypothesis
the encoding
a scene
m estimation
a image
each hypothesis
model complexity
image with
first frame
map for
regions of
the cooperative
05 0
computer vision
each object
3 d
point j
minimal encoding
motion estimate
complicated occlusion
credit for
predicted feature
selection stage
s dja
estimation framework
soccer ball
hypotheses which
update rule
the selection
the estimation
velocity field
the robust
an image
motion parameters
multi layer
local maxima
with complicated
continuation method
of image
an m
applied our
support based
estimation process
an estimator
constant regions
range data
each view
single object
least squares
error of
real object
a motion
vision v
how many
a hypothesis
and support
djy x
body motion
recovered 3
p djy
overhead term
region grouping
overlapping support
b initial
disconnected regions
image signal
cooperative update
known robust
single support
b final
estimated surface
s djh
motion model
two motions
estimation literature
single robust
savings for
segmentation model
into homogeneous
homogeneous but
global velocity
squares estimate
sequence and
signal and
estimation methods
the recovered
eq 19
a majority
basis functions
a signal
the predicted
that object
image the
object in
second order
machine intelligence
dt and
estimators to
outlier points
robust estimators
line process
body motions
multiple estimators
final hypotheses
piecewise polynomial
parameters x
disjoint regions
field models
the noise
pattern analysis
on pattern
a robust
the person
have found
the initial
maps to
image b
features from
parameter space
linear basis
or surfaces
hypotheses with
the mdl
motion segmentation
thin plate
additive gaussian
d model
each frame
initial conditions
objects or
find the
motions in
two hypotheses
feature locations
multiple objects
estimator is
entire image
recursive structure
length principle
the subset
estimate of
model parameters
and machine
intelligence v
the sequence
hypotheses for
relative orientation
maps for
the kalman
estimation we
order polynomial
populations of
frame from
for support
the credit
an edge
in the scene
the residual error
a support map
of the image
the breakdown point
an m estimator
set of hypotheses
structure from motion
edge based segmentation
residual error of
0 050 05
05 0 2
segmentation of image
050 05 0
an edge based
in the image
minimum description length
the segmentation of
support map for
of support maps
initial hypothesis set
ds dja dt
2 0 050
the minimum description
the initial set
represent the segmentation
for each hypothesis
sequence and b
support maps to
the predicted feature
the selection stage
a image b
the encoding savings
applied our method
of image with
of an m
initial set of
a majority of
object in the
0 2 0
to the estimation
for each object
regions of the
of initial hypotheses
in the robust
velocity field models
support maps for
single support map
of linear basis
3 d model
recovered 3 d
map for each
b final hypotheses
a motion estimate
p djy x
the support maps
initial set is
well known robust
least squares estimate
shows the support
based segmentation of
of range images
images that contain
segmentation model is
rigid body motion
with complicated occlusion
a single support
the initial hypotheses
sequence with two
recursive structure from
and b final
breakdown point of
cooperative update rule
the robust estimation
using a support
a real object
linear basis functions
the m estimation
image b initial
the minimal encoding
the image signal
global velocity field
objects or surfaces
savings for a
each object in
computer vision v
analysis and machine
on pattern analysis
and machine intelligence
machine intelligence v
transactions on pattern
of computer vision
pattern analysis and
of the scene
in the sequence
a single object
of hypotheses which
set of support
l s l
p y x
hypothesis for each
the description length
segmentation of a
second order polynomial
rigid body motions
the state vector
a multi layer
the support of
motions in the
the estimation process
parameters are estimated
of the signal
we have found
corresponding to the
description length principle
we applied our
the signal and
the entire image
the 3 d
international journal of
the observed data
of a region
in the signal
a set of
journal of computer
the first frame
points which are
have found that
of a scene
to represent the
to use in
in the selection
to describe a
approach to estimating
to recover an
thresholding the residual
estimation of k
the noise free
flickering random dot
in an mdl
majority of points
parameter and support
deciding how many
constant across models
degenerate but a
the correct estimation
multi layer representations
solutions are degenerate
multiple objects or
value means it
dt and thus
use of support
for rigid body
least one hypothesis
our method has
point j and
rule eq 23
length principle to
error norm given
order polynomial surfaces
figure taken from
at point j
and support estimates
using global velocity
the important result
the first camera
segmentation using global
real object in
subset of hypotheses
hypotheses corresponding to
no overlap in
construction of synthetic
savings of the
segmentation of range
the recovered 3
8 of these
shows the construction
noise free case
maps to represent
the initial hypothesis
range data for
estimators to describe
the encoding cost
support maps were
of additive gaussian
cooperative support update
encoding cost of
then thresholding the
a human figure
frame from image
under eq 19
we allow multiple
compute a support
robust estimation methods
image into homogeneous
one hypothesis in
regions of support
transparent flickering random
high order discontinuity
an arch sitting

corpus/krapavin2000-test/628679.txt
affine
gramian
frames
eq
shape
acquisition
motion
invar
depth
camera
invariant
images
perspective
discrimination
orthonormal
coplanar
similarity
frame
image
pose
trajectories
multiframe
matrix
coordinates
aff
recognition
weak
invariance
rigid
unfamiliar
origin
factorization
fifteen
frm
criterion
qr
transformations
tracked
views
cholesky
distortions
dotted
centered
singular
calibration
overconstrained
quadratic
object
curves
projection
solid
reconstruction
columns
basis
ave
ball
submatrix
incremental
centering
transformation
3d
fig
pong
theta
umass
ponce
mms
inigo
svd
column
orientation
pivoting
ratio
matching
rows
optional
five
dashed
ground
translation
truth
rotation
definite
incrementally
ninety
residues
nonlinear
noise
isotropic
euclidean
700
rotational
entries
reference
periphery
discriminates
pseudoinverse
measurements
thirty
rotated
tracks
scaling
decomposition
translations
lens
extrapolation
basri
ping
representations
norm
errors
rot
feet
mn
familiar
sequences
2m
measurement
ullman
collects
themselves
2b
kalman
pt
viewer
550
orthographic
subscripts
2d
box
factorizations
angles
est
favorably
interpolation
visual
estimation
mirror
depict
lend
specifically
centroid
ranged
row
curve
stage
nonzero
subjects
poor
tracking
trajectory
matrices
coordinate
rm
vision
rotating
hajder
chequered
amherst
1581
heuristical
rothganger
rangefinders
9201751
pocs
christy
noncoplanar
boufama
youcef
genc
1589
perspectivity
zest
yakup
wmn
cosines
toumi
svetlana
chetverikov
markerless
necker
sixty
strikes
horaud
cordelia
reliably
vectors
avoids
dimensional
perturbation
rotations
homogeneous
gave
combinations
imaging
bad
jean
equations
sony
contaminated
basis points
weak perspective
similarity invariant
invariant representation
the gramian
discrimination ratio
the affine
affine shape
good basis
three basis
the object
shape matrix
depth computation
gramian g
3 theta
coordinates of
five frames
for acquisition
theta 3
frame m
unfamiliar views
quadratic criterion
w b
shape representation
invariant shape
similarity transformations
to similarity
the camera
the quadratic
reference system
affine transformations
gramian matrix
linear criterion
model acquisition
first frame
perspective projection
frames were
image measurements
eq 5
the similarity
random sequence
the basis
three dimensional
in frame
coplanar with
solid curves
value decomposition
the origin
invariant with
the solid
singular value
of eq
under weak
our algorithm
the depth
of images
the centered
fifteen frames
2 frm
frame discrimination
centered image
selected basis
rigid invar
aff invar
affine transformation
qr factorization
the points
points in
the shape
image sequences
matrix g
basis is
matrix a
structure from
ground truth
pose of
computation of
p b
the three
frames used
linear system
shape and
relative errors
from image
the trajectories
from motion
the image
the discrimination
3 matrix
measurement matrix
depth values
eq 7
see eq
transformation between
eq 11
the dotted
this sequence
in 25
linear combination
an orthonormal
of affine
affine invariant
object points
were used
of w
z real
matching measure
column pivoting
gramian can
image trajectories
representation computed
pong ball
similarity invariance
reference origin
thirty frames
invariance with
perspective approximation
curve uses
invar aff
box sequence
matching criterion
three selected
the singular
the weak
transformations that
the computation
the pose
the transformation
j k
a g
in eq
the frames
t z
points themselves
its columns
calibration and
poor basis
new images
dotted curves
acquisition the
with column
of three
computation using
linear combinations
the invariant
the dashed
the sequence
three of
columns of
acquisition of
positive definite
frames and
in space
images that
the reference
images used
dimensional coordinates
to affine
and isotropic
factorization with
unit norm
depth or
the linear
points on
z t
eq 3
the coordinates
images of
matrix of
a similarity
basis the
the matrix
frame of
points can
invariance to
first five
matrix w
the cholesky
points i
basis vector
model matching
the orthonormal
truth data
representation a
and affine
and incremental
ping pong
sequence is
the good
the coordinate
fig 2b
camera calibration
the ground
in fig
w t
to compute
coordinate system
collects the
eq 8
depth map
similarity invariant representation
the basis points
the similarity invariant
the affine shape
three basis points
the three basis
coordinates of the
3 theta 3
the gramian g
the quadratic criterion
affine shape matrix
of the basis
of the object
the weak perspective
with the origin
the first frame
respect to similarity
of the gramian
in frame m
basis points in
to similarity transformations
the linear criterion
used for acquisition
under weak perspective
the solid curves
coplanar with the
frames were used
singular value decomposition
invariant with respect
of the points
of the similarity
of the camera
i j k
the computation of
the gramian matrix
the good basis
a similarity invariant
shape matrix a
depth values of
combination of three
frame discrimination ratio
the discrimination ratio
similarity invariant shape
depth computation using
invariant representation a
theta 3 matrix
representation a g
frames used for
the singular value
the relative errors
z t z
the depth values
of three of
linear combination of
points in space
pose of the
the ground truth
the 3 theta
sequence of images
for the quadratic
structure from motion
the coordinate system
points on the
curves in fig
three selected basis
for acquisition the
invariance with respect
errors in depth
the three selected
relative errors in
with column pivoting
representation computed by
in depth computation
in an orthonormal
basis points and
invariant shape representation
gramian can be
p of eq
qr factorization with
for model acquisition
first five frames
factorization with column
basis points i
linear and incremental
the object points
acquisition of the
selected basis points
to affine transformations
ping pong ball
a good basis
added to w
equations in 11
value decomposition of
from a sequence
a linear combination
computation of the
for the linear
and motion from
dimensional coordinates of
all the frames
this linear system
matrix p of
the reference point
transformation between the
images used for
to model matching
three dimensional coordinates
the image measurements
image to model
of eq 5
points i j
points can be
in the coordinate
reported in 25
computed by our
with respect to
a random sequence
used for model
ground truth data
the first five
of the affine
the object the
the points in
shape and motion
from image sequences
the pose of
the columns of
is invariant with
frame of the
a 3 theta
the results with
is a linear
were used for
of the shape
by our algorithm
of three dimensional
eq 11 can
therefore weak perspective
determine the gramian
thirty frames were
eq 5 we
centered image measurements
550 to 700
pivoting to the
to compute pose
shows the trajectories
sequence is more
w b is
j inigo thomas
point and compared
new orthonormal basis
from the singular
logarithmic scale the
linear criterion the
shape matrix and
and isotropic scaling
transformations that is
discrimination ratio 1
fig 2b and
criterion the situation
because of centering
the quadratic and
lend themselves favorably
unlike most algorithms
the computed gramian
let w t
z real we
coordinates of points
13 to 33
curve uses the
column pivoting to
rigid invar aff
all its columns
invar aff invar
the points themselves
model matching measure
simple linear algorithm
compute a depth
compute a similarity
basis the solid
the row subscripts
without camera calibration
from 13 to
first frame ranged
invariant algorithm for
large perspective distortions
ratio 1 6
pt pose rigid
centered image measurement
to 700 mms
sequence discussed in
ratio true random
the dashed curve
unfamiliar views are
w b of
wide lens camera
the new orthonormal
theta 3 identity
random sequence for
algorithms our algorithm

corpus/krapavin2000-test/628687.txt
modal
strain
wrench
correspondences
deformations
eigenmodes
modes
shape
prototype
shapes
stiffness
deformation
mode
align
energy
eigenvectors
displacements
correspondence
displacement
hammer
mass
recognition
nonrigid
feature
amplitudes
bent
interpolation
contour
image
rigid
silhouette
deformable
alignment
matching
fem
affinity
elastic
warp
material
airplane
wrenches
matched
equilibrium
airplanes
galerkin
matrix
nodal
body
vision
frequency
strongest
affinities
coordinate
ended
vibration
planes
ik
interpolants
matrices
rotation
silhouettes
wing
deforming
jl
unmatched
defor
recovered
images
eigenmode
viewpoints
descriptions
morphing
canonical
orientation
phi
eigen
deform
damping
features
dickinson
saab
match
stretched
object
aligned
parameterization
viewpoint
sven
brady
physically
resolution
symmetry
strains
hammers
distinctiveness
ght
shokoufandeh
eigenshapes
similarity
intelligence
sampling
springs
views
tools
shapiro
surface
conforming
gaussians
aa
noise
physical
mations
eigenspace
karhunen
kl
recovering
generalized
2d
quaternion
cloud
pear
gaussian
oe
principal
matches
objects
aligning
loads
discarding
vectors
clouds
percent
describing
terpolants
tilted
macrini
fuselage
cub
crescent
orthonormalized
eigendecomposition
regroup
piper
eigensnakes
cars
locations
reliably
ject
distinctive
eq
rotations
formulation
proximity
polar
signature
fig
bb
forces
eigenproblem
volkswagen
siddiqi
thinned
surgery
kaleem
nonconforming
truncation
tracking
retrieval
centroid
ali
tog
interpolated
centered
amplitude
invariant
appearance
virtual
upright
hough
dobkin
inertia
vw
isoparametric
graphics
columns
3d
rotated
dy
motion
dimensionality
finger
funkhouser
snake
deforms
weigh
eve
hancock
sclaroff
spring
extracted
strain energy
the modal
feature points
finite element
the prototype
correspondences are
the strain
modal matching
to align
modal strain
low order
of feature
the correspondences
mode amplitudes
mode shape
frequency modes
a ik
similar shapes
and stiffness
modal deformations
bent wrench
modal displacements
order modes
rigid body
stiffness matrices
each mode
mass and
body modes
prototype wrench
canonical descriptions
hand tools
points were
the finite
coordinate system
the eigenvectors
of modal
contour points
ik a
a jl
align the
elastic body
the eigenmodes
nonrigid modes
each tool
wrench and
interpolation matrix
machine intelligence
on pattern
pattern analysis
deformations that
correspondences were
this figure
most similar
feature point
object recognition
a prototype
computed for
the material
physically based
the rigid
and machine
intelligence v
other tools
feature correspondences
the feature
wrench with
two planes
the wrench
deformations from
strongest corresponding
generalized feature
two similar
displacement at
the hammer
this modal
modes are
eigenvectors of
higher frequency
the strongest
each image
of deformations
interpolation functions
warp the
oe i
stiffness and
affinity matrix
and mass
element model
prototype to
energy needed
feature data
of displacement
the shape
shape functions
shapes can
points only
stiffness matrix
the nodal
shapes are
computer vision
correspondences between
of shape
shape vector
modal deformation
mode number
of vibration
mass matrices
single ended
modes computed
silhouettes were
nodal point
shape vectors
simple physical
displacements u
of mode
from deforming
shapiro and
two percent
eigenmodes are
modes describe
ended wrench
non rigid
feature locations
of features
the displacement
correspondence and
shape description
the mode
recognition and
prototype object
and brady
the affinity
different hand
material properties
deforming the
body centered
modes were
the matched
object s
each feature
the features
the bent
to warp
deformations and
next most
energy to
were computed
the interpolation
understanding v
and recognition
k l
the deformations
two shapes
lower resolution
energy that
tools the
the low
analysis and
the correspondence
image understanding
high frequency
2 d
higher resolution
low frequency
different views
data points
percent of
5 mode
number amplitude
interpolated modal
large rotations
element nodes
frequency ordered
target airplanes
eigenvectors are
aligned prototype
modes z
loads r
first 22
s generalized
top points
feature connectivity
ali shokoufandeh
prototype with
displacement signature
modal matrix
modes this
ended wrenches
silhouette correspondences
material matrix
intermediate deformations
equilibrium problem
silhouette points
unmatched nodes
tree shapes
eigenvectors oe
different planes
hammer and
our shape
each modal
of feature points
needed to align
modal strain energy
the finite element
mass and stiffness
and stiffness matrices
ik a jl
rigid body modes
higher frequency modes
l a ik
correspondences are shown
a ik a
to align the
k l a
analysis and machine
pattern analysis and
transactions on pattern
on pattern analysis
machine intelligence v
and machine intelligence
the modal strain
the strain energy
of the correspondences
the correspondences are
the rigid body
the low order
the two planes
align the two
stiffness and mass
low order modes
warp the prototype
the eigenvectors of
finite element model
the prototype to
number of feature
energy needed to
shapes can be
each tool is
to each tool
prototype to each
the modal displacements
data points only
strain energy in
mode shape vector
the other tools
used in building
frequency of vibration
frequency modes describe
only two percent
two percent of
shown below each
the bent wrench
energy that results
shapiro and brady
the strongest corresponding
modes computed for
tool is shown
terms of modal
strain energy that
deforming the prototype
and mass matrices
different hand tools
onto the other
mode shape vectors
below each image
the feature points
next most similar
from deforming the
strain energy to
a prototype wrench
results from deforming
in this figure
each feature point
were computed for
for object recognition
of the finite
few of the
the most similar
g k x
matrix for the
image understanding v
of data points
and image understanding
shown in this
vision and image
percent of the
two sets of
in building the
sets of features
a few of
ieee transactions on
computer vision and
object recognition and
the two objects
silhouette correspondences were
cloud of feature
of shape deformation
terms of deformations
similar shapes are
most similar shapes
of modal deformations
ordering of shape
of the eigenvectors
the top points
displacement at the
g l x
elements of k
two dimensional problem
the higher resolution
top points on
eigenvectors oe i
5 mode number
strongest corresponding contour
feature points are
other tools the
shapes are a
the mass and
points were sampled
from a prototype
canonical descriptions for
a jl kl
form k l
deformations from a
us to recognize
direction of displacement
vector oe i
then the strongest
aligned with little
correspondences were computed
recovering the modal
global to local
contour points were
points were found
the prototype with
i th mode
energy to compare
the first 22
ordered by increasing
element model the
for correspondence and
correspondences are found
corresponding contour points
the elastic body
wrench and the
prototype onto the
with different hand
finite element nodes
bent wrench and
to local ordering
each mode shape
mode number amplitude
correspondence and recognition
body modes of
the object s
the i th
on the two
the large number
in terms of
using the first
of the shape
finite element method
a very different
the material properties
each image we
solving the dynamic
as a similarity
x g l
non rigid motion
eigenvectors of the
local ordering of
is shown below
of the large
computed for the
are shown in
for the full
viewed from a
of the modal
from the prototype
to warp the
feature points in
the next most
of a prototype
that results from
a very good
large number of
a 2 d
the elements of
in each image
of the strongest
the first image
c d fig
i th node
the form k
the two trees
allows us to
oe i is
the first three
number of data
closed form solution
for a two

corpus/krapavin2000-test/628688.txt
da
fl
discontinuities
smoothness
regularizer
lp
smoothing
regularization
mrf
euler
discontinuity
energy
regularizers
aifs
ff
jjj
membrane
aif
adaptive
interaction
derivative
vision
oversmoothing
convex
priors
continuity
apf
wn
convexity
anisotropic
quadratic
apfs
defects
ill
pami
diffusion
posed
1fl
regularizing
noise
band
strength
ihi
dx
minimization
derivatives
slopes
analog
jf
continuous
gnc
2fl
deltaff
continuities
synaptic
lim
586
576
neighboring
2d
image
irregularities
roof
restoration
fig
blake
piecewise
posterior
temperature
clique
jg
pavlidis
inadequacy
sigma25
shah
ffid
thicker
stability
regularized
gibbs
string
continuously
vol
1g
triangles
fi
approximated
yy
thinner
geman
conductance
hopfield
ffif
girosi
flip
gradient
li
pp
markov
potential
whereby
differentiability
steep
mrfs
zisserman
leclerc
f0
weak
annealing
bands
reconstruction
analytic
xy
descent
mumford
penalized
abrupt
circuit
nonzero
monotonically
neighborhood
stable
images
jh
priori
penalty
closeness
field
weighting
simulated
instantiates
geiger
spacing
stochastic
un
everywhere
intelligence
delta
potentials
adaptivity
pixels
realizes
1995
dis
diagonal
signal
boundary
directions
neurons
missing
encoded
updating
xm
isotropic
preserving
eq
differentiable
variational
piece
spaced
robust
solid
convergence
constrained
discrete
white
pyramid
equilibrium
manufacturing
spatially
prescribed
parameterized
49
continuation
solutions
wile
ntu
monotony
gories
disturbances
szli
infi
deltafl
shulman
bedini
moothness
herve
soh
usingthe
rod
graduation
besl
2263
carmine
evenness
asymptote
marroquin
ntuix
oversmoothed
fiore
the da
da model
euler equation
lp model
g fl
the lp
line process
the euler
h fl
da solution
solution f
the smoothness
the energy
smoothness priors
discontinuity adaptive
fl j
wn x
fl is
the convexity
potential function
anisotropic diffusion
smoothing strength
on discontinuity
adaptive smoothness
quadratic regularizer
the adaptive
the smoothing
the interaction
data d
smoothness constraint
h ff
priors in
process variables
at discontinuities
neighboring points
ill posed
regularization models
interaction function
the solution
of discontinuities
the quadratic
energy function
u f
li on
un f
g 1fl
pami 17
vol pami
as jjj
17 no
adaptive interaction
586 june
576 586
regularization model
aifs the
component defects
intelligence vol
of aifs
smoothing at
discontinuities where
network circuit
pp 576
between neighboring
the derivative
convexity of
the regularization
f 0
computer vision
the band
f ff
stable to
in parameters
with discontinuities
jg 0
defects are
a convex
1 continuous
regularization and
such noise
the line
in computer
mean field
no 6
6 pp
c 1
posed problems
interaction between
model is
band b
ihi fl
adaptive string
to discontinuities
1fl is
mrf model
functions aifs
the regularizer
corresponding energy
string model
the irregularities
jjj increases
but bounded
and roof
a gnc
equation constrained
interaction functions
jf n
bounded slopes
roof edges
current i
solutions obtained
june 1995
f n
fl the
ff j
is stable
ff the
necessary condition
without such
directions are
machine intelligence
l i
potential functions
in mrf
d dx
continuous nature
continuous domain
smoothness term
dis continuities
analog network
to smoothing
b fl
neighborhood system
mrf models
solution is
pattern analysis
on pattern
markov random
h f
the continuity
piece wise
on 2d
term u
the approximated
field theory
equation 25
a discontinuity
g ff
be adaptive
j d
n x
i 0
discontinuities the
constrained by
f0 1g
and machine
solid lines
lp solution
delta function
0 ff
discontinuities in
variables l
robust statistics
fl 2
to changes
e f
derivatives in
is piecewise
large but
energy minimization
ff x
fl 0
an energy
the data
leads to
adaptive to
obtained with
encoded into
global minimum
the analog
ideal signal
when jf
g 2fl
finite fi
2 ihi
wise constant
and shah
and pavlidis
gnc like
process potential
and membrane
to oversmoothing
associated euler
solution depends
binary line
regularizing the
in thinner
the membrane
empirically chosen
priori smoothness
constraint encoded
the da model
the euler equation
the lp model
the da solution
of the da
da model is
the line process
the solution f
adaptive smoothness priors
on discontinuity adaptive
discontinuity adaptive smoothness
line process variables
priors in computer
smoothness priors in
in computer vision
the quadratic regularizer
interaction between neighboring
li on discontinuity
the smoothing strength
g fl j
the smoothness constraint
the data d
between neighboring points
in the lp
the convexity of
g fl is
6 pp 576
without such noise
machine intelligence vol
586 june 1995
vol pami 17
17 no 6
576 586 june
solutions obtained with
than the lp
is stable to
of g fl
pp 576 586
intelligence vol pami
pami 17 no
model is defined
of the euler
no 6 pp
c 1 continuous
ill posed problems
for the adaptive
f n x
0 ff x
the corresponding energy
equation constrained by
interaction functions aifs
adaptive interaction functions
stable to changes
euler equation 25
convexity of e
of adaptive interaction
the network circuit
and roof edges
large but bounded
h fl 2
that the da
euler equation constrained
da solution is
potential function g
but bounded slopes
current i i
lp model the
model the interaction
to be adaptive
as jjj increases
changes in parameters
data d is
at discontinuities where
u f j
1fl is used
necessary condition is
adaptive to discontinuities
for the da
smoothing at discontinuities
in parameters and
g 1fl is
transactions on pattern
analysis and machine
and machine intelligence
pattern analysis and
on pattern analysis
i i 0
the energy minimization
fl is defined
a continuous domain
be adaptive to
variables l i
the smoothness term
arbitrarily large but
f j d
g f n
on a continuous
mean field theory
derivatives in the
it is stable
class of adaptive
to changes in
the interaction is
of the analog
2 c 1
the global minimum
the solution is
stability of the
wn x can
an important necessary
this demonstrates not
in thinner solid
aifs the corresponding
lp model which
adding sigma25 evenly
random fields mrfs
ihi fl is
jf 0 ff
defects such as
d is shown
the corresponding apfs
class of aifs
priori smoothness constraint
as j increases
the band the
solution f to
uniformly spaced points
process potential function
interaction is piecewise
for regularizing ill
the uniform smoothness
lines the ideal
introduce a parameter
simulated by adding
distributed random noise
into r c
energy function e
fl is chosen
anisotropic diffusion 16
ffif ff with
at i is
which are indicated
euler equation associated
ff f 0
corresponding apfs and
dis continuities the
h ff j
mumford and shah
such noise this
line process variable
in 55 the
oversmoothing at discontinuities
difference between different
using the hopfield
a priori smoothness
controlling the interaction
the smoothness and
f measures the
minimizing the corresponding
functions aifs the
smoothness constraint encoded
shown in dashed
quality changes etc
evenly distributed random
line process potential
term u f
mrf model by
simulated component defects
however the da
for discrete problems
spaced points x
exponential g 1fl
the cost caused
obtained with simulated
h ff f
when jf 0
in triangles with
as manufacturing inadequacy
noise this demonstrates
solution f ff
error tolerance property
neighborhood system the
is white gaussian
indicated by triangles
component defects are
empirically chosen as
gaussian with standard
allows bounded but
smoothness constraint is
as the line
the variation ffif
noise shown in
shown in thinner
neighboring points and
different models lies
and vertical directions
gnc like algorithm
triangles with 50
smoothness term u
signal is shown

corpus/krapavin2000-test/628710.txt
trilinear
views
epipolar
projective
coefficients
homographies
affine
homography
orthographic
pixels
camera
recovering
3d
seven
motion
image
projection
shashua
recognition
plane
bilinear
geometry
trilinearity
amnon
perspective
epipoles
recovered
correspondences
vision
squares
scene
uncalibrated
multiples
bca
reconstruction
nine
cameras
across
quan
eight
noise
intersection
planes
visual
invariants
00
projected
intelligence
matrices
displacement
alignment
coordinates
collinear
novel
maximal
linearly
avidan
reprojection
lefthand
navab
recover
frame
algebraic
scalar
tensors
lens
columns
correspondence
equations
tensor
object
images
righthand
centers
tri
compatible
fundamental
stereo
gideon
luong
nassir
funding
2d
trials
occlusions
geometries
error
onto
display
calibration
matrix
pgl
ortho
tele
epipole
coming
shape
hypersurface
coplanar
n00014
recogni
intertwined
singular
averaged
ronald
stein
shai
frames
metric
scale
ambiguities
imaging
laboratory
reference
125
lemma
auxiliary
ignoring
undergo
focal
invariant
scaled
infinity
rigid
dealt
gamma1
robustness
cv
equating
re
pin
sender
pixel
uniqueness
biological
regularities
graphic
ff
curved
emphasized
triplet
phi
sensitive
1d
multiplying
ground
38
surfaces
cubic
163
hole
center
my
canonical
self
combination
projecting
chung
configuration
configurations
behaved
mourrain
lowed
strm
4038
devi
gln
oliensis
sugimoto
funda
alignmentyielding
torfi
1dretinal
jianbo
0385
ortn
marugame
9217041
strum
yanlin
bilin
sminchisescu
hayman
hartley
meridian
sturtz
mutsumi
asingle
velten
vince
cartridges
thrhallsson
mirko
bilinearity
heyden
738
oskarsson
orthographically
1191
kalle
re projection
corresponding points
three views
the trilinear
the epipolar
trilinear functions
epipolar intersection
model views
epipolar geometry
points across
maximal error
linear solution
reference views
seven points
the coefficients
average error
views of
re projected
34 points
two reference
perspective views
for recovering
views are
novel view
orthographic views
across three
pixels and
fundamental matrices
linear combination
trilinear result
third view
scale compatible
projection error
image coordinates
of views
structure from
recovering the
vision v
visual recognition
machine intelligence
trilinear forms
v 00
the homography
amnon shashua
on pattern
pattern analysis
eight points
7 pixels
of trilinear
intersection method
homographies from
linearly independent
points were
error is
and average
multiples of
of re
and machine
intelligence v
are multiples
both equations
image noise
scalar s
least squares
algebraic functions
two model
from motion
views the
whose columns
the linear
a trilinear
seven corresponding
all 34
relative affine
trilinear form
the trilinearity
combination method
17 parameters
view 3
v 0
views and
across the
linear least
a linear
the fundamental
computer vision
columns are
non metric
fundamental matrix
coefficients were
gamma1 h
were recovered
minimal configuration
of corresponding
are linearly
of image
reconstruction from
of points
affine structure
parallel projection
of seven
projection using
of v
points that
by 38
3d reconstruction
points are
minimal number
a scalar
the correspondences
were used
these functions
coefficients of
the three
homography from
two orthographic
trilinearity result
perspective view
lefthand display
maximal re
coefficients up
any plane
camera transformation
self occlusions
any perspective
coefficients ff
error averaged
10 points
righthand display
average re
eight corresponding
three perspective
bca gamma1
recovered linearly
be scale
nine trilinear
trilinear coefficients
3 pixels
correspondences across
via alignment
to recover
x 00
in between
1 7
in 3d
international journal
from two
be recovered
views in
2 due
error of
four equations
five corresponding
of epipolar
between views
bilinear functions
scalar k
long quan
the tri
the lefthand
that satisfies
the re
analysis and
the image
to image
a scene
matrix whose
the novel
ieee transactions
two views
display the
nine points
achieve reasonable
ground plane
four corresponding
3d visual
y 00
solving for
plane is
theorem 1
the minimal
a matrix
the object
are sufficient
the maximal
using all
geometry and
views can
squares solution
affine and
geometry is
00 y
views we
4 pixels
functions of
journal of
22 n
v 22
coming from
3 be
the three views
the epipolar geometry
corresponding points across
across the three
points across the
and average error
the linear combination
multiples of v
pixels and average
the trilinear functions
two reference views
of re projection
a linear solution
re projection error
the trilinear result
across three views
average error is
the epipolar intersection
of corresponding points
of the trilinear
transactions on pattern
on pattern analysis
analysis and machine
and machine intelligence
machine intelligence v
pattern analysis and
for recovering the
three views are
epipolar intersection method
exists a scalar
columns are multiples
views of an
the fundamental matrices
of v 00
number of corresponding
maximal error is
two model views
are multiples of
computer vision v
of computer vision
points were used
for the coefficients
structure from motion
whose columns are
for a linear
7 2 due
the two reference
corresponding points are
trilinear functions of
all 34 points
linear combination method
seven corresponding points
re projection using
using the trilinear
linear least squares
international journal of
the minimal number
a scalar s
methods for recovering
a novel view
1 7 2
journal of computer
number of points
views of a
are linearly independent
the coefficients of
for solving for
a matrix whose
matrix whose columns
solving for the
minimal number of
ieee transactions on
points that were
can be recovered
intelligence v 22
problem of re
the righthand display
be scale compatible
trilinear functions are
all three views
the maximal re
recovering the fundamental
4 pixels and
reference views in
bca gamma1 h
to image noise
three perspective views
the homography from
pair of trilinear
any perspective view
eight corresponding points
used for recovering
four corresponding points
the model views
the lefthand display
average re projection
functions are linearly
coefficients up to
coefficients were recovered
the trilinearity result
7 pixels and
maximal re projection
be recovered linearly
epipolar intersection and
two orthographic views
projection error averaged
maximal error of
functions of views
presence of errors
the re projected
the average re
model views of
epipolar geometry is
points across three
third view 3
the maximal error
homographies from 1
in the lefthand
functions of image
be re projected
five corresponding points
from 1 7
perspective views of
the 17 parameters
linear combination of
2 due to
of the object
were used for
is a matrix
of image coordinates
the ground plane
x 00 y
intersection and the
in the righthand
the fundamental matrix
minimal configuration of
average error of
in 3d visual
00 y 00
and the linear
to achieve reasonable
of p 00
image coordinates of
need to recover
the corresponding points
on the minimal
v 22 n
of theorem 1
coefficients of the
to recover the
graph on the
least squares solution
up to a
sufficient for a
of an object
the first frame
are sufficient for
of v 0
at most four
the first four
solve for the
in the presence
of a scene
a least squares
the graph on
eight points for
were recovered using
of the multiples
a bilinear function
obtain 3 a
the existence part
projective space p
of two reference
the eight or
of seven points
a common scale
affine and projective
coefficients identical across
using all 34
the trilinear coefficients
case v 0
projective structure from
calibration of a
views and the
combination of views
the first view
one can manipulate
errors in image
for biological computational
linear combination methods
in the trilinearity
shai avidan amnon
relative affine invariant
can manipulate views
intelligence laboratory and
of algebraic functions
three corresponding points
a relative affine
to be scale
each degree of

corpus/krapavin2000-test/628731.txt
acoustic
scores
speaker
classifiers
recognition
classifier
identification
face
score
speech
voice
eyes
interocular
eye
codebook
training
rejection
hyperbf
codebooks
mouth
person
rank
nose
integration
stranger
correlation
cues
utterance
eqn
visual
normalization
ranks
reject
database
biometric
interactions
image
normalized
utterances
signal
images
misrecog
strangers
tanh
rejected
speakers
subsystems
adaptation
familiar
estimators
integrated
measurement
session
regions
lip
deviation
features
confidence
utter
irst
cepstrum
templates
digitized
multimodal
people
candidates
sessions
quantization
recordings
mel
interacted
digit
oe
accepted
variations
static
outputs
persons
im
vectors
rejecting
illumination
ff
dispersion
vq
matching
accept
164
couples
interacting
verification
similarity
acquisition
frontal
anil
entries
letters
axis
vision
semispace
grabber
favouring
hampel
brunelli
intraspeaker
misrecognized
troids
hernndez
mfccs
kwat
1915
spectrum
reported
facial
fusion
filter
geometric
acceptance
robust
mapping
threshold
reliable
rankings
spectra
jain
mad
eqns
biometrics
pupils
1905
recognizer
dat
abidi
digits
intensity
hamming
geometrical
frame
symmetry
pixels
distance
waveforms
phonetic
negatives
scribed
independence
bank
scale
distances
interaction
authentication
text
psi
gaussian
finger
transitional
recog
unimodal
bivariate
cen
samples
thereby
audio
ij
sounds
noise
lying
plane
evaluated
ross
estimate
hybrid
fs
spectral
match
adapted
sigmoidal
acquired
energy
reference
distributions
weighted
normalize
median
ro
luis
arun
perceptron
lighting
fig
stochastic
security
delta
location
separation
channel
users
centroids
gang
template
the acoustic
face recognition
acoustic and
the scores
the speaker
speaker recognition
measurement level
identification system
recognition systems
of scores
acoustic features
linear classifier
the interocular
and mouth
and visual
nose and
integrated score
normalized scores
hyperbf network
the identification
the integrated
eyes nose
and face
geometric average
the database
the eye
scores are
multiple classifier
reference database
an hyperbf
speaker and
interocular distance
best candidates
the integration
the speech
total error
correlation values
familiar rejected
person identification
the training
recognition system
the eyes
accept reject
multiple classifiers
the score
the system
reported in
recognition letters
the classifiers
integration of
stranger accepted
speech signal
rank measurement
real interactions
background noise
familiar misrecog
adaptation vectors
weighted geometric
user face
multiple cues
0 familiar
reject rule
the rejection
best candidate
for face
system performance
pattern recognition
the adaptation
features used
the face
the image
is reported
the classifier
interval 0
classifiers and
single feature
of classifiers
scores is
and voice
scores and
database entries
the normalized
face and
vector quantization
training and
letters v
the rank
input signal
reported experiments
visual features
an identification
of eqn
rank correlation
right eye
normalization of
the user
a person
outputs of
standard deviation
then be
the confidence
average and
text independent
hybrid rank
second final
acquisition channel
test sessions
normalized ratio
dynamic codebooks
speakers in
corresponding ranks
level integration
identification systems
digitized image
score list
score distributions
utterances of
utterance length
corresponding regions
stochastic minimization
matching scores
verification system
speaker verification
first ten
final best
rank information
acoustic analysis
the utterance
5 familiar
integration module
hamming window
eye templates
energy outputs
the reference
negative examples
static or
was used
features and
to reject
of interactions
and standard
the static
the location
training vectors
psi i
person recognition
classifier can
different classifiers
error measure
classifiers can
non acceptable
score and
symmetry axis
leave one
for speaker
system is
the measurement
higher the
the correlation
the reported
the correct
system based
the available
static and
processing v
the classification
power spectrum
correlation value
the digit
integrated system
identification is
on vector
the higher
the different
of multiple
and scale
scale and
the recognition
the features
of people
features the
each person
second best
points lying
the mapping
database the
and dynamic
a reliable
or dynamic
ranks of
different features
the rankings
learning task
by means
can then
a vector
of features
the symmetry
threshold is
rejection of
acoustic and visual
nose and mouth
of the scores
the reference database
an hyperbf network
the acoustic and
and face recognition
face recognition systems
eyes nose and
the measurement level
the speaker and
to the integration
the interocular distance
speaker and face
the integrated score
the eyes nose
the total error
pattern recognition letters
recognition letters v
in the reference
the best candidate
of the eye
the integration of
is reported in
normalization of the
and visual features
weighted geometric average
rank measurement level
of the identification
location and scale
the adaptation vectors
the user face
using an hyperbf
the linear classifier
of the interocular
a linear classifier
the reported experiments
accept reject rule
the normalized scores
interval 0 1
of the user
the database entries
the correlation values
of the correlation
into the interval
of the mapping
the interval 0
of the classifiers
can then be
in the database
of the integrated
reported in figure
the static and
and standard deviation
level the output
measurement level is
in the reported
features used in
reported experiments the
speakers in the
the eye templates
the different features
the corresponding regions
hybrid rank measurement
list of scores
the different classifiers
acoustic features and
and second final
the energy outputs
identification system based
the identification system
the first ten
of the rankings
y t n
on vector quantization
face and voice
of multiple cues
based on vector
the speech signal
the score distributions
normalized ratio of
utterances of the
second final best
final best candidates
of people in
the acoustic features
and rank information
at the measurement
set of classifiers
a weighted geometric
static and dynamic
the higher the
system based on
training and test
mapping from the
reported in table
of the first
the scores are
of the speaker
a learning task
from the score
average and standard
the features used
leave one out
of multiple classifiers
of the best
by means of
the power spectrum
people in the
for face recognition
static or dynamic
is applied to
for the integration
n 16 p
using a weighted
output is a
match with the
ranks of the
number of people
applied to the
of the available
are reported in
the database the
given by the
derived from the
performance is evaluated
spectrum of the
of the face
the l 1
the system is
the equation above
the vectors of
of the known
a set of
set of examples
independence of the
in table iii
the confidence of
confidence of the
in the equation
of the image
use of multiple
of the database
follows 1 the
value of the
of the features
signal processing v
recognition systems the
user face is
for a reliable
recognition sub system
correlation values the
visual ones provide
recognition system based
are combined using
the speaker recognition
the rank correlation
to adapt session
integration of multiple
0 familiar misrecog
a leave one
and mouth regions
the eye to
defined in eqn
is approximated using
translated scaled and
of acceptable and
robust statistical techniques
corresponding features of
speaker recognition system
the same coordinates
classifiers and their
functions classifiers pattern
plane contribute with
of the acoustic
2005 r brunelli
rejecting a user
template matching process
the nose and
then be quantified
accepted or rejected
based on acoustic
integrated score the
1905 1915 december
s2 represent the
turn for testing
user as unknown
brunelli verification through
best integrated score
total error is
two best scores
rank information derived
a person identification
person identification using
lists of scores
an important capability
strangers misrecognized and
the pixel level
hyperbf network a
the normalized ratio

corpus/krapavin2000-test/628733.txt
canny
operator
tangential
operators
image
curve
responses
combinators
statue
curves
continuity
discontinuities
derivatives
edge
maxima
oe
tangent
fi
vision
respond
derivative
logical
intensity
convolution
noise
nm
stabilizers
neighbourhood
response
zucker
psi
ae
gaussian
preconditions
ff
steerable
discontinuity
ending
gamman
cross
neck
edges
smooth
signal
normal
dcf
receptive
curvilinear
nearby
visual
images
xi
fig
orientations
lateral
gammag
positively
endline
michelangelo
junctions
categorize
perceptual
steven
behaviour
inflection
orientation
evidence
detectors
region
endings
koenderink
fingerprint
rising
centered
sign
dimensional
detection
convolutions
creases
ideal
eq
differentiable
spatial
00
locating
smoothing
field
peak
stable
junction
near
structural
discontinuous
contrast
differential
75i
unstabilized
striate
hildreth
conveying
confusion
linearity
coincident
regions
attenuation
lim
cartesian
gaussians
equivalences
dubuc
terminations
xii
2ffl
haralick
benoit
positives
2b
false
algebra
fulfill
boolean
drawing
verified
overshoot
751
signalled
linearities
oval
cortex
salience
filters
chin
salient
grouping
250
curvature
16b
stably
shoulder
stimulated
marr
sensitivity
crossing
gaps
negative
interfere
contour
profiles
family
exhibit
critically
extremum
intensities
folds
bifurcation
adopt
measurement
locally
confirmation
sectional
contradictory
iff
decomposing
examination
slope
stabilized
cat
revealed
complement
hypothesis
eqs
heat
contextual
criterion
pixels
symmetrically
singularities
crossings
song
early
drawings
pointwise
responding
biological
lines
noisy
deliberately
centroid
relied
rejection
around
additive
designs
zeroes
contours
detector
neural
figs
1a
213
l l
l operators
image curve
l operator
logical linear
image curves
the tangential
linear operator
the canny
the l
the operator
canny operator
linear operators
canny s
contrast line
l combinators
line ending
one dimensional
an image
negative contrast
positive responses
line operator
the curve
cross section
local maximum
step edge
end line
positive contrast
dimensional operator
operator is
image operators
the linear
the line
in fi
the image
the statue
operator responses
contrast lines
normal condition
maximum in
operator which
fi oe
linear on
l x
these operators
the normal
operators by
linear reduction
local continuity
tangential operator
edge operators
component responses
half field
b canny
oe x
steven w
w zucker
fi x
lines and
the logical
of image
xi a
maps computed
false positive
operator a
edge detection
and edges
edge maps
operators are
a local
a l
fi 0
vision v
an operator
s algorithm
operator psi
curve operators
gammag 00
derivative fi
curve types
gamman 3
of statue
dimensional operators
dimensional l
positive response
linear convolution
statue a
dimensional signal
differential structure
respond positively
line stable
the tangent
this operator
these conditions
the local
operator for
and line
operators which
the cross
see fig
computer vision
responses to
oe ae
is centered
local maxima
of operators
spatial support
positive only
receptive field
in xi
fi s
early vision
operator and
for image
near a
two dimensional
image structure
l image
normal conditions
visual system
ff is
p j
steerable filters
same scale
of l
and edge
for edges
are run
a linear
a line
linear l
noise sensitivity
l edge
l combination
is end
and junctions
dcf of
operator will
the chin
inflection points
line endings
signal fi
tangential and
structural preconditions
convolution by
line drawing
slope above
line like
line detectors
curve ff
00 oe
image line
linear combinators
responses represent
and tangential
a rising
operator should
operators both
perceptual grouping
ae approximate
a positive
continuity of
of curve
curves is
ff s
second derivative
the cartesian
derivatives of
centered on
ae x
conditions are
a negative
the derivative
the step
edge and
operators is
the neighbourhood
neighbourhood of
zero crossing
structural conditions
combinators are
measurement operators
and neck
the stabilizers
between nearby
boolean algebra
minimal polynomials
crossing of
operators for
b figure
evidence for
the intensity
and normal
responses the
curves which
discontinuities and
additive gaussian
iff ff
revealed by
positively in
the l l
l l operators
l l operator
the canny operator
an image curve
l l combinators
canny s algorithm
lines and edges
maximum in fi
a l l
the linear operator
local maximum in
one dimensional operator
of l l
the operator is
false positive responses
the line ending
positive contrast line
and edge maps
b canny s
by b canny
contrast line operator
maps computed by
the local continuity
edge maps computed
of the operator
steven w zucker
a local maximum
of the curve
computed by b
f p j
the one dimensional
a one dimensional
computer vision v
operator is centered
negative contrast line
image curve operators
a positive response
negative contrast lines
are run at
end line stable
a logical linear
image curves is
of image curves
local continuity of
spatial support of
in fi oe
edge and line
of statue a
the linear reduction
dimensional l l
l l image
one dimensional signal
the logical linear
oe ae x
the tangential operator
of computer vision
of an image
algorithms are run
g i g
an operator which
algorithm and c
f l x
the cross section
that the l
for the existence
run at the
and c l
the same scale
s algorithm and
ff is an
international journal of
in the image
in the neighbourhood
c l l
journal of computer
i g i
the neighbourhood of
in xi a
image curve with
logical linear combinators
linear reduction of
0 oe x
l operator psi
the normal condition
l operators both
signal fi x
with the canny
operators both algorithms
normal and tangential
two dimensional operators
detail of statue
zero crossing of
of l x
of these operators
l l edge
logical linear operators
the component responses
also a local
l l combination
one dimensional l
of logical linear
statue a from
i iff ff
logical linear l
is end line
for image curves
the spatial support
linear l l
dcf of l
positive responses to
iff ff is
curve with normal
near a step
a negative contrast
derivative fi 0
the derivative fi
positive only if
both algorithms are
cartesian product of
on f p
is linear on
for early vision
in i iff
by the line
p j x
the cartesian product
the visual system
a linear operator
on the image
of the l
have the effect
expressed as the
centered on the
a linear combination
analysis and machine
pattern analysis and
and machine intelligence
transactions on pattern
on pattern analysis
machine intelligence v
the two dimensional
in b the
operator which is
of these conditions
l l and
is an image
1 p 5
that the linear
of the local
these conditions are
support of the
b c figure
intensity variation along
linear on f
operator responses represent
the tangent s
confusion between lines
g 00 operators
of xii a
i the curve
for predictable behaviour
l operators are
of two g
for edge detection
show the edge
low order differential
maxima in a
line endings the
depends critically on
measurement operators for
be positive only
tangent t i
sense of three
the following equivalences
confusion and perceptual
at a line
independent orientations in
the tangent and
steerable filters for
positive response only
oval in each
positive operator responses
is r where
250 250 751
and negative contrast
zucker complexity confusion
convolution by g
requires that both
line operator should
dimensional operator for
each l l
and canny 2
kinds of image
linear operator which
fi 0 oe
one dimensional normal
operator s response
expected image structure
minimal polynomial p

corpus/krapavin2000-test/628753.txt
symmetry
mirror
centroid
shape
symmetries
symmetric
folding
occluded
reflection
shapes
cn
contour
3d
sd
plane
folded
center
focals
2d
image
interlaced
measurements
quad
angular
transform
probable
rotational
chirality
orientation
axis
radians
distance
reconstruction
images
closest
fp
angles
fig
symmetrical
selection
smoothing
quadrant
configuration
marked
flowers
jerusalem
multiresolution
rotated
grey
origin
hel
sensed
averaging
regions
rotation
quadrants
skewed
smoothed
orbit
continuous
21a
focal
cos
recognition
neighborhood
locations
visual
sin
arm
perfectly
vision
detection
dn
orbits
locally
averaged
unfolding
minimization
axes
grasping
unfold
frontal
circular
marola
symme
tuzikov
91904
busyness
gilat
pled
chiral
symmetropy
seperately
avnir
planes
p0
reflective
resolution
obtaining
appendix
sampled
derivations
location
phi
deviation
digitization
laue
crystals
attentive
18a
hebrew
unoccluded
squared
polygon
uncertain
tog
radial
object
patch
handed
reflecting
dark
distances
geometric
projected
planar
noisy
szymon
funkhouser
l6
guiding
perpendicular
objects
analytic
perceived
rotating
shortening
elevation
photograph
evaluating
mass
rusinkiewicz
iii
measurement
farthest
groups
pattern
rectangles
probability
intelligence
graphics
faces
robust
sampling
variance
unfolded
kun
divisions
guess
measuring
recomputed
gamman
feature
coefficient
finding
uncertainty
multipliers
israel
onto
group
yang
contours
expanded
sam
38
lagrange
reconstructing
criterion
occlusion
vi
division
inverted
normalization
perception
derivation
27d
guibas
niloy
21b
metries
normalizefig
colliot
402fig
lytical
breckon
organic
densityfig
zavidovique
terefrence
yossi
the symmetry
symmetry distance
of symmetry
mirror symmetry
symmetry transform
the centroid
symmetric shape
symmetry of
center of
a shape
reflection plane
the folding
centroid of
symmetry group
cn symmetry
the center
selection about
folding method
symmetry is
at equal
locally symmetric
symmetric regions
occluded shape
angular selection
equal angles
of points
shape is
the points
the mirror
symmetry value
closest symmetric
quad tree
symmetry in
selection at
distance value
probability distribution
cn symmetric
symmetry focals
symmetric configuration
transform of
most probable
the shape
the sd
continuous symmetry
symmetry axis
a original
3d object
symmetry and
n points
probable symmetric
continuous feature
shape p
the cn
an occluded
using angular
the contour
symmetry as
shapes and
distance values
original shape
points are
symmetry detection
points fp
symmetries in
the reflection
a 2d
the quad
dn symmetry
3d mirror
mirror axis
3 symmetry
mirror symmetric
symmetry map
g symmetry
the image
shape using
symmetries of
symmetry groups
points is
order n
of selection
original image
in 2d
about the
measured points
radians about
of occluded
of mirror
of symmetries
points a
d fig
section iii
a symmetry
the folded
symmetric shapes
points selected
q sets
the closest
configuration of
symmetry c
angles about
symmetry focal
equal distances
symmetry d
occluded shapes
folded points
perfectly symmetric
n radians
symmetry has
distance sd
multiresolution scheme
expected location
distribution of
points i
about which
b c
the measurements
reconstruction of
c d
shape by
we minimize
in images
points about
rotational symmetry
resolution image
of measurements
low resolution
symmetry the
in 38
i 0
marked as
of order
sd of
point symmetry
the occluded
a reflection
selected at
of shapes
the 3d
symmetry for
point about
c 3
of symmetric
a continuous
into q
fp i
a b
the origin
orientation of
symmetric 3d
sd values
single shape
average point
given shape
shape represented
finding locally
almost symmetric
measuring symmetry
circular symmetry
mirror symmetries
rotational symmetries
2d polygon
face orientation
averaged point
symmetry if
continuous contour
angular intervals
or occluded
sensed points
values denote
obtaining f
by reflecting
finite symmetry
occluded flowers
symmetric region
minimum symmetry
symmetries and
frontal vertical
hel or
symmetry measure
sampled points
possible reflection
contour at
local symmetries
vertical view
image quadrant
figure 21a
symmetry measures
folded measurements
symmetry content
different symmetries
location of
value obtained
a mirror
shape with
detection of
closest to
marked by
are selected
the g
the symmetry distance
center of symmetry
of the symmetry
of a shape
the symmetry transform
about the centroid
the centroid of
the center of
symmetry transform of
about the center
the folding method
selection about the
of symmetry of
the mirror symmetry
centroid of the
at equal angles
symmetry distance value
angular selection about
the closest symmetric
probability distribution of
the most probable
locally symmetric regions
symmetry distance values
symmetry of a
symmetry of order
of n points
a continuous feature
most probable symmetric
distribution of symmetry
the symmetric shape
using angular selection
selection at equal
an occluded shape
center of selection
of the shape
of order n
of the measurements
the quad tree
the symmetry value
c 3 symmetry
shape using angular
3d mirror symmetry
symmetry as a
the original shape
the probability distribution
a b c
of the points
points are selected
as a continuous
c d fig
transform of a
in section iii
along the contour
of symmetry in
evaluating the symmetry
closest symmetric shape
a original image
point about which
symmetry group g
angles about the
mirror symmetry is
a shape p
of symmetry distance
i n radians
equal angles about
of mirror symmetry
the g symmetry
original image b
the reflection plane
that point about
mirror symmetry transform
selected at equal
symmetric regions in
amount of symmetry
of the quad
symmetric shape using
points selected at
symmetry has been
symmetry distance sd
b c d
sets of n
of the image
configuration of points
a 3d object
of symmetry and
radians about the
a shape is
regions in images
r t g
shapes and the
by 2 i
set of measurements
the symmetry of
it is invariant
b c fig
the shape is
at the origin
in any dimension
of an occluded
to any finite
the average point
shapes and objects
frontal vertical view
distance sd of
3d object is
noting that r
symmetric configuration of
of occluded shapes
a single shape
points i 0
the 3d object
measurement q i
amount of different
symmetry of different
orientation of symmetric
a symmetric shape
of different symmetries
obtaining a single
a frontal vertical
order n the
under the maximum
reflection plane the
c the closest
the image quadrant
section iii for
rotational symmetry of
shape represented by
different symmetries of
the expected location
the folded points
and the centroid
of symmetries in
gamma1 i 0
probable symmetric shape
mirror symmetry axis
a shape represented
d e fig
g symmetry group
the cn symmetric
symmetry transform 1
algorithm for deriving
a 2d object
expected location of
the cn symmetry
define the symmetry
distance value as
finite symmetry group
a given shape
folding method as
the symmetry map
cn symmetric configuration
a 2d polygon
each measurement q
marked by phi
finding locally symmetric
at equal distances
deriving the symmetry
low resolution image
maximum likelihood criterion
symmetric set of
symmetry transform for
n gamma1 i
set of points
with respect to
to the given
the amount of
2 i n
of the amount
the standard deviation
the points are
transform of the
is invariant under
the symmetry axis
point symmetry group
sd of a
the n elements
an initial guess
q sets of
center of mass
of the occluded
g n gamma1
the low resolution
symmetries of a
points fp i
different shapes and
i g n
multiple of n
a configuration of
fp i g
of shapes and
of different shapes
method as described
of a 2d
types of symmetries
closest to the
points on the
described in section
as described in
that r t
and it s

corpus/krapavin2000-test/628768.txt
thermophysical
truck
scene
thermal
surface
lwir
tank
imaged
energy
invariants
hypothesized
imagery
temperature
object
image
car
steel
elemental
feature
vehicle
invariant
contextual
material
cnd
vehicles
van
radiation
recognition
separability
measurement
reflectance
hypothesis
i1
hypotheses
capacitance
i2
null
emissivity
amb
mistaken
heat
infrared
pose
thermo
visible
wheels
invariance
features
erroneous
gi
absorbed
rear
polymer
coatings
driving
separation
physics
volume
afosr
conductance
irradiation
convected
cv
scenes
determinants
metal
ti
frame
intra
vectors
conics
solar
sensed
wavelength
photometric
materials
outdoor
eqn
visual
centered
air
rad
st
absorptivity
radiative
polypropylene
radiometric
vulcanized
stability
compose
2d
deviations
images
hypothesize
geometric
surfaces
fluxes
conduction
rubber
phenomenological
conductivity
atmosphere
wind
formulation
conducted
incorrect
panels
wheel
inter
subspace
transformation
elimination
algebraic
flux
vegetation
tai
counting
lost
buildings
identity
labeled
internal
region
formed
consisted
calibrated
9g
deltax
dt
ith
infinitesimal
contract
vision
measurements
exchange
normals
objects
exploited
am
five
matrices
3d
abs
minimally
span
front
sensor
composition
derivation
vary
variation
deviation
conservation
military
illumination
alarm
spectrum
ratios
ambient
shading
orientation
histogram
circuit
interior
classifiers
freedom
diversity
precomputed
shape
establish
coordinates
reflection
stereo
unknown
relationships
pyranometer
42e5
emissive
93wl001
plastic
albany
resistances
0063
1529
91109584
mundy
66e14
season
f33615
thermally
reputed
polystyrene
9e5
dts
sheet
gramm
groundwork
uncoated
unoxidized
insolation
truck 1
the feature
the surface
the imaged
1 truck
null space
the thermal
the thermophysical
the object
feature value
space vector
thermophysical properties
imaged object
scene to
the energy
invariant features
to scene
object recognition
scene conditions
the van
correct hypothesis
four points
lwir image
contextual support
elemental volume
is hypothesized
w cnd
thermophysical model
truck 2
inter class
a 4
object class
class separation
the null
thermal capacitance
unit surface
gi s
invariant feature
image region
the elemental
one scene
measurement vector
energy exchange
of lwir
from scene
object centered
the measurement
the image
intra class
the material
physics based
a 3
4 a
surface area
for object
type i2
lwir imagery
tank tank
invariant relationships
van car
unknown vehicle
counting argument
of energy
points are
the features
n points
a car
features that
per unit
temperature of
erroneous hypotheses
thermal and
measurement matrices
real imagery
material properties
the tank
measurement vectors
volume at
ti s
points labeled
5 a
energy per
or surface
the truck
a 2
the points
features for
the hypothesized
image measurements
a van
vectors a
of point
mean value
the counting
feature is
f k
and pose
5 theta
object identity
invariant to
thermal image
of thermophysical
scene parameters
separability between
imaged surface
thermophysical algebraic
absorbed by
correctly hypothesized
like polymer
hypothesized data
t amb
driving conditions
energy absorbed
deviations away
tank van
car truck
respective other
hypothesized object
different material
incorrect hypotheses
vehicle is
hypothesis truck
feature consisted
surface reflectance
centered reference
correct hypotheses
second scene
vehicles when
mistaken hypothesis
thermophysical feature
thermophysical invariants
of truck
type feature
thermophysical approach
and surface
two point
object classes
a feature
the formulation
the car
standard deviations
surface of
and visual
invariants for
contextual knowledge
non visible
formed using
of vehicles
1 energy
other vehicles
different scenes
algebraic invariants
geometric invariants
9 am
space vectors
first scene
object properties
five points
the identify
vector j
points in
recognition the
of invariant
the correct
data from
object and
an object
linear transformation
a 1
and or
consistency constraint
2d object
materials and
feature values
that compose
eqn 8
scene are
the correctly
of object
point set
composition and
surface is
the transformation
labeled in
feature to
each view
this feature
the vehicle
physical properties
reference frame
3 a
theta 5
region r
features were
of type
computed for
properties and
r was
the temperature
the derivation
truck 1 truck
1 truck 1
of the imaged
the imaged object
null space vector
the null space
at the surface
the feature value
for object recognition
the correct hypothesis
one scene to
from one scene
by the surface
scene to scene
from scene to
per unit surface
feature of type
unit surface area
of the object
the counting argument
the elemental volume
thermal and visual
of point set
thermophysical properties of
energy per unit
and or surface
5 a 2
of the van
volume at the
4 a 2
feature value is
a 4 5
of type i2
f k r
4 a 4
4 4 a
a 2 5
2 4 a
5 a 4
of the features
a 2 4
3 a 4
for the correct
a 4 4
the surface of
of the surface
surface of the
tank tank tank
used to the
truck 1 data
to the identify
correctly hypothesized data
when this feature
scene to another
object centered reference
absorbed by the
null space vectors
tank van car
the thermal capacitance
labeled in figure
the correctly hypothesized
points labeled in
the thermal image
the measurement vector
other vehicles when
the feature consisted
hypothesis truck 1
the thermophysical feature
image measurements are
using the thermophysical
truck 1 and
respective other vehicles
to scene conditions
1 data from
van car truck
the thermophysical model
invariant to scene
deviations away from
2d object centered
and a standard
the invariant feature
of truck 1
5 a 3
consisted of point
2 9 am
truck 2 9
the imaged surface
inter class separation
energy absorbed by
standard deviations away
thermophysical model of
the truck 1
identity and pose
hypothesized data of
formed using the
value is formed
elemental volume at
to the correctly
vehicles when this
feature is applied
the respective other
the second scene
feature consisted of
of lwir imagery
image region r
a feature of
to the points
2 5 a
temperature of the
4 a 1
the points labeled
the first scene
the feature values
the measurement matrices
is formed using
1 5 a
4 a 3
the energy per
a 3 5
from the respective
of n points
to the image
of the feature
surface to the
a 1 5
a standard deviation
the surface to
to the environment
the surface is
a 1 4
has a mean
described in section
the derivation of
mean value of
points are selected
3 a 2
a mean value
a 3 4
the object the
the coordinates of
of the null
a 4 3
3 5 a
of the material
features that are
standard deviation of
3 4 a
1 4 a
coordinates of the
2 3 a
a 2 3
4 3 a
for an image
points in the
a linear transformation
used to establish
into two sets
a given object
the points are
the formulation of
body panels a
is a jth
some unknown vehicle
unknown vehicle the
four points are
car at locations
properties and or
reasonable to use
energy exchange model
space vector j
center coordinate frame
correct hypothesis hypothesis
the 5 theta
inter class separability
it makes available
3 a 1
radiative properties of
derivation of thermophysical
image actually obtained
object class k
first scene and
compose a 5
of object k
i2 used to
transforming the coordinates
measurements are obtained
given by transforming
of this 2d
the point selection
j j for
figure 1 energy
the van center
formulation of feature
truck 1 the
four vectors a
type feature used
feature f k
the imaged objects
or surface normals
from truck 1

corpus/krapavin2000-test/628779.txt
coe
cients
pose
invariants
jk
rotation
recognition
estimation
algebraic
noise
shapes
curve
conic
curves
polynomial
euclidean
guitar
shape
center
std
angle
linearcenter
ip
colored
conics
dev
translation
perturbations
missing
polynomials
invariant
cubic
hawk
butter
tting
ips
deviation
2d
deviations
silhouette
centers
mig
sky
cubics
centering
rotations
rotated
degree
cient
recognizer
descriptors
alignment
0j
subspaces
transformation
intrinsic
jj
pixels
sec
ts
arg
covariant
dierent
rst
stable
covariance
angles
angular
fig
monomials
undergone
centered
vision
scatter
percentage
orientation
deformations
perturbed
transformations
jc
radians
dened
patches
fourier
0035
pims
0045
weightings
quartics
c40
radiuses
ne
accurate
indexing
3d
variability
gaussian
realizations
coordinate
database
transformed
superquadrics
0025
3l
0015
radian
representations
degrees
200
stability
kimia
bayesian
parameterization
imaginary
translations
expansion
simplication
silhouettes
kn
estimate
implicit
diagonal
origin
species
iterated
sin
zz
iterations
dierence
discriminating
airplane
matrix
butterfly
query
careful
squared
occlusions
iterative
estimated
discrimination
homogeneous
invariance
375
preceding
benjamin
transforms
squares
noisy
geometric
deduce
benet
exploitation
binomial
splines
surfaces
training
02
followed
quadratic
05
realized
superimposed
nonlinear
curvature
occlusion
cosine
gradient
cos
normalization
2c
00
messy
unaected
tarel
rocquencourt
inaccurately
bitangeants
domaine
wolovich
unparalleled
malah
cem
ections
sizeable
drawer
shes
barzohar
coefcients
1283
nsalan
voluceau
helzer
coefficients
accuracy
turns
vectors
similarity
queries
perturbation
taylor
pose estimation
coe cients
complex representation
algebraic curve
polynomial coe
the coe
missing data
algebraic curves
c jk
the complex
the polynomial
shape recognition
t center
colored noise
th degree
the pose
coe cient
the rotation
of invariants
for pose
std dev
pose independent
sky hawk
cients of
estimation and
complete set
standard deviation
euclidean transformation
cient vector
euclidean transformations
standard deviations
implicit polynomial
rotation invariants
a conic
in sec
of degree
butter y
a jk
invariant recognition
degree polynomials
cients c
arg c
pose invariant
rotation estimation
a cubic
the angle
6 th
polynomial to
centered by
data set
c 0
the algebraic
in fig
the ip
deviation of
polynomial is
of coe
100 0
4 th
of algebraic
invariants for
2d curves
center t
independent shape
polynomial curves
deviations 0
colored gaussian
curve data
jk j
ip coe
intrinsic center
careful comparison
shape data
accurate pose
t linearcenter
noise std
euclidean center
a silhouette
the translation
sec 2
and pose
under rotation
sec 3
0 0
degree n
estimation based
fourier descriptors
jk are
invariant shape
between shapes
complex coe
fast accurate
noise and
the curve
rotation is
by rotation
jk is
curve is
a ne
and rotation
an algebraic
coordinate system
is rotated
random starting
curve at
translation and
real and
recognition and
z z
functions of
and invariant
recognition based
starting points
an ip
0 100
complex polynomial
0j k
leading form
cubic is
cients it
3d surfaces
j kn
similar std
maximum accuracy
cubics under
c jj
and cubics
relative angles
angular invariants
0 butter
complex basis
invariant object
euclidean invariants
0 sky
20 missing
noise missing
independent recognition
a colored
l jk
the conic
conics and
angle estimation
real polynomial
to euclidean
5 0
percentage of
of missing
curves and
d l
the euclidean
cients for
the transformation
rotation of
vector c
few iterations
estimation of
degree polynomial
dimensional subspaces
dev is
recognition on
are iterated
under rotations
translation estimation
expansion we
each polynomial
representation of
12 5
invariants are
under euclidean
single computation
by angle
indexing into
rotation invariant
for algebraic
5 pixels
independent invariants
c 11
f n
vector a
a 20
use all
linear functions
20 a
using all
invariant to
imaginary parts
degree 4
2d shape
and imaginary
center to
jk and
the transformed
covariance matrix
to noise
object recognition
followed by
computer vision
relative orientation
noise has
new basis
the complex representation
polynomial coe cients
the coe cients
pose estimation and
complex representation of
the polynomial coe
coe cients of
the algebraic curve
of algebraic curves
complete set of
coe cient vector
for pose estimation
an algebraic curve
coe cients c
representation of algebraic
th degree polynomials
4 th degree
6 th degree
the pose estimation
set of invariants
a complete set
all the polynomial
standard deviation of
of the polynomial
of degree n
in sec 3
fast accurate pose
independent shape recognition
100 0 0
followed by rotation
ip coe cients
the ip coe
pose independent shape
at random starting
percentage of missing
standard deviations 0
random starting points
the euclidean transformation
of the complex
cients of the
of coe cients
estimation based on
linear functions of
of missing data
a 20 a
and c 0
sec 2 2
a few iterations
of the curve
of the coordinate
all the information
of the coe
the coe cient
in the polynomial
in sec 2
recognition based on
the coordinate system
using all the
based on all
queries by example
and pose estimation
curves and 3d
pose estimation based
noise std dev
pose estimation of
noise missing data
0 100 0
dev is 0
conics and cubics
k j kn
function of increasing
cubics under rotation
d l z
the angle estimation
center t center
cient vector a
0j k j
pose independent recognition
rotation is 1
20 a 11
0 sky hawk
a cubic is
0 0 sky
2d curves and
similar std dev
of independent invariants
by rotation estimation
invariant shape recognition
a real polynomial
12 5 pixels
0 butter y
and cubics under
coe cients it
center to the
20 missing data
to euclidean transformations
of a conic
std dev is
expansion we obtain
on the coe
and 3d surfaces
coe cients for
of the rotation
deviation of the
the real and
set of independent
of a polynomial
of the translation
in the coe
the relative orientation
of invariants and
shape recognition and
shown in fig
functions of the
the data set
origin of the
and imaginary parts
deviation of 0
translation and rotation
real and imaginary
is 1 n
center of a
2 2 a
to the data
the origin of
c and c
0 0 0
e i j
6 6 6
the standard deviation
way to compute
of the angle
is invariant to
use all the
a 11 a
it turns out
percentage of the
as a percentage
the complete set
2 or 3
a percentage of
at the origin
rotation of the
comparison of aligned
jc jk j
algebraic 2d curves
data 20 missing
under euclidean transformations
std dev x
representation of ips
degree ip curves
the original polynomial
algebraic curve is
to emphasis the
jk jk t
set of rotation
emphasis the fact
moderate percentage of
0025 0035 0045
may have undergone
translated by t
values are std
proposed pose estimation
estimation between two
a conic is
sec 3 2
polynomial coe cient
the zero set
true rotation is
and invariant recognition
polynomial f n
degree functions of
and recognition can
butter y 0
using information in
error noise std
deviations 0 05
algebraic curve which
centering is invariant
with the algebraic
capture the global
having standard deviation
radiuses 2 2
200 dierent random
the euclidean center
derive a complete
system this centering
accurate pose independent
algebraic curve can
the block l
of quartics for
and pose independent
invariants for an
and after expansion
under a rotation
intrinsic center to
for an ip
the proposed pose
the rotation invariants
c jk e

corpus/krapavin2000-test/628780.txt
disparity
stereo
occluded
occlusions
tsukuba
match
inhibition
pixel
poggio
image
marr
disparities
5x5x3
occlusion
pixels
vision
ground
window
images
truth
intensity
3x3x3
camera
3d
uniqueness
7x7x3
cooperative
smooth
coal
map
dot
synthetic
baseline
scene
surface
continuity
matching
correlation
dense
gpm
stereogram
matches
neighboring
sight
intensities
mine
diffusing
binocular
squared
isometric
nakamura
detected
converged
areas
depth
discontinuities
003
mrf
maps
tower
directional
rxcxd
sloping
scharstein
delineated
diffused
zitnick
labeled
sigmoid
surfaces
iterations
902
860
rectified
oversmoothing
multiview
3x3
fronto
szeliski
84
repetitive
masking
area
averaging
incorrect
042
occluding
stereoscopic
correctly
converge
slanted
kanade
roof
bing
percentage
correspondence
scenes
black
normalized
errors
97
inhibiting
sing
fish
omni
filtered
47
foreground
00
correct
university
convergence
58
texture
adaptive
99
attempted
2d
textured
285
quantitative
array
inhibit
projective
supplied
april
98
regions
similarity
unwanted
diffusion
ordering
volumetric
distortion
continuous
iteratively
kang
resultant
plot
assumptions
detection
hirschmller
burkert
niese
degui
prez
szelski
fattening
subregioning
kanatsugu
jingli
ladendorf
cynthia
minglun
leupold
shengsheng
myron
passig
olague
burschka
smeaton
yasuaki
infection
lutton
darius
bobick
telepresence
noisiest
garibaldi
intille
evelyne
noel
2ex
jiwon
changming
stereograms
photogrammetric
someya
matting
hendriks
connor
qiuming
rooftop
periscope
consistency
update
phenomena
constraint
steven
segmentation
bi
visible
2002
dr
ohta
ayoub
margrit
gelautz
lamp
photorealistic
match values
disparity map
local support
support area
the disparity
of tsukuba
and poggio
ground truth
c r
marr and
r c
left image
disparity values
disparity space
stereo matching
right image
r d
stereo algorithm
non occluded
disparity maps
d c
truth data
the match
match value
the inhibition
random dot
initial match
correct match
inhibition constant
adaptive window
based stereo
ordering constraint
c d
normalized correlation
april june
detected occlusions
pixel r
as occluded
found correctly
update function
a stereo
multi baseline
a pixel
vision v
computer vision
occluded in
stereo image
pixels labeled
uniqueness assumption
stereo algorithms
real stereo
the ground
smooth and
stereo correspondence
stereo vision
and detailed
y r
a disparity
of sight
black areas
image pairs
values within
june 2002
stereo methods
true occlusions
3d local
by university
occluded areas
coal mine
cooperative algorithm
poggio 15
tsukuba data
support among
47 n
v 47
international journal
the uniqueness
occlusions and
depth maps
and disparity
image pair
occluded pixels
with ground
values l
our algorithm
element v
university of
the ordering
areas are
images the
u of
pixel in
each pixel
element r
squared differences
isometric plot
occlusions detected
a 5x5x3
explicitly identified
occlusion detection
camera masking
84 003
resulting disparity
false match
area black
labeled non
diffusing support
neighboring elements
reference left
dot stereogram
processing constraints
stereo images
window method
detailed disparity
synthetic random
gpm mrf
maximum match
in disparity
completely converge
stereo pair
mine scene
area sizes
occlusions found
neighboring match
log filtered
image and
values were
a cooperative
two assumptions
intensity values
b right
along similar
similar lines
global constraints
by marr
dense depth
is occluded
of disparities
of match
baseline stereo
a 3d
the window
of computer
journal of
among neighboring
quantitative comparison
to pixel
three images
image similarity
the percentage
a match
of occlusion
image c
all match
input images
and occlusion
were correct
and continuity
d denote
matching and
the university
the detected
project to
have converged
the image
percentage of
have attempted
synthetic and
uniqueness and
different local
the left
were found
sigmoid function
correctly the
values have
in areas
one pixel
of local
constant a
match between
the true
data supplied
to occluded
occlusions the
inhibition area
incorrect disparities
disparity discontinuities
poggio are
disparity relative
cooperative stereo
building attached
multiview image
oversmoothing and
assumption states
unique match
tsukuba s
labeled occluded
1 042
the coal
slanted roof
d c r
local support area
r c d
marr and poggio
c r d
r d c
the match values
university of tsukuba
ground truth data
initial match values
the ground truth
the ordering constraint
y r c
the left image
the disparity map
the inhibition constant
vision v 47
april june 2002
pixel r c
smooth and detailed
u of tsukuba
computer vision v
of computer vision
of local support
of the disparity
occluded in the
match values l
the right image
47 n 1
international journal of
in the left
journal of computer
v 47 n
the local support
and poggio 15
in the ground
with ground truth
element r c
by university of
of tsukuba data
stereo matching and
the true occlusions
poggio 15 16
the uniqueness assumption
match values within
black areas are
3d local support
the multi baseline
a correct match
values within a
using our algorithm
1 3 p
n 1 3
disparity maps are
left image b
pixels labeled non
adaptive window method
lines of sight
were found correctly
neighboring match values
the resulting disparity
are detected occlusions
based stereo methods
values l 0
synthetic random dot
and detailed disparity
non occluded in
random dot stereogram
values have converged
local support for
maximum match value
inhibition constant a
to completely converge
all match values
similar lines of
labeled non occluded
the maximum match
a reference left
uniqueness and continuity
area black areas
matching and occlusion
coal mine scene
the disparity space
the initial match
b right image
areas are detected
and occlusion detection
support area sizes
real stereo image
image b right
reference left image
right image c
isometric plot of
diffusing support among
different local support
the detected occlusions
support area black
true occlusions found
stereo image pair
of match values
found correctly the
for each pixel
the percentage of
of the detected
in areas of
along similar lines
stereo image pairs
c r r
match value is
left image and
match values and
by marr and
of the true
r c in
d denote the
the university of
in the right
r c r
synthetic and real
have attempted to
demonstrate the effectiveness
percentage of the
c r c
plot of the
can produce a
that project to
using multi baseline
window method 12
map using multi
fast stereo matching
object b in
stereo methods is
case depicted in
high match values
real stereo images
of the coal
the correct disparity
a 5x5x3 local
a stereo algorithm
three different local
3x3x3 5x5x3 and
the 3d disparity
disparity map obtained
for quantitative comparison
003 pixels labeled
the random dot
match with p
match values have
right image image
support among neighboring
continuous almost everywhere
labeled as occluded
allowed to completely
by diffusing support
area rxcxd correct
match values to
camera angles used
explicitly identified to
values l n
and a disparity
support among disparity
3x3x3 local support
s multiview image
occlusions that are
correctly as occluded
support 3x3x3 5x5x3
occlusions found for
image as illustrated
for stereo matching
unwanted smoothing in
several synthetic and
of image intensities
a 3d area
match values the
truth disparity map
of tsukuba a
dense stereo correspondence
corresponding to occluded
with the uniqueness
detailed with occlusions
the disparity errors
correct correct found
a pixel being
labeled occluded in
array of match
of tsukuba group
feature based stereo
5x5x3 and 7x7x3
3d disparity space
values along similar
baseline stereo with
a cooperative stereo
left image then
being occluded increases
and are continuous
to occluded pixels
disparity map found
the 84 003
nakamura et al
detailed disparity map

corpus/krapavin2000-test/628789.txt
tsbn
mlp
pixelwise
cpts
cml
gmm
training
ikl
likelihood
ml
marginals
road
segmentation
posterior
image
images
pixel
trained
classication
vegetation
predictions
compensated
jy
marginal
tsbns
furniture
pixels
neural
segmentations
entropies
belief
pearl
bouman
xje
conditional
colour
scaled
label
sky
em
street
entropy
labels
maximise
coding
prior
jpeg
cpt
scenes
rural
probabilities
raw
multiscale
causal
mrfs
bayesian
compensation
normalising
inference
propagation
generative
surface
labelling
scene
root
dierent
mpm
classications
lossless
scaling
mixture
lm
message
trees
evidence
gaussian
hidden
downward
initialised
markings
ls
smap
laferte
clamped
sowerby
gmms
dx0
softmax
marking
predictors
train
tree
optimisation
jx
children
mobile
correlations
quadtree
labelled
passing
dr
hmms
rees
codec
bae
perez
maximising
ej
yjx
parent
spatially
region
ik
initialisation
gareth
rise
regions
gradient
ow
bpp
uninstantiated
upward
pa
columns
estimated
classiers
diag
mrf
node
probability
calculation
appendix
urban
92
lter
shapiro
modelling
pmlp
helmholtz
nechyba
blocky
glm
downsampling
gldv
levelled
todorovic
loco
loopy
bristol
accuracies
normalised
recognition
networks
67
43
learned
unsupervised
seven
graphical
estimation
77
network
texture
misclassied
independences
downsampled
mlps
prediction
bits
six
siblings
dataset
calculated
features
markov
prof
database
baum
aerospace
unlabelled
condent
positional
trainable
71
nding
conguration
uk
posteriori
78
feature
truncated
speech
panel
wright
classier
ground
conjugate
45
truth
89
the tsbn
the ml
label images
x l
ml tsbn
road surface
scaled likelihood
pixelwise predictions
the mlp
the cml
p x
posterior marginal
the cpts
to level
the tree
the scaled
ikl ikl
street furniture
l jy
and mlp
a tsbn
gmm and
the training
mobile object
pearl s
marginal entropies
trained tsbn
maximum likelihood
neural networks
the gmm
from level
surface building
ml trained
the pixelwise
prior marginals
compensated mlp
vegetation road
cml training
level 1
root node
the prior
the root
the em
the posterior
p y
road marking
p xje
tsbn model
mlp pixelwise
building street
marginal likelihood
tsbn and
training set
log p
conditional probability
belief network
bits pixel
conditional maximum
likelihood model
y i
each class
node x
training the
likelihood method
tsbn the
marking road
cml trained
to maximise
cml tsbn
tsbn training
gmm pixelwise
furniture mobile
and cml
colour images
probability propagation
marginals of
for mlp
jpeg ls
likelihood training
message passing
em algorithm
test images
gaussian mixture
non causal
prior model
image segmentation
i jx
class labels
y m
the image
the conditional
each region
the label
a cpt
mlp local
posterior marginals
z ikl
compensated gmm
under ow
label image
causal mrfs
for gmm
cpts in
passing schemes
local predictions
road markings
ml training
data y
ml and
the likelihood
belief networks
image coding
the segmentation
neural network
images the
each pixel
a prior
likelihood in
the compensated
pa i
level 7
prior probabilities
have used
propagation in
of pixel
classication accuracy
likelihood p
training of
the raw
training data
rise to
generative model
hidden nodes
graphical models
image analysis
the marginal
to train
l given
laferte et
the normalising
passing scheme
siblings of
sky vegetation
smaller trees
object vegetation
range correlations
bayesian image
a quadtree
s probability
bouman and
likelihood cml
both gmm
mlp predictors
tsbn using
jy the
spatially uniform
seven classes
hand labelled
n ikl
avoid under
perez et
pixelwise classication
learned cpts
and road
p ej
40 full
raw mlp
and shapiro
gmm model
pixels were
dynamic trees
normalising factor
tsbn with
of posterior
map segmentation
uniform compensation
image modelling
coding cost
tsbn methods
structured belief
over segmentations
cpts on
the images
ground truth
model parameters
pixels in
was used
appendix a
trained to
the classication
the hidden
the seven
cpts from
classify each
x lm
predictions with
al 36
a multiscale
jx l
p yjx
p x l
the ml tsbn
the scaled likelihood
gmm and mlp
x l jy
road surface building
the ml trained
posterior marginal entropies
to level 1
scaled likelihood method
surface building street
ml trained tsbn
p y i
building street furniture
conditional maximum likelihood
the root node
the em algorithm
for the mlp
ikl ikl ikl
the likelihood model
maximum likelihood training
vegetation road marking
road marking road
gmm pixelwise predictions
furniture mobile object
of the tsbn
y i jx
marking road surface
mlp pixelwise predictions
the training set
for each class
in the training
of the tree
the gmm and
p c k
the tsbn model
with the ml
ml and cml
x l is
the label images
training the tsbn
the marginal likelihood
street furniture mobile
message passing schemes
in the tree
the conditional probability
of the ml
message sent to
the ground truth
the prior probabilities
a number of
neural networks for
root node to
the message sent
compensated mlp pixelwise
the normalising factor
the tsbn using
non causal mrfs
and mlp local
sent to node
and road surface
the class labels
in bits pixel
avoid under ow
hidden variables x
classify each region
bouman and shapiro
tree structured belief
cpts from the
s probability propagation
in the tsbn
object vegetation road
of label images
the prior marginals
and mlp predictors
spatially uniform compensation
that the likelihood
trained tsbn and
gaussian mixture models
laferte et al
message passing scheme
for both gmm
perez et al
x l given
the tsbn methods
for the tsbn
l jy the
of the cpts
to avoid under
compensated gmm pixelwise
i jx l
mobile object vegetation
pearl s probability
both gmm and
the learned cpts
marginal likelihood p
and cml trained
maximum likelihood cml
marginals of the
the computation of
we have used
can be calculated
maximum likelihood ml
et al 36
scaled conjugate gradient
columns 3 and
in x l
the hidden variables
of the mlp
log p for
of the images
from the root
the tree which
y i x
probabilities for each
of the posterior
training set of
p x i
the posterior probabilities
each class and
the maximum a
each class in
rise to a
using the em
conditional probability p
it appears that
at the root
of the training
was used in
the tree is
can be carried
the observed data
appears that the
maximum a posteriori
figures 4 and
for training the
the calculation of
root node and
computation of p
see appendix a
x i and
pixels in the
hidden markov models
probability distribution over
w r t
training and test
see section 6
in our experiments
probability of the
is known as
be carried out
section 4 5
down sampled image
tsbn the network
to level 7
that the generative
black square is
is only dependent
tsbn with mlp
the cml trained
likelihood model p
structured belief network
to classify each
to x l
3 aspect ratio
compare the tsbn
inference procedures for
both colour images
sky vegetation road
posterior marginals p
log p x
probability tables cpts
the cluster program
corresponding label images
training for the
of british aerospace
pixelwise predictions spatially
likelihood against iteration
i jx i
ground truth labelling
cml tsbn method
the marginals of
siblings of x
the compensated mlp
training images the
street furniture and
label images are
classes see 4
43 test images
model p yjx
tsbn to model
each black square
marginal entropies are
features were extracted
likelihood cml training
node y i
the ml and
z 0 2s
longer range correlations
likelihood p x

corpus/krapavin2000-test/628814.txt
cherno
silvey
nuisance
asymptotic
snr
distances
sensor
lrt
leibler
kullback
ali
target
sec
tank
coe
recognition
targets
likelihood
detection
quantizers
gaussian
compressed
truck
cients
sensors
noise
miss
compression
image
hypothesis
coder
coders
transform
quantization
hypotheses
orientation
concave
lindeberg
mixture
imagery
quantized
lossy
favorable
detector
convex
imaging
theoretic
wavelet
thermodynamic
bounds
distributions
priors
tractable
radar
statistical
noisy
probability
distance
prior
ji
composite
scene
dissimilarity
inequality
multisensor
unquantized
ratios
intractable
pdf
variability
ln
tightness
attractive
unknown
ary
t62
testing
remote
fig
di
modeled
figs
additivity
monte
ch
ratio
expressions
involving
additive
orthonormal
corrupted
infrared
variate
tight
entropy
carlo
images
spikes
tance
degradations
measures
classification
bit
db
analytically
equality
cient
central
integrals
minimax
rigid
clean
exp
template
angles
zone
clutter
strengthened
pixel
bayesian
realizations
identically
multiplicative
signal
error
erent
rates
alarm
proposition
convexity
invertible
worst
simplifies
jensen
deformations
asymptotically
expectation
optimality
nonlinear
simulations
qualified
orientations
formulated
evaluated
approximations
conditioned
covariance
energy
probabilities
flir
vasudevan
cher
deadzone
advantageously
is2
imagers
analytics
lavanya
calumet
kassam
dwelled
lanterman
shaikin
quantizer
urbashi
decompressed
unbeatable
noncoherent
civilian
tanks
category
estimation
dead
ds
quantities
exponent
approximation
templates
mass
conditional
ects
decreasing
dr
statistically
1264
marginals
hyperspectral
thermo
marcum
curran
trucks
bhattacharyya
reemphasize
1274
usion
neyman
systematic
poisson
scalar
coherent
i d
p e
d i
in sec
target recognition
ali silvey
the cherno
cherno distances
of error
kullback leibler
nuisance parameters
likelihood ratio
p miss
detection problem
probability of
leibler distances
bounds on
hypothesis testing
sec 2
sensor noise
and kullback
coe cients
target detection
sensor data
the asymptotic
cherno distance
cherno and
error p
leibler and
asymptotic approximation
d p
information theoretic
sec 5
log likelihood
sec 6
c d
d gaussian
recognition performance
compressed data
i i
on p
upper bound
transform coe
hypotheses h
likelihood ratios
on target
composite hypothesis
the lrt
and cherno
l ji
silvey distances
theoretic distances
data i
h i
the likelihood
the probability
recognition problems
asymptotic expressions
distances in
the target
ji i
image data
h 0
the lindeberg
truck imagery
least favorable
noisy sensor
nuisance parameter
cherno bound
average approximation
the ali
silvey class
testing problem
target is
p f
decreasing and
detection performance
the tank
bit rates
known target
detection problems
l c
the kullback
problems involving
h 1
cients c
m ary
the mixture
independent components
hypothesis test
to p
bound on
is convex
the transform
hypothesis h
is concave
distances are
the sensor
bit rate
scalar quantizers
at orientation
ary hypothesis
binary detection
involving nuisance
of cherno
error rule
approximation 35
lossy compression
expression 21
optimal lrt
bound 14
gaussian sensor
silvey distance
binary hypothesis
on cherno
asymptotic expression
snr 8
distances provide
miss p
ratio is
cients are
the compressed
the prior
the log
noise and
performance measures
parameters such
distance d
and h
performance bounds
limit theorem
central limit
p i
sensors are
average distance
image t
under hypotheses
theoretic bounds
automatic target
ratios l
under hypothesis
tank and
mixture distribution
of miss
minimum probability
and truck
and 15
statistical models
system parameters
proposition 7
modeled as
detection algorithm
of targets
cherno bounds
carlo simulations
see sec
of asymptotic
on detection
dissimilarity between
under some
gaussian noise
p 0
d are
the detection
d s
expressions for
coe cient
d where
possible targets
35 is
under h
gaussian data
provide upper
random with
11 and
data are
the inequality
upper bounds
lower bounds
d d
d h
these distances
sec 3
compression algorithm
an upper
the average
are tight
as target
prior distribution
some conditions
distances that
are modeled
in fig
the optimal
e is
a target
a known
corrupted by
targets are
convex function
i d i
d i d
probability of error
i i d
on p e
data i d
kullback leibler distances
to p e
and kullback leibler
l c d
the likelihood ratio
p e is
the probability of
cherno and kullback
error p e
of error p
kullback leibler and
i d gaussian
i d is
likelihood ratio is
p e in
d p i
in sec 6
l ji i
ali silvey distances
11 and 15
and cherno distances
information theoretic distances
leibler and cherno
ji i d
composite hypothesis testing
in sec 5
the log likelihood
in sec 2
hypothesis testing problem
bounds on p
transform coe cients
ali silvey class
the ali silvey
sensor data i
d s p
decreasing and c
the asymptotic approximation
i d h
the cherno bound
sec 2 4
cients c d
the kullback leibler
upper bound on
log likelihood ratio
bound on p
d p 0
i d p
coe cients c
h 0 and
the sensor data
and p e
parameters such as
proposition 7 1
c d d
0 and h
ratio is the
coe cients are
ali silvey distance
tank and truck
the asymptotic expression
probability of miss
on target recognition
detection problem in
involving nuisance parameters
in the ali
theoretic bounds on
target recognition performance
d gaussian sensor
under hypothesis h
log likelihood ratios
i d are
asymptotic expressions for
of error rule
bounds on target
target recognition problems
a known target
is the likelihood
of miss p
sensor noise and
the minimum probability
approximation to p
under hypotheses h
nuisance parameters in
noisy sensor data
the cherno distance
likelihood ratios l
distances in 11
gaussian sensor noise
as random with
i d the
the average approximation
binary detection problem
for the tank
and truck imagery
d h i
c is concave
the cherno and
m ary hypothesis
and p miss
sensor data are
image t i
asymptotic expression 21
the optimal lrt
asymptotic approximation 35
leibler distances in
miss p miss
central limit theorem
an upper bound
and h 1
and c is
lower bounds on
of the compressed
p e and
modeled as random
the compressed data
hypothesis h i
testing problem the
i d where
see sec 2
as in sec
distance d p
such as target
and the asymptotic
discussed in sec
sec 5 1
minimum probability of
automatic target recognition
information theoretic bounds
d are independent
probability of false
dissimilarity between two
sec 2 2
d where the
provide upper bounds
monte carlo simulations
between two distributions
c d are
of error is
of error for
under some conditions
s p 0
the data i
h i the
in 11 and
the central limit
p f and
upper bounds on
p i i
h i and
the upper bound
the average distance
d i i
are modeled as
problem in which
optimal lrt detector
miss and p
simple hypothesis testing
illustrate the theory
p i d
the target recognition
of ali silvey
from i d
corrupted by i
along with noisy
the projected image
expectation under hypothesis
with noisy sensor
known target is
bounds on ali
lrt in 4
convex decreasing and
nuisance parameter we
d gaussian noise
cherno distances in
is the mixture
asymptotic approximation to
the mixture distribution
erent noise realizations
j i d
with prior under
for the cherno
on detection performance
upper bound 42
presence of nuisance
bounds on detection
from 44 l
mixture distribution i
exp snr 8
whether a known
with nuisance parameter
classification of multiple
of nuisance parameters
sec 6 3
worst where worst

corpus/krapavin2000-test/628823.txt
mvc
cluster
clusters
gmm
plateaus
plateau
variance
clustering
samples
border
outliers
candidates
tendency
partitional
tendencies
r15
nearest
criterion
hit
foreigners
neighborhood
strength
segmentation
epochs
towns
furthest
sample
iris
d31
outer
o3
german
gaussian
fig
annealing
expansion
constraint
assessment
rank
genetic
prominent
mixtures
neighbors
lumped
ms
em
delft
veenman
greed
reinders
asok
dga
neighbor
homogeneity
neighboring
displayed
foreign
unite
square
fuzzy
clusterings
rajagopalan
maximisation
stochastic
likelihood
fastest
accordingly
statistical
inner
cordingly
mates
venkatesh
colored
grey
certainly
collect
optimum
discover
originating
defect
hypothesized
squared
cumulative
ranking
max
display
unsupervised
occasional
recognition
simulated
convergence
locality
evolutionary
varied
candidate
image
3320
5031
tarroux
irises
eucledian
2810
1429
arguable
2907
mediamatics
1840
coevolutionary
andrey
foreigner
1417
selectionist
3309
2163
2897
samsi
amador
classifier
impose
joint
optimization
ray
union
1940
rohan
rion
0030
jhin
precautions
0062
mayer
2600
1290
butions
sian
wende
varying
putting
displays
curve
priori
circular
isolated
knee
copes
2152
agglomerative
crite
artificial
isolation
undesirable
dencies
demarcation
concatenate
constellation
seeded
inhomogeneous
distributions
predefined
expresses
removal
significant
proper
marcel
isolates
bors
robust
lists
merged
gain
validity
ac
separate
statistics
nonparametric
optima
conceptually
growing
distance
resemblance
oscillations
422
disrupt
epoch
act
randomly
fractal
rating
neigh
410
ga
leading
textured
mutation
centroids
skipping
rearranged
prevent
categorized
homogeneous
the mvc
k means
mvc algorithm
variance constraint
the cluster
data set
gmm algorithm
the gmm
of clusters
means algorithm
expansion candidates
j e
maximum variance
means and
c a
constraint parameter
the k
the clustering
the variance
outer border
gmm method
cluster tendency
square error
cluster tendencies
rank list
and gmm
statistical results
error criterion
the clusters
hit m
mvc and
method parameter
means table
ms k
parameter hit
of cluster
cluster c
clusters is
a cluster
image segmentation
the outliers
r15 data
foreigners of
tendency assessment
significant plateau
of epochs
inner border
real structure
clustering result
the r15
german towns
means model
variance cluster
time ms
optimization process
the samples
clusters and
cluster algorithm
similar 2
iris data
from varying
points points
d gaussian
k nearest
variance of
samples in
the criterion
of applying
of expansion
one cluster
m time
of samples
the neighborhood
in fig
2 constraint
the optimization
the iris
clustering with
hit rate
simulated annealing
the 2
4 samples
partitional cluster
the o3
its criterion
significant plateaus
curve resulting
mixtures modeling
cluster algorithms
prominent plateaus
nearest foreigners
border b
discover cluster
c display
means k
border i
joint variance
towns data
cluster variance
maximum plateau
plateau strength
o3 data
grey colored
neighboring cluster
cluster neighborhood
colored cluster
cluster itself
shown which
the square
data sets
the em
algorithms to
corresponding clustering
e max
15 clusters
s max
gaussian mixtures
see fig
sample a
display the
2 parameter
with respectively
outliers in
a plateau
of candidates
nearest neighbors
accordingly the
x c
cluster is
candidates of
separate clusters
ranking for
clusters as
the german
the originating
to collect
are displayed
a the
results of
parameter for
the algorithms
algorithm were
cluster with
gaussian distributions
computation time
the grey
the furthest
th order
the strength
the gaussian
to find
clusters that
of squared
respectively 3
displayed as
for cluster
a maximum
neighborhood of
em algorithm
the hit
for sample
border of
e and
2 d
robust in
the nearest
the rank
modeling gmm
cluster models
cluster mates
cluster mvc
mvc method
rank lists
symbolic time
a accordingly
cluster instead
individual clusters
d31 data
cluster mean
strength s
fuzzy clustering
cluster sample
constraint instead
j veenman
gaussian clusters
neighboring samples
some prominent
criterion optimum
the greed
cluster model
hypothesized clusters
local criterion
plateaus in
of foreign
those samples
neighbor ranking
clusters act
t reinders
e plateaus
plateau in
the mvc algorithm
the k means
k means algorithm
k means and
number of clusters
the variance constraint
for the mvc
of the mvc
j e and
the square error
means and gmm
and gmm algorithm
cluster c a
e and m
in a the
algorithms to the
the algorithms to
time ms k
the gmm algorithm
k means table
method parameter hit
variance constraint parameter
and the gmm
hit m time
parameter hit m
ms k means
applying the algorithms
the gmm method
statistical results of
a maximum variance
m time ms
maximum variance constraint
means and the
of a cluster
results of applying
of applying the
of clusters is
of the cluster
2 d gaussian
the r15 data
of cluster c
the mvc and
square error criterion
of expansion candidates
maximum variance cluster
resulting from varying
similar 2 d
both the k
mvc algorithm is
r15 data set
m are displayed
the 2 constraint
the cluster tendency
set of expansion
gmm method with
the optimization process
the maximum variance
iris data set
in the cluster
the variance of
x c a
parameter for the
and the k
able to find
for the clustering
in j e
towns data set
discover cluster tendencies
with respectively 3
gaussian mixtures modeling
respectively 3 and
of squared error
is shown which
number of epochs
2 constraint parameter
to c a
cluster with respectively
the german towns
the 2 parameter
d gaussian distributions
that the mvc
k means model
and c display
maximum plateau strength
the grey colored
the gaussian mixtures
sample a is
the cluster itself
inner border i
german towns data
nearest foreigners of
c display the
grey colored cluster
varied the 2
of the grey
k means k
ranking for sample
the outer border
gmm algorithm were
border b a
expansion candidates of
the cluster neighborhood
of a plateau
and 4 samples
colored cluster with
to discover cluster
points points points
means k means
cluster tendency assessment
outer border b
a of cluster
the o3 data
for sample a
the rank list
border i a
k nearest foreigners
mvc and the
the expansion candidates
o3 data set
shown which is
curve resulting from
number of candidates
variance of the
the neighborhood of
of the clusters
and m are
n x y
the hit rate
of the gmm
b j e
constraint in order
is generated as
displayed as a
squared error criterion
the iris data
means algorithm with
in separate clusters
for image segmentation
in b j
of clusters to
and the gaussian
from the cluster
are displayed as
of x in
data set is
clusters that are
in c a
a is shown
cumulative distribution of
of the 2
set is shown
which is generated
results of the
as a function
sum of squared
f n x
c a is
data set in
fig 4 b
the em algorithm
in order to
a function of
the optimization of
to find the
of the samples
in fig 10
data set and
for partitional clustering
modeling gmm method
constraint instead of
g x q
x in y
robust in finding
mvc algorithm may
nearest neighbors method
samples in c
cluster mates of
outer border of
we first varied
a neighboring cluster
restricted number of
with likelihood maximisation
neighbors method in
matches the samples
in y as
variance constraint in
than the mvc
b a of
the outliers in
15 clusters is
display the neighborhood
15 similar 2
the clustering with
notion of foreign
act in parallel
symbolic time series
to x c
a cluster we
furthest cluster mates
some prominent plateaus

corpus/krapavin2000-test/628848.txt
parallax
epipoles
epipole
motion
frames
scene
plane
3d
frame
brightness
camera
fl
homography
planar
image
images
epipolar
recovered
pixel
residual
displacements
singularity
estimation
shape
pixels
recovery
correspondences
eq
squares
brighter
pw
aperture
dense
pyramid
surface
carpet
alignment
reference
pi
ambiguity
2d
calibration
bars
fig
unknowns
homographies
sfm
views
displacement
unknown
uncalibrated
horizontal
vertical
motions
warped
estimated
minimization
house
fluctuations
geometries
recovering
ffiu
garden
stairs
taller
correspondence
centered
estimating
vicinity
flower
elevated
constancy
ego
estimate
reconstruction
grey
phi
resolving
gradients
folded
denominators
weights
ground
flow
geometry
aligned
depth
across
quantities
gradual
darker
projective
err
disappears
resolved
opposed
pure
radial
recover
mixed
gradient
coordinate
coordinates
field
scenes
facade
flt3
2nl
prazdny
takeo
toys
theta5
misalignment
rulers
theta30
jth
window
denominator
visible
texture
lamp
weaving
trifocal
attendant
fine
noise
scalar
square
105
front
uniquely
resolution
finest
gauge
transforma
occluding
suffer
distances
phase
measurements
shifted
encode
kanade
tensors
indoor
looming
benefits
constraint
eliminated
parametric
spatial
simultaneous
coarsest
okamoto
rename
multiplying
expression
region
weight
rotation
notoriously
aligning
itera
meaningful
ambiguities
stabilization
stripes
linearized
enlarge
pole
translational
video
normalization
vision
estimates
decouples
folding
parametrically
defense
constrained
sample
relates
gamma1
focused
warping
recovers
precomputing
textured
equating
unify
pyramids
eqs
285
gracefully
ence
cameras
holes
unified
iteration
purely
plane parallax
multiple frames
the epipoles
reference plane
the reference
planar parallax
shape recovery
3d structure
planar surface
the recovered
the epipole
multiple epipoles
the plane
scene structure
reference frame
3d scene
the camera
two frames
parallax displacements
t j
the residual
image motion
multi frame
epipoles are
values correspond
local phase
the brightness
estimation process
residual parallax
one epipole
aperture problem
parallax motion
horizontal motion
epipole singularity
vertical motion
the 3d
each pixel
structure and
the epipolar
the scene
frame from
image brightness
images with
two frame
reference image
to multiple
fl is
frames the
scene points
the carpet
camera epipoles
parallax displacement
residual image
global phase
the aperture
plane pi
correspondence estimation
fl x
recovered structure
squares minimization
parallax flow
the parallax
dense 3d
shape relative
structure fl
brighter values
11 13
each frame
motion parameters
all frames
frame i
recovery for
relative to
the image
sequence fig
a planar
motion and
motion of
per frame
camera motion
and motion
brightness constraint
frame estimation
d search
scalar weight
geometries or
parallax estimation
uncalibrated views
epipoles i
frame case
mixed motions
pyramid level
ground surface
typical depth
epipoles the
b gamma1
dense planar
spatial gradients
plane alignment
the images
estimation algorithm
one frame
with multiple
x y
the structure
of shape
the planar
from multiple
across multiple
image displacements
pixels across
the house
flow vector
recovered shape
the homography
our direct
structure parameter
calibration parameters
previous iteration
the sequence
the shape
frame in
pixel x
the unknown
structure from
are estimated
eq 3
parallel to
direct estimation
the singularity
pixel and
the local
the ground
recovery of
we estimate
g l
the squares
frames to
depth map
j g
least squares
flow field
sequence b
eq 5
from applying
frames our
pixel per
pure vertical
pyramid construction
of ego
variations across
plane homography
brightness constancy
frames however
unknown calibration
epipole t
epipole the
ambiguity is
recovering dense
all effects
line constraint
estimated well
brightness measurements
jth frame
g estimating
homography estimation
grey corresponds
darker values
carpet fig
taller points
camera geometries
points above
shape fluctuations
simultaneous estimation
local correspondence
3d parallax
parallax decomposition
an epipole
epipole in
motion ambiguity
estimated directly
not estimated
brightness variations
direct recovery
parallax representation
homography and
images fi
from brightness
after plane
estimation i
which handle
unknowns are
multiple uncalibrated
homography of
to taller
epipole at
points relative
parallax e
residual planar
ambiguity along
the reference plane
the plane parallax
the reference frame
with multiple epipoles
to multiple frames
values correspond to
and the camera
the 3d structure
a planar surface
3d structure and
the residual parallax
shape recovery for
from the sequence
frame from the
the local phase
in the scene
structure and the
at the epipole
least squares minimization
residual image motion
shape relative to
the camera epipoles
of shape recovery
j g l
brighter values correspond
the two frame
to a planar
planar parallax displacements
across multiple frames
images with multiple
the recovered structure
the aperture problem
fl x y
applying the algorithm
to the reference
for each pixel
the sequence fig
one frame from
scene structure and
the estimation process
the reference image
structure and motion
relative to a
map that results
3d scene structure
d search problem
a plane in
the structure parameter
reference plane and
directly from image
recovered shape relative
shows the recovered
results from applying
typical depth map
a one frame
pixel x y
sequence a one
two frame case
dense planar parallax
dense 3d structure
a typical depth
b the recovered
example of shape
across all frames
recovery for a
the 3d scene
depth map that
our direct estimation
the residual image
of the building
the ground surface
direct estimation algorithm
the global phase
multiple frames the
sequence b the
correspond to points
i x t
the recovered shape
3d structure of
the epipoles are
reference plane is
relative to the
x t j
plane in the
vicinity of the
the algorithm to
for each frame
the motion parameters
all the images
from applying the
plane is the
from the camera
t j for
for a sequence
e g from
the sequence b
distances from the
in the reference
the structure and
the previous iteration
is a typical
the vicinity of
a b fig
structure parameter fl
and we estimate
fi j g
on the squares
bars is not
pi between the
of planar parallax
correspond to scene
not estimated well
epipole t j
each frame i
plane parallax representation
sample images from
after plane alignment
from the planar
from image brightness
unknown calibration parameters
a shape invariant
parallax displacement and
are estimated directly
to a plane
camera epipoles are
parallax motion of
to sequences with
1 d search
planar surface in
per frame to
the vertical motion
plane parallax estimation
plane parallax framework
algorithm to real
camera epipoles the
the planar parallax
to taller points
from multiple uncalibrated
linear expression in
the plane homography
multiple uncalibrated views
the horizontal motion
done by 11
the fine structure
the simultaneous estimation
the brightness constraint
motion ambiguity along
note the fine
reference plane the
grey corresponds to
directly from brightness
image brightness variations
all effects of
recovering dense 3d
epipoles t j
parallax flow vector
has an epipole
scene structure fl
of the epipole
the carpet fig
by the denominator
folded into the
of 11 13
simultaneous estimation of
the epipoles i
reference plane pi
denote the image
plane parallax decomposition
image motion of
reference frame i
from the aperture
all the epipoles
algorithms which handle
to the denominators
brightness variations across
pure horizontal motion
squares minimization over
the plane pi
each pixel and
e g estimating
they were all
direct recovery of
pixel per frame
camera geometries or
by 11 for
are folded into
fine structure of
flower garden sequence
local correspondence estimation
or camera motion
with weights equal
to scene points
from brightness measurements
brightness measurements in
which handle cases
sequences with purely
j x y
is not estimated
residual planar parallax
previous iteration and

corpus/krapavin2000-test/628884.txt
lighting
harmonics
harmonic
images
reflectance
lambertian
sphere
albedo
light
surface
reflectances
subspace
recognition
illuminated
normals
image
9d
energy
illumination
convolution
hnm
spherical
shashua
kernel
pca
dz
intensity
georghides
albedos
4d
belhumeur
coefficients
lights
3d
cosine
pose
shadows
spanned
oe
amplitude
kriegman
face
scaled
dc
nine
reflection
kba
hecke
zonal
funk
object
delta
diffuse
nm
sin
gamman
approximation
analytically
lambert
gamma2
99
negative
pixels
koenderink
qr
doorn
cone
analytic
approximated
faces
zmura
1zp
ramamoorthi
ik
photometric
analog
enforce
vision
epstein
negativity
specularities
cos
rendering
distant
rendered
convex
basri
moses
ck
tog
isotropic
reflected
specular
rotationally
normal
theta
squared
intensities
n0
subspaces
bidirectional
pixel
doe
amplitudes
blicher
subsample
hanrahan
brdfs
pnm
hallinan
dobashi
coefficient
accuracy
dimensional
captured
realizable
matlab
angle
approximations
brdf
7d
physically
transform
1d
yuille
longitude
legendre
poles
illuminate
lagrange
graphics
2d
fourier
projecting
squares
unscaled
convolutions
latitude
roc
coordinate
coordinates
van
stereo
cast
orthonormal
linearity
rearrangement
polynomials
exponent
variations
render
materials
accurately
recognizing
varies
jacobs
pole
enforcing
svd
everywhere
fourth
half
objects
facing
suggestion
angles
appearance
matrix
mike
scattering
integral
visible
human
integrating
bad
law
basis
choi
six
shading
ambient
ravi
inverting
arbitrarily
generative
multiplier
approximates
source
2008
inherits
saturated
direction
projection
frequency
near
constraint
87
produced
shape
varying
the harmonic
basis images
the sphere
the reflectance
harmonic images
the light
reflectance function
linear subspace
non negative
lighting conditions
images of
surface normal
order approximation
the surface
of images
spherical harmonics
negative lighting
low dimensional
point source
the lighting
surface normals
the harmonics
illuminated by
the image
reflectance functions
harmonic basis
delta functions
s images
an object
lambertian kernel
the lambertian
dc component
lighting function
dimensional linear
the images
delta function
light is
a convolution
gamma ik
negative combination
half cosine
9d space
georghides et
of lambertian
harmonic reflectances
order harmonic
space spanned
n gamma2
the dc
scaled by
a low
the energy
an image
spanned by
the delta
first order
cosine function
belhumeur and
the albedo
these images
model s
four harmonics
m gamman
images produced
is illuminated
energy captured
and kriegman
lambertian reflectance
kriegman 1
negative light
order harmonics
harmonics with
lambertian object
harmonic transform
space coordinates
normals scaled
the amplitude
linear space
components of
the kernel
face recognition
first few
theta r
of lighting
a reflectance
first nine
harmonics are
its energy
low order
our approximation
amplitude of
energy in
can produce
a 4d
reflected by
for recognition
the analog
n x
9d linear
object illuminated
illumination cone
lambert s
b nm
bidirectional reflection
sin d
dz n
recognition algorithms
kba gamma
hecke theorem
unit albedo
light includes
a 9d
analytic description
the funk
positive lighting
funk hecke
qr decomposition
shashua s
unit sphere
the convolution
images we
the intensity
images are
images that
a point
transform of
a 3d
a sphere
theta 4
linear combination
the space
koenderink and
reflectance of
light reflected
oe sin
z ck
van doorn
z direction
dimensional space
pose and
r oe
the coefficients
a linear
order n
the half
the object
a face
analog of
near a
degree polynomial
and lighting
use this
approximation to
the illumination
object under
linear method
an analytic
captured by
and van
a model
n z
the spherical
min z
subspace that
obtained under
of delta
arbitrarily bad
few harmonics
z 1zp
lighting in
d zmura
epstein et
harmonic light
ck s
the albedos
4d linear
attached shadows
harmonics this
reflection distribution
a lambertian
coefficients k
lambertian objects
squared energy
negative least
first harmonic
and moses
shashua 25
harmonics we
the 9d
rotationally symmetric
is rotationally
of lights
photometric stereo
physically realizable
1zp n
specular objects
nine harmonic
enforce non
sphere as
d doe
set of images
non negative lighting
on the sphere
the basis images
low dimensional linear
the surface normal
of an object
a low dimensional
the lambertian kernel
the reflectance function
a non negative
images of an
a point source
model s images
of images of
of the surface
of the delta
the images of
the surface normals
space spanned by
the dc component
non negative combination
the light is
the harmonic basis
georghides et al
harmonic basis images
the linear subspace
of the harmonic
of the sphere
components of the
the delta function
the half cosine
normals scaled by
the harmonic transform
the harmonic images
is illuminated by
negative combination of
a model s
a reflectance function
of the lighting
energy captured by
images produced by
belhumeur and kriegman
and kriegman 1
surface normals scaled
of delta functions
by the harmonic
the first few
spanned by the
first order approximation
the first nine
the amplitude of
of the approximation
the space spanned
scaled by the
the analog of
images of a
of the object
dimensional linear subspace
funk hecke theorem
harmonic transform of
non negative light
order harmonic images
of the dc
the spherical harmonics
combination of delta
the harmonics with
the light includes
the funk hecke
object can produce
images that an
min z ck
kba gamma ik
an analytic description
when the light
of the lambertian
illuminated by a
by the albedo
object illuminated by
the illumination cone
linear combination of
of the energy
as a non
the first order
analog of a
the light reflected
and van doorn
koenderink and van
the reflectance of
the z direction
light reflected by
of a convolution
the set of
a linear combination
transform of the
to a model
of images that
z 2 z
of the light
low dimensional space
the surface of
to the image
in the image
approximation to a
by a point
the intensity of
make our approximation
half cosine kernel
dz n gamma2
analytic description of
linear space we
oe sin d
of lambertian reflectance
a 4d linear
a linear subspace
the first harmonic
to the linearity
use this analysis
shashua 25 and
lambert s law
the sphere as
r theta r
images b is
reflection distribution function
a qr decomposition
near a low
shashua s method
first few harmonics
d n gamma2
gamma2 dz n
and lighting conditions
non negativity of
pose and lighting
z 1zp n
half cosine function
the delta functions
linear subspace in
point source at
dimensional linear space
a low order
a lambertian object
is rotationally symmetric
the lighting function
enforce non negative
lie near a
t z t
nine harmonic images
an object under
th order approximation
bidirectional reflection distribution
that the light
epstein et al
order approximation of
z components of
b is p
25 and moses
and moses 20
first order harmonic
z ck s
non negative least
p theta r
according to lambert
the energy captured
can produce we
to lambert s
the reflectance functions
first nine harmonic
negative least squares
n gamma2 dz
negative lighting function
light is non
sphere is illuminated
whose exponent is
sin d doe
ck s t
a delta function
reflected by the
by the first
constraint that the
the constraint that
an object can
images of the
the nearest image
is p theta
of the harmonics
2 z k
non negative function
second order approximation
is a delta
n th order
s t z
computed at run
the non negativity
if the light
surface normal at
space of all
point on the
on the surface
transactions on graphics
obtained when the

corpus/krapavin2000-test/628975.txt
dependence
subscripts
coupled
array
hyperplane
references
loop
cone
hyperplanes
r2
r1
intersects
dimension
plane
planes
subroutines
intersect
el
directions
parafrase
supercomputing
dimensions
parallelization
eispack
dependences
equations
wolfe
loops
interprocedural
bounds
vectorizer
canonical
min
1990
solutions
inequalities
parallelizing
numerical
indices
motzkin
coefficient
fortran
inner
residues
dimensional
restructuring
geometrical
3n
subscript
intraprocedural
yunheung
restructurer
iia
restraints
examined
obvi
lp
sign
parallelized
difficulties
convex
hoeflinger
paek
weng
supercompilers
972
marina
962
diophantine
ip
valued
tests
subscripted
jay
ind
independence
york
notices
wu
angles
ously
arrays
multiprocessors
subdomain
chu
nonempty
transformations
disjoint
checking
supercomputers
packages
outermost
testing
sigplan
unclear
simplex
max
cross
1993
jan
lemma
321
chih
innermost
subsystems
chung
empirical
ping
analyzer
thousand
conservative
tested
boun
973
iic
xiaofang
baowen
jingke
8971
zhongqiang
karmarkar
daries
minjoong
8943
3214
lilja
coefficients
massive
parallelism
direction
programs
lemmas
equalities
consistency
subsystem
ordinary
detect
hundred
pipelined
region
integer
lambda
lu
examination
spice
separatedly
tzen
ishfaq
itpack
iib
sects
maydan
fishpak
1074
lee
csur
examining
boundaries
compilers
symbolic
equation
compiler
intersection
eigensystem
junjie
knowns
followings
rim
uniformization
hennessy
gyungho
sharma
1991
interconnection
chang
fourier
simultaneously
areas
iterations
rare
chen
compile
spaces
examines
automatic
kwong
kwang
sadayappan
yew
privatization
338
ahmad
iid
bacon
364
monica
dror
residue
package
viewing
data dependence
l test
l 1
dependence directions
array references
f l
loop bounds
coupled subscripts
1 l
dependence analysis
the l
l 2
intersects v
l plane
dimensional array
by loop
dependence direction
in r
every l
by dimension
l planes
el 1
l cone
integer solutions
r 2
dimension by
and r2
loop indices
multi dimensional
v min
r1 and
f el
as dependence
numerical methods
min f
a hyperplane
the loop
a l
no data
y line
hyperplane in
coupled dimensions
v i
if v
linear combination
l set
have coupled
a dependence
bounds as
each l
and v
test in
l m
2 l
r m
bounds only
l tests
canonical solutions
y equations
intersect v
earlier numerical
improvement rate
dependence test
a y
y i
additional time
v max
references with
r 1
of array
are coupled
y equation
common solutions
between r1
f equation
line then
equations and
analysis for
v is
1 v
called a
equation corresponds
r n
j j
a cone
dimension j
a j
a f
valued solutions
hyperplanes in
a linear
exact data
inequality consistency
f equations
existing numerical
hyperplane p
plane intersects
on inequality
l region
canonical solution
dimension algorithms
i called
fixed l
test is
i j
inner loop
coefficient of
dimensional arrays
2 space
and inequalities
each v
f i
v if
subscripts in
the dependence
the coefficient
of loop
subscript expressions
the inner
array a
2 v
on supercomputing
dependence in
m space
m equations
proof follow
dimension test
program restructuring
v j
linear function
dependence between
defined by
direction vector
plane each
iteration dependences
consistency checking
of coupled
data independence
in parafrase
have min
program parallelization
f line
in l
real valued
not intersect
new algorithm
linear programming
determine whether
equations in
have common
practical cases
directions then
ordinary programs
cross iteration
a geometrical
j 0
dimensions are
supercomputing p
j 1
u j
each dimension
then there
whether s
contains s
otherwise they
only then
single dimension
i definition
half spaces
two half
the line
of l
same argument
in 3
min i
2 have
a data
2 7
and 2
sign of
real programs
for array
v then
of 2
such hyperplanes
loops r
fourier motzkin
whole r
dimension approach
parallelization restructurer
deciding linear
constant lower
interconnection complexity
loop residues
each subsystem
intraprocedural and
valued solution
f plane
common loops
computing loop
f l 1
1 l 2
the l test
l 1 l
dimensional array references
data dependence analysis
defined by loop
by loop bounds
multi dimensional array
dimension by dimension
r1 and r2
no data dependence
in r m
well as dependence
every l 1
loop bounds as
as dependence directions
l 2 in
v is defined
a data dependence
the loop bounds
a dependence direction
dependence analysis for
if v is
f el 1
called a l
l test in
in r n
bounds as well
2 l m
coefficient of each
of each v
in f l
intersects v if
each l cone
l test is
l 2 l
in the line
is no data
in r 2
in 3 2
have coupled subscripts
in each l
the l set
l m in
a j 0
for every l
and 2 2
case of 2
each v i
a y equation
a l plane
min f l
r 2 space
if f l
the l tests
by a dependence
loop bounds only
called a y
earlier numerical methods
linear combination of
is defined by
2 1 and
s and v
of l 1
r 2 is
hyperplane in r
line in r
of array references
a hyperplane in
data dependence in
equations in 3
between r1 and
the coefficient of
i and v
linear function of
test in the
and 2 7
of loop indices
equation corresponds to
data dependence between
l 1 v
1 r 2
array references with
the inner loop
l 2 is
r 1 r
and v j
called a f
based on inequality
fixed l 1
and v min
a f equation
l set is
argument as for
definition the equation
equations and inequalities
a y line
of two half
exact data dependence
the y equations
l plane intersects
existing numerical methods
then f l
proof follow the
bounds only then
min f el
r m which
i called a
6 and 2
on inequality consistency
2 v n
by dimension algorithms
have min f
not intersect v
v min i
l j a
dependence directions then
boundary of two
inequality consistency checking
line then f
f i j
a linear combination
conference on supercomputing
are no more
v i and
function of l
coupled subscripts in
in data dependence
v j are
dependence direction vector
the dimension by
l 2 v
if a j
multi dimensional arrays
2 in r
is a linear
cross iteration dependences
region is a
in multi dimensional
two half spaces
for data dependence
2 is said
dependence test for
dimension j 1
1 and 2
of the l
a linear function
is a cone
each dimension of
j a j
two dimensional array
1 only if
array references are
is the boundary
i in f
array references in
real valued solutions
distributed systems v
transactions on parallel
on supercomputing p
and distributed systems
loop bounds and
l 1 in
the same argument
the sign of
on parallel and
v i in
within the loop
no more than
then there are
2 6 and
same argument as
a line in
follow the same
i j j
to determine whether
to a linear
does not intersect
related by a
parallel and distributed
there are no
intraprocedural and interprocedural
divide r 2
indices from the
and j 3
have constant lower
of 2 dimensional
restructuring for high
two coupled dimensions
upper bounds u
dependence of multi
as for lemma
which the l
is nested in
loop indices from
computing loop residues
the dependence directions
given a line
that f l

corpus/krapavin2000-test/629004.txt
dependence
subscripts
s2
references
s1
array
loop
dependences
coupled
interprocedural
nonlinear
subscript
parafrase
supercomputing
wolfe
linpack
packages
kuck
coefficients
urbana
loops
dissertation
assertions
champaign
proc
ependence
depen
independence
banerjee
parallelizing
sigplan
compiler
dcs
independences
distances
pp
symbolic
gcd
dependenc
rpt
ph
yew
vol
illinois
conf
ence
dimension
1988
diophantine
routines
uncertain
padua
1984
s3
eispack
tests
aug
xample
iucdcs
notices
multiprocessor
unknown
subroutines
1986
fortran
valued
zhu
int
partially
cytron
distance
est
1978
iteration
statements
parallelization
direction
reference
1990
nest
623
zhiyuan
nonzero
nesting
programs
ping
cologne
1991
antidependent
nicolau
cumulatively
ndependence
eferences
cripts
9257
uccess
inear
uiucdcs
hose
ispack
ivisor
umber
leasure
propagation
kennedy
fo
compile
synchronization
scheduling
rice
rep
dimensions
ion
1995
1979
ar
percentage
indices
ome
itpack
dat
nce
directions
restructuring
west
library
alue
yunheung
als
vectorizer
flow
york
chih
zeroth
doacross
partitioning
nonetheless
thousand
package
crosses
linearity
airs
hoeflinger
tx
symp
paek
houston
supercompilers
kuhn
972
weng
nov
tang
nasa
transformations
962
marina
university
proceeds
476
5th
undefined
dimensional
measurements
detection
parallelism
fisher
jay
subscripted
86
compilers
index
effects
conceivable
ave
multiprocessors
did
he
usage
subdomain
weather
chang
counted
iterations
250
tech
chu
substitution
trans
examined
ble
supercomputers
162
cm
toplas
1992
testing
speedup
vectors
detected
data dependence
coupled subscripts
array references
dependence direction
partially linear
dependence distance
dependence test
user assertions
dependence analysis
the dependence
nonlinear subscripts
reference pairs
symbolic terms
direction vector
dimensional array
array reference
s1 and
dependence distances
linear subscripts
between s1
d dissertation
l conf
and s2
data dependences
of array
test algorithms
iteration i
at urbana
on supercomputing
dependence directions
data independence
int l
dependence between
illinois at
a dependence
i loop
urbana champaign
test sequence
ph d
in iteration
of illinois
or partially
single dimension
subscripts and
in parafrase
of s2
equal test
champaign dcs
independence detection
dissertation university
depen ence
all equal
the test
subscript expression
supercomputing p
gcd test
reference pair
test method
wolfe test
test is
acm sigplan
constant propagation
dependence exists
multiprocessor systems
banerjee wolfe
exact test
direction vectors
conf on
loop is
unknown symbolic
nonzero coefficients
on s2
d kuck
then s1
test terminates
rpt no
s2 has
root test
loop nesting
interprocedural constant
loop indices
parallel processing
real valued
unknown variables
proceeds to
linear or
parallel execution
self scheduling
have coupled
theta test
given dependence
diophantine equation
detection rate
proc of
the gcd
loop index
subscripts in
coefficients of
sigplan notices
distance with
test 4
for supercomputing
j loop
on multiprocessor
of s1
of dependence
references and
s1 is
valued solutions
test could
array subscripts
a loop
notices v
rep iucdcs
working programs
p yew
dimension tests
21 no
usage frequency
p tang
test proceeds
yew and
loop partitioning
ith coupled
different passes
total array
undefined defined
s2 due
flow dependent
u banerjee
iucdcs r
a references
dcs rep
1988 int
c zhu
two dimensional
references with
test methods
s2 in
distance is
parallelizing compiler
of references
are linear
real programs
how often
for array
considered simultaneously
2 coupled
s1 in
data depen
constant distances
next dimension
references were
data synchronization
dimension test
library routines
c chen
is flow
or 1
a subscript
of unknown
the loop
terminates otherwise
unknown values
user programs
every loop
flow dependence
example 2
analysis for
did not
references are
the percentage
west germany
cross iteration
may 1998
do loop
ordinary programs
1991 cologne
cologne west
21 1991
table 9
university of
either 1
be executed
direction for
the all
it proceeds
dependence tests
index variable
zhiyuan li
integer solutions
of loop
statements in
references in
interprocedural analysis
a parallelizing
the theta
in array
with coupled
dependence testing
array reference pairs
s1 and s2
ph d dissertation
int l conf
between s1 and
in iteration i
dependence direction vector
data dependence analysis
at urbana champaign
illinois at urbana
the dependence distance
linear or partially
or partially linear
of illinois at
two dimensional array
data dependence test
dimensional array references
conference on supercomputing
dependence between s1
d dissertation university
partially linear subscripts
dependence distance with
dissertation university of
all equal test
urbana champaign dcs
l conf on
the i loop
dependence analysis and
on supercomputing p
university of illinois
dependence analysis for
banerjee wolfe test
the gcd test
a dependence direction
1 or 1
distance with respect
data dependence exists
interprocedural constant propagation
the exact test
i loop is
and s2 has
dependence test methods
the all equal
the test terminates
coefficients of loop
dependence direction vectors
s2 has a
unknown symbolic terms
dependence test algorithms
the j loop
dimensional array reference
data dependence between
array references with
on multiprocessor systems
a data dependence
sigplan notices v
acm sigplan notices
either 1 or
is flow dependent
a subscript expression
iteration i must
data dependence tests
and s2 due
test is performed
dependent on s2
1988 int l
otherwise it proceeds
of s1 in
execution of s1
detection rate of
of unknown variables
dcs rep iucdcs
champaign dcs rep
s1 in iteration
rep iucdcs r
test terminates otherwise
test proceeds to
percentage of references
s2 due to
the flow dependence
each test method
terms with unknown
and c zhu
number of unknown
with unknown values
the theta test
flow dependent on
single dimension tests
j loop is
dependence distance is
then s1 is
i loop and
yew and c
of array subscripts
ith coupled subscripts
terminates otherwise it
the dependence direction
pair of array
in data dependence
have coupled subscripts
of array references
the acm sigplan
proc of the
the next dimension
the given dependence
have constant distances
are linear or
with coupled subscripts
2 coupled subscripts
flow dependence between
test could be
of loop indices
a loop index
statements in a
are either 1
for every loop
it proceeds to
dependence test for
example 2 4
proceeds to the
21 1991 cologne
real valued solutions
could be extended
cologne west germany
by each method
the reference is
the statements in
1991 cologne west
is no data
17 21 1991
we did not
the percentage of
can be executed
the test sequence
a distance of
proceedings of the
shows the percentage
a parallelizing compiler
the two dimensional
june 17 21
to the j
column shows the
5th international conference
the above example
the 5th international
therefore the equation
total array references
that quite a
i must follow
solutions and there
independence detection rate
loop is variable
equal test is
i 1 s3
he diophantine equation
of its coefficients
wolfe beyond induction
distance of 1
on large multiprocessor
in different passes
l conf parallel
the dependence crosses
data dependence distance
in library routines
often coupled subscripts
scheme to enforce
sigplan not vol
user assertions to
s3 in iteration
art in data
large multiprocessor systems
in array references
in partially linear
s2 in iteration
urbana champaign rpt
exact test could
of user assertions
solutions suffice in
rice university houston
of s3 in
of self scheduling
for supercomputing research
kuck r kuhn
how often coupled
data dependence on
is antidependent on
symbolic terms with
constant dependence distance
p tang p
d kuck r
three factors that
packages were chosen
discovered that a
w nonlinear subscripts
is per formed
enforce data dependence
gcd test the
program partitioning and
references ith coupled
current data dependence

corpus/krapavin2000-test/629046.txt
ped
dependences
dependence
loop
parascope
interprocedural
pane
transformations
pfc
editor
fortran
ptool
parallelization
parallelism
loops
editing
enddo
interactive
private
button
edits
synchronization
mimdizer
buttons
interchange
array
users
displayed
edit
sink
sigmacs
ptran
inapplicable
transformation
kennedy
assertions
program
ir
skewing
display
dataflow
unsafe
analyzer
faust
vectorizing
scalar
pat
text
symbolic
nest
automatic
race
advice
statements
parallelized
superb
sequential
references
supercomputing
compiler
diagnostic
iteration
tool
vectorization
kathryn
ffis
subscripted
safe
anti
inhibit
programs
ken
conservative
flow
incremental
carried
chau
ffl
statement
tools
supercomputers
scientific
mckinley
wavefront
iterations
enabled
browser
codes
pcf
miscellaneous
unrolling
machines
displays
parallelizing
shared
programmers
reordering
warren
deletion
1991
programming
facility
selects
havlak
postdominator
guidebook
panes
underlined
rice
mouse
anomaly
sequent
optimizing
debugging
preserved
structured
tseng
mechanically
opportunity
dialog
classification
preserve
propagation
imprecise
post
breaking
transforma
interlock
vectorizer
deleted
expert
safely
assist
expose
experiences
source
multiprocessing
hazards
alamos
delete
hide
wen
query
splitting
concert
interchanges
supercompilers
assignment
38
enhancing
supports
fly
inhibits
steering
dominance
ssa
mature
option
unstructured
assistance
hybrid
override
programmable
directives
utilizes
push
advanced
replacement
tiling
inner
guide
nested
compilers
precision
fusing
notices
headers
arrays
subscript
1994
overlooked
abilities
static
event
driver
overcomes
adjusts
spurious
maintained
environment
discovers
effects
project
enclosing
classifies
elsewhere
permits
testing
errors
sigplan
dependence analysis
the dependence
dependence graph
parallel programming
parascope editor
the parascope
the loop
of dependences
interprocedural analysis
the user
the dependences
ped is
dependences that
in ped
programming environment
the program
dependence information
dependences in
ffl loop
transformations are
a loop
loop carried
dependence pane
text pane
program transformations
loop and
of dependence
ir n
parallel loop
a parallel
event synchronization
a dependence
of interprocedural
in parallel
s 1
control flow
carried dependences
dependence analyzer
dependences for
dependence testing
loop interchange
the ir
statement dependence
of ped
dependence display
enddo enddo
ped s
pane the
dependence is
interactive parallel
current dependence
analysis and
the transformation
data dependence
constant propagation
iteration space
array references
loop level
a transformation
an interactive
run in
reordering transformations
structured transformations
ped has
dependences the
variable classification
control dependence
i loop
data dependences
a program
side effects
synchronization in
programming tool
dependences are
assignment statement
loop may
transformations that
the transformations
private variables
editor a
dependence s
parallel fortran
n programming
current loop
ken kennedy
be run
user selects
loop nest
loop in
independent statements
for subscripted
loop skewing
level parallelism
s dependence
subscripted variables
advice and
true dependence
program changes
source and
the text
procedure calls
step size
parallelism in
symbolic analysis
an edit
experiences using
loop independent
dataflow analysis
the current
are enabled
they want
program analysis
conservative dependences
pcf fortran
assist users
source reference
mechanically possible
1 ffis
any assertions
by ped
or private
button the
sink variable
ffl defined
dependence list
imprecise dependence
wavefront method
scalar replacement
useful parallelism
scalar dataflow
miscellaneous transformations
pat can
sink reference
of automatic
parallel programs
fortran programs
dependences and
transformation is
memory machines
for parallel
and dependence
that loop
s 2
dependence in
the variable
optimizing transformations
transformations dependence
false dependences
loop distribution
interactive program
sequential loop
s mckinley
interprocedural side
editor is
2 later
loop into
incremental dependence
dependence type
kathryn s
transformation algorithms
the wavefront
expert advice
parallel form
ffl statement
this mechanism
be displayed
transformations the
distributed memory
analysis in
nested loops
presented with
section analysis
race conditions
regular section
is underlined
dependence occurs
dependences which
automatic tools
interactive parallelization
the parallel
precision of
programs to
is displayed
loop can
variables from
the precision
anomaly detection
enabled when
interprocedural constant
scientific programs
chau wen
and interprocedural
wen tseng
precise analysis
with loop
parallel machines
user is
the source
iteration of
graph and
the parascope editor
the dependence graph
a parallel programming
the dependence pane
the text pane
run in parallel
in the dependence
parallel programming environment
loop carried dependences
the ir n
in a parallel
a parallel loop
be run in
dependence graph and
statement dependence graph
dependence analysis and
of the program
dependence analysis for
parallel programming tool
the current dependence
interactive parallel programming
of the dependences
interprocedural analysis and
of the loop
dependence analysis in
in the program
synchronization in a
dependences in the
loop level parallelism
the dependence analyzer
event synchronization in
the dependences in
the dependence display
of dependence analysis
control and data
if the transformation
ir n programming
the current loop
dependences in a
n programming environment
and the dependence
for subscripted variables
of interprocedural analysis
in a program
the i loop
analysis and optimization
is an interactive
the iteration space
in the loop
the loop and
s 1 ffis
scalar dataflow analysis
imprecise dependence analysis
the transformation algorithms
dependence is preserved
all the dependences
s 1 indicates
s 2 later
when s 1
occurs when s
programming environment an
programs for parallel
parascope editor is
provided by ped
the wavefront method
to assist users
of dependence information
transformations are enabled
dependence pane the
dependence occurs when
enddo enddo enddo
text and structure
interprocedural analysis of
and sink variable
interactive program transformations
assist users in
dependence s 1
into a parallel
of the parascope
loop and used
and its use
the user selects
of the dependence
the user is
the precision of
of an edit
user selects the
incremental dependence analysis
dependences for the
are enabled when
loop may be
kathryn s mckinley
its use in
the transformation is
distributed memory machines
of a loop
all of the
analysis and transformation
and data dependences
that s 2
running in parallel
in parallel programming
regular section analysis
the transformations are
in a loop
in the text
iteration of the
chau wen tseng
static single assignment
data dependences in
the user to
semantics of the
data dependence analysis
practical dependence testing
and optimization in
source and sink
they want to
the source and
conference on supercomputing
an assignment statement
the control flow
want to be
may then be
the user can
carried by the
1 indicates that
the execution of
loop in the
detecting data dependences
editor a new
with the mouse
analysis of dependences
from running in
improve the precision
graph the statement
that loop the
ped s dependence
to private storage
level parallelism in
a guidebook to
limitations of automatic
j loop in
variables from one
sets of dependences
focuses on loop
dependence breaking transformations
of scientific programs
the graph can
of the ir
a statement dependence
for interactive parallelization
use of diagnostic
evolution of parascope
compilers a test
notice in figure
the parascope project
analysis of low
potential candidates for
on loop level
from being run
dependence filter facility
wait event synchronization
given an opportunity
query become the
iteration space of
determine whether two
13 14 56
variable classification dialog
dependence in ptran
programming tool proceedings
of the ptran
information is displayed
analysis a dependence
dependences that cross
debugging with on
expert advice and
analysis for interactive
structured program transformations
skewing the wavefront
propagation with conditional
with loop interchange
programming on sequent
of array side
new interactive parallel
the ptran analysis
classes of dependences
dependences with the
analysis system for
improving balance for
the original sequential
match the query
for multiprocessing a
buttons in the
by permitting the
9 13 14
use in optimization
experience with interprocedural
ped focuses on
transformations the following
last k iterations

corpus/krapavin2000-test/629048.txt
interprocedural
pfc
riceps
linpack
dependence
yew
subscript
kennedy
regular
parallelization
array
descriptors
triolet
subscripts
supercomputing
parascope
linpackd
compiler
fortran
dependences
rice
notices
summary
lattice
ref
stride
sigplan
dogleg
propagation
precision
ranges
parafrase
parallelism
symbolic
parallelized
lowenthal
kathryn
callahan
calls
dataflow
dads
sites
effects
li
benchmarks
ken
hall
arrays
expressions
loops
subarrays
sandhya
blas
style
diff
references
optimizing
enddo
atom
loop
compilers
1992
rugina
dad
inline
cdrom
mckinley
linearization
mary
rs
codes
meet
translation
mpi
toplas
ip
subroutines
compilation
referenced
regions
rinard
dwarkadas
manchester
translating
cache
merge
supercomputer
junjie
england
strides
amarasinghe
standardization
editor
caller
scalar
programs
saman
inlining
radu
monica
intersection
scientific
descriptor
mimd
zhiyuan
hoeflinger
paek
flow
merged
suite
sections
precise
convex
merging
mod
bronis
clobber
marathe
jaydeep
chauhan
eggers
blockability
dhruva
supinski
jeremiassen
delinearization
efie
weatherly
telescoping
12338
lowered
abs
perfect
transformations
classical
gu
united
tseng
aug
kd
cooper
1993
july
ayon
rencuzogullari
vectorizing
basumallik
murphy
tushar
reshaped
mckee
reshapes
nakazawa
deficiency
disciplines
intersecting
euler
locations
restructuring
san
else
multiprocessors
programming
hazard
willy
brent
yunheung
eigenmann
chakrabarti
umit
gyungho
yoo
analyzers
zwaenepoel
franklin
sorrento
1966
lo
banerjee
1998
keeping
site
interactive
lam
mueller
hazards
club
rudolf
privatization
inefficiencies
sally
1995
bounds
translated
utility
induction
jose
procedures
translate
liao
regular sections
regular section
section analysis
interprocedural analysis
and yew
dependence analysis
on supercomputing
side effects
value numbers
li and
supercomputing p
call sites
parallel programming
actual parameter
of interprocedural
notices v
sigplan notices
formal parameter
acm sigplan
of regular
interprocedural side
access sets
ref a
interprocedural propagation
constant propagation
induction variables
meet operation
ken kennedy
dataflow analysis
parallelization of
interprocedural summary
global value
ieee conference
acm ieee
bounded regular
local analysis
the parascope
atom images
loop induction
summary analysis
summary regular
data access
symbolic analysis
a else
programming style
analysis for
parascope editor
summary information
array side
calls in
call graph
the blas
program parallelization
sections with
conference on
subscript expressions
shared memory
yew s
bounds f
meet operations
rice compiler
restricted regular
and kennedy
parallel calls
an interprocedural
analysis alone
end algorithm
compiler evaluation
program suite
then ref
true access
dependence graphs
interprocedural constant
the rice
the meet
sections for
call site
at rice
procedure calls
effects of
the subscript
analysis and
dependence testing
automatic parallelization
analysis in
called procedure
s mckinley
corresponding actual
modular programming
kathryn s
return end
distributed shared
on programming
proceedings of
of procedure
algebra subroutines
w hall
access descriptors
codes from
mimd distributed
inline expansion
complete applications
side effect
n 7
7 p
the call
the referenced
with bounds
of subscripts
actual parameters
the linpack
supercomputing cdrom
cdrom p
distributed memory
systems toplas
toplas v
evaluation program
bounds information
summary sections
referenced section
section subscripts
subarrays that
lo bounds
sections implemented
programming support
triolet s
compilation dependences
subscript values
stride information
radu rugina
subscript lattice
alone ip
efficient interprocedural
other interprocedural
enddo return
rugina martin
summary section
pfc and
of meet
classical interprocedural
scientific disciplines
programming environment
fortran d
sections are
memory machines
each procedure
of references
of parallelism
and intersection
each reference
and systems
a procedure
cache performance
international conference
saman p
interactive parallel
p amarasinghe
were parallelized
parameter array
k lowenthal
direct parallelization
and intersecting
interprocedural array
and procedure
consistent then
convex regions
manchester england
invariant expressions
pfc s
linpack library
of pfc
in pfc
15 1994
1994 manchester
editor an
sandhya dwarkadas
united states
ranges for
programming v
else if
begin if
07 13
on complete
s lam
each subscript
recursive programs
call statements
monica s
analysis must
junjie gu
mary w
gu zhiyuan
s else
perfect benchmarks
languages and
of call
precision of
the perfect
of parallel
programming languages
regular section analysis
li and yew
conference on supercomputing
on supercomputing p
sigplan notices v
acm sigplan notices
of regular section
acm ieee conference
ieee conference on
proceedings of the
ref a else
regular sections we
the parascope editor
of regular sections
a formal parameter
of procedure calls
the meet operation
interprocedural constant propagation
the rice compiler
and yew s
modular programming style
the dependence graphs
global value numbers
true access sets
bounded regular sections
rice compiler evaluation
then ref a
loop induction variables
number of subscripts
languages and systems
on programming languages
n 7 p
distributed shared memory
side effects of
kathryn s mckinley
data access descriptors
interprocedural analysis and
interprocedural side effects
programming languages and
linear algebra subroutines
the side effects
of interprocedural analysis
mimd distributed memory
on supercomputing cdrom
of parallel programming
distributed memory machines
supercomputing cdrom p
international conference on
number of references
the call graph
dependence analysis and
transactions on programming
systems toplas v
and systems toplas
journal of parallel
regular sections for
enddo return end
the referenced section
performance of regular
library of linear
restricted regular sections
section analysis is
consistent then ref
regular sections with
of scientific disciplines
parameters and global
of meet operations
effect analysis in
access sets the
linpack library of
the true access
codes from a
on complete applications
evaluation program suite
they can represent
value numbers for
analysis alone ip
summary regular sections
analysis in linear
compiler evaluation program
the subscript lattice
radu rugina martin
section analysis on
and its use
parallel programming v
data flow analysis
of call statements
interprocedural side effect
1994 manchester england
and the perfect
parascope editor an
parallelization of call
corresponding actual parameter
saman p amarasinghe
11 15 1994
32 n 7
interactive parallel programming
july 11 15
15 1994 manchester
for each procedure
36 n 7
david k lowenthal
the linpack library
to the blas
memory machines proceedings
the called procedure
array side effects
direct parallelization of
effects of procedure
interprocedural analysis for
using the parascope
analysis for program
its use in
gu zhiyuan li
mary w hall
junjie gu zhiyuan
1998 acm ieee
and global variables
november 07 13
notices v 32
for each array
07 13 1998
monica s lam
detection of parallelism
side effect analysis
dataflow analysis for
13 1998 san
cdrom p 1
software distributed shared
automatic parallelization of
written in an
machines proceedings of
of linear algebra
interprocedural dependence analysis
29 n 2
1998 san jose
the same shape
analysis and optimization
quadratic in the
notices v 36
the 1998 acm
8th international conference
the 8th international
acm transactions on
the data access
san jose ca
the number of
in the number
parallel and distributed
the effects of
the precision of
programs written in
of the 1998
bounds a i
the six programs
chauhan ken kennedy
parallelization of numerical
bounds analysis of
an ambitious optimizing
liao monica s
franklin lowenthal dyn
of discovering parallelism
of complete application
regular sections implemented
complete application codes
jaydeep marathe frank
dependence graphs produced
fast execution time
take time proportional
keeping useful internal
interprocedural analysis alone
range then let
non dedicated clusters
call sites in
in a style
optimizing communication in
wei liao monica
of pointers array
figure 2 lattice
interprocedural data flow
in common blocks
an o d
else let l
jeremiassen susan j
array data flow
regular section subscripts
a that may
good programming practice
dependences in an
expense of translating
pointers array indices
s else return
for arrays and
r chakrabarti prithviraj
supercomputer performance evaluation
program parallelization and
pass a i
call statements a
ambitious optimizing compiler
riceps a set

corpus/krapavin2000-test/629058.txt
arrays
array
partitions
0c
loop
partitioning
loops
interprocessor
offset
ff
communication
processor
cc
diagonals
supercomputing
kandemir
alignment
partition
locality
offsets
choudhary
compilers
compiling
compiler
interchange
accesses
banerjee
ramanujam
mahmut
allocation
anti
superb
partitioned
multicomputers
transformations
operands
machines
columns
pingali
simd
programmer
decompositions
optimizing
parallelograms
equations
references
executes
automatic
parallelogram
fortran
restructuring
processors
1995
alok
parallelizing
multiprocessors
ping
dependences
annotations
esin
jih
woei
mongenet
gannon
aids
formulation
incurred
rows
fi
outer
taylan
decomposition
hyperplane
memory
compatible
wrap
huang
vectors
deriving
parallelism
sheu
family
interchanging
peizong
keshav
kth
paid
shared
prithviraj
mar
supercompilers
catherine
iterated
distribute
1993
volume
parallelization
accessed
numa
nests
shenoy
iterations
transformation
interchanged
nested
notices
matrix
tokyo
computers
diagonal
7th
dataflow
writer
chu
compilation
programs
owner
mod
workload
supercomputers
shapes
mutually
sigplan
referred
consuming
chih
procedural
wei
defines
minimizing
rowwise
ender
ponnusamy
marchdec
zdamar
orchestrating
suprenum
prith
acknowlegdment
kastner
wenrui
zima
knobe
rnger
zcan
enormity
memetic
rauber
loechner
minyi
equationsb
musicus
raja
lebarta
systemb
linet
onbaioglu
todate
onbasioglu
gudula
stripmined
gallivan
assignment
li
sequentially
february
japan
memories
worthwhile
row
organization
admit
free
scientific
rewritten
macro
inter
gupta
affine
minimize
architectures
passing
day
incur
improving
trapezoidal
relieved
akimasa
koshizuka
yoshida
nagaraj
nonshared
cedar
ayguad
1336
honoring
chua
1321
cierniak
blaze
communication free
free partitioning
of arrays
ff cc
c 0c
0c a
array a
arrays a
partitions of
of array
offset vectors
cc a
array b
processor k
b ff
distributed memory
interprocessor communication
of equations
constant offsets
zero communication
no communication
parallel loops
ff 0
free partitions
executes 1
into columns
memory machines
the partitions
k executes
in array
the loop
local memory
a 22
partitioning of
when communication
linear references
parallel lines
partitioned into
dimensional arrays
on distributed
loop interchange
and b
following system
data distribution
communication in
r mod
anti diagonals
following loop
data partition
a and
lines in
a solution
communication is
the accesses
a formulation
for communication
of parallel
a 21
locality of
fully parallel
j ramanujam
of lines
the offset
partition of
on supercomputing
k p
complex memory
shared memory
partitioning is
compiling programs
matrix s
loop l
outer loop
in interprocessor
mod are
compatible partitions
communication minimization
in arrays
loop after
into anti
alignment functions
mutually compatible
process partitioning
solution 1
of ff
a compiler
loop transformations
automatic data
array accesses
on parallel
parallelizing compilers
family of
of loop
supercomputing p
system of
following set
data partitioning
partitions are
data decomposition
supercomputing v
of supercomputing
parallel and
and distributed
of fortran
in deriving
a family
the element
storage patterns
ramanujam a
offsets in
as processor
into rows
sequentially iterated
that aids
matrix notation
iterated parallel
index domain
b for
same processor
and loop
a 12
alok choudhary
formulation that
compiling for
and fi
to as
for parallel
1 k
the journal
programs for
the programmer
after transformation
inter processor
aids in
computers acm
minimizing communication
is partitioned
distributed systems
a which
a 11
present a
wei li
0 means
paid to
referred to
allocation of
is incurred
fortran programs
allocation problem
result in
memory systems
the array
array elements
data allocation
is paid
of data
systems v
example example
example 10
array element
array access
of reference
0 a
transformations in
fi 0
defines a
li keshav
to managing
complicated example
discuss techniques
also assigned
normalization loop
lines given
access normalization
loop example
communication see
data usage
vectors q
current day
describe array
diagonals figure
arrays into
huang chih
accesses result
get ff
therefore worthwhile
determine allocation
jih woei
given partition
automatic process
loop interchanging
incur zero
deriving heuristics
catherine mongenet
optimizing data
therefore ff
2n by
worthwhile for
if insufficient
set array
communication free partitioning
arrays a and
ff cc a
a b ff
c 0c a
0c a b
b ff cc
partitions of arrays
of arrays a
a and b
communication free partitions
is no communication
executes 1 k
1 k p
k executes 1
processor k executes
one of ff
b for example
on distributed memory
when communication free
for communication free
b c 0c
family of lines
free partitioning is
and b for
set of equations
of array a
array a is
k p to
of array b
the following loop
the offset vectors
in array b
partitioned into columns
fully parallel loops
that r mod
lines in array
i of array
partitioning is possible
family of parallel
cc a which
system of equations
partitioning of arrays
a is partitioned
the partitions of
the following system
conference on supercomputing
most one of
partitions of a
distributed systems v
transactions on parallel
has a solution
parallel and distributed
and distributed systems
distributed memory machines
on parallel and
referred to as
partition of a
following set of
linear references in
into anti diagonals
formulation that aids
of equations which
that aids in
in interprocessor communication
free partitions are
b are partitioned
free partitioning of
constant offsets in
p to n
r mod are
can we find
communication is incurred
ff 0 means
of parallel lines
partitioned into rows
to processor k
for linear references
loop after transformation
present a formulation
as processor k
for the partitions
0 c 0c
zero communication in
in array a
partitioned into anti
interprocessor communication in
equations which has
shows the partitions
and loop interchange
alignment functions that
of communication free
allocation of arrays
a family of
on supercomputing p
locality of reference
the following set
journal of supercomputing
of supercomputing v
is partitioned into
partitions are not
sequentially iterated parallel
attention is paid
iterated parallel loops
12 a 22
of lines in
the matrix s
n by p
of loop transformations
j ramanujam a
the same processor
a i j
the journal of
the outer loop
of ff 0
compiling programs for
to n by
is paid to
interprocessor communication is
are not feasible
array accesses in
11 a 21
assigned to processor
array a and
defines a family
for data partitioning
order to minimize
consider the following
such that r
elements of array
of fortran programs
techniques for data
no communication is
shared memory machines
in distributed memory
data distribution and
paid to the
of a and
ieee transactions on
of the partitions
a 12 a
following system of
parallel programming v
a 11 a
of the loop
is possible if
row i of
is referred to
to the following
the problem of
journal of parallel
values of c
which has a
huang chih ping
if we allocate
array b is
matrix notation to
of equations would
no data dependences
of data usage
the line in
is therefore worthwhile
in fully parallel
pingali access normalization
line in array
describe array accesses
data access graph
rows r of
reduce communication on
22 0 c
communication see figure
of optimizing data
partitioning decomposition of
partition of b
analysis will have
technique for linear
non trivial solution
a 21 0
distribution in superb
loop transformations in
in deriving heuristics
addition to managing
communication when communication
being partitioned into
offset vectors q
loop l 1
0 a 12
0 and fi
array b to
case array a
data usage to
determine allocation in
allocation problem then
analyze patterns of
processors is p
therefore for communication
same processor then
are no data
compiler to analyze
no communication see

corpus/krapavin2000-test/629077.txt
arrays
array
dimensions
processors
cyclic
compiler
sequentialized
partitioning
alignment
loop
dimension
multicomputers
grid
loops
contiguous
kandemir
parallelization
sequentialize
parallelizing
processor
aligned
tred2
mahmut
supercomputing
replicated
references
quality
parallelizable
ramanujam
parallelism
cag
xij
subscript
banerjee
cyclically
interprocessor
choudhary
parafrase
ipsc
fortran
1994
communication
sequentialization
replication
prithviraj
notices
multiprocessors
programs
sigplan
program
xrsiq
zaafrani
costs
distributions
rhs
constraints
measures
favoring
ito
locality
anderson
monica
1995
compilers
onetomanymulticast
constraint
jennifer
1993
decisions
alok
block
subroutines
trfd
apl
dgefa
subscripts
topology
automatic
eispack
ym
wg10
zm
tseng
rows
compile
chau
linpack
vm
manish
distribute
compiling
strategy
assignment
tuple
chen
shenoy
ching
lam
var
optimizations
layout
distribution
diniz
manytomanymulticast
interf
modn
pande
primitives
lhs
interprocedural
ifip
owns
compilation
gets
segments
scientific
washington
pivoting
united
appearing
nested
aug
statement
outer
flo52
nagaraj
rinard
pedro
1251
taylan
mee
machines
methodology
routine
align
xm
segment
toplas
index
conflicts
coprocessor
sheu
dino
santosh
restructurer
mdg
amarasinghe
gains
expression
memory
message
subramanian
advocates
club
saman
multicasting
peizong
estimates
regarding
wen
determination
speedup
shared
across
superb
wai
balasundaram
kremer
affinity
sequential
programmer
iterated
subroutine
transformations
commack
nova
katz
kind
favor
intel
gupta
considerations
varies
chien
override
ulrich
numerous
multiply
kennedy
imbalance
dependence
routines
512
emerges
wise
np
determining
partitioned
tokyo
microseconds
quality measures
data partitioning
array dimensions
data distribution
grid dimension
cyclic distribution
array dimension
the array
our strategy
the distribution
distributed memory
the compiler
of processors
of arrays
distribution scheme
the program
processor grid
of constraints
distribution of
execution time
constraints on
an array
quality measure
automatic data
communication constraints
do do
distribution function
alignment of
on supercomputing
communication costs
various arrays
processors along
of various
the processor
distribution functions
partitioning scheme
various constraints
supercomputing p
parallelization constraints
parafrase 2
j ramanujam
the arrays
interprocessor communication
the quality
d arrays
these arrays
block size
array is
the communication
the alignment
dimensions are
dimensions of
a cyclic
mahmut kandemir
program segment
ipsc 2
notices v
program segments
those arrays
parallelizable loops
m anderson
to sequentialize
jennifer m
component alignment
sequentialization of
loop index
sigplan notices
loop in
acm sigplan
of array
on processors
for multicomputers
prithviraj banerjee
measures of
the loop
processors on
each array
for execution
their quality
our approach
that dimension
on multicomputers
on distributed
all processors
of dimensions
n i
parallelizing compiler
parallelizing compilers
arrays a
are distributed
is distributed
for data
memory multiprocessors
memory machines
real programs
shared memory
on parallel
a zaafrani
distributed cyclically
below do
final distribution
contiguous or
aligned dimensions
various loops
grid topology
corresponding grid
contiguous distribution
relative block
distribution schemes
small arrays
memory multicomputers
dimension is
each dimension
for parallelizing
of distribution
a constraint
for distributed
and z
project at
replicated on
subscript expression
distribution for
and distributed
assignment statement
or cyclic
alignment problem
and chen
various dimensions
each constraint
the 1994
that computation
block sizes
of automatic
expression for
on data
of quality
reference patterns
array we
a loop
conference on
parallel and
two dimensions
data references
explicit communication
1994 washington
s lam
arrays we
monica s
alok choudhary
multicomputers proceedings
of aligned
on all
references in
dimensions we
corresponding to
communication time
the constraints
across processors
li and
processors in
partitioning of
parallel program
dimensions in
the assignment
of n
transactions on
dimension of
be aligned
by rows
proceedings of
constraints and
distributed systems
replication of
outer loop
gets mapped
smaller arrays
scheme suggested
contiguous manner
is sequentialized
time expression
gains made
aggregate communication
on fortran
processor tuple
aligned array
distribute arrays
multiprocessors acm
compiler would
r ito
various array
zaafrani m
parallelizable loop
arrays used
xij 1
tred2 program
the kind
memory parallel
compile time
along that
parallel loops
the quality measures
an array dimension
quality measures of
the distribution of
number of processors
conference on supercomputing
for execution time
automatic data partitioning
of an array
data partitioning scheme
for data partitioning
constraints on the
on supercomputing p
distribution of arrays
a and z
on the distribution
of the program
of these arrays
the processor grid
data distribution scheme
the quality measure
of the array
of our strategy
processors on which
on data distribution
sigplan notices v
acm sigplan notices
loop in which
for distributed memory
in the program
arrays a and
distribution function for
distribution of various
of automatic data
their quality measures
jennifer m anderson
expression for execution
and n 2
of processors on
of the processor
values of n
on distributed memory
dimension is distributed
the data distribution
1 and n
proceedings of the
of n 1
n 1 and
distributed systems v
transactions on parallel
the alignment of
the distribution function
and distributed systems
distribution of a
parallel and distributed
on parallel and
distributed memory multicomputers
in a cyclic
replicated on all
the array dimensions
distribution of an
the component alignment
contiguous or cyclic
class of aligned
the final distribution
relative block sizes
notion of constraints
of processors along
the corresponding grid
of various arrays
quality measures the
component alignment problem
measures of various
measures of constraints
of quality measures
outer loop index
cyclic distribution for
the array is
of the 1994
value of n
li and chen
kinds of constraints
array dimensions are
quality measure of
all array dimensions
the parallel program
numbers of processors
the block size
ieee transactions on
the distribution functions
the communication costs
multicomputers proceedings of
monica s lam
1994 washington d
do do do
the kind of
the subscript expression
notices v 30
communication can be
with the value
the value of
data distribution the
on fortran programs
execution time expression
second distribution function
processors along the
array dimension a
of their quality
of elements along
corresponding grid dimension
m r ito
dimension a k
dimensions in that
two array dimensions
and z by
multiprocessors acm sigplan
below do do
to real programs
class of dimensions
the compiler would
arrays used in
in different steps
satisfied or not
should be aligned
array dimensions we
of various constraints
by our strategy
zaafrani m r
scientific application programs
shown below do
are not aligned
determine the applicability
array dimensions is
a contiguous manner
alignment of array
array dimension is
a zaafrani m
various array dimensions
the type index
regarding the distribution
on the alignment
alignment of two
two dimensions of
formulation of constraints
constraint to sequentialize
for parallelizing compilers
washington d c
the program and
acm ieee conference
the communication time
on all the
the numbers of
ieee conference on
corresponding to the
distributed memory parallel
data partitioning on
choudhary j ramanujam
by li and
mahmut kandemir alok
the array dimension
constraints on data
2 d arrays
n i the
iterated parallel loops
sequentially iterated parallel
overall execution time
partitioning of arrays
the overall execution
different steps of
of array dimensions
implementing our approach
our strategy for
the ipsc 2
data references in
kandemir alok choudhary
a cyclic manner
a constraint to
different parts of
distributed memory machines
the same processor
the outer loop
d and e
number of elements
architectures and compilation
problem of automatic
intel ipsc 2
a 1 with
in that class
techniques for parallelizing
for each array
on all processors
in a contiguous
wg10 3 working
3 working conference
the second distribution
the ifip wg10
reference patterns in
of constraints that
of the ifip
along each dimension

corpus/krapavin2000-test/629113.txt
quorum
coterie
coteries
nondominated
quorums
join
8g
antiquorum
dominated
composite
7g
agreements
nonempty
replica
f3
exclusion
6ae
62
f2
minimality
contradiction
qc
molina
abbadi
mutual
garcia
agrawal
f4
barbara
6g
qa
nonleaf
f9
el
cg
f6
unavailable
containment
agreement
4g
complementary
f8
masafumi
yamashita
tree
f5
intersection
9g
f1
f7
harada
complimentary
3g
takashi
fc
protocol
protocols
5g
read
iff
2g
cgg
gamma1is
ibaraki
gamma1such
replicated
gamma1
vote
saxena
rai
ae
rcd
children
voting
1g
timestamps
nodes
cu
timestamp
availability
cis
votes
vulnerability
ag
node
enumerate
copy
copies
rad
2b
returns
replicas
fa
advance
mc
inline
kuo
depth
decentralized
02
lem
consensus
append
kameda
tsaan
2gg
yiwei
nonreplicated
ffbgg
bioch
cbe
chiao
abaddi
ffagg
toshihide
1145
sangita
neilsen
gamma1qc
jagmohan
1134
0then
coter
clocks
assignments
satisfied
permission
ary
914
shyan
arbiters
658
1026
1gg
905
gamma15
1035
mizuno
shing
reviews
joining
formalized
dahlia
794
721
wool
avishai
747
masaaki
petersen
2a
subsection
dominates
replication
ments
false
agree
leaf
874
779
malkhi
728
865
maximal
subsets
write
transversal
sixteenth
folded
occasions
744
yu
likewise
wr
herlihy
662
ub
concurrency
prob
determining
accident
ies
weighted
reliability
byzantine
qg
reiter
ng
gracefully
kun
child
stabilizing
257
1995
database
equivalently
maxima
recovery
failures
acquires
a quorum
under u
a coterie
h 3
join algorithm
composite coterie
g 3
nondominated coteries
quorum g
tree coteries
coteries are
coterie under
quorum set
62 h
suppose g
the join
that g
g 2
c 3
y 62
quorum agreements
are nondominated
set under
replica control
6 h
h 1
intersection property
2 g
will show
is nondominated
input coteries
quorum agreement
write quorums
cases to
consider either
coterie is
complementary quorum
7 8g
a contradiction
g 1
mutual exclusion
u 3
x 62
q gamma1
the quorum
h 2
62 g
quorum of
exists y
a composite
2 c
is dominated
of nodes
6ae h
coterie join
coterie c
3 h
algorithm may
u 1
3 6
quorum sets
a nonempty
containment test
nonempty coteries
the coterie
coterie g
antiquorum set
a nondominated
quorum containment
agrawal and
and el
nonempty set
0 h
f2 3
c 1
f3 1
garcia molina
c 2
2 suppose
g 0
3 is
quorums of
q 3
generate quorum
f4 5
coterie and
qc s
nondominated coterie
agreement under
u 2
el abbadi
y 2
there exists
h 0
unavailable the
the quorums
node a
that y
1 suppose
ae ae
tree protocol
consider 1
distributed mutual
depth two
2 such
3 since
tree coterie
3 6ae
join function
nonleaf node
are quorums
and barbara
that qc
coteries of
nodes contains
f6 4
quorum which
coteries as
coteries may
6 4g
an antiquorum
coterie if
f5 6
we will
set h
3 such
nodes such
given set
to consider
a complementary
let u
some quorum
by agrawal
new larger
3 1g
any quorum
version number
and q
1 such
2 q
the composite
binary tree
control protocols
c is
because y
molina and
quorums in
exclusion in
distributed systems
theorem 2
let g
exclusion problem
tree c
two cases
2 h
either x
of read
since c
efficient method
2 3g
by theorem
the intersection
f8 9
7g and
coteries for
z 62
complimentary quorum
02 c
in quorums
in replica
f9 7
takes nonempty
takashi harada
coteries and
8 9g
simple input
antiquorum sets
coteries under
quorum h
harada masafumi
8g f2
8g are
masafumi yamashita
g 02
coterie the
qa 3
nondominated the
of coteries
vote assignments
9 7g
f7 8
and antiquorum
sets complementary
larger coterie
contains a
constructed by
g h
q 2
1 2g
then c
the join algorithm
is a coterie
that g 3
coterie under u
a composite coterie
set under u
quorum set under
show that g
a coterie under
will show that
is a quorum
cases to consider
contains a quorum
a quorum g
under u 3
we will show
y 62 h
set of nodes
join algorithm may
g 3 6
g 3 h
y 2 g
may be used
algorithm may be
g 3 2
be a nonempty
a quorum agreement
to consider either
3 h 3
tree coteries are
that y 62
coteries are nondominated
c 3 is
there exists y
2 c 3
a quorum of
x 62 g
3 2 c
1 suppose g
the input coteries
node a 1
3 6 h
a quorum set
6 h 3
the intersection property
is a contradiction
next we will
theorem 2 1
two cases to
first we will
g 2 c
q 3 is
agrawal and el
a nonempty set
nonempty set of
let g 3
the composite coterie
62 g 1
quorum g 2
intersection property is
3 is dominated
62 h 1
under u 2
62 h 3
quorum containment test
are two cases
such that g
3 is a
of nodes such
a set h
2 g 3
and write quorums
and el abbadi
exists y 2
2 g 1
such that y
h 3 6
to generate quorum
the quorum containment
consider 1 suppose
quorum agreement under
consider either x
binary tree protocol
a nondominated coterie
suppose g 2
a coterie g
of depth two
0 h 3
a complementary quorum
g 1 such
complementary quorum set
2 suppose g
agreement under u
properties in theorem
replica control protocols
are nondominated coteries
obtain a contradiction
2 such that
be a quorum
u 1 let
u 1 be
h 1 and
3 such that
to consider 1
distributed mutual exclusion
1 such that
a given set
nodes such that
2 g 2
1 let u
and some quorum
3 6ae h
tree coteries of
molina and barbara
quorum g 0
a coterie is
3 since g
by agrawal and
or x 62
f2 3 6
g 0 h
coterie join function
of nodes contains
c 3 there
note that qc
g 2 2
nonleaf node has
coteries may be
dominated by theorem
that qc s
6ae h 3
g 2 such
coteries of depth
composite coterie is
q gamma1 is
an antiquorum set
g 3 6ae
input coteries are
nodes contains a
h 3 since
under u 1
3 there are
c is a
1 be a
if a given
method for determining
the binary tree
of a composite
each case we
given set of
by theorem 2
that h 0
j i i
join algorithm to
definition of h
so there exists
u 2 be
introduced by agrawal
x 2 u
efficient method for
case we will
this is a
2 u 1
s contains a
h 3 and
showing that g
h 0 h
mutual exclusion in
mutual exclusion problem
garcia molina and
property is satisfied
distributed systems v
transactions on parallel
an efficient method
parallel and distributed
and distributed systems
read and write
follows that g
x 2 g
is a composite
2 1 there
start by showing
let u 1
ae ae ae
let u 2
may be applied
used to generate
in a distributed
on parallel and
we will find
in theorem 2
that the join
6 and g
c 2 first
sets complementary quorum
sets and antiquorum
5 tree coteries
and antiquorum sets
are unavailable the
some quorum g

corpus/krapavin2000-test/629124.txt
dunx
policy
page
numa
ss
migration
synth
coherency
gp1000
workload
placement
replication
pages
uma
sp
migrations
freeze
policies
ro
migrate
ideal
remote
fault
analytic
predictions
defrost
references
static
bouncing
msort
replicate
bbn
rm
rc
window
cache
replications
reference
faults
multiprocessors
mig
mod
psolu
hough
mor
gauss
scanner
copy
shared
theta
multiprocessor
memory
daemons
freezing
completion
predicted
wrm
mandel
mva
interprocess
processor
race
management
microseconds
trigger
operating
settings
4s
migrated
replicated
frozen
migrating
workloads
errors
decisions
rep
predicts
pr
experimental
virtual
coherence
7s
tc2000
hh3d
assortment
read
kernel
fish
contention
frame
invalidation
architectural
confidence
0s
factors
reevaluation
550
remotely
history
instances
os
architectures
varied
000
request
upsilon
effects
triggered
parameterized
controls
synthetic
activity
module
granularity
barriers
comprised
dynamic
wave
tuning
wait
degrades
tuned
platinum
6s
5s
bolosky
snooping
incorrect
consistency
servicing
costs
justify
99
hardware
recent
referenced
aging
fpr
fortunate
secs
replicating
ms
prob
plot
nine
encountered
barrier
spg
scanners
interconnection
measurements
seconds
validation
subtle
lw
invalidations
9s
transitions
measured
differences
queue
plotted
versions
sharing
programmer
accurate
excessive
pursuing
bt
movement
modification
worse
opportunities
poor
ten
invalidated
implementable
bx
experimentation
five
lr
bm
1s
count
program
contributing
simulates
nearly
transfer
interval
varying
questions
pivot
handler
invalidate
2s
nonuniform
addressing
experimentally
adjusts
page placement
ideal policy
recent mod
freeze window
workload model
static policy
theta theta
a page
the page
the numa
ss and
dynamic page
r ss
coherency fault
the policy
the uma
the dunx
copy page
numa memory
multiple copy
our workload
the ideal
memory management
cache policy
sp pages
replication coherency
analytic model
numa static
page bouncing
error policy
page migration
input parameters
memory reference
the analytic
the static
bbn gp1000
rm pages
dynamic multiple
static page
the gp1000
the mean
migration and
operating system
the workload
page fault
dynamic policy
analytic predictions
dynamic placement
synth instances
page classes
page is
shared memory
the model
and replication
and sp
of page
to migrate
completion time
e sp
local remote
ss pages
in dunx
workload 4
coherency faults
over migration
numa problem
k mig
w ss
placement activity
fault pairs
model predictions
the bbn
99 confidence
the freeze
that page
experimental data
of dynamic
virtual memory
mean time
in microseconds
system kernel
our analytic
synthetic program
performance of
w c
confidence interval
memory references
memory module
model experiments
uma dynamic
8 node
migration costs
dunx implementation
uma version
the synth
interprocess reference
rc migrations
a coherency
migration or
or replicate
policy decisions
policy but
numa version
k rep
ro and
phase transitions
remote architectures
uma static
reference history
placement policy
page replication
r ro
the cache
remote memory
read only
local memory
the experimental
r c
shared data
a replication
of references
measured performance
experiments r
ideal with
remote reference
migrations and
a numa
instance 5
the recent
system model
mean number
to replicate
references to
and predicted
replication is
q m
memory multiprocessors
a remote
measured completion
memory request
under dunx
page errors
predicted data
workload 3
r sp
window parameter
policy errors
page scanner
numa versions
the interprocess
550 000
reference granularity
our dunx
numa multiprocessor
the ro
write reference
our gp1000
for synth
and numa
migration is
only fashion
uma and
mod parameter
of freeze
dunx operating
ss values
mod on
000 550
copy policies
e ss
incorrect policy
dunx kernel
sp page
local frame
and rm
placement is
to reference
value analysis
page the
single copy
policy and
of recent
effects of
data obtained
replication the
a local
policy is
mean value
page faults
theta figure
parameter settings
the memory
static combination
placement policies
of policy
migrate or
sp values
run under
on reference
for replication
theta theta theta
the static policy
the ideal policy
dynamic page placement
copy page placement
multiple copy page
numa memory management
our workload model
the cache policy
r ss and
static page placement
replication coherency fault
ss and sp
dynamic multiple copy
of dynamic page
migration and replication
99 confidence interval
the workload model
and w ss
on the gp1000
the bbn gp1000
coherency fault pairs
the freeze window
the numa problem
is in microseconds
the error policy
the recent mod
ss and w
of the page
number of references
of the policy
operating system kernel
ro and rm
a coherency fault
page placement policy
local remote architectures
of recent mod
the analytic model
model experiments r
the uma version
experiments r is
r is in
mean value analysis
the page is
shared memory multiprocessors
mean number of
performance of the
a page fault
of the static
r c w
comparison of experimental
freeze window is
freeze window parameter
for synth instances
000 550 000
a numa multiprocessor
migrate or replicate
and predicted data
experimental and predicted
completion time in
dunx operating system
a page migration
a 99 confidence
the numa version
of experimental and
uma version of
shared data pages
on a numa
recent mod parameter
page placement the
recent mod on
read only fashion
the numa static
of dynamic placement
for the bbn
performance of some
a local frame
uma and numa
the mean number
the performance of
to a local
theta theta figure
the operating system
page fault that
experimental data obtained
window is set
a page that
the model predictions
reference time t
c r c
the system model
the mean time
of a page
to the page
effectiveness of dynamic
c w c
in class c
worse than that
in a read
triggered the fault
reference triggered the
page placement policies
page placement activity
to page bouncing
of the numa
the synthetic program
ss and wrm
uma dynamic combination
w ss values
policy design space
mean measured completion
dynamic policy points
of r ss
software input parameters
class c r
r sp and
when freeze window
ideal policy is
to our workload
wide assortment of
ro rm ss
comparison of 8
results completion time
bound a 99
to justify a
the mean measured
approximate mean value
sp and w
a frame on
model input parameters
in local remote
remote memory module
of our workload
that the policy
of our analytic
a performance goal
of the uma
interprocess reference granularity
dynamic placement activity
fault that results
replication over migration
the r ss
a synthetic program
the interprocess reference
necessary to justify
workload model for
ideal policy but
page placement is
in numa memory
and w sp
approximate ideal policy
input parameters to
numa static combination
performance dynamic policy
gp1000 measured performance
hand tuned numa
a wide assortment
numa shared memory
the reference count
workload 4 model
result in performance
race condition in
4 model experiments
w sp values
the dunx operating
the analytic predictions
and network contention
of 8 node
migration or replication
page to a
of freeze window
single copy policies
number of migrations
the uma dynamic
our analytic model
that of the
a read only
in the analytic
kernel for the
prob of a
the 99 confidence
time to actually
local and remote
memory and network
page migration and
is the mean
significantly better than
than the static
to a page
a local memory
the policy is
referenced in a
the experimental results
the effects of
the input parameters
mean time between
the memory management
the experimental data
to be fairly
in a frame

corpus/krapavin2000-test/629154.txt
packets
routing
packet
mesh
transposition
travel
route
destined
permutation
destination
vertically
destinations
odd
processors
processor
row
queues
sorting
east
2n
column
inversion
movement
south
array
west
exchange
optimally
reach
routes
theta
north
distance
horizontally
vertical
rotation
contents
buffer
move
distances
4n
completes
forced
moves
neighbors
neighboring
participates
arrays
bad
moving
uninterrupted
rotations
neighbor
participate
heuristic
delayed
horizontal
queue
instant
opposite
buffers
gap
routed
computers
position
connected
phases
chain
initially
normalized
synchonization
nxn
krizanc
drand48
builts
jonathon
antonios
rajasekaran
largeand
tollis
queuesize
brebner
tidswell
procced
symvonis
tsantilas
makedon
located
motion
adjacent
lemma
columns
switched
100
reaches
kunde
ofparallel
10000
completion
cross
meshes
transmit
submeshes
itis
interconnection
communicate
sup
probabilistic
simulations
619
valiant
trough
lemmata
positions
wants
enter
leighton
happen
boundary
direction
forces
transpositions
downwards
gamma
directions
experiment
trapped
thetan
normalization
phase
remind
origins
multistage
625
experimental
generator
constitute
upwards
interrupted
away
198
got
want
torus
disjoint
art
3n
mimd
area
communicates
pathological
rows
instances
bidirectional
talk
collisions
stays
deterministic
leftmost
comparisons
traced
originated
transfer
novel
hits
random
admit
occupy
generators
off
originally
queueing
tighter
created
buffering
normalize
decreased
2k
grids
spite
go
chip
exchanged
hundreds
permutations
starts
observe
corner
said
portion
solved
diameter
discarded
summation
moderate
greedy
messages
secondly
nontrivial
ffl
algorithm route
to travel
the packets
all packets
routing steps
even transposition
odd even
routing problem
packets that
the routing
packet p
packets have
packet routing
the odd
n mesh
mesh connected
the mesh
destined for
size queues
permutation routing
column destination
transposition method
total distance
routing problems
packets in
packet that
are destined
random routing
n theta
reach their
n steps
theta n
a packet
their destinations
the packet
at position
its destination
distance that
the row
permutation problem
permutation packet
compared packets
d s
two packets
its column
n packets
2n steps
buffer area
of processors
2 steps
o n
at time
one packet
routing on
theta 100
in 2n
performs optimally
row k
packet has
is destined
constant size
position i
each processor
the south
any permutation
to move
the exchange
be empty
route needs
be processor
type h
same column
moves vertically
100 theta
these packets
destination then
processor at
will reach
to route
same direction
maximum distance
mesh is
movement of
routing algorithm
opposite directions
time instances
type v
sorting on
an inversion
of packet
for mesh
that want
initially at
2n gamma
that d
packets to
have that
i t
queues the
packets are
time disjoint
processors algorithm
correct column
bad situation
their column
after 2n
connected array
moving vertically
routing time
vertical movement
move vertically
n routing
packets want
delayed packets
disjoint phases
to opposite
of packets
mesh of
routing of
neighbor to
the distances
that initially
routing in
the north
that algorithm
row of
steps required
then after
2 routing
travel to
destinations of
neighboring processors
100 mesh
optimal routing
needs exactly
go further
completes the
distance a
next step
mesh the
a permutation
of routing
area for
an n
the destinations
packets will
no packet
other packet
travel is
the east
for position
a transposition
an exchange
connected parallel
problem on
forced to
steps the
have to
packet will
2 packets
empty after
steps using
vertically and
complete the
most n
a 100
distances the
on mesh
it moves
the west
for random
packet of
first row
of type
a chain
want to
exactly 2
after o
has to
second phase
linear array
packets of
non optimal
destination the
to complete
steps that
route the
routing is
time t
d t
2n o
arrays extended
routes all
instances t
east neighbors
8 elements
good experimental
experimental behavior
packets reach
moving horizontally
have to travel
odd even transposition
the odd even
packets have to
theta n mesh
of the mesh
has to travel
that d s
n theta n
even transposition method
packet routing problem
packets that are
that all packets
of the packets
in the odd
total distance that
permutation routing problem
all packets that
constant size queues
are destined for
the total distance
have that d
all packets have
the packet that
packet has to
that algorithm route
complete the routing
of packet p
its column destination
random routing problems
mesh of processors
permutation packet routing
s i t
routing problem on
n mesh is
reach their destinations
the packets that
destined for the
want to move
the maximum distance
an n theta
is destined for
at position i
n mesh of
100 theta 100
the packets have
distance that all
of routing steps
neighbor to be
distance a packet
that are destined
for random routing
size queues the
position i j
on a chain
initially at position
algorithm route needs
completes the routing
after the exchange
a 100 theta
will be empty
row of the
the same direction
maximum distance a
the packets in
for mesh connected
packet routing on
a packet has
the same column
to be processor
will have that
the routing of
n 2 steps
on a 100
we will have
all the packets
that want to
of type h
the routing in
time disjoint phases
buffer area for
destined for position
want to travel
mesh connected array
by algorithm route
2n gamma 2
packets that will
theta 100 mesh
be empty after
its destination then
destination then after
of type v
routing on a
packets want to
after o n
packet of type
the distances the
processors algorithm route
exactly 2 packets
n routing steps
that the packets
j is destined
of algorithm route
to opposite directions
mesh is called
after 2n steps
cross the row
packets that want
s k t
to go further
of processors algorithm
forced to occur
chain of processors
the next step
of the routing
o n 2
at time t
problem on a
any permutation routing
packet p is
given an n
to travel is
order to complete
the packets to
if the packet
has to go
to its left
to travel to
the destinations of
the routing is
to complete the
steps in order
mesh connected parallel
at most n
a chain of
number of routing
order to reach
on mesh connected
a linear array
the first row
on a mesh
t and d
the second phase
participates in the
observe that all
packets in the
during the next
p i 1
and p i
i and p
the movement of
i j is
this implies that
of 8 elements
constant and very
that column at
routing problems that
processor 1 the
than p so
its correct column
routing problem proof
packet that initially
r routing steps
two time disjoint
arrays extended abstract
efficient heuristic for
type h also
routing steps and
array of 8
packets to its
our routing algorithm
steps that is
than n packets
to travel at
are two pairs
steps the row
transposition method is
algorithm that completes
n sup 2
the packet initially
reach their column
routes the packets
forced to move
the row assume
processor at position
vertical movement of
route the packets
all packets will
problems where non
assume a row
two packets that
used for sorting
routing problem in
packets reach their
destinations of the
mesh with at
route needs exactly
2n steps the
moving vertically and
forces p to

corpus/krapavin2000-test/629166.txt
dfs
speedup
superlinear
backtracking
processors
sequential
leaf
searched
heuristic
faults
visited
visits
puzzle
backtrack
successors
search
queens
podem
depth
processor
expanded
pruned
gammaqueens
backtracks
subtree
atpg
superlinearity
fl
bounding
htd
instances
visit
ordering
solutions
heuristics
ob
wn
density
efficiency
anomalies
formulations
hacker
regions
tree
pruning
hm
trees
wild
visiting
formulation
root
nodes
satisfiability
speedups
node
branching
densities
circuits
fraction
probabilistic
succeeds
ae
region
am
advice
karypis
intelligence
serial
multiprocessors
fault
hackers
25600
banded
homogenization
simd
cards
curves
artificial
2s
kumar
average
monien
6400
sublinear
prune
iscas
sliced
randomized
statically
validate
analyzed
overhead
gammafl
happens
circuit
trials
vipin
frontier
balancing
branch
searches
cutoff
bernoulli
gamma1
analytical
solve
1600
searching
slicing
shallow
dominates
reader
subspace
annals
experimental
uniform
uniformly
multiprocessor
analyses
ordered
expansions
uniformity
validated
balanced
expands
dist
nagy
thedistribution
browne
krauss
symult
734
chaplin
formany
areconsidered
unexpanded
1means
lintao
shapira
arvindam
deceleration
prunesearch
1057
forsimple
korf
aesequential
dehne
soln
thetheoretical
dibmyampersandmdash
719
comparethe
c499
upperlimit
fpt
stege
youssef
vineet
okushi
nonattacking
challou
felner
alori
rau
saletore
2010
antreich
c1355
isnonuniform
fumiaki
kbfs
taillon
64003282251751257525number
cheetham
ganz
harmonic
hardness
italic
occurrence
identifies
proportional
busy
files
located
leaves
85
cuts
fundamentals
unstructured
promising
substantially
dynamically
faulty
andrew
gamma
violates
dr
kurt
sunil
bordeaux
parallel dfs
sequential dfs
superlinear speedup
simple backtracking
parallel search
searched by
dfs algorithms
of dfs
leaf nodes
solve instances
space tree
search space
the search
bounding heuristic
the average
average speedup
first search
backtrack search
nodes expanded
ordering heuristic
a solution
state space
of solutions
depth first
dfs is
15 puzzle
nodes visited
sequential search
and parallel
visited by
fl fraction
dfs visits
sequential and
speedup on
in parallel
of processors
by sequential
the parallel
of leaf
theorem a
ob trees
regions searched
speedup obtained
the sequential
parallel formulations
the root
of nodes
leaf node
different processors
or parallel
parallel formulation
heuristic backtracking
1 leaf
dfs and
parallel depth
n gammaqueens
dfs will
dfs for
speedup in
linear speedup
that parallel
than sequential
of depth
of parallel
probabilistic algorithms
space search
the processors
21 8
to solve
solution in
by parallel
the ordering
search overhead
solution density
randomized parallel
atpg problem
backtracking which
queens problem
the atpg
solution densities
parallel branch
solution nodes
heuristic information
htd faults
ordered dfs
sequential or
one solution
s d
the tree
fraction of
by different
anomalies in
left subtree
expanded by
successors of
for parallel
solutions are
dfs in
solutions then
a bounding
dfs the
solution is
search tree
speedup is
our parallel
curves for
the regions
communication overhead
formulations of
the 15
the serial
of faults
density of
parallel algorithm
processor in
search and
nodes than
branching factor
generate tests
of speedup
the speedup
search on
experimental results
search algorithms
a gamma1
expanded in
backtracking and
node being
a processors
the successors
one processor
artificial intelligence
average number
d gamma
speedup anomalies
n regions
solutions among
nodes searched
dfs was
expanded node
probabilistic search
processors finds
heuristic makes
total instances
gammaqueens problem
superlinear speedups
dfs algorithm
parallel podem
puzzle problem
processor parallel
more solutions
dfs this
recently generated
2s d
the hacker
hacker s
search below
root node
visited in
search in
the bounding
pattern generation
serial algorithm
hard to
the density
in sequential
are visited
w 1
random order
speedup for
test pattern
case happens
which solutions
makes correct
wild cards
search problems
for ordering
is superlinear
simd parallel
an expanded
which successors
independently until
heuristic reduces
whole search
gamma fl
of backtracks
on hard
those faults
it visits
and bound
tree is
n processors
in 21
obtained is
than 1
search is
non uniform
is available
on simd
bound algorithms
in parallel dfs
to solve instances
state space tree
depth first search
the average speedup
nodes visited by
sequential and parallel
the search space
distribution of solutions
and parallel dfs
of parallel dfs
fl fraction of
searched by different
density of solutions
of nodes expanded
of leaf nodes
by different processors
number of leaf
number of nodes
a solution is
number of processors
the ordering heuristic
regions searched by
the state space
of the search
on the average
at the root
parallel depth first
the bounding heuristic
by parallel dfs
theorem a 1
parallel formulations of
sequential or parallel
and parallel search
the sequential dfs
parallel dfs algorithms
leaf nodes visited
being a solution
nodes expanded by
than sequential dfs
in 21 8
the regions searched
fraction of the
hard to solve
superlinear speedup on
state space search
efficiency of parallel
speedup on the
of the processors
the left subtree
solution is found
for parallel dfs
parallel branch and
the 15 puzzle
heuristic is available
superlinear speedup in
a bounding heuristic
average speedup obtained
gamma 1 leaf
the atpg problem
parallel dfs is
parallel dfs visits
speedup obtained is
backtrack search algorithms
one solution in
node being a
of dfs algorithms
dfs algorithms we
1 leaf nodes
formulation of dfs
2 a processors
sequential search and
anomalies in parallel
of nodes visited
of the time
d gamma 1
parallel formulation of
easy to solve
generate tests for
average number of
curves for the
of depth first
to generate tests
finding a solution
test pattern generation
the serial algorithm
case in which
search space is
2s d gamma
the parallel dfs
of an expanded
n gammaqueens problem
speedup for parallel
in which successors
two processor parallel
different processors are
2 a gamma1
speedup anomalies in
the total instances
parallel dfs the
space tree is
most recently generated
speedup in parallel
that parallel dfs
whole search space
nodes searched by
leaf nodes on
heuristic reduces the
algorithms we analyze
processors finds a
our parallel formulation
sequential dfs and
or more solutions
average case behavior
the processors finds
the n gammaqueens
the parallel search
in which solutions
on hard to
solutions are distributed
the hacker s
an expanded node
of nodes searched
visited by sequential
leaf node being
15 puzzle problem
parallel dfs will
heuristic information is
hacker s problem
of solutions among
backtracking which does
by sequential dfs
the density of
branch and bound
the average number
in the whole
in the parallel
find a solution
the average case
the case in
near the root
the whole search
successors of an
1 gamma fl
speedup curves for
on simd parallel
of solutions is
which solutions are
simd parallel computers
finds a solution
communication overhead is
the root node
the parallel algorithm
theorem 5 3
in a random
one processor in
and bound algorithms
a balanced binary
the successors of
are visited in
distributed uniformly in
of processors n
a non leaf
balanced binary tree
solution in the
nodes on the
automatic test pattern
number of leaves
when the distribution
to order the
a probabilistic algorithm
trees of depth
the leaf nodes
the number of
non leaf node
leaf nodes in
the reader should
of depth d
uniform distribution of
in this formulation
until one of
of the state
of the ordering
mean number of
for the n
on one processor
search can be
analysis in section
root node is
of a search
of the total
processor in the
a solution in
of them individually
or parallel dfs
solutions then dfs
is superlinear the
in parallel state
solutions are uniformly
ordered backtrack search

corpus/krapavin2000-test/629185.txt
race
release
consistency
unset
vax
synchronization
acquire
processor
po
paired
weak
hardware
races
programmers
stall
buffer
releasing
sequentially
incomplete
pairable
acq
conflicting
completes
unifies
processors
coherence
syncread
ordering
sequential
cache
read
unpaired
reserve
shared
fetch
instructions
ownership
multiprocessors
programmer
syncwrite
free
proposal
rel
acquires
memory
obey
uniprocessor
issued
datawrite
acquiring
writes
serialization
preceding
barrier
inc
programs
empties
synchronized
sistency
buffers
implementations
flag
consistent
restrictive
designers
obeys
designer
multiprocessor
releases
caches
execute
distinguished
optimizations
reads
kontothanassis
local_flag
so1
dataread
directory
stalls
correctly
sees
delay
transferred
program
distinguishing
leonidas
uniprocessors
dwarkadas
happens
critical
distinguishes
executions
ensures
completion
conflict
remembers
ops
properly
370
adve
write
execution
location
semaphores
protocol
requirement
deadlock
atomically
semaphore
keleher
gharachorloo
drf1
galen
nsyncs
prefer
deleted
released
request
labeled
instruction
sigops
cox
sigplan
viewpoint
dependencies
overrelaxation
writable
stets
rajamony
bershad
sandhya
lockup
manson
causally
sarita
retaining
returned
transfers
formalizes
opera
3b
notices
pram
interlock
sigarch
zwaenepoel
larus
livelock
2a
violations
message
asynchronous
fong
wo
hunt
causal
retains
delays
1994
jose
executes
stalling
pugh
dubois
california
robert
discusses
returns
logic
pong
parthasarathy
zucker
complementarity
remote
requests
detecting
post
permission
2b
invalidated
p0
rc
scott
intuition
coherent
concurrent
tagged
monterey
drafts
pro
disadvantages
scalable
restrictions
retain
delayed
count
rollback
interconnection
writing
race free
data race
free 1
release consistency
free 0
weak ordering
sequential consistency
synchronization operations
sequentially consistent
memory operations
ordering release
the vax
program order
memory model
po po
test set
shared memory
data operations
special buffer
data requirement
four models
vax model
the releasing
releasing processor
data races
fetch inc
happens before
cache coherence
before 1
an acquire
operations of
a processor
the release
properly labeled
acquire condition
reserve buffer
a read
for hardware
is data
a release
this processor
data operation
synchronization operation
hardware designer
1 unifies
requirement conditions
correctly synchronized
the acquire
hardware designers
acquiring processor
implementation proposal
memory models
paired with
ordering and
the write
a memory
for programmers
processor to
an execution
a write
operations are
all implementations
an operation
vax and
obey data
incomplete buffer
consistency the
reason with
memory consistency
consistency or
p 0
1 memory
execution is
s test
than weak
implementations of
and release
and data
the read
programmers prefer
unpaired synchronization
unset s
the unset
labeled programs
incomplete operations
release acquire
critical section
of weak
conflicting operations
memory multiprocessors
a data
operations and
operations from
distributed shared
or data
of release
unifies the
the synchronization
p 1
free program
are incomplete
the data
write on
same location
programs that
release and
consistency models
free programs
coherence protocol
consistent to
the hardware
the execution
syncread flag
buffer empties
consistent hardware
read returns
consistent execution
empty special
on sequentially
pairable relation
its incomplete
inc count
write due
post acquire
formal interface
appear sequentially
the happens
and acquire
special operations
memory location
less restrictive
the four
the programmer
read on
0 s
of data
consistency and
a hardware
p rel
pre release
operations preceding
processor sees
a synchronization
to delay
an implementation
consistency to
to reason
all processors
a program
a programmer
address of
ownership of
consistency for
in program
s data
on x
most programmers
paired release
with sequentially
ensures sequential
read due
the pairable
designers since
coherence logic
data write
serialization operations
serialization operation
release condition
the acquiring
consistent special
appears sequentially
con sistency
an unset
released line
by program
restrictive than
with sequential
are distinguished
the program
the processor
s write
1 relation
model data
completion of
consistency with
execution of
the operations
buffer message
release operation
consistency 11
issued and
acquire and
before y
operation until
consistency by
incomplete data
value written
transferred to
other models
the completion
data race free
race free 1
race free 0
weak ordering release
ordering release consistency
and data race
of data race
a data race
the data race
po po po
the four models
the data requirement
the vax model
weak ordering and
happens before 1
the releasing processor
p 0 s
is data race
for data race
test set s
free 1 is
consistency the vax
1 memory model
or data race
release consistency the
free 1 memory
all implementations of
data requirement conditions
and release consistency
to reason with
model and data
of weak ordering
consistency or data
is less restrictive
release consistency or
in program order
obey data race
s test set
vax model and
for hardware designers
free 1 unifies
p 1 s
shared memory multiprocessors
a memory location
prefer to reason
race free program
ordering and release
a memory model
unifies the four
synchronization operations and
and the vax
sequentially consistent to
free 0 for
appear to execute
properly labeled programs
vax and data
than weak ordering
to data race
programmers prefer to
race free programs
a hardware designer
by all processors
implementations of data
paired with the
cache coherence protocol
ordering and the
the same location
distributed shared memory
read on x
release and acquire
implementation proposal for
sequential consistency to
model data race
appear sequentially consistent
write due to
0 s write
sequentially consistent hardware
of this processor
release acquire condition
sequentially consistent execution
by program order
before 1 relation
release consistency and
of sequential consistency
operations are distinguished
reason with sequential
1 unifies the
the vax and
of release consistency
for a hardware
release consistency with
fetch inc count
empty special buffer
on sequentially consistent
special buffer empties
the happens before
free 1 if
operations of the
returns the value
an execution is
a test set
1 is less
definition of data
in an execution
memory consistency models
the completion of
test set and
explicit and formal
group of programs
a read due
a data operation
less restrictive than
most programmers prefer
program order and
implementations of weak
read returns the
consistency and data
read due to
free 1 provides
and a read
appears sequentially consistent
the release acquire
ensures sequential consistency
with sequentially consistent
the implementation proposal
allowed by weak
hardware designers since
post acquire condition
0 for hardware
the acquiring processor
the synchronization operations
free 1 that
the pairable relation
consistent special operations
memory operations of
for hardware to
0 s data
implementation of data
memory operations in
consistency with sequentially
pre release condition
cache coherence logic
that most programmers
the memory operations
execution is possible
with sequential consistency
free 1 because
race free and
1 s test
sequential consistency for
to weak ordering
process as usual
synchronization operations of
allows an implementation
the read returns
free 0 1
unpaired synchronization operations
special buffer message
the execution is
programs that are
value written by
of a data
the critical section
a synchronization operation
conflicting data operations
seen by all
write on x
not allowed by
the pre release
models for shared
consistency models for
will appear to
of memory consistency
for shared memory
for an execution
the value written
1 provides a
to the acquiring
for correctly synchronized
not data race
the reading processor
1 relation for
paired release and
until datawrite completes
conflicting operations from
data operations of
free program on
programmers can expect
before 1 orders
memory operations and
14 17 1994
release consistency 11
retain ownership of
can expect sequential
detecting data races
free 1 system
are data race
the control requirement
s data write
an implementation proposal

corpus/krapavin2000-test/629269.txt
predicates
lcmvector
predicate
wcp
conjunctive
lcmvectors
checker
lp
incomparable
debugger
detection
newchanged
utddb
roc
weak
unstable
message
lin
snapshots
debugging
processes
garg
monitor
stutter
detect
trace
programmer
queue
maxu
sent
chandy
inc
vijay
snapshot
firstflag
lamport
coordinator
fifo
disjunctive
messages
stable
austin
queues
detecting
bool
kshemkalyani
ks
suffix
causal
events
debug
ajay
head
breakpoints
adversary
detected
logic
changed
exclusion
happened
timestamps
timestamp
hoagland
hurfin
spezialetti
kashyap
skt
sujatha
clocks
boolean
sequences
detects
marzullo
waldecker
punit
comparisons
actions
program
vectors
decentralized
pred
var
p1
mutual
raynal
send
checking
traces
kulkarni
9s
formulas
global
programs
deduce
kearns
heads
received
became
bryan
sandeep
prog
s2
receive
jay
msg
chandra
conjuncts
speeds
orders
p2
critical
consistent
detectable
michel
greg
cooper
strong
miller
choi
halting
csp
fig
conjunction
id
false
monitors
offline
channels
checks
mg
chin
petri
texas
formula
decomposed
concurrent
analyzer
f1
iff
n00039
resettable
1323
decentralizing
lpm
chiou
korfhage
ddb
spuriously
truthness
karun
earlieralgorithms
indebugging
haban
plouzeau
apredicate
navy
677
bouge
thepredicate
willard
pazel
replays
mattern
rcvd
myre
biyani
weigel
2bool
deletehead
decentralization
predicates2
1077
1438
discussdetection
lcmvec
trw
nonchecker
thomborson
loon
dbg
gdo
predicateslocal
pine
tomlinson
9110605
itbecomes
incompara
bythe
excessiveoverhead
decentralize
conjunctivepredicates
assistantship
schlumberger
1333
jchanged
thatare
3lp
explosion
sends
clock
weak conjunctive
global sequence
local predicates
checker process
distributed program
conjunctive predicates
global state
global predicates
detection of
the checker
predicates in
process p
distributed programs
the lcmvector
local predicate
run r
p roc
in distributed
global predicate
a distributed
conjunctive predicate
of global
roc t
unstable predicates
predicate is
a global
the wcp
global sequences
our algorithms
distributed run
distributed debugger
lp i
distributed systems
is true
k garg
predicate detection
of weak
global states
the predicate
non checker
the trace
the global
for detection
a run
vijay k
our logic
of local
of predicates
the snapshot
p i
r i
message path
its lcmvector
checker processes
1 lp
inc t
of unstable
before s
the process
to detect
true for
head of
a weak
stable predicates
in debugging
application process
lp 1
state s
different processes
boolean expression
true in
no message
of comparisons
processes in
the programmer
sent after
chandy and
lin lin
the head
the state
at s
predicates are
a message
q i
p j
and lamport
distributed computations
the local
lcmvector at
sent message
stutter of
became true
wcp is
local pred
predicates detection
a lin
recently sent
be decentralized
a stutter
pure conjunction
of lcmvectors
repeated snapshots
distinct s
8 distinct
program message
time vectors
trace r
lin j
stable predicate
inc s
local actions
in changed
detect even
program messages
two lcmvectors
unstable predicate
snapshots in
f semantics
relational global
disjunctive predicates
are true
max t
true we
s 1
mutual exclusion
and lp
3 lp
true our
atomic sequences
message id
of incomparable
detecting atomic
predicates ieee
d kshemkalyani
ajay d
while loop
6 s
any predicate
happened before
total orders
the monitor
s j
e 3
of checking
are incomparable
the while
conjunction of
the detection
s 0
s 2
t p
states in
of events
such predicates
queue q
partial order
predicate in
deduce that
consistent with
message complexity
after s
predicate may
state g
some global
become true
efficient distributed
will detect
the run
the adversary
be detected
distributed snapshots
for weak
any global
be true
each process
above algorithm
q j
check if
local states
and p2
the program
been sent
predicates that
state t
predicate to
a boolean
is sufficient
following holds
states of
predicates is
program may
message or
linear r
changed newchanged
suffix g
possible global
recognizing event
lp j
lcmvectors to
systems detecting
a distributed program
the process p
the checker process
a global sequence
weak conjunctive predicates
of local predicates
of global predicates
predicates in distributed
p roc t
weak conjunctive predicate
process p i
a weak conjunctive
of weak conjunctive
a distributed run
detection of global
in distributed systems
for detection of
the global state
unstable predicates in
in distributed programs
the global sequence
the local predicate
vijay k garg
a global state
predicate is true
detection of weak
global predicates in
at the head
the head of
in a distributed
true for the
t p roc
is no message
expression of local
is at s
the global predicate
boolean expression of
message path from
of unstable predicates
a run r
of global sequences
global state is
number of comparisons
in different processes
the run r
chandy and lamport
conjunction of local
detection of unstable
of a distributed
a boolean expression
if the global
in distributed computations
process p j
of a global
processes in the
distinct s t
predicates detection of
lcmvector at the
the application process
any global predicate
a stutter of
recently sent message
a pure conjunction
lp 1 lp
message or the
pure conjunction of
a local predicate
f semantics of
can be decentralized
local predicates are
snapshots in distributed
a global predicate
sent message or
8 distinct s
local predicate is
3 lp 1
if the lcmvector
most recently sent
for distributed programs
sent after s
relational global predicates
the lcmvector at
e 3 lp
for weak conjunctive
non checker processes
stutter of r
i and s
of a message
is true for
the while loop
detecting atomic sequences
atomic sequences of
algorithms for detection
sequences of predicates
global state g
predicates ieee transactions
predicates are true
ajay d kshemkalyani
or the beginning
consider a distributed
head of q
it is true
class of predicates
of distributed programs
algorithm to detect
that t p
predicates in a
before s 2
the state of
since the most
that the predicate
have been sent
of global states
of the while
for the process
distributed systems with
the detection algorithm
our algorithms in
could not have
of the trace
is true in
the above algorithm
in the trace
by the process
and s j
the state s
set of global
s i and
in the system
as a boolean
of predicates in
the following holds
s 1 and
the predicate is
of our algorithms
of q i
the most recently
run of a
parallel and distributed
of events in
a finite sequence
to check if
trace r i
all local predicates
predicate is one
is before s
logic is as
programs consistent detection
stable predicate is
propositional linear temporal
each program message
been sent after
of one queue
snapshot satisfies the
their implementation in
inc t and
became true we
relationship to petri
at s 2
systems detecting atomic
program may be
detect even unstable
global sequence such
deduce that 8
orders for parallel
debugging concurrent programs
lp true for
state s we
detect strong conjunctive
wcp is satisfied
many total orders
the suffix g
g f semantics
predicates proposed by
received in or
global sequence of
punit chandra ajay
and inc u
in q j
and 3 g
a distributed debugger
checker process which
distributed systems detecting
from inc t
program message it
miller and choi
global events and
algorithms detect even
or a stutter
lcmvectors u and
roc t u
conjunctive predicate we
any message received
if the wcp
semantics of e
message sent after
concurrent regular expressions
set of incomparable
detecting relational global
implementation in csp

corpus/krapavin2000-test/629280.txt
arjuna
persistent
rpc
object
atomic
binding
server
helios
naming
module
replicas
replication
action
client
uid
activated
services
abort
gvd
objectstate
cid
commit
service
volatile
transparency
actions
passive
remote
ansaware
serialisability
statemanager
atomicaction
uids
replica
store
manager
lock
migration
concurrency
servers
stub
objects
lockrecord
thisone
invocation
functioning
crash
invocations
modules
responsible
replicated
storage
recordlist
transparencies
persistence
stable
invoking
initiate
ordinator
port
bindings
rajdoot
restore_state
lockmanager
recoveryrecord
read_state
recovery
failures
structuring
invoked
clients
supporting
aborted
portable
name
crashes
portability
hostname
rpcs
facilities
activation
galileo
op1
save_state
commit_shadow
write_state
abstractrecord
ansa
delete_shadow
write_shadow
managing
activating
copy
functionality
recoverable
tolerant
locks
permitting
destructor
node
fault
locking
active
algol
connection
unix
oriented
operating
binder
atomicity
accessing
mutually
abortion
aborting
repaired
implementing
capable
identifier
prepare
organised
transaction
facility
setlock
get_request
wheater
transputers
getmsg
putmsg
guardians
cids
rpccallrecord
concealing
hfs
committed
consistency
interfaces
management
modular
names
subsystem
committing
registered
activate
nested
copies
host
permanence
recoverability
trader
send_reply
invoker
ensuing
provision
replicating
mappings
failure
policy
file
hierarchy
enhancements
creation
registering
checkpoints
revisions
cohorts
stubs
mechanisms
aborts
stores
heterogeneous
co
instances
messages
demon
transputer
gr
reply
delete
location
normally
named
primary
sockets
crashed
isa
executing
terminating
locate
maintained
string
multicast
invokes
intentions
destroyed
recorded
program
examination
interface
stuart
interconnecting
atomic action
object store
the object
persistent object
object support
atomic actions
an object
action module
binding service
rpc module
persistent objects
support module
the binding
the atomic
the server
active replication
the arjuna
naming and
the rpc
of arjuna
the client
the persistent
and binding
object servers
the naming
object server
application program
naming service
the helios
a persistent
the gvd
passive replication
binding services
in arjuna
abort operation
connection manager
stable storage
transparency mechanisms
concurrency control
responsible for
the abort
programming system
object is
object replicas
store component
object oriented
module provides
object storage
the services
distributed system
of atomic
is responsible
state changes
provided by
an application
objects in
object can
its state
object manager
the ansaware
manager process
the cid
location information
distributed programming
remote procedure
object will
replicas of
operation of
co ordinator
commit processing
of persistent
remote objects
changes to
object the
the action
class hierarchy
of objects
an operation
mutually consistent
object structure
servers and
a remote
the recordlist
cid of
crash of
persistent state
uid of
available replicas
arjuna system
invoking operations
server processes
store node
group view
volatile storage
volatile store
the volatile
object b
replicated objects
name server
write lock
module the
the application
that object
the functionality
commit time
application programs
a passive
state of
be activated
by invoking
and server
application level
made available
server process
replica consistency
non replicated
passive object
object stores
rpc and
an atomic
action a
a distributed
fault tolerant
a node
the invocation
object it
replication in
instances of
at commit
the uid
server node
system structuring
the crash
the class
client and
the commit
server which
support for
a connection
the operations
on stable
procedure call
is invoked
be made
invocation of
services provided
name of
x window
of objectstate
stub for
arjuna distributed
window system
copy passive
access transparency
service operation
of helios
class specific
store representation
activated objects
server managing
activated object
objectstate in
system implementing
stable object
of initiate
node crashes
class objectstate
replication policy
helios operating
support modules
nested atomic
naming module
system services
class statemanager
the serialisability
prepare operation
concurrent invocations
disk representation
manager component
the activated
binding modules
serialisability property
replication transparency
arjuna 11
local rpc
objectstate instance
capable of
user defined
invoked to
operating system
for accessing
and replication
maintained by
for supporting
the state
migration and
as objects
the host
objects are
at n
the atomic action
persistent object support
atomic action module
the object store
the binding service
of the object
object support module
naming and binding
of an object
a persistent object
the rpc module
an application program
the persistent object
and binding services
the naming service
state changes to
an atomic action
the abort operation
an object store
object store component
object servers and
is responsible for
of the atomic
provided by the
of atomic actions
distributed programming system
of persistent objects
client and server
connection manager process
of the server
the object manager
be made available
operation of the
object can be
that the object
the arjuna system
object store node
persistent state of
the cid of
the crash of
object is responsible
of atomic action
an object server
the object server
of the arjuna
atomic action a
of a persistent
objects in arjuna
a distributed system
with the object
for the object
remote procedure call
to run on
the application program
a remote procedure
for distributed computing
a passive object
then the object
by the binding
on stable storage
support for distributed
the connection manager
an object oriented
maintained by the
migration and replication
the location information
at commit time
the naming and
can be made
services provided by
of the class
to the object
to ensure that
the invocation of
the name of
about object replicas
to system structuring
version of arjuna
x window system
the x window
passive replication in
i an object
the uid of
invoking operations on
and persistent object
helios operating system
uid of the
information about object
the persistent state
and binding modules
one object store
copy passive replication
the services of
object manager component
disk representation of
single copy passive
from the rpc
instance of objectstate
local rpc module
persistent objects in
arjuna 11 23
cid of the
the serialisability property
abort operation of
the prepare operation
services can also
state and methods
the arjuna distributed
object support modules
the helios operating
abort operation is
11 23 29
rpc and persistent
necessary to ensure
as a part
of the host
and the object
state of the
in a distributed
the management of
of the services
operations on objects
in effect this
the functionality required
of the persistent
implementing fault tolerant
its state to
the services provided
concerned mainly with
the co ordinator
failures such as
changes to the
an object is
name of the
by the underlying
to the client
if the object
the object and
the server for
consider an application
module provides a
server for the
the object can
interfaces to the
objects in a
the object that
where the server
a class hierarchy
an object it
an operation of
object oriented systems
for that object
object has been
of the binding
instances of the
state of an
itself can be
each object is
be capable of
the client and
an object are
objects in this
as an object
an instance of
to the objects
of a node
an object can
a single object
in an object
by the naming
that object it
list of available
managed through appropriate
differ from its
of available replicas
once an application
action module and
and atomic action
concurrency control policy
achieved by invoking
server managing that
using the helios
new states of
consistency protocols to
action module the
be de activated
classes derived from
support modules are
structuring fault tolerant
operation is responsible
replicas of a
the group view
guardians and actions
robust distributed programs
store representation e
heterogeneous computer systems
servers are created
oriented transaction processing
initiated on a
operations initiate terminate

corpus/krapavin2000-test/629283.txt
response
throughput
processors
tasks
processor
elemental
series
bdt
pipeline
pipelined
ipsc
assignment
subhlok
asgn
task
assignments
convex
allocating
compositions
jaspal
scheduling
np
multitasked
parallelism
motion
fl
hallaron
partitioning
grids
proc
pipelines
nonconvex
allocated
composition
hypercubes
hypercube
multiprocessor
diagonal
psi
constraint
dinda
nonconvexity
vondran
precedence
gross
intel
dilation
parallelizable
webb
meet
maximizes
vision
embedding
priority
jon
supercomputing
architectures
monotone
007
choudhary
transputer
allocation
image
1994
rectangular
stereo
alok
arises
allocations
diagonals
computations
sec
gary
multistage
systolic
pipe
notices
chains
contention
mapping
nonuniform
nondecreasing
maximizing
statically
constituent
dag
convexity
sigplan
signature
characterizations
comprised
composite
benchmark
pipelining
convolution
schedule
dummy
marked
subject
embeddings
stream
monotonicity
pasm
threatens
aknown
krishnamurti
computationsextending
varshney
weiner
goubran
jinquan
jaspar
areapplied
endeavors
childrens
bepipelined
timerequirement
ofprocessors
bokhari
mimimal
followingprocessor
rnp
kohr
andrecomposition
intertask
lvoie
whichis
pureza
downton
krishnaiyer
assignmentoptimizing
rafik
luddy
ofassignments
vitoria
estimation
assigned
heap
maximized
vol
understanding
minimal
minimize
onto
achieving
subchain
fleury
1164
chitectures
prasanna
lion
typeface
forma
chinneck
koranne
retiming
makespan
pramod
procs
keng
david
completion
thomas
optimally
meshes
utilizing
tradeoff
scene
nine
loop
assigning
multiprocessors
communication
straint
digest
nonincreasing
checksum
extrapolated
amdahl
643
minimizes
initialize
job
experimentally
sup
treat
communicating
supply
feasible
rakesh
throughputs
krishnamurthy
1185
srinivasa
dsp
ncube
donald
670
costs
maximal
response time
time function
series parallel
o np
time functions
throughput constraint
parallel task
the response
the throughput
of processors
np 2
processors to
optimal response
response times
throughput problem
task structures
processor assignment
time problem
parallel tasks
task structure
minimal response
log p
a response
t i
individual tasks
of series
tasks t
the series
data sets
ipsc 2
time constraint
embedding rectangular
proc time
assignment diagonal
elemental tasks
asgn sec
series composition
throughput requirement
f p
tasks are
for mapping
tasks we
data set
data parallel
optimal assignment
task system
parallel precedence
rectangular grids
motion estimation
p time
the tasks
david r
jaspal subhlok
f 1
a throughput
gamma psi
and parallel
tasks to
time proc
motion understanding
multitasked parallel
sec asgn
execution signature
constraint fl
convex over
throughput constraints
pipeline computations
feasible assignments
maximizes throughput
given response
dilation two
pipeline computation
throughput subject
series task
nonconvex response
thomas gross
assigning processors
understanding benchmark
subject to
processor system
each t
parallel architectures
to t
p processors
a series
dynamic programming
parallel composition
parallel components
of stereo
for series
o hallaron
task response
2 log
in o
is convex
f i
all assignments
all feasible
optimal processor
stereo image
individual task
are convex
for parallel
the optimal
algorithms for
each task
parallel algorithms
intel ipsc
series and
task systems
the task
processors and
by allocating
assignments that
assigned to
the minimum
processor allocation
problem arises
of tasks
the processor
processor to
s response
pipeline the
the parallel
function for
allocated to
t 1
a task
mapping systolic
priority heap
utilizing multidimensional
jon webb
states jaspal
multidimensional loop
pipelined data
processor count
composite task
task compositions
assignment diagonals
hallaron thomas
count q
function completely
a transputer
dinda jon
containing branches
binary decomposition
gary vondran
convex then
minimal mesh
hypercubes characterizations
minimize schedule
constraint using
pipe pipelined
vondran optimal
parallel pipeline
series tasks
assign processors
subhlok gary
integrated vision
binary hypercubes
monotone nondecreasing
a bdt
maximal throughput
x processors
np sup
of elemental
processing engine
throughput if
q processors
estimation system
signature 10
statically assigned
scheduling multiprocessor
transputer environment
possible throughput
multiprocessor tasks
given throughput
good throughput
minimizing response
potentially parallelizable
array assignment
minimum response
subhlok david
multistage linear
every response
mapping task
bdt node
pipelined image
r fl
gross peter
for pipe
webb communication
allocating programs
minimize response
a dinda
mesh embeddings
r o
problems on
of scheduling
to individual
response time function
response time functions
the response time
o np 2
in o np
optimal response time
number of processors
response time problem
response time constraint
time function for
a response time
a series parallel
the throughput constraint
the throughput problem
2 log p
log p time
series parallel task
np 2 log
minimal response time
the optimal assignment
embedding rectangular grids
meet the throughput
series parallel precedence
time function f
of series parallel
each t i
subject to a
time proc time
np 2 time
the optimal response
given response time
nonconvex response time
for individual tasks
time constraint fl
of stereo image
time functions for
proc time proc
image understanding benchmark
is convex over
to individual tasks
all feasible assignments
throughput subject to
s response time
to a response
series and parallel
algorithms for mapping
asgn sec asgn
for parallel tasks
through the task
assigning processors to
sec asgn sec
throughput constraint and
of data sets
tasks are considered
processor assignment for
the task structure
sequence of data
r o hallaron
david r o
t 2 and
must be processed
to the response
intel ipsc 2
are considered to
the intel ipsc
the tasks are
to t i
of processors to
f p is
and t 3
response time for
for each t
the series composition
branches and loops
schedule length a
in a transputer
considered to form
a motion estimation
processors to t
minimum response time
scheduling parallel task
parallelism on large
multiple processors to
11 0 007
minimizing response time
function c j
achieving a given
square grids with
is potentially parallelizable
np sup 2
over a b
multitasked parallel architectures
while achieving a
processors to individual
were observed to
architectures and parallel
in binary hypercubes
and loops within
constraint fl and
mesh embeddings in
dinda jon webb
united states jaspal
parallel task systems
grids in hypercubes
allocating programs containing
systolic algorithms onto
both by pipelining
are dummy tasks
processors to each
array assignment problem
a multiple processor
algorithms for integrated
q processors and
parallel task system
an optimal response
or response time
webb communication and
to minimize schedule
is statically assigned
subhlok david r
optimal processor assignment
maximizing throughput subject
pipelined data parallel
for pipe pipelined
mapping task and
minimal mesh embeddings
containing branches and
utilizing multidimensional loop
a dinda jon
throughput problem is
multiprocessor tasks to
throughput if the
partitioning in a
elemental tasks t
memory requirements as
the least cost
the minimum on
grids with dilation
parallel precedence relation
every data set
every task is
that achieve throughput
multiple processor system
count q we
throughput constraint is
nondecreasing function of
response time subject
assign processors to
feasible assignments a
the throughput requirement
system in computer
states jaspal subhlok
partitioning of cache
a loop where
functions are convex
jon webb communication
loop parallelism on
f p fl
with dilation two
parallel tasks has
tasks we may
every response time
pipelined image processing
minimize schedule length
than q processors
convex then the
parallelism in applications
convex over a
task structures and
peter a dinda
embeddings in binary
is o np
use in scheduling
mapping systolic algorithms
hallaron thomas gross
subhlok gary vondran
and parallel components
for mapping task
response time if
scale parallel processor
o hallaron thomas
12 0 11
are convex then
task structure and
and processor count
minimize response time
processor count q
assignments in t
multistage linear array
times for individual
throughput constraint using
its optimal response
image processing engine
motion estimation system
task is potentially
complexity of scheduling
i processors for
tasks has already
x processors to
on mapping systolic

corpus/krapavin2000-test/629334.txt
synchronizer
processor
delays
rate
synchronizers
processors
stochastic
ro83
petri
dilation
network
nbue
markov
embedding
nets
transmission
distributions
firing
chain
er2
er1
ws
negligible
message
transits
bt89
s84
topologies
networks
messages
ff
exponentially
directed
enabled
delta
log
cycle
limiting
vertex
subadditive
gx
ck
ae
ffi
shuffle
pr
fork
convex
ergodic
edges
marked
topology
synchronization
exponential
a1
asynchronous
queueing
quiescent
clock
vertices
realization
beats
proposition
edge
embed
queuing
incoming
ps
deterministic
ba89
mmz88
rajsbaum
r88
ma89
awakened
debruijn
bg89
chep
d70
bl91
pu89
slowdown
slow
combinatorial
vg
unam
bs88
spanner
probabilities
degraded
synchronous
grows
gamma1
random
remark
queues
indegree
kb
outdegree
completion
degree
corollary
fi
recursions
cb
logarithmic
induction
butterfly
completed
graphs
arrived
coming
slows
ending
slower
schedulers
diminishes
tentative
sends
join
kd
gammak
sent
identically
strongly
probability
transition
rates
shall
m2
links
bounds
son
inductive
eg
jv
snapshots
acyclic
regular
breadth
st
fx
gamma
techsel
cl85
ciudad
dgsca
transmissiondelays
fikm
b88
v2v
simplesynchronizer
rm92
theassumption
ps89
04510
exponentialdistribution
awake
pv89
unittime
bm89
redvax1
quentin
westudy
bmt89
liberty
bk91
sy86
matematicas
instituto
sideman
k73
c67
ra91
unison
therandom
forthe
gurdip
grst92
selfloop
theaverage
bfs
lipman
og87
bakr
bms89
synchronousnetwork
abottleneck
leastlog
path
minus
bottleneck
finishes
token
a2
recurrence
investigations
routing
optimistic
definite
processing times
the rate
processor v
rate of
k v
transmission delays
the network
a processor
computational step
stochastic petri
the synchronizer
the processing
directed cycle
random variables
g v
log delta
petri nets
delta in
markov chain
level l
networks with
limiting probability
k 0
exponentially distributed
network is
the markov
every k
of processors
marked graphs
mean gamma1
simple synchronizer
negligible delays
log ffi
the limiting
ff v
rate is
k n
slow processor
v k
with dilation
in g
s 0
complete graph
e t
simple directed
network synchronization
times k
ws k
v e
processor in
t v
delays are
m k
with mean
order n
log n
in v
non negligible
r v
its in
asynchronous network
network with
theorem 3
t k
state s
a network
of distributions
time t
the processors
ck log
state ws
ro83 s84
more variable
computation rate
synchronizer is
potential rate
negligible transmission
processing state
d out
topology but
regular degree
synchronizer for
ergodic theory
a synchronizer
chain associated
variable than
for every
dilation 2
arbitrary topology
at level
the random
times in
states in
distributed networks
in h
n g
one message
processor is
computational steps
different topologies
fork join
v and
v in
edge to
have that
are independent
strongly connected
can embed
variables k
mean 1
distribution f
a complete
all processors
deterministic case
complete network
processors in
probability distributions
t g
times are
r g
k 1
of states
h v
an embedding
4 log
incoming edge
embed the
different networks
global clock
n gamma
length k
the slow
lemma 4
subadditive ergodic
random processing
of synchronizers
kb n
enabled processors
exact computations
in er1
stochastic ordering
network k
general distributions
ffi out
corresponding processing
degree network
ps k
marked graph
stochastic marked
compare networks
steps executed
transits to
limiting probabilities
general probability
pr ck
state ps
same arbitrary
same rate
a processing
theorem 4
each processor
v is
g t
ff j
distributions of
ffi in
of distributed
path of
equal to
v of
we compare
v for
h are
of length
distributed with
are random
the delays
lower bounds
deterministic processing
degraded by
out degree
same mean
adding edges
combinatorial approach
a path
network we
n t
v 0
it follows
of messages
variables with
of computation
of v
of stochastic
follows that
c n
the behavior
constant factor
the exponential
embedding is
the rate of
the processing times
the rate is
stochastic petri nets
rate of a
rate of the
log delta in
processing times in
of the network
that the rate
t k v
processing times are
the order n
in the network
for every k
the markov chain
the random variables
of a processor
the limiting probability
with mean gamma1
e t i
limiting probability of
on the rate
each of its
a complete graph
the network is
a processor in
of the synchronizer
processing times k
processing times and
n g t
times k v
a simple directed
every k 0
the slow processor
simple directed cycle
a computational step
at level l
a network with
of states in
transmission delays are
rate of any
in distributed networks
path of length
g v e
negligible transmission delays
v e be
random variables k
chain associated with
rate of computation
message m k
v k 0
graph with dilation
a processor v
which the processing
ck log delta
can embed the
embed the order
variables k v
the simple synchronizer
number of states
we have that
k n is
exponentially distributed with
d in v
of its in
k v k
one can embed
an asynchronous network
random variables with
of the random
on each of
s 0 by
level l is
with dilation 2
number of processors
by theorem 3
of length k
the number of
of the processing
is at least
e be a
to s 0
from s 0
it follows that
of the processors
theorem 3 3
up to time
the same rate
time t v
logarithmic factor in
random processing times
edge to processor
the synchronizer is
the transmission delays
of non negligible
processor v in
exponentially distributed processing
v or simply
deterministic processing times
computational steps executed
markov chain associated
arbitrary topology but
corresponding processing times
more variable than
the limiting probabilities
the potential rate
strongly connected graph
same arbitrary topology
of graph embedding
non negligible transmission
bounds for stochastic
non negligible delays
the same arbitrary
the computation rate
rate of v
subadditive ergodic theory
reached from s
in k n
ending in v
the same mean
of any network
limiting probabilities of
with different topologies
n gamma l
a directed cycle
processor is enabled
its in coming
stochastic marked graphs
distributed processing times
of network synchronization
general probability distributions
n t v
network k n
mean gamma1 we
by the firing
state ws k
r g v
we compare networks
with mean 1
of computational steps
transmission delays and
the effect of
lemma 4 1
study the effect
to time t
maximum degree of
n is at
the network we
processors in the
in an asynchronous
theorem 2 1
a constant factor
lower bounds on
number of messages
the behavior of
realization of the
are independent and
the maximum degree
1 the rate
in the maximum
h k v
rate is at
message transmission delays
4 log n
independent r v
if the processing
of different networks
the incoming edge
number of computational
a program designed
k 0 there
variables with mean
show that adding
and lower bounds
of a simple
v 2 v
graph in the
is equal to
an edge to
incoming edge to
path in h
proof of part
one message is
a complete network
theorem 3 8
that the processing
in networks with
k 1 v
distributed with mean
be a network
that lemma 4
of distributed algorithms
class of distributions
networks with different
distributions of the
probabilities of the
with the same
of theorem 3
upper and lower

corpus/krapavin2000-test/629351.txt
simd
queen
grainsize
atomic
gromos
mimd
processor
kernel
synchronous
processors
thread
instruction
auction
fullness
asynchronous
messages
loosely
mp
dest
subqueen
message
efficiencies
runtime
responsequeen
parallelqueen
irregular
utilization
machines
msg2
chare
threads
molecular
rescheduling
instructions
load
destination
collision
placement
parallelism
grainsizes
sequentialqueen
suspension
emanated
graphinators
superoxide
board
mpl
priority
maspar
tailing
1k
computations
granularity
speedup
ghc
balancing
transfer
execute
act
buffered
efficiency
overhead
iteration
active
scheduling
architectures
massively
processes
seqqueen
solutioncount
graphinator
queeninit
lgdf
auc
msg3
dismutase
oscreateproc
msg1
residual
emergency
synchronization
linda
cyclic
variation
m1
corp
sod
mandelbrot
cyc
queens
m2
scheduled
supercomputers
cm
array
barrier
indirect
prevention
millisecond
entry
balance
send
addressing
dynamics
prolog
sec
speedups
transferred
program
phase
declarations
unprocessed
imbalanced
cycle
balanced
portable
growing
sys
diagonals
unsolved
deliver
transfers
reactive
oriented
src
computers
98
maximize
nonuniform
ix
executes
flat
execution
wait
deferred
viii
int
selection
machine
pn
repeatedly
methodologies
thinking
simulation
architecture
keyword
milliseconds
mismatch
loop
simlad
4209
dietz
rescue
bookkeep
npac
stalled
hut
mized
label1
gummaraju
nael
code1
6968
xianzhi
5688
rips
computation0
dally
label2
4001
code2
jayanth
mattan
bernut
qcd
ahn
responsecount
abu
procname
hanxleden
syracuse
wilsey
groningen
8809615
ghazaleh
babb
bovine
4phase
jerry
unsent
9109114
hensgen
iterations
priorities
communication
ffl
body
newly
fortran
vii
atomic computation
p kernel
atomic computations
on simd
n queen
asynchronous problems
data messages
loosely synchronous
simd machines
a simd
simd machine
the grainsize
mp 1
the p
queen problem
auction algorithm
thread based
12 queen
computation selection
grainsize variation
dest p
data area
common data
system overhead
synchronous problems
runtime support
support system
active t
destination processor
the gromos
act i
the atomic
memory space
processor p
application problems
the thread
user program
process messages
of atomic
sec speedup
message transfer
the simd
instruction level
level approach
process message
queen 13
program phase
queen 14
full state
13 queen
14 queen
gromos program
kernel system
a runtime
problems on
synchronous and
system efficiency
kernel is
iteration t
computation types
an mimd
the auction
oriented approach
molecular dynamics
the instruction
cyclic algorithm
indirect addressing
gromos 12
the mimd
chare kernel
queen 8
handle asynchronous
queen gromos
speedup time
system phase
machines handle
the fullness
fullness efficiency
time sec
theta k
a 12
execution time
of processors
16 a
thread level
kernel language
the loosely
simd architectures
a 16
load balancing
every processor
messages are
application oriented
simd computers
each atomic
random placement
data message
t active
region growing
implemented on
12 a
at processor
array based
connection machine
the processor
instruction multiple
emergency state
residual data
system oriented
queen is
execute different
synchronous loosely
flat ghc
mimd like
message msg2
maspar mp
processor suspension
process placement
process definitions
tailing effect
mimd machines
1k processor
the 1k
reactive kernel
processor mp
efficiencies sys
generated process
grainsize of
simd hardware
priority auction
the utilization
processors are
each processor
8 a
the destination
at iteration
based programming
processor utilization
the system
i t
efficiency depends
and simd
nearly full
utilization efficiency
main process
active processors
sys n
computation type
programming methodology
irregular and
and speedups
available parallelism
the n
and asynchronous
state when
the user
of processes
different processors
ffl the
processor q
placement the
central control
system program
j p
efficiency is
data parallel
newly generated
int k
control unit
and thread
d k
to execute
a process
are buffered
cycle through
on mimd
of threads
one instruction
overhead the
massively parallel
adaptive algorithm
computation will
processor executes
the 12
computation model
the synchronization
all processors
the computation
type a
a message
the load
be transferred
execute the
machines is
f int
the cyclic
computation phase
problem and
space at
different problem
the p kernel
a simd machine
the n queen
common data area
the atomic computation
on simd machines
of atomic computations
on a simd
p kernel is
problems on simd
instruction level approach
runtime support system
n queen problem
act i t
8 a 12
time sec speedup
the grainsize variation
loosely synchronous problems
of data messages
the instruction level
12 queen 13
queen 13 queen
the gromos program
the system overhead
queen 14 queen
12 a 16
a 16 a
a runtime support
p kernel system
13 queen 14
atomic computation types
the auction algorithm
the thread based
loosely synchronous and
the system efficiency
in the p
a 12 a
sec speedup time
p kernel language
an atomic computation
simd machines handle
asynchronous problems on
the loosely synchronous
14 queen 8
speedup time sec
queen 8 a
the message transfer
n queen gromos
each atomic computation
user program phase
queen gromos 12
gromos 12 queen
the destination processor
at processor p
t active t
on the connection
at iteration t
number of processors
the connection machine
memory space at
maspar mp 1
f int k
process messages are
of atomic computation
a common data
with d k
newly generated process
thread based programming
the system oriented
processor p with
the asynchronous problems
the utilization efficiency
processor mp 1
on the 1k
auction algorithm is
and the gromos
data messages and
1k processor mp
the thread level
the 12 queen
active t active
nearly full state
atomic computations and
synchronous loosely synchronous
sys n queen
system oriented approach
based programming methodology
the cyclic algorithm
application oriented approach
different processors can
fullness efficiency the
atomic computation type
space at processor
12 queen problem
the 1k processor
the application oriented
system overhead the
efficiencies sys n
machines handle asynchronous
residual data messages
thread based model
queen problem and
mp 1 the
the user program
central control unit
handle asynchronous problems
of the p
i t is
efficiency depends on
the main process
for different problem
kinds of messages
times and speedups
the computation phase
the processor utilization
transfer of data
efficiency is defined
computation will be
execution time of
in the instruction
figure 7 is
synchronous and asynchronous
out of memory
messages to be
and the load
execution times and
to be transferred
utilization efficiency depends
the first transfer
of threads can
the new resource
a barrier at
on the board
an auction algorithm
a user program
p kernel the
loosely synchronous asynchronous
process atomic computation
for application problems
atomic computation with
the residual data
of available parallelism
36 37 39
and speedups mp
to implement on
entire instruction set
transparent to users
one atomic computation
the process message
f cyc is
kernel is able
the fullness efficiency
ffl the gap
system efficiency is
destination processor id
processors at iteration
and thread based
queen problem as
atomic computations a
handle general asynchronous
thinking machines corp
the synchronous problems
m2 j p
msg3 m f
n body simulation
are active the
atomic computations that
the synchronization phase
thread based approach
dest p 1
the data message
asynchronous problems is
few processors are
parallelqueen and responsequeen
7 is 0
implement on a
chare kernel 30
synchronous problems can
like software on
on an mimd
on simd computers
of instructions emanated
a loosely synchronous
p kernel was
computation selection algorithms
efficiencies for different
maximize the processor
computation type a
on mp 1
body simulation is
on simd hardware
granularity can be
software on simd
msg2 i j
processors can execute
atomic computations are
iteration 1 in
one common data
queen problem on
data area should

corpus/krapavin2000-test/629361.txt
embedding
std
xor
cube
torus
multicomputer
dilation
hypercube
toruses
embeddings
ring
onto
distances
cc
clockwise
multicomputers
rings
byweight
meshes
counterclockwise
hypercubes
neighbor
load
links
dimension
mesh
interconnection
topology
neighbors
mod
dimensions
spectrum
distance
ave
node
vertices
dimensional
spague
processes
labeled
fft
topologies
longest
d1
dc
squared
waiting
proven
lemma
averagedistance
communication
d2
executing
cubes
metrics
nodes
matic
lai
numbering
finish
intervals
dilations
vertex
communicate
corollary
shortest
mapped
outperforms
processors
minimizes
tic
duration
obviously
stage
periods
focuses
modelled
choi
link
stages
wrap
communicates
routed
average
bit
clarity
interconnected
concentrates
hop
centers
1247
1239
wohlmuth
1clockwise
tarkov
wwith
gonzlez
cerio
mun
jaeyoung
indistinctly
karci
youngsong
lindenberg
1distances
0th
consequence
lemmas
period
routing
mapping
tasks
excepting
cepba
880
mayer
daz
1260
kohonen
2k
undirected
label
expressions
lowest
proposals
execution
conflicts
radix
1256
mikhail
valero
hyung
garca
isoperimetric
1036
expression
minimizing
sorts
says
exchange
target
message
cf
executed
hopes
569
harper
cicyt
friedrich
tori
otto
scalable
embedded
labels
scalability
abstractmany
optimality
loaded
4k
574
bw
edge
destination
emulation
ministry
restated
interconnect
luis
interchanged
matter
frequently
sorting
activity
arrive
allocated
contribute
move
odd
reviewing
euromicro
281
constitute
configurable
tackled
periodic
extensively
bijective
symmetrical
tuples
miguel
atlanta
barcelona
corollaries
injection
ready
imply
phase
wait
negligible
tao
d cube
std n
xor embedding
n std
standard embedding
cube algorithm
the xor
constant distances
2 d
cc d
cube onto
d 1
embedding is
embedding with
onto a
std d
dimensional torus
a ring
f d
an embedding
with constant
the multicomputer
c dimensional
cube algorithms
d n
average distance
d 2
a d
n j
the embedding
the cc
k mod
j n
d i
d nodes
clockwise in
a cc
links dilation
dilation spectrum
hypercubes onto
d c
mod 2
the hypercube
n w
a hypercube
the standard
embedding of
in relation
n i
0 d
load of
a multicomputer
is counterclockwise
xor d
d std
i n
the d
c n
w c
minimum load
standard and
distances d
the byweight
f xor
byweight embedding
counterclockwise in
xor embeddings
on rings
xor n
communication topology
every process
dilation of
optimal for
node n
average load
embeddings with
in consequence
ring with
waiting intervals
longest dilation
algorithm onto
is clockwise
for rings
embedding f
is optimal
relation to
mesh or
the ring
1 d
embedding for
embeddings of
execution time
one dimensional
embedding on
to links
or torus
the links
the torus
this embedding
any node
i 0
distance of
dimensions of
dilation is
interconnection topology
total dilation
communication component
whose dilation
communication tasks
dc c
torus is
hypercube onto
d1 2
2 dc
called xor
2 d1
and toruses
node c
the load
n k
proven that
the execution
torus the
d processes
3 cube
of embeddings
links whose
the average
each dimension
node due
of hypercubes
embedding the
be labeled
d j
for meshes
nodes of
d k
embedding and
point links
dimension i
onto rings
n xor
multicomputer in
multicomputer the
with hypercube
embedded onto
neighbor processes
target multicomputer
onto toruses
onto meshes
d2 2
torus multicomputers
are clockwise
2 d2
4 cube
the graph
all distances
embedding has
in dimension
any subset
the dimensions
neighbor in
of dimensions
node of
dimensional meshes
the dilation
with dilation
a torus
mapping function
process n
mapped onto
to 2
with 2
dimension in
dimensional mesh
i c
n elements
hypercube communication
a squared
d be
the communication
of any
a line
the nodes
is proven
and minimum
distances of
parallel algorithms
any embedding
graph represent
meshes of
of hypercube
distances must
neighbors at
embedding are
k n
i d
x k
interconnection topologies
hypercube is
n std n
std n std
the xor embedding
the standard embedding
d cube algorithm
with constant distances
cc d cube
a d cube
cube onto a
embedding with constant
f d n
onto a ring
2 d c
n j n
an embedding with
the d cube
d cube onto
2 d 2
d cube algorithms
of a d
i 0 d
mod 2 d
2 d 1
of the hypercube
n i n
xor embedding is
the cc d
k mod 2
n w c
c dimensional torus
2 d nodes
embedding is optimal
0 d 1
of the cc
links dilation spectrum
the average distance
of the d
in relation to
average distance of
d 2 d
standard embedding is
the standard and
distances d i
constant distances d
to 2 d
d 1 d
both the standard
d 1 of
a cc d
the links dilation
1 d 2
is optimal for
with 2 d
d be an
of the xor
of the multicomputer
d i i
that the xor
ring with 2
embeddings with constant
is counterclockwise in
x k mod
one dimensional torus
the byweight embedding
counterclockwise in relation
be an embedding
i i 0
a ring with
f d be
of the embedding
1 of a
n k n
due to links
cube algorithm is
relation to n
and the xor
standard and the
xor embedding of
of hypercubes onto
clockwise in relation
embedding on rings
n std d
let f d
0 to 2
embedding of a
d i d
dimensions of the
d i n
than 2 d
mesh or torus
is proven that
the average load
of the standard
distance of the
it is proven
xor embedding the
dc c dimensional
optimal for meshes
2 d1 2
called xor embedding
2 dc c
whose dilation is
std d std
links whose dilation
a 2 d1
d n v
algorithm onto a
to f d
cube algorithm on
and minimum load
is clockwise in
d std d
the execution time
the load of
in dimension i
c n i
least 2 d
node due to
nodes of the
k c n
to point links
d c d
c n j
of the graph
point to point
is mapped onto
the communication component
onto a 2
d n w
4 cube onto
for the xor
d n std
of the torus
d1 2 d2
hypercube communication topology
hypercubes onto toruses
the embedding f
the longest dilation
neighbor in dimension
h d n
std n figure
a 4 cube
links with dilation
any embedding with
to links whose
the xor embeddings
2 d2 2
graph represent the
algorithms with hypercube
embedded onto a
std d n
of different performance
to communication tasks
standard embedding on
due to communication
on a multicomputer
relation to f
a ring the
embeddings of a
hypercubes onto rings
d nodes then
the target multicomputer
meshes and toruses
d2 2 dc
std d 2
cube algorithm onto
execution time of
i n j
of the ring
node of the
for both the
a d 1
for the standard
maximum and minimum
a one dimensional
the nodes of
from node c
d n i
j c n
d n k
d 1 0
problem of embedding
different performance metrics
set of different
n i c
graph which represents
the particular case
of 2 d
an embedding of
topology of the
from 0 to
we have that
of a hypercube
distances must be
the dilation of
the graph represent
any node of
dilation of the
two dimensional meshes
load of a

corpus/krapavin2000-test/629396.txt
speedup
ksr
uniprocessor
scalability
subcache
processors
superlinear
eq
scaled
isospeed
cache
mflops
sequential
generalized
speed
ring
traditional
virtual
asymptotic
processor
remote
unitary
householder
memory
shared
kendall
rlsp
isoefficiency
xian
speedups
engine
theta
efficiency
proportionally
inefficient
slalom
mbytes
sizeup
regularized
rings
scaleup
matrix
ratio
cycles
machines
computers
scalable
superlin
burg
reform
stablized
scalabilities
allcache
intensive
fig
ksr1
maspar
doubled
measurement
metric
parallelism
latency
access
iso
scientific
metrics
elapsed
equals
squares
givens
unscaled
ncube
quotient
influence
hierarchy
shifting
measured
fat
gbytes
scales
factorization
cornell
puters
se
profile
paragon
inefficiency
fits
slows
slower
bounded
accommodated
deficiency
sun
unity
group
analytic
1024
cm
solved
perfect
cubic
benchmark
square
engines
platforms
solving
gpst
pantano
abstractgeneralized
dorder
consedered
debatable
jogalekar
processers
commonly
timing
achieves
clock
floating
consumed
fixing
intel
machine
passing
industries
tmc
superlinearity
agencies
credits
patterned
malloc
1088
prasad
fahringer
woodside
inflated
589
deductions
gustafson
offset
512
revealed
ideal
speeds
excellent
finish
cause
measures
570
grand
sandia
enjoyed
jianping
advancement
unprecedented
603
amdahl
unmeasurable
extremely
causes
instruction
numerical
big
5n
arena
unlikely
seven
locate
targeting
skill
elusive
sp2
porting
technology
maintained
he
2n
significantly
increased
columns
flops
connecting
absolute
equality
government
murray
458
cessing
noticeably
wonder
efficiencies
kbytes
simulators
segments
sparse
calculated
qr
tridiagonal
search
generalized speedup
traditional speedup
speedup is
ksr 1
memory bounded
problem size
fixed time
shared virtual
virtual memory
asymptotic speed
scaled speedup
superlinear speedup
speedup the
0 cache
the generalized
bounded speedup
sequential processing
speedup and
group 0
sequential speed
theta theta
of processors
the traditional
the uniprocessor
parallel processing
isospeed scalability
relative speedup
memory access
the sequential
speed is
the fixed
c p
the scaled
the speedup
the ksr
remote access
single processor
time generalized
average speed
scaled problem
uniprocessor efficiency
local cache
w 0
the asymptotic
remote memory
ring 0
of superlinear
parallel speed
fixed size
on ksr
generalized efficiency
local memory
search engine
memory machines
parallel computers
1 parallel
work w
access time
uniprocessor cost
speedup can
the subcache
5 mflops
scalability 12
multiple processors
the memory
s w
the parallel
time speedup
speed over
i processors
1 cache
is unitary
of uniprocessor
over sequential
the scalability
execution time
of work
kendall square
solved on
the measured
memory is
i w
parallel computer
ring ring
size speedup
bounded generalized
uniprocessor speed
speedup given
computational speed
ring 1
square ksr
xian he
he sun
algorithm machine
a ksr
the isospeed
regularized least
traditional scaled
processors increases
virtual address
sequential algorithm
the matrix
scalability of
memory hierarchy
in fig
and memory
12 equals
increases proportionally
local ring
engine 0
scalability is
of parallel
w is
p processors
computation intensive
group 1
speedup on
mbytes of
large problem
cost ratio
processor cycles
system size
local access
the speed
if fixed
asymptotic cost
measured superlinear
absolute speedup
machine combination
work types
profile shifting
speedup 3
access ratio
machine clock
speedup are
size traditional
of ksr
uniprocessor execution
subcache the
unitary speedup
32 mbytes
reasonable measurement
bounded scaleup
householder transformation
speedup s
problem sizes
of per
large problems
memory machine
cache and
eq 6
intensive applications
as parallel
the local
in eq
speedup for
between fixed
the kendall
a scientific
is linear
in parallel
are active
distributed memory
the machine
one processor
cycles for
sequential execution
parallel work
scientific application
clock rate
speedup with
1 shared
analytic model
equals one
simple analytic
causes of
ratio of
the remote
processors are
of eq
parallel execution
on shared
speed on
parallel system
the regularized
size increases
is fixed
passing model
the iso
proportionally to
to 34
timing results
performance metrics
shared memory
not equal
more reasonable
sequential time
matrix is
parallel algorithm
access is
the generalized speedup
generalized speedup is
the traditional speedup
shared virtual memory
group 0 cache
memory bounded speedup
number of processors
the asymptotic speed
the fixed time
theta theta theta
virtual memory machines
the problem size
the ksr 1
fixed time generalized
time generalized speedup
traditional speedup is
and memory bounded
ksr 1 parallel
of superlinear speedup
on ksr 1
speedup is linear
the average speed
generalized speedup and
the scaled problem
a single processor
p i w
c p i
fixed time speedup
speedup is unitary
the scaled speedup
speedup and the
speedup is a
generalized speedup the
the sequential processing
1 parallel computer
the uniprocessor efficiency
fixed time and
in parallel processing
speedup is defined
of processors increases
traditional scaled speedup
scalability 12 equals
5 5 mflops
regularized least squares
the fixed size
as parallel speed
group 1 cache
speedup can be
xian he sun
speed over sequential
on shared virtual
i processors are
p s w
time of per
speedup the scaled
kendall square ksr
scaled speedup is
defined as parallel
causes of superlinear
a ksr 1
bounded generalized speedup
over sequential speed
traditional speedup the
square ksr 1
on the ksr
memory bounded generalized
the traditional scaled
fixed size speedup
scaled problem is
parallel speed over
the isospeed scalability
on a ksr
search engine 0
on a single
the speedup is
of local memory
the local memory
problem size increases
s w 0
the work w
speedup is the
remote memory access
processors are active
c s w
time and memory
of the sequential
c p s
problem is solved
execution time can
1 shared virtual
of problem size
memory bounded scaleup
a scientific application
may not equal
algorithm machine combination
cache and group
virtual memory machine
when i processors
of ksr 1
remote access ratio
traditional speedup and
machine clock rate
the computational speed
sequential algorithm and
computation intensive applications
between fixed time
measured superlinear speedup
on the asymptotic
32 mbytes of
the uniprocessor execution
local ring ring
12 equals one
and group 0
virtual address space
the memory bounded
speedup given in
size traditional speedup
ring ring 0
the simple analytic
the regularized least
simple analytic model
asymptotic speed is
average speed is
traditional speedup on
superlinear speedup are
if fixed time
uniprocessor speed is
into the subcache
shared virtual address
memory access time
in the local
is defined as
the number of
the relative speedup
and remote memory
w i be
sequential execution time
speedup the speedup
the local ring
increases proportionally to
s w is
work w is
on multiple processors
parallel execution time
the kendall square
between the generalized
superlinear speedup is
local cache and
mbytes of local
virtual memory is
the cost ratio
up to 34
be as defined
proportionally to the
w 0 is
the matrix is
ratio of the
of the parallel
where w 0
with p processors
is the cost
processors on the
message passing model
the system size
the search engine
with the traditional
and the generalized
access time of
the sequential time
local memory of
time can be
shared memory model
on one processor
shown in fig
the shared memory
sequential and parallel
the message passing
the influence of
of the matrix
the parallel algorithm
of the traditional
cost is fixed
matrix is increased
size increases proportionally
so big that
scaleup then memory
sequential processing on
define the uniprocessor
the uniprocessor speed
problem size w
search engine se
speeds for different
uniprocessor efficiency is
the sequential speed
speed is defined
analytic model 4
existing performance metrics
scientific application has
34 local rings
processors generalized speedup

corpus/krapavin2000-test/629399.txt
hull
mesh
hulls
broadcasting
buses
meshes
convex
supporting
bus
textstyle
submeshes
pocket
vertices
2r
vertex
substep
olariu
rank
row
semigroup
processor
stage
schwing
broadcast
packet
neighbors
coordinates
plane
log
gurla
sorted
sample
rm
column
himabindu
dap
convexity
stephan
movement
geometry
rectangular
massively
venkatavasu
bokka
pockets
qa
theta
vlsi
broadcasts
processors
reconfigurable
2z
holding
fastest
samples
wilson
larry
collinear
yn
halfplane
elizabeth
23529
unenhanced
dedicate
stageg
bhagavathi
dominion
norfolk
enhanced
merged
submesh
unsorted
stored
gamma1
virtue
stout
2y
proposition
intersected
separable
own
square
altogether
preserved
communications
invariant
xy
mn
detects
qp
james
shall
architectures
image
illustrating
simd
sqrt
hashed
systolic
polygon
sampling
coordinate
lemma
computations
dlog
diameter
invariants
ingredients
miller
intention
perfectly
ffi
storing
va
horizontally
38
receipt
ranks
computers
guarantees
array
architecture
prescribed
spatially
eliminated
phenomenon
department
fvertical
amt
substeps
yuppie
odu
fhorizontal
9407180
holey
fpreprocessingg
937
podality
configurational
movable
edwardsville
0162
cervical
19858
pbroadcasts
ppa
pby
kand
khorizontally
merry
27909
kbroadcasts
62026
0779
dharmavani
5log4
minfj
pand
jingyuan
subtracting
committed
spent
eliminate
update
enhancing
lying
connected
moved
vertical
correctly
counterparts
findings
involves
technicality
triangulating
ibarra
chosing
maxfa
1035
1019
noy
nas1
median
suitably
city
stages
generality
specifically
oe
belong
lies
tedious
chip
recognition
pixels
proceeding
handling
solved
consisting
abstractrecently
supporting line
upper hull
multiple broadcasting
the supporting
convex hull
upper hulls
mesh with
with multiple
a mesh
hull of
r j
the mesh
u 2r
broadcasting of
meshes with
row buses
the convex
of u
with row
u 1
o y
in o
sample vertex
in u
the vertices
a i
line of
of stage
on meshes
stage 2
the upper
hull algorithm
points in
th step
stage 3
line to
bus in
the plane
of size
right neighbors
semigroup computations
the bus
new upper
u 2
log n
n time
2r gamma1
y theta
sorted points
size y
submeshes r
processor in
of upper
the points
major order
n points
rank of
every processor
hull is
rectangular meshes
column major
a supporting
its rank
in r
the packet
in row
mesh connected
8 log
two upper
textstyle 1
enhanced meshes
plane sorted
local communications
l schwing
supporting lines
stephan olariu
processor holding
of submeshes
n textstyle
on enhanced
y time
invariant h
data movement
computing the
u and
computational geometry
first column
takes o
vertices in
o n
theta n
the rank
coordinates of
the submeshes
the coordinates
and u
o x
and v
hold at
log 2
vertex in
the processors
points stored
broadcasting has
own row
convexity guarantees
optimal convex
for sorted
log textstyle
himabindu gurla
gurla stephan
hull as
qa i
task takes
own rank
our convex
size n
left of
lemma 3
the processor
time on
in column
size p
performed in
vertices that
bus to
sample vertices
hull problem
hulls of
hull algorithms
mesh architecture
mesh r
correctly update
square meshes
lower hull
james l
1 over
for meshes
running time
their own
vertices of
vertex u
as consisting
log 3
the sample
n theta
o log
stored in
massively parallel
i th
increasing x
every sample
hull and
rm log
hulls and
the task
movement in
broadcast the
we state
4 n
and right
p n
i 1
of v
x coordinate
j k
of computing
stage 1
original mesh
the invariant
every vertex
sorted by
39 40
meshes ieee
every column
row i
its left
buses of
will broadcast
hull for
hull from
theta 2z
buses are
column buses
z time
y log
in rm
the dap
largest pocket
rm o
perfectly similar
venkatavasu bokka
new hull
packet along
larry wilson
further reference
bokka himabindu
rank within
longer on
pocket a
with multiple broadcasting
the supporting line
mesh with multiple
the upper hull
supporting line of
a mesh with
multiple broadcasting of
broadcasting of size
the convex hull
meshes with multiple
supporting line to
with row buses
upper hull of
hull of a
on a mesh
a i 1
i th step
of upper hulls
o n 1
in the plane
convex hull algorithm
on meshes with
in r j
computing the supporting
mesh with row
the bus in
new upper hull
in u 1
convex hull of
u 1 and
r j k
n time on
line of u
and right neighbors
line of two
the new upper
hull of the
points in the
of u 1
time on a
u and v
u 2r gamma1
of size y
a supporting line
of stage 2
in column major
size n 3
size y theta
two upper hulls
n points in
in o n
on the upper
the mesh with
1 and u
and u 2
of the mesh
computing the convex
hold at the
on the bus
column major order
the points in
the rank of
to hold at
task of computing
the first column
of computing the
of two upper
plane sorted by
n 1 8
the plane sorted
step of stage
broadcast the packet
of stage 3
the processor holding
8 log 3
compute the supporting
o y time
on enhanced meshes
the invariant h
pair of upper
4 n time
textstyle 1 over
every processor in
size p n
stored in column
submeshes r j
the vertices in
points in r
performed in o
be performed in
all the vertices
the coordinates of
of size n
the upper hulls
of size p
v in u
1 8 log
vertices in u
p n theta
state the following
the left of
h and s
u in u
its left and
log n log
the i th
can be performed
proposition 3 3
of u and
of n points
left of u
log 3 4
time of stage
rank of v
neighbors if any
3 n time
their own rank
right neighbors if
the submeshes r
by increasing x
using local communications
gurla stephan olariu
upper hulls and
enhanced meshes ieee
pairs of upper
increasing x coordinate
sorted points in
line to p
the mesh architecture
this task takes
takes o y
every sample vertex
the points stored
in o y
optimal convex hull
in u 2r
meshes with row
major order in
rm log textstyle
to correctly update
multiple broadcasting has
our convex hull
james l schwing
every vertex on
of u 2r
himabindu gurla stephan
convexity guarantees that
2r gamma1 and
left and right
to the left
th step of
in row i
lemma 3 2
of a i
the vertices of
union of u
convex hull problem
coordinates of u
convex hull is
an upper hull
convex hull algorithms
rank of u
computing the upper
sorted by increasing
vertices of u
column of the
we state the
a i and
the task of
computed in o
massively parallel architectures
n 1 6
for meshes with
of r j
a mesh connected
of a set
of the points
in o log
vertex on the
3 4 n
the original mesh
o log 2
meshes ieee transactions
r j 2
row buses of
o y log
multiple broadcasting a
log 2 time
line qa i
log 2 3
data movement in
n sorted points
algorithms for sorted
reference we state
points stored in
supporting line is
buses of size
no longer on
task takes o
upper hulls u

corpus/krapavin2000-test/629409.txt
crown
multilevel
crowns
events
consistently
chordal
security
bipartite
site
transaction
unclassified
leakage
ordering
riv85
event
orders
timestamp
secret
den82
hc86
bou85
aj93a
lattices
databases
planar
bl76
hasse
greatest
replicated
lattice
bouchitt
ordered
orderings
serialization
concurrency
secure
iff
exhibited
globally
classifications
decisions
sites
database
covert
partial
synchronization
timestamping
hierarchical
histories
inconsistent
message
directional
au
cos92
jk90
chordless
kk92
aj93b
serializable
signaling
consulting
serializability
diagram
antichain
lamport
contradiction
nonplanar
serializes
locks
receipt
timestamps
consistent
visible
classes
incomparable
communication
relabel
prohibited
encapsulates
planarity
leaks
totally
dominated
lock
acyclic
vertex
antisymmetric
edges
raw
elimination
clock
enjoy
subgraph
cycle
detection
mod
directed
max
read
resort
split
graphs
remote
discarding
2n
transitive
inconsistency
injective
vqg
unwound
nato
tisymmetric
unshown
trotter
com83
semitrees
proscribed
531
lam78
pleasure
setups
unserializable
obliged
drw82
tro81
salowe
imagination
lam73
locking
channel
precedes
choices
subsequence
edge
inconsistently
kernelized
partite
leaking
diction
receipts
fuller
unwind
outgrowth
prominently
precluding
moh
vd
undirected
observations
items
neighbor
free
incident
restrictions
receiving
indirect
contra
envisioned
708
arisen
lapadula
rework
confinement
multics
communicate
comparability
conjectures
demarcation
rival
chord
confidential
unsurprisingly
vq
ivan
mcdermott
overt
erty
nization
concurrent
maximal
eliminated
cyclic
troublesome
ings
redo
mally
collect
derivative
channels
perhaps
scheduling
sketch
informally
mandate
suits
dominance
unable
dilemma
larly
unfamiliar
global p
consistently ordered
crown free
a crown
partial order
communication structure
partial orders
ordering decisions
multilevel security
hierarchical databases
the crown
communication structures
is crown
p max
crown detection
greatest element
e 1
ordered at
ordered property
the consistently
p j
least upper
event ordering
e 2
is consistently
a partial
class p
crowns in
split graph
globally consistent
of events
at p
the unclassified
a a
concurrency control
s has
that global
secure databases
a greatest
bl76 den82
consistent ordering
free partial
visible at
bound classes
one directional
multilevel replicated
unclassified level
hasse diagram
bipartite graph
l e
free property
b high
local events
not consistently
in multilevel
transaction processing
the partial
the site
control algorithms
event e
exhibited in
a au
crown in
is chordal
as multilevel
of crown
security classifications
replicated secure
or signaling
b low
global synchronization
n least
covert or
dominated classes
timestamping algorithm
secret level
bouchitt e
s is
e i
the ordering
the split
mod n
than 4
additional synchronization
message about
for multilevel
global consistent
site b
directional communication
main database
and hierarchical
each event
a transaction
is bipartite
planar lattice
au a
suppose s
orders to
order has
induced subgraph
decisions are
distributed environment
security and
replicated databases
iff s
an induced
events at
length greater
is exhibited
of global
ordering of
e p
the events
a multilevel
site a
must respect
a lattice
structures that
a distributed
order is
multilevel secure
in partial
consulting the
by consulting
upon receipt
order s
upper bound
q as
lamport s
for event
a bipartite
suppose that
of classes
diagram is
maximal element
event in
directed graphs
events is
classes in
classes then
consistent event
crowns and
bou85 and
to crown
one crown
at class
without resort
planarity is
cos92 kk92
a chordless
about e
synchronization information
planar lattices
totally order
unique greatest
that crown
transaction histories
consistent orderings
e bou85
timestamp generation
ordering assignments
replicated architecture
acyclic communication
sites communicate
max does
receiving site
crowns of
local order
to crowns
planar partial
ordered consider
leakage can
describe communication
jk90 cos92
of crowns
globally inconsistent
inconsistent event
crown since
crown is
being consistently
aj93a a
signaling channel
arbitrary directed
undirected version
why suppose
execution histories
for crowns
he i
further global
corresponding timestamps
partitioned synchronization
be crown
serializes e
given events
paper indicate
chordless cycle
synchronization rule
ordered iff
databases hc86
time o
a a a
a partial order
is crown free
is consistently ordered
s is consistently
the crown free
global p j
has a crown
consistently ordered property
s is crown
that global p
the consistently ordered
least upper bound
a greatest element
crown free property
the communication structure
the split graph
of global p
the partial order
s has a
crown free partial
not consistently ordered
and hierarchical databases
the unclassified level
communication structure is
upper bound classes
is not consistently
ordering decisions are
multilevel security and
has a greatest
concurrency control algorithms
of partial orders
e 2 are
mod n 1
1 and e
and e 2
a a au
e 1 and
example in a
security and hierarchical
replicated secure databases
at the secret
a message about
as multilevel security
a main database
in a multilevel
in partial orders
the secret level
n least upper
one directional communication
p j where
such as multilevel
greater than 4
p must respect
for event ordering
in q as
nodes in q
crown detection in
hasse diagram is
consistently ordered at
exhibited in table
of crown detection
visible at p
free partial orders
that l e
multilevel replicated secure
at the unclassified
a communication structure
communication structures that
covert or signaling
partial orders to
partial order has
the ordering of
partial order is
local to p
a au a
order has a
l e i
an induced subgraph
au a a
a distributed environment
partial order s
that e 1
by consulting the
of length greater
that s has
length greater than
cycle of length
to extend the
is a partial
is a contradiction
a bipartite graph
upon receipt of
of a partial
partial order in
time o n
the multilevel security
make some observations
at p max
a multilevel security
ordered property in
edge can be
set an element
j where class
element of which
e 1 or
to crowns in
let be some
prior to e
q is bipartite
on partial orders
consistently ordered a
the crown detection
be some finite
p max does
order in figure
at class p
consistent ordering decisions
paper indicate that
be globally consistent
why suppose that
part by consulting
bouchitt e bou85
jk90 cos92 kk92
whether a communication
to describe communication
being consistently ordered
clock at the
to crown free
global p to
then remove such
without resort to
ordered property to
additional synchronization information
e i mod
structure is crown
ordering decisions at
consistently ordered iff
hierarchical databases hc86
resort to further
a database at
a crown since
to order e
read locks on
bound classes then
classes in t
directional communication structure
of contradiction consider
for crowns of
indicates that p
consistently ordered consider
global consistent order
a crown in
property to describe
local ordering decisions
partitioned synchronization rule
unique least upper
where class p
suppose s is
crowns of size
the corresponding timestamps
algorithms for multilevel
class p j
free property is
chordless cycle of
g is chordal
s has no
ordering decisions without
global p i
the partitioned synchronization
further global synchronization
be crown free
decisions are possible
max does not
arbitrary directed graphs
be consistently ordered
or signaling channel
condition on global
global p states
describe communication structures
a unique greatest
globally consistent event
crowns in partial
states that global
a chordless cycle
ordered iff s
least one crown
each site must
at a main
detection in arbitrary
see why suppose
on global p
the receiving site
unique greatest lower
than n least
ordered at p
any class p
is exhibited in
event and ordering
encapsulates a database

corpus/krapavin2000-test/629420.txt
tet
tpg
tets
ray
consumer
producer
quadrant
lcet
blocking
rooted
lcets
terminating
tpgs
congruent
vertex
shootray
semaphore
numrecords
petri
fig
synchronization
p1
slope
p2
timed
shooting
rays
fl
segments
receive
green
q3
horizontal
deadlocks
processes
upgs
subtrajectory
findalltets
segment
infinite
transition
x2
nets
blocks
q1
p3
interprocess
buffer
axis
blocked
x4
deadlock
transient
constraint
00
send
npaths
maxnpaths
branchless
dssp
lies
plane
semaphores
quadrants
vertical
progress
intersects
diagonal
a6
iff
vertices
homotopic
visualization
arc
phi
program
dead
programs
b1
geometric
x3
cartesian
units
forever
nondeterministic
axes
disk
trajectory
exclusive
resource
b2
lipski
consumer15
findfreepoints
freepoints
net
hyperplanes
a4
race
4n
periodic
mutually
cycle
red
visual
concurrent
preceding
subpath
oe
od
thick
exclusion
repetitions
deterministic
a1
figs
mct
carson
jjf
color
read
directed
vernon
transitions
colored
records
zg
x7
rectangle
bounding
firing
x1
q2
x5
a5
reynolds
safety
meeting
transaction
final
mutual
spent
optionally
duration
reachable
lines
serially
papadimitriou
labeled
outgoing
restate
roman
cox
gi
initialize
locked
intersect
1st
buffers
block
execution
synchronizing
a3
2nd
followed
visualizing
arrangement
reusable
portion
outcomes
grey
terminates
9211342
abstractthrough
subtrajectories
jed
bottomg
shaffer
soisalon
impli
hfoe
deadlocked
upg
findnonblockinglcets
magott
edgesg
utp
tripathi
bp1
erability
marking
locking
jj
quantities
geometrically
brackets
fg
generators
simultaneously
paths
the tet
a tpg
rooted at
constraint line
at g
point g
a tet
initial point
the producer
g 0
non terminating
tets rooted
the consumer
g 00
possible tets
initial quadrant
process 0
terminating programs
line instance
slope one
in fig
non blocking
final point
tet is
of tets
tet rooted
constraint lines
producer consumer
both processes
are congruent
lies on
f d
ray rooted
diagonal ray
computational geometric
a constraint
line segments
l f
lines in
process 1
infinite length
a point
n th
tpg h
progress graph
the tpg
a ray
one ray
ray shooting
f o
code segment
time units
read send
performance properties
cartesian graph
will block
vertex labeled
timed progress
blocking lcets
write y
vertex for
petri net
infinite number
line l
y write
compute f
an infinite
a process
line segment
d g
continuous path
fig 3
and final
program execution
0 0
to fig
all possible
consumer program
problem p2
producer has
the tets
shootray l
for terminating
terminating program
a quadrant
ray with
directed continuous
never blocks
tpg for
all tets
tet the
blocking lcet
problem p1
read x
11 7
a slope
at time
true do
while true
the graph
f g
petri nets
is nondeterministic
h phi
rule ii
synchronization operation
and p2
program state
3 c
g c
g g
two processes
periodic behavior
intersects a
the program
a program
p1 and
with initial
1 1
a vertex
synchronization points
congruent to
which process
13 b
graph model
of constraint
the initial
a transient
25 31
from g
p1 given
p empty
tpg determine
producer will
to q3
blocking if
time 4n
tet ray
from consumer
th send
ii case
an lcet
tpgs to
output process
terminating producer
and consumer
spent blocked
blocking tets
tet in
0 process
consumer write
green vertex
lies off
second tet
findalltets for
solve p1
one tet
transition out
bounding line
horizontal ray
geometric performance
right bounding
program fig
q1 to
ray that
time assumption
tets recall
tet contains
producer process
horizontal and
g is
fig 6
cycle time
point 0
the plane
x from
finding all
case 2
each process
which both
arc from
at point
r 2
any point
quadrant in
synchronization point
producer and
yet executed
model corresponding
color g
race condition
execution trajectory
to petri
consumer has
return g
od figure
p operation
graph contains
one vertex
vertex in
rooted at g
a constraint line
tets rooted at
constraint line instance
the initial quadrant
tet rooted at
the tet rooted
non terminating programs
all possible tets
slope one ray
f d g
ray rooted at
fig 3 c
a tpg h
constraint lines in
in fig 3
g c i
given a tpg
point g 0
write y write
with initial point
corresponding to fig
a tet is
at g is
y write y
a slope one
set of tets
one ray rooted
infinite number of
an initial point
while true do
a point g
computation of f
an infinite number
producer consumer program
in the tet
intersects a constraint
the producer has
to a tpg
which both processes
any point g
and final point
shootray l f
a tpg for
timed progress graph
for non terminating
directed continuous path
initial point g
compute f d
number of tets
for terminating programs
the tet is
possible tets rooted
p1 and p2
on a constraint
2 time units
if the consumer
g g 0
the n th
lines in the
the graph contains
lines in fig
fig 3 b
in fig 6
g 0 g
to compute f
of all possible
line segments in
an arc from
final point g
read x from
of constraint lines
right bounding line
two possible tets
a p operation
computational geometric algorithms
transition function f
computational geometric problem
g 00 and
time spent blocked
thus the tet
at g 0
process 0 process
tpg h g
tet is non
terminating producer consumer
a vertex for
vertex for point
transition out of
lies off a
receive x from
a directed continuous
tpg determine if
graph model corresponding
point 1 1
point g and
g and final
the consumer has
the other process
is non blocking
2 the tet
each point g
and f d
non blocking tets
producer and consumer
from a visualization
tet is a
h g c
is a ray
the tet contains
progress of each
output a representation
or right bounding
a tpg determine
x from consumer
phi g c
another constraint line
f o g
top or right
off a constraint
n th send
from a tpg
the producer will
ray with initial
q1 to q3
exactly one tet
when the producer
or y axis
to g 00
rule ii case
geometric performance analysis
process 0 blocks
the second tet
of f o
f o and
g 0 to
p1 given a
h phi g
x from disk
final point of
non blocking if
at time 4n
fig 13 b
in the plane
lies on the
a synchronization operation
model corresponding to
of horizontal and
that lies on
not yet executed
a code segment
to petri nets
0 3 1
o and f
a non blocking
rules i and
set of all
g 1 1
the smallest of
the x or
lies on a
the top or
the final point
3 1 3
number of repetitions
horizontal and vertical
point 0 0
of repetitions of
determine if there
of a program
0 0 1
1 1 and
because the first
from g 0
in the graph
2 0 3
case 2 the
has not yet
g is the
the sequence of
in the initial
in case 2
the progress of
the set of
in r 2
1 4 1
if there exists
in fig 11
in which both
x or y
that leads to
a green vertex
one buffer producer
of concurrent execution
consumer has not
fl we write
point 25 31
rays of the
two conditions corresponding
exclusive resource access

corpus/krapavin2000-test/629425.txt
keys
pg
sorting
snake
multiway
sorted
merge
subsequences
zeroes
batcher
bruijn
petersen
shuffle
subgraphs
subgraph
odd
hamming
columnsort
dirty
bitonic
sequences
sort
product
networks
hypercube
subsequence
dimension
gamma2
hamiltonian
exchange
transposition
merging
dimensions
dimensional
asymptotic
mesh
torus
homogeneous
routing
mct
gray
gamma1
grid
dilation
asymptotically
permutation
network
products
ary
sorters
slowdown
exchanged
prefixing
diameter
bisection
congestion
erasing
vertex
concatenation
emulation
leftmost
parberry
uth
symbol
trees
rows
cleans
running
merges
interconnection
consecutive
cube
sorts
filled
position
de
subnetworks
parker
node
2g
column
positions
labels
rightmost
ux
row
transpositions
adjacent
interleave
versatile
connected
predecessor
symbols
grids
differ
graphs
area
concatenated
reading
recursively
hung
221
columns
hypercubes
recursive
merged
weight
referring
array
rm
embedding
f1
cycle
1step
emulations
pgr
fundemental
shuffles
drysdale
schnorr
sortings
lisza
222g
logarithmic
brackets
vertices
organization
tuple
tuples
biing
crcw
tsung
kunde
spokes
dimensionally
aks
hypercubic
routings
shyan
reintroducing
chyun
reconciling
situation
completion
log
generalized
partly
shaded
unreasonably
prams
flies
adaptative
yuh
bounded
tori
bz
pictured
inserting
simplifies
aggarwal
cleaning
curly
butter
leighton
folded
clarification
papers
dividing
white
divide
yung
shamir
210
resp
developing
shan
cleared
ku
puters
tighten
tolerant
ours
nodes
202
2f
instances
randomized
delta
window
width
identifies
f0
euromicro
211
alternates
ting
220
bo
gamma3
kai
product networks
pg r
snake order
dimensional product
multiway merge
sorting algorithm
the keys
n r
r dimensional
r keys
in snake
odd even
pg k
of pg
sorted sequence
keys on
dirty area
r gamma1
of keys
product network
sorted sequences
homogeneous product
de bruijn
to sort
of sorting
shuffle exchange
p g
sorting on
merge sorting
merge algorithm
o r
the multiway
r node
running time
3 dimension
sorting n
dimension 1
of zeroes
pg 2
n sorted
dimension 3
mesh connected
keys in
u p
merge process
v pg
for product
asymptotic complexity
zeroes and
the dirty
dimension 2
sort n
the merge
even transposition
on pg
q r
sequence d
the sequences
hamming weight
r gamma2
the subsequences
connected trees
batcher algorithm
of product
permutation routing
and ones
the r
the hypercube
gray code
of dimensions
the snake
situation after
a sorting
2 node
of odd
sort on
the n
products of
two dimensional
sorting network
sorting networks
subsequences b
2 keys
of petersen
even merge
factor graph
ary gray
the petersen
n subsequences
each sequence
n time
1 dimension
node r
r 2
u v
of de
the running
g subgraph
bruijn networks
initial situation
petersen graphs
in pg
petersen graph
single sorted
b i
product of
sequence j
can sort
dimensional torus
sorted order
the sorting
the hamming
log 2
o n
2 n
r is
sorted in
sequences of
at dimensions
product graph
node shuffle
exchange or
of shuffle
for sorting
our algorithm
even or
zeroes in
length n
the sequence
sorting algorithms
g r
2 dimensional
algorithm on
this step
2 subgraphs
or de
code sequences
exchange networks
hypercube the
and congestion
is sorted
merge operation
the asymptotic
the subgraph
time complexity
keys of
complexity of
the sorted
vertex labels
in product
k gamma2
r tuple
n node
hamming distance
n ary
the odd
i j
n rows
c j
graph g
n 2
exchanged with
sequences into
any computation
when r
n sequences
node de
exchange network
subsequence b
of batcher
congestion 2
one principle
bruijn network
bruijn or
subgraphs at
code sequence
dimensions f1
observe from
compare exchange
group sequence
or shuffle
leftmost position
subgraphs u
for pg
unit hamming
by prefixing
step 3
use u
steps of
g i
sequence a
with bounded
not bounded
recursive call
networks with
is filled
concatenation of
the diameter
of step
asymptotically optimal
n r keys
in snake order
o r 2
n r node
the multiway merge
u p g
multiway merge algorithm
of pg r
complexity of sorting
b i j
dimensional product of
on the n
the r dimensional
dimension 3 dimension
r dimensional product
of product networks
r keys on
for product networks
the dirty area
the n r
keys on the
sort n r
of odd even
r node r
node r dimensional
merge sorting algorithm
u v pg
p g r
pg r gamma1
n sorted sequences
sorting n r
n 2 node
to sort n
odd even transposition
number of dimensions
mesh connected trees
the snake order
of sorting n
number of zeroes
of de bruijn
sorted in snake
homogeneous product networks
asymptotic complexity of
zeroes and ones
the sorting algorithm
dimension 1 dimension
log 2 n
the running time
length n 2
the sequence d
odd even merge
v pg k
single sorted sequence
sequence a i
steps of odd
n 2 keys
the keys of
of petersen graphs
the merge process
sequence of keys
pg k 1
ary gray code
pg r is
subsequences b i
sorting algorithm on
the asymptotic complexity
sorting algorithm for
de bruijn networks
of keys in
a single sorted
a sorting algorithm
on the hypercube
sequences of length
2 n time
the keys in
factor graph g
two dimensional product
of shuffle exchange
sort on the
n ary gray
of the multiway
multiway merge sorting
or de bruijn
pg 2 subgraphs
snake order for
exchange or de
a recursive call
product networks a
sorted sequences into
product of petersen
3 dimension 2
3 dimension 1
shuffle exchange or
g r gamma1
r dimensional torus
the hamming weight
gray code sequences
keys on pg
node shuffle exchange
even merge sorting
algorithms for product
1 dimension 2
of zeroes in
v p g
the petersen graph
r 2 n
the two dimensional
when r is
shuffle exchange networks
of dimensions is
of zeroes and
the keys on
in product networks
as the running
the odd even
the vertex labels
1 k gamma2
running time of
of the odd
recursive call to
is filled with
b u v
see figure 7
of length n
r is not
q 2 1
running time is
two steps of
is not bounded
call to the
the n 2
sorted sequences of
de bruijn or
products of de
de bruijn network
sorted sequence j
product of de
sequences c j
if the hamming
j can differ
at dimensions f1
node 2 dimensional
bruijn networks 9
on pg r
the r tuple
the leftmost position
sorting on pg
and congestion 2
2 dimensional product
of pg k
1 r gamma2
r 2 log
node de bruijn
dimensional product network
possible to sort
2 node 2
sequence c j
shuffle exchange network
on product networks
2 subgraphs are
dimensions f1 2g
merge sorting network
any homogeneous product
p g 3
dimensional product graph
properties of product
snake order on
can sort on
sequence d obtained
or shuffle exchange
dimension 2 dimension
unit hamming distance
of order r
bruijn or shuffle
the zero one
sequences i i
product networks and
product networks in
zero one principle
2 node shuffle
m n figure
gray code sequence
in pg r
product networks have
homogeneous product network
each sorted sequence
to sort on
subsequence b i
n subsequences b
have unit hamming
hamming weight of
networks have been
the time taken
algorithm on the
into a single
the nodes of
element g of
of the keys
in row major
r is bounded

corpus/krapavin2000-test/629430.txt
retiming
dfg
unfolding
unfolded
period
retimed
mcp
legal
cycle
sha
100505
tpds
schedule
inprod
100505_1
dfgs
regularpaper97
dsp
968
delay
iteration
doc
scheduling
sh
prologue
edwin
dot
am
shortest
chao
edge
flow
count
preprocessing
loop
fig
lp
trans
ab
epilogue
retimings
qingfeng
production
static
mip
counts
zili
cr
vlsi
lemma
synthesis
97
zhuge
vliw
paths
shao
library
loops
edges
path
turely
saem
immaterial
schedules
vol
notre
jihong
dame
sched
xiao
graphs
gers
2a
pipelining
factor
rate
codesign
delays
integers
node
nonrecursive
inte
pushed
signal
critical
precedence
unfold
pipelined
circuitry
neil
ceiling
bin
equals
37
periods
struc
yun
designer
mail
nonnegative
dataflow
risc
dependencies
beach
resource
copies
fractional
inequality
273
timothy
multiprocessor
293
3a
host
resp
iff
hardware
jacome
interiteration
iowa
chantana
regroups
iastate
dongming
fice
messerschmitt
daal03
akturan
parhi
transformative
meikang
zhiping
saxe
0074
nonintegral
thies
durham
0459
warshall
abstractloop
asips
ranga
0these
chatha
multiproceesor
reprints
precedences
lfc
chantrapornchai
mook
8912100
50011
nice
iterations
oct
inequalities
han
kim
1997
pipeline
1270
huntington
vemuri
ieeecs
hms
ule
46556
kyoto
finer
negative
unit
iterative
december
feedbacks
1256
amarasinghe
ules
leiserson
matroids
soo
reorganizes
teger
veciana
composes
contradic
fore
subsection
longest
instant
scheduler
factors
copy
dung
rome
saman
army
multirate
xue
circularly
nique
unfolding factor
cycle period
retiming r
r f
g r
legal retiming
a retiming
g f
retiming and
iteration period
a dfg
and unfolding
unfolded graph
the unfolded
in g
a legal
factor f
an unfolding
dfg g
minimum iteration
delay count
u v
mcp f
v f
time dfg
f c
the dfg
r v
of retiming
static schedule
p f
graph g
unit time
data flow
o v
period c
original dfg
rate optimal
that g
f and
d p
22 97
2 inprod
97 9
doc regularpaper97
library trans
ab 19
retiming algorithm
the retiming
inprod 100505
100505 100505_1
968 10
100505_1 doc
trans production
37 am
dot ab
regularpaper97 dot
production tpds
19 968
f library
tpds 2
delay counts
time o
9 37
minimum cycle
v e
retiming on
given unfolding
m sha
negative delay
r u
flow graphs
f f
every path
10 22
from u
dfg c
via retiming
lp form
path u
path p
to v
d e
f an
f v
the minimum
7 s
f for
edwin h
scheduling data
graphs via
edge e
in time
g such
f is
node v
dfg and
time dfgs
unfolding factors
the retimed
f copies
sh v
dfg in
retimed by
iteration bound
computation time
the cycle
the iteration
the unfolding
o f
d f
from v
bound g
shortest path
in fig
v in
of node
h m
loop l
a cycle
c f
for every
edge from
of g
period of
node u
f in
v v
original graph
flow graph
having negative
retiming technique
sha scheduling
chao and
retimed dfg
and sha
l cr
1997 f
by retiming
retimed graph
retiming from
8 no
vol 8
u to
v and
t p
an edge
u i
in v
f g
schedule can
for unit
from lemma
a schedule
12 december
path algorithms
with unfolding
no 12
f r
f the
d l
node set
on g
an unfolded
by unfolding
unfolding is
critical paths
preprocessing algorithm
iteration j
if part
d r
2a is
the preprocessing
and f
v j
v to
t f
e f
v 0
systems vol
december 1997
a static
a path
retiming algorithms
graph dfg
retiming the
unfolding technique
dfg which
corresponding minimum
period mip
bin xiao
dfg is
dfg first
qingfeng zhuge
and unfolded
dfg obtained
retiming to
integer where
and retiming
mip f
g r f
a legal retiming
retiming and unfolding
unfolding factor f
the unfolded graph
an unfolding factor
that g r
legal retiming r
a retiming r
minimum iteration period
d p f
r f c
in g f
such that g
the cycle period
is a legal
in time o
the minimum iteration
a cycle period
time o v
cycle period c
the original dfg
unit time dfg
minimum cycle period
g f c
100505_1 doc regularpaper97
f an unfolding
ab 19 968
9 37 am
library trans production
production tpds 2
968 10 22
inprod 100505 100505_1
f library trans
dot ab 19
100505 100505_1 doc
regularpaper97 dot ab
be a dfg
10 22 97
19 968 10
97 9 37
doc regularpaper97 dot
22 97 9
2 inprod 100505
tpds 2 inprod
trans production tpds
for every path
the minimum cycle
and f an
given unfolding factor
a given unfolding
data flow graphs
p in g
the iteration period
h m sha
period of g
a static schedule
cycle period of
via retiming and
flow graphs via
a dfg g
dfg c a
c a cycle
o v e
graphs via retiming
factor f and
on the unfolded
retiming r on
path u v
unfolded graph g
edwin h m
f for every
time o f
scheduling data flow
of retiming and
t p c
dfg g r
path p in
f in g
and g r
r f is
e in g
g such that
u to v
u v e
every path p
of node v
to v j
in g r
a unit time
an edge from
on the original
order of retiming
period and f
delay count of
for unit time
retiming r f
u v f
g f and
o f v
o v 3
data flow graph
a dfg c
graph g f
from u i
u and v
cycle period and
c if and
is an edge
original graph g
the original graph
v in v
that g f
in g if
vol 8 no
retiming r such
and 7 s
f copies of
negative delay counts
v f in
from v f
graph g r
unfolding factor a
having negative delay
sha scheduling data
exists a legal
retiming from v
retiming on the
and sha scheduling
computation of node
find a retiming
no 12 december
chao and sha
8 no 12
at iteration j
the unfolding factor
december 1997 f
12 december 1997
1997 f library
with unfolding factor
and unfolding is
function from v
the iteration bound
f c if
g f such
systems vol 8
the retiming technique
the delay count
unit time dfgs
edge from u
from u to
schedule can be
v in g
find the minimum
fig 2a is
shortest path algorithms
edge e in
is proved the
g f r
distributed systems vol
from v to
g be a
in fig 2a
of g r
u v s
r u r
e d e
let g be
r is a
runs in time
the graph g
that g c
that d p
c f g
graph g such
f such that
which runs in
f and c
g and s
u v v
of g f
a critical path
for a dfg
cycle period for
mcp f for
u i r
mcp f f
optimal schedule can
j r v
v f to
all s where
dfg and f
no loops having
i r u
iteration period of
v j r
an unfolded graph
0 s f
dfg in fig
delay count d

corpus/krapavin2000-test/629432.txt
bfea
spline
knot
nurbs
curve
surface
vcca
splines
rational
cell
curves
architecture
pumped
surfaces
controller
graphics
ac
megson
systolic
basis
parametric
virtual
clock
patch
calculate
cells
accumulating
array
normals
pts
isoparametric
pipeline
calculating
tangent
uniform
pacs
calculated
delay
bezier
vlsi
patches
weights
unified
rhs
hardware
cycles
conics
dag
pac
derivative
triangle
grid
cubic
indispensable
adder
u2
inner
kth
knots
megsons
subtractors
speeded
denominator
blending
incremented
registers
gammak
workstations
subtractor
pumps
1th
active
quantities
geometric
3d
dummy
units
coordinate
downstream
equivalents
engine
inputs
triangles
normal
architectures
lth
boils
weighted
4d
delta
orders
pins
vectors
extent
vertices
numerator
core
product
derivatives
wn
resultant
generation
host
discrete
throughput
functional
division
nonrational
sandwiched
versprille
7l
u1fourth
proengineer
abstractb
meager
gourard
geomod
7max
systolically
1fourth
casteljau
ushered
nondependence
rationalized
4kl
deboor
lj
p0406control
umin
iges
tessellated
5max
equation
corrupted
row
timing
ffl
bi
calculation
vector
calculates
mathias
pumping
pump
era
umax
ctrl
elaborates
suitably
boxes
apart
rendering
fill
shaded
computes
aided
inset
unfolds
innovations
aliased
slowed
useless
communicate
sent
cycle
microcode
cagd
warranted
continues
shapes
difficulties
generations
raster
rose
explosive
pulled
modeling
calls
upstream
subtracted
semiconductor
routine
evolution
outputs
column
theta
fi
quadratically
utmost
controls
integration
primitives
dependency
decouples
widespread
cards
lighting
impressive
u1
shape
basis function
b spline
control points
basis functions
the bfea
knot vector
the curve
rational b
virtual control
spline curves
b splines
and surfaces
useful basis
order basis
nurbs surface
control point
the knot
function values
the basis
curves and
of basis
the nurbs
computation of
uniform rational
this architecture
the computation
of u
the surface
knot values
spline curve
uniform knot
active control
point on
architecture for
the controller
j l
parametric value
nurbs curve
a nurbs
bfea is
the architecture
non uniform
the ac
clock cycles
points and
function computation
evaluation array
curve surface
curve is
function evaluation
unified architecture
of control
n i
of bfea
bfea the
weighted control
pumped to
product computation
non rational
uniform b
to calculate
u and
curve the
i k
surface is
the parametric
architecture to
of nurbs
the virtual
time required
non zero
discrete values
first cell
graphics pipeline
k basis
curve computation
architecture proposed
value u
spline surface
of b
surface the
k u
input to
inner product
t i
the figure
the vcca
function curves
cell requires
to vcca
are pumped
last point
cell in
only k
u is
l v
the control
each cell
4 n
the point
c u
two clock
one triangle
kth order
systolic architecture
l active
architecture is
0 35
function value
the input
surfaces we
points on
point p
calculate the
x coordinate
normal vectors
vlsi architecture
geometric modeling
architecture presented
linear structure
these control
grid of
w i
a unified
first term
curve and
curve or
processing cell
parametric values
isoparametric curve
highly suitable
by vcca
megson 19
vcca to
nurbs in
nurbs surfaces
i gammak
unit control
calculating array
accumulating cells
curve control
to ac
megson s
bfea as
modeling applications
incremented and
control pts
k useful
compute nurbs
linear architecture
function generation
by megson
the equation
high end
rhs of
required to
to compute
k theta
clock cycle
particular value
the rhs
of equation
functions and
architectures for
equation 8
their weights
points are
the derivative
second term
theta l
whole curve
end workstations
term gives
tangent vectors
valid range
those basis
standard graphics
for integration
nurbs curves
integration into
whole surface
every clock
to various
derivative of
of v
delta delta
the graphics
values are
time taken
from host
functional units
pipeline of
one useful
35 0
zero values
from from
output line
ffl they
are calculated
computer graphics
the basis function
b spline curves
basis function values
the computation of
curves and surfaces
for the computation
virtual control points
rational b spline
control points and
useful basis functions
spline curves and
architecture for the
the basis functions
of control points
of basis functions
on the curve
of the curve
the virtual control
of b spline
point on the
active control points
uniform knot vector
non uniform rational
b spline curve
number of control
values of u
value of u
basis function computation
computation of basis
uniform rational b
basis function evaluation
the nurbs surface
on the surface
of the basis
n i k
rational b splines
the knot vector
i k u
discrete values of
order basis functions
the curve surface
function evaluation array
basis functions and
computation of nurbs
j l v
inner product computation
parametric value u
the parametric value
basis function is
a unified architecture
required to calculate
control points are
of b splines
time required to
the first cell
basis function value
non uniform knot
order basis function
uniform b spline
spline curve is
the bfea the
non rational b
weighted control points
the architecture proposed
knot values are
useful basis function
the knot values
the bfea is
of basis function
of the bfea
the point on
b spline surface
the b spline
the last point
of the architecture
values of v
l j l
k and l
to calculate the
the curve is
the control points
j l j
basis functions are
of u and
points on the
rhs of equation
basis functions of
first order basis
and surfaces we
knot vector and
these control points
basis function curves
l active control
theta l active
types of b
the active control
k theta l
in the bfea
control point p
two clock cycles
knot vector is
nurbs surface the
function values the
cell in the
computation of the
this architecture is
the x coordinate
basis functions for
t i k
the input to
input to the
the inner product
every two clock
and their weights
of discrete values
u and v
in the figure
a b spline
particular value of
the architecture presented
control points in
the control point
computation of b
points and their
the first term
the curve the
number of discrete
required to generate
from the equation
points and the
in the rhs
the rhs of
x coordinate of
set of basis
one useful basis
k basis functions
pipeline of high
a nurbs curve
to the ac
basis function generation
function values for
basis function n
a nurbs surface
the term w
integration into the
is incremented and
compute nurbs surfaces
direction of u
highly suitable for
proposed by megson
graphics pipeline of
have non zero
control points n
value u is
to the bfea
kth order basis
standard graphics pipeline
incremented and the
non zero values
architecture to calculate
the weighted control
of k theta
megson s architecture
the standard graphics
of high end
to from host
the bfea as
calculate a nurbs
ffl the architecture
the useful basis
which have non
virtual control point
are only k
term gives the
suitable for integration
and surfaces is
n j l
curve control points
for integration into
grid of k
and its weights
function curves for
computes the virtual
to compute nurbs
a rational b
computation of uniform
the time required
the second term
n i 1
of the point
in the direction
coordinate of the
at its vertices
systolic architecture for
the figure 5
the valid range
every clock cycle
1 n i
points and its
be non zero

corpus/krapavin2000-test/629437.txt
load
balancing
transfer
particles
diffusion
percent
deltal
tasks
pic
particle
dsmc
locality
eff
balance
gde
computers
ogde
imbalance
diffusive
ffit
reactor
hb
diff
grid
transferred
neighbors
timestep
agde
paragon
plasma
routines
task
t3d
remapping
gec
lavg
errmax
thruster
cells
processors
transfers
workload
intel
vectors
concurrent
phases
balanced
efficiency
movement
hawk
scplib
transferring
pde
exchange
solver
field
cray
partition
repartitioning
dhb
partitions
metric
cell
err
library
mapped
const
underloaded
torus
mesh
metrics
disturbance
ode
facilities
comprised
calculate
calculated
phase
knapsack
loads
termination
runtime
move
kwok
scalable
dist
ffl
lowest
ideal
timestepping
changxun
rarefied
propulsion
ffil
powerchallenge
backflow
macroparticles
addendum
exchanges
quantities
256
heat
initiated
idle
ion
simulations
push
communication
workstations
fromone
bisection
options
meshes
mapping
silicon
scatter
exceeds
costly
synchronization
utilization
randal
million
neighboring
send
poor
selection
simulation
max
diffuse
tori
receive
overloaded
fairly
prediction
lap
physics
min
strategies
undertaken
unstructured
conducted
spectral
gradient
electromagnetic
zhong
balances
laboratory
irregular
accuracy
hl
cheung
color
adjusting
grids
heterogeneous
gather
institute
center
timing
unnecessary
potentials
efficacy
exhausted
distance
moved
iterative
outgoing
rigorous
continuum
cur
burns
asynchronous
converged
norm
closest
dimensional
exposing
extremal
communicating
location
scalar
preserve
thread
multicomputers
parametric
neighbor
remedy
threads
bars
adaptive
granularity
speedup
scalability
destinations
dramatically
converges
expect
evolves
dynamic
rel
load balancing
transfer vectors
the load
a task
transfer vector
the transfer
load balance
dynamic load
each computer
work transfer
of tasks
task selection
eff min
of load
the hb
two computers
vector algorithms
task s
the diffusion
load imbalance
computer to
total load
hb method
diffusion algorithm
balancing framework
the computers
to load
of work
the tasks
a load
a computer
percent more
pic code
computer i
the pic
balancing algorithm
communication locality
one would
neighbors j
to computers
intel paragon
of processors
lowest cost
timestep size
task movement
deltal i
the timestep
computer must
diff 1
phase two
the gde
the dsmc
field solve
balancing steps
scalable concurrent
total work
average distance
2 phase
load of
which tasks
after load
one computer
all neighbors
task i
balance the
balancing for
transfer of
percent of
transfer cost
balancing the
to deltal
balancing would
ogde diff
ffl max
imbalance exists
particle push
field solver
1 diff
processors ogde
global norm
load prediction
its transfer
same total
1 computer
computers have
cost metric
computers is
for load
the computation
the locality
grid cells
an intel
cray t3d
overall efficiency
each task
tasks to
a computation
phase one
load evaluation
balancing problem
achieve load
algorithms transferred
balancing to
programming library
efficiency of
and distributed
parallel and
workload of
task mapping
the scalable
efficiency was
would expect
the field
concurrent programming
been calculated
the particles
tasks will
cost of
c l
load distribution
an efficiency
l i
one can
the grid
n i
simulation of
subset sum
hb algorithm
task transfer
scatter to
processors percent
both computers
the gec
dimensional exchange
static mapping
ion thruster
balancing system
computer 2
percent this
256 processors
the agde
gec reactor
by deltal
communication list
global load
new load
particles contained
hierarchical balancing
every computer
gradient model
tasks transferred
gde algorithm
sum problem
dsmc code
diffusion algorithms
gde method
lavg eff
balancing was
ode s
various transfer
load as
mapping of
j 2
be initiated
reduced the
authors of
a transfer
the cost
of computers
is comprised
particles that
percent utilization
varying numbers
locality was
diff 2
50 percent
ideal location
based load
communicating tasks
computer 1
be transferred
termination condition
phase 1
its neighbors
load is
computers in
of grid
a partition
computing v
prediction model
application if
gather scatter
options in
i receive
two large
balancing strategies
computation was
local load
computer has
l max
dynamic load balancing
the load balancing
of a task
of load balancing
a task s
transfer vector algorithms
load balancing framework
j 2 n
2 n i
load balancing algorithm
the hb method
neighbors j 2
all neighbors j
total work transfer
amount of work
to load balance
computer to another
of the transfer
the total load
of the hb
the pic code
the timestep size
load balancing steps
a load imbalance
cost of load
the transfer vectors
a load balancing
the lowest cost
after load balancing
of the tasks
load balancing for
load of a
parallel and distributed
an intel paragon
the same total
the overall efficiency
scalable concurrent programming
ogde diff 1
diff 1 diff
load imbalance exists
work transfer vectors
the scalable concurrent
task s state
load balancing would
the transfer vector
processors ogde diff
of processors ogde
the load of
number of processors
one would expect
a task is
load balancing to
load balancing problem
from one computer
to achieve load
achieve load balance
the work transfer
an efficiency of
one computer to
number of tasks
set of tasks
of the load
the transfer of
load as a
load balancing the
of an intel
for load balancing
of the grid
of parallel and
distributed computing v
the cost of
journal of parallel
of a computation
of the computers
percent more work
scatter to obtain
load prediction model
concurrent programming library
authors of 24
of processors percent
to load balancing
based load balancing
gather scatter to
from all neighbors
the hb algorithm
a computer must
percent more for
tasks to computers
1 computer 2
average distance between
of tasks will
deltal i j
the gde algorithm
c l n
determine which tasks
transfer vectors are
load balancing was
mapping of tasks
of the pic
satisfy its transfer
and after load
256 processors of
n i receive
computer 1 computer
lavg eff min
the field solver
its new load
of its data
an application if
the subset sum
to dynamic load
subset sum problem
computer 2 phase
load balancing system
at each computer
processors percent utilization
its transfer vectors
2 phase 1
to two large
various transfer vector
set of computers
task selection is
total load is
the authors of
and distributed computing
of an application
the mapping of
of a computer
the simulation of
is comprised of
two large scale
of grid cells
same total load
to all neighbors
number of load
for dynamic load
number of particles
the computation was
varying numbers of
i to all
2 phase 2
percent of the
task i is
applied to two
phase 2 phase
load balancing strategies
its data structures
that a load
d dimensional mesh
and execution times
processors of an
if the load
would expect that
of tasks to
efficiency of a
the computation this
comprised of a
of the computation
for a particular
computing v 64
numbers of processors
the average distance
the change in
a d dimensional
it may be
the case of
location of a
1 diff 20
maintain an efficiency
to 256 processors
transfer number of
better not to
a roughly equal
transfer left and
case a task
computation this fact
to be inferior
between communicating tasks
of two computers
of ideal speedup
balance the computation
the two computers
to guide task
which tasks should
of o ffit
cannot be divided
the hierarchical balancing
between two computers
or improve communication
transfer vector between
termination condition based
for varying numbers
purpose load balancing
between neighboring computers
reduced the transfer
each computer having
each partition the
with 10 tasks
the maximum such
would calculate the

corpus/krapavin2000-test/629439.txt
dilation
packings
packing
hypercubes
sized
star
embedding
embeddings
hypercube
alg
packed
expansion
submeshes
asymmetric
kmax
avr
2c
kmin
gamma
dimension
embed
theor
h2hi
pack
links
nigam
bn
load
gammat
template
asym
dimensions
embeds
symmetrically
ratios
mesh
width
embedded
lfloor
rfloor
copies
sec
slices
int
disjoint
dim
submesh
sym
symmetric
odd
compose
cube
union
discarded
dings
dimensionality
expan
subsec
partitioning
aver
grouping
produced
krishnamurthy
image
mapped
induced
hyper
graphs
sahni
guest
congestion
connecting
produces
interconnection
asymmetry
link
eq
depicts
hierarchically
usable
base
144
migration
allocation
log_2
particularity
tearing
nacional
rically
010011110010110124
conselho
reassigning
log_2n
repertory
spaceand
desenvolvimento
ranka
200392
dil
blog
bel
dimensional
metrics
mapping
viewpoint
origin
cdot
asymmet
1010
packs
sional
subsecs
referred
permutations
node
labeled
devised
listed
var
048
hamiltonians
cayley
featuring
supercomput
diameter
characterizes
formed
subsection
628
sacrifice
coordinates
largest
relabel
8n
intermediary
mult
omitted
average
host
denser
pioneered
temp
72
ranging
growing
accordingly
theta
symmetry
nodes
utilization
quantities
ding
576
slowdown
label
sorting
strings
assures
nk
accommodating
struc
fft
attractive
264
copy
pseudocode
discards
secs
producing
discusses
slow
unused
lists
terminology
tasks
compound
ture
contrasts
fig
arrangement
abstractwe
employ
nc
reader
46
configured
132
dist
characterize
labels
popularity
cubes
th
background
ultimate
slice
workloads
paths
achieves
800
variable dilation
n gamma
into s
s n
q k
dilation embeddings
gamma 1
sized packings
star graph
sized packing
average dilation
multiple sized
of q
q n
dilation embedding
hypercubes into
fixed sized
load 1
h n
the star
with load
disjoint union
expansion ratios
base dilation
packing p
g k
links of
m n
dilation d
star graphs
dilation 3
p f
embedding of
gamma t
packing techniques
template packings
odd sized
d avr
d base
bn 2c
k into
p m
alg 2
embeddings of
dilation of
asymmetric packings
packed q
into star
and expansion
a packing
packings of
n gammat
alg 1
an asymmetric
the disjoint
embedded into
which embeds
expansion 1
packings in
embedded with
our packings
gammat h2hi
small expansion
hypercube dimensions
sized dimensions
use dim
1 2c
embedding techniques
packed into
the dilation
u into
embeds the
dilation 1
k s
k b
be embedded
packing of
hypercubes are
to pack
dimension i
dimension links
w dilation
avr w
largest hypercube
symmetric fixed
our multiple
our variable
dilation vector
discarded submeshes
asymmetric fixed
and dilation
copies of
n with
th dimension
of hypercubes
dilation 4
are packed
the expansion
produced by
of width
and base
dimensions of
base p
of m
our techniques
into m
expansion of
the packing
b n
n 10
of g
an embedding
sec 2
n which
k kmin
a links
dimensional star
union u
asym q
hypercubes q
packings are
sym q
q kmax
symmetric packings
symmetrically packed
pack q
our packing
partitioning process
of theor
packing hypercubes
induced submeshes
low expansion
node allocation
theor 1
embedded hypercubes
packing if
packings as
the embedding
link of
a disjoint
slices of
space constraints
e u
we denote
of e
k many
mapping algorithm
embedding hypercubes
dimension b
hypercube that
along dimension
2 along
gamma 2
in sec
a dimension
which produces
into v
of hypercube
into paths
dilation and
1 along
q 4
by grouping
1 s
omitted due
dimension a
a variable
7 h
into h
packing and
of into
with dilation
by p
the hypercube
many copies
dimensional hypercube
labeled with
sec 4
f int
to space
k a
b into
the copies
of embedding
v h
of h
j k
if use
cases 8
embed dings
or kmin
produce dilation
by nigam
pack hypercubes
pack p
left lfloor
packings i
define theorem
resulting packing
asymmetric template
into s n
n gamma 1
m n gamma
q n gamma
variable dilation embeddings
variable dilation embedding
of q k
the star graph
of q n
with load 1
multiple sized packings
s n with
fixed sized packing
of m n
n gamma t
embedding of q
q k s
a variable dilation
fixed sized packings
load 1 and
n with load
the disjoint union
base dilation 3
embeds the disjoint
hypercubes into star
q k into
multiple sized packing
into star graphs
of s n
gamma 1 s
which embeds the
can be embedded
s n which
copies of q
h n and
embedded into s
s of q
and base dilation
n gammat h2hi
sized packing p
dilation embedding of
embeddings of q
of h n
of g k
slices of width
the largest hypercube
dimensions of m
the average dilation
d base p
packing of q
d avr w
symmetric fixed sized
be embedded with
1 and base
dilation d base
links of q
odd sized dimensions
k into s
q k b
our multiple sized
our variable dilation
dilation embedding techniques
asymmetric fixed sized
of hypercubes into
of e u
which we denote
in s n
are packed into
gamma 1 m
i th dimension
space constraints the
a disjoint union
s n the
the expansion of
p f and
be embedded into
gamma t into
into h n
hypercubes into the
into an n
nodes of m
of theor 1
hypercubes q k
links of e
our packing techniques
paths of h
dilation and expansion
gamma 1 with
p f n
hypercubes are packed
packing p f
hypercubes into s
a packing p
1 into s
and expansion 1
a symmetric fixed
gamma 1 2c
average dilation of
7 h n
k n gamma
packing hypercubes into
b into s
constraints the interested
an asymmetric fixed
embedding hypercubes into
gamma 1 into
packings in this
k b into
dimension a links
into paths of
packed q k
s n can
u into s
n dimensional star
k many copies
average dilation d
sized packings in
f n gammat
into v h
and multiple sized
p f which
proof of theor
sym q n
dimensional star graph
dimension links of
into the star
f which embeds
asym q n
dilation d avr
dilation 3 for
disjoint union u
mapping of v
largest hypercube that
sized packing of
hypercube that can
3 and expansion
of variable dilation
v h n
to space constraints
in m n
and of e
9 for a
dilation 3 and
b n gamma
along dimension i
n and of
into m n
to 9 for
n which we
of q 4
n gamma 2
referred to 9
comparison with related
the dilation of
denote the largest
is an asymmetric
many copies of
subsection we present
omitted due to
interested reader is
of the star
due to space
gamma 1 and
denote by p
disjoint union of
of f is
an n dimensional
an embedding of
is referred to
we denote the
we denote by
with related work
a mapping of
for the cases
for a proof
dimension i link
f int i
for 4 n
upper limit k
packings and embeddings
i link of
the expansion ratios
pack q n
characterizes a symmetric
25 and dilation
sec 4 presents
size 2 theta
by alg 2
of width 1
dimension b links
sized dimension if
3 embedding of
union u into
devised for the
asymmetric multiple sized
packing p m
t into s
q n 2
for even i
node of h

corpus/krapavin2000-test/629443.txt
scheduling
tasks
myopic
parallelizable
schedule
parallelization
deadlines
resource
backtracks
feasibility
schedulability
deadline
usep
success
split
task
preemptive
multiprocessor
window
sharep
laxities
scheduler
earliest
fig
num
feasible
laxity
processors
dispatch
max
btrk
est
heuristic
reclaiming
scheduled
parallelized
exclusive
oeae
manimaran
partitionable
2e
processor
ratio
2c
simulation
queues
met
vertex
aperiodic
edf
mode
meeting
siva
offered
sc
arriving
figs
parallelism
eat
murthy
2a
dynamically
backtracking
queue
schedulable
usage
precedence
fixing
2b
meet
integrated
arrive
centralized
studies
qin
multiprocessors
strongly
resources
arm
ready
sublinear
overloading
sensitivity
imprecise
speedup
arrival
behaves
requirements
xiao
check
degree
till
parallelizing
shared
shashidhar
merugu
omari
defago
t2t
ecutes
manikutty
paramter
weightage
parm
nonparallelizable
jeopardizing
alghamdi
somani
utilization
2d
robot
dynamics
predictable
periodic
availability
tighter
conflicting
trend
1137
yeon
preemptable
1152
avionic
t11
inoguchi
629
t13
sublinearity
evaluations
ahead
exclusion
permitted
overhead
degrees
finish
nonpreemptive
parallelizes
reschedule
academy
1324
nuclear
1315
checked
infeasible
ram
wireless
tries
schedules
yuanyuan
ignorant
anand
arcs
hong
worst
upto
648
avail
saturates
feasibly
abstractmany
yasushi
indian
quebec
executing
commack
nova
dispatched
8a
plant
885
comma
xavier
varying
executions
exploits
backup
requested
achieving
reliability
11th
arun
spending
8b
dynamic
timing
mohammed
sung
subtasks
montreal
backtrack
portion
res
tightness
jiang
basics
uniprocessor
jong
termination
xie
completion
max split
success ratio
task scheduling
parallelizable task
feasibility check
check window
scheduling algorithm
a task
myopic algorithm
real time
task t
of parallelization
the myopic
task parallelization
dynamic scheduling
of backtracks
of tasks
of task
tasks are
task set
of max
feasible schedule
the tasks
the schedule
tasks in
the success
scheduling cost
the task
dispatch queues
t 13
their deadlines
resource requirements
time systems
t i
the parallelizable
simulation studies
the feasibility
time tasks
in fig
schedulability of
task sets
k tasks
fig 2c
est t
integrated heuristic
strongly feasible
schedule is
the resource
for scheduling
multiprocessor systems
the scheduler
computation time
tasks with
case computation
t 11
scheduling of
the schedulability
search tree
of resource
num btrk
earliest available
window k
split tasks
laxity parameter
task queue
partial schedule
ratio offered
scheduled on
shared mode
deadlines and
resource usage
resource constraints
tasks on
parallelization is
scheduling algorithms
parallelization of
multiprocessor real
resource reclaiming
preemptive algorithm
always higher
effect of
degree of
of feasibility
computation times
time task
parallelized and
available time
the deadline
task is
among tasks
a preemptive
fig 2e
ready time
split 1
tasks arrive
fig 2d
of myopic
dynamically arriving
for feasibility
and sharep
g manimaran
num split
parameter fig
for multiprocessor
fig 2a
a feasible
heuristic which
taken as
non preemptive
meet their
the earliest
the search
task s
split are
non parallelizable
current task
h value
current schedule
figs 4
window fig
scheduling problem
to meet
the scheduling
in real
proposed algorithm
tasks is
exclusive mode
and scheduled
task model
in tasks
constraints among
algorithms 8
schedule by
on success
offered by
each task
scheduling in
tasks to
the dispatch
s deadline
new tasks
mode at
earliest time
schedule for
of number
ratio for
be met
algorithm for
processors and
checked for
by max
time multiprocessor
with increasing
and resource
values of
for shared
time of
different values
ffl let
fig 2b
for simulation
algorithm is
parallelism in
time scheduling
lower values
resource is
tasks have
feasible in
its deadline
with resource
requirements of
of processors
tasks of
by fixing
tasks taken
scheduling t
best task
both preemptive
next best
max c
constrained tasks
split then
ratio by
b extend
w parameter
k size
heuristic function
edf which
reclaiming from
arriving tasks
algorithm backtracks
which feasibility
meeting deadlines
higher scheduling
exploits parallelism
schedule from
split 4
high schedulability
scheduling considered
feasible is
parallelizable task scheduling
feasibility check window
the success ratio
of max split
values of max
task scheduling algorithm
degree of parallelization
the myopic algorithm
of a task
task t i
the feasibility check
number of backtracks
scheduling algorithm for
the parallelizable task
of parallelization of
real time systems
dynamic scheduling algorithm
real time tasks
all the tasks
est t i
worst case computation
task parallelization is
a feasible schedule
the search tree
of the feasibility
of resource usage
a task t
parallelization of a
check window k
of task parallelization
of feasibility check
success ratio offered
a preemptive algorithm
case computation time
size of feasibility
success ratio for
ratio offered by
schedulability of a
always higher than
meet their deadlines
of a preemptive
multiprocessor real time
algorithm is always
is always higher
in real time
the schedulability of
real time task
the simulation studies
to meet their
the task set
for different values
a task is
earliest available time
of myopic algorithm
the current task
the integrated heuristic
mode at time
the dispatch queues
algorithm for scheduling
effect of w
parallelization is more
tasks in real
increases the success
offered by max
tasks of a
parallelism in tasks
success ratio is
of task sets
and scheduled on
the task t
scheduling in real
the scheduling cost
max split are
check window fig
in fig 2c
resource constraints among
figs 4 8
parallelized and scheduled
on success ratio
by max split
max split 1
is strongly feasible
checked for feasibility
constraints among tasks
available for shared
available time of
schedule is extended
a partial schedule
tasks in the
that the task
number of tasks
of the myopic
in a task
and resource requirements
feasible schedule for
time multiprocessor systems
the proposed algorithm
different values of
given in fig
in fig 2a
the tasks in
scheduling algorithm is
the schedule is
task s deadline
of number of
the earliest time
proposed algorithm is
time tasks on
scheduling algorithm the
real time multiprocessor
in the schedule
is extended by
effect of resource
that the success
lower values of
of the task
real time scheduling
the tasks are
of the search
maximum degree of
computation time of
t i for
a simple heuristic
t i is
set of tasks
for real time
in 8 the
is more effective
hard real time
extensive simulation studies
however the higher
is the earliest
satisfy such requirements
set given in
schedule by the
infeasible due to
a parallelizable task
of tasks taken
algorithm behaves like
search tree specific
search tree constructed
robot arm dynamics
in tasks to
the conflicting requirements
conducted extensive simulation
dynamically arriving real
num btrk and
look ahead nature
are feasible in
myopic scheduling algorithm
task set given
variety of task
effect of number
tasks are less
uses a resource
for shared mode
preemptive version however
scheduling overhead parallelizable
k tasks where
becomes available for
schedule is strongly
preemptive algorithm is
as est t
of tasks checked
algorithms 8 9
achieving high resource
laxity parameter fig
success size of
split maximum degree
computation times of
feasibility check has
access in which
an intermediate solution
availability of processors
for parallelizable task
tasks taken as
intermediate solution which
version however the
non preemptive algorithms
for which feasibility
like the myopic
exploits parallelism in
earliest time when
higher scheduling overhead
literature to satisfy
myopic algorithm fig
5 effect of
and achieving high
high schedulability and
max split maximum
overhead parallelizable task
simulation studies show
tasks checked for
preemptive algorithm has
times of tasks
first k tasks
arcs correspond to
such requirements the
resource utilization are
performing feasibility check

corpus/krapavin2000-test/629444.txt
supernode
supernodes
hyperplanes
grain
schedule
tiling
ct
shape
dependence
startup
parallelepiped
koziris
nectarios
transformation
partitioning
athanasaki
phases
transferred
dependences
lengths
loops
communication
georgios
matrix
hyperplane
tile
processors
running
sotiropoulos
goumas
processor
nested
index
vectors
iteration
tiled
volume
maria
iterations
loop
nests
cone
fronts
aristidis
tsoukalas
luce
transmission
square
discusses
message
transformations
tsanakas
drosinos
panayiotis
cutting
smps
extreme
nikolaos
nonlinear
pipelined
penalty
theta
hypercube
systolic
hd
comm
grouping
scheduling
doubly
oe
wave
closed
comp
939
jingling
rajopadhye
disp
rashmi
hyperrectangular
95008
1220
dharma
balev
papakonstantinou
200ms
hodzic
multicom
wentong
hyperrectangles
andonov
campbell
lsgp
yanev
edin
1138
planes
vector
hyper
affine
boothe
weijia
1151
startups
dimensionalities
clare
abstractwith
nitions
professorship
9502889
1233
convex
sides
minimized
media
multiprocessors
bajaj
crete
triolet
hal
sliced
1315
supercomputing
spaces
schedules
messages
ramanujam
dencies
defi
respected
gamma1g
sadayappan
irigoin
gt
peizong
transputer
xue
915
732
doacross
rectangular
multidimensional
side
711
henry
zvi
supercompilers
pen
dell
mapped
families
uniform
depen
jersey
oblique
kedem
island
955
941
greece
grouped
sizes
columns
shang
puters
nicosia
collinear
thirteenth
reasonably
transmitted
transformed
phase
interdependent
assistant
meir
lemmas
neighboring
subtasks
equidistant
298
alternates
analytical
formulation
modeled
226
ave
integral
rank
cai
cyprus
baltimore
minimizing
approximated
dependencies
initiation
197
305
orthogonal
normal
299
bg
the supernode
supernode size
supernode transformation
total running
a supernode
grain size
optimal supernode
linear schedule
index space
running time
optimal grain
length vector
the optimal
side lengths
supernode index
iteration index
relative side
supernode shape
dependence matrix
supernode relative
dependence vectors
different supernode
parameter model
relative length
parameter communication
optimal linear
one parameter
and shape
d s
supernode is
partitioning hyperplanes
and supernode
supernode sizes
size and
an optimal
j s
two parameter
supernode transformations
schedule vector
optimal relative
size g
computation phases
parallelepiped supernode
supernodes are
communication model
h r
the total
communication time
algorithm j
of supernode
communication phases
nectarios koziris
the parallelepiped
nested loops
side length
be transferred
j d
startup penalty
two supernode
transformation h
matrix h
matrix d
vector r
closed form
supernode partitioning
one supernode
maria athanasaki
square supernode
startup cost
communication startup
communication cost
g o
the grain
of dependence
the communication
the iteration
r g
index set
the startup
time is
bounded loop
supernode the
resulting supernode
n partitioning
nonlinear program
supernode grain
lengths of
memory parallel
s d
communication phase
iteration space
data to
iterations in
size for
supernode and
consider algorithm
transformed algorithm
for supernode
optimal shape
supernode side
hyperplane matrix
ct s
of supernodes
dimensional algorithm
convex cone
constant bounded
ct ct
l processors
space j
g r
distributed memory
single processor
shape of
processors time
tile size
form expression
all dependence
find an
theta theta
h and
transformation is
transformation with
penalty and
to find
of finding
with uniform
v g
communication volume
schedule length
by matrix
cost is
computation time
for different
of phases
phases and
loop nests
set j
size only
shape the
find the
the n
of data
the amount
discusses how
of communication
2002 maria
scheduling length
dependences 12
each supernode
that supernode
size shape
supernodes in
independent supernodes
components depend
four iterations
affine function
g ct
wave fronts
supernodes the
with doubly
changes lemma
schedule wave
containing four
loops onto
as supernode
the supernodes
loops a
by h
model with
normal vectors
a square
amount of
the linear
nested loop
a message
comm in
real positive
to square
and square
12 such
optimal tile
startup time
sotiropoulos georgios
hyperplanes to
athanasaki aristidis
tiled nested
parallelepiped supernodes
georgios goumas
tsoukalas nectarios
drosinos maria
athanasaki nectarios
uniform dependence
square containing
on supernode
parameters h
extreme vectors
supernode volume
aristidis sotiropoulos
constant communication
algorithm problems
total running time
the total running
optimal grain size
the optimal supernode
optimal supernode size
a supernode transformation
the optimal grain
of a supernode
size and shape
the supernode size
iteration index space
grain size and
supernode size and
how to find
optimal linear schedule
parameter communication model
relative length vector
the supernode index
running time is
for different supernode
the one parameter
supernode index space
the iteration index
j s d
the linear schedule
h r g
side length vector
amount of data
to be transferred
find the optimal
side lengths of
the parallelepiped supernode
transformation h r
of data to
s d s
data to be
relative side length
supernode transformation h
length vector r
of the supernode
different supernode sizes
one parameter model
optimal relative length
parameter model with
length vector is
grain size g
one parameter communication
communication cost is
for the optimal
find an optimal
the grain size
the optimal relative
of supernode transformation
the two parameter
an optimal supernode
linear schedule vector
communication startup cost
relative side lengths
matrix d s
dependence matrix d
index space and
supernode relative side
algorithm j d
supernode transformation is
supernode size for
distributed memory parallel
an optimal linear
h and r
number of communication
problem of finding
square supernode shape
two parameter model
two parameter communication
two supernode transformations
v g r
and j s
an optimal grain
the resulting supernode
l processors time
lengths of a
supernode index set
the startup penalty
constant bounded loop
supernode size only
and shape of
startup penalty and
j s is
to find an
to find the
for the one
running time a
the dependence matrix
all dependence vectors
of dependence vectors
dependence vectors in
discusses how to
a communication phase
of the parallelepiped
by matrix h
model with constant
the supernode transformation
supernode is a
a linear schedule
optimal supernode shape
computation phases and
of communication phases
the communication startup
j d where
single processor in
optimal supernode relative
supernode transformation with
on the supernode
a single processor
a closed form
index set j
closed form expression
finding an optimal
in a communication
form expression for
time for different
and the optimal
the amount of
number of phases
expression for the
2 the optimal
of iterations in
to the optimal
is a square
memory parallel computer
processor in a
shape of a
d 2 d
that the total
the number of
of minimizing the
d s can
nested loops a
g g o
linear schedule wave
set with g
by a grain
an affine function
model communication cost
supernode transformation applied
square containing four
bounded loop iteration
shape the total
supernode grain size
schedule wave fronts
for two supernode
the supernode grain
affine function of
supernode size changes
supernode size g
resulting supernode is
index space with
components of dependence
a grain size
a square containing
vectors d 2
shape or close
be the supernode
parameter model and
the convex cone
size g and
change as supernode
components depend on
with doubly nested
the optimal shape
changes lemma 3
supernode shape or
and supernode shape
and shape when
for general cases
cost is modeled
the supernodes are
and square supernode
size and supernode
after the supernode
algorithm in example
a supernode relative
t comm in
should be contained
also provided for
and dependence matrix
h g r
grain size for
n partitioning hyperplanes
the scheduling length
supernode size is
communication time t
a supernode the
dependences 12 such
close to square
both the supernode
and the supernodes
constant communication time
supernode the supernode
supernode relative length
partitioning hyperplanes to

corpus/krapavin2000-test/629452.txt
routing
destination
gedir
wireless
hop
hcb
energy
swr
power
localized
ad
consumption
hoc
mfr
dir
neighbors
delivery
lifetime
packet
sensor
sp
transmission
neighbor
message
rm
bd
route
networks
mobile
stojmenovic
shortest
node
sl
radio
metrics
nfp
power1
ct2
ivan
sd
nc
gps
neighboring
compass
loop
battery
ct1
nearest
progress
aware
networking
success
dies
metric
mobility
transmissions
location
protocols
elec
counts
routes
boca
raton
minpower
bcsw
transmit
closer
sb
flooding
sa
bmsu
nodes
rounded
bs
forwarding
sender
kv
multihop
ietf
crc
consumed
ts
reception
geographic
savings
toward
holding
rates
forward
count
3619
guaranty
sppower
maxpow
rodoplu
minpow
eghk
clusterhead
bmjhj
batteries
minimize
proactive
retransmissions
traffic
greedy
network
tv
hops
source
hosts
dijkstra
send
greatest
closest
saving
sending
ksu
expends
prasant
reluctance
healing
tassiulas
mohapatra
finn
mc
demand
distance
decisions
hoping
plenty
memorizing
minimizes
adjusted
packets
pc
trial
weighted
amp
865
forwarded
ax
selects
path
sensors
bellman
sleep
conserving
radii
662
ford
quorum
ticket
radius
shall
handbook
press
chao
rate
ar
hl
awareness
674
gui
reached
graphs
formulas
rt
nk
aimed
retransmission
delivered
transmitting
sends
monitoring
superiority
obstacles
signal
variant
experimentally
occasional
meng
positioning
sides
failure
communicated
cn
jie
variations
failed
drops
spaced
update
lin
yu
alpha
2e
inc
solely
ac
hopefully
power cost
routing algorithm
routing algorithms
ad hoc
power consumption
wireless networks
efficient routing
loop free
power efficient
power needed
and power
u r
node a
sp power
the power
of power
hoc networks
sensor networks
hop counts
in wireless
cost methods
localized routing
hcb model
power aware
a 1
routing in
a n
f a
ad a
shortest weighted
cost efficient
the packet
of routing
success rate
destination is
hoc wireless
2 hop
the destination
the message
energy consumption
path algorithm
cost and
d ad
currently holding
ivan stojmenovic
routing task
non localized
cost routing
direct transmission
and destination
destination d
weighted path
the energy
neighbor of
u d
of destination
mobile ad
neighboring nodes
in ad
to d
routing protocols
hop count
each node
power method
routing decisions
transmission power
random progress
power savings
delivery rates
localized power
aware routing
remaining power
ts r
compass routing
rm model
gps based
wireless ad
for wireless
c a
node b
consumption in
wireless sensor
a neighbor
neighboring node
hoc networking
a u
is u
a f
the routing
location update
3 8
to destination
destination the
networks proceedings
to forward
routing tasks
a ts
sp cost
or dir
cost method
is loop
per routing
nfp method
total power
e elec
aware metrics
bd c
unit graphs
power saving
cost b
best choice
message to
power at
neighbors and
needed for
packet is
update scheme
a bd
based routing
pc b
networks mobile
localized algorithms
consumption for
v s
8 3
b a
control messages
the cost
nodes can
intermediate node
to nearest
nearest integer
rounded to
energy per
will minimize
are loop
source and
the network
location of
a routing
holding the
algorithm is
distance between
destination node
of neighbors
to transmit
the localized
total energy
if nodes
shortest path
forward the
its neighbors
a is
of ad
d a
the location
the success
a 2
1 a
our experiments
routing techniques
minimal power
s ad
networks crc
radio model
cost algorithms
proposed localized
in sl
energy consumed
consumption metric
method dies
tv s
hcb and
raton fl
power formula
ad bd
low success
r tv
consumption may
boca raton
increased energy
power only
delivery rate
adjusted transmissions
for hcb
be neighbor
past traffic
inc boca
bcsw kv
previous node
progress method
localized cost
power adjusted
in swr
minimize p
crc press
dir routing
demand based
cost iii
mfr and
and power cost
the power needed
efficient routing algorithm
cost and power
routing algorithm is
ad hoc networks
a u r
power efficient routing
power needed for
neighbor of b
sp power cost
shortest weighted path
power cost methods
ad hoc wireless
in wireless networks
hoc wireless networks
in ad hoc
a f a
u d ad
mobile ad hoc
is u d
routing in wireless
a 1 a
wireless sensor networks
wireless ad hoc
8 3 8
currently holding the
weighted path algorithm
power cost and
forward the message
d ad a
a 1 2
c a 1
the destination is
a n 1
the power consumption
power consumption in
3 8 3
ad hoc networking
message to a
networks proceedings of
b a f
2 1 a
in the network
location update scheme
power cost routing
power cost efficient
f a ts
algorithms are loop
neighboring node a
cost routing algorithms
power cost b
algorithm is loop
power aware metrics
cost efficient routing
rounded to nearest
routing algorithms are
a ts r
power consumption for
are loop free
properties of power
sizes of m
is loop free
localized power efficient
power needed to
until the destination
closer to destination
cost b a
a 2 a
a neighbor of
the message to
1 a 1
2 a n
1 g a
pc b a
c a f
to forward the
success rate for
t f a
f a u
nodes can be
1 2 1
the success rate
acm international symposium
routing in ad
the location of
will be referred
each node is
d a c
is a neighbor
at distance d
the previous node
follows repeat let
wireless networks crc
techniques for mobile
r tv s
per routing task
as the sp
of power adjusted
localized routing algorithm
b that minimizes
networks the handbook
localized routing algorithms
choice of neighbors
c a of
u r tv
to a until
battery power at
routing techniques for
direct transmission is
p b a
destination is reached
a 1 c
handbook of ad
networks crc press
power aware routing
delivery in wireless
power adjusted transmissions
for direct transmission
to nearest integer
location of their
hcb and rm
boca raton fl
the cost c
a bd c
reached if possible
minimizes pc b
neighbors and destination
networks and applications
power cost method
energy consumption may
the power cost
a be neighbor
if d c
crc press inc
d is u
power consumption metric
low success rate
power and cost
g a where
increased energy consumption
the node a
press inc boca
random progress method
where g a
power cost algorithms
intermediate node a
total power needed
that minimizes pc
aware routing algorithm
needed for direct
routing algorithm may
inc boca raton
be neighbor of
for hcb model
the total power
networks mobile networks
repeat let a
cost c a
1 a n
in wireless sensor
in our experiments
at each node
from b to
source and destination
algorithm may be
1 a 2
a a 1
the best choice
a and b
symposium on mobile
large m the
proceeds until the
and routing algorithms
applications v 10
as follows repeat
guaranteed delivery in
reached or a
algorithm proceeds until
power consumption of
of sending message
message is to
for wireless networks
hoc networking and
holding the message
on mobile ad
b a u
a to d
a 1 g
the handbook of
with guaranteed delivery
a where g
minimize the total
d c a
of ad hoc
in case of
values of m
is reached if
of their neighbors
hoc and sensor

corpus/krapavin2000-test/629472.txt
coord
cubefulldist
fulldist
stability
hypercube
coordinator
protocol
messages
info
rtt
round
message
multicast
hypercubes
protocols
s_coord
ack
node
failures
neighbors
array
multicasts
logical
hop
arraymin
receive
topology
scalability
count
hm
detection
reliable
received
queue
receives
incomplete
load
fault
tolerant
goto
stable
hypercast
middlewares
topologies
sent
nodes
network
ensemble
arrays
receiving
cube
bitmap
sg
pseudo
maintains
periodically
gossiping
iteration
ms
label
ids
heard
recipients
hy
scalable
rmtp
zooms
fifo
children
hops
regularity
links
log
faulty
totem
horus
endif
physical
sends
ring
connections
toolkits
transis
parent
diameter
discarded
superimposed
delivery
member
wise
simulations
embed
routing
tolerance
disseminate
isis
multicasting
delta
yes
tree
missing
wait
loaded
superimposing
root
goals
detect
802
rounds
everyone
initialization
queues
buffers
replies
weakening
reflected
bottlenecks
detecting
bytes
dissemination
communicates
guo
preceded
rings
peer
collisions
sending
indices
transport
randomly
19ms
relacs
fwjw
024
jsg
percast
heartbeats
jitters
180010305070last
topolo
percube
refraining
46ms
110x
10xx
percubes
82ms
iterations
fan
cubes
row
hardly
analytical
connection
unreliable
advance
travel
bus
1900
16ms
advisable
ordinator
rebuilt
pinwheel
mpp
100mbps
lookup
finished
imposed
buffer
400
indication
indexes
delivered
communication
srm
fitness
tailoring
subscribe
underlining
send
counted
seconds
matrix
infrastructure
faults
piggybacking
topol
gt
mishra
sustain
employ
sensitivity
fully
medium
bit
labels
worst
traverse
cristian
stability detection
s coord
node i
logical hypercube
receive from
detection protocols
the coordinator
sequence number
info message
each node
reliable multicast
coord and
message count
network load
the protocol
of nodes
hop count
a stability
cubefulldist coord
incomplete hypercube
stability information
coord fulldist
of messages
based protocol
detection protocol
from i
protocol round
r i
the stability
log n
in cubefulldist
message stability
fulldist s_coord
in coord
maximum queue
an info
i maintains
m i
node k
coord protocol
cubefulldist is
hypercube structure
hypercube based
number array
cubefulldist the
incomplete hypercubes
node j
from node
o n
received by
array r
every node
all messages
goto step
system size
network topology
n messages
first node
array s
the logical
fully distributed
with sequence
label all
on cubefulldist
coord the
and cubefulldist
sg z
fulldist protocol
a logical
each round
last message
upon receiving
of node
messages received
current round
iteration number
as stable
average network
the hypercube
fault tolerant
queue length
number p
queue size
received from
its neighbors
distributed protocol
group communication
by node
the message
physical topology
than cubefulldist
become stable
input arrays
cubefulldist performance
receives o
in hm
stability array
stability messages
ack messages
coordinator receives
coord is
member rtt
messages cubefulldist
in fulldist
stability message
round r
tree based
the network
all nodes
node sends
the rtt
round number
an incomplete
a protocol
g i
failures on
messages from
pseudo code
load is
logical neighbors
ack r
increases r
node failures
nodes number
protocol in
the tree
message received
from all
links in
the info
element wise
last node
receives an
its logical
of logical
i n
the system
protocol messages
physical network
node 0
protocol that
round ffl
info messages
notice difference
hypercube approach
fulldist the
receiving ack
m cube
its matrix
5 failures
logical hypercubes
code line
until receive
multicasts an
fulldist and
cubefulldist protocol
of coord
s_coord figure
hypercubes to
between first
3 failures
node rtt
start message
messages node
containing array
receiving info
failures 4
stability g
failures failures
of fulldist
1 coord
arraymin element
info s
worst result
s stability
4 failures
coordinator based
whose j
max queue
i multicasts
array stability
i has
from every
from k
current iteration
network topologies
node in
the pseudo
g z
that receives
line 1
n o
minimum of
a round
scalability of
based protocols
count and
j th
messages were
failures 5
stability detection protocols
receive from i
number of messages
the stability detection
stability detection protocol
number of nodes
of the protocol
each node i
node i maintains
the logical hypercube
an info message
cubefulldist coord fulldist
coord fulldist s_coord
a logical hypercube
the sequence number
from i 0
from node j
sequence number array
a protocol round
with sequence number
logical hypercube structure
label all messages
array r i
sequence number p
in s coord
sequence number of
messages received from
all messages received
received from every
fully distributed protocol
an incomplete hypercube
every node k
k with sequence
maximum queue size
receive from k
i n m
node k with
average network load
messages from all
a fully distributed
received by node
k as stable
number p s
node i has
the last message
the current round
of system size
i maintains the
of node i
function of system
from every node
tree based protocol
of messages cubefulldist
its logical neighbors
receives o n
the coordinator receives
a stability detection
on cubefulldist performance
round of the
s coord and
the maximum queue
of nodes number
from all nodes
and last node
the average network
and s coord
the input arrays
in cubefulldist the
logical hypercube based
maintains the following
is the sequence
all its neighbors
number of the
i from node
nodes number of
last message received
node i from
matrix m i
each node sends
of each round
message received by
the pseudo code
s i k
in round r
by node i
protocol in figure
o n messages
r i to
hop count and
in the system
i k as
o n o
of the last
protocol that is
in the hypercube
to all its
messages are sent
p s i
the current iteration
links in the
the first node
coordinator based protocol
i whose j
first node and
failures 4 failures
messages cubefulldist coord
array stability array
4 failures 5
a stability message
contains all 1
node in round
of logical hypercubes
connection is added
s coord protocol
and worst result
info message containing
node failures on
of node failures
of reliable multicast
difference in scale
no failures failures
start a protocol
node i that
and message count
g 2 z
an m cube
3 failures 4
receives an info
its matrix m
increases r i
count and message
sg z is
in coord the
hypercube based protocol
failures 3 failures
difference between first
logical hypercube approach
according to node
arraymin element wise
i that receives
failures 5 failures
failures failures 3
i receive from
better than cubefulldist
whose j th
line 1 and
code line 1
messages node i
first member rtt
pseudo code line
notice difference in
wait until receive
g 1 z
of its matrix
element wise minimum
array s i
coord and cubefulldist
node and last
all 1 s
randomly generated network
number array stability
from i the
failures on cubefulldist
between first node
of s coord
multicasts an info
ack r i
the info message
last node rtt
upon receiving info
r from node
has received in
a round number
o n 2
received in the
minimum of the
node i s
i has received
i each node
1 and line
wise minimum of
in the pseudo
system size the
is each node
sends and receives
the underlying physical
of the stability
system load is
r i whose
been received by
total number of
scalability and fault
a logical ring
in an incomplete
on all links
node i receives
in i n
n 2 messages
from all its
all links in

corpus/krapavin2000-test/629492.txt
supernode
tiling
cone
schedule
hyperplane
extreme
vectors
cutting
supernodes
matrix
dependence
gamma0
startup
hyperplanes
projection
lengths
directions
transformation
tile
125
nectarios
koziris
athanasaki
iteration
shape
georgios
ui
diagonal
index
pernode
1v
maximal
loops
row
luce
goumas
orthogonal
jacobi
maria
drosinos
vector
iterations
rows
communication
message
nested
transformed
ramanujam
tiled
tcomm
sadayappan
parallelepiped
partitioning
phases
column
loop
surface
hull
volume
nikolaos
sinks
nests
processors
objective
lectures
u1
direction
dependencies
got
processor
ct
square
selection
determinant
corollary
uday
gamma312
runningv1v2
rountev
1qh
uating
shahriar
perplanes
droped
hyperrectangle
muthu
atanas
500c
parsa
lotfi
baskaran
rectan
bondhugula
context0000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111
gamma187
const1
2445
extenssion
dependen
terminol
transformations
500
running
side
trix
boothe
startups
1q
sotiropoulos
abstractwith
9502889
aristidis
rections
scal
professorship
tsoukalas
clare
sented
convex
transmission
sides
oe
dimensional
plane
ensured
minimized
template
media
nine
multiprocessors
sriram
za
tsanakas
ecution
saeed
utiliza
timal
triolet
supercomput
transfor
krishnamoorthy
sliced
minimizes
supercomputing
minimizing
architectural
communicating
multiplied
spaces
schedules
floor
pendent
respected
execu
panayiotis
seminar
irigoin
transputer
732
606
doacross
rectangular
multidimensional
minf
wavefront
711
stencil
cies
henry
smps
pen
ogy
diag
gle
optimum
optimality
uniform
jersey
tiles
grouped
optimizations
passing
rescaling
hy
nicosia
hadamard
normals
shorten
systolic
sv
equidistant
gorithms
hd
direc
alternates
inde
criterion
226
labs
vec
linear schedule
the supernode
supernode transformation
h u
index space
tiling cone
hyperplane direction
projection vectors
direction matrix
iteration index
relative side
cutting hyperplane
schedule length
the tiling
schedule vector
a supernode
supernode size
maximal projection
supernode shape
side lengths
optimal supernode
total running
extreme directions
dependence vectors
row vectors
matrix h
cone generated
n extreme
column vectors
the cone
optimal linear
extreme projection
side length
communication startup
d s
vectors of
directions of
extreme dependence
running time
hyperplane directions
transformed algorithm
of supernode
supernode relative
supernode index
supernode side
startup cost
optimal relative
of extreme
vectors in
optimal q
dimensional algorithms
length matrix
dependence cone
time optimal
matrix with
supernode partitioning
equal components
vector with
two dimensional
tile size
length vector
the transformed
vector l
the communication
the iteration
vectors from
cone m
h ui
projection vector
jacobi algorithm
125 gamma0
gamma0 125
optimal cutting
optimal hyperplane
s d
selection of
of matrix
of vector
the linear
iterations in
optimal tile
dependence matrix
supernode transformations
original iteration
one supernode
supernode is
maria athanasaki
communication phases
nectarios koziris
matrix d
uniform dependencies
the cutting
the surface
for optimal
a cutting
transformation h
0 125
objective function
with equal
of minimizing
vector 1
available processors
on lemma
vector z
surface of
algorithms with
extreme points
of h
of communication
j d
y y
the total
being orthogonal
considered approximate
gamma0 5
relative supernode
are supernode
su pernode
5 gamma0
cone formed
sinks on
extreme index
z arbitrarily
matrix e
supernode template
four row
1v 0
by maximal
corresponding tiling
optimal orthogonal
new maximal
in cone
orthogonal tiling
another hyperplane
sufficient condition
by h
orthogonal to
directions and
of iterations
the vector
transformation is
communication time
vector r
the optimal
a square
corollary 1
nested loops
the directions
schedule of
exactly n
matrix r
the dependence
vector v
nested loop
j s
computation time
hull of
supernode and
drosinos maria
startup time
cone then
stronger result
georgios goumas
athanasaki nectarios
500 500
its diagonal
with extreme
on supernode
hyperplane matrix
extreme vectors
supernode volume
parallelepiped supernodes
unit determinant
ct s
cone proof
continuous space
in continuous
tiling multidimensional
partitioning hyperplanes
multidimensional iteration
supernode to
negative components
two row
discussed with
space j
square supernode
goumas nikolaos
index points
with uniform
convex hull
diagonal matrix
not include
of vectors
cone is
125 0
min s
same linear
with vector
tiling of
as column
the tiling cone
iteration index space
hyperplane direction matrix
linear schedule length
linear schedule vector
of the tiling
relative side lengths
the linear schedule
total running time
maximal projection vectors
optimal linear schedule
the cone generated
cone generated by
a supernode transformation
cutting hyperplane direction
extreme directions of
of h u
the iteration index
the total running
directions of the
column vectors of
set of extreme
matrix h u
extreme projection vectors
optimal relative side
the communication startup
communication startup cost
supernode index space
two dimensional algorithms
the supernode size
optimal supernode shape
supernode relative side
the transformed algorithm
h u and
with equal components
vectors of matrix
side length matrix
vector with equal
row vectors from
schedule length of
direction matrix h
relative side length
row vectors of
cutting hyperplane directions
supernode side length
of a supernode
a linear schedule
side length vector
n extreme directions
i d s
from the surface
of iterations in
s d s
for two dimensional
projection vectors and
by the supernode
the cutting hyperplane
n extreme dependence
a cutting hyperplane
r is optimal
linear schedule of
column vectors in
extreme dependence vectors
original iteration index
length matrix r
125 gamma0 125
h u 1
exactly n extreme
y y y
in a supernode
supernode transformation h
supernode size in
optimal tile size
the original iteration
j s d
index space and
of the supernode
supernode transformation is
time optimal supernode
the surface of
vectors from the
vectors in the
running time is
surface of the
based on lemma
vectors of the
number of communication
number of iterations
hull of the
the directions of
in the transformed
does not include
in the convex
the choice of
of minimizing the
maximal projection vector
the maximal projection
supernode size the
another hyperplane direction
vector l are
equal components and
cone formed by
is discussed with
inside the cone
extreme index points
of vector s
four row vectors
be considered approximate
to being orthogonal
0 125 gamma0
hyperplane directions and
condition for optimal
optimal hyperplane direction
sinks on the
schedule length in
being orthogonal to
the cone formed
space and should
matrix or a
by maximal projection
the dependence cone
the jacobi algorithm
based on relation
z arbitrarily close
selection of optimal
in cone m
relative supernode side
construction of vector
matrix with vector
its diagonal and
defined by corollary
for optimal relative
optimal cutting hyperplane
5 gamma0 5
on relation between
generated by maximal
supernode shape for
in continuous space
vectors of b
to vector 1
new maximal projection
the supernode shape
h u 2
of supernode shape
with n extreme
continuous space and
two extreme dependence
derived in continuous
selection of supernode
and the cutting
with extreme directions
tiling cone and
vector z arbitrarily
same linear schedule
orthogonal to vector
tiling cone then
directions and optimal
optimal orthogonal tiling
negative components then
results are derived
vector u in
min s d
ensured by selecting
tiling cone proof
of extreme projection
and sufficient condition
convex hull of
the convex hull
time it takes
a necessary and
index space into
matrix r and
iteration spaces for
125 0 125
dependence vectors in
the supernode index
an optimal supernode
optimal supernode relative
iterations in one
then the supernode
athanasaki nectarios koziris
schedule of all
vectors in d
side lengths and
index space is
schedule vector and
multidimensional iteration spaces
and h u
the n extreme
vectors we can
index space j
on its diagonal
size the relative
of available processors
for algorithms with
in one supernode
supernode transformation the
the supernode transformation
as column vectors
in the supernode

corpus/krapavin2000-test/630534.txt
featuremine
mining
winnow
pruning
fire
features
wwwwww
frequent
spelling
training
feature
classification
ignite
eid
idlist
bulldozer
maxw
raises
classifiers
freq
sequences
parity
idlists
betting
classifier
distinctive
bb
bayes
bet
time8
subsequence
word
time0
mine
plan
irrelevant
sequential
suffix
bets
ab
tag
subsequences
bd2
digat
spade
bd1
y8
naive
prune
p3
pos
mined
accuracy
covers
label
bc
000
y4
domains
frequency
redundant
vs
terrain
x3
547
x7
millions
boolean
dataset
folds
p2
weights
bulldozers
truei
burned
moveto
politics
time32
time6
subsumes
chess
selecting
correction
traces
meta
dna
correlated
subsumed
corpus
eids
hcmac
poker
mines
brown
ith
criteria
additionally
datasets
p1
y3
monitoring
million
conf
integrates
item
chih
learning
produced
511
vegetation
weigh
www
heuristic
games
6g
predictive
plans
patterns
web
min
items
classify
122
observable
hf
attributes
trained
confidence
exponentially
primitives
x6
parent
cell
phoenix
nm
scalable
thousands
moves
bd
75
personalized
someone
efficiently
database
partition
rare
337
your
events
forest
lattice
rules
selection
association
water
wins
3n
predicting
discover
categorical
215
simulation
ci
win
success
iff
me
2917
novices
xrules
bayesfm
ignites
4331
xiaonan
dig
ferr
falsei
winnowfm
dug
igniting
arificial
unburnable
featurem
garbay
y9
yih
merl
shiou
winnowtf
burning
2019
rialle
bayestf
winnows
duchne
dichotomic
bez
ria
guozhu
3802
classification algorithms
features produced
feature set
by featuremine
frequent sequences
the fire
wwwwww wwwwww
feature value
class c
the features
feature f
pruning rules
training examples
data mining
value pairs
naive bayes
feature mining
d bb
featuremine algorithm
1 raises
bb d
min freq
the featuremine
pruning rule
of features
features to
classification accuracy
boolean features
fire world
sequential domains
f 1
features for
produced by
d d
standard classification
spelling correction
features which
mining techniques
f i
features that
selecting features
as features
execution traces
each example
ith bet
frequent for
b pruning
www www
the idlists
mined features
sequence mining
non sequential
the feature
the training
class label
exponentially large
decision lists
max l
be frequent
sequence data
target word
of feature
of examples
dataset there
all frequent
features and
for classification
to class
features are
the frequency
1 covers
test examples
examples and
correlated with
examples in
mining algorithm
frequent and
potential features
features out
2 covers
meta features
betting sequences
75 75
features features
1 547
sequence lattice
sequential features
parent partition
observable features
raises twice
improve classification
the idlist
bets 3
bd2 x7
parity problems
ignite x3
examples d
example features
idlist for
idlists of
000 examples
raises 2
547 122
any feature
maxw and
features we
for sequence
feature sets
n a
features is
for class
a feature
to search
in sequential
each feature
time time
a b
training data
a fire
new examples
feature subset
all features
boolean feature
possible features
a bc
frequent sequence
brown corpus
be subsumed
redundant features
sensitive spelling
classification performance
for features
irrelevant features
label c
c j
of sequence
mining for
search over
mining algorithms
the weights
criteria for
the plan
feature selection
in d
features from
f 2
sequential data
features should
large space
class labels
for selecting
millions of
features can
for describing
of potential
sequences as
is frequent
our selection
on feature
the mining
which features
sequences and
of training
there were
a plan
the classifier
cpu seconds
p 1
the ith
to classify
training set
selection criteria
each parent
an instance
instance is
subsumed by
a min
the examples
the sequence
a classifier
context sensitive
the frequent
a occurs
a sequence
features in
to efficiently
ones played
pos 2
non distinctive
features each
specified min
irrelevant boolean
raises by
featuremine with
efficiently search
length sequences
integrates pruning
p3 raises
vs then
sequence classifier
features produced by
the features produced
produced by featuremine
feature value pairs
wwwwww wwwwww wwwwww
feature f i
d bb d
the featuremine algorithm
p 1 raises
bb d d
data mining techniques
that the features
number of features
class c j
examples in d
f 1 covers
d d bb
dataset there were
of feature value
test examples and
a b pruning
the ith bet
standard classification algorithms
all frequent sequences
criteria for selecting
the target word
d d d
for class c
to class c
mining techniques to
in the training
f 2 covers
this feature set
www www www
of potential features
sequences as features
be subsumed by
the feature set
used a min
each feature f
each parent partition
the mining algorithm
1 547 122
the idlist for
a sequence is
will be subsumed
the idlists of
features out of
the fire world
context sensitive spelling
sensitive spelling correction
for selecting features
features should be
space of all
an instance is
the a b
for each example
that f 2
of examples in
features that are
data mining algorithms
of all subsets
set of examples
the frequency of
all subsets of
we used a
the training examples
of the features
an example simulation
and disk based
examples d and
and max l
the sequence lattice
the meta features
mined features from
web usage data
a b relations
evidence for different
1 raises and
freq maxw and
1 true f
be frequent for
for describing each
the resulting idlist
this enables it
ones played by
scalable and disk
75 75 75
based on length
we search over
simulation the fire
min freq maxw
intersecting the idlists
mining algorithm itself
different features to
sequence data the
you re vs
to feed into
maxw and max
selection criteria for
the same eid
the subsequence relation
feature set f
some constant 1
frequent sequences as
f 1 subsumes
feature is true
have label c
plan execution traces
eids f1 2
irrelevant features for
features of length
rule described in
algorithm itself instead
primitives for describing
the non sequential
reduce classification accuracy
pruning rule described
to efficiently mine
boolean features to
the frequent sequences
examples that f
two pruning rules
classify new examples
n a 94
our selection criteria
different min freq
b indicates a
547 122 1
pruning as a
by classification algorithms
vector of feature
for sequence classification
post processing step
y3 time8 ignite
selecting features to
features to feed
p3 raises 2
ith bet and
than vs then
c than f
classification algorithms furthermore
a boolean feature
in the fire
a sequence and
raises and then
present criteria for
by featuremine in
in the brown
n a 86
first pruning rule
there vs their
of selecting features
class label on
frequent and distinctive
frequent for class
scalable feature mining
large feature sets
on or off
target word and
and trained the
is exponentially large
i vs me
digat bd2 x7
an example sequence
time32 ignite x6
significantly correlated with
a chi squared
respect to class
value pairs for
seconds cpu seconds
the primitives for
that all features
the pruning rules
for the spelling
of possible features
d and parameters
1 raises twice
p2 calls p3
for different features
we mined features
to mine for
itself instead of
use data mining
to search over
belonging to class
a fire line
all elements do
someone bets 3
value pairs we
to classify new
122 1 547
with the features
ab bd bc
can reduce classification
bd2 x7 y4
in sequential domains
irrelevant or redundant
user specified min
trained the classifier

corpus/krapavin2000-test/630575.txt
unexpected
interestingness
association
rules
consequent
discovered
meat
conforming
milk
rpc
unexpectedness
grape
dairy_product
items
mining
fruit
beef
ias
gi
apple
ga6
grades
clicking
ranking
visualization
pork
ga3
cheese
her
ij
actionability
subjective
vague
actionable
ga7
match
pk
conform
associations
item
fooditem
gb6
gb4
confm
specification
impression
belief
rule
conditional
she
pear
rankings
chicken
feelings
conforms
courses
specifications
ga
confidence
rn
rm
screen
rank
expectations
colored
rvn
bsunexp
r11
r12
gb
analyzes
beliefs
believes
impressions
truly
lm
grade
boxes
exam
students
box
conformity
metaqueries
fooditems
unexpcond
gb5
dmql
gb1
ga2
discovery
taxonomy
ranked
forgotten
precise
nus
lsn
clothes
his
objective
buy
query
proposes
pruning
subjectively
i1
00
counted
he
rpcs
him
analyzing
consequents
feeling
butter
degrees
optional
post
measures
gis
people
specify
remind
buying
health
sn
uninteresting
hierarchy
huge
discovering
unwanted
contradict
singapore
something
beforehand
helping
generalized
matches
interactive
50
concept
retrieves
language
insignificant
reasonably
sql
gb7
ga1
glut
sebastin
gb3
identifiy
rps
ga4
interestingenss
ventura
interestngness
intellgent
preciseness
yiyuan
confid
dm2
1116
unexpectcond
rvm
internationalisation
wizwhy
pks
blanchard
envelopment
nstb
associatino
fule
courseware
kender
guillet
gb2
unexpconseq
datamine
ga5
minqing
disjunctive
predictive
queries
deviations
fly
sure
basically
matching
potentially
visual
bad
findings
cristbal
shekar
kefir
dempster
romero
shafer
lsm
briand
association rules
discovered rules
unexpected rules
the discovered
the user
interesting rules
existing knowledge
conforming rules
the unexpected
discovered rule
unexpected condition
consequent parts
unexpected consequent
0 50
both side
side unexpected
association rule
his her
rules visualization
visualization unit
and consequent
rules that
conditional and
a discovered
clicking on
generalized association
of rules
rule mining
u j
rules with
the rules
consequent rules
milk cheese
condition rules
ga3 3
discovered association
is unexpected
user s
the conditional
our existing
the interestingness
subjective interestingness
interestingness of
he she
and confidence
proposed technique
rules are
the rule
unexpected because
unexpected with
beef pork
rule a
the gi
match value
the consequent
those rules
visualization system
data mining
items in
interestingness analysis
objective interestingness
are unexpected
of items
support and
precise knowledge
user to
of unexpected
rank 2
the pk
the conforming
potentially interesting
ga6 1
unexpected items
1 00
specification language
a i
rules using
analysis system
s existing
specify his
the rpc
rules the
rules in
rules unexpected
gb4 3
match purpose
dairy_product grape
purpose ranking
vague feelings
rn rm
rpc specification
user believes
grades in
existing concept
consequent match
grape pear
3 gb6
colored box
gb6 3
s specifications
ga7 2
3 gb4
rules a
conforms to
of discovered
the visualization
ij be
of association
j u
unexpected patterns
conditional part
and unexpected
post analysis
of interestingness
conform to
rules it
our applications
ij and
an item
box with
ranking of
not counted
identify those
types of
50 r12
actionability is
expressed where
rules according
fruit dairy_product
unexpected association
pork chicken
rules easily
unexpected match
1 ga3
condition items
bad grades
milk apple
conformity and
meat milk
reasonably precise
or expectations
dairy_product meat
lm ij
50 r11
conforming match
rules most
average grades
confidence are
j well
those potentially
s vague
rules shows
pear apple
truly unexpected
2 ga3
r12 ga7
exam results
that conform
3 rank
r11 ga6
interesting items
some associations
rules and
query based
various types
of knowledge
ij to
a class
parts of
to average
the proposed
specification 2
interesting association
interestingness measures
consequent part
him her
user identify
match values
interesting ones
her existing
rule is
rules from
ranking the
are interesting
00 and
the colored
objective measures
mining process
s 1
the items
to specify
the specification
rules to
21 27
l ij
user is
measures are
finding interesting
associations among
mining algorithm
the discovered rules
both side unexpected
the conditional and
rules visualization unit
conditional and consequent
consequent parts of
and consequent parts
rule a i
a discovered rule
discovered rule a
support and confidence
unexpected consequent rules
unexpected condition rules
side unexpected rules
the user s
association rule mining
the user to
the visualization system
s existing knowledge
2 0 50
user s existing
unexpected with respect
rank 2 0
discovered association rules
in the conditional
u j u
the proposed technique
is unexpected because
of a i
generalized association rules
of u j
to specify his
clicking on the
those rules that
ij be the
specify his her
items in the
number of rules
of association rules
about the domain
the conforming rules
analyzes the discovered
our existing knowledge
the conditional part
rules a discovered
interestingness analysis system
1 00 and
user s specifications
purpose ranking of
the user believes
3 gb4 3
the unexpected consequent
match purpose ranking
generalized association rule
3 gb6 3
using the user
rules that are
to the user
1 a n
degrees of interestingness
the interestingness of
rules using the
ij to denote
1 b k
1 s m
of the discovered
types of knowledge
existing knowledge about
conforms to the
parts of a
association rules using
to identify those
is not counted
a n b
n b 1
the rules with
denote the degree
of items in
in our applications
b 1 b
the discovered association
rule mining process
that conform to
the unexpected condition
our existing concept
box with a
grape pear apple
the unexpected items
0 50 r11
identify those potentially
conditional part of
the discovered rule
ga6 1 ga3
the colored box
3 rank 2
beef pork chicken
the consequent part
2 a discovered
potentially interesting rules
and confidence are
to the pk
rules are interesting
interesting rules easily
50 r11 ga6
have the unexpected
unexpected association rules
r11 ga6 1
of existing knowledge
both the conditional
1 ga3 3
discovered rules according
conforming rules visualization
of interesting rules
fruit dairy_product meat
ga3 3 gb4
user s vague
gb6 3 rank
in the consequent
on the colored
the generalized association
2 ga3 3
0 50 r12
ga3 3 gb6
expressed where 1
those potentially interesting
some associations among
are unexpected with
numbers of items
rules that conform
existing knowledge or
meat milk apple
50 r12 ga7
rules according to
ga7 2 ga3
00 and 0
unexpected consequent match
visualization unit to
ranking the rules
of the rpc
r12 ga7 2
and 0 50
u j well
rules shows us
user to specify
with a value
rules it is
set of rules
a i a
the user is
the user identify
set of discovered
rule a 1
the consequent parts
unit to the
j u if
to a u
interesting association rules
her existing knowledge
his her existing
those rules with
of the rule
s 1 s
of discovered association
be the numbers
rules with respect
rules that satisfy
rules in particular
with respect to
various types of
a 1 a
our applications we
of rules the
c is not
a data mining
r r r
these rules are
if the rule
of elements in
are computed as
huge number of
the rule and
all the rules
of the rules
to the specification
rules in a
association rules in
conform to the
set of items
the rules in
the whole set
bad grades in
average to average
u if both
because dairy_product is
interestingness match values
i a has
conforming rules unexpected
unexpected consequent rule
i matches that
b k conforms

corpus/krapavin2000-test/631019.txt
reliability
ultrareliable
coincident
ultrareliability
failure
independence
growth
hour
life
software
bug
knight
gamma9
testing
bugs
quantification
fault
specimens
specimen
mission
region
hamlet
leveson
tolerance
critical
moderate
extrapolation
binomial
sys
errors
versions
gamma7
gamma15
dick
loglinear
replacement
years
rate
failures
hours
tolerant
safety
accelerated
littlewood
inputs
credible
morzenti
gamma8
sigsoft
hardware
fi
ff
gamma5
experimentation
interaction
amounts
morasca
subjected
infeasible
secs
intercept
phyllis
replicates
device
statistical
digital
probability
flaws
multiversion
engineering
theta
frankl
teams
dependability
kth
angelo
experimenter
wasserman
criticisms
shepard
inescapable
liability
keiller
amey
zeil
gamma12
gamma11
3pkt
54526
fail
manifest
sigada
nagel
missions
roderick
3735
miller
annals
quantifying
protect
john
slow
subjective
discovered
electrically
voter
bev
kt
nuclear
terry
sandro
hal
debate
notes
duration
sample
experimentally
validation
portland
feasible
fails
exponential
voted
strigini
calculated
xiang
pietro
chi
predict
enables
maine
why
chapman
physical
erroneous
slope
establishing
verification
shanghai
lorenzo
echo
23rd
tempting
stochastic
reliable
program
hypothesis
aaron
probabilities
justified
a1
industrial
meaningless
2r
blum
null
removed
tester
establish
black
experiment
rates
rejecting
ada
danger
redundant
programmed
yin
inevitably
24th
repetitive
unreasonable
outputs
78
failed
mitchell
removal
arrival
manuel
a3
estimates
error
supplies
enormous
computers
china
box
reply
axiom
toronto
reformulation
extremely
ultra
brian
gammafineither
interfailure
credibility
diane
rkt
farokh
reliability growth
software reliability
per input
ultrareliable region
the ultrareliable
life critical
coincident error
failure rate
theta 10
test time
p sys
growth model
software fault
coincident errors
expected test
on test
software engineering
the independence
moderate reliability
10 gamma9
sample rate
growth models
of failure
the reliability
of software
life testing
interaction terms
independence assumption
tolerant software
fault tolerance
replacement case
test specimens
system failure
rate per
on software
expected time
probability of
the coincident
feasible amounts
last bug
fail independently
of life
a reliability
reliability is
system reliability
test is
c knight
software failure
of testing
the probability
the test
gamma9 for
fi errors
for ultrareliable
ultrareliable systems
accelerated testing
10 gamma15
ultrareliable software
in life
independence model
fi error
10 gamma7
reliability region
the system
the expected
the software
john c
the versions
quantification of
critical applications
dick hamlet
sys is
fault tolerant
versions are
time on
reliability of
amounts of
failure of
test duration
reliability models
kth execution
binomial process
more testing
physical failures
digital computers
a coincident
for life
low reliability
hour mission
10 hour
versions fail
critical systems
is infeasible
testing process
than 10
software is
real time
of 10
these terms
the testing
of independence
failure times
to moderate
the fi
critical region
software bugs
engineering p
be calculated
the program
the failure
of inputs
of test
the ff
the interaction
1 hour
acm sigsoft
safety critical
d t
and fi
the loglinear
reliability system
program a1
bugs removed
n version
exponential process
17 bugs
is ultrareliable
no coincident
reliability software
design flaws
y intercept
the knight
slow system
next bug
the moderate
ultrareliability quantification
test specimen
programming teams
10 gamma8
for coincident
ultrareliable the
non replacement
separate programming
multi version
more versions
failure process
subjective arguments
ultrareliable system
of bugs
within feasible
known functions
life and
the ultrareliability
replicates n
error rate
null hypothesis
establishing that
formal methods
input is
different versions
low to
is accurate
errors are
rate of
device is
subjected to
the low
ff and
time per
of reliability
years 1
critical software
or moderate
terms must
low sample
10 gamma5
failure per
notes v
sigsoft software
engineering notes
tolerance and
test for
equation 10
rate is
independently then
failure rates
key assumption
failure on
mission time
10 hours
reliability modeling
to inputs
chi square
testing will
years in
system fails
it take
reliability model
the quantification
an accelerated
the ultrareliable region
in the ultrareliable
software fault tolerance
probability of failure
time on test
the independence assumption
reliability growth models
expected time on
failure rate per
fault tolerant software
rate per input
the coincident error
the interaction terms
the expected time
reliability growth model
on software engineering
life critical applications
feasible amounts of
the probability of
of software fault
john c knight
tolerant software reliability
of 10 gamma9
the independence model
the reliability growth
time per input
the expected test
10 gamma9 for
and fi errors
expected test time
per input is
theta 10 gamma15
coincident error rate
conference on software
p sys is
of software reliability
of failure of
expected test duration
amounts of testing
the system failure
case is r
the last bug
of test specimens
the replacement case
to moderate reliability
moderate reliability region
replacement case is
a coincident error
for life critical
a failure rate
the fi error
that p sys
in life critical
a reliability growth
a probability of
the reliability of
time to failure
low to moderate
for the replacement
software engineering p
in the low
the low to
r and n
amounts of time
of the test
the failure rate
number of test
software engineering v
ff and fi
order of 10
the null hypothesis
failure of 10
within feasible amounts
of establishing that
of life and
the non replacement
software reliability modeling
gamma9 for a
number of bugs
failure per input
the test specimen
system reliability is
growth models are
critical region is
10 hour mission
remove the last
these terms must
the system fails
low reliability system
of p sys
a 10 hour
non replacement case
sys is small
matter of life
the kth execution
on test can
of multi version
or more versions
no coincident errors
the versions are
fi error can
time execution time
or moderate reliability
in the moderate
life testing is
for ultrareliable software
on test is
the next bug
terms are small
software reliability is
used in life
of bugs removed
low sample rate
proceedings of the
software engineering notes
engineering notes v
acm sigsoft software
sigsoft software engineering
fault tolerance and
a function of
can be calculated
reliability of the
3 theta 10
the quantification of
real time execution
of system failure
the ff and
low or moderate
the system reliability
the test time
of a reliability
the key assumption
to failure of
parameters which can
that the independence
probability of system
the different versions
in software systems
international conference on
of software engineering
as a function
failure of the
must be shown
use of digital
these terms are
system under test
versions of a
the testing process
failure rate of
sequence of inputs
for a 10
the second case
be greater than
if the system
much greater than
arrival rate of
that the system
in either case
annals of software
the arrival rate
error can be
transactions on software
to test for
such a model
the test is
as a black
software engineering may
theta 10 gamma8
fails a new
failure rates per
binomial process can
the low reliability
probability of accepting
that r remains
seems inescapable that
dependability proceedings of
10 gamma7 hour
desired levels of
finished when r
reliability there are
a device fails
intercept last bug
a failed device
independence model is
into the ultrareliable
at first the
gamma7 to 10
test d t
tester chooses values
smaller the statistical
for one year
program slope y
quantification of ultrareliability
get us into
testing will be
a3 54526 1
07 theta 10
the testing problem
hardware physical failures
programs in reference

corpus/krapavin2000-test/631027.txt
ecs
client
ru
server
cs
clients
dbms
jobs
throughput
queue
job
disk
cached
sqs
qus
update
workstations
orkload
manager
pages
architectures
curves
rad
database
page
upd
unify
cache
mtts
caching
instr
speedup
concurrency
locks
delis
commun
ccm
datapages
ccp
rates
cpu
mpl
lock
workstation
configurations
rd
updates
abrt
quss
locking
workloads
queuing
streams
blocked
experiment
writer
query
decline
abort
perc
sts
lqs
kanitkar
commit
configuration
architecture
logs
generator
workload
increments
diskless
instructions
participating
alue
vinay
resident
rel
multiprogramming
deadlock
curve
accesses
alex
mtt
cmt
9msec
rocessingqueue
roussopoulos
mix
consistency
selectivity
queued
56
packages
disks
request
enhanced
cont
aborted
incremental
msec
writers
dbmss
simulation
scalability
network
read
pertinent
cpus
gains
join
mips
selections
tuples
ready
mainframe
qualifying
percentage
light
site
declines
submitting
kill
transaction
binding
adms
logrd
ddlock
prc
cs21e
commence
readqueue
notify
requests
memories
submits
examine
depicts
queries
serviced
databases
pure
fract
1316
mbits
mesg
locked
buffered
retrieval
log
deadlocks
requested
stream
resources
lan
dewitt
awaiting
ism
routed
stations
queues
modern
readers
clustered
submitted
responsible
selectivities
timestamped
flushed
bytes
min
volume
requesting
depicted
tuple
multiprogrammed
modifications
predominantly
prototype
serious
rate
counterparts
linearly
decides
utilization
simulators
utilizing
transfers
soft
principal
centralized
coherence
loads
chart
catalog
file
nick
benchmarking
rec
updated
differential
the server
ecs cs
the ecs
the ru
the cs
server dbms
client server
ru cs
the client
cached data
rad unify
sqs u
dbms architectures
cs and
throughput rates
server disk
concurrency control
w orkload
orkload generator
jobs min
6 ecs
network manager
56 clients
client disk
2 ecs
and ru
update curves
of clients
main memory
update rates
enhanced client
cs 8
0 ecs
zero update
and ecs
ecs architecture
server and
disk access
a job
jobs are
cs 6
of ecs
throughput speedup
8 ecs
server database
blocked queue
commun software
client main
over cs
4 ecs
alex delis
cs 4
the rad
u experiment
dbms architecture
cs ru
the mtts
of server
the network
of client
clients figure
cs 2
update rate
clients the
access time
ru and
under light
0 update
server relation
workstation server
simulation packages
unify type
light update
update jobs
ecs server
0 ru
update streams
pure update
job is
the clients
the throughput
ready queue
the w
send queue
control manager
almost linearly
client cache
server architecture
the log
the workstation
of cached
server s
the disk
in client
the 0
0 curve
log page
write type
ecs clients
cs configuration
ecs over
ecs performance
for ecs
almost proportional
cont caching
one writer
40 clients
caching perc
increases almost
every client
database architectures
disk reduction
ru ecs
kanitkar alex
update curve
client cpu
ru throughput
ecs model
cs curves
both cs
ecs is
vinay kanitkar
meaning v
sts u
of workstations
cache memory
the concurrency
disk accesses
clients for
queuing model
the update
input queue
shared database
cs the
cs is
query update
closed queuing
v alue
of dbms
cs 0
cache consistency
page accesses
a client
of jobs
database system
the job
workloads the
non zero
output queue
queued in
locking and
new data
parameter cont
the increments
demand new
active jobs
server relations
page instructions
writer at
6 jobs
appear much
incremental access
ecs throughput
diskless client
p rocessingqueue
cs throughput
the sts
queue ccm
lqs u
abort queue
at 56
tuple selectivity
ecs the
update queue
the upd
update blocked
queue abrt
differential files
ru configuration
server concurrency
cpu mips
software application
update workload
application soft
queue send
the sqs
dbms configurations
service module
control queue
queue cmt
appropriate client
ecs 2
the qus
commit queue
server main
the jobs
data caching
the database
this experiment
architectures and
client server dbms
w orkload generator
of the server
the w orkload
cs and ru
number of clients
enhanced client server
non zero update
from the server
of the ru
the rad unify
ecs cs 8
number of workstations
on the server
of cached data
disk access time
client main memory
6 ecs cs
server dbms architecture
the ecs architecture
2 ecs cs
4 ecs cs
rad unify type
cs 4 ecs
ecs cs 4
cs 6 ecs
cs 8 ecs
zero update curves
of the cs
for the ecs
unify type of
the server s
to the server
the server and
client server architecture
in client server
concurrency control manager
server disk accesses
queuing model for
ecs cs 2
vinay kanitkar alex
the cs configuration
almost linearly with
client disk access
cont caching perc
meaning v alue
both cs and
increases almost linearly
cs 2 ecs
the ecs model
of the ecs
0 ru cs
8 ecs cs
ecs cs 6
the network manager
ru and ecs
kanitkar alex delis
almost proportional to
the enhanced client
0 ecs cs
the 0 update
type of dbms
in the ecs
server dbms architectures
the concurrency control
examine the performance
the performance of
the non zero
we observe a
in the client
at the client
the blocked queue
scalability of client
ru cs curves
queue send queue
software application soft
writer at a
for the cs
is almost proportional
clients the ecs
the cs and
the appropriate client
for the ru
commun software application
jobs min and
queuing network models
server main memory
ecs over cs
page instructions to
pages to be
appear much later
pure update workload
server disk access
56 clients the
server concurrency control
ecs 2 ecs
performance of ecs
the throughput speedup
workstation server architectures
commit queue cmt
concurrency control queue
of server disk
ecs cs 0
with tuple selectivity
at 56 clients
control queue ccm
the ru configuration
under light update
cs and ecs
sqs u and
the sts u
sqs u experiment
parameter cont caching
range of 4
the update rate
abort queue abrt
one writer at
client server database
0 update curve
demand new data
linearly with the
with the number
the number of
closed queuing network
main memory size
number of participating
the server disk
when a job
through the network
two phase locking
at a time
to be cached
queued in the
in a client
the almost linear
to the 0
of client server
the ready queue
the job is
maintaining consistency of
in the server
performance and scalability
the other two
the percentage of
is depicted in
for more than
the client s
are done on
to the appropriate
from 4 to
the server is
and scalability of
memory of the
data from the
all the non
parallel databases v
and parallel databases
simulation results show
than that of
of the database
a client server
et al in
distributed and parallel
than clients the
of all models
server becomes the
update rates 1
experiments sqs u
the server database
high throughput rates
ru over cs
queue abrt update
throughput rates for
1998 vinay kanitkar
dbms architectures and
the client main
client s site
disk tr average
the ecs over
three alternative workstation
instr log page
enhanced workstation server
delis nick roussopoulos
client client client
and file server
two system configurations
jobs are not
than 40 clients
percentage of server
queue workload generator
the diskless client
cpu set to
pure update workloads
server database architectures
and ru cs
and ecs architectures
tradeoffs in client
simple database operations
mpl concurrency control
consistency of client

corpus/krapavin2000-test/631036.txt
subdomain
subdomains
covers
narrows
criteria
properly
universally
sel
testing
sdc1
partitions
criterion
sdc2
specification
sdc
detecting
suite
subsumes
dua
fault
weyuker
faults
edges
maldonado
associations
program
adequacy
inputs
software
flow
expose
nfa
suites
fxj0
adequate
subsumption
executable
cover
analogs
sigsoft
subsume
mutation
ability
sd
causing
gammauses
hamlet
applicable
frankl
strategies
partition
engineering
jos
reflexive
covering
selection
strengthens
tester
coverage
3g
measures
repetitive
mathur
relations
transitive
singh
aditya
max
jino
nsup
vergilio
delamaro
robby
nfup
manufacture
stuart
notes
failure
branch
gamman
tosem
stubblebine
gammap
devanbu
200g
silvia
carlos
regina
zhu
assessing
analytical
du
guarantee
unexecutable
phyllis
jeng
kn
disjoint
wong
edge
pairwise
eric
elaine
inspire
assoc
fd
1993
427
dick
weiss
arising
duplicates
dependability
undefined
belonging
loop
statement
multi
f0
concentration
selecting
1995
bearing
corollary
relationships
sub
exiting
duplicate
conditional
programs
assessed
mario
hong
association
goto
cryptographic
induces
na
simulations
superset
intersection
anomalies
overlapping
undecidable
thetaspecifications
0properly
8810287
thetaprograms
inali
marcio
schatz
919
199g
unexercised
wisniewski
bai
lingzi
ganghong
trustability
mrcio
diaper
0such
sdc3
hatcliff
pasquini
sugeta
pravin
voas
912
howden
probbetter
yudong
jsdc1
probabilistic
feasible
theorems
relation
analog
paths
york
distinction
pascal
def
satisfies
podgurski
yuen
zweben
mccleese
8920701
787
premkumar
pasareanu
hierons
harshinder
gourlay
ftjt
cukic
yueh
capizzano
redefines
c 1
c 2
properly covers
partitions c
specification s
program p
covers c
p s
1 properly
properly partitions
all uses
each subdomain
p uses
all edges
criteria c
fault detecting
detecting ability
the all
and specification
subdomain based
p specification
software engineering
multi set
all p
input domain
and criteria
test suite
for p
p use
that c
universally applicable
test cases
criterion c
data flow
test case
on software
sel 2
of subdomains
uses criterion
causing inputs
failure causing
covers relation
1 covers
testing criteria
one test
c sub
flow testing
the covers
faults than
a program
narrows relation
the narrows
the universally
partition testing
2 according
than c
subdomain consists
if c
at detecting
use associations
detecting faults
test data
based criteria
the program
edges criterion
sdc1 p
narrows c
1 narrows
uses and
p and
2 such
m 2
the subdomains
variable v
2 for
every program
cases from
testing strategies
covers and
s if
inputs that
sdc p
properly cover
universally narrows
1 universally
sd all
subdomain d
sel 1
1 partitions
is better
then c
better at
of test
engineering v
c adequate
1 subsumes
the properly
partitions relation
uses does
y max
a test
guarantee that
and c
test suites
the criteria
subdomains are
subsumes c
to sdc1
applicable analogs
using sel
between criteria
requires selection
c use
for program
the fault
random testing
not guarantee
that proof
branch testing
testing ieee
ability of
2 does
s then
selection of
better according
fxj0 x
sdc2 p
some subdomain
partitions relations
analogs of
start node
subdomain in
sub 1
reflexive and
transitive if
acm sigsoft
from each
program testing
is reflexive
testing techniques
based testing
of testing
this program
not universally
universally covers
repetitive statement
or repetitive
definition p
specification pair
if sdc2
uses criteria
definition c
subdomains arising
subsumes relation
sub 2
the subsumes
least one
d 3
all inputs
m 1
edges for
software testing
flow graph
s and
clear path
conditional or
definition clear
adequate test
multi sets
adequacy criteria
probabilistic measures
s c
criteria in
test set
a definition
of fault
the multi
relation is
sigsoft software
notes v
engineering notes
criterion are
g frankl
a subdomain
testing criterion
j weyuker
data selection
selection strategies
and transitive
transactions on
element from
the subdomain
program shown
or or
d max
not c
ieee transactions
question of
or sel
not partition
c 2 for
partitions c 2
covers c 2
c 1 properly
for p s
2 for p
all p uses
and specification s
p and specification
that c 1
program p and
criteria c 1
fault detecting ability
properly partitions c
properly covers c
program p specification
and criteria c
p specification s
1 properly covers
specification s and
1 and c
guarantee that c
s and criteria
from each subdomain
c 2 such
and c 2
1 is better
c 1 and
a program p
exists a program
if c 1
1 properly partitions
on software engineering
c 1 is
one test case
p s if
c 1 covers
than c 2
the input domain
transactions on software
c 2 according
failure causing inputs
then c 1
software engineering v
data flow testing
the all edges
2 according to
1 covers c
uses and all
the all p
each subdomain consists
1 partitions c
subdomain consists of
s c 1
at detecting faults
c 2 if
the fault detecting
detecting ability of
the all uses
that the fact
2 such that
least one test
all edges criterion
c 1 partitions
narrows c 2
c 1 narrows
c 2 does
subdomain based criteria
sdc1 p s
faults than c
test cases from
fact that c
the narrows relation
p s then
s then c
according to m
better at detecting
for program p
for every program
a multi set
sdc p s
the universally applicable
the covers relation
2 for program
for this program
a test suite
of fault detecting
is better at
detecting faults than
all edges for
not guarantee that
uses does not
relation is reflexive
is reflexive and
p s c
such that proof
the multi set
does not guarantee
applicable analogs of
c 1 universally
p use of
c 1 subsumes
one element from
requires selection of
c sub 1
and all uses
p uses criterion
selection of at
and transitive if
criterion c 1
universally applicable analogs
1 subsumes c
p uses and
at least one
test case that
all uses criterion
testing ieee transactions
flow testing criteria
of failure causing
for p and
p and s
a variable v
reflexive and transitive
the start node
better than c
sdc2 p s
definition c use
better according to
definition p use
6 3 y
p uses does
2 all uses
p s observation
of test cases
ieee transactions on
there exists a
or repetitive statement
relations between criteria
specification pair p
each program p
cases from each
all uses criteria
transitive if c
c sub 2
the subsumes relation
the properly covers
subdomain based testing
belonging to sdc1
conditional or repetitive
pair p s
case that is
program specification pair
1 universally narrows
universally narrows c
specification s then
specification s the
according to any
covers and properly
of all inputs
every program specification
in the program
the question of
measures of fault
all inputs that
to m 2
definition clear path
element from each
each subdomain in
clear path with
test case from
software engineering notes
engineering notes v
acm sigsoft software
sigsoft software engineering
c 1 does
test data selection
is a multi
and all edges
path with respect
be a program
that a test
program shown in
2 if for
proof let p
if for every
2 does not
the fact that
c 2 be
for each program
is better according
n test cases
illustrates the distinction
covers relation is
probabilistic measures of
1 7 14
a true partition
assume c 1
the covers and
s if sdc2
that m sdc1

corpus/krapavin2000-test/631040.txt
keir
lemur
apple
maria
versions
sloth
subversions
orange
subversion
file
rcs
files
vanilla
modules
french
odin
belgian
adele
module
configuration
software
lkm
variants
fred
russian
mouse
variant
graphics
principle
sccs
string
montagunix
bulgarian
import
makefiles
numeric
x4
trunk
join
worlds
japanese
revision
substructure
vm
configure
manager
lisp
prog
comp
makefile
dsee
uselist
gandalf
jasmine
create
command
refinement
subcomponent
montague
intensional
builds
relevant
mm
associative
interface
programmers
noninterfering
joins
unix
correction
unwieldy
versioning
recompilation
proc
dictionary
label
english
controlling
uncommon
families
differing
branches
world
users
axioms
philosophical
toolset
names
development
illusion
hypertext
component
integrated
compromise
applicative
reusability
inequalities
algebra
evolved
object
meaning
ancestors
lattice
packages
significance
compiler
merged
hierarchically
releases
ambiguity
inherit
programs
canonical
simplest
shape
subsystems
reusable
configurations
environments
contraction
compatible
requested
merging
incomparable
protection
cooperation
ideas
labels
brobdingnagian
ands
recuperation
employer
autoload
rcsmyampersandmdash
giants
superversion
plaice
marmoset
lustre
brobdingnag
katakana
hiragana
pioneer
gulliver
horrendously
forks
modeller
francophone
transliteration
blanca
subver
arabic
juggling
bootstrapped
recombining
popshop
boggling
syrian
mancilla
kassios
papaspyrou
bugfix
kanji
glu
intensionalizing
dzhon
anterior
sprout
directory
looks
infinite
extensible
commutative
fast
language
organizing
inheritance
visit
merge
imagine
smart
accords
stipulating
indiscriminately
maxi
fifteenth
versioned
mysterious
scopes
logi
menus
paradoxical
brother
hitherto
marriage
everything
asks
operator
rejected
varies
keir apple
maria orange
most relevant
the version
versions of
fast version
of versions
version control
the versions
apple version
o file
relevant version
version and
the vanilla
version language
apple fast
complete system
version is
version of
structure principle
version names
orange version
version v
vanilla version
variant structure
orange keir
a maria
the variant
version space
possible world
software configuration
version we
different versions
software development
the fast
version which
of version
between versions
of variant
desired version
graphics mouse
complete systems
and rcs
lemur to
the keir
and maria
o files
of modules
least upper
the files
a version
string correction
refinement relation
the principle
this version
of software
exist in
each module
to string
every file
string to
version 1
one version
of component
the import
the component
lemur is
and keir
configuration manager
variant substructure
for versions
a subversion
appropriate version
subversion of
substructure principle
development control
join versions
to versions
apple and
numeric versions
maria version
lemur was
revision control
maria and
relevant versions
y version
files involved
to create
versions are
a system
version for
exists in
a module
software configurations
engineering environment
the trunk
component if
each component
versions is
module a
versions we
every component
file there
created to
example that
the o
c programs
canonical form
the refinement
control based
general version
the french
does one
versions and
variants of
other modules
versions the
our version
the software
of complete
software engineering
would allow
a unix
component c
would want
relevant to
software in
different components
of components
a file
of programs
would be
principle of
most general
noninterfering versions
compromise version
versions becomes
maria keir
version variables
third version
formally presents
proc keir
of maria
the adele
lemur a
prog o
software environments
a uselist
true lemur
versions would
version most
both keir
integrating noninterfering
applicative data
different programmers
sloth has
as adele
and lkm
maria s
on module
to sloth
version would
odin 3
lemur does
for extensible
be variants
of sloth
component files
russian bulgarian
have versions
smart recompilation
compiler by
its subversions
possible versions
cooperation in
software databases
version instead
to version
french version
system modelling
version requested
vanilla one
apple keir
of keir
fast subversion
version name
unix tool
the maria
below maria
version lemur
for revision
one prefer
local significance
version labels
configuration systems
intensional logic
version algebra
to components
dictionary order
block moves
the most relevant
fast version of
most relevant version
maria orange version
keir apple version
the fast version
orange keir apple
maria orange keir
variant structure principle
the versions of
versions of the
least upper bound
version of the
2 3 4
a maria orange
the variant structure
version of component
apple version of
keir apple fast
the vanilla version
version v of
of the version
the least upper
version of a
version of each
string to string
a complete system
to string correction
of a system
of the component
of each component
most relevant to
for example that
the version of
the files involved
families of software
variant substructure principle
software engineering environment
the o file
of complete systems
development control based
relevant version of
the keir apple
the variant substructure
the desired version
of versions we
software development control
complete systems and
versions of components
versions of complete
concept of variant
keir apple and
to exist in
version of every
most general version
the version space
version 1 2
version which is
suppose for example
the refinement relation
used to create
the principle of
control based on
example one could
in a distributed
different versions of
1 2 3
of a component
of a module
not exist in
representation of families
a third version
relevant to v
set of versions
the odin system
an integrated toolset
based on system
proc keir apple
does one prefer
the version requested
version is not
of extension and
base of programs
user interface would
of component a
file proc keir
having their own
with block moves
and configuration control
version and its
on system structure
of every component
relation between versions
using the variant
with infinite precision
versions would be
correction problem with
we configure the
on software version
apple and maria
to versions of
version and configuration
canonical form for
version language is
toolset for engineering
keir s apple
third version of
a particular version
for revision control
between versions of
the vanilla one
i for local
available are keir
notion of version
shape 13 14
software version and
software system modelling
between a version
general version possible
exists in versions
maria and keir
integrated environments such
version most relevant
based on module
the import file
a canonical form
joins of versions
x y version
most relevant versions
and its subversions
efficient applicative data
require that every
that it depends
vanilla version is
it exists otherwise
created to accept
such as adele
we take version
when we configure
of different components
relevant versions of
the packages that
managing reusable software
vm and lkm
this version language
the version language
component if it
approach to version
in every version
for a maria
appropriate version of
upper bound operator
problem with block
the o files
of version 1
it the resulting
use version v
can use version
integrated toolset for
hierarchically structured entities
notion of versions
odin system an
labels the o
a unix tool
and string to
manager for extensible
organizing software in
modules that it
to version control
large software development
a version which
be variants of
applicative data types
cooperation in a
version and if
extension and contraction
version control is
infinite precision arithmetic
follows the principle
technique and string
lemur to test
the french version
ease of extension
and cooperation in
configuration manager the
configuration management systems
a version and
software configuration systems
engineering software configurations
noninterfering versions of
interface would be
system modelling facility
exists otherwise we
the compiler by
it specifies that
integrating noninterfering versions
can be variants
principle of x4
extensible software environments
on module interconnection

corpus/krapavin2000-test/631068.txt
duas
adequacy
coverage
effectiveness
subjects
adequate
exposing
testing
criterion
criteria
edges
dua
find1
matinv1
strmtch1
null
strmtch2
textfmt
expose
find2
yes
regression
asset
detm
c2
covered
universe
c1
000
transpose
frankl
associations
weyuker
buggyfind
logistic
hamlet
duran
ntafos
experiment
exposes
determinant
software
executable
sigsoft
confidence
exposed
flow
effective
program
matinv2
ludcmp
subj
rothermel
vs
pascal
fault
subject
detecting
programs
instrumented
nine
proportion
408
gregg
error
unexecutable
extent
proportions
randomly
box
errors
percentage
engineering
hypothesis
phyllis
cover
juristo
notes
ability
empirical
weiss
98
practitioners
package
lu
moreno
harrold
gerhart
366
subdomains
positively
outputs
vegas
1600
subsumes
bev
littlewood
burnett
goodenough
black
generation
169
faults
strigini
matrices
matrix
00
branch
white
238
assessing
dick
strate
text
portland
missing
detect
gies
2000
sira
backsolving
landi
1669
logit
labiche
6100
1584
032
statistical
infeasible
020
lorenzo
456
likelihood
questions
failure
studies
mutation
margaret
inversion
tosem
erroneous
statistically
ryder
021
briand
556
1678
blanks
6400
instrumenting
stubblebine
579
devanbu
1294
dupuis
tse
hunter
ffl
prob
demands
comparing
bug
five
023
041
484
demillo
lixin
mutants
03
did
executed
1125
seeded
testers
615
misleading
specification
singular
wong
goodness
oregon
comparisons
selection
eric
significance
667
basili
557
mathur
775
inspire
473
mary
sample
detects
likely
paths
inputs
all uses
test sets
all edges
test set
adequate test
adequacy criteria
effective than
000 yes
an error
more effective
null criterion
effectiveness of
adequacy criterion
subject programs
adequate sets
the effectiveness
yes 0
sets that
software engineering
subject program
test generation
expose an
the all
the null
edges adequate
data flow
than all
detecting ability
the test
an adequacy
of test
on software
c adequate
vs 0
uses was
dua coverage
uses adequate
1 000
0 000
test data
of criteria
a test
use associations
definition use
subjects all
test case
flow testing
2000 0
exposes an
for find1
of adequacy
test cases
was more
logistic regression
uses and
the program
software testing
coverage of
the duas
than null
criterion c1
null adequate
vs all
missing path
executable duas
nine subjects
extent to
error than
fault detecting
edges and
the extent
the universe
the subject
generated test
testing criteria
set size
exposing an
error detecting
generation strategy
of exposing
four of
edges or
uses is
edge coverage
error exposing
edges was
edges duas
criterion and
but two
program testing
acm sigsoft
random testing
that cover
the subjects
in four
criterion is
the experiment
1 00
ability of
partition testing
that satisfy
comparison of
edges criterion
than c2
edges covered
exposing ability
the error
testing techniques
to expose
detect an
and effectiveness
uses criterion
edges all
data adequacy
and weyuker
increased effectiveness
between coverage
prob exposing
100 coverage
duas covered
set exposes
satisfy c2
exposed an
of duas
that exposed
algorithm 408
c1 more
hypothesis testing
or edges
the proportion
the probability
each test
more likely
testing methods
proportion of
the nine
of testing
all but
white box
executable edges
percentage of
by size
null hypothesis
set sizes
software test
engineering v
coverage and
notes v
sigsoft software
engineering notes
will expose
larger test
duran and
and ntafos
those test
gregg rothermel
of adequate
similar size
branch testing
response variable
0 03
criteria the
exposing for
for find2
for strmtch1
satisfy criterion
coverage vs
1600 0
or duas
169 0
position f
vs prob
5 1600
of criterion
associations or
coverage to
lu decomposition
each subject
criterion in
criterion c
given test
these criteria
the fault
randomly generated
criterion the
uses to
and null
black box
criteria for
those that
random test
error increases
which test
path testing
satisfied all
at 98
set satisfies
c1 is
probability that
to which
adequate test sets
more effective than
test sets that
than all edges
000 yes 0
the effectiveness of
effective than all
the null criterion
expose an error
all edges adequate
an adequacy criterion
the test set
the all uses
was more effective
1 000 yes
a test set
c adequate test
all edges and
on software engineering
all uses was
all uses adequate
edges adequate sets
of all uses
the all edges
test set size
adequate test set
exposes an error
0 000 yes
definition use associations
data flow testing
all uses and
effectiveness of all
of test sets
of all edges
detecting ability of
the extent to
extent to which
of the subjects
all uses is
all but two
test generation strategy
an error than
the subject programs
than the null
uses adequate test
of adequacy criteria
subjects all uses
in four of
generated test sets
of the duas
error detecting ability
comparison of criteria
exposing an error
software engineering v
transactions on software
test sets are
four of the
likely to detect
the subject program
error than those
each test set
error exposing ability
effective than null
comparing the effectiveness
all edges was
of exposing an
test set sizes
of an adequacy
that all uses
the nine subjects
than those that
fault detecting ability
of the nine
and all edges
of the effectiveness
all edges criterion
uses and all
detect an error
and all uses
all edges all
f s c
more likely to
the proportion of
test data adequacy
all uses criterion
of testing methods
edges and all
the fault detecting
coverage and effectiveness
of adequate test
between coverage and
of criteria for
larger test sets
adequate sets that
which all uses
set exposes an
probability of exposing
edges was more
test set exposes
c1 more likely
exposed an error
the missing path
the increased effectiveness
those test sets
are those test
adequate sets of
uses was more
is more effective
those that satisfy
test sets in
of data flow
that a test
data adequacy criteria
randomly generated test
all uses to
to detect an
edges all uses
sets that cover
sets that satisfy
software engineering notes
engineering notes v
acm sigsoft software
sigsoft software engineering
be more effective
test sets of
flow testing criteria
duran and ntafos
effective than the
all edges for
the probability that
conference on software
which test sets
relationship between coverage
vs all uses
of the executable
satisfy criterion c1
that for find1
to expose an
effective than c2
associations or edges
prob exposing for
edges or duas
an error increases
significantly more effective
frankl and weyuker
or edges covered
criterion c1 more
for each subject
test set satisfies
criteria for fixed
that satisfy c2
uses is more
coverage vs prob
will expose an
1 5 1600
all edges or
null adequate sets
of criterion c
effectiveness of criterion
that satisfy criterion
vs prob exposing
of c adequate
the executable duas
of position f
12 1 000
5 1600 0
than null adequate
any test set
each subject program
probability that a
the null hypothesis
a test case
that the test
sparse matrix package
sets of similar
given test set
the test sets
test generation techniques
edges adequate test
the lu decomposition
of similar size
to a f
1 0 at
all elements to
effectiveness of an
software engineering p
of the experiment
experimental comparison of
likely to expose
that cover all
ability of testing
adequacy criterion is
an error message
program s flow
test sets for
of the subject
one test case
a c adequate
s flow graph
test set that

corpus/krapavin2000-test/631072.txt
shielded
exceptions
handler
exception
resume
fp
strict
psml
functional
handlers
gerald
esc
handling
shield
terminate
raised
axiom
languages
subexpressions
strictness
exceptional
object
lazy
effecting
ascii
notations
propagation
prioritizing
constructs
association
alex
subexp
isv
persistent
hyper
ml
objects
referential
hx
primitive
module
e1
semantics
cure
laws
shielding
programmed
raises
phi
activation
transparency
runtime
algebraic
deterministic
yemini
hfunc
liberated
negate
law
lastly
signals
axioms
raising
invoker
backus
reeves
circled
partially
fl
id
asc
actors
unanticipated
embed
abnormal
illegal
berry
l4
style
propagates
append
fault
composition
behaves
firewalls
incorporating
priorities
signal
undesired
invoked
vi
handled
embedding
neumann
imperative
ad
identity
applicative
iii
res
transfer
proach
inhibited
bad
iv
retry
retaining
normal
axiomatic
commutativity
string
detected
functionals
successes
programmer
author
von
deals
conventional
atom
active
tolerant
fully
l2
zee
curable
broadened
h64
cured
sume
ceptions
defni
ffi1
anurag
14i
h12
takeshi
3480
30i
influx
dler
ogasawara
micronet
minimalistic
h13
bretz
ffitl
edo
nicholl
conflict
operating
preliminaries
grams
forms
language
raise
concise
null
tolerance
vii
invocation
flow
discard
treating
hideaki
shields
ald
2a7
ule
l5
indeterminate
germane
negates
exp2
nate
wadler
expository
942
prioritizes
nakatani
komatsu
h3a
toshio
namei
sequentializing
ger
transforms
enforcing
unexpected
completion
conversion
insert
operator
canada
henceforth
proposals
software
retain
lan
regained
exception handling
the handler
resume exceptions
non strict
shielded objects
functional languages
in fp
resume exception
input object
of fp
exception e
strict functions
in functional
functional forms
shielded object
an exception
of exceptions
a resume
object x
terminate exception
up propagation
a terminate
handler functions
handling in
handler function
the exception
exceptions are
exception is
exception handlers
fully shielded
partially shielded
terminate exceptions
in gerald
of exception
primitive functions
active domain
defined exceptions
deterministic behavior
psml 6
exception objects
activation point
handlers in
system defined
an object
exceptions as
fp functions
is raised
object is
for exception
exceptions the
exceptions in
partially or
esc e
hyper strictness
handler h
of effecting
using axiom
ad f
shielded by
fp programs
gerald 9
ml 7
control transfer
a handler
exceptions can
the function
the algebraic
notations for
the up
referential transparency
this law
strict semantics
exceptions a
exception the
function f
of functional
the input
handling constructs
new constructs
strict in
propagation of
an exceptional
algebraic properties
constructs for
x e
and resume
functions into
handler is
operating on
effecting a
functions operating
completely shielded
exception object
into strict
prioritizing exceptions
introduce hyper
exception values
on exception
association point
for resume
alex 3
of esc
persistent nature
add subexp
constructs does
identity domain
level exception
incorporating exception
fundamental conflict
the notations
the active
terminate and
choice operator
be programmed
the association
the activation
semantics of
domain of
on completion
strict on
axiom 2
the subexpressions
runtime test
lines similar
select function
exception or
any exception
function id
to exception
law can
constructs in
and functional
handler can
the fp
mathematical properties
lazy functional
handler the
the module
identity function
functions and
application of
the identity
and handler
algebraic laws
input objects
the primitive
the persistent
the semantics
functional programming
standard ml
software fault
control flow
the application
the conventional
e is
laws of
execution model
not introduce
a runtime
our approach
the select
association of
in lines
the author
is invoked
the object
functions this
the resume
strict over
handling construct
expression oriented
conventional view
e isv
signal bad
backus fp
axiomatic treatment
hyper strict
functional lan
bad by
fl language
be liberated
select tail
transforms non
down propagation
form hx
tolerant tools
exception name
and berry
to embedding
a shielded
non persistent
yemini and
treat exceptions
fp program
embedding exception
handle bad
exceptions however
the shield
on shielded
invocation chain
the input object
exception handling in
a resume exception
a terminate exception
in functional languages
the up propagation
non strict functions
the activation point
properties of functional
exception handlers in
exception e is
the active domain
for exception handling
terminate and resume
the primitive functions
functions and functional
means of effecting
strict functions into
the exception e
system defined exceptions
input object is
up propagation of
and functional forms
the handler function
to the handler
apply to all
exception handling constructs
the algebraic properties
exceptions can be
the application of
an object x
handling constructs in
functions operating on
the notations for
of effecting a
effecting a control
resume exceptions are
and resume exceptions
partially shielded objects
notations for exception
gerald 9 and
primitive functions of
not introduce hyper
algebraic laws of
strict in both
e is raised
identity domain of
be non strict
the association point
laws of fp
for resume exceptions
functions into strict
handler h for
mathematical properties of
semantics of fp
non strict in
fully shielded object
lines similar to
the handler the
introduce hyper strictness
law can be
a control transfer
persistent nature of
the persistent nature
the handler h
shielded objects of
view of exceptions
exceptions as a
functions of fp
into strict functions
in lines similar
the identity domain
lower level exception
handlers in functional
this law can
and handler functions
handling in fp
our approach to
non strict semantics
of exception handling
of fp functions
on completion of
like the identity
the select function
exception is raised
behaves like the
on an object
the identity function
the semantics of
software fault tolerance
of functional languages
algebraic properties of
a means of
as a means
a function f
an exception is
the choice operator
can be programmed
function f can
domain of f
does not introduce
in section iii
with the help
of the primitive
conventional view of
values to handle
of esc e
completion of h
the dynamic invocation
a shielded object
resume exceptions in
construct for functional
association point for
the signal bad
both arguments the
notations for programming
and partially shielded
list of successes
immediate application of
handlers in fp
ad f and
dynamic invocation chain
handler function on
fault tolerant tools
in fp the
failure by a
selection of i
transforms non strict
resume exception the
reeves et al
resume exceptions can
exception handling are
the resume exception
strict with respect
from the association
model of yemini
raises a resume
on shielded objects
functional or applicative
expression oriented language
and psml 6
provides an exceptional
exception that is
defined exceptions can
string of numbers
functional style and
at the activation
can programming be
incorporating exception handlers
exceptions in functional
bad by x
view of treating
exception is allowed
control flow oriented
to embed exception
priorities to exceptions
using axiom 2
system defined exception
referential transparency and
a strict function
2 construct and
of fp are
treating exceptions as
in incorporating exception
flow view of
deterministic program behavior
runtime test b
partially shielded object
for programming terminate
the object x
of new constructs
the shield of
the replacement model
to handle exceptions
functional languages can
resume exceptions the
shielded objects are
by a runtime
as f where
exception e isv
of treating exceptions
x 0 terminate
exceptions are raised
partially or fully
constructs does not
conventional control flow
a handler function
transparency and the
yemini and berry
completely shielded objects
parallel execution model
the functional forms
a fully shielded
of yemini and
handling construct for
in fp style
nature of exception
that of l2
treat exceptions as
an axiomatic treatment

corpus/krapavin2000-test/631084.txt
coverage
subdomains
subdomain
universally
covers
testing
properly
criteria
mutation
suites
criterion
decision
suite
subsumes
cover
sd
sdc
adequacy
fault
mdcc
detecting
arising
faults
branch
flow
causing
sdc1
inputs
weyuker
myers
program
oi
narrows
covering
failure
subsume
selection
minimized
tuples
specification
mutant
hamlet
du
nfa
exercised
software
laski
korel
paths
false
mcc
contexts
duplicates
subsumption
testers
phyllis
rise
2g
subexpression
elaine
detect
statement
adequate
analogs
frankl
association
statements
executable
mutants
ability
tosem
strategies
edges
dc
unexecutable
f0
practitioner
ordered
operators
applicable
associations
engineering
programs
guaranteed
clarke
fxj1
avritzer
reliability
selecting
feasible
da
sigsoft
edge
tester
node
yuen
sdc2
harrold
deficiency
evaluate
failures
effectiveness
boolean
path
bev
littlewood
morasca
sandro
ntafos
sub
compound
strigini
tak
jeng
anomalies
controlling
showed
occurring
inspire
exercise
argued
decisions
conditional
consisting
10g
427
weiss
def
occurrences
overlapping
db
multi
partition
distributions
dr
poorer
lorenzo
negations
analytical
elementary
likely
negation
attention
satisfies
abilities
modification
alberto
loop
artifact
repetitive
goto
definitions
measures
branches
zhu
regardless
family
investigated
dividing
assessing
structural
expose
suffix
cause
executed
relations
exposed
strategy
f1
dept
assembly
0g
predicate
bingchiang
tacit
0narrows
mumcut
fxjnot
curiosity
0obtained
forgcs
dcc
ftjp
fai
anecdotal
evoke
fxj4
9206910
eof
1402
malevris
notes
likelihood
fails
mary
transitivity
summarizing
arrow
adequately
cc
condition coverage
universally properly
decision condition
properly covers
context coverage
multiple condition
properly cover
decision coverage
p uses
c 2
covers c
c 1
branch testing
test case
ordered context
failure causing
not universally
test suites
mutation testing
test suite
test cases
minimized decision
fault detecting
multi set
all uses
all p
detecting ability
the subdomain
testing criteria
subdomains arising
data flow
evaluate to
required k
arising from
test selection
each subdomain
coverage is
program p
the subdomains
cover decision
1 properly
causing inputs
coverage does
criterion c
p s
a test
cover c
coverage universally
software engineering
coverage and
at detecting
detecting faults
subdomain based
subdomain d
coverage criterion
1 universally
inputs that
faults than
input domain
on software
software testing
covers relation
test data
decision d
causing input
covers decision
mutation operators
sd mdcc
of subdomains
the criteria
the program
one test
criteria that
definition clear
flow testing
clear path
adequacy criteria
a definition
the all
flow graph
a fault
this program
sdc p
to true
partition testing
not properly
if c
limited mutation
subsumes but
uses universally
these criteria
least once
the decision
1 subsumes
c sub
suite that
in node
of test
case from
k tuples
of criteria
those inputs
du paths
subdomains are
all du
to false
simple oi
2 sd
better at
each decision
node n
of testing
d d
detect a
from each
and ordered
path with
start node
a subdomain
satisfies c
testing methods
least as
cover all
specification s
the universally
p use
criteria are
criteria in
decision in
ability of
a decision
take on
universally applicable
the properly
coverage subdomains
oi paths
d 9
tuples criterion
coverage 0
coverage requires
coverage subsumes
every program
but does
the fault
of conditions
testing strategies
guaranteed to
a use
the criterion
criterion requires
all simple
paths criterion
than branch
uses or
nfa property
selection of
be exercised
based testing
covers all
be better
a program
adequacy criterion
data adequacy
the multi
d 2
testing and
rise to
edge 8
coverage proof
subdomain consisting
the mutant
coverage according
relative fault
subdomain in
selection strategies
based criteria
suite is
data selection
that c
true at
and specification
the covering
of failure
any test
to branch
testing we
false at
uses all
for program
of fault
that make
d 1
in p
let d
program specification
universally covers
expression controlling
subsumes all
sub multi
sub 2
decision condition coverage
multiple condition coverage
universally properly covers
universally properly cover
all p uses
covers c 2
properly covers c
ordered context coverage
not universally properly
minimized decision condition
does not universally
fault detecting ability
subdomains arising from
1 properly covers
from each subdomain
if c 1
failure causing inputs
condition coverage is
coverage universally properly
c 1 properly
properly cover c
coverage does not
a test suite
at detecting faults
detecting ability of
one test case
evaluate to true
not properly cover
required k tuples
properly cover decision
multi set of
on software engineering
cover c 2
c 1 universally
properly cover all
does not properly
c 2 for
and ordered context
failure causing input
inputs that make
of those inputs
properly covers decision
covers decision coverage
definition clear path
data flow testing
clear path with
test case from
the fault detecting
of the criteria
a test case
path with respect
detect a fault
1 universally properly
properly covers relation
sdc p s
consisting of those
those inputs that
at least once
context coverage and
the decision coverage
limited mutation testing
coverage and ordered
condition coverage and
d d t
condition coverage does
subsumes but does
c 2 if
test suite that
detecting faults than
for this program
guaranteed to be
the multi set
evaluate to false
transactions on software
c 2 then
to evaluate to
c 1 subsumes
likely to detect
all du paths
suite that satisfies
decision coverage is
the condition coverage
m and e
cover decision coverage
at least as
better at detecting
of failure causing
start node to
a definition clear
take on the
the input domain
the start node
but does not
to be better
to detect a
c 1 to
the subdomains arising
the properly covers
from the start
of fault detecting
set of subdomains
of testing methods
be better at
context coverage does
in node n
all simple oi
true at least
than branch testing
uses universally properly
to branch testing
simple oi paths
cover all p
p uses universally
cover decision condition
condition coverage universally
context coverage universally
that c 1
that if c
then c 1
for every program
of data flow
is a definition
a multi set
program p and
2 then c
uses or all
properly covers all
of subdomains arising
inputs that cause
to satisfy c
subdomain based criteria
number of failure
that satisfies c
as c 2
a use of
case from each
on the value
software engineering v
p and specification
test data adequacy
flow testing criteria
c 1 is
in the program
the form a
requires that every
t 2 d
test data selection
selection of one
false at least
form a or
require the selection
d 2 sd
the criteria we
branch testing we
the relative fault
edge 8 9
the subdomain consisting
d d f
value true at
that multiple condition
coverage according to
coverage requires that
from the subdomain
condition coverage subdomains
condition coverage criterion
relative fault detecting
condition coverage 0
subdomain consisting of
that context coverage
value false at
the required k
2 sd mdcc
least as likely
condition coverage requires
test cases from
to v from
we showed that
p s and
of test cases
more test cases
number of conditions
satisfies c 1
attention to programs
selecting test cases
c sub 2
arising from this
a sub multi
this program the
c sub 1
d is d
inputs in d
the nfa property
test suite t
sub multi set
boolean expression controlling
d is of
causing inputs in
of all inputs
subsumes c 2
a definition of

corpus/krapavin2000-test/631115.txt
prover
stack
newstack
constructor
specifications
concat
rewriting
accumulator
inductive
axioms
rewrite
lemmas
const
specification
pf
stmt
constructors
recenter
pntr
equational
proofs
pop
circle
weakest
elem
precondition
annotations
verification
nat
conjunct
generic
push
chunk
larch
wp
subtype
template
termination
completeness
arguments
underspecification
isnewstack
shape
induction
double
confluence
superclass
recursive
subprogram
abstract
correctness
stripping
fertilize
accumulation
algebraic
inductions
tuples
drop
reverse
lp
fertilized
overspecification
center
chunks
subclass
inline
incompleteness
symbols
a1
sides
theorems
inheritance
antecedent
radius
void
strategies
loop
axiom
stacks
exponentiation
skolem
axiomatize
hoare
a2
equations
proving
confluent
array
instantiations
replaces
truth
virtual
successor
obligations
postcondition
discrepancies
canonical
expressiveness
automated
subtyping
naturals
undecidable
enumeration
instantiated
units
sufficiently
tactic
underspecified
alphard
bendix
huet
natarray
stepwise
annotate
automatically
sort
reasoning
proved
member
minimization
subclasses
power
syntactic
tasks
decrementing
induct
isempty
completion
hints
reversal
statements
designing
outermost
statement
forever
hypothesizes
exempt
implementations
manipulate
validation
return
init
max
peculiarity
monoid
h0
unsolvable
formulas
lack
complexities
semantic
annotated
formula
postconditions
templates
verify
oriented
portions
body
flaws
underflow
boyer
tactics
annotating
0i
obligation
permit
formal
entails
programs
instances
expressive
topmost
subterm
associative
p2
generalization
rewritten
crucial
abstraction
concepts
program
chose
supplied
symbol
knuth
subexpression
guidance
reduction
languages
factoring
attempts
axiomatic
package
removes
public
concrete
moore
abstractions
move
power function
our prover
the prover
sufficient completeness
recursive reduction
while statement
theorem prover
term rewriting
design strategies
sufficiently complete
weakest precondition
a constructor
type stack
power functions
left sides
const return
defined operations
left side
a stack
rewrite system
while statements
q pntr
program units
constructor based
the recursive
a specification
the weakest
and sufficiently
equational reasoning
return center
subprogram parameters
constructor enumeration
inductive variable
theta nat
constructor terms
wp w
const point
newstack and
an inductive
the specification
abstract data
a rewrite
tuples of
right side
rewriting systems
of specifications
data types
data type
rewriting and
inductive hypothesis
of shape
instance of
virtual double
next q
generic formal
abstract properties
binary choice
inductive variables
stack is
the axioms
a while
be proved
correctness of
the stack
the power
rewrite systems
generic program
abstract class
abstract base
prover is
sort s
s i
of arguments
an equation
the loop
the specifications
is canonical
prover for
constructor c
each constructor
proving theorems
the operation
rewrite rules
of tuples
specification is
verification of
an instance
canonical and
lemmas to
a superclass
the constructors
the inductive
sides of
specifications and
properties of
termination of
truth of
the lemmas
by cases
axiom of
and push
the truth
push s
types generic
function pf
procedure pop
inductive for
defined operation
syntactic properties
manipulate objects
nat theta
type shape
program components
inline void
verification tasks
our strategies
recursive constructors
only syntactic
of stmt
of while
pure virtual
crucial properties
type induction
consistent extension
body stmt
critical pairs
stack newstack
new templates
templates one
center const
the proof
to rewrite
a subtype
specifications the
of sort
rewrite rule
precondition of
of type
completeness of
the type
example 2
the formula
in example
the theorem
in position
object oriented
type t
of term
base classes
the conjunct
representation mapping
constructors the
drop is
stmt is
extend s
of circle
verification problems
inductive arguments
algebraic specifications
is begin
an accumulator
of accumulator
the correctness
operations which
the types
expressiveness of
the equation
and verification
the proofs
specifications our
constructors of
which manipulate
of constructor
completely defined
program correctness
remaining arguments
of expressiveness
type parameters
an abstract
the verification
argument of
instances of
an automated
strategies for
the generic
s 0
then return
s center
formal proofs
equational specification
our specification
circle is
actual parameters
algebraic specification
s operations
reduction of
a lemma
lack of
of correctness
verification techniques
the recursive reduction
power function of
the power function
the weakest precondition
a while statement
recursive reduction of
and sufficiently complete
design strategies for
of a stack
a constructor enumeration
const return center
wp w r
the theorem prover
of a while
to be proved
abstract data types
of tuples of
the left side
discussed in example
the binary choice
precondition of a
weakest precondition of
the type stack
of sort s
canonical and sufficiently
left sides of
an abstract class
by the prover
of a specification
an instance of
of the loop
the right side
set of tuples
an inductive hypothesis
term rewriting systems
the correctness of
the truth of
s i 1
its power function
combination of arguments
of remaining arguments
the left sides
extension of s
data type induction
of while statements
and consistent extension
new templates one
and sufficient completeness
sufficient completeness of
our theorem prover
generic program units
sort s i
a defined operation
constructor based systems
tuples of remaining
which manipulate objects
consistent extension of
theta nat theta
the prover for
nat theta nat
the constructors of
tuples of arguments
between the types
of expressiveness of
rewriting and induction
left side is
of type shape
an inductive variable
lack of expressiveness
in example 2
of the specification
types of the
is the power
of arguments of
symbol in the
complete and consistent
a rewrite system
abstract base classes
of term rewriting
a rewrite rule
reduction of the
by means of
attempt to prove
a complete and
the types of
of the procedure
and verification of
in position 1
of the axioms
the original proof
suggested by the
the function computed
the axioms of
sides of the
is an instance
correctness of the
function computed by
of type t
left side of
parallel implementation of
the specification of
of the generic
the expressive theory
s left side
of each constructor
as a lemma
a constructor based
extend s 0
while statement is
identity of concat
the prover automatically
recursive argument of
3 holds when
systems rewriting systems
const point c
hoare s system
tuples of constructor
new incompleteness result
reductions abstract properties
sort of this
its left identity
continue by cases
not a peculiarity
right identity of
only syntactic discrepancies
a canonical and
we chose inductive
where max a
in the axioms
selected place with
inductive variable and
a peculiarity of
templates one associated
program state after
drop discussed in
of our specification
symbols of a
reduced to true
as rewrite systems
the formula being
of naturals and
step is associative
with newstack and
with a fresh
type stack is
replaces the selected
is a monoid
lemma replaces instances
an equation does
and reverse are
calculate wp w
with inheritance and
place since the
types generic program
of a defined
rewrite system is
a new incompleteness
via inheritance a
stack represented by
recursive reduction strategies
that some computation
result for hoare
shared language specifications
strategies for rewrite
the second theorem
we extend s
operations which manipulate
when a generic
are pure virtual
we replace instances
using the binary
generic formal subprogram
e we replace
center const return
equation cannot be
of sufficient completeness
program units and
power function pf
function of stmt
since the sort
generic subprogram parameters
data types generic
are representative of
first three instantiations
two new templates
the other lemma
left sides we
objects of type
used to rewrite
specification s i
annotating abstract base
by equational reasoning
show its application
a right identity
of constructor terms
return center y
axioms are developed
stack discussed in
incompleteness result for
elem return elem

corpus/krapavin2000-test/631132.txt
usage
certification
profile
reuse
reliability
shy
certified
mtbf
reused
runeson92
certify
chart
profiles
probabilities
failure
behaviour
modelling
software
services
module
acceptance
vii
service
s2
reusable
rejection
s3
stimulus
markov
repository
musa
dial
tnorm
certifica
hypothesis
transition
accepted
users
s1
external
c1
objective
component
constituents
c2
changed
testing
failures
conformity
poore93
u11
dials
wohlin
runeson
osman
poore
wohlin93
musa87
balci
complemented
chain
hierarchy
adjustments
confidence
probable
structural
correction
idle
resetting
534
concluded
events
script
growth
calculations
rejected
development
labs
telecommunication
compo
operational
faults
chapter
emphasized
320
stored
article
appended
configurations
perceived
r2010tnorm
r97531reject
certifi
ut1
cific
hendrick
whittaker93
peraphon
ut2
severities
sheppard
sophatsathit
graeme
traceability
nance
marketed
u12
tification
nakkrasae
antonellis
ormsby
musa93
sathit
accreditation
developmental
brantestam
u21
modularity
fall
corrected
predetermined
800
adjustment
developing
attached
castano
interdependence
condon
1160
prechelt
dunn
pernici
1664
certi
walcelio
fied
melo
emam
cer
reset
emerging
ring
indirectly
predictions
composed
chains
measures
profiled
34th
personnel
horizons
923
whittaker
ischia
spective
tichy
knight
helen
tomacs
nent
rework
receiver
modelled
reliable
disadvantage
zhuge
markets
851
khaled
exceptionally
richardson
732
assess
drawn
plotted
concerning
fault
normalized
basili
calendar
ures
312
fulfil
certifying
johan
engineering
impossible
region
x0
847
spe
whilst
links
lutz
arthur
ponents
475
interdependent
digit
administration
usage model
the usage
usage profile
certification of
software components
behaviour level
the shy
usage models
of software
the component
hypothesis certification
certification model
vii certification
shy model
the certification
the reliability
be certified
the components
usage profiles
control chart
reliability measure
the module
be reused
a component
failure data
with reuse
a usage
profile the
usage of
to certify
component is
of components
model is
for acceptance
component certification
usage modelling
the mtbf
3 usage
the behaviour
reuse of
profile for
user types
test cases
the model
the hypothesis
user type
and usage
the services
for reuse
services are
new usage
service s1
expected usage
reliability measures
reuse the
of usage
the repository
usage testing
usage level
the probabilities
users of
of reliability
the objective
failure time
reusable components
the failure
user of
when developing
the external
the system
component can
is reused
reused without
4 certification
external user
certifica tion
level usage
certification can
shy models
reused component
components both
mtbf requirement
different usage
certified the
level user
been certified
structural usage
state hierarchy
certified with
software systems
rejection of
software reliability
model and
the reuse
it possible
modelling the
of confidence
development with
is certified
developing for
chart is
certification is
reliability growth
chain on
certify the
acceptance or
the reused
points fall
given degree
profile can
external view
software engineering
objective is
probabilities in
type level
module m
or rejection
the users
the service
complemented with
system configurations
and s3
reused the
components must
the user
module is
of test
components in
a transition
component the
probabilities for
model for
chapter 5
component has
both when
s2 and
profile is
fall in
markov chain
components a
a specific
reliability the
reliability of
hypothesis is
components this
also means
transition in
models for
is changed
the testing
model must
in chapter
script and
reliability level
user b
certified before
hierarchy model
service usage
future reliability
model parts
components system
operational profile
q labs
external users
system context
time tnorm
parts hence
poore93 3
for certification
test script
failure types
components also
new profile
u11 and
adjustments in
repository and
arbitrary usage
modelling 3
a dials
met with
the stimulus
actual usage
component developed
conformity between
mtbf is
usage state
system constituents
again beginning
reliability a
new certification
entire usage
failure number
0 534
dials b
1 reuse
required mtbf
by musa
modelling usage
between services
wohlin93 runeson92
the usage model
certification of software
of software components
usage model and
of the usage
vii certification of
the usage profile
the behaviour level
hypothesis certification model
the shy model
of the component
usage model is
usage profile the
the hypothesis certification
usage model for
the component is
usage model of
usage profile for
usage models for
the usage models
of the components
of a component
in the usage
from the usage
certification model is
the reliability measure
to be certified
and usage profile
profile the usage
model and usage
certification of components
3 usage modelling
on the behaviour
for the module
the services are
can be reused
usage of a
usage of the
component can be
the module is
to be reused
of the system
of test cases
with the component
the model is
model for the
probabilities in the
if the component
and with reuse
user type level
usage profile can
the failure data
the component has
that the usage
the component the
different usage profiles
the state hierarchy
of the shy
usage model must
given degree of
development with reuse
of failure data
a usage profile
both when developing
components both when
when developing for
new usage profile
that the mtbf
points fall in
for and with
behaviour level usage
4 certification of
random number is
reuse of components
the control chart
mtbf requirement is
developing for and
the objective is
reliability of the
in chapter 5
a given degree
complemented with a
the probabilities in
chain on the
or rejection of
acceptance or rejection
generation of test
for a component
software components a
it possible to
must be derived
components must be
5 a simple
the users of
the usage of
makes it possible
models of the
the hypothesis is
degree of confidence
fall in the
a transition in
model of the
concluded that the
with a given
users of the
on software engineering
the service usage
usage modelling 3
run through again
the shy usage
changed to s2
characteristics usage model
by the external
a specific reliability
new certification must
actual usage profile
its characteristics usage
will probably give
2 reuse of
be re certified
a component without
the external users
than a predetermined
reuse it is
quality of software
usage profile which
profile the reliability
software components proceedings
et al musa87
shy models of
test script and
the usage level
must be certified
of software usage
reliability measure of
assignment of probabilities
modelling of software
therefore the usage
is run through
shy usage model
a dials b
usage model the
component the usage
script and the
be certified the
number is drawn
the actual usage
profile for a
component is stored
the required confidence
state hierarchy model
different system configurations
upper levels of
important issue is
components also means
of usage profile
software components 5
the components both
software reuse emerging
simple example usage
another usage profile
being put into
the mtbf is
are further discussed
with its characteristics
failure data in
failure time tnorm
user of type
the new usage
and the usage
drawn for example
be reused without
usage models are
transition from idle
an external user
specific reliability level
collection of failure
level user type
the structural usage
execution of test
be certified with
profile for the
of detail the
for acceptance or
be reused if
shy model is
a control chart
structural usage of
cases and collection
normalized failure time
module m is
software components system
reuse emerging technology
probably give a
between the usage
developed for reuse
component developed for
reliability measure stored
usage level user
of components also

corpus/krapavin2000-test/631135.txt
firing
spns
spn
petri
marking
regenerative
stochastic
sr
nets
smp
emc
transition
subordinated
ctmc
transitions
regeneration
timed
steady
transient
rft
enabled
dtmc
srp
markov
dspns
ciardo
firings
markovian
markings
expolynomial
fire
fires
tangible
dspn
gspns
distributions
reachability
transmission
net
nk
exponentially
matrix
conversion
reward
inhibitor
timeout
exponential
supplementary
const
semi
gsmp
technische
espns
tpns
tokens
german
jensen
immediate
discrete
restart
ctmcs
ioe
memoryless
berlin
holding
instants
transi
geom
numerical
truncation
entries
oe
sm
mr
evolution
deterministic
probabilities
multiplicity
probability
0101
molloy
gtpns
marsan
tpn
mial
0110
ajmone
expolyno
bobbio
stieltjes
timenet
tg
delay
vol
arc
equations
places
underlying
laplace
sans
trivedi
srns
chain
piecewise
pi
geometric
instant
scaling
analytical
psi
discretization
policies
arcs
0g
universit
cesses
polynomials
hierarchy
row
factors
mass
reinhard
quotients
normalizing
fl
enabling
event
fired
und
se
excessively
activity
generalized
matrices
formulas
generator
processes
constitute
normalized
enjoys
mail
1994
differential
kernel
unity
characterization
embedded
weighted
multiplications
recurrent
theta
concurrently
randomization
delta
exchange
germany
throughput
fur
1e
rows
appendix
simulation
disabled
increasingly
drawn
sufficiently
stochas
100c
shedler
fioe
rechnersysteme
bechta
1132
williamsburg
horvth
gmd
asymptotical
natkin
geist
stochastiques
mikls
100b
bmft
gesellschaft
thors
gtpn
expolynomials
rfts
daten
armin
10587
sanda
chiola
erhan
1731
symons
rge
kelling
multiplic
tekel
stochastic petri
firing time
petri nets
transition t
the firing
sr spn
steady state
the emc
the steady
a sr
distributed firing
regeneration points
sr spns
firing of
state solution
the marking
enabled in
firing times
stochastic process
petri net
the subordinated
the smp
probability vector
marking process
t 1
semi markov
underlying stochastic
transient analysis
conversion factors
in marking
timed transitions
immediate transitions
timed transition
exponentially distributed
probability matrix
a marking
the rft
subordinated ctmc
process underlying
regenerative spns
firing delay
spns with
markov regenerative
spn is
the matrix
discrete time
timed petri
the transient
state analysis
of spns
state probability
the spn
a spn
transition probability
transition is
numerical solution
a transition
of conversion
step transition
emc is
matrix exponential
regenerative stochastic
firings of
a smp
regenerative transition
emc can
extended dspns
spns and
of spn
the reachability
and stochastic
time distributions
underlying a
state probabilities
of stochastic
to marking
marking dependent
spns the
transitions t
reachability set
solution of
for transient
deterministic and
non exponentially
a regenerative
a srp
regeneration point
vol 20
spns where
execution policies
regenerative transitions
markov spns
the sr
firing distributions
rft of
of supplementary
ciardo et
expected holding
average firing
minimum rft
semi regenerative
subordinated processes
activity networks
ctmc spns
transmission line
holding times
step oe
spns underlying
a dtmc
unit step
matrix p
is enabled
process is
distributions are
continuous time
a stochastic
jensen s
the stochastic
other transitions
each marking
20 no
generalized timed
its firing
the regeneration
time distribution
e t
distribution is
the transmission
of timed
al a
engineering vol
analytical solution
generalized stochastic
no 7
marking is
transition s
transition firing
vector of
markov chain
of t
matrix of
t s
on software
july 1994
7 july
of transition
to fire
equations 11
software engineering
stochastic activity
spn s
with generally
transitions enabled
extended stochastic
two transitions
piecewise defined
spn whose
spn can
time spns
exponential transitions
spn classes
generally distributed
each timed
markovian spn
become enabled
embedded process
constant firing
firing process
the tangible
srp spns
transient state
equations 16
dtmc spns
immediate transition
places contain
embedded markov
supplementary variables
vector matrix
phase type
smp the
generalized semi
modeling power
spns if
tangible marking
increasingly efficient
spn or
a subordinated
evolution of
markov process
a characterization
one step
analysis of
instant of
discrete event
of immediate
the instant
geometric distribution
entries of
distribution function
scaling factor
stochastic petri nets
the steady state
of the emc
a sr spn
steady state solution
the firing of
stochastic petri net
of a sr
exponentially distributed firing
the marking process
probability vector of
e t s
state solution of
transition probability matrix
distributed firing times
a stochastic petri
stochastic process underlying
the firing time
transient analysis of
process underlying a
state probability vector
step transition probability
of the smp
the underlying stochastic
steady state analysis
underlying stochastic process
steady state probability
of stochastic petri
of conversion factors
the stochastic process
one step transition
underlying a stochastic
regenerative stochastic petri
jensen s method
firing time distribution
firing time distributions
and stochastic petri
the matrix exponential
deterministic and stochastic
after the firing
the one step
firing of t
probability matrix p
of transition t
vector of the
the matrix of
timed petri nets
firing times are
emc can be
of immediate transitions
a regenerative transition
non exponentially distributed
firing of a
al a characterization
through a scaling
vol 20 no
20 no 7
of the spn
ciardo et al
the emc is
7 july 1994
the regeneration points
the minimum rft
engineering vol 20
no 7 july
where the firing
the emc can
distributed firing time
of timed transitions
transition t 1
transactions on software
on the marking
generalized stochastic petri
transition t in
a transition t
matrix p of
the reachability set
in each marking
for the transient
transition is enabled
of l m
analysis of stochastic
an analytical solution
generalized timed petri
software engineering vol
of the stochastic
on software engineering
the entries of
process is a
distribution of t
et al a
the instant of
by the matrix
a scaling factor
of a transition
equations 11 and
11 and 12
a characterization of
evolution of the
enabled in each
semi markov spns
embedded markov chain
extended stochastic petri
transitions enabled in
of the sr
the rft of
f t delta
state probabilities for
method of supplementary
generalized semi markov
markov regenerative stochastic
with non exponentially
increasingly efficient solution
matrix of conversion
expected holding times
equations 16 and
where modeling power
reduced in exchange
transition t with
classes of spns
analysis of deterministic
generally distributed firing
with unit step
if e t
power is reduced
the embedded process
can become enabled
of each timed
spns where all
the subordinated ctmc
for an increasingly
classes where modeling
must be studied
of extended dspns
constant firing times
of supplementary variables
firing time of
s 2 e
of sr spns
of a smp
if the firing
state analysis of
an increasingly efficient
the subordinated processes
transient state probabilities
regeneration points must
c of conversion
with generally distributed
exchange for an
average firing time
semi markov process
spn classes where
the sr spn
numerical solution is
piecewise defined by
of spn classes
each timed transition
hierarchy of spn
marking process is
in a marking
modeling power is
regeneration points of
stochastic process the
stochastic activity networks
spn can be
the expected holding
sr spn is
a subordinated ctmc
his work was
of equations 11
for the subordinated
sr spns the
is enabled in
the evolution of
characterization of the
the reachability graph
solving the linear
enabled in marking
t 1 can
enabled in a
conversion factors and
transient and steady
an efficient numerical
t in marking
petri nets with
transition t 2
of the srp
the discrete time
class of extended
of deterministic and
the linear system
is given by
solution of the
the initial marking
and steady state
petri nets a
points must be
in exchange for
is reduced in
a discrete time

corpus/krapavin2000-test/631150.txt
standby
warm
temperature
seniority
jacket
reactor
copy
hot
batch
reliability
copies
profile
cold
sensor
valve
junior
steam
reaction
cb
master
processor
reactions
mse
primary
processes
concentration
fault
processors
failure
oe
recovery
allocated
profiles
water
tolerant
hierarchically
alive
vulnerable
chemical
hardware
failures
4t
slots
parent
sampling
nrc
unmaintainable
kinetics
valves
tolerate
unreliable
load
simulated
unattended
deprived
harsh
senior
period
survives
supervisor
filled
replication
restart
fail
child
instr
actuator
serving
frequency
charge
houston
cooling
hierarchy
consume
spare
link
favorable
backup
controller
stop
hierarchical
lived
9a
acquiring
tolerance
simulates
triple
simulation
replicated
proportional
double
controlling
repair
capacity
yield
self
burst
rate
allocation
prescribed
peer
active
controls
formulating
partial
reactant
helicopter
9110816
chical
exothermic
chemicals
mississippi
38677
a129
seniorities
weir
vessel
c68000
magnitude
fraction
fails
minute
broadcasting
channel
subsystem
temporary
continuity
faulty
logical
loading
nel
xw
reac
bastani
regulating
effecting
reacted
proportionately
howev
sumed
date
capability
you
structured
receiving
reliabilities
datagram
regulatory
nuclear
quirements
backups
damages
eter
tmax
ess
puter
consecutive
redundancy
envision
090
unexpectedly
gammac
er
failed
simulator
advances
ceases
sync
disruption
stand
critical
broadcast
inventory
responsibilities
die
governs
links
protocols
commission
possessing
disrupt
decline
ent
iff
exponentially
prac
repairing
surviving
a2a
formulates
param
302
sequently
heat
advancing
instantaneously
tice
logged
catastrophic
favored
warm standby
hot standby
control process
temperature profile
the warm
standby system
standby copy
standby copies
batch reactor
standby scheme
primary copy
jacket temperature
the batch
a warm
cold standby
of warm
partial copy
the reliability
reliability of
control processes
the jacket
sensor input
master control
batch reaction
the hot
copy of
the control
logical communication
standby and
junior copy
yield of
process control
processing power
level processes
copy with
the temperature
full copy
copies of
a level
the sensor
reactor system
the yield
its seniority
partial copies
a process
a temperature
oe m
control programs
the primary
the master
steam valve
of cb
standby schemes
sensor sampling
standby is
optimal temperature
temperature control
s seniority
chemical batch
using warm
control hierarchy
temperature profiles
fail stop
hierarchically structured
a primary
hierarchical control
stop processors
copy and
a processor
level 2
fault tolerant
a copy
a partial
p 3
control program
level 1
process and
a control
oe a
the steam
a junior
full copies
the standby
seniority function
the junior
input temperature
standby there
water valve
simulation evaluation
copy s
vulnerable period
consecutive reactions
solution concentration
sampling frequency
the mse
profile is
is allocated
control information
underlying hardware
allocation a
to tolerate
allocated to
failure of
same hardware
processor failures
the reaction
the reactor
of receiving
hardware failures
3 process
and hot
copy is
the copy
processes in
the recovery
takes over
with oe
for upper
hardware cost
a hierarchically
which simulates
of replication
communication link
profile to
level 3
of hot
recovery time
copies is
system failure
temperature and
mean square
a hot
all copies
1 process
load on
square error
this level
communication links
upper level
of processes
and oe
is proportional
to oe
allocated for
process which
p 4
takes charge
just hot
triple processor
copy provides
alive and
valve which
recovery rate
double failure
double and
three copies
standby redundancy
cb desired
jacket to
closed when
iff 9a
a steam
kinetics of
with warm
new seniority
is unreliable
seniority equal
those operating
9a 2
valve is
standby using
you alive
standby warm
and triple
the kinetics
2 processes
active copies
be deprived
structured system
where burst
global factors
in harsh
sec of
unmaintainable systems
embedded is
order consecutive
temperature changes
channel process
final yield
copies e
on unattended
jacket processes
will consume
seniority for
reactor in
are you
g instr
using hot
parallel structure
batch reactions
the warm standby
a warm standby
the hot standby
warm standby system
of warm standby
the reliability of
warm standby copies
a partial copy
the batch reactor
warm standby scheme
the control process
master control process
warm standby copy
of a process
the primary copy
hot standby copies
the sensor input
a temperature profile
process control programs
hot standby system
the batch reaction
warm standby and
a full copy
reliability of the
copies of a
of the warm
yield of cb
jacket temperature control
using warm standby
a level 1
warm standby is
standby system is
chemical batch reactor
batch reactor system
a primary copy
the control processes
temperature profile is
control process and
the master control
a level 2
copy of a
is allocated to
primary copy of
of the hot
copy of m
fail stop processors
of the primary
logical communication links
in the warm
sensor input temperature
sensor input is
oe m p
standby scheme is
of the batch
temperature profile to
the yield of
level 3 process
hot standby scheme
same hardware cost
a hot standby
level 1 process
upper level processes
standby copy and
of hot standby
to system failure
logical communication link
the jacket temperature
on the reliability
copy s seniority
frequency of receiving
input temperature profile
hot standby copy
copy with oe
temperature control process
and hot standby
the junior copy
lead to system
oe a p
lower level processes
a junior copy
process which simulates
of the control
by a level
a control process
the control information
a hierarchically structured
a level 3
of receiving the
failure of the
the same hardware
a process and
processing power of
all copies of
mean square error
between the actual
be allocated for
is proportional to
p 3 and
that of the
view of the
power of a
of a processor
order of magnitude
standby scheme in
in a hierarchically
processes are embedded
a better reliability
control process needs
it is allocated
its seniority to
standby copies e
junior copy of
sampling interval in
three copies of
receiving the sensor
failures are possible
level 2 process
standby and hot
use of warm
by a junior
order consecutive reactions
copies of j
environments where burst
with warm standby
full copy of
that the warm
processes i e
the mse is
junior copy with
a simulation evaluation
cold standby schemes
such that allocation
the final yield
this level consists
for warm standby
where burst hardware
g instr sec
closed when p
reliability of partial
the actual temperature
are embedded is
profile to be
primary copy and
of control when
and cold standby
replicated on three
the recovery action
in harsh environments
oe a y
operating in harsh
hierarchically structured system
is with department
yield of b
copies instead of
the temperature profile
processes e g
with a seniority
only the copy
a the capacity
the steam valve
physical environment of
jacket temperature profiles
the water valve
triple processor failures
the three copies
harsh environments where
detailed one corresponding
control hierarchy in
embedded is simulated
seniority equal to
proportional to oe
the temperature sensor
a simulated chemical
seniority for example
a solution concentration
system failure in
hardware is unreliable
provides direct control
of process a
9a 2 a
software failure rate
control processes each
to oe a
parent to child
containing a full
the standby copy
the desired temperature
a steam valve
to the jacket
first order consecutive
a process control
of achieving fault
desired temperature profile
underlying hardware is
hence the frequency
by r t
exponentially distributed time
temperature sensor input
long lived unmaintainable
standby system as

corpus/krapavin2000-test/631158.txt
jobs
sites
eg
underloaded
overloaded
queuing
site
underload
sharable
ol
queue
ul
overload
sharing
job
load
rommel
transferred
usefully
intensity
plbs
coefficient
traffic
plots
bulk
arrival
transform
balancing
probability
sums
eq
homogeneity
distributions
disciplines
vs
binomial
plotted
designers
arrivals
expectation
service
queues
melman
nul
ohio
underloads
expression
homogeneous
random
livny
formula
il
normal
expressions
peak
conditional
analysts
combinations
singhal
normality
normalized
potential
varied
markovian
ith
attains
interpretations
across
rb
cpus
accept
observation
fluctuations
transfer
tends
identically
law
transforms
numerical
simultaneous
rewrite
professor
observations
success
peaks
systsems
trinomial
tul
backlog
shivaratri
supportive
implementers
gratefulness
nagaraja
coefficients
insight
shall
independence
comprising
denominator
discipline
rate
polynomial
ineligible
krueger
nol
staunch
mukesh
distribution
putting
tend
cumulative
pieces
sriram
director
imbalances
profitably
insights
summation
event
quantify
researched
unimodal
tol
bz
0001
approximations
probabilities
75
shared
bimodal
853
equiprobable
lightly
extrapolating
feasibly
overloads
exceedingly
iyengar
sanity
happen
likewise
excess
truncating
informatics
sharper
clarity
geometric
negative
stochastically
obtainable
839
recursions
plot
markov
quantity
jack
instances
arrive
improvement
calculated
medicine
shift
readily
modeled
serviced
encouragement
laplace
summand
invert
noteworthy
striking
truncation
nl
queued
indebted
specialize
integers
predict
middle
wherever
college
accurately
curves
definitions
wasted
anticipated
recursive
measures
potentially
exact
seldom
capacity
keeping
derivable
attain
communications
kth
transferring
confusion
load sharing
of jobs
jobs that
sharable jobs
of sharable
1 queue
j c
traffic intensity
queue size
random variable
job sharing
sharing coefficient
z transform
of eg
for load
m 1
sites in
a site
sites are
1 case
site is
queuing models
m x
x m
the probability
vs r
underloaded sites
the job
distribution of
m m
jobs is
eg and
eg vs
the queue
the traffic
probability distribution
p g
mean number
r i
potential for
can usefully
overloaded sites
theorem 1
jobs in
following expression
s i
all sites
of g
i i
be transferred
size distribution
each site
q i
i n
1 i
usefully be
conditional random
of overload
p ol
p ul
independent instances
from definition
plots of
of load
general formula
the overload
the mean
the z
distributed system
load balancing
i l
from observation
i independent
m d
for 1
site s
the potential
denoted as
of sites
the distribution
across sites
overload and
definition 13
sums of
the sites
random variables
the system
overloaded site
i sites
bulk size
ul and
of underload
job arrival
negative binomial
balancing success
rommel s
underload in
ith power
a i
in m
1 b
system parameters
l h
g 0
queuing model
transform of
n l
distributions of
are normal
of r
the random
h increases
of overloaded
exact expressions
is underloaded
intensity for
normal or
and service
expression for
g k
1 l
system performance
the m
observation 7
and plotted
sharing is
coefficient is
eg is
size at
expectation of
be shared
probability of
overall system
of underloaded
three queuing
are plots
j sites
n ul
through figure
variable q
job transfer
usefully transferred
il k
important queuing
success plbs
both eg
particular queuing
and underload
n ol
or underloaded
queuing disciplines
total underload
c vs
0 observation
transferred jobs
i il
or overloaded
size random
all i
its probability
in theorem
formula for
various combinations
the conditional
d 1
is overloaded
are overloaded
observation 8
following expressions
overloaded then
be usefully
distributed computing
transferred from
system designers
l and
we obtain
probability distributions
queue is
definition 12
expression in
of j
the expectation
sites the
transform methods
negative random
system denoted
a increases
be overloaded
of queuing
case than
the queuing
transferred across
and h
service time
arrival rate
the sum
i 1
exact expression
or zero
plotted against
number of jobs
of jobs that
jobs that can
of sharable jobs
x m 1
number of sharable
distribution of g
m 1 queue
m 1 case
m m 1
m x m
potential for load
job sharing coefficient
the traffic intensity
the queue size
for load sharing
theorem 1 b
sites in the
the job sharing
in the system
1 i n
the z transform
probability distribution of
z transform of
the m m
sharable jobs is
l and h
the mean number
the potential for
mean number of
m d 1
the probability distribution
the following expression
queue size at
eg vs r
can usefully be
queue size distribution
p g k
n 1 l
all i 1
for 1 i
the random variable
the distribution of
for p g
site s i
i 1 i
a site is
of eg vs
eg and j
independent instances of
of i independent
the conditional random
that can usefully
j c is
jobs in the
s i is
that a site
and j c
1 queue is
in theorem 1
of the traffic
1 i i
the distributed system
load balancing success
its probability distribution
traffic intensity for
probability of load
underload in the
for j c
expression in theorem
sharing coefficient is
of n l
i independent instances
in m x
in m m
ith power of
the ith power
plots of eg
distribution of the
overall system performance
at each site
is the random
of load balancing
i and s
all sites are
i l k
load sharing is
across sites in
a i l
of j c
values of r
of system parameters
a general formula
general formula for
of jobs in
i are independent
sums of the
sum of i
p a i
the number of
the expectation of
the probability of
probability distributions of
l h and
of the queue
various combinations of
r i and
compute the probability
a i i
expectation of the
in the m
to system designers
conditional random variable
transferred across sites
size random variable
important queuing models
a increases the
using this expression
sites are normal
d 1 queue
as h increases
following expression i
0 l h
calculated from definition
the job arrival
including a general
a 0 75
normal or underloaded
overload and underload
the total underload
n l h
ul and p
for various combinations
from definition 12
load sharing in
be usefully transferred
this random variable
the overload and
random variable q
the system denoted
both eg and
p g 0
each site is
usefully be shared
of load sharing
c vs r
j c vs
size at each
i sites are
transferred from s
and p ol
from the probability
sharing in distributed
p ul and
need for load
are plots of
q i l
arrival and service
small or zero
0 for 1
balancing success plbs
queue is given
total underload in
job arrival rate
usefully be transferred
for its probability
from definition 13
the sum of
of the sum
be transferred from
the expression in
the probability distributions
expression for the
obtain the following
theorem 1 a
in a distributed
can be usefully
negative random variable
1 queue the
the queuing model
of sites in
exact expression for
distributed computing system
the following expressions
k i i
the sums of
the distributions of
we obtain the
an exact expression
definition 13 for
at a site
g n 1
for n i
non negative random
of the sites
computing the distribution
the r i
distributed computing systems
if q i
distributions of the

corpus/krapavin2000-test/631167.txt
freshness
harmonicity
atg
utilization
periods
producer
consumer
tasks
period
deadlines
offsets
sampler
pruning
deadline
timing
correlation
separation
correlated
offset
inputs
intermediate
solver
chain
foreach
task
precedence
constraints
lcm
priority
producers
scheduling
channels
consumers
constraint
preemptive
feasible
asynchronous
schedulability
restructuring
rates
tightened
10ms
jt
buffer
allowable
dinesh
ramanathan
phi
40ms
outputs
rajesh
periodic
reads
tightly
seongsoo
dasdan
gerber
assignment
window
feasibility
chains
external
engineers
succ
harmonic
replication
writer
sampling
gcd
possess
bottlenecks
schedulable
writes
read
samples
correlate
subsystems
shadow
cpu
tight
driven
derivation
saksena
30ms
7619
ladan
d2
polytope
requirements
channel
successors
elimination
sampled
rate
macros
possesses
gupta
slack
ingredients
esterel
avionics
minsoo
braberman
venture
80ms
fabricated
blocking
schedule
imposed
slots
ali
automation
merging
compiler
delivered
rtl
blown
ipc
linearities
synthesizing
kang
constrains
scheduler
buffers
guaranteeing
dm
circularly
confluence
ryu
codesign
solutions
tool
outputting
revisit
looser
stamps
jx
d1
rendered
earliest
handful
mandate
dispatching
drift
delay
tighten
vastly
aggressively
temporally
eliminating
exclusively
head
impose
dong
instantiates
parent
latest
allocation
item
thumb
eliminated
reactive
child
restrictions
outgoing
burns
subgraph
simplification
perhaps
calibration
slicing
objective
imposing
buffered
constituent
replicating
jeff
constraining
bill
predecessors
hong
designs
replicate
accommodate
transformed
analogue
robotics
42
deriving
constrained
merged
restricting
greatest
instantiate
hopefully
coupled
denoting
nonlinear
temperature
synthesis
task graph
end constraints
to end
end to
intermediate constraints
separation constraints
freshness constraints
real time
a task
the atg
the harmonicity
constraint solver
i s
producer consumer
task i
t i
offsets and
correlated inputs
the freshness
end requirements
each task
the constraint
the intermediate
timing constraints
and deadlines
o i
correlation constraints
the periods
constraint set
task s
the task
the tasks
solution space
the t
and offsets
restructuring tool
period variables
atg s
freshness and
constraints are
the utilization
w 4
deadlines and
task set
time systems
external inputs
and separation
assignment algorithm
data object
output y
a producer
the sampler
variable elimination
different rates
consumer pair
tightly correlated
output tasks
parent pruning
sampler s
lcm child
output task
period assignment
asynchronous task
child pruning
gcd parent
constraint derivation
u min
buffer allocation
period t
hard real
y 1
the producer
the end
a period
f y
our example
constraints on
the constraints
dinesh ramanathan
static priority
correlated data
utilization bound
task periods
a freshness
example application
the period
a solution
correlation and
4 s
delivered at
execution time
d i
tasks which
offset and
ffl a
search space
linear constraints
ensure that
feasible set
fully periodic
from slots
consumer task
timing parameters
slots 0
harmonicity assumptions
pruning takes
succ i
harmonic chain
d2 6
solution strategy
intermediate task
virtual sequence
harmonicity constraints
sampler task
harmonicity relationship
deadline variables
constraint assignment
chain merging
output separation
intermediate tasks
foreach t
free variables
the derived
of constraints
the precedence
constraints c
t 4
inputs and
constraints may
and writes
constraints for
compiler tool
min u
following ingredients
maximum execution
s period
derivation algorithm
rajesh k
k gupta
timing driven
seongsoo hong
candidate solutions
jt 2
ali dasdan
the window
of intermediate
the deadline
the system
the consumers
compute y
minimum rate
the offsets
phi i
object d
s l
design automation
input x
to c
the feasible
constraints which
and deadline
simple fact
outgoing edge
on task
reduced set
cpu utilization
periods for
a utilization
feasible schedule
the search
the scheduler
the chain
is delivered
tasks 4
are sampled
integer solutions
small example
d1 d2
algorithm fails
fixed priority
as possible
set c
constraints the
tasks and
reads and
tasks are
the consumer
the shadow
time tasks
deadline and
the deadlines
the separation
constraints and
to y
assign the
with period
deadline for
time scheduling
the buffer
the head
end to end
to end constraints
the end to
t i s
the constraint solver
the t i
offsets and deadlines
a task graph
to end requirements
the intermediate constraints
i s and
o i s
for each task
and d i
s and d
real time systems
d i s
the task graph
constraint set c
hard real time
producer consumer pair
asynchronous task graph
of the atg
lcm child pruning
gcd parent pruning
the separation constraints
deadlines and offsets
the atg s
solution to c
period t i
the example application
for the t
3 5 6
set of constraints
i s we
data object d
external inputs and
the harmonicity relationship
intermediate constraints and
offset and deadline
the constraint derivation
the freshness and
d1 d2 6
s period is
set of intermediate
window of execution
tasks 4 and
the assignment algorithm
the o i
y is delivered
and deadline variables
is delivered at
constraint derivation algorithm
from slots 0
a minimum rate
freshness and separation
harmonic chain merging
the search space
task graph with
to compute y
the utilization bound
f y 1
a task i
on the utilization
the constraint set
rajesh k gupta
the following ingredients
maximum execution time
at this point
as possible and
inputs and outputs
the window of
a producer consumer
a small example
and a maximum
reads and writes
for the intermediate
non linear constraints
in a hard
through the system
a hard real
linear constraints on
of the task
finding a solution
values for the
real time tasks
real time scheduling
read and write
much as possible
interval of time
x to y
minimum rate of
precedence requirement is
the period variables
task periods and
atg s structure
end requirements we
within t when
intermediate constraint assignment
to end timing
of intermediate constraints
separation constraints will
delivered at time
dasdan dinesh ramanathan
the buffer allocation
and deadlines and
utilization based pruning
on task periods
sampling of x
of the periods
windows for each
straightforward priority assignment
set of asynchronous
a single outgoing
a single cpu
end requirements into
o i and
single outgoing edge
base clock rate
from the harmonicity
period variables and
running at different
sampler s l
edge in figure
constraint w 4
2 jt 1
real time designs
the intermediate components
consider a task
t 2 jt
correlation and allowable
original task graph
jt 2 and
the intermediate tasks
of efficient scheduling
the derived constraints
burns et al
a straightforward priority
i s hence
in the analogue
if a task
s o i
separation constraints for
different rates and
intermediate constraints c
correlation constraints may
u min u
then the x
each output task
be subject to
foreach t l
the harmonicity assumption
periods offsets and
each task s
victor a braberman
be if y
tightly correlated inputs
denote this constraint
1999 dinesh ramanathan
this simple fact
systems external inputs
real time producer
the analogue to
the output task
the last intermediate
the periods deadlines
end constraints are
deadline and period
the tasks that
thus the separation
with period t
search time required
reader may use
is then re
producer consumer pairs
a maximum rate
for example y
and separation constraints
graph and b
example application from
y latest y
freshness constraints the
ali dasdan dinesh
output tasks 4
n dimensional polytope
task s period
priority based scheduling
sampler task s
re submitted into
s sampling of
after the buffer
the entity relationships
periods deadlines and
solved for the
child pruning in
freshness and correlation
transmission time is
the windows for
constraint solver in
for the o

corpus/krapavin2000-test/631169.txt
timing
cache
wcet
instruction
wcta
reservation
pipelined
block
misses
caches
pipeline
miss
risc
wcets
schema
tail
references
reference
hits
struct
interference
worst
rd
instructions
md
wctas
processors
hit
alu
overestimation
analyzer
phi
head
execution
loop
pruned
pruning
live
program
blocks
preempted
seongsoo
preemptive
scenario
accurately
succeeding
retargetable
sp
fig
exp
friedhelm
ferdinand
engblom
jakob
ermedahl
80c188
stappert
preceding
processor
policy
calculating
compile
constructs
overlapped
lyul
wmin
r3000
fidge
lee
preemption
assembly
tasks
benchmark
board
mapped
surrounding
mips
cycle
contents
scheduling
intra
prediction
max
tight
concatenate
sang
revised
timer
wp
inherits
pipelining
notices
fetched
addresses
cached
sheayun
roychoudhury
procedurally
abhik
whalley
idt7rs383
xianfeng
harmon
jungkeun
wilhelm
dongkun
theiling
acsr
ffi
nov
memory
calculated
arc
overlap
sigplan
kim
path
nop
jihong
concatenates
opcode
fpu
minsoo
tulika
rectify
paths
ranges
mm
programs
associative
statement
predicted
prune
limitation
calculation
schneider
tables
safe
loose
andreas
christian
formula
accurate
estimation
effects
burst
lw
hazards
colin
ryu
gmez
accesses
ij
predicting
analyzing
ansi
variation
cycles
loaded
hayes
reinhard
displaced
timers
superscalar
compiler
static
enumerates
henrik
tighter
accounted
tool
ignoring
resumes
div
dirty
mitra
concatenation
predictions
chip
suffers
voltage
stage
write
automation
analytical
weight
refine
associativity
null
task
stack
bounds
liu
shin
bb
ian
longest
infeasible
delay
penalties
program construct
the timing
first reference
the cache
case execution
timing information
timing schema
timing analysis
execution path
pipelined execution
reservation table
cache block
last reference
instruction block
execution time
worst case
the wcet
of pipelined
timing formula
wcet bounds
real time
data caches
t max
reference i
cache memory
the instruction
risc processors
time systems
the wcta
struct pipeline
wcets of
the phi
cache timing
the wcets
w 2
basic block
memory block
cache miss
pipeline cache
phi operation
original timing
execution scenario
case timing
timing tool
the worst
w 1
timing analyzer
wcet of
program constructs
miss in
reservation tables
or misses
the program
of cache
loop statement
write back
cycle mean
hits or
block in
maximum cycle
timing effects
preceding program
extended timing
the loop
for risc
execution and
and cache
reference to
proposed technique
wcet analysis
the reservation
execution times
write access
live ranges
the execution
task interference
succeeding program
intra task
information w
alu rd
references whose
s wcet
case scenario
each program
the write
in w
instruction cache
pipelined processors
basic blocks
an instruction
rd if
this timing
the succeeding
cache contents
memory blocks
be pruned
of instruction
cache misses
reference and
time bound
block is
data cache
timing variation
revised timing
if md
history sensitive
ffi tail
loop timing
block address
hit in
cache in
a cache
at compile
of tasks
a tail
to b
a timing
information of
call graph
w 3
p i
of instructions
write through
misses of
simple time
same cache
a program
d i
execution paths
preemptive scheduling
benchmark programs
time of
analysis technique
i j
compile time
cache the
cache and
b 4
each instruction
for real
instruction references
of wcet
the hits
construct is
construct in
path p
policy is
element in
p j
instruction caches
set associative
direct mapped
with path
weighted directed
s head
cache hits
analysis for
b 2
timing behavior
the proposed
s first
cache partitioning
ffi head
write run
our extended
pipelining effects
the wctas
whose hits
schema approach
timing abstraction
through policy
wp n
accurately accounted
wcta can
program syntax
mean weight
a wcta
pipelined processor
timing variations
md fig
jakob engblom
write accesses
a reservation
two reservation
one cache
block addresses
30 overestimation
exp s
back policy
friedhelm stappert
andreas ermedahl
wcet estimation
christian ferdinand
wcta wp
block fetched
wcta of
fetched on
differ depending
measured execution
head and
worst case execution
in the cache
of pipelined execution
the program construct
case execution path
pipelined execution and
real time systems
the worst case
timing analysis of
case execution scenario
the wcets of
the timing information
cache timing information
the original timing
execution and cache
reference to b
pipeline cache timing
original timing schema
and cache memory
struct pipeline cache
d i j
worst case timing
execution time of
each program construct
timing information of
of data caches
the phi operation
hits or misses
miss in the
the first reference
the execution time
with each program
first reference to
for risc processors
the wcet of
the instruction block
timing effects of
the maximum cycle
first reference i
maximum cycle mean
extended timing schema
the preceding program
last reference i
w 2 s
the timing analysis
the proposed technique
time systems v
the reservation table
a program construct
analysis of data
the timing effects
of the succeeding
for the timing
timing information w
the timing formula
and last reference
cycle mean of
w 1 s
timing formula of
s first reference
effects of pipelined
program construct in
succeeding program construct
reference and last
the succeeding program
be the worst
program construct is
the loop statement
first reference and
case execution time
of the loop
can be pruned
to b 2
the cache in
the cache and
into the cache
sequence of instructions
at compile time
loop timing analysis
simple time bound
of timing information
bit is set
the cache contents
in the wcta
with path p
analysis of pipelined
write access is
the cache block
alu rd if
execution path that
timing information associated
preceding program construct
revised timing schema
in the reservation
of the phi
this program construct
wcets of tasks
2 s first
same cache block
wcet bounds of
this timing formula
in w 2
or misses of
rd if md
a simple time
the timing tool
of the program
for real time
the timing schema
in w 1
the same cache
mean of g
a cache miss
execution path of
construct is a
weighted directed graph
hit in the
of cache misses
path p i
case timing analysis
block in the
of the preceding
reference to the
systems v 17
information associated with
block can be
s execution time
references whose hits
timing schema the
about the factors
instruction block references
best case scenario
cache memory we
schema the timing
within a maximum
fetched on a
t max is
cache block in
history sensitive nature
timing schema approach
the timing variation
whose hits or
burst of cache
instruction block addresses
each instruction block
will differ depending
of cache miss
our extended timing
a loop statement
write back policy
of instruction caches
path not necessarily
and pruning operations
wcta wp n
the data cache
of about 30
program construct this
the wcet bounds
program construct the
maximum of about
s last reference
write through policy
in a wcta
reference i else
accurately accounted for
accessed in w
is a tail
the extended timing
time bound in
the hits or
reservation table in
case timing abstraction
timing analysis technique
of wcet analysis
program constructs can
execution scenario of
the write through
instruction block can
measured execution times
the program syntax
exp s 1
what the surrounding
scenario for w
b 2 will
each cache block
about 30 overestimation
a reservation table
inter task interference
two reservation tables
due to write
reference i w
cache block is
cache simulation approach
differ depending on
i w 2
the history sensitive
block fetched on
path that might
worst case scenario
of the instruction

corpus/krapavin2000-test/631174.txt
conversion
units
meter
radar
conversions
dimension
meters
numeric
kilogram
glisp
si
dimsizes
simplifyunit
unit
convert
mass
coercion
altitude
dimvals
kilograms
dimint
quantity
lisp
aircraft
vip
simplification
quotient
foot
pound
feet
compiler
loveman
relpos
joule
karr
force
dimbias
decimal
measurement
converted
numerator
newton
diff
atlas
novak
integer
checking
temperature
books
substance
multiplication
eme
pounds
gasoline
utm
gallons
watt
volt
sigma4
quantities
denominator
unequal
arithmetic
radians
dimensions
energy
factors
powers
shaft
syst
gldefun
money
reuse
languages
programmer
integers
sz
idl
legitimate
field
encoding
composite
synonyms
vectors
overflow
acre
centimeter
cunis
kilowatt
slug
3048
metrication
dimensionless
comet
cutm
gev
horvath
sigma9
ounce
horsepower
glvar1621
newtons
parsec
incorrect
subtraction
symbolic
sqrt
converting
generic
lists
expansion
east
triangle
ada
multipliers
encoder
tables
nil
motion
compile
multiplied
constants
angle
physical
utexas
nano
flattened
inch
synonym
english
procedures
language
unusual
syntax
pulse
simplified
physics
fig
mega
kinematics
floating
automatic
arguments
division
factor
multiply
menu
book
ontology
pi
atm
abbreviations
specification
compiled
software
base
tradition
transmission
scalar
source
accuracy
ftp
hour
packages
kg
strict
dimensional
verified
particle
gordon
dividing
measurements
validating
product
bit
sorted
allowable
runtime
requested
vector
returned
hypotenuse
calculators
raya
101325
luminosity
80000000
overlook
defderivedunits
cliche
glcoerceunits
tarun
nanosecond
fahrenheit
farad
schulz
hilfinger
tablespoons
7961
ampere
of units
conversion factor
the conversion
unit conversion
second second
unit is
dimension integer
conversion factors
the radar
dimension vectors
dimensional analysis
units of
the dimension
a dimension
units in
base units
the unit
the units
of measurement
units are
the aircraft
dimension integers
conversion is
units that
a unit
dimension of
if unit
source unit
dimension vector
meter second
si system
unit conversions
unit to
of unit
unit that
quotient of
unit for
units real
desired unit
numeric conversion
unit simplification
simple unit
unit system
conversion of
units such
to convert
units and
units is
units to
the glisp
input unit
units as
a numeric
the si
karr and
time diff
to meters
8 vector
loveman 15
pound force
and loveman
meter meter
conversion from
the numeric
and denominator
generic procedures
coercion of
an 8
a quotient
and unit
numerator and
and conversion
integer encoding
unit can
standard unit
programming languages
a quantity
dimension checking
corresponding dimension
real meters
a conversion
include units
kilogram meter
base quantities
composite unit
automatic coercion
altitude radar
aircraft from
unit checking
bit integer
the integer
the compiler
of dimension
the source
units we
units the
unit the
for conversion
be converted
of base
dimensions of
and units
mass to
is legitimate
field size
any combination
units for
in fig
the vector
as part
numeric values
unit it
factor for
the type
simplification of
checking and
factor f
dimsizes i
unit systems
units integer
same unit
si units
convert any
numeric type
abstract unit
unit must
with numeric
hand argument
convert units
goal system
such units
new unit
10 gallons
or quotient
simplifyunit joule
mass units
from mass
glisp language
numeric quantity
meter the
is meter
kilograms to
numeric constant
two products
eme international
x units
dimint v
altitude of
equivalent combination
radar angle
simple units
goal units
product lists
syst eme
in lisp
conversion and
32 bit
converted to
the input
software reuse
this unit
units must
conversion algorithms
any equivalent
8 vectors
type specification
factor and
an arithmetic
in programming
the numerator
of conversion
generic procedure
each quantity
quantities and
for simplification
a product
a compiler
algorithms are
per unit
a field
an error
unit of
data types
for dimension
mass and
other units
and goal
and dimension
specified for
the user
that include
one unit
result type
addition subtraction
output unit
quantity in
a desired
the dimensions
powers of
of types
the conversion factor
units of measurement
the dimension of
second second second
the input unit
of units is
unit that is
of the radar
the source unit
units such as
conversion of units
unit is a
units that are
an 8 vector
conversion factor for
if unit is
system of units
combination of units
conversion factor and
units as part
of units in
and loveman 15
karr and loveman
numeric conversion factor
a dimension integer
meter second second
numerator and denominator
the conversion factors
the units of
a quotient of
of units of
units real meters
units is the
a dimension vector
per unit for
the integer encoding
one unit to
the si system
of base units
checking and conversion
the unit conversion
unit to another
conversion factor f
conversion factor is
quotient of units
dimension of a
unit can be
a unit is
unit conversion is
the standard unit
to a desired
input unit is
as part of
any combination of
unit for example
32 bit integer
unit of the
shown in fig
the numerator and
the unit of
the same unit
units in programming
or quotient of
inclusion of units
of units to
field size of
coercion of units
of units are
product or quotient
the conversion is
of unit conversions
conversion from mass
to any equivalent
the goal system
factor and dimension
convert any combination
quotient of two
any equivalent combination
terms of base
of two products
of a quotient
if the conversion
a unit system
unit checking and
syst eme international
altitude of the
conversion is legitimate
and goal units
automatic coercion of
combinations of units
for dimension checking
units to any
of the aircraft
the dimension integer
kilograms to meters
such units are
dimension vectors are
the glisp language
kind of unit
the desired unit
unit is meter
units we have
of the source
in programming languages
of a unit
units in the
of data types
of generic procedures
conversion factors and
source and goal
quantity in the
of the conversion
for simplification of
speed of light
a unit that
of units and
a field size
the type of
by the compiler
of the numeric
of the integer
number of units
in terms of
of the result
a variable that
type of the
the dimensions of
units of the
of the motion
dimension of the
that are used
on software engineering
conversion and one
making a new
the goal unit
for symbolic simplification
are dimension vectors
meter meter second
dimint u dimint
by hardware devices
expressed in si
and denominator product
sin function may
meter meter kilogram
conversion is a
conversion factor of
international system of
quantities and units
integer 2 pi
for conversion and
atlas language 5
source unit and
of unit simplification
and temperature and
while the conversion
gallons of gasoline
time diff aircraft
between mass and
a simple unit
unit conversion may
one scalar operation
to convert any
a composite unit
units when necessary
x units real
multiply or divide
new unit from
languages allow coercion
of this triangle
units for example
a new unit
use of units
base units of
that are by
unit for conversion
the aircraft from
units the dimension
part of data
diff aircraft altitude
is meter second
from one unit
left hand argument
in si units
example the dimension
altitude radar altitude
b if unit
subtraction and comparison
representation allows a
the range sigma4
result of nil
real meters y
of units we
by multiplication and
of dimension integers
the atlas language
mass units to
source unit to
half the input
conversion may also
the syst eme

corpus/krapavin2000-test/631185.txt
tla
diagram
diagrams
hin
outi
predicate
hx
action
sem
init
infinitely
phi
pi
psi
wf
unchanged
fairness
yi
formula
enabled
specification
hai
increments
asserts
iff
hn
delta
leaves
hm
pictures
inv
formulas
pc
labeling
999
upsilon
stuttering
equals
sf
muller
disjunction
omega
draw
transition
semaphore
au
actions
khdri
desharnais
ridha
frappier
assigns
originating
implication
mili
predicates
picture
forever
semantically
temporal
ng
fig
flowchart
formalisms
jules
labeled
inputs
logic
incremented
specifications
primed
events
oe
asserting
arrows
transitions
invariance
ti
nat
leave
operators
proofs
hs
ali
pn
complementary
marc
node
circuit
ae
edge
safety
iii
lusini
specificationand
dillon
priming
gedanken
plicitly
innumerable
2init
thimbleby
leisurely
2inv
aquila
nondisjoint
7init
correcteven
nonboolean
kutty
actiondiagram
complements
aspects
expressive
satisfying
views
invariant
conjunction
purely
spaghetti
mealy
inv1
bulleted
melliar
ramakrishna
tochi
vicario
increment
label
rigid
proving
describing
interpretation
eter
695
unprimed
moser
agrams
708
conjoining
harold
understand
false
infinite
aid
assertion
326
888
infix
ous
drawn
labels
rigor
formu
quotes
conveyed
indicated
iv
larly
specifica
simi
dia
meaning
ffl
interface
traditional
scenarios
2f
param
sequential
boolean
suffices
310
236
dition
asserted
homomorphism
equivalences
tosem
quantifier
visual
graphical
tuples
friendly
ditions
las
conjunct
confusing
imply
differs
usability
element
moore
illustrate
synchronization
else
precise
string
181
repeatedly
predicate action
action diagram
tla formula
c element
action diagrams
hx yi
diagram of
y unchanged
of hin
pi c
phi phi
infinitely many
a predicate
a behavior
increments x
hai v
a diagram
the diagram
a state
hin i
corresponding tla
leaves y
i outi
a tla
outi for
and leaves
wf hx
hm 1
tla formulas
steps occur
i hx
hin outi
state function
an action
fairness condition
input c
the predicate
in tla
that increments
asserts that
m hx
transition diagrams
behavior iff
1 step
diagrams are
is enabled
for pi
true of
the formula
the fairness
state satisfying
step that
diagram is
input i
node n
the specification
i w
else leaves
of tla
these diagrams
specification psi
init pi
many hai
w steps
v steps
many hn
specification pi
initial nodes
n input
ffl to
diagram for
in i
are infinitely
state predicate
is true
hn 1
yi is
complete specification
ii every
that infinitely
a specification
m 1
to describe
enabled in
state transition
6 out
diagrams that
of figure
unchanged or
omega omega
diagrams to
of psi
step or
init is
a step
x by
m inv
upsilon r
init phi
2 outi
fairness conditions
yi step
enabled iff
tla specifications
hin 1
sem sem
s assigns
yi steps
purely state
incremented infinitely
predicates labeling
init c
diagram are
complementary views
phi upsilon
diagrams can
yi m
under stuttering
v sem
provide complementary
hn 2
describe aspects
muller c
oe ae
i equals
unchanged and
pi 2
every step
an n
both x
many steps
by one
temporal logic
for psi
diagrams with
p sem
implies 2
another predicate
leaves both
false of
the tla
of hx
tla the
with domain
step is
of states
1 i
x and
and y
n step
the disjunction
one and
an m
or else
equal a
not enabled
assigns to
ae oe
diagrams in
s iff
next state
or false
in process
diagrams of
2 m
possible state
2 input
originating at
true or
each node
to equal
infinitely often
o for
state based
steps or
state s
y by
v is
its environment
delta au
khdri ali
asserts of
taking infinitely
correct description
equals out
constant operators
specification figure
one plus
unchanged since
tla differs
delta represented
element together
formula asserts
output step
semantically it
jules desharnais
tla there
formula fig
ridha khdri
psi phi
predicate action diagram
a predicate action
action diagram of
predicate action diagrams
of a behavior
diagram of hin
phi phi phi
and leaves y
corresponding tla formula
hin i outi
the predicate action
increments x by
the corresponding tla
input c element
leaves y unchanged
wf hx yi
one and leaves
i hx yi
that increments x
x by one
hm 1 i
m 1 step
1 i hx
is true of
by one and
the fairness condition
by the diagram
diagram of figure
state transition diagrams
of hin i
an n input
for pi c
m hx yi
the c element
a behavior iff
a state function
outi for pi
a tla formula
a state satisfying
aspects of a
true of a
many hai v
unchanged and iii
hai v steps
one that increments
infinitely many hai
i outi for
in i 6
1 i w
that infinitely many
init pi 2
i 6 out
of hin outi
ii every step
hn 1 i
an m 1
hx yi is
i w steps
or else leaves
infinitely many hn
there are infinitely
are infinitely many
x and y
all the inputs
1 in 2
infinitely many steps
a state predicate
both x and
a 2 input
hai v is
n input c
in 2 outi
an n step
hx yi m
complementary views of
the specification psi
describe aspects of
purely state based
x and leaves
a a predicate
1 step is
the tla formula
hx yi steps
phi upsilon r
provide complementary views
is enabled iff
a step that
leaves both x
hx yi step
phi phi upsilon
tla formulas are
implies that infinitely
step is either
an a step
y by one
2 i w
the predicates labeling
the complete specification
diagrams can be
muller c element
2 input c
and y unchanged
hin 1 in
specification pi c
to describe aspects
unchanged or else
hn 2 i
is true or
false of a
step is one
logic of actions
originating at node
2 m u
or false of
pi 2 m
ae oe ae
oe ae oe
to describe a
is a predicate
function with domain
an action that
a diagram is
state for example
in a state
true or false
action that is
each node n
b the corresponding
temporal logic of
an action a
c 1 1
at node n
the temporal logic
an action is
is enabled in
from a state
pair of states
we take as
for each node
described in 3
iff it is
x or y
transition diagrams are
action diagram for
tla differs from
state s iff
many hn 2
c element and
delta represented by
a correct description
is a diagram
khdri ali mili
jules desharnais marc
tla specifications are
value that state
many steps occur
how diagrams are
one plus the
which are analogous
a muller c
plus the value
formula of figure
draw diagrams of
yi m 1
state action n
enabled in other
invariant under stuttering
diagrams are used
to provide complementary
is incremented infinitely
v a asserts
c element together
as a diagram
edges originating at
v steps or
action is true
a diagram for
for a specification
s assigns to
of sequential scenarios
the formulas defined
to illustrate proofs
correct description of
a tla specification
explain the specification
step that starts
state satisfying in
ffl to illustrate
tla formula fig
the formula delta
of condition 3
where 1 in
that m inv
a asserts that
hin outi for
many hn 1
tla formula of
integration of sequential
the diagram are
this formula asserts

corpus/krapavin2000-test/631204.txt
views
pipe
reuse
deltay
glisp
p1y
ls1
circle
correspondences
eqn
deltax
oop
p2y
generic
abstract
p2x
p1x
specialized
radius
procedures
mkv
translation
segment
xmas
lisp
diameter
cone
wrapper
var
atan
buttons
compiler
compilation
deleting
gldefun
obj3
compiled
interface
vars
equations
xfers
setf
leftof
menu
encapsulation
languages
graphical
diagram
reused
phi
solved
unsolved
idl
specialization
float
mouse
transfer
slope
polar
2b
cos
tuple
software
conversion
expt
lileanna
formats
basis
transformational
storing
functional
gries
sqrt
translate
representations
fig
deleted
transformations
mathematica
t7
2a
algebraic
documenting
superclass
emulates
ml
correspondence
units
dep
modula
code
diagrams
tan
p2
stored
references
reusable
runtime
p1
theta
inside
1415926535897931
lil
unchangeable
christmas
sinapse
glambda
miranda
create
object
compile
independence
measurement
interfaces
scientific
message
fields
manipulations
storage
polya
implementer
biggerstaff
kids
specify
polygon
algebra
symbolic
parameterized
store
inherited
exit
creation
generics
accomplishes
read
typed
language
oriented
calling
angle
clicking
program
field
viewing
cartesian
record
selects
modules
enter
versions
encapsulates
rigidity
t5
broker
mathematical
sin
standards
inhibits
functors
produced
isomorphism
created
inefficient
dependency
button
programming
saved
clean
2d
compiling
checking
reusability
ontology
conformance
interoperability
equation
pi
everyone
warning
ordinary
solver
human
sharing
tree
subexpression
ls
standardization
someone
repeating
understand
ada
specialize
items
module
operate
packages
denotational
reusing
target
draws
basis variables
abstract type
application data
basis variable
application type
the abstract
the view
a view
generic procedures
line segment
generic algorithms
the application
deleting eqn
software reuse
inside diameter
var defined
transfer variables
pipe as
abstract data
view type
glisp compiler
the basis
each basis
2b deleting
generic procedure
of views
abstract variable
a pipe
the glisp
of generic
the correspondences
the user
a circle
equation set
as circle
from correspondences
xmas tree
2a solved
solved eqn
the equation
of basis
reuse of
through views
the generic
type and
procedure that
data type
a line
code that
a procedure
views from
desired variable
p pipe
ls1 data
circle p
symbolic algebra
the ls1
solved variables
specialized versions
each correspondence
of measurement
data types
the pipe
the graphical
an abstract
graphical interface
equation is
data translation
our system
an application
reuse by
independence properties
variables that
the inside
correspondences between
in line
the equations
deltax deltay
with views
a ls1
in oop
oriented functional
2d deleting
leftof distance
enter var
exit vars
transfer variable
1 enter
store into
deltay p2y
p2y p1y
deltay deltax
length cos
wrapper objects
using views
setf get
deltay length
4 exit
views can
specialization of
object oriented
graphical user
a cone
specialized version
data structure
a generic
type as
user interface
data representations
and independence
generic algorithm
equations for
be reused
expression tree
all basis
new equation
deleted tuple
view is
equations that
to reuse
variables are
an equation
units of
variable is
if feature
were solved
type the
procedures to
translation of
interface is
variables of
radius is
translation to
of data
the transfer
feature is
be stored
computed this
abstract types
correspondence is
correspondences are
software engineering
tuple variable
type pipe
application types
eqn slope
transformational programming
each abstract
theta 2a
produces efficient
deltax length
eqn deltay
eqn deltax
into basis
be inefficient
parameterized programming
atan deltay
3 repeating
line compilation
user obtains
repeating step
achieve reuse
length sin
goal type
which views
from basis
basis equations
obj3 is
pipe divided
ordinary programming
storing into
correspondences using
deltax p2x
p2x p1x
to translate
a diagram
the specialized
other languages
expected by
views is
oriented programming
of object
specify a
the diagram
read of
program development
is compiled
procedures the
code is
to specify
data can
the radius
defined for
be specialized
between an
is produced
by 2
be specified
algorithms that
type a
the abstract type
the application data
the application type
the basis variables
of the abstract
the basis variable
a line segment
2b deleting eqn
each basis variable
of the application
of the basis
the glisp compiler
units of measurement
an application type
2a solved eqn
the inside diameter
pipe as circle
translation of data
of basis variables
divided by 2
an abstract type
the generic procedures
and independence properties
the view type
specialized versions of
basis variables and
a basis variable
the abstract data
of generic algorithms
storage and independence
the transfer variables
abstract data type
of generic procedures
specialization of generic
as a circle
a generic algorithm
set of basis
variables of the
of the generic
from the application
for a line
the desired variable
deltay p2y p1y
application data structure
equation is deleted
through the view
generic algorithms that
views from correspondences
2d deleting eqn
ls1 data structure
enter var defined
all basis variables
1 enter var
abstract type a
the equation set
4 exit vars
application data and
application type and
object oriented functional
by the glisp
basis variable v
if feature is
to the application
the storage and
that are used
of a generic
data type and
the generic algorithms
views can be
a read of
the graphical interface
the equation is
graphical user interface
expected by the
data representations and
variables that are
is computed this
a specialized version
a procedure that
to be reused
object oriented programming
references to the
specialized version of
and the abstract
variable of the
a cone the
as a cone
be reused for
from basis variables
each correspondence is
for each basis
repeating step 2
application data a
the pipe divided
a strongly typed
to achieve reuse
application type as
application data type
type the user
in line compilation
interface is self
pipe divided by
atan deltay deltax
having to understand
clean separation between
to reuse a
type the view
versions of generic
deltax p2x p1x
is self documenting
equations for computing
an expression tree
basis variable in
3 repeating step
inside diameter of
the goal type
the new equation
of a pipe
a ls1 data
theta 2a solved
abstract type the
generic procedures the
variable is added
equation set is
some generic procedures
the user obtains
that is defined
a list of
code that is
in terms of
described in this
variables and equations
of the pipe
a clean separation
software reuse by
data structure from
computed this is
that is produced
by specialization of
variable v i
of application data
view of a
abstract data types
appear to be
by 2 the
tree as a
the view is
type of object
a generic procedure
a view is
the correspondences are
such a procedure
of the view
of a circle
the graphical user
if the equation
procedure that is
ways in which
to compute each
correspondences between the
operate directly on
to be stored
on the application
directly on the
fields of the
can be specialized
the variable is
at compile time
of the transfer
for a variety
that are defined
an instance of
a system that
to a list
area of a
defined for the
data can be
the user does
field of the
user does not
produced only if
are references to
adapted to fit
pipe can be
makes the application
basis variable while
field does not
interface modules that
types t 1
circle can be
cos l angle
through a view
abstract type are
might be inefficient
an ordinary programming
deltay 2b deleting
describe how application
ordinary programming language
basis variables is
line segment fig

corpus/krapavin2000-test/631218.txt
printer
unity
laptop
mobile
receiver
sender
statements
reactive
reacts
disconnection
transient
increment
roman
catalin
gruia
inhibit
mobility
statement
driver
mccann
history
interactions
synchronization
disengage
reconfiguration
superposition
bit
disconnected
picco
abstractions
sharing
queue
coordination
gian
guard
murphy
location
engage
pietro
status
assignment
disengagement
wireless
compositional
actions
amy
inhibited
action
synchronized
composition
mascolo
inhibitions
engagement
idlei
program
co
atomic
transaction
decoupled
flag
reactively
csp
xx
automata
shared
declare
month
reactions
interleaved
phase
hoare
ed
coselection
expressing
fqg
constructs
reasoning
services
quantification
xb
lime
cecilia
params
programs
interaction
logic
modular
abstraction
weakly
superposed
participants
tosem
isolation
propagate
vol
express
software
semantics
s0
reconnection
hosts
propagation
idle
fair
interleaving
execute
limerick
connectivity
vari
recording
ireland
engineering
synchronous
consensus
predicate
luiz
filesystems
newloc
wermelinger
actionka
frgs
fpgs
printer2
fiadeiro
coexecution
idleg
payton
triple
propagated
methodology
guards
appending
located
medium
designers
telephone
simultaneous
dependent
mechanisms
registration
ables
print
concurrent
union
namespaces
reset
scheduled
axiomatic
communication
predicates
executing
indirectly
assign
safety
reaction
synchronizing
connection
executed
agents
execution
coarser
operationally
lf
reintegration
jamie
liveness
communicate
transparency
ha
false
interference
augmented
quiescent
inhibition
sf
rendezvous
nization
documents
clauses
style
directional
specify
modularity
underlying
guessed
falsified
programmer
compose
failures
transmission
sides
host
items
asymmetric
sigsoft
aware
serialized
reasoned
julien
22nd
printer q
laptop q
a s
s phase
q printer
mobile unity
reacts to
standard unity
reactive statements
reactive statement
mobile computing
catalin roman
q laptop
gruia catalin
a increment
interactions section
receiver bit
program sender
assignment statements
software engineering
transient sharing
mobile components
sender bit
underlying program
the receiver
b y
b t
non reactive
s driver
b increment
proof logic
state satisfying
the statements
context dependent
the sender
the unity
the laptop
abstractions for
receiver history
compositional programming
false reacts
program receiver
the printer
of mobile
co located
satisfying p
for mobile
on software
a x
pietro picco
programming abstractions
gian pietro
the reactive
the program
when r
l murphy
and roman
roman compositional
driver when
mccann and
the queue
and context
s action
o automata
the components
the interactions
a state
location dependent
of disconnection
the statement
reconfiguration and
month 1998
increment when
status a
amy l
statement would
xx no
x month
vol xx
of program
a statement
x b
reasoning about
sender receiver
to receiver
for execution
input actions
hoare triple
and disconnection
new statements
in mobile
programs are
executed in
s f
value written
engineering vol
no x
to bit
location and
execution of
statement is
history sequence
t guard
output actions
status laptop
statements from
t driver
inhibit b
disconnection and
reactive propagation
ed b
initially assign
phase variable
disconnection of
phase idlei
both statements
guard b
picco gruia
to laptop
s guard
r inhibit
phase idle
decoupled and
unity superposition
program composition
unity program
q reacts
current location
statements are
a mobile
shared variable
each statement
of transient
program variables
two programs
two statements
of synchronization
earlier example
while disconnected
a coordination
inhibit a
superposition is
the mobile
fixed point
of assignment
shared variables
right hand
logic for
the history
statements of
statement s
in equation
forms of
wireless communication
receiver may
statements in
statements that
hand sides
when p
variable bit
among mobile
components must
the assignment
to specify
components are
of statements
abstraction for
statement that
distributed consensus
the variable
xb y
increment ed
length receiver
coordination constructs
j mccann
cecilia mascolo
fair interleaving
unity programs
true reacts
program union
statement synchronization
connection status
system sender
laptop is
not inhibited
mobile setting
unity can
unity s
underlying variables
expressing reconfiguration
to printer
unity union
triple notation
a xb
idlei a
non mobile
sender counter
synchronization relationships
ensures q
when connectivity
a s phase
q printer q
laptop q printer
q laptop q
gruia catalin roman
reacts to a
the interactions section
in a state
a state satisfying
x b y
a s driver
printer q laptop
abstractions for mobile
a s action
for mobile computing
a x b
state satisfying p
compositional programming abstractions
false reacts to
to a s
on software engineering
the underlying program
gian pietro picco
programming abstractions for
in the interactions
roman compositional programming
and context dependent
mccann and roman
and roman compositional
driver when r
r a s
i o automata
transactions on software
by the sender
the assignment statements
status a x
engineering vol xx
no x month
xx no x
vol xx no
reconfiguration and disconnection
non reactive statement
x month 1998
printer q printer
in mobile unity
amy l murphy
selected for execution
a s f
software engineering vol
executed in a
the current location
when r inhibit
a s guard
s phase idle
q reacts to
b increment when
notation and logic
the receiver may
to receiver bit
the programs are
b t driver
of reactive statements
status laptop q
reactive statement is
b t guard
guard b t
from standard unity
s guard b
when r a
of the unity
laptop q laptop
picco gruia catalin
pietro picco gruia
of mobile computing
forms of synchronization
location and context
the form given
mobile computing systems
right hand sides
when the two
form given in
written by the
the two programs
of the queue
of assignment statements
of the statement
of the underlying
the components are
value written by
and logic for
ed b increment
phase idlei a
left hand variables
components are disconnected
phase when r
s phase b
when connectivity is
s driver when
f true reacts
statement is scheduled
the variable bit
phase a s
every value written
t driver when
non reactive statements
and b increment
when the components
when the programs
f false reacts
peter j mccann
the reactive statement
program is in
of mobile unity
the reactive statements
to the interactions
driver ha s
a standard unity
s f false
idlei a s
the communications medium
and location dependent
statements are of
a increment ed
decoupled and context
of mobile components
among mobile components
system sender receiver
and disconnection of
mobile unity can
of the reactive
s phase a
inhibit b t
true reacts to
b t r
s b t
sequence of boolean
s phase idlei
length receiver history
r inhibit a
statement that is
of program sender
pietro picco amy
increment ed b
to laptop q
a notation and
b t phase
t phase when
an underlying program
s driver ha
the new statements
the earlier example
inhibit a s
hoare triple notation
reactive propagation of
the connection status
satisfying p it
picco amy l
to sender bit
with standard unity
a xb y
phase b t
continue to function
given in equation
shared variables and
assigned to by
1 s and
s f true
are co located
a new location
of other components
between the components
y a x
the same name
methodology tosem v
and methodology tosem
engineering and methodology
software engineering and
of the history
a mechanism for
capable of expressing
be the formula
items from the
the two statements
software engineering p
the execution of
2000 limerick ireland
from the text
must be added
june 04 11
allowed to execute
04 11 2000
11 2000 limerick
of the statements
execution of the
t r a
provides a mechanism
a s b
of the transaction
to by the
propagated to the

corpus/krapavin2000-test/631246.txt
controller
breaker
breakers
circuit
transformer
sigali
signal
fault
pds
station
attractivity
departure
objectives
faults
controllable
3z
dynamical
sensors
voltage
cells
upstream
req
synthesis
polynomial
opened
invariance
cell
uncontrollable
visibility
plant
admissible
event
prop
boolean
arrival
faultdep4
faultdep1
faultdep2
faultdep3
controllers
propagation
dep
verification
cb
signals
closing
reqopen
insuring
downstream
zx
instant
triples
link
electric
opening
rc
default
events
reachability
physical
power
synthesize
specification
false
algebraic
interruption
hospital
double
synthesized
arr
controlled
bdd
trajectory
compatible
concerns
coded
reqclose
zclose
lectricit
faultarr1
subprocesses
z3z
clocks
encode
file
clock
instants
picked
named
booleans
primitive
synchronous
sc
equations
absent
evolves
behaviors
lem
equational
sequel
dangerous
polynomials
trajectories
ideals
compiler
open
chao
confirmation
varieties
maximal
material
establishment
reachable
translation
requirements
interpreted
appearance
sensor
kai
yong
translated
cai
closed
manipulates
triple
yuan
processes
methodology
solutions
supplies
logical
informed
init
prob
disappear
transient
safety
controls
0g
checked
abstraction
composition
homopolar
22703
sc1
quations
e5
7c8321
wattmetric
openlink
2712
m64
pz
paren
gali
electrocute
supervisory
setstates
dep2
tractivity
wenhui
currents
2fault
rwc
9elimu
reorganized
syrf
evolve
specifies
duration
allocated
instantaneous
importance
proposition
fig
diagram
receives
definitively
verif
deprived
phisms
contrario
spontaneously
electricity
emption
reopened
2725
reactivity
xng
costumers
encoded
incremental
language
objective
requests
encodes
strict
classical
8t
v0
circuit breaker
circuit breakers
transformer station
control objectives
power transformer
the circuit
breaker is
polynomial dynamical
signal program
order relation
the controller
the signal
controller synthesis
in signal
a controller
of states
state x
z 3z
the control
the fault
sensors of
station controller
control u
controlled system
signal language
a pds
breakers are
the departure
the power
dynamical system
the controlled
state variable
a signal
the sensors
the boolean
physical fault
is opened
two faults
the upstream
initial states
the state
boolean prop
req open
power propagation
departure level
fault propagation
default when
states e
fault is
of polynomial
a fault
the system
the plant
set states
the transformer
controller is
discrete event
the polynomial
over z
a polynomial
the states
states where
the arrival
req close
fault link
the attractivity
fault dep
by sigali
station network
invariance reachability
objectives in
synthesis methodology
verification objectives
controller c
prop is
double fault
different circuit
attractivity of
fault visibility
link circuit
event y
boolean error
double faults
event systems
faults are
different cells
a state
the different
state variables
cost function
a physical
to open
present and
invariance of
y t
states of
picked up
dynamical systems
specification of
a control
is true
states is
link level
polynomial that
cell 1
to synthesize
x 0
a power
concerns the
the double
control of
polynomial relation
departure circuit
upstream circuit
controller insuring
when faultdep1
arrival level
as invariance
high voltage
departure cell
faultdep4 default
faultdep1 and
default false
signal programs
controller using
system evolves
and faultdep4
objectives that
arrival cell
logical abstraction
polynomial dynamic
next instant
a controllable
system sc
departure cells
cost allocated
closing requests
traditional control
and req
dep 1
fault exists
relation c
value true
the primitive
true when
a circuit
c x
is present
the cells
q x
the solutions
of signal
the invariance
physical model
signal of
triple x
and closing
local controllers
opening and
the downstream
primitive operators
main process
as polynomial
control synthesis
strict order
event variables
fault at
maximal for
a cell
interpreted by
is then
signal the
controller we
polynomial equations
evolves into
signal x
a hospital
polynomial c
non boolean
systems over
specified in
of equations
true the
with y
verification of
solutions of
seen by
compatible with
order relations
c defined
the voltage
controller that
states f
and false
the events
data flow
close and
using algebraic
optimal control
clock of
power transformer station
the circuit breaker
circuit breaker is
the power transformer
set of states
the control objectives
the circuit breakers
transformer station controller
the sensors of
a state x
polynomial dynamical system
the controlled system
circuit breakers are
of the power
of the circuit
breaker is opened
the signal language
of a signal
of states e
the order relation
specified in signal
a power transformer
polynomial dynamical systems
a physical fault
the transformer station
a circuit breaker
the signal program
the boolean prop
the initial states
the different cells
the state variable
discrete event systems
a control u
of the departure
different circuit breakers
a signal program
transformer station network
the control u
of polynomial dynamical
the different circuit
the attractivity of
prop is true
interpreted by sigali
controller synthesis methodology
order relation c
in signal the
the double fault
over z 3z
the boolean error
of the signal
the controller is
importance of the
y in x
of discrete event
with y in
of a power
of the different
the solutions of
that q x
the value true
the invariance of
states where the
by the sensors
seen by the
of the system
sensors of a
the departure level
and closing requests
order relation a
specification in signal
when two faults
error is true
two faults are
strict order relation
a controller insuring
and faultdep4 default
upstream circuit breakers
the upstream circuit
system evolves into
the next instant
picked up by
of signal programs
cost allocated to
the system evolves
when faultdep1 and
the link circuit
compatible with y
departure cell 1
breakers are closed
control objectives that
a controller that
of states where
all the upstream
c x 0
present and true
a triple x
the primitive operators
dynamical systems over
control of discrete
the fault propagation
boolean prop is
the arrival cell
as invariance reachability
the cost allocated
control of polynomial
of control objectives
the departure cell
link circuit breaker
in signal of
station controller using
value of x
of the fault
and the control
specification of a
maximal for the
terms of polynomial
at the departure
into a state
the fault is
opening and closing
initial states of
relation a c
if the fault
sensors of the
1 is said
signal of the
of the lines
state x and
initial states the
a cost function
of the primitive
states of the
polynomial that is
a polynomial that
is true when
the clock of
this kind of
to the state
such that q
is true the
takes the value
at each instant
is equal to
we will now
the states of
invariance of the
the state variables
x and that
and then by
from the initial
of states is
to the control
true when the
the system s
cost function is
translation of the
the importance of
application to the
controlled system sc
by sigali that
fault exists at
control verification objectives
propagation and visibility
ideals varieties and
pds can be
process power propagation
are booleans that
sigali that checks
the control verification
fault is picked
re establishment of
true and close
yong chao li
non boolean expressions
receives the event
be better compared
default when faultdep2
it is present
as ideals varieties
fault dep 1
terms of polynomials
compute a controller
control objectives we
all the circuit
fault prob lem
traditional control objectives
controller is then
true when two
into either x
the complete signal
the local controllers
corresponding circuit breaker
a polynomial dynamical
signal program the
controller using a
the compiler produces
better compared to
account the importance
station network as
is attractive from

corpus/krapavin2000-test/631250.txt
faults
release
modules
fault
metrics
cyclomatic
prone
loc
pareto
hypotheses
basili
post
pericone
module
testing
hypothesis
density
fenton
software
sigff
predictors
failures
operational
kloc
alberg
densities
releases
pre
discovered
defect
1984
empirical
incidence
1a
evidence
proportion
pfleeger
ostrand
hatton
ohlsson
scatterplots
weyuker
proneness
prediction
relating
scatter
elaine
perricone
organisation
benchmarking
ft
cmm
graphed
munson
adams
neil
phases
predictor
prerelease
normalised
1b
published
st
predicting
si
engineering
studies
you
80
failure
repeatable
predict
dot
companies
khoshgoftaar
koru
20601001400
mccabe
postrelease
interphase
compton
responsible
quality
reveal
2a
1996
bell
norman
op
popularly
emam
defects
constitute
explanatory
1000
60
246
strong
martin
early
thomas
trends
1990
140
tended
2b
robert
rel
industrial
believed
versus
misleading
causal
collected
absolute
3000
sada
zuse
tomaszewski
dearth
alshayeb
kanoun
curiously
gwendolyn
inspections
shesh
walton
paulish
fdl
nishith
benlarbi
grahn
underpin
withrow
khosghoftaar
gunes
lundberg
moeller
kitchenham
accumalated
reliability
traced
correlates
sigsoft
metric
1992
principle
1995
extracted
analysed
development
popular
percentage
plots
piotr
rai
hkan
factory
warnings
ada
months
accumulated
diagrams
plot
goel
predictability
organisations
2060100
quantitative
sdl
woo
khaled
company
valuable
against
09
broadly
el
remarkable
75
lars
flawed
ramifications
tian
dangerous
commercial
notably
tested
397
subsequent
correlation
evolution
uml
mohammad
softwarepractice
dependability
trend
economics
legacy
effort
release n
post release
fault density
pre release
fault prone
release faults
of faults
prone modules
complexity metrics
of modules
for release
the faults
faults in
cyclomatic complexity
software engineering
faults discovered
operational faults
modules contain
modules which
basili and
the modules
fault densities
most fault
release fault
higher incidence
system test
contain most
hypotheses relating
and pericone
the pareto
size metrics
release testing
pareto principle
and failure
fault data
of fault
predictors of
incidence of
fault and
good predictors
module size
those modules
in modules
a module
modules in
faults and
in system
relating to
small proportion
hypothesis 1a
constitute most
proportion of
metrics are
the fault
hypothesis 4
discovered during
failure prone
loc are
densities at
on software
modules are
function test
pre and
dot represents
as loc
in pre
each dot
small number
system size
testing and
in release
pericone 1984
were responsible
per kloc
thomas j
j ostrand
all faults
early fault
and failures
strong evidence
faults are
discovered in
elaine j
releases of
because those
j weyuker
in function
and post
of pre
modules constitute
the operational
faults for
software quality
of software
in operation
most of
martin neil
fault prediction
scatterplots of
engineering hypotheses
80 100
and alberg
ostrand elaine
simple size
design metrics
m bell
of cyclomatic
than smaller
and perricone
faults per
ft and
density is
an empirical
simply because
metrics such
modules that
the software
are good
failure data
to predict
failures in
and operational
of code
scatter plots
implies higher
prone in
between subsequent
complexity figure
during pre
of early
evidence to
predictor of
robert m
software system
testing phases
faults faults
than simple
code size
later fault
the cyclomatic
predict later
kloc is
rel n
and pfleeger
normalised data
major releases
dependent variable
subsequent major
absolute number
in basili
1a and
hypothesis 5
hatton 1997
testing ft
alberg 1996
fenton and
a small
and op
no evidence
modules were
faults were
responsible for
n 1
and operation
the 20
software development
and repeatable
at corresponding
in post
faults figure
function testing
constant between
testing effort
fault proneness
software v
20 40
and st
10 of
for fault
each module
are traced
si and
good predictor
be fault
engineering p
modules and
development and
scatter plot
observed a
metrics were
of testing
lines of
we test
the scatter
roughly constant
for hypothesis
faults of
modules with
engineering v
of complexity
for release n
release n 1
of the faults
fault prone modules
post release faults
number of modules
of modules contain
modules contain most
fault and failure
in system test
higher incidence of
faults in system
most fault prone
contain most of
basili and pericone
the most fault
hypotheses relating to
incidence of faults
pre release faults
the faults discovered
number of faults
of faults in
pre release testing
and post release
the pareto principle
release fault density
faults and failures
complexity metrics are
good predictors of
prone modules in
the operational faults
small proportion of
fault density is
constitute most of
are good predictors
of the modules
small number of
most of the
as loc are
in pre release
loc are good
represents a module
failure prone modules
each dot represents
fault densities at
dot represents a
of pre release
in modules which
releases of a
faults discovered in
simply because those
faults discovered during
such as loc
of the operational
of faults and
the faults in
a small number
pre and post
is simply because
on software engineering
relating to the
because those modules
pre release fault
those modules constitute
post release fault
of complexity metrics
of fault and
were responsible for
distribution of faults
size metrics such
and failure prone
thomas j ostrand
in release n
modules constitute most
modules which are
and pericone 1984
and failure data
n 1 each
elaine j weyuker
evidence to support
lines of code
metrics such as
if a small
for fault prediction
robert m bell
during pre release
1 each dot
testing and operation
ostrand elaine j
of early fault
the modules which
implies higher incidence
early fault data
software engineering hypotheses
faults for release
than simple size
discovered during pre
of cyclomatic complexity
proportion of modules
fault prone in
j ostrand elaine
faults in function
ft and st
basili and perricone
this is simply
software engineering v
proportion of the
the code size
then this is
10 of the
proceedings of the
between subsequent major
and alberg 1996
use of early
in post release
predict later fault
fenton and pfleeger
testing and operational
the post release
metrics are better
si and op
phases of testing
constant between subsequent
modules which were
fault data to
cyclomatic complexity and
in basili and
predictors of fault
stable and repeatable
release faults for
subsequent major releases
of faults discovered
later fault and
predictor of fault
pareto principle of
in function test
release n and
be fault prone
of fault density
to the pareto
the fault density
principle of distribution
cyclomatic complexity figure
a small proportion
roughly constant between
to predict later
occur in modules
per kloc is
that a small
transactions on software
data to predict
good predictor of
of distribution of
and failures in
of the code
and software v
the software engineering
a good predictor
for each module
of systems and
empirical study of
systems and software
an empirical study
number of pre
journal of systems
of testing and
faults in a
the system size
100 of the
release n see
two releases of
than smaller ones
and operation remain
faults per kloc
modules which account
that the small
20 80 rule
metrics for fault
12 months of
simple size metrics
systems produced in
from source code
corresponding phases of
and operational phases
popular complexity metrics
in similar environments
metrics based on
n see figure
which are fault
n release n
prone post release
similar fault densities
broadly similar fault
1a a small
of modules figure
densities at similar
at corresponding phases
j weyuker robert
release testing then
for hypothesis 1a

corpus/krapavin2000-test/631253.txt
lqn
requesthandler
client
ioout
server
uml
architectural
pipeline
collaboration
filter1
ioin
filter2
filters
buffer
processor
semaphore
replications
utilization
ioexec
downstreamfilter
upstreamfilter
rh
software
fig
proc
request
stackout
stackin
telecommunication
collaborations
phase1
throughput
serialization
message
services
requests
accessor
submodel
filter
bottleneck
container
synchronous
configurations
queueing
reply
modelling
behavioural
processors
entry
service
behalf
servers
asynchronous
upstrmfilter
coallocation
shmem1
downstrmfilter
proc_item
phase2
modelled
architecture
forwarding
hardware
rectangle
configuration
utilizations
waiting
critical
clients
passive
devices
user1
system0
usern
pulls
case0
mirandola
raffaela
proc1
entries
thread
busy
attributes
proposes
connector
arc
dummy
io
database
phases
demands
tasks
visits
patterns
task
queue
messages
rendezvous
rome
interactions
object
idle
item
shared
bottlenecks
achievable
diagrams
toolset
behaviour
allocation
script
replication
cortellessa
active2
petriu
proc2
utilization0
lifeline
grassi
phase3
server2
active1
shmem2
allocated
excessive
read
measurements
served
sect
submodels
lifecycle
blackboard
callers
wait
transformation
roles
early
alternatives
612
serializes
weaknesses
saturated
active
structural
quantify
vincenzo
vittorio
arcs
frequently
systematic
slave
broker
61
arrow
sigsoft
transformations
qn
613
delegates
accepting
capacity
pattern
response
circle
scenarios
optionally
corba
stochastic
objects
running
utilized
exchanged
loads
layered
bridging
pushes
exposes
insure
exclusive
3rd
delays
italy
invoke
named
handler
scheduling
responsible
diagram
cpu
offer
stages
replies
initiating
contained
assess
processes
threads
device
contributions
development
lqn model
the lqn
architectural patterns
in fig
client server
an lqn
processor node
software architecture
performance models
are running
telecommunication system
with buffer
of requesthandler
the pipeline
performance attributes
task entry
requesthandler replications
of lqn
the client
pipeline with
the software
running on
the server
and filters
software performance
asynchronous message
upstreamfilter downstreamfilter
replications utilization
request arc
performance modelling
a lqn
filters are
processor configuration
processor nodes
each software
the filters
critical section
pipeline and
same processor
the system
shared object
the uml
the requesthandler
stackin stackout
processor database
task utilizations
performance engineering
lqn submodel
lqn task
the architectural
client to
behalf of
on behalf
passive object
achievable throughput
a client
performance analysis
software components
useful work
performance model
a software
different processor
synchronous message
utilizations for
server systems
level architecture
downstreamfilter buffer
utilization ioout
proc base
forwarding message
excessive serialization
database requesthandler
buffer upstrmfilter
included services
accessor shared
software bottleneck
architectural pattern
4 proc
software task
buffer upstreamfilter
semaphore task
to excessive
object operations
filter1 filter2
61 number
fully modified
upstrmfilter downstrmfilter
lqn was
6 processors
server client
class object
queueing network
high level
performance limitations
modified system
structural and
server may
software and
a task
model parameters
of services
to building
as entries
of visits
a telecommunication
active objects
demands for
and behavioural
an entry
allocation of
modelled as
execution times
the bottleneck
on different
an asynchronous
a reply
entries of
see fig
models from
4 processor
the allocation
system0 20
server pattern
uml a
multi server
serialization constraints
case0 20
into lqn
section accessor
phase1 phase2
critical sect
half way
building performance
base case0
modified system0
container contained
raffaela mirandola
into performance
lqn models
2002 rome
6 processor
level architectural
software server
distributed software
the collaboration
performance july
from hardware
constraint sequential
thread of
configuration base
each architectural
early performance
coallocation container
time demands
way modified
the shared
each user
to processors
the utilization
a server
processing power
critical sections
a performance
the high
contributions to
frequently used
requests for
a pipeline
systematic approach
and performance
20 61
each request
a collaboration
a uml
buffer figure
software architectures
service requests
different software
other servers
system request
and configurations
queue where
next item
hardware devices
architectural connection
for performance
transformation of
the performance
with message
performance characteristics
of control
entry for
a rectangle
task that
the message
entry of
configurations and
is saturated
may offer
different configurations
the lqn model
are running on
pipeline and filters
same processor node
number of requesthandler
on different processor
different processor nodes
as in fig
the same processor
a client to
the shared object
an lqn model
of the lqn
performance models from
requesthandler replications utilization
for each software
of requesthandler replications
running on different
task utilizations for
pipeline with buffer
client server client
shown in fig
on behalf of
the high level
the software architecture
approach to building
high level architecture
upstreamfilter downstreamfilter buffer
due to excessive
20 61 number
structural and behavioural
buffer upstrmfilter downstrmfilter
buffer upstreamfilter downstreamfilter
client server systems
lqn model is
an asynchronous message
the architectural patterns
users are running
as entries of
filters are running
61 number of
proc base case
pipeline with message
to excessive serialization
the filters are
the pipeline with
each request arc
replications utilization ioout
proposes a systematic
the performance attributes
running on the
the allocation of
number of visits
in fig 4
transformation of the
as a client
on the same
an entry of
for each request
a systematic approach
systematic approach to
hardware to software
behalf of different
high level architectural
software task entry
section accessor shared
of a pipeline
described in fig
critical section accessor
case of 6
in the lqn
server client server
modified system0 20
each software task
a reply from
the class object
and performance july
from hardware to
of an lqn
building performance models
thread of control
software performance engineering
24 26 2002
2002 rome italy
processor database requesthandler
the constraint sequential
each architectural pattern
shared object operations
of 6 processors
base case0 20
4 processor configuration
into a performance
system is saturated
to other servers
client server pattern
the telecommunication system
processor configuration base
the semaphore task
lqn model for
july 24 26
performance july 24
of the requesthandler
case0 20 61
level architecture of
modelled as entries
26 2002 rome
coallocation container contained
half way modified
6 processor configuration
configuration base case0
from the high
of a system
of the system
a pipeline with
reply from the
a performance model
on software and
behalf of a
maximum achievable throughput
3rd international workshop
is running on
software and performance
a telecommunication system
fig 4 a
in the case
in fig 2
entry for each
the real system
fig 5 and
to the software
of the pipeline
the system bottleneck
entry of the
for the 4
weaknesses in the
fig 1 and
a rectangle with
1 january 2004
entries of the
software and hardware
the work to
when the system
workshop on software
the client server
the critical section
for each user
architecture of a
entries of a
be modelled as
as shown in
performance analysis of
of a task
notes v 29
as a process
n 1 january
execution times for
executed on the
the role of
the 3rd international
of different types
the case of
of the server
performance engineering of
co allocation collaboration
request handler ioout
an lqn task
20 613 4
system0 20 612
that the callers
a multi server
software architecture of
level architectural patterns
processor node the
task that plays
buffer filter1 1
a new software
task are executed
processor ioexec database
the pipeline connector
filter1 1 n
a system request
request arc from
object flow carried
task entry seen
of rh replications
queueing network lqn
execution time demands
level software architecture
the bottleneck moves
configurations with one
sequential attached to
architectural patterns into
coordinate outside the
the first filter
database requesthandler figure
as response time
to building performance
is saturated in
of the telecommunication
cause for performance

corpus/krapavin2000-test/633045.txt
multicast
overlay
narada
members
layer
cluster
hosts
peer
nice
host
member
leader
stress
stretch
streaming
l0
join
protocol
unicast
rp
peers
leaders
heartbeat
clusters
networking
delivery
kbps
latency
hierarchy
topology
telecommunications
overheads
layers
internet
sites
multimedia
routers
latencies
c0
hops
joining
scalable
bayeux
packet
packets
traffic
overlays
protocols
media
membership
video
pastry
a12
receiver
ms
l1
scribe
hilton
suman
bobby
overhead
links
testbed
super
group
bhattacharjee
mesh
audio
cl
departures
bandwidth
panel
paths
infrastructure
workshop
recovery
onds
3k
cork
yoid
baochun
druschel
stevenson
topologies
singapore
b0
tapestry
belongs
banerjee
seconds
cumulative
joins
leave
losses
ton
zhang
128
proxies
advances
lengths
seungjoon
refreshes
simulation
native
resilient
path
ip
routing
900
trees
scattercast
eachmember
basicjoinlayer
leadership
rmx
almi
secs
p2p
refresh
li
link
period
network
metrics
metric
ireland
networks
periodic
guang
plot
groups
dissemination
messages
2007
ananth
rao
failures
simulations
600
trip
contacts
experimented
kurose
aravind
rapid
nearby
experiment
stream
800
sigcomm
operating
june
nineteenth
bootstrap
chord
multicasting
probes
tree
duration
yang
washington
towsley
route
14th
joined
merge
soft
guo
failure
stabilizes
quicker
closest
lee
lifetime
b2
addressable
invariants
amortized
l2
beichuan
806
kyoungwon
georganas
minseok
zongming
robustnessof
shavitt
spiros
sugat
gorinsky
animesh
p2cast
mojtaba
kommareddy
ungraceful
joinjoin
hefeeda
hosseini
harrick
pucha
layer multicast
application layer
the cluster
the overlay
layer l
data path
control overhead
end hosts
the nice
nice protocol
the rp
the narada
peer to
other members
to peer
multicast group
control traffic
of members
leader of
narada 5
the stress
in nice
super cluster
data delivery
the multicast
in layer
group sizes
members in
networking v
telecommunications networking
and telecommunications
cluster leader
overlay multicast
the group
the hierarchy
the international
computer networks
path lengths
hosts are
the control
highest layer
an overlay
multicast protocols
multicast protocol
the members
cluster in
of hosts
video june
overlay topology
delivery path
level hops
for nice
link stress
control overheads
layer l0
control topology
data paths
the leader
the join
hosts in
media streaming
group size
digital audio
computer and
wide area
members that
members to
path length
on network
at members
cluster leaders
average member
the stretch
average control
networks the
l i
failure recovery
ip multicast
systems support
the member
application level
in peer
overhead at
a cluster
audio and
direct unicast
to layer
member departures
bandwidth data
for narada
new leader
host that
multicast using
proceedings of
and operating
group members
workshop on
cumulative distribution
international journal
for digital
peer multimedia
overlay networks
bobby bhattacharjee
multimedia streaming
2005 hilton
hilton singapore
the different
the data
a host
operating systems
suman banerjee
large receiver
l0 clusters
l0 cluster
receiver sets
stream applications
source specific
join phase
narada protocol
change phase
area implementation
members on
layer l1
1 cluster
i cluster
stress on
data stream
to end
and video
each host
join procedure
leaders of
cl i
international workshop
each cluster
on networking
member is
hosts that
the joining
members and
advances in
data packets
streaming november
any layer
membership change
control path
multicast data
simulated time
the internet
network and
the super
data packet
to join
o k
journal of
11 2005
log n
distribution of
members of
end host
other hosts
join query
of computer
ieee acm
ton v
networking ton
of application
the sites
support for
joining member
peter druschel
overheads at
stevenson washington
nice hierarchy
multicast infrastructure
narada 30
multi unicast
average path
overlay path
panel 0
member h
2005 stevenson
2004 cork
cluster membership
nice is
stress distribution
system multicast
stress metric
cork ireland
joining host
its leader
baochun li
different members
l1 cluster
these members
site c
in narada
and 3k
unicast latency
heartbeat message
application layer multicast
peer to peer
layer l i
the multicast group
layer multicast protocols
the nice protocol
and telecommunications networking
telecommunications networking v
networks the international
computer networks the
computer and telecommunications
the data path
of computer and
the international journal
proceedings of the
digital audio and
and video june
for digital audio
on network and
support for digital
leader of the
network and operating
of the cluster
application level hops
the highest layer
the cluster leader
layer multicast protocol
operating systems support
of the hierarchy
international journal of
in peer to
systems support for
workshop on network
cumulative distribution of
on the overlay
journal of computer
the control topology
data delivery path
in layer l
and operating systems
the leader of
audio and video
the average control
the data delivery
cluster in layer
fraction of members
the super cluster
control overhead at
2005 hilton singapore
11 2005 hilton
members in the
the join procedure
to peer multimedia
peer multimedia streaming
the end hosts
groups of size
international workshop on
of the members
the control overhead
the application layer
for application layer
of application layer
data stream applications
layer l j
control overhead for
of hosts that
l i cluster
membership change phase
of members that
13 14 2005
members on the
wide area implementation
basic data path
the other members
hosts in the
networking v 50
advances in peer
the basic data
the overlay topology
time in secs
streaming november 11
workshop on advances
other members in
multimedia streaming november
networking v 51
end to end
on networking ton
ieee acm transactions
networking ton v
transactions on networking
of a cluster
11 11 2005
the group size
l j 1
the acm workshop
november 11 11
the cluster size
conference on multimedia
large receiver sets
video june 16
k and 3k
the joining host
average link stress
peers on the
14th international workshop
average control overhead
june 13 14
along the overlay
cluster leaders of
the cluster leaders
the narada protocol
the nice hierarchy
the stress metric
2004 cork ireland
a new leader
and 3k gamma
stevenson washington usa
the control traffic
14 2005 stevenson
end system multicast
video june 13
different group sizes
18 2004 cork
low bandwidth data
2005 stevenson washington
international conference on
on the control
n 1 p
on advances in
june 16 18
clusters of size
16 18 2004
3k gamma 1
in the group
acm workshop on
v 50 n
v 51 n
from the source
between k and
the group members
links on the
of application level
the international workshop
2007 n 1
on the data
o log n
on multimedia november
join and leave
v 2007 n
for groups of
streaming proceedings of
we experimented with
control and data
number of application
the 14th international
acm international conference
v 82 n
the join phase
stress on links
sites c d
with large receiver
suman banerjee seungjoon
hosts that correctly
j 1 cluster
end hosts are
128 end hosts
super cluster for
time 1000 seconds
new host joins
in the highest
tree building protocol
in layer l1
scalable application layer
the sites c
secs 128 end
belongs to layer
700 800 900
any layer ffl
the closest member
control traffic at
is the leader
banerjee seungjoon lee
average path length
of the overlay
data path quality
the stress on
the narada application
advances in multimedia
present results from
using an overlay
overhead at an
distributed tree building
simulation v 82
all members in
all hosts are
for nice is
size upper bound
its l0 cluster
worst case control
into an appropriate

corpus/krapavin2000-test/633055.txt
flows
rat
flights
packets
packet
rtt
congestion
traces
tcp
flight
window
tra
receiver
flow
mss
bytes
sender
transport
internet
limiting
rates
rate
bandwidth
regional2
duration
acknowledgment
trace
sf
connections
delayed
connection
slow
sigcomm
link
opportunity
limited
bu
peering1
regional1b
regional1a
fac
correlations
mbps
stream
avoidance
bottleneck
fastest
msec
correlation
di
er
tool
trip
host
determinations
access1c
access1b
tcpanaly
fraction
advertised
routers
estimation
nagle
erent
acknowledgments
transferred
transmit
kbps
logr
npd
knowledgments
dummynet
datasets
skewed
mbyte
accounted
router
adus
rtts
deemed
identified
cumulative
big
round
limits
behaviors
transmission
links
dynamics
sizes
loss
peering
plot
networking
backbone
trace0
logd
ss
experiencing
factors
ack
rcvr
mtu
sndr
network
captured
validated
traffic
evident
analyzer
lived
measurement
cdf
statistics
90
candidate
normality
inter
fc
layer
determination
idle
dominant
arrival
lasting
file
exhibited
jan
periodic
routing
saturated
characteristics
plots
80
sec
experience
simulations
ect
burst
ca
million
percentage
predicted
sarvotham
seqb
specif
lukas
ssthresh
kencl
awndmax
ackf
wilk
validate
summary
origins
duplicate
256
un
cult
background
across
congested
validation
assess
tests
complementary
causes
n2
percentile
transitions
competing
durations
review
aggregate
varied
successive
transitioned
freebsd
kortebi
erentiate
muscariello
corr
wetherall
janeriro
oueslati
provider
consistent
ip
hours
hour
dataset
experienced
bandwidths
web
estimate
category
spaced
sigmetrics
logs
load
t rat
window limited
rate limiting
packet traces
receiver window
flow rates
tra c
application limited
transport limited
bandwidth limited
slow start
delayed acknowledgments
the bytes
congestion limited
bottleneck link
the tool
rtt estimation
of flows
opportunity limited
fast flows
acknowledgment packets
the sender
flight sizes
without delayed
of bytes
and duration
the rate
a flow
summary flow
limiting factors
congestion avoidance
packet loss
host window
acknowledgment stream
sender window
the flight
flows in
data packets
acm sigcomm
each connection
limited the
the rtt
the acknowledgment
bu er
the link
correlation between
limited if
the mss
of flow
rate limit
cumulative fraction
limiting behavior
and rate
the traces
limiting factor
packets at
candidate rtt
successive flights
flow rate
flows account
limited behavior
the rates
the internet
the receiver
the bottleneck
a connection
bytes in
flows are
the packet
between size
of tcp
8 packet
flow is
round trip
fastest flows
limited congestion
flight size
fraction flow
sf i
receiver limited
internet flow
limited flows
for between
of internet
tcp connections
congestion window
access links
traces and
a rate
link bandwidth
fraction of
traces the
limited by
the connection
accurate within
connections as
window sizes
of packets
size and
di erent
advertised window
in flight
transmit data
traces we
of flights
nagle algorithm
rtt we
inter packet
flows transmit
rat to
periodic determinations
consecutive flights
background load
regional2 figure
flight f
flights f
regional1b regional2
regional1a regional1b
other flow
rat was
and acknowledgment
bytes transferred
100 msec
peering1 regional1a
data stream
consistent with
the connections
identified the
packet level
trip time
and receiver
first packet
correctly identified
review v
computer communication
communication review
sigcomm computer
flow size
limited application
as bandwidth
packet trace
limited a
flow characteristics
rate distribution
s transitions
a flight
duration and
for over
rates and
the trace
rate and
limited in
the 8
the correlations
accounted for
per flow
for flows
sender s
the flows
account for
90 of
delayed ac
connections were
into flights
trace contains
flow sizes
deemed the
4 flights
q plot
limited tra
rate analyzer
limited receiver
the nagle
single direction
window limits
limited transport
each rate
flow level
flows bytes
flow statistics
between rate
8 traces
limited when
limiting behaviors
network limits
packets into
side estimation
connection sizes
complementary distribution
rat works
mbyte file
total bytes
mss sized
limit determination
ac knowledgments
distribution of
measurement october
tool was
and host
each trace
receiver window limited
of the bytes
the rate limiting
rate limiting factor
the bottleneck link
a flow is
size and rate
size and duration
sender window limited
rate limiting factors
of flow rates
packets at the
distribution of flow
for each connection
between size and
correlation between size
without delayed acknowledgments
fraction of bytes
and without delayed
flows account for
8 packet traces
rate limiting behavior
host window limited
flow rates and
the rtt estimation
limited congestion limited
cumulative fraction flow
of successive flights
the acknowledgment stream
of a connection
of the traces
data packets at
accurate within a
in the internet
flights f i
limited application limited
packet traces we
set of flights
as bandwidth limited
rate and duration
t rat to
peering1 regional1a regional1b
of t rat
internet flow rates
s transitions to
and acknowledgment packets
a rate limiting
regional1a regional1b regional2
correctly identified the
when the trace
limited a flow
the packet traces
packet traces and
round trip time
the first packet
computer communication review
sigcomm computer communication
communication review v
acm sigcomm computer
with and without
the sender s
tra c is
of the flows
number of packets
of the periodic
tra c in
within a factor
the tool was
of the rates
internet measurement october
the flight size
flows transmit data
flow rates in
summary flow data
packets into flights
the receiver window
make a rate
complementary distribution of
the total bytes
correlation between rate
in each trace
application limited tra
delayed ac knowledgments
rate limit determination
by t rat
the trace contains
the 8 traces
and host window
the flight sizes
acknowledgment packets at
t rat works
regional1b regional2 figure
window limited the
percentage of bytes
limited tra c
the 4 flights
each rate limiting
the periodic determinations
a candidate rtt
q q plot
of 2 packets
the connections as
the 8 packet
as receiver window
limited transport limited
flow is considered
a rate limit
and receiver window
between rate and
t rat was
the nagle algorithm
rate limiting behaviors
and summary flow
a single direction
the distribution of
of the rate
on internet measurement
the data stream
of the 4
of the connections
the link bandwidth
sender and receiver
factor of 1
the congestion window
for a candidate
the transport layer
direction of a
of the rtt
the correlation between
number of flows
90 of the
at the sender
of the link
are consistent with
review v 36
congestion limited transport
fast flows are
window limited using
the bytes in
t rat deemed
limited receiver limited
mss sized packets
by rate limiting
limited the sender
sequence number seen
million 1 in
receiver limited figure
bandwidth limited if
limited flows have
bytes flows bytes
flows limited by
the largest sequence
both directions of
data and acknowledgment
rat deemed the
jan 3 2002
the flows in
flows bytes flows
traces and summary
fraction of flows
duration and rate
as highly skewed
with congestion avoidance
largest sequence number
t rat we
in 256 no
sender s window
most flows are
highly skewed as
dominant rate limiting
summary flow level
the advertised window
and duration and
sizes of 2
experience any loss
for flows lasting
flows lasting longer
big and fast
rat correctly identified
application limited congestion
consistent with slow
other flow characteristics
flow s transmission
a log normal
transitions to un
s transmission rate
the dominant rate
flow level statistics
with slow start
lasting longer than
limited behavior was
the inter packet
host sndr rcvr
can not reject
limited if it
rates of flows
transport limited receiver
rate and size
of internet flow
background tra c

corpus/krapavin2000-test/633558.txt
quantum
alice
bob
qubit
qubits
epr
entanglement
classical
disjointness
buhrman
cleve
communication
joei
bits
protocol
unitary
gates
protocols
circuit
holevo
superdense
coin
yao
wigderson
rank
her
jii
query
teleportation
podolsky
einstein
grover
jozsa
disj
deutsch
channel
vegas
raz
promise
rosen
jbi
las
ip
hadamard
private
automata
coding
wolf
bounds
send
teleporting
cnot
flip
gate
unlimited
superposition
separations
sends
klauck
tapp
j0i
j1i
public
ji
separation
bit
parties
elementary
dam
communicated
toss
kremer
nielsen
rounds
amplitudes
deterministic
gavinsky
jxi
kempe
exponential
log
bi
wants
polynomials
omega
jff
discrepancy
exhibited
53
dmitry
communicate
share
sampling
eq
gaps
black
dense
vlsi
error
strengths
distributional
classically
ronald
transformation
gap
julia
coins
ff
receives
prior
uv
inner
joint
acting
box
f0
1g
applies
message
transform
flips
distributive
she
circuits
norm
tight
vs
ffl
outputs
phi
measurement
equality
preprint
weaknesses
boolean
thirty
jc
copying
determinism
polynomially
jointly
probability
j11i
superoperators
spooky
povms
bitstring
impressively
copier
as2
plitudes
regev
quantummechanical
jyi
11234
gammaly
kerenidis
physicists
iordanis
rodl
separa
gall
shor
jxij0ijyi
brassard
probabilistic
security
parity
logarithm
mechanical
measuring
exact
van
suffice
provably
negates
undetermined
mehlhorn
oded
triumph
qaip
ques
hyer
ambainis
turing
44
bounded
round
nayak
2q
reversible
stipulates
deltay
variant
compromises
literally
entangled
disposal
outcome
queries
communication complexity
quantum communication
classical communication
of quantum
and bob
alice and
the quantum
to bob
bounded error
lower bounds
a quantum
epr pairs
quantum circuit
classical bits
log rank
epr pair
prior entanglement
cleve and
quantum protocol
buhrman cleve
q f
quantum and
rank f
alice s
unitary transformation
quantum entanglement
quantum algorithms
quantum computation
d f
error protocols
basis state
n qubits
error quantum
for disjointness
lower bound
the classical
qubits and
classical protocol
1 qubit
quantum query
for quantum
entanglement and
of communication
bounds on
superdense coding
de wolf
private coin
complexity lower
quantum protocols
complexity quantum
public coin
by buhrman
input x
and classical
and quantum
a qubit
hadamard transform
quantum information
x y
f x
in quantum
good lower
n bits
value f
las vegas
yao 53
holevo s
two qubits
way quantum
a hadamard
by yao
zero error
of epr
einstein podolsky
ji b
the deutsch
on quantum
deutsch jozsa
exact protocols
elementary gates
exponential separation
shared epr
to alice
circuit is
to send
if alice
error probability
a unitary
bounds for
bound for
quantum algorithm
suppose alice
f log
communication and
the channel
r 2
by polynomials
send n
alice can
probabilistic communication
all total
non deterministic
query algorithm
bob can
bound techniques
for exact
query complexity
protocol for
the protocol
exponential gap
grover s
bob receives
quantum classical
theory quantum
unlimited prior
communication quantum
klauck 34
then bob
and tapp
bob now
1 epr
fast quantum
2 qubits
cleve wigderson
alice applies
dense coding
44 for
total f
qubit ff
classical world
share unlimited
exact quantum
bits x
alice receives
joint state
podolsky rosen
complexity of
finite automata
of classical
applies a
ff 0
bounds by
log n
y 2
inner product
total functions
1g n
for ip
quantum state
quantum complexity
norm 1
m qubit
bob share
38 32
transformation u
deterministic communication
quantum computing
right value
2 classical
quantum automata
a promise
query quantum
gamma n
a classical
black box
to communicate
their joint
and wigderson
to 38
alice has
van dam
complexity on
than classical
n bit
the black
the communication
vlsi and
gate is
wants to
some function
in communication
omega gamma
m f
compute some
can just
with classical
an omega
some error
log m
complexity the
bounds in
transform to
small error
to her
compute f
gaps between
on input
computes f
superposition of
o 1
quantum communication complexity
alice and bob
classical communication complexity
log rank f
lower bounds on
f x y
of quantum communication
a quantum circuit
quantum and classical
in the quantum
value f x
bounded error protocols
and classical communication
complexity lower bounds
communication complexity lower
of classical communication
communication complexity quantum
f log rank
in quantum communication
communication complexity of
lower bound for
the deutsch jozsa
bounded error quantum
bound for disjointness
holevo s theorem
of epr pairs
wants to send
a hadamard transform
buhrman cleve and
communication complexity the
the classical protocol
quantum entanglement and
lower bound techniques
for all total
a unitary transformation
bounds by polynomials
in communication complexity
in the classical
lower bounds for
lower bounds by
omega gamma n
x y 2
the black box
of a quantum
query quantum algorithm
their joint state
exponential separation of
unlimited prior entanglement
quantum algorithm for
a basis state
shared epr pairs
for exact quantum
two qubits and
1 epr pair
bits x i
hadamard transform to
the classical world
share unlimited prior
epr pairs and
introduced by yao
quantum circuit is
of quantum and
and bounded error
protocol for f
classical communication and
good lower bound
einstein podolsky rosen
qubit ff 0
for quantum communication
by yao 53
buhrman cleve wigderson
2 classical bits
bits to bob
by buhrman cleve
the quantum communication
for bounded error
exact quantum protocols
if alice and
separation of quantum
q f and
cleve and wigderson
communication complexity on
right value f
and quantum communication
n 2 qubits
that a quantum
to 38 32
38 32 for
quantum information theory
on input x
f0 1g n
want to compute
f o 1
input x 2
to compute some
d f log
bound techniques for
deterministic communication complexity
of quantum computation
non deterministic communication
and bob share
the value f
bounds for quantum
the right value
an omega gamma
input x y
complexity of set
r 2 f
f to denote
some function f
y 2 d
and communication complexity
and r 2
lower bounds in
the communication complexity
of the protocol
qubits and or
a classical channel
power of quantum
buhrman and de
zero error quantum
use q f
a good lower
and bob s
on both x
to bob but
private vs common
to bob bob
or to make
via a classical
than classical communication
sends the result
quantum and probabilistic
t 2 log
security of quantum
ff 0 j1i
complexity is characterized
a 1 qubit
the state i
quantum mechanical algorithm
mapping ji b
of quantum key
send n bits
information theory quantum
classical communication in
entanglement and communication
a bounded error
deterministic quantum query
and de wolf
of basis states
protocol we use
all total f
epr pair to
qubit gate is
first n qubits
will generally depend
alice can just
quantum complexity theory
bob now applies
coding and a
vector of amplitudes
and 1 epr
her two qubits
rank f o
gate is the
deutsch jozsa problem
joint state is
n bit input
maps basis state
by kremer 37
a log m
2 x bob
epr pair 1
and bob each
some error probability
bob do not
prior epr pairs
communication can sometimes
common random bits
and bob do
of quantum information
and buhrman 21
related to distributive
mechanical algorithm for
private space the
survey the main
alice applies a
n bound for
matrix form this
between quantum and
applies the unitary
as little communication
y will generally
bits in communication
complexity quantum entanglement
just send her
of m f
for exact protocols
an epr pair
by superdense coding

corpus/krapavin2000-test/633565.txt
cafeobj
institution
behavioural
grothendieck
hosrwl
institutions
rwl
category
cube
morphism
rewriting
specification
morphisms
signature
msa
ntriv
imports
functor
inclusion
module
denotation
triv
nnat
mon
obj
arrows
sentences
equational
exactness
specifications
behaviourally
signatures
sp
indexed
carriers
reduct
homomorphism
mod
liberality
theories
hidden
colimits
protecting
logic
coherent
foundations
elt
fibred
sentence
loose
liberal
sorts
paradigms
sorted
algebra
algebraic
semantics
satisfaction
diaconescu
homomorphisms
ins
logics
methodologies
vars
jij
osa
rzvan
surjections
inclusions
sen
iff
nat
sign
structuring
coinduction
maude
cocomplete
import
parameterised
pow
ole
denotations
categories
ordinary
monoid
embeddings
op
composition
osrwl
jsign
mathematical
arrow
logical
transitions
instantiation
hi
parameterisation
pushout
coherence
rewrite
visible
observational
flattening
abbreviated
pullback
inherited
constructs
regarded
generalises
embeds
preserves
imported
naturals
valuations
embedding
importing
importation
ultraproducts
cha
obj2
determinstic
llanos
rincn
strict
lattice
transition
concept
hu
associativity
carrier
weak
expansion
concurrent
equivalence
paradigm
concepts
colimit
mel
initiality
ayala
hsa
surjection
monoids
jargon
hartenstein
shared
operational
ji
s2
verification
language
prototyping
commutativity
conservative
simplification
diagrammatic
formul
meseguer
lax
methodological
injective
trans
sort
conceptual
semantic
notice
idempotence
classical
membership
notably
concrete
concurrency
index
objects
ei
minded
construc
interpretations
348
familiarity
giving
declarative
morgan
firm
object
crucial
s1
executable
translated
adjoint
interplay
scripts
extra
calculus
modelled
completeness
modules
reconfigurable
informaticae
famous
the cafeobj
cafeobj cube
cafeobj institution
of cafeobj
behavioural specification
theory morphisms
in cafeobj
rewriting logic
inclusion system
the grothendieck
grothendieck institutions
category of
cafeobj is
indexed institution
the institution
an institution
theory morphism
algebraic specification
h v
the category
the denotation
of behavioural
a behavioural
grothendieck institution
module imports
extra theory
basic specification
the behavioural
signature morphism
institution of
institution is
hidden algebra
weak inclusion
shared approach
indexed category
institutions of
inclusion systems
an indexed
z z
order sorted
specification and
signature h
a hosrwl
of institution
hidden sorts
a grothendieck
in hosrwl
non behavioural
institution independent
grothendieck construction
is liberal
module system
logical foundations
of signatures
foundations of
s b
concept of
of theory
a category
model m
a h
semantics of
of specification
v s
specification in
important r
behaviourally coherent
module import
model homomorphism
cafeobj module
mon pow
institution we
theory colimits
of hosrwl
hosrwl signature
hosrwl institution
2 jij
s ntriv
the hosrwl
cube institutions
functor mod
c at
signature s
for equational
denotation of
initial model
sorts and
sp of
non shared
institution in
rzvan diaconescu
module composition
institution embeddings
op ins
t sp
behavioural coherence
system hi
proof calculus
signature morphisms
model functor
institution homomorphism
institution homomorphisms
coherent hidden
of grothendieck
jij and
cafeobj specification
of arrows
reduct functor
index category
the reduct
behavioural operations
trans m
institution the
behavioural rewriting
cafeobj the
basic specifications
structured specification
index morphism
i op
the language
a sentence
notice that
each index
s s
the mathematical
the indexed
m satisfies
r ole
equational logic
a functor
an inclusion
of specifications
s terms
multiple parameters
more classical
s term
underlying logic
behavioural equivalence
arrows of
logical semantics
the inclusion
r r
mathematical foundations
a signature
a 0
m s
from 11
the semantics
of sentences
the logical
m only
the satisfaction
s 0
of module
sentence of
a theory
0 t
see 12
m 0
with obj
behavioural specifications
and institution
easily translated
liberal if
following cafeobj
denotation sp
2 category
exact if
elt n
parameter instantiation
and grothendieck
ordinary theory
hu ji
observational logic
institutions and
institutions we
ole for
grothendieck category
as theory
s algebra
of institutions
ntriv is
institution which
specification paradigm
sentences is
nnat is
thought as
proving behavioural
s triv
model 0
cafeobj a
the carriers
the rwl
multiple imports
behavioural equation
institutions in
institutions definition
2 jsign
model reduct
its category
of the cafeobj
the cafeobj cube
the cafeobj institution
h v s
z z z
the category of
s s b
v s s
in the cafeobj
foundations of cafeobj
institutions of the
category of signatures
signature h v
the grothendieck institution
extra theory morphisms
r r r
an indexed institution
important r ole
i 2 jij
a hosrwl signature
an important r
the inclusion system
weak inclusion system
the hosrwl institution
cafeobj cube institutions
for each index
the denotation of
logical foundations of
index i 2
cafeobj institution is
m satisfies a
e m only
category of theories
semantics of cafeobj
of extra theory
m only if
cafeobj institution in
coherent hidden algebra
of the grothendieck
a weak inclusion
grothendieck institution of
inclusion system for
a basic specification
institution of the
an indexed category
of the hosrwl
i op ins
of theory colimits
2 jij and
inclusion system hi
the logical foundations
the shared approach
specification in cafeobj
of cafeobj is
the semantics of
of the language
i e m
the arrows of
is a sentence
sentence of the
the initial model
specification and programming
each index i
specification and verification
the expansion is
a sentence of
for all a
the index category
the following cafeobj
liberal if and
behavioural specification paradigm
an institution homomorphism
denotation sp of
is a grothendieck
in algebraic specification
iff the expansion
2 m s
cafeobj cube such
is a h
cafeobj cube is
part of hosrwl
r ole for
user defined transitions
theories of the
the denotation sp
behavioural specification and
a theory morphism
which embeds all
module composition system
existence of theory
cafeobj is based
the theory corresponding
specification of non
the indexed institution
op c at
result from 11
a behavioural equation
cafeobj cube the
the institution embeddings
cafeobj module system
of signatures of
shared approach the
as with obj
that the behavioural
theory corresponding to
cafeobj institution we
a s algebra
its category of
morphism u 2
of theory morphisms
non shared approach
easily translated to
exact if and
a grothendieck construction
the behavioural equivalence
j iff the
of grothendieck institutions
the non shared
satisfaction relation between
the grothendieck category
be easily translated
a h v
of an indexed
interpretation of j
index morphism u
inclusion system of
the behavioural specification
u 2 i
a signature h
the institution independent
context c z
of module imports
of basic specifications
s ntriv is
the case of
if and only
and only if
regarded as a
is an inclusion
a category c
following result from
h a 0
a natural transformation
on states of
signatures of the
the concept of
are modelled as
accordingly to the
and a s
of theories of
denotation of the
of a signature
several kinds of
for the category
the logical and
be regarded as
in the case
at the level
in the small
mathematical foundations of
only if for
model m of
the user defined
the satisfaction relation
specification in the
the completeness of
rather than in
in the shared
the operational semantics
a model m
play an important
the definition of
notice that this
for each signature
results for equational
the rewrite context
institution is a
of behavioural specifications
cafeobj specification in
12 for details
on the cafeobj
theory morphisms between
has a weak
functor mod sign
with obj cafeobj
of s sentences
liberal for each
use of behavioural
by sen hosrwl
in cafeobj the
sorted rewriting logic
actions and observations
in cafeobj we
of cafeobj the
and mathematical foundations
signature s a
cube i e
semantics of behavioural
satisfaction condition holds
an embedding indexed

corpus/krapavin2000-test/633574.txt
sup
fgng
regression
ns
lim
convergence
minimax
kd
nonparametric
antos
lip
birge
fg
classication
yang
brick
2d
rate
rates
tending
fp
devroye
gyor
el
bayes
denition
fb
stone
estimation
distributions
1g
plug
gn
lugosi
bricks
polinomial
lq
efy
er
pf
tsybakov
inmum
recognition
classes
pfc
f0
kohler
exponent
entropy
individual
rst
decision
km
fa
bounds
classi
disjoint
xed
xg
pack
fn
universally
jg
kfk1
ibragimov
xunif
fatou
massart
extention
fgn
mammen
kx
khasmiskii
efj
pedent
bxc
eln
k1np
fng
t2n
korostelev
imply
dierent
fy
fc
unif
kfk
c2c
n2n
1q
funtions
10e
efg
estimates
generalizations
mat
identically
log
assertion
recog
reconstruction
probability
derivatives
wants
chervonenkis
1045
borders
qa
barron
theorems
uniformly
asymptotic
remark
metric
lebesgue
vapnik
error
learning
counterexamples
kp
inequality
rules
sample
strange
conditioning
nish
inde
decreases
discrimination
modulus
lipschitz
00
corollary
diers
subclass
vanishing
cn
measurable
nition
segment
specially
kg
assure
tend
slow
jensen
fastest
mr
cubic
posteriori
strongest
converging
1e
references
pattern
k1
contraction
inferior
dened
0g
estimators
smoothness
concerning
d2
therein
density
jx
a2
subsequence
ts
continuity
anything
indicator
fi
strong
wishes
border
arbitrarily
cation
achievable
intersections
exclude
easier
doesn
modied
dropping
innite
tell
fr
rich
distribution
rational
slowly
statistical
spirit
derives
proofs
denitions
exponential
nontrivial
j k
lim sup
of convergence
individual lower
y 2d
convergence for
regression function
n g
c j
ns c
sup x
lower rate
function estimation
kd c
fgng sup
fg n
a j
class d
rate of
lip d
upper rate
k d
2 d
lower rates
yang 16
el n
fp j
b n
k r
a n
sup sup
x y
lower bounds
in yang
sup b
er ns
minimax lower
positive sequence
with kd
sup lim
of distributions
bayes decision
c c
assumption 1
r d
j g
of nonparametric
r ns
2d lim
birge 7
c er
individual upper
classes lip
nonparametric pattern
rules fg
log t
1 d
these classes
tending to
yang s
sup r
sup a
d kd
class f
classes d
fb n
the bayes
c n
an individual
of error
of regression
the classes
bounds for
n l
which satisfy
the rate
d c
sequence tending
in birge
xed distribution
gyor and
see antos
kd moreover
corresponding distribution
satisfying 6
gn sup
exist rules
metric entropy
the brick
distribution class
regression functions
3 fgng
than regression
let fb
of x
1 q
to zero
distributions of
0 1
n j
r i
fa n
plug in
pattern recognition
r r
the class
n a
rates of
log 1
c x
taking values
function class
the plug
m j
f0 1g
classes see
rst term
every sequence
all distributions
every c
d y
x 00
j log
probability of
on 0
exponent of
for d
r a
for every
denition 5
see also
q 1
see devroye
is lip
every distribution
2d el
antos and
t jg
d assumption
i fy
antos gyor
brick i
is sup
devroye et
b ns
estimates see
a ns
strong minimax
to yang
stone 15
kohler 4
sup gn
distribution classes
satisfy lim
d f0
function estimates
exist regression
and lugosi
gives kd
and tsybakov
n lim
fgng lim
choose fp
exist individual
k lq
convergence results
a class
g n
k 3
there exist
theorem 2
a decision
g is
the exponent
convergence of
estimation for
error of
sequence fg
classication is
rule see
if assumption
uniformly bounded
image reconstruction
sequence fa
distribution x
decision rule
and kohler
rate results
minimax theory
ns a
near 1
are arbitrarily
the support
v d
g be
support of
k then
in rule
the sequence
sample size
c j k
a j k
rate of convergence
of convergence for
sup x y
j k d
x y 2d
j k r
regression function estimation
fg n g
0 1 d
fp j g
individual lower rate
k d c
lower rate of
d c j
lim sup sup
el n l
b n a
probability of error
distributions of x
n j k
of x y
c n j
r a j
individual lower rates
fgng sup lim
in yang 16
sup sup x
sup b n
k r a
sup lim sup
lim sup b
upper rate of
k r i
er ns c
convergence for the
an individual lower
r ns c
y 2d lim
log 1 q
rules fg n
is an individual
kd c c
c er ns
the classes lip
sup a n
lim sup r
2d lim sup
ns c er
a class d
sup r ns
classes lip d
minimax lower bounds
individual upper rate
n a n
distribution of x
2 d is
the bayes decision
convergence for a
tending to zero
r r r
f n g
class of distributions
lower bounds for
rates of convergence
c c x
the rate of
n 2 d
convergence of nonparametric
for the plug
sequence tending to
kd moreover for
j k g
k d kd
in birge 7
with kd c
the individual lower
moreover for every
an individual upper
corresponding distribution class
of nonparametric pattern
of convergence results
fa n g
n g which
class d of
c x k
than regression function
a positive sequence
plug in rule
d of distributions
convergence for d
k 3 fgng
fgng sup x
distribution class d
fb n g
nonparametric pattern recognition
lip d and
the corresponding distribution
g which satisfy
n g is
satisfying 6 for
then the sequence
i a j
c 2 c
on 0 1
m j k
a n k
lower rates of
function class f
r i c
of distributions of
n g be
of convergence of
is in a
in a j
the class d
for these classes
for the classes
the plug in
j k then
d is an
as the sample
be the class
of error for
the exponent of
i c j
the rst term
for every c
error for a
for a class
j k 2
the support of
class of functions
6 for any
the sample size
strong minimax lower
is sup x
devroye et al
class f then
expected error of
c k 3
of fp j
ns a ns
sequence fg n
minimax theory of
there exist individual
assertion 2 proof
function estimation for
sup gn sup
second term c
d and v
that is sup
2d a n
because of j
d kd moreover
can choose m
bounds for learning
bayes decision for
if assumption 1
d assumption 1
lim sup gn
antos gyor and
function with support
easier than regression
of individual lower
a n remark
which satisfy lim
for every distribution
and x 00
class d if
birge 7 in
distribution x y
positive sequence fa
near 1 2
with support on
2d el n
with m c
to yang s
6 c j
i f c
for the minimax
x is uniformly
functions f such
a n lim
sequence fa n
the brick i
6 g g
j log t
support of d
exist individual lower
g g d
r d f0
rate for d
y 2d el
sequence b n
arbitrary positive sequence
are arbitrarily close
which are arbitrarily
decision for c

corpus/krapavin2000-test/633577.txt
geolev
adaboost
leveraging
margin
learner
arcing
master
weak
geoarc
boosting
descent
margins
hypotheses
hypothesis
jjh
jjdjj
sample
steepest
sin
gradient
breiman
angle
jjhjj
schapire
bagging
jj
learning
potential
orthant
learners
gammarf
confident
predictions
cone
template
x4
iterations
recurrence
ff
direction
singer
rated
confidence
training
freund
normalized
leverager
learnability
wrapper
flipping
mlc
predictors
feasible
iteration
datasets
rim
classifiers
coefficient
arc
incomparable
amortized
delta
sign
normed
sine
generalization
2m
bounds
leibler
boost
uci
conversion
kullback
wrapped
flip
continuing
classification
outlined
geometric
pac
minimized
derivatives
voting
dependence
tangent
negative
cos
repository
labels
logitboost
olev
drifting
atsch
undifferentiable
gentile
ffh
aboost
eurocolt
ffhjj2
geoboost
9700201
error
divergence
gradients
games
vectors
sees
normalizing
edge
lie
majority
weighting
normalizations
tapers
trains
abstain
gression
divergences
zoutendijk
exponentiated
fooled
unsatisfying
inscribed
fits
lemma
quinlan
hinted
unnormalized
strengthens
jagota
penalizing
convergence
viewed
transformation
empirical
intuition
yoav
warmuth
warranted
manfred
ameliorate
resampling
monotonic
additive
vector
mildly
comparably
leverages
learnable
differentiates
confidences
mason
multiplying
creates
convert
seek
abe
navigating
halving
preliminary
modified
ip
equally
decrease
wrapping
sigma1
normalization
decision
insight
intriguing
bers
committee
diminishing
arun
label
constrained
likelihood
potentials
claudio
guessing
wise
noting
decreases
contributing
flips
discriminant
tracked
cancel
instructive
c4
friedman
minimizing
corollary
logistic
prediction
ran
effectiveness
proportional
bounding
complication
weak learner
master hypothesis
the weak
leveraging algorithm
the leveraging
potential function
the sample
margin vector
leveraging algorithms
hypothesis h
weak hypothesis
the master
adaboost s
arcing algorithms
sample error
the margin
margin space
weak learning
distribution d
steepest descent
of steepest
jjh t
feasible direction
geolev s
the geolev
gradient descent
potential functions
the margins
t jj
margin vectors
master hypotheses
learner s
sin 2
jj 2
the angle
margins of
and geoarc
that geolev
adaboost and
jjdjj 1
an arcing
s hypotheses
geolev algorithm
arcing algorithm
of geolev
geolev and
goal vector
weak hypotheses
to adaboost
angle between
negative components
the direction
the potential
geolev geoarc
the boosting
arc x4
for adaboost
by geolev
direction of
h 0
a margin
low confidence
coefficient ff
between g
of h
hypotheses with
positive orthant
delta h
s hypothesis
normalized to
a weak
the distribution
direction d
angle to
a distribution
start of
equally confident
amortized analysis
of adaboost
confidence rated
new master
hypotheses produced
in margin
than adaboost
boosting algorithms
geolev to
confidence predictions
second transformation
and geolev
jjhjj 2
of leveraging
error rate
generalization error
components therefore
t iterations
schapire and
bound has
polynomial learnability
and singer
modified sample
vector g
h to
hypothesis is
the start
iterations required
this potential
hypothesis with
training error
have negative
boosting and
vector h
2 t
the sign
by majority
ff t
s bound
descent on
an amortized
sample the
h t
the hypotheses
iteration t
minimized when
sample s
to h
the coefficient
d delta
learning algorithms
given to
on h
d t
s margin
negative gradient
zero sample
approximate gradient
class classification
hypotheses produce
continuing as
natural potential
direction gradient
node decision
to recurrence
recurrence 22
breiman 5
geoarc may
geoarc algorithms
sine of
template outlined
produces hypotheses
descent the
bounds indicate
boosting a
and jjhjj
2m sin
plane p
leverager is
algorithm geolev
confident on
that adaboost
between adaboost
25 iterations
boost by
geolev is
gammarf delta
learner produces
new weak
our geometric
adaboost algorithm
the leverager
on margin
adaboost on
repository these
on jjdjj
theoretic generalization
that jjdjj
leveraging process
singer 15
after 25
rated predictions
geolev does
yields sin
valued hypotheses
large margins
2 normed
on jjh
adaboost is
descent can
decision taken
weak learners
s master
boosting property
improved boosting
by freund
weighting d
hypotheses contain
d 0
a potential
h on
between h
a feasible
the weak learner
the master hypothesis
the leveraging algorithm
the sample error
of the weak
of steepest descent
the potential function
jjh t jj
weak learner s
master hypothesis h
t jj 2
direction of steepest
of the master
sin 2 t
geolev and geoarc
the weak hypotheses
margins of the
the goal vector
the weak hypothesis
the geolev algorithm
an arcing algorithm
the angle between
on the sample
the direction of
the margins of
to the weak
master hypothesis is
the margin vector
learner s hypotheses
sample error rate
on the potential
a feasible direction
angle between g
a margin vector
between g and
the coefficient ff
over the sample
at the start
the start of
start of the
when the weak
sample s 0
s bound has
the master hypotheses
is an arcing
low confidence predictions
margin vector is
of leveraging algorithms
new master hypothesis
in margin space
the weak learning
distribution d t
have negative components
angle between h
a weak learning
goal vector g
weak hypothesis h
jj 2 1
and the margins
be normalized to
to adaboost s
the new master
the angle to
weak learning algorithm
distribution d 0
hypotheses produced by
can have negative
schapire and singer
an amortized analysis
given to the
g and the
if the weak
for the weak
learner s hypothesis
of the iteration
in the sample
of iterations required
descent on the
the positive orthant
on the weak
a potential function
the edge of
outlined in the
error rate of
edge of the
leveraging algorithms include
that jjdjj 1
uci repository these
direction gradient descent
that the weak
on jjdjj 1
the adaboost algorithm
improved boosting algorithms
this potential function
master hypotheses produced
situation in margin
a master hypothesis
arcing algorithm with
theoretic generalization of
s margin vector
boosting algorithms using
decrease the angle
generated by weak
h delta h
weak hypotheses contain
the sine of
sample given to
algorithms using confidence
by geolev to
generalization of on
hypothesis h with
equally confident on
the sample given
the hypotheses generated
the boosting property
on jjh t
boosting a weak
new weak hypothesis
potential function at
the iteration and
weak learner the
feasible direction gradient
angle to g
negative components the
a natural potential
the bounds indicate
application to boosting
sine of the
and ff t
r and jjhjj
the leveraging process
of the margins
potential function on
pac learning algorithms
better than adaboost
fits the template
the geolev and
decision taken by
and equally confident
bounds indicate that
d delta h
r 2 terms
by the leveraging
breiman 5 4
y i h
geolev s bound
descent can have
natural potential function
a second transformation
geolev does not
to an arcing
confidence rated predictions
and singer 15
decision theoretic generalization
approximate gradient descent
produces hypotheses with
correct and equally
weak learning method
zero sample error
a weak learner
of the leveraging
gammarf delta d
and the margin
bounds are incomparable
first t iterations
geolev to achieve
d t over
negative components therefore
template outlined in
by the weak
margin vectors lie
the margin of
cos 2 0
leveraging algorithm is
the leverager is
weak learner produces
and geoarc algorithms
many low confidence
incomparable to adaboost
most y s
of adaboost s
hypotheses generated by
algorithm by majority
on margin space
and g we
using confidence rated
margin space at
that geolev geoarc
h to h
leveraging algorithm based
component of h
weak hypothesis with
weak learner with
2m sin 2
jj 2 then
and geolev s
and jjhjj 2
steepest descent can
used by geolev
margin vector h

corpus/krapavin2000-test/633623.txt
parking
cars
excursions
excursion
coalescent
brownian
car
law
surely
places
aldous
prole
convergence
k1
biased
permutation
bridge
flajolet
widths
pitman
conned
jumps
probing
additive
hashing
weakly
rst
uniformly
ne
fragmentation
empirical
skorohod
chassaing
bntc
2kn
converges
shall
resp
block
blocks
pr
lim
subsection
place
entails
park
proposition
bertoin
coalescence
0st
dnu
yor
marckert
equiprobable
stochastic
owing
sup
lemma
uniform
giant
pittel
parks
random
nx
dirichlet
knuth
philippe
statistics
1f
conditional
vague
sizes
tried
multiplicative
normalized
doob
chronology
subordinator
exchangeable
louchard
dickman
metaphore
riordan
bruxelles
subordinators
perman
gaussian
schemes
equivalently
denes
borel
cantelli
harmless
poisson
yielding
simplex
universite
incidentally
width
combinatorial
fv
birth
topology
induction
theorems
density
insures
lebesgue
continuity
logarithmically
enlarge
minded
nally
occupied
largest
normalised
joint
sample
exp
innitely
consequence
1g
motion
dened
processes
sure
continuum
successively
asserted
1998
almost
emergence
xm
regards
continuous
giving
xn
dene
mathematical
bn
insertions
xi
probable
proves
sorted
empty
ci
du
cf
iii
f1
concerning
cameron
triomphe
shepp
dnxe
noncomputer
ofn
wellner
parked
plaine
shorack
cafe
ulb
cartan
bvd
talg
asnelles
binomially
straddles
elie
i2e
824
csorgo
rossler
alea
b1m
chassain
poblete
laurencot
salvy
chp
iecn
acording
combinatorists
exchangeability
desintegration
francon
dkw
kingman
charasteristic
riviera
svante
vervaat
cedex
libre
vandoeuvre
corrolary
revesz
verwaat
car c
excursions of
parking schemes
additive coalescent
n places
almost surely
size biased
of excursions
of cars
theorem 1
brownian excursion
place k
parking scheme
z n
cars on
n k
lemma 5
biased permutation
empty place
uniform convergence
of theorem
v n
distributed as
convergence of
block containing
brownian bridge
linear probing
proof of
h n
cars that
containing car
n cars
standard additive
of e
proposition 5
on 0
and independent
to park
conditional law
a brownian
sizes of
the block
subsection 5
we shall
of parking
the parking
empirical process
excursion of
conned parking
fragmentation process
law of
empirical processes
u k
widths of
of sizes
k k1
standard gaussian
of z
u m
random graph
the prole
normalized brownian
multiplicative coalescent
that tried
0 1
e n
the sequence
random permutation
jumps of
theorem 4
of blocks
of lemma
distributed on
uniform random
random variables
hashing with
on n
the empirical
r 1
the random
c 1
h k
current minimum
n m
of h
bntc n
random discrete
same law
weakly to
remaining cars
the excursions
law as
converges weakly
k cars
d ne
the skorohod
m bntc
almost sure
poisson dirichlet
k 2kn
relation 5
a random
independent of
the rst
y 1
mathematical statistics
sequence u
k t
almost any
have theorem
h v
for almost
5 12
the stochastic
of widths
uniformly to
on place
park on
permutation of
sequence of
given that
n to
the brownian
of car
above its
brownian motion
f n
uniformly distributed
the law
block of
u 1
the conditional
n converges
resp the
lim n
m k
m n
1 y
5 4
this last
5 3
shall prove
a sequence
uniformly on
excursion that
marckert chassaing
sample paths
sure convergence
parking on
vague topology
bridge we
given car
converges uniformly
uniform on
has interest
the excursion
aldous pitman
z 1f
uniformly continuous
independent uniform
excursion e
stochastic additive
between parking
any uniformly
cars parking
bounded uniformly
the conned
place 1
flajolet et
prole associated
by aldous
k1 in
1f x
1 4
owing to
order statistics
y k
k n
1 n
to z
the sizes
z z
largest block
hashing table
n above
the vague
of subsection
k places
space a
n e
n d
of independent
to lemma
x 1
n n
the proof
a consequence
random variable
the multiplicative
b 1
car c 1
of excursions of
size biased permutation
the block containing
of theorem 1
theorem 4 1
proof of theorem
of sizes of
on n places
on 0 1
widths of excursions
n k t
cars on n
standard additive coalescent
block containing car
containing car c
the standard additive
of h n
of z n
theorem 1 3
of lemma 5
uniform convergence of
theorem 1 2
sizes of blocks
theorem 1 4
the size biased
a brownian bridge
and independent of
of cars that
lemma 5 12
uniform random variables
number of cars
uniformly distributed on
excursions of z
normalized brownian excursion
1 and independent
the random graph
biased permutation of
the empirical process
its current minimum
for almost any
cars that tried
theorem 1 1
of the block
the conditional law
a random permutation
the sequence of
independent of e
r 1 n
the n k
the uniform convergence
n d ne
with linear probing
the same law
n cars on
convergence of z
place k is
h v n
excursion of e
convergence of sizes
due to 5
space a sequence
the parking scheme
excursions of h
above its current
m bntc n
converges weakly to
hashing with linear
of widths of
u k 2kn
sequence of widths
same law as
of mathematical statistics
the multiplicative coalescent
an empty place
the excursions of
sizes of excursions
excursions of e
of parking schemes
proof of lemma
we have theorem
of the sequence
n k 1
of theorem 4
distributed on 0
a sequence u
lemma 5 9
of car c
law of the
lemma 5 11
theorem 1 6
the law of
is distributed as
subsection 5 2
sequence of independent
the convergence of
we shall prove
proposition 5 3
3 proof of
the prole associated
k1 in which
sequence of sizes
conned parking schemes
gaussian and independent
law as the
to park on
5 2 that
line of proof
of subsection 5
paths of e
of the parking
for the vague
of the excursion
sample paths of
bounded uniformly continuous
h n to
independent uniform random
processes of mathematical
z 1f x
empirical processes of
a normalized brownian
brownian bridge we
parking scheme for
z n to
is standard gaussian
parking schemes for
to a brownian
interest in itself
the stochastic additive
stochastic additive coalescent
has interest in
decomposition of sample
any bounded uniformly
the conned parking
almost sure convergence
random variables u
giving the factor
that almost surely
flajolet et al
the vague topology
y k n
1f x z
car c i
uniformly continuous function
of the conned
cars parking on
theorem 1 5
standard gaussian and
n to z
brownian excursion e
conned parking scheme
uniform on 0
car c k
of sample paths
distributed as t
block of cars
almost any uniformly
parking schemes of
blocks of cars
of the largest
0 1 and
as a consequence
theorem 5 1
theorem 2 1
of a random
the largest block
v n n
conditional law of
for any bounded
lemma 5 8
cars on the
obtain that for
of h k
on the simplex
5 3 we
the proof of
permutation of the
in which n
k is empty
lemma 5 10
n e n
we shall use
lemma 4 2
e n n
as the sequence
of connected components
due to lemma
proposition 5 4
v n is
in subsection 5
lemma 2 2
4 1 is
1 proof of
proposition 5 2
of proposition 5
of f n
1 we have
distributed on the
theorem 3 1
that for any

corpus/krapavin2000-test/633709.txt
nns
performances
nn
stepdisc
regression
bonnlander
ruck
selection
relevance
saliency
neural
leray
moody
czernichow
cibas
criterion
ecd
backward
ocd
obd
dorizzi
classification
derivatives
yacoub
0000000000000000000
refenes
hessian
feature
retraining
damage
pruning
validation
training
mutual
sv
weight
stopping
monotonous
mse
derivative
stepwise
perf
prediction
parametric
measures
wilks
kittler
frontier
criteria
wave
stop
fisher
correlated
multilayer
recognition
brain
forward
ard
1994
statistical
coefficient
noisy
rossi
obs
learning
stopped
pathological
frontiers
discriminating
hypothesis
mclachlan
epanechnikov
souli
fogelman
ebd
saliencies
priddy
hajlmarsson
ssr
intensive
heuristic
entropy
prohibitive
sensitivity
1977
weights
1996
ingredients
computationally
eliminated
percentage
fukunaga
surgeon
fraser
regressor
aberrant
gustafson
axis
ranking
1986
battiti
retrained
networks
outputs
cell
variance
risk
absolute
gaussian
narendra
perceptrons
mlp
bootstrapping
estimates
representative
1992
rely
density
threshold
estimated
correlations
nonparametric
generalization
floating
estimation
correlation
fs
trained
heuristics
network
search
feedforward
perceptron
uncorrelated
cross
squared
hidden
wrt
selects
classical
meaningless
fitted
discriminant
1978
attractive
modelling
bayesian
deletion
subsets
diagonal
1970
dependencies
neurons
exhaustive
statistics
restrictive
statistic
difficulty
error
layer
differentiable
averaged
branch
confidence
1993
salient
deletes
artificial
selecting
discarding
regularization
kernels
gradient
variation
marginal
covariance
costly
selected
determinant
gasca
swinney
wertz
pertinence
001011111111111110100
hermans
10001111111111111111
kullbak
econometrics
representativeness
000110111111111011100
rdle
infraction
committees
stahlberger
multinormal
baxt
000001100111101010000
000001111110111000000
01011011101110111111
utans
feature selection
variable selection
selection methods
selected variables
the nn
mutual information
neural networks
for regression
choice criterion
validation set
weight pruning
relevance measures
stop criterion
l l
generalization error
a validation
sv p
order methods
for classification
wave problem
p selected
backward search
different variable
non linear
of variables
the hessian
the relevance
performance comparison
the selection
these methods
methods which
selection for
the saliency
variables perf
saliency is
selected variable
for nns
correlated variables
stepdisc 4
feature evaluation
good performances
non pathological
axis percentage
cell damage
method p
bonnlander 4
variable set
x l
pattern recognition
the generalization
5 2
selection method
variable subset
evaluation criterion
parametric methods
performances and
c r
take into
between variables
relevance of
cross validation
neural network
these measures
evaluation criteria
nn is
regression and
a variable
f x
r p
of variable
fisher test
of nns
model independent
pure noise
moody 5
gaussian problem
stepwise methods
fs p
relevance measure
variable relevance
two gaussian
refenes 5
dorizzi 5
for stopping
czernichow 5
architecture selection
original wave
floating search
x f
linear models
measures for
is stopped
input variables
al 1996
methods are
p a
variables in
several authors
for neural
noise variables
based feature
remaining variables
stopping the
final prediction
or classification
prediction error
training set
search and
the performances
non parametric
l x
percentage of
selection is
criterion is
performances of
methods use
5 3
variable is
best subset
best performances
input variable
these derivatives
class j
two weight
p 1
the training
been proposed
et al
estimated on
on heuristics
regression or
correct classification
the search
a feature
f c
several methods
absolute values
comparison of
of feature
authors use
optimal search
into account
of different
computed using
computationally intensive
r all
the derivative
the different
classification and
of remaining
density estimation
the network
the selected
linear regression
and regression
either for
input i
al 1994
p b
the weight
is usually
model selection
search methods
s method
propose to
diagonal approximation
cibas leray
or stepwise
to obd
since variables
backward methods
noisy wave
fitted for
regressor f
p variables
variables bonnlander
saliency of
refenes et
fogelman souli
select is
representative methods
branch bound
dependence measure
stop criteria
discriminating power
community which
each nn
relevance criterion
fixed threshold
3 dorizzi
difficulty here
data refenes
early brain
set sv
early cell
bonnlander s
performances but
derivative absolute
wilks lambda
nn variable
variable selection methods
different variable selection
of different variable
a validation set
the generalization error
feature selection methods
l l l
p selected variables
performance comparison of
f c r
of the generalization
comparison of different
method p selected
axis percentage of
feature selection method
selected variable set
selected variables perf
r p 2
stepdisc 4 2
bonnlander 4 3
l l x
of a variable
the relevance of
x l l
methods which have
feature selection for
relevance of a
may be used
all these methods
either for regression
selection is stopped
backward search and
the best performances
of selected variables
original wave problem
l x x
the original wave
5 2 7
moody 5 2
dorizzi 5 2
pure noise variables
for regression or
the two gaussian
the choice criterion
of remaining variables
czernichow 5 2
the nn is
c r all
refenes 5 2
selection for neural
using a validation
selection methods on
the selected variable
gaussian problem with
methods which use
for stopping the
order methods which
two gaussian problem
f x l
percentage of selected
compute the mutual
the final prediction
sv p 1
relevance measures for
4 3 2
et al 1996
for neural networks
4 2 2
take into account
f x f
x f x
5 2 3
non linear models
a feature selection
1 n p
best subset of
several authors have
the best subset
which have been
the mutual information
classification and regression
5 2 8
variables on the
a variable by
5 2 1
the training set
not take into
proposed to use
of feature selection
in 5 1
p a b
we have used
sets of variables
on the model
methods on the
an estimate of
in this problem
methods may be
for non linear
et al 1994
a local minimum
have used a
to take into
do not take
computed using a
the importance of
been proposed by
5 1 1
only one variable
of the relevance
set sv p
using mutual information
the nn with
to select is
density p a
methods in feature
perf stepdisc 4
optimal cell damage
o the importance
c r non
1994 proposed to
salient features for
difficulty here is
l sv p
with uncorrelated variables
percentage of variables
fs p forward
variable is found
variables selected y
cibas 5 3
table 1 selection
p th variable
variable selection in
the saliency of
variable is usually
early cell damage
stop criterion or
with good performances
the stop criterion
priddy et al
vs percentage of
of variables selected
does not delete
noisy wave problem
bonnlander s method
validation set since
correlations between variables
architecture selection for
methods vs percentage
nn is trained
stopping the selection
the wilks lambda
are nearly linear
and regression tasks
in the nn
a simple backward
families of methods
estimated on a
a choice criterion
refenes et al
each nn in
each variable deletion
the classification or
the evaluation measure
a variable subset
gustafson and hajlmarsson
bottom of table
for regression and
several methods propose
good performances but
time series modelling
proposed a series
2 3 dorizzi
simple backward search
allows to take
of correct classification
validation or algebraic
is retrained after
the noisy wave
fitted for nns
pathological data refenes
feature selection pattern
the selected variables
or stepwise methods
of weights of
data refenes 5
variables the second
the partial correlation
ruck 5 2
sub optimal search
order methods several
leray 5 3
and the nn
on a validation
ingredients of feature
partial correlation coefficient
zero order methods
regression or classification
propose two weight
as a choice

corpus/krapavin2000-test/634719.txt
recurrence
polynomials
orthogonal
rec2ortho
holonomic
classical
pols
swarttouw
koornwinder
polynomial
differential
monic
coefficients
unknowns
maple
equating
meixner
bessel
hypergeometric
standardization
numerator
laguerre
retode
obner
charlier
nonlinear
denominator
exit
warning
hermite
zeros
solutions
equation
identities
gammag
bring
rational
discrete
equate
rewrite
shift
oe
hahn
jacobi
powers
denominators
ae
family
ff
gr
4a
chebyshev
multiples
krawtchouk
pollaczek
equations
falling
multiply
radicals
gammax
degree
accessible
affirmative
maxfn
classified
transformation
transformations
factorial
definite
return
gamman
nonnegative
2a
jn
chapter
lowest
deduce
bases
families
rewriting
gets
orthogonalen
favard
leipzig
rationally
hypergeom
inators
differentialgleichungen
askey
deltarp
htwk
mws
groebner
polynome
liouvillesche
worksheet
imn
durch
racah
hyperterm
koepf
klassischen
pochhammer
charakterisierung
decides
densities
density
ag
substitute
translated
sturm
denom
gamma2x
universities
factorials
strict
transform
fa
xq
pleasant
shifted
summation
agree
classification
difference
qx
nontrivial
lim
coeffi
solve
yields
backward
die
continuous
institutions
boils
amsterdam
tom
abbreviation
algorithmically
summand
thanks
valid
forms
turns
ren
transforms
normal
cn
quantum
vanish
substituting
pn
invariant
analogue
bn
overlap
finitely
besides
formulas
ax
dictionary
question
dx
algebra
brackets
brought
der
html
visit
handbook
shifts
command
applicable
brings
decomposing
linearly
transformed
yet
cients
representations
converse
inverse
tedious
implying
returns
demands
generates
vectors
interval
modification
resolved
operators
assertion
sequel
collect
mathematical
acknowledgment
weight
article
recurrence equation
orthogonal polynomial
orthogonal polynomials
polynomial solutions
classical orthogonal
the recurrence
difference equation
n x
discrete orthogonal
classical discrete
q orthogonal
classical q
three term
term recurrence
q difference
polynomials are
holonomic three
polynomial solution
exists exit
nonlinear system
differential equation
return no
p n
the coefficients
unknowns a
linear transformation
solution exists
c d
polynomials of
standardization given
swarttouw s
koornwinder swarttouw
s rec2ortho
with koornwinder
given holonomic
and bring
solutions of
the differential
denominator of
oe x
b c
no classical
the numerator
a recurrence
yet unknowns
maple implementation
numerator or
zeros of
the zeros
the q
the denominator
k n
is larger
coefficients of
has classical
the classical
and e
the unknowns
c n
linear transformations
the standardization
ae x
d e
x n
polynomial of
polynomial form
transformation x
gammag f
gr obner
bring them
rec2ortho n
unknowns f
given recurrence
bases methods
x gammag
lowest terms
in lowest
warning parameters
obner bases
equating the
equation has
of either
the powers
t n
the degree
equation 1
of e
then return
resulting equations
implementation these
polynomial system
polynomial identities
linear transform
them therefore
7 x
one gets
e f
e c
d and
a polynomial
most second
as yet
equation of
parameters have
e according
equation x
normal forms
see e
similarly as
terms if
equation in
x 7
u n
exit 4
the bessel
accessible with
solution vectors
multiply these
these rational
common denominators
no orthogonal
monic set
returns their
identities by
implementation rec2ortho
coefficients equate
valid with
degree exactly
2 shift
table 22
difference equations
q polynomials
numerator of
methods if
a holonomic
these identities
denominators and
shift shift
koornwinder and
step according
make monic
applicable 1
given by
of degree
their common
larger than
of classical
a b
rewrite the
not accessible
coefficients a
degree of
than 4
of oe
e b
of orthogonal
of algorithm
bring these
polynomials if
the hypergeometric
degree one
equating coefficients
equation p
chebyshev polynomials
output return
3 rewriting
rewriting rewrite
by gr
two resulting
information includes
set e
b n
of polynomial
for ff
either t
or u
x is
constant with
family 1
shift by
equate the
given now
of table
for classical
is valid
n given
algorithm 2
the solution
cases i
parameter ff
these polynomials
if applicable
algorithm decides
by strict
above cases
rational functions
define v
and g
algorithm 1
a nonlinear
the recurrence equation
orthogonal polynomial solutions
classical orthogonal polynomial
classical discrete orthogonal
classical q orthogonal
polynomial solutions of
p n x
three term recurrence
term recurrence equation
b c d
n is larger
holonomic three term
orthogonal polynomials are
solution exists exit
recurrence equation 1
orthogonal polynomial solution
polynomial solution exists
d and e
denominator of e
n x is
e c n
the q difference
unknowns a b
q orthogonal polynomials
q difference equation
a b c
if the degree
the denominator of
c d and
q orthogonal polynomial
recurrence equation has
with koornwinder swarttouw
then return no
swarttouw s rec2ortho
discrete orthogonal polynomial
a recurrence equation
koornwinder swarttouw s
classical orthogonal polynomials
the unknowns a
return no classical
c d e
the differential equation
the zeros of
of e c
is larger than
d e f
the coefficients of
x is not
the numerator or
degree of either
discrete orthogonal polynomials
numerator or the
equating the coefficients
equation has classical
rewrite the recurrence
a given holonomic
e a n
as yet unknowns
coefficients of x
or the denominator
either the numerator
a polynomial of
recurrence equation in
u n x
normal forms of
t n x
of oe x
polynomials are not
f and g
solutions of the
e b n
b n is
of e b
c n is
the degree of
differential equation 3
in polynomial form
of orthogonal polynomials
x or u
obner bases methods
given holonomic three
larger than 4
lowest terms if
coefficients a b
zeros of oe
either t n
transformation x 7
at most second
a given recurrence
and e of
the difference equation
warning parameters have
or u n
terms if the
linear transformation x
bring them therefore
0 n n
7 x gammag
and bring them
them therefore in
difference equation 5
therefore in polynomial
gammag f with
of polynomial solutions
parameters have the
in lowest terms
with as yet
have the values
x gammag f
implementation these results
ff 2 r
unknowns f and
given recurrence equation
rec2ortho n 2
gr obner bases
the classical orthogonal
yet unknowns f
by their common
if either t
a nonlinear system
our implementation these
a linear transform
using our implementation
are not accessible
n 1 0
f with as
of either the
equation of the
1 0 n
the linear transformation
see e g
n 2 n
the coefficients a
in x or
x 7 x
e according to
results are obtained
n 1 k
of x n
similarly as in
constant with respect
in the continuous
solution vectors a
this information includes
input a holonomic
common denominators and
3 rewriting rewrite
the two resulting
applicable 1 input
methods if the
the classical discrete
rational functions in
shift shift by
if applicable 1
recurrence equation is
rewriting rewrite the
then the recurrence
their data if
about the standardization
obtained by strict
recurrence equation by
polynomials are multiples
orthogonal polynomials if
this algorithm decides
a holonomic three
standardization given now
1 input a
recurrence equation p
monic set e
solutions and returns
equations this results
now a define
is valid with
n x of
difference equation x
in the unknowns
of the numerator
cases i e
1 similarly as
data if applicable
difference equation 6
coefficients equate the
linear transform of
e r x
multiply these identities
not a polynomial
equation 2 shift
one in x
step according to
polynomials are given
these identities by
information includes the
output return the
the standardization given
consider the recurrence
denominators and bring
not accessible with
nonlinear system in
polynomial solutions and
recurrence equation 2

corpus/krapavin2000-test/634745.txt
determiners
determiner
mon
students
drank
beer
glass
monotonicity
collective
atom
plural
sentence
gqt
dfit
witness
ptriv
quantification
dalrymple
operator
scha
rtriv
existential
plurals
sentences
benthem
monotone
count
conservativity
quantifiers
atoms
distributive
five
downward
predicates
conservative
smiled
triviality
roommates
van
denotation
happy
article
shifting
quantifier
ltriv
19c
upward
der
student
denotations
bc
collectivity
winter
entities
fitting
wit
entailments
polarity
argument
pi
reciprocal
collections
drink
hungry
counting
neutral
arguments
distributivity
definite
coffee
atomic
who
iff
predicate
lifting
1981
barwise
cooperated
keenan
sisters
colleagues
conjunct
hit
truth
undesired
noun
shop
montague
men
whole
linguistic
meanings
rich
friends
plurality
yesterday
preserved
nominal
girls
preservation
singular
verb
dark
ve
theories
participated
schwarzschild
licenses
ahl
drinking
westerst
nps
cars
proposal
imposes
permutation
problematic
met
treatment
empirical
cooper
man
saw
familiar
linguistically
19a
haifa
gqs
people
1984
proposes
1974
erator
articles
language
colleague
asymmetries
reformulation
interpretation
1992
couples
sing
nouns
empirically
reflects
1993
phenomena
implication
requirement
preserves
grammar
tautology
functors
1998
trivial
entailment
meaning
singletons
treatments
reformulate
intuitions
participation
1g
composition
contemporary
readings
semantics
intersection
reconsider
equivalences
2001
derives
entail
phrase
members
operators
sang
blue
israel
lifted
items
seemingly
cons
1986
ja
interacts
3a
ever
came
cf
expressions
respects
treated
semantic
iota
reviewer
fauconnier
sneezed
34a
bauerle
glass of
whole glass
drank a
beer together
of beer
the determiner
monotonicity properties
exactly five
atom atom
a determiner
of determiners
determiner d
mon mon
atom determiner
students drank
five students
determiner is
over e
a whole
the students
set determiner
left argument
students who
collective predicates
dalrymple et
collective quantification
determiners that
of collective
count d
type shifting
der does
collective determiners
n operator
is mon
the monotonicity
of students
of atoms
right argument
determiner over
not mon
set set
plural determiners
atomic entities
determiner fitting
determiners in
the witness
van benthem
s d
natural language
witness operator
and mon
the dfit
dfit operator
d s
d is
bc operator
van der
students are
e operator
than five
operator is
d over
in natural
or mon
mon determiners
of plural
downward monotone
existential requirement
mon and
hit each
count operator
determiners are
non ptriv
mon or
standard gqt
collective predicate
the count
sentences such
monotone in
atom set
some but
right monotone
determiners such
left monotonicity
who drank
rich students
definite article
the bc
over collections
in gqt
argument of
the existential
second argument
witness set
quantification in
counting process
is conservative
an atom
all a
b e
denotation of
this article
in sentences
exactly 5
not all
of plurals
bounded composition
atom determiners
non preservation
conservative atom
been roommates
determiner that
determiner all
witness condition
under count
either mon
not rtriv
who ve
their monotonicity
student 0
of scha
ptriv and
determiners the
first argument
of atomic
operator that
al s
sets of
fact 7
ve been
argument but
the definite
that count
to collective
the counting
of sets
properties of
of monotonicity
and collective
scha s
with collective
monotonicity loss
determiner count
most five
who hit
generalized quantifier
sub process
is pi
all some
0 student
right trivial
set determiners
negative polarity
global determiner
determiners this
fitting operator
for plurals
man 0
a distributivity
always preserved
are happy
determiner are
monotonicity under
this determiner
distributive predicates
mon then
dark beer
coffee shop
monotonicity of
d be
left right
domain e
for instance
let d
power set
the denotation
a witness
its left
a distributive
operator let
sentence 6
the coffee
generalized quantifiers
winter 1998
of dark
the quantifier
quantifiers and
pi and
an existential
the atom
non monotonicity
any atom
composition operator
a conservative
all is
iff for
this operator
the e
truth value
monotonicity property
whole glass of
glass of beer
a whole glass
drank a whole
of beer together
atom atom determiner
students drank a
monotonicity properties of
dalrymple et al
s d s
all the students
exactly five students
van der does
of the determiner
determiner over e
determiner d over
set set determiner
the n operator
count d is
the left argument
the monotonicity properties
is not mon
the dfit operator
d over e
of collective quantification
in natural language
determiners that are
atom determiner d
properties of determiners
of atomic entities
sets of atoms
set of atoms
sentences such as
the e operator
the right argument
the count operator
hit each other
atom determiner over
d is non
mon or mon
the witness operator
some but not
for all a
the students are
the students who
sets of atomic
the students drank
quantification in natural
an atom atom
a determiner d
the bc operator
who drank a
five students drank
is non ptriv
determiners such as
of collective determiners
five students who
of determiners in
d is mon
students who drank
in s d
d is not
but not all
monotone in its
defined for all
the definite article
non ptriv and
over e is
exactly 5 0
who ve been
left argument of
of a determiner
is either mon
that count d
determiner d is
the determiner all
over e the
b e by
a determiner is
students who ve
the witness condition
ve been roommates
of plural determiners
conservative atom atom
atom atom determiners
either mon or
atom set determiner
let d be
set of sets
et al s
less than five
and van der
a b e
of the students
e the corresponding
iff for all
such as all
in this article
at the coffee
the coffee shop
at most five
the determiner is
of dark beer
determiner fitting operator
downward monotone in
determiner count d
any atom atom
be a conservative
who hit each
beer together in
of the definite
non preservation of
their monotonicity properties
set determiner count
all a e
the set set
d is pi
5 0 student
glass of dark
properties of collective
students are happy
its left argument
global determiner d
0 student 0
bounded composition operator
a global determiner
dark beer together
to collective predicates
mon and mon
classes of determiners
the existential requirement
sets of students
argument of the
the second argument
the denotation of
more than five
all a b
of sets of
is defined for
witness set of
by the count
e and b
the counting process
subsets of e
be an atom
in sets of
d be a
in this situation
d be an
the first argument
that a global
set determiner that
d s n
the following sentence
monotonicity property in
as all some
determiners that satisfy
winter 1998 2001
not all and
the rich students
distributed sets of
distributed set of
operator let d
and ii below
existential requirement in
when the determiner
drink beer 0
n operator is
than five students
the van benthem
an existential requirement
number of students
a conservative determiner
determiner d that
e then for
when they apply
collective predicates in
determiner that is
participated in sets
right argument with
of quantification in
saw each other
beer together all
was a set
that the denotation
argument e g
set of students
of scha and
van benthem problem
this determiner is
beer together b
with collective predicates
every conservative atom
than exactly five
in sentences such
over e for
with mon determiners
determiners in gqt
the atom atom
such as 19c

corpus/krapavin2000-test/634756.txt
egenet
layout
plm
adjustment
fsa
quad
overlapping
solver
penalize
lagrangian
layouts
overlap
dyn
mental
genet
constrained
scaling
multiplier
opt
quadratic
modied
orthogonal
satisfaction
gls
misue
eades
preserve
nd
constraint
lagrange
drawing
csp
endif
scale
bmx
endfor
disjunctive
revise
oo
optimization
nite
ij
node
reset
minima
neighbours
csps
adjusted
rst
dene
minval
mincost
bestcost
bmy
solvers
constraints
ordering
mx
stepsize
predened
neighbour
initialize
remove
nds
shrunk
optimum
stopping
augmented
penalties
aesthetic
multipliers
unnecessarily
resource
exceeded
labels
minimize
preserves
vars
satised
continuous
penalty
force
objective
crossing
mch
busting
minimimizing
aesthetically
disadvantage
horizontal
exibility
ciency
pleasing
lai
convex
updating
preserving
direction
anchored
perm
violated
jv
ciently
nodes
static
label
eect
removing
heuristic
search
dierent
dimension
graphs
invokes
solving
scan
australia
oating
simplest
map
fourth
domains
sampling
pseudo
halt
coordinates
factors
huang
vertical
positions
solve
strengthened
var
ranges
nding
modify
display
animated
enlarged
australasian
norm
cpu
labelled
mu
orthogonality
removes
height
position
xed
neural
placement
convergence
fastest
violations
modication
dy
handle
edge
wei
empirical
dierence
iterates
spring
symmetry
formulating
normalized
nikola
reoptimizations
besti
z2d
microgenetic
77760
wanchun
justment
dsz
5535
langrangian
sajeev
cryptarithmetic
lyons
2821
fteen
2844
abutt
38880
nikolov
127008
omax
155mhz
3688
tunneling
8108
lmms
counteracting
readablity
lapping
junbin
9and
rightwards
modica
layout adjustment
layout with
node overlapping
the egenet
adjustment problem
constrained optimization
orthogonal ordering
initial layout
graph layout
egenet solver
modied egenet
local search
the layout
egenet and
for layout
and plm
with quad
best layout
continuous constrained
new layout
overlap constraints
original egenet
mental map
plm figure
uniform scaling
quadratic programming
the modied
c no
for graph
no overlap
graph 8
d layout
with scale
with fsa
with plm
with egenet
augmented cost
egenet opt
scale fsa
f layout
the x
optimization problem
c layout
satisfaction problems
graph drawing
scale c
fsa d
adjusted layout
egenet f
remove node
quad e
adjustment problems
e layout
resulting layouts
resource limit
the orthogonal
cost function
layout for
original graph
x direction
layout is
the graph
optimization problems
c oo
optimization function
dynamic layout
fsa quad
overlapping in
and resulting
layouts for
the adjusted
and y
node v
to preserve
cost z
y direction
multiplier methods
graph 9
of dyn
graph s
constraint satisfaction
the constraints
preserve the
objective function
a solution
scaling factors
local minimum
and fsa
egenet approach
egenet network
b layout
convex quadratic
removing node
egenet model
penalize opt
misue et
sampling size
domain sampling
by scale
penalize ctr
overlap constraint
solution found
initial and
the variables
best solution
c y
the augmented
quadratic solver
to layout
graph 7
problem as
a constrained
adjustment in
x 0
f z
to nd
layout in
x and
graph 1
8 by
a graph
nd the
a local
the optimization
local minima
search methods
s mental
s orthogonal
force scan
layout since
of misue
overlapping nodes
overlapping constraints
normalized optimization
right horizontal
plm gives
the plm
solver can
quad egenet
the original
no node
c x
the search
the no
each variable
the penalty
the constraint
y directions
lagrangian multiplier
lagrangian method
original structure
scan algorithm
graph 6
each node
z b
z v
constraints c
active set
the initial
preserving the
the nodes
the best
the objective
no x
m x
nd a
of constraints
to solve
the y
node labels
solution is
a nite
for solving
scaling in
a predened
node label
the mental
linear constraint
limit is
the overlap
is reset
reset to
the lagrangian
nodes as
adjustment as
revise bounds
worst layout
adjustment with
overlapping while
solution cost
initialize vars
var order
label overlap
plm solver
resulting layout
peter eades
and egenet
static layout
tree layout
mx ij
layout adjustment problem
the layout adjustment
the initial layout
the modied egenet
for layout adjustment
egenet and plm
the orthogonal ordering
constrained optimization problem
the best layout
the original egenet
layout with egenet
layout with plm
d layout with
layout with quad
augmented cost function
with plm figure
c layout with
layout with scale
f layout with
layout with fsa
the x direction
continuous constrained optimization
resulting layouts for
initial and resulting
layout adjustment problems
layouts for graph
and resulting layouts
e layout with
the augmented cost
the new layout
the original graph
the x and
in the x
with fsa d
egenet f layout
as a constrained
scale c layout
quad e layout
layout adjustment in
no overlap constraints
fsa d layout
with egenet f
with scale c
the adjusted layout
scale fsa quad
with quad e
remove node overlapping
constrained optimization problems
x and y
a constrained optimization
subject to c
the objective function
local search methods
node overlapping in
solve the layout
the egenet approach
the no overlap
adjustment problem as
the egenet solver
removing node overlapping
b layout with
the node overlapping
misue et al
resource limit is
approach to layout
to layout adjustment
domain sampling size
graph 8 by
the y direction
problem as a
the graph s
of the graph
best solution found
constraint satisfaction problems
user s mental
a continuous constrained
s orthogonal ordering
no node overlapping
force scan algorithm
a convex quadratic
graph s orthogonal
the dynamic layout
the force scan
egenet solver can
dynamic layout adjustment
fsa quad egenet
and y directions
mental map of
of misue et
the mental map
scale and fsa
modied egenet solver
initial layout is
c no x
node overlapping constraints
in the egenet
adjustment problem is
value of dyn
each node v
u is su
represents a solution
a local minima
is reset to
of the nodes
gives the best
solution is found
for the graph
domain of each
to nd the
for the x
the best solution
to preserve the
the active set
disadvantage is that
lagrangian multiplier methods
node overlapping while
solver can be
the egenet network
how the egenet
no overlap constraint
a no overlap
overlapping while preserving
node v to
preserve the orthogonal
plm gives the
original egenet solver
uniform scaling approach
the worst layout
layout adjustment as
which will remove
modied egenet and
local search method
dynamic graph layout
normalized optimization function
layout adjustment with
the resulting layout
the penalize ctr
preserving the user
existing graph layout
towards the solution
layout adjustment for
y 0 s
by scale fsa
pseudo lagrangian method
node overlapping the
for graph 9
node label overlap
produces the best
orthogonal ordering constraints
graph layout adjustment
of layout adjustment
overlapping in graph
the plm solver
the uniform scaling
the domain sampling
new layout is
investigate how the
egenet opt invokes
the optimization function
of the egenet
the solution cost
original egenet model
adjustment in a
the resource limit
static layout adjustment
s mental map
both the x
the cost function
in the y
a local minimum
a solution is
of the original
to nd a
of each variable
of v or
nds a solution
a linear constraint
the previous solution
v or u
be expressed directly
the original structure
and m y
the x dimension
right of v
or u is
active set method
how to modify
x 0 v
for the y
of the layout
of the best
is su ciently
constraints of the
the local minimum
the constrained optimization
the scaling factors
in operations research
the x 0
of the orthogonal
programming problem which

corpus/krapavin2000-test/634941.txt
majda
pego
capillary
bt
drs
hyperbolicity
ow
leverett
instability
hyperbolic
porous
elliptic
eq
saturations
corner
riemann
deg
stone
conservation
saturation
umbilic
region
diusion
pressures
eqs
stability
interior
eigenvalues
det
permeabilities
eld
pressure
mp
bifurcation
permeability
eigenvectors
oil
strict
ref
laws
neighborhood
buckley
waves
capillarity
eigendirection
boundary
convective
petroleum
triangle
eigenvector
h1
vh
corners
prop
gas
og
nonuniqueness
family
immiscible
marchesin
eigendirections
sh
near
eects
jacobian
nondegeneracy
posedness
strictly
quadratic
cnpq
uid
locus
plohr
mobilities
water
d1
edge
generically
matrix
shock
reservoir
h3
phase
azevedo
reservoirs
diffusive
d3
regions
continuous
unstable
viscosity
elds
br
suciently
sec
hypotheses
wo
curves
sucient
diusive
sotomayor
parabolicity
dge
zumbrun
viscosities
roussarie
admissibility
media
diffusion
vanish
nd
stable
slow
parabolic
wave
takens
kw
bogdanov
medium
flow
determinant
eigenvalue
coincide
dms
refs
associate
mixed
remark
secs
rotates
proposition
h2
rotate
assumptions
fractional
characteristic
curve
ux
evidently
satises
angle
speeds
wg
ill
open
grant
vanishes
linearized
phases
dened
porosity
compressibility
pore
nonclassical
props
dumortier
calculations
dene
contour
arc
equations
traversing
viz
nonzero
inequality
nilpotent
oscillatory
nonexistence
instabilities
seepage
coinciding
loci
satisfying
lemma
boundaries
p3
satised
numerical
nonnegative
denition
traveling
interpolation
odd
experimentally
tangent
linearly
ection
diagonally
rst
purely
smooth
concerning
mobility
statement
traverses
thermal
qp
u2
oscillation
nonpositive
majda pego
three phase
the majda
phase ow
strict hyperbolicity
line eld
assumption 4
0 u
u 2
saturation triangle
assumptions 4
fast family
conservation laws
f 0
b u
4 18
the corner
capillary pressure
phase flow
interior of
elliptic region
the saturation
the interior
stone s
instability region
g bt
strictly hyperbolic
r f
s w
pego stability
deg r
capillary pressures
the capillary
hyperbolic region
det r
drs point
the elliptic
18 4
the eigenvalues
open edge
pego condition
satisfying assumptions
quadratic stone
u 1
4 22
prop 2
4 25
to s
s g
s model
associate u
family line
by eqs
the buckley
the saturations
a drs
drs points
g e
the fast
of strict
the boundary
4 19
point u
the edge
neighborhood of
by eq
open neighborhood
near the
component system
buckley leverett
eigendirection of
slow family
ow models
e bt
linear stability
of riemann
porous medium
drs bifurcation
linear instability
bt u
porous media
a neighborhood
boundary of
r s
stability condition
model satisfying
and u
and bt
continuous line
ref 3
umbilic points
leverett capillary
riemann problems
in porous
the corners
by prop
that det
under grant
eigenvalues of
u r
two component
f 1
for three
multiple of
ow in
eld on
positive multiple
mixed type
system 4
eq 2
and f
4 21
u is
eqs 6
the strictly
pego instability
of drs
riemann solutions
in petroleum
the leverett
pressure jacobian
purely convective
characteristic speeds
conditions d1
unstable region
convective form
permeability k
diusion matrix
pego unstable
a porous
pego stable
eq 6
the slow
if u
the open
r j
of in
u 0
2 18
eq 4
in ref
right eigenvectors
elliptic regions
2 6
of f
at u
in eq
laws of
j u
eq 1
a continuous
a model
instability in
phase i
we nd
the quadratic
and 4
deg e
the mobilities
of capillarity
constant solution
k ow
two saturations
marchesin plohr
balance matrix
cnpq under
leverett s
h1 h3
of secs
an umbilic
azevedo marchesin
immiscible three
plohr and
umbilic point
ow s
k og
fractional ow
neighborhood v
bt the
linearly stable
the oil
ow functions
an eigendirection
stable region
continuous oriented
of sec
suciently small
of conservation
elliptic boundary
by assumption
u and
an open
w and
e u
strict inequality
normalized so
a point
s f
system 1
condition for
f 0 u
the majda pego
three phase ow
the saturation triangle
of the saturation
the interior of
three phase flow
in the interior
the fast family
of strict hyperbolicity
stone s model
assumptions 4 18
for three phase
and u 2
of f 0
interior of in
4 18 4
majda pego stability
u 2 to
u 1 to
to s w
of b u
s w and
assumption 4 18
quadratic stone s
associate u 1
and 4 25
majda pego condition
satisfying assumptions 4
the elliptic region
a neighborhood of
1 to s
2 to s
a drs point
model satisfying assumptions
family line eld
fast family line
a model satisfying
the quadratic stone
in a neighborhood
an open neighborhood
at the corner
the boundary of
18 4 22
phase ow models
point u 2
of the majda
the open edge
eq 1 1
the buckley leverett
of in a
s and f
boundary of the
for a model
u 2 e
by prop 2
b u r
neighborhood of the
the eigenvalues of
in porous media
by assumption 4
line eld on
strictly hyperbolic region
bt u 0
g bt u
conservation laws of
the slow family
phase ow in
system 1 1
pego stability condition
continuous line eld
two component system
we associate u
w and u
of the corner
near the boundary
a continuous line
a point u
positive multiple of
for the slow
s g and
by eq 6
pego instability region
capillary pressure jacobian
the leverett capillary
g e u
phase flow in
which the majda
purely convective form
in the strictly
majda pego stable
majda pego unstable
the strictly hyperbolic
majda pego instability
the elliptic boundary
region of strict
of conservation laws
in a porous
pego unstable region
det r f
system 4 8
laws of mixed
the capillary pressure
a porous medium
assumption 4 19
0 u is
to s g
lemma 2 6
of system 1
of mixed type
a positive multiple
on the edge
u 2 u
at the corners
r s and
or s g
two phase ow
the hyperbolic region
4 22 and
the capillary pressures
marchesin plohr and
of drs points
s w or
ow s w
eq 2 18
22 and 4
fractional ow functions
azevedo marchesin plohr
eigenvalues of f
leverett capillary pressures
pego condition for
pego stable region
condition 2 6
ow in porous
the purely convective
conditions d1 and
cnpq under grant
of riemann solutions
given by eqs
4 19 and
det r s
an eigendirection of
an umbilic point
w or s
r j u
18 4 19
immiscible three phase
open neighborhood v
that det r
in ref 3
that g e
convective form of
existence of drs
e and bt
linearly stable near
by eqs 6
if we associate
normalized so that
the region of
that f 1
prop 2 3
stable near the
g and u
f 2 2
if u 2
system 4 9
condition for the
1 and u
f 1 1
we nd that
such that g
u 1 and
be a continuous
hypotheses of theorem
2 1 has
in an open
the hypotheses of
u is a
matrix f 0
0 u and
as u traverses
by an odd
on the saturations
the unique eigendirection
hyperbolic conservation laws
satises assumptions 4
and sucient condition
eigendirection of b
of phase i
assumptions 4 24
point of strict
hyperbolicity of the
s r b
are smooth curves
saturation triangle and
eld rotates by
line eld rotates
a j u
solution u x
odd multiple of

corpus/krapavin2000-test/634972.txt
safety
lf
certifying
touchstone
compiler
typed
recipient
bcopy
producer
safe
trusted
dst
evidence
compliance
annotations
edx
pcc
policy
int
csubneq
gcc
assembly
assertions
cons
csubb
sel4
x3
src
code
carrying
proofs
certificate
tal
ann
eax
certificates
certified
invariants
fr1
movl
ebx
x1
checking
pointer
logical
gnu
compilation
r3
mobile
ecx
hoisted
x0
unpack
qsort
trust
languages
x2
vc
infrastructure
policies
sharpen
kmp
blur
ms
array
validity
nil
certification
verification
r1
checker
language
intermediate
cmpl
vcgen
intg
cedilla
java
simplex
complies
cc
loop
r2
register
null
locals
dereferences
consumer
checkable
compilers
prover
esp
dec
integrity
o4
accumulator
huffman
twelf
imul
elf
6arrays6bcopy1aiai
codefr1
jmp
car
cdr
typing
generator
provers
compiled
92
comply
attached
dependently
tilt
rm
burden
tag
annotated
ret
assurances
certify
jumps
unsafe
program
programs
warrant
unoptimized
judgment
soundness
signature
void
frameworks
excerpt
modula
annotation
checked
isolation
1372
underwritten
2528
20308
4340
03000
anteneh
esi
checkability
05000
1885
l22
2748
2218
1912
underwrite
ass10
1874
edge50001500025000
intgg
gmean1000
17260
instructions
checks
proving
discipline
pf
jump
provably
nop
1272
definitional
dereferenced
0time
1248
hoisting
l7
3792
snippet
4532
cert
caller
inv
accesses
optimizations
unreachable
bars
object
mem
executable
496
edi
suppliers
mov
security
native
52
optimizing
818
x86
l6
ptr
compromises
the safety
safety policy
computing base
trusted computing
has type
typed intermediate
proof carrying
certifying compiler
a certifying
carrying code
code recipient
typed assembly
intermediate languages
the trusted
safety is
of safety
logical framework
type annotations
the lf
the code
assembly language
the compiler
object code
the producer
logical assertions
mobile code
verification condition
special j
add x1
safety policies
evidence of
type system
safety of
type checking
the evidence
a safety
explicit proofs
safety infrastructure
x2 add
in lf
gnu gcc
proof generator
sel4 x2
the recipient
type list
level languages
for safety
a proof
a type
the proof
certified code
kmp unpack
unpack bcopy
dec cc
sharpen qsort
simplex kmp
blur sharpen
qsort simplex
x1 4
safety properties
of compliance
validity of
the program
proof checking
memory safety
lf logical
csubb x3
touchstone is
safety certificates
recipient can
producer to
code the
dependent types
high level
type information
the validity
well typed
int list
safe mobile
code is
the loop
compliance with
complies with
compiler for
safety invariants
r2 fr1
certifying theorem
safety certificate
certifying compilers
code block
the touchstone
edx i
generation ms
int r2
code producer
checking compliance
3 52
o4 2
recipient to
condition generation
x3 sel4
verification conditions
cedilla systems
bcopy edge
return address
trust the
low level
the return
provably safe
gcc and
cons h
52 3
logical frameworks
code blocks
producer s
type checker
source language
type theory
type int
run time
the verification
a code
44 2
2 92
92 3
target code
theorem proving
compiler is
code this
intermediate code
formal representation
theorem prover
l has
program code
the type
code in
that type
theorem provers
16 3
2 44
type directed
imul x3
add imul
ann inv
safety specification
must trust
as touchstone
bcopy 6arrays6bcopy1aiai
language compiled
pseudo register
f sum
bounds check
flow safety
certificates can
codefr1 int
touchstone compiler
csubneq x1
cons int
pointer arithmetic
and pointer
ann unreachable
by touchstone
rm mem
each compilation
nil void
safety 2
add x0
check type
pointer dereferences
movl 4
safe component
the pcc
safety proof
void cons
a checkable
the logical
this code
attached to
safety and
code to
comply with
type safety
the dec
a verification
integrity of
are safe
and explicit
the object
to rely
compiled by
the integrity
list 2
dependently typed
a judgment
to trust
fault isolation
proof p
the bars
to typed
null pointer
the safety policy
trusted computing base
the trusted computing
proof carrying code
typed assembly language
typed intermediate languages
a certifying compiler
with the safety
the safety of
has type list
the code recipient
evidence of safety
sel4 x2 add
evidence of compliance
add x1 4
kmp unpack bcopy
blur sharpen qsort
simplex kmp unpack
qsort simplex kmp
sharpen qsort simplex
x2 add x1
of the trusted
of the proof
the object code
t has type
a safety policy
in the lf
the safety infrastructure
the proof generator
the lf logical
lf logical framework
l has type
the validity of
high level languages
of the safety
safe mobile code
safety of the
validity of the
the return address
the logical framework
of the code
of a safety
int r2 fr1
complies with the
x3 sel4 x2
unpack bcopy edge
the producer s
the verification conditions
of safety is
safety is the
a verification condition
2 44 2
verification condition generation
csubb x3 sel4
that the program
it is to
2 92 3
provably safe mobile
of mobile code
formal representation of
has type int
for the safety
certifying compiler for
v has type
a formal representation
is well typed
of the compiler
comply with the
a type system
a i 1
the integrity of
the program code
the compiler is
of the evidence
type system is
the code producer
int and t
control flow safety
for proof carrying
type annotations in
type list then
the recipient can
nil void cons
safety policy in
and t has
in the trusted
run time checking
i f sum
the touchstone compiler
bounds and null
each compilation phase
h has type
language compiled by
safety policy and
codefr1 int r2
condition generation and
the proof carrying
the bounds check
checking compliance with
add imul x3
safety policy this
int for i
certificates can be
void cons int
a proof p
cons int list
safety infrastructure is
such as touchstone
compiled by touchstone
of rm mem
to rely on
that the code
of a proof
in the logical
how can we
proof that the
for safety is
with all optimizations
for a code
of these invariants
cons h t
that the recipient
for provably safe
the program does
type int and
low level languages
to typed assembly
if l has
the evidence of
design of the
type system for
is the property
we are exploring
type checking in
a i f
if h has
well typed programs
a type directed
discussed above the
safety properties of
the safety property
to ensure that
for i 0
the compiler can
programming languages a
the theorem prover
of the object
recipient of the
the source language
a logical framework
program does not
we discuss in
are likely to
time required to
is to decide
it is much
is attached to
i 0 i
the types of
are required to
it has not
soundness of the
proof in the
73 9 8
represented as terms
the given assertions
52 3 86
automatic theorem proving
logical assertions and
3 20 9
the gcc and
the dec cc
a code block
51 2 97
03000 05000 0time
0 818 0
infrastructure is to
hoisted note that
computing base since
theorem provers the
with mathematical rigor
i e src
system for expressive
array bounds and
0 1912 0
62 5 50
6 92 5
certifying compiler such
because the compiler
never jumps to
decision procedures 12
it must work
0 136 0
the harder it
44 2 76
560 0 4340
x3 1 sel4
certifying theorem provers
does not crash
meta language for

corpus/krapavin2000-test/635014.txt
semiring
scsp
csps
concrete
abstraction
semirings
sol
galois
soft
abstract
idempotent
scsps
fuzzy
abstractions
concretization
abstracting
satisfaction
preserving
tuple
subtuples
monotonicity
lattice
reals
constraint
coni
tuples
insertion
denition
lattices
naturals
nd
glb
classical
abstracted
hdef
csp
dene
ti
safe
inconsistencies
multiplicative
dened
opt
consistency
clp
dierent
solutions
optimum
intensive
propagation
bring
insertions
formalizations
nding
bistarelli
monotone
ordering
anything
con
valued
safeness
prade
1i
pl
constraints
possibilistic
vs
ha
ordered
didier
rst
maximize
additive
incomparable
easier
opposite
species
idempotence
dubois
multiplying
fd
commutative
preference
gure
coincide
henri
absorbing
locally
branch
onto
correctness
lowering
stefano
map
don
associative
composition
notice
closer
fig
hints
min
costs
arc
passing
hn
frameworks
combining
semantics
family
simplied
element
topology
reformulation
maps
combine
concerns
00
interpretation
partial
souhila
s_fuzzy
bonchi
b1g
extensivity
hf0
benferhat
lattice1
timetabling
ellman
s_prob
s_csp
intensiveness
giampaolo
interchangeability
myampersandrdquo
semir
abscon
surjectivity
fcsp
ordeing
bella
bipolar
tosca
approximating
expressive
transitivity
theorems
1g
fusion
worse
dening
preservation
def
relate
brings
counterparts
formalization
adjoints
kaci
absurd
analyis
combina
approximation
obtaining
proposals
compiling
satised
arrows
associating
correct
hc
upgrading
duced
interchangeable
notion
shorter
artificial
says
intelligence
uncertainty
recalled
hpl
giunchiglia
posets
intro
myampersandldquo
fausto
disregarded
guiding
monotonic
integers
want
coincides
notions
probabilities
formalism
think
domain
relationship
the concrete
the semiring
the abstract
an scsp
order preserving
concrete problem
scsp problem
soft constraint
galois insertion
abstract problem
the abstraction
a galois
sol p
optimal solution
v 0
problem p
in p
constraint satisfaction
that v
semiring values
f sol
optimal solutions
with value
have that
concrete semiring
semiring s
semiring value
soft constraints
of abstraction
classical csps
abstraction scheme
p over
concrete and
constraint problems
semiring is
solution correct
monotonicity of
an optimal
an abstraction
a semiring
is idempotent
the concretization
of p
preserving property
valued csps
not idempotent
f p
solution of
s v
abstraction function
concretization function
not order
associated to
tuple t
new problem
abstract problems
abstract semiring
locally correct
value v
a soft
the naturals
to nd
v s
satisfaction problems
local consistency
over s
the lattice
abstract one
concrete problems
constraint problem
solutions of
a a
by monotonicity
0 v
the abstracted
abstract domain
semiring and
semiring element
concrete side
semiring where
concrete scsp
the scsp
fuzzy semiring
multiplicative operation
scsp p
abstracted version
abstraction is
from fuzzy
abstraction from
solution with
nd an
the multiplicative
each tuple
the fuzzy
smaller than
0 5
is safe
given an
partial order
of soft
this abstraction
function maps
is order
than 0
tuple in
p which
is smaller
abstract interpretation
p and
the glb
semiring based
and intensive
semiring over
fuzzy csps
that sol
abstract side
abstracting soft
solution correctness
hdef coni
galois insertions
c semiring
local correctness
safe solution
csps this
ti property
the semirings
abstractions between
idempotent then
concrete lattice
bring back
two semirings
to fuzzy
abstraction which
of abstractions
concrete domain
value 0
if is
p 0
of constraints
optimal in
a solution
s consider
see theorem
two abstract
our abstraction
positive reals
two lattices
opt p
domain values
each constraint
is total
our notion
if instead
or also
than v
into 1
the optimal
the monotonicity
tuples are
nd all
optimum of
p with
any tuple
in 16
a fig
0 6
abstract scsp
for scsps
semirings and
fuzzy csp
of semiring
two us
concrete ordering
concrete one
n csps
in valued
same solutions
abstraction framework
v sol
soft csps
fuzzy n
problems concrete
abstraction changes
semiring that
semiring for
scsp which
preserving abstraction
property says
intensive then
problem say
from optimization
some subtuples
abstraction we
negative reals
function f
c v
the tuples
in 0
value greater
of domain
the abstract problem
given an scsp
an optimal solution
the concrete problem
in the concrete
an scsp problem
a galois insertion
scsp problem p
optimal solution of
we have that
the concrete semiring
in the abstract
solution of p
problem p over
optimal solutions of
the concrete and
p over s
have that v
a a a
with value v
v s v
that v s
concrete and the
of the concrete
that v 0
on the abstract
the optimal solutions
0 v 0
solution with value
order preserving property
not order preserving
f sol p
of the semiring
the semiring values
and the abstract
of the abstract
the concretization function
the order preserving
s v 0
the abstraction function
soft constraint problem
soft constraint problems
if is idempotent
over s consider
the abstract semiring
is not idempotent
a soft constraint
t in p
constraint satisfaction problems
by monotonicity of
the new problem
v 0 v
on the concrete
nd an optimal
is order preserving
the concrete side
the abstracted version
theory of abstraction
the concrete scsp
monotonicity of we
the fuzzy semiring
the multiplicative operation
problem and then
is not order
p which is
notion of abstraction
the abstract one
over the naturals
than 0 5
is smaller than
to nd an
a a fig
the abstract domain
s consider a
obtained by combining
of domain values
solution correct and
which is safe
abstraction which is
all the optimal
sol p is
is locally correct
correct and intensive
safe solution correct
the abstract side
easier to solve
the two semirings
is safe solution
the concrete lattice
any tuple t
to a semiring
semiring over the
f on p
f is safe
p is smaller
on p which
that sol p
to the concrete
function f on
consider a function
the monotonicity of
our notion of
f p is
bound of an
to each tuple
v 0 2
constraint of p
value v in
say x and
v in p
0 5 and
v 0 by
the concrete domain
greater than 0
value of t
w r t
in p which
of we have
a solution with
smaller than 0
solution of the
of t in
solutions of the
is obtained by
that of p
local consistency algorithm
problems a a
concrete problems a
problem p 0
tuple t with
galois insertion from
than 0 6
over the concrete
of an optimum
the concrete ordering
of a galois
with the glb
this abstraction changes
the negative reals
concrete problem in
order preserving abstraction
family of abstractions
is idempotent then
abstract problem and
the positive reals
a semiring s
in valued csps
locally correct w
is solution correct
an abstraction which
multiplicative operation of
over the semiring
1 into 1
in 0 x
the corresponding concrete
semiring that is
in constraint satisfaction
if two abstract
associated to s
abstract problems concrete
with value greater
some useful information
an scsp p
semiring values of
the concrete one
value associated to
problems concrete problems
take any tuple
abstracted version of
in each constraint
local correctness of
p with value
are order preserving
the abstraction from
of an scsp
and intensive then
abstraction from the
0 by monotonicity
reals into the
f is solution
maximize the minimum
abstract problem say
tuple of domain
csps this abstraction
abstraction scheme for
tuples of values
intensive then if
have that opt
the ti property
optimum of p
the same solutions
of some subtuples
the scheme when
of a soft
solution correctness of
the partial order
a function f
to prove that
value greater than
of the tuples

corpus/krapavin2000-test/635238.txt
irup
cutting
stock
csp
trim
zz
instances
km
divisible
dz
piece
pieces
pattern
feasible
relaxation
dominant
gap
mirup
ea
gaps
maximal
patterns
investigations
proper
lp
csps
fulfilled
assertion
iq
families
cut
nica
family
integer
material
belong
2p
eg
relaxations
packing
residual
knapsack
dominance
possesses
round
pe
fulfilling
possessing
equivalence
fulfills
cf
delta
abbreviation
demands
prime
pairwise
ed
lengths
reels
0741
0394
wooden
0444
1csp
gamma2q
roundup
supplementing
since2b
0667
unpacked
fmg
0sufficiently
gau
9p
ng
dimensional
inequalities
tends
belongs
loss
units
0556
gilmore
deltae
gomory
structur
continuous
contradiction
ql
dominates
rational
f1g
impression
lim
initiated
1j
fulfil
asymptotically
mj
concluding
ld
implemen
tations
integral
1994
lexicographically
counterexample
conjectured
3g
demand
possibilities
fulfill
plane
rounding
arise
tend
said
counter
unlimited
branch
heuristics
z
interval
omitting
decade
nd
equals
duality
cone
gamma
sufficiently
remarkable
shortly
f2
violating
summarizing
possess
intractability
increased
arises
tighter
matrix
rarely
bin
inequality
generality
ae
infinity
supposed
remarks
especially
separating
pi
ir
succeed
62
smallest
00
characterized
modelled
fifth
index
infinite
substitution
ratios
analogously
ff
published
tests
conjecture
decreasing
difficulties
constructive
identified
constructions
remember
comprehensive
fl
ith
negative
observations
numerous
coefficients
relatively
identification
odd
notations
importance
mostly
named
modified
completeness
sizes
largest
inherent
covered
occurring
versa
verify
sake
non irup
pattern a
irup instances
cutting stock
instance e
stock problem
z c
cutting pattern
cutting patterns
divisible case
the csp
the instance
zz m
dimensional cutting
dz c
the cutting
2 zz
to e
instances e
proper pattern
trim loss
feasible with
non equivalent
k instances
delta e
patterns a
a with
exist any
the divisible
integer round
continuous relaxation
up property
c e
the pattern
one dimensional
round up
of instances
to m
pieces of
e t
maximal cutting
irup instance
dominant if
stock material
trim less
e dz
feasible pattern
non dominant
equivalent non
the gaps
of e
an instance
not belong
a j
e p
a pattern
maximal with
because of
lp relaxation
any proper
e 0
of length
piece lengths
less pattern
ed defined
pattern matrix
maximal pattern
equivalent instances
show z
irup 1
total trim
order demands
stock problems
modified integer
the mirup
t a
of non
the instances
belong to
be cut
have z
pairwise relatively
km and
be dominant
will consider
negative integer
the integer
there does
feasible for
instances with
1 k
instances of
k 2
d a
the stock
any maximal
families of
a 1
of cutting
of construction
instances as
e hence
relatively prime
csp is
for instances
the piece
instances can
p 1
e is
z e
any feasible
the lp
such instances
a i
note the
instance is
possesses the
integer solution
to cut
is feasible
m proof
a is
j d
gaps tend
exist non
instances belong
theoretical investigations
dominant cutting
cutting plane
csp are
km km
relaxation bound
gap equal
proper patterns
k instance
stock length
feasible patterns
a trim
asymptotically bounded
2 iq
dominant patterns
irup in
pattern ea
irup k
with cutting
gap delta
of csps
order demand
1 km
ng denote
lim p
irup if
a dominates
smallest piece
3 belongs
instance presented
dimensional csp
1 fulfills
small gap
no trim
3 patterns
then assertion
1 instances
have initiated
dominance let
p units
knapsack problems
property irup
investigations a
if delta
j nd
e k
a 6
exact solution
a then
not exist
m 1
pattern with
instance with
k e
for k
family of
that means
solution of
the continuous
the family
index set
for proof
with k
loss of
if z
instances in
if l
z z
e pattern
family with
of investigations
solution approach
maximal patterns
problem csp
non irup instances
cutting stock problem
respect to e
belong to m
dimensional cutting stock
one dimensional cutting
of the csp
the instance e
of non irup
feasible with respect
pattern a with
2 zz m
z c e
pieces of length
the one dimensional
a non irup
integer round up
pattern a j
cutting pattern a
round up property
the divisible case
the pattern a
zz m 1
families of non
not exist any
a with a
not belong to
pattern a is
feasible pattern a
pattern a a
e dz c
non irup instance
non equivalent non
1 k instances
trim loss of
stock problem a
the cutting stock
l 2 zz
proper pattern a
equivalent non irup
dz c e
the continuous relaxation
maximal with respect
a pattern a
a d a
feasible for proof
instance e p
ed defined in
trim less pattern
the instances e
exist any proper
in the divisible
piece of length
irup 1 k
have z c
because of construction
defined in 3
the modified integer
family of instances
total trim loss
the order demands
maximal cutting pattern
irup instances of
times the pattern
since the gaps
cutting pattern of
cutting stock problems
modified integer round
instance e 0
patterns a j
non irup 1
we will consider
we have z
of e is
instances of the
there does not
non negative integer
of non equivalent
pairwise relatively prime
consider the instance
the lp relaxation
then the instance
cannot be cut
to m proof
does not belong
equivalent to e
index set of
family of non
with a d
e t a
c e e
to e if
6 a with
a a 6
for instances of
e is also
is feasible for
if t a
a 6 a
with k 2
i 2 i
if the order
of the lp
with respect to
does not exist
p 1 the
a is said
only if l
do not belong
the index set
for the one
of the continuous
the csp is
algorithms and computer
tend to 1
exact solution approaches
has a trim
to e pattern
property irup if
i an instance
any proper pattern
pattern is not
pattern a dominates
the smallest piece
if z c
irup instances can
6 because of
relaxation of e
cutting and packing
of instances e
because of t
c if z
exists a column
the total trim
belongs to d
to the divisible
we show z
in 3 belongs
the gaps tend
any cutting pattern
stock problem csp
lim p 1
the stock length
pattern a of
maximal pattern a
with a because
instances can also
asymptotically bounded by
because of 5
have initiated a
e pattern a
2 the instance
instances belong to
irup instance is
least one piece
a column a
a trim loss
if p 5
any feasible pattern
with 3 patterns
integer vector a
z c if
gap equal to
with e t
lp relaxation with
gap delta e
p of instances
become independent from
with gap equal
problems algorithms and
delta e 1
the cutting pattern
exist non irup
non dominant patterns
irup instances in
be dominant if
column a k
a maximal pattern
3 belongs to
be cut with
the order demand
than 1 in
1 k instance
dominant cutting patterns
to become independent
there exist non
instance presented in
the integer round
of zz m
dominant if there
non irup k
to be dominant
instance e is
be given such
to e then
to obtain non
any maximal cutting
e then a
instances with k
is also feasible

corpus/krapavin2000-test/635239.txt
greedy
admissible
matroids
gale
matroid
coxeter
symplectic
orderings
weight
orbit
acting
rank
polytope
compatible
root
attains
roots
edmonds
rado
unstarred
solves
cyclic
starred
supporting
ba
injective
nite
bipartite
hyperplane
gelfand
spanning
652
ordering
polytopes
denition
orthogonal
orders
poset
endpoints
correctly
steiglitz
hyperoctahedral
greedoids
borovik
optimization
combinatorial
chooses
edge
collection
group
subsets
representatives
lawler
continuation
action
answered
5g
a2a
joining
transitively
papadimitriou
permutations
ordinary
bijection
conversely
intention
texts
proposition
acts
dene
nd
induced
f1
dened
bouchet
51234
45123
sitive
korte
xag
involutions
maximumwith
34512
lovasz
cryptomorphic
sympletic
serganova
precede
permutation
symmetric
geometric
lie
dening
edges
evasive
negating
objective
classical
consisting
f6
rmative
i2b
furnishes
12345
vertex
characterized
nonempty
denitions
icting
avenues
concerning
algebra
cosets
6g
strata
vertices
remark
cardinality
white
transpositions
automorphism
acyclic
transitive
characterization
parabolic
hr
combinatorics
antisymmetric
vector
concerns
cient
interchanged
subsume
inverse
arrangements
fag
exive
contained
1g
weights
geometries
symmetrically
element
situations
lg
lexicographically
246
manifolds
reversing
corollary
tran
signicance
convex
fails
question
generality
partial
intentionally
torus
light
irreducible
eectively
put
bases
subgroup
attain
perturbed
hall
sought
naturally
notions
2g
compatibility
hull
orthonormal
f2
comprising
readability
violating
brackets
philip
theorems
meant
preferable
achieves
partially
perturbation
comprise
tree
nds
objectives
closed
motivates
rst
converse
realization
maximizes
satised
ordered
elementary
greedy set
the greedy
greedy algorithm
s p
weight function
k greedy
greedy sets
a greedy
rank k
admissible vector
a root
gale order
admissible weight
for s
on s
correctly solves
the gale
symplectic matroids
a rank
s k
optimization problem
acting on
orderings of
l is
linear orderings
admissible for
algorithm correctly
is admissible
an admissible
pair s
function f
set for
k element
admissible functions
compatible with
l s
of s
group case
coxeter matroids
solves the
cyclic group
admissible function
o k
total weight
f v
attains a
element subsets
linear orders
the cyclic
maximum on
linear order
of l
the optimization
s q
matroids the
problem for
parallel to
only linear
f b
example 3
order on
in p
single orbit
matroids of
every linear
polytope l
is supporting
algorithm chooses
unique maximum
weight functions
optimization problems
is compatible
nite set
tree problem
orbit of
of greedy
linear ordering
of example
a nite
p contains
action of
p consisting
and admissible
linear extension
roots are
that l
all linear
then l
orthogonal to
the order
spanning tree
the roots
is parallel
partial orderings
conversely assume
f a
set l
p g
the group
linear objective
group acting
edge e
combinatorial optimization
set s
vector v
a polytope
ordering in
algebra root
every weight
simple framework
gale maximum
rado and
supporting hyperplane
some admissible
the matroid
hyperplane of
orbit o
admissible the
s together
matroids are
be supporting
gelfand and
matroid case
collection l
set system
f compatible
and edmonds
if f
theorem 5
collection of
both endpoints
f is
in l
a collection
of g
edge of
case let
if l
of matroid
many but
root systems
matroid theory
g acting
2 greedy
a supporting
lie algebra
x attains
that f
p if
if and
the pair
b f
contains only
for every
subsets of
a weight
subset l
all admissible
every admissible
group z
rank 2
every edge
order if
l o
a maximum
the admissible
the spanning
not parallel
function there
root then
theorem 4
ordered set
p there
set and
property that
the induced
of root
z 5
vector 1
not admissible
i for
root of
condition 3
a geometric
on n
a unique
be called
the action
continuation of
maximum in
independent sets
k is
the linear
at both
on l
sets are
and 34
l at
the collection
all i
the greedy algorithm
a greedy set
for s p
greedy set for
set for s
rank k greedy
weight function f
k greedy set
optimization problem for
is a greedy
correctly solves the
orderings of s
algorithm correctly solves
pair s p
l s k
greedy algorithm correctly
to a root
a rank k
admissible weight function
order on s
solves the optimization
parallel to a
the gale order
is a rank
on s k
linear orderings of
l is a
the optimization problem
for s q
nite set s
the group case
contains only linear
admissible for s
s p if
is admissible for
l is not
the cyclic group
p contains only
f is admissible
s p g
element subsets of
k element subsets
acting on n
admissible vector v
spanning tree problem
problem for every
not a greedy
greedy algorithm chooses
then the greedy
acting on s
the greedy sets
a weight function
f is compatible
the pair s
f b f
s p is
under the action
with the order
s k is
is compatible with
the order on
is a root
a root of
subsets of s
of example 3
for every linear
l o k
set in l
a single orbit
greedy set and
compatible with some
gale order if
an admissible weight
of greedy set
edge of l
if every edge
of partial orderings
in the gale
maximum on l
only linear orders
greedy sets are
l is parallel
conversely assume that
a linear extension
attains a maximum
an admissible vector
ordering in p
every edge of
for the order
of a nite
b f a
then l is
assume that l
linear function f
function f v
partial orderings of
the roots are
which the greedy
at both endpoints
p consisting of
not a root
o k is
is parallel to
a nite set
if and only
and only if
of l is
group acting on
a unique maximum
edge e of
of s p
s p and
greedy algorithm and
theorem 5 7
compatible with the
the action of
the linear function
element of l
example 3 4
order in p
k greedy sets
every admissible weight
denition of root
k is supporting
v x attains
symplectic matroids the
all admissible functions
not admissible the
any pair s
lemma 5 6
continuation of example
orthogonal to some
set s together
function there are
cyclic group z
example 2 5
rado and edmonds
f compatible with
every weight function
admissible the greedy
greedy set l
s together with
all k element
for every weight
n the roots
s p consisting
lie algebra root
linear extension of
of g acting
rank 2 greedy
orbit o k
the matroid case
matroids the greedy
of linear orderings
that p contains
x attains a
in the matroid
supporting hyperplane of
to some admissible
a supporting hyperplane
on l at
e of l
set and admissible
2 greedy set
f v x
for many but
p of partial
some admissible vector
subset l s
a simple framework
theorem 5 5
consisting of a
set l s
many but not
for every admissible
a maximum on
of all k
g acting on
problem for all
a rank 2
not parallel to
root of s
for all admissible
contained in a
is not a
that l is
of theorem 4
is a continuation
the spanning tree
a continuation of
of a polytope
f a for
is an admissible
that f b
by the greedy
of all linear
example 3 3
of s the
proof assume that
p there is

corpus/krapavin2000-test/635251.txt
crossings
crossing
vertices
heuristic
heuristics
hamiltonian
neural
flcnp
mplan
bisect
page
drawing
greedy
graphs
edges
cube
len
subgraphs
embeddings
layout
planar
hypercubic
book
bisection
vertex
pagenumber
bruijn
edge
ccc
gr
displays
cq
hq
interconnection
fmt
udb
dyn
pages
neuron
embedding
tq
crossed
hypercubes
layouts
hypercube
torii
flq
wbf
neurons
ran
italic
sx
pub
excitatory
vlsi
xed
pk
books
d2
circulant
embeddable
dimension
hamming
cycle
thickness
folded
recalculation
aside
uv
adjacency
dier
stacks
cycles
networks
opt
bisected
toroidal
fen
kautz
conjectured
st
positioned
branch
subgraph
rcd
insignicant
outerplanar
labelled
twisted
inhibitory
rst
nc
pm
cross
complexities
network
cpu
greedily
butter
dierent
predetermined
plane
recurrence
iterations
star
rad
versatile
84
cr
nd
optimally
permutations
motion
drawn
196
jl
nding
specied
rank
density
eight
dg
wrapped
inline
link
loop
tied
comput
torus
architectures
simulator
arc
convergence
optimality
2e
minimization
node
dm
par
embed
regular
ordering
plot
formed
3d2
planarization
unxed
1654
mostb
poorest
runing
embeddding
circulants
ubd
lution
27knalso
k8
mcculloch
cnmgrafmyampersandmdash
subhamiltonian
conected
alphaserver
2e1
eggleton
cnmgraf
2100a
topologies
ik
bounds
sorting
readability
brie
orderings
embedded
adjacent
deviation
handbook
eective
pendant
discernible
discouraged
nervous
headings
connectivities
diogenes
1016
pancake
shue
dwarfed
supergraph
undetectable
deviated
undirected
signicant
diagrams
exact
exceeds
solutions
spine
ipping
crossing number
of crossings
node line
the heuristics
e len
test graphs
d vertices
gr ran
crossings in
1 page
d has
programming heuristic
planar crossing
a graph
of dimension
number problem
of graphs
linear crossing
exact algorithm
the node
neural network
of vertices
dynamic programming
hypercubic networks
2 page
2 d
de bruijn
each edge
dyn bisect
d2 d
greedy gr
len 1
link edges
mplan e
page drawing
page dyn
ran mplan
bisect neural
graph drawing
d 1
the book
book crossing
complete graphs
initial upper
q d
random graphs
o m
the neural
greedy heuristic
d of
hamiltonian cycle
heuristics the
the crossing
embeddings of
optimal solution
vertex ordering
in crossings
fmt italic
crossing minimization
xed linear
pub fmt
regular figure
hamming cube
test graph
linear layout
network heuristic
book embeddings
st d
in books
maximal planar
crossed cube
bisection heuristic
one page
a hamiltonian
heuristics and
along the
edge is
edges are
two pages
put aside
heuristic this
smallest increase
edge density
drawing and
layouts of
the bisection
upper bound
network model
2 edges
graph layout
layout problems
layout problem
1 edges
line in
the vertices
bound algorithm
l g
a crossing
connected cycles
graphs with
optimal solutions
graph g
edges between
cube connected
vertices are
crossings obtained
bit binary
fixed linear
aside in
heuristic results
graph 30
positioned along
smaller subgraphs
cq d
vertices 00
d bit
book thickness
books a
the pagenumber
neural found
crossings number
tq d
page embeddable
network graphs
upper page
ccc d
page heuristic
vertices along
embedding graphs
neural figure
lower page
global upper
pk d
sequential simulator
hamiltonian order
sx d
crossings found
the crossed
hq d
the edge
all test
edges and
k n
for parallel
parallel computation
has d
the hypercube
drawing of
the planar
edges in
the page
predetermined and
optimal vertex
crossing numbers
greedy heuristics
29 29
neural and
a heuristic
and bound
all edges
labelled by
the xed
an optimal
an edge
heuristics for
for graphs
graph was
vertices were
some interconnection
heuristic based
average rank
graph size
motion equation
has 2
interconnection networks
graphs in
minimum number
the cube
vertices and
branch and
with up
the subgraphs
theoretical bounds
partial solution
a drawing
vlsi design
base cases
embeddings for
edge length
dimension d
heuristic is
algorithm are
an experimental
planar graphs
a layout
star graph
although its
are added
m 2
adjacency matrix
number of crossings
the node line
crossing number of
along the node
d of dimension
of a graph
node line in
crossing number problem
dynamic programming heuristic
planar crossing number
of crossings in
of the heuristics
linear crossing number
2 d vertices
1 page dyn
e len 1
len 1 page
gr ran mplan
greedy gr ran
dyn bisect neural
ran mplan e
mplan e len
page dyn bisect
d vertices and
the neural network
each edge is
initial upper bound
book crossing number
the crossing number
o m 2
number of a
the planar crossing
pub fmt italic
the initial upper
on the neural
has 2 d
d has d
the two pages
d 1 edges
neural network heuristic
the exact algorithm
graphs with up
link edges between
d has 2
2 d 1
number of the
crossings in the
the book crossing
embeddings of graphs
the edge density
smallest increase in
and bound algorithm
the cube connected
neural network model
for graphs with
cube connected cycles
for parallel computation
line in the
of dimension d
d 1 2
the other heuristics
heuristic based on
page drawing of
for complete graphs
embedding graphs in
put aside in
positioned along the
2 page drawing
in books a
1 2 edges
the crossed cube
increase in crossings
xed linear crossing
aside in the
that a heuristic
an optimal vertex
optimal vertex ordering
the vertices along
regular figure 5
of crossings number
the upper page
the xed linear
a 2 page
crossings number of
global upper bound
node line and
heuristic results for
crossings found by
network model of
of crossings obtained
graphs in books
all test graphs
the book thickness
of crossings found
of test graphs
bisect neural figure
neural found the
the hamming cube
d bit binary
on the node
o n 4
branch and bound
the dynamic programming
the minimum number
the optimal solution
d is formed
of dimension the
pair of edges
the smallest increase
graph drawing and
a heuristic based
crossings in a
the motion equation
ordering of vertices
for the crossing
to the layout
for all test
edges and is
found the optimal
minimum number of
drawing of g
i k j
to the page
a hamiltonian cycle
time complexities of
with up to
a graph g
an exact algorithm
vertices are adjacent
two vertices are
the complete graph
the adjacency matrix
edges are added
times for the
of the graph
a dynamic programming
the number of
complexities of the
of the motion
for a graph
number of vertices
bounds for the
for each edge
vertices on the
29 29 29
a horizontal node
the bisection heuristic
major order of
four pages are
page if an
are adjacent i
the hypercube q
embed the edges
lower page if
books a layout
of dimension were
heuristic gr ran
the two greedy
an optimal ordering
edges ik and
cr i k
and book embeddings
for the fixed
fixed linear crossing
phase are added
graph was 84
arc in one
ik and jl
hq d of
vertices 00 0
positions are not
a theoretical network
of vertices greedy
st d has
linear and book
is predetermined and
the heuristics are
exceeds the current
196 test graphs
opt greedy gr
two greedy heuristics
heuristic this is
are not xed
vertices i j
pages are necessary
the circulant graph
neural and e
labelled by all
of four graph
q d by
found by heuristic
several heuristics and
sorting using networks
motion equation loop
page embeddable graphs
the 2 page
and the hamming
networks proposed as
of linear layout
bisect and dynamic

corpus/krapavin2000-test/635468.txt
iho
wrapping
ivps
odes
lohner
stepsize
taylor
enclosure
eect
qr
eigenvalues
interval
coe
obreschko
pts
enclosures
hermite
validated
cients
truncation
factorization
arithmetic
intervals
stability
ivp
box
advancing
overestimations
rigorous
series
instability
ordinary
nonsingular
corrector
enclosing
moore
sti
ode
rotated
stable
enclose
overestimation
enclosed
matrices
di
nding
uniqueness
dened
eigenvalue
berz
makino
nonautonomous
lim
widths
diagonal
jr
bigger
cient
wrapped
tight
tend
error
jt
validating
triangular
parallelepiped
signicantly
jacobian
ty
unstable
nn
lth
tighter
eective
formula
perspective
midpoint
distributive
law
magnitudes
veri
reducing
bounds
advances
numerical
xed
newton
preprint
priori
asymptotically
nd
expansions
ith
formulas
exible
ax
matrix
predictor
propagates
expositional
hidde
stepsizes
eigenraam
zonotopes
eijgenraam
rihm
tadiff
mag
kruckeberg
fadbad
obreschkoff
pade
parallelepipeds
dierenti
nitudes
roundings
subdistributive
unshifted
ranges
width
conjugate
inclusion
propagating
picard
moduli
kw
diagonalized
lindelof
outwards
dissipative
jacobians
orthogonal
sides
culty
ample
principal
vectors
outline
round
ir
nota
unacceptably
dierentiating
pth
differential
validate
autonomous
propagated
ellipsoids
orbits
oscillates
veries
ab
interpreted
normally
phases
showed
jhj
banach
guaranteed
dierent
validates
scalars
quotients
existence
suer
outward
535
parabolic
tighten
serious
integration
reliability
block
nite
uv
contracts
rearrange
converge
cult
interpret
ation
abs
overestimate
ated
lr
readily
dierentiable
jong
francis
grid
automatic
meth
modulus
products
magnitude
jaj
chips
overview
solutions
the wrapping
wrapping eect
ivps for
for odes
global error
for ivps
taylor coe
lohner s
taylor series
interval arithmetic
its method
iho method
y iho
y its
the solution
the stepsize
eigenvalues of
the iho
an its
pts method
s qr
direct method
qr factorization
an interval
hermite obreschko
interval vector
interval methods
truncation error
w y
computing rigorous
stepsize and
interval hermite
factorization method
coe cients
the eigenvalues
y j
true solution
the its
the interval
its methods
stable scheme
the pts
constant stepsize
interval taylor
interval vectors
validated methods
rigorous bounds
the taylor
methods for
stability of
the global
and order
for advancing
enclosure of
ordinary di
j 1
the stability
the direct
more stable
algorithm ii
advancing the
t j
intervals a
initial value
error in
error of
solution of
odes and
interval method
the qr
existence and
p q
coe cient
an enclosure
lim j
value problems
and uniqueness
much bigger
y t
scheme for
method and
new perspective
eect in
standard numerical
at t
reducing the
of taylor
local truncation
asymptotically unstable
nonsingular with
computed bounds
iho methods
rotated box
formula 29
enclosure y
standard functions
validated solutions
of validated
law does
wrapping effect
iho scheme
obreschko method
qr algorithm
series coe
priori enclosure
methods considered
tight enclosure
order taylor
in interval
22 that
arithmetic operations
20 21
and matrices
in 22
r j
y 0
method is
real intervals
point interval
r nn
enclosures of
its and
q p
z j
bigger than
a box
that lim
high order
of interval
upper triangular
instability in
unstable in
eect as
cient of
s method
2 r
perspective on
bounds on
the true
of reducing
point methods
unique solution
eect the
eect is
solution on
recent advances
a b
uniqueness of
tend to
box is
solution set
is nonsingular
applied with
for reducing
of ordinary
of eigenvalues
some recent
showed in
the truncation
of y
computing tight
lohner 17
describe lohner
of lohner
wrapping of
for sti
series its
or wrapped
series expansions
eigenvalues f
enclosure method
eect can
of moore
wrapping e
guaranteed bound
equal magnitude
moore 19
ax j
arithmetic evaluation
berz and
by intervals
odes but
f ax
parallelepiped f
validating existence
iteration 48
odes have
principal diagonal
exible c
machine interval
obreschko iho
how lohner
diagonal tend
stepsize or
iho y
propagates with
an ivp
di a
and midpoint
method propagates
the wrapping eect
ivps for odes
for ivps for
the global error
methods for ivps
reducing the wrapping
the direct method
an its method
s qr factorization
global error in
taylor coe cients
lohner s qr
qr factorization method
global error of
the eigenvalues of
taylor coe cient
the iho method
the true solution
on the solution
the solution of
at t j
of the solution
eigenvalues of t
the stability of
an interval hermite
advancing the solution
computing rigorous bounds
the pts method
more stable scheme
stable scheme for
interval hermite obreschko
lohner s method
a constant stepsize
rigorous bounds on
stepsize and order
interval methods for
for advancing the
enclosure of the
a more stable
high order taylor
the taylor coe
on the wrapping
the its method
an interval method
interval arithmetic operations
constant stepsize and
validated methods for
for odes and
wrapping eect in
the interval vector
much bigger than
w y its
scheme for advancing
that lim j
in 22 that
solution of an
existence and uniqueness
problem of reducing
lim j 1
perspective on the
initial value problems
new perspective on
error in the
a new perspective
order taylor series
vectors and matrices
error of the
with a constant
bounds on the
the computed bounds
1 the wrapping
a priori enclosure
reduce the wrapping
showed in 22
sense that lim
the interval taylor
wrapping eect the
overview of interval
interval taylor series
in interval methods
local truncation error
a tight enclosure
for computing rigorous
the local truncation
not much bigger
for the its
for the truncation
w z j
series coe cients
applied with a
interval vectors and
for an ordinary
taylor series coe
hermite obreschko method
w y iho
the wrapping effect
asymptotically unstable in
wrapping eect as
some recent advances
the interval arithmetic
wrapping eect is
the solution on
stability of an
generation of taylor
and uniqueness of
uniqueness of the
intervals a b
on each step
2 r nn
unstable in the
y j 1
q p q
of y t
of reducing the
a unique solution
for reducing the
than the global
in the direct
by the box
the truncation error
the taylor series
problem for an
coe cient of
value problem for
we showed in
to the eigenvalues
for the solution
an initial value
recent advances in
for the global
bigger than the
initial value problem
of an initial
the mean value
then a is
stability of the
and r j
bound for the
an a priori
we outline the
formula for the
is nonsingular with
cients of y
1 w y
and order k
d r n
2 x g
odes but also
generating the taylor
the principal diagonal
the its and
taylor series expansions
computed by generating
when applied with
methods for initial
nding a more
interval vector y
f ax j
wrapping of the
hermite obreschko formula
in an its
of the its
and order to
stepsize or increasing
ivp for an
parallelepiped f ax
discuss some recent
if t has
the algebraic eigenvalue
the rotated box
computing tight enclosures
in the pts
ir and 2
a exible c
distributive law does
the parallelepiped f
arithmetic evaluation of
on the stepsize
diagonal tend to
validate existence and
standard numerical methods
that w y
the hermite obreschko
orthogonal and r
machine interval arithmetic
of interval taylor
ith taylor coe
a block upper
the standard functions
three intervals a
solution y t
method propagates with
for the iho
its method is
for propagating the
the y 1
a b ab
its method we
a xed matrix
for odes are

corpus/krapavin2000-test/635471.txt
dae
daes
ode
projector
ker
subspaces
im
projectors
decoupling
index
cf
solvable
bdf
commute
stepsize
inherent
ivp
coe
discretization
hessenberg
euler
nullspace
ds
remark
dierential
numerically
leading
dp
differential
continuously
dq
dened
2g
formulated
matched
subspace
dierentiable
densely
regular
properly
solvability
kutta
runge
algebraic
numerical
denition
adjoint
hilbert
onto
abstract
cl
cients
nj
supposed
subintervals
equations
pe
f1
restrik
nullspaces
tischendorf
dissipativity
bvp
higueras
pdae
mrz
dx
ind
exive
hamiltonian
respective
quadratic
dn
nonsingular
bijective
bijection
j1
backward
rewrite
reformulations
semidenite
contractive
fredholm
approved
commutativity
benet
stability
realize
vanishes
remarkable
dierentiate
boundary
nonlinear
coupled
factorization
uniquely
maps
db
cient
integration
nice
berlin
modied
matrices
factorizations
satised
gures
homogeneous
manifolds
transparent
dierent
assertion
obviously
operator
seemingly
matrix
reformulated
invariant
circuit
modication
formulate
nd
smoothly
spaces
stated
injective
advatages
hilbertraum
refactorizations
derlying
bvps
10099
representaions
treatet
dierentiably
dieculties
simulaneously
respresentation
anlogous
nessesary
uncompleteness
contruction
iam
sobering
dissymmetry
pdae4
nondangerous
kurina
gekoppelter
adsorbing
correspondig
alway
unsightly
linearen
multibody
stiy
ential
orthoprojectors
humboldt
pdaes
contractivity
sjh
toren
entiable
theorie
statet
partiellen
contrac
appers
nite
operators
spanned
_
assertions
dier
trivially
rewritten
somehow
brevity
admissible
mathematics
di
put
rank
norm
treating
mathematik
uj
systematical
0a
clm
pdes
harmless
systeme
dissipative
brunner
bijectivity
arbitrariness
formula
equation
d t
index 2
index 1
the dae
inherent regular
regular ode
dae 2
a dae
leading term
1 t
numerically well
well formulated
well matched
im d
differential algebraic
2 24
dened on
the decoupling
properly stated
the inherent
algebraic equations
dp 1
ode 2
ds 1
the index
remark 2
projector onto
the projector
onto n
decoupling commute
stated leading
along s
a t
has index
ker a
a projector
and d
s 1
cf 2
f1 2g
g 1
the subspaces
2 23
the bdf
stepsize restrictions
abstract dae
a nj
regular dierential
cf 13
dae has
2 daes
dq 1
commute in
explicit ode
bounded maps
euler backward
quadratic control
linear quadratic
all t
t and
t 2
t n
2 f1
continuously dierentiable
the euler
2 9
t s
initial condition
0 t
u t
the respective
2 i
dn 1
the leading
1 d
5 4
runge kutta
optimal control
coe cient
t are
matrix functions
ker g
ker d
daes with
daes a
kutta methods
norm sense
dae is
t ker
2 dae
dae 5
algebraic systems
normally solvable
have index
properly formulated
exive generalized
if im
hessenberg size
projector function
depend continuously
densely solvable
formulated leading
abstract daes
time invariant
and dn
1 case
t u
of index
t x
uniquely determined
2 1
on t
vary with
dierential equation
euler method
integration methods
generalized inverse
the ivp
adjoint equation
with properly
t cl
stepsize restriction
im g
2 c
value problem
coe cients
1 with
e t
the coe
x t
hilbert spaces
discretization and
subspaces and
a properly
circuit simulation
1 along
g in
numerical integration
solution of
remark 3
1 5
with index
benet of
method applied
this subspace
re exive
t along
in circuit
x n
is dened
are constant
g 2
for index
control problems
nite dimensional
denition 2
on l
equation of
t is
on i
holds that
an abstract
a bijection
size two
we nd
the discretization
and index
dierential algebraic
constant rank
im e
further due
ind t
projectors that
that denition
extra stepsize
onto ker
original dae
1 daes
assertion can
form dae
solvable and
are spanned
abstract index
dae and
dae with
be bijective
index case
constant subspaces
stated if
subspace s
leading terms
dae decoupling
projectors are
2 differential
restrictions may
for treating
have properly
projectors the
those equations
index dae
the inherent regular
inherent regular ode
dae 2 1
s 1 t
numerically well formulated
t 2 i
and d t
t s 1
d t s
the index 1
of the dae
t and d
im d t
d t n
n 1 t
2 1 with
ode 2 24
a dae 2
all t 2
1 t and
a t and
is dened on
2 f1 2g
a and d
differential algebraic equations
ker a t
onto n 1
index 1 case
properly stated leading
along s 1
t n 1
the leading term
in the index
has index 1
index 2 daes
regular dierential equation
1 and dn
projector onto n
are well matched
the euler backward
ds 1 and
index 2 f1
dp 1 d
and dn 1
linear quadratic control
2 c i
for all t
g 1 t
equation 2 1
the initial condition
theorem 3 1
x 2 c
regular ode 2
differential algebraic systems
re exive generalized
e t x
the projector onto
given an index
if d t
and index 2
and the decoupling
1 and index
the dae 2
of index 2
inherent regular dierential
the decoupling commute
in circuit simulation
g in circuit
exive generalized inverse
formula 2 23
index 2 dae
have index 2
d are well
n 1 along
properly formulated leading
if im d
1 along s
runge kutta methods
ker d t
given a dae
1 with index
hessenberg size two
the dae 5
with a properly
g 2 is
t u t
e g in
dened on l
index 1 and
numerical integration methods
dened on x
d t are
not vary with
5 4 is
t d t
the re exive
2 i let
remark 2 3
t x t
is a bijection
method applied to
5 1 5
d t is
by the problem
to the inherent
2 c 1
a solution of
for t 2
2 5 3
t along s
one optimal control
well formulated daes
a projector onto
d t ker
denotes a projector
dq 1 g
optimal control for
vary with t
index dae 2
versions 3 15
subspaces ds 1
index 1 on
and densely solvable
1 t along
mathematics v 45
regular explicit ode
the solution representation
the index 2
then the inherent
quadratic control problem
23 2 24
be time invariant
is a remarkable
nullspaces ker a
matrix functions a
a linear quadratic
the norm sense
preserving integration of
has index 2
projectors that realize
well matched in
dierential algebraic equations
the nullspace of
dae if for
abstract differential algebraic
and 3 16
boundary conditions should
cl im g
dae 5 2
quadratic control problems
properly stated if
continuously on t
matched in the
is a projector
the dae decoupling
be numerically well
dae has index
decoupling commute in
1 t do
stepsize restrictions may
without any stepsize
bvp 5 4
sense on t
euler backward method
approximation x n
normally solvable and
assertion can be
proof this assertion
stated leading terms
explicit ode 2
cl ker g
spanned by continuously
be well matched
treating so called
for treating so
1 d ii
g 2 t
discretization and the
the problem 5
subspace s ind
2 23 2
the problem data
solvable and well
1 2 f1
1 on i
abstract dae has
g 0 t
partial differential algebraic
constant coe cient
0 t f
2 the dae
9 3 10
any stepsize restriction
index 1 dae
for index 1
t cl im
leading term is
within this subspace
is properly stated
2 24 and

corpus/krapavin2000-test/635794.txt
discretisations
nonconforming
nite
multigrid
stokes
discretisation
smoothing
mesh
grid
spaces
nodal
functionals
solvers
gmres
cell
crouzeix
raviart
fk
convergence
h4
cells
piecewise
dened
prolongation
braess
sarazin
nest
bilinear
smoother
k2t
conforming
i2i
averaged
disc
navier
transfer
elliptic
simplicial
regularity
multi
smoothers
korn
h7
mixed
coarser
satises
lr
dierent
eciency
quadrilaterals
residue
nc
grids
pressure
quadrilateral
h3
solver
coarse
lowest
rened
nonsymmetric
triangulation
norm
element
barycentric
prolongations
neighbouring
saddle
triangulations
rates
exible
discontinuous
satised
freedom
renement
residual
dene
renements
mappings
operator
symmetric
analysed
triangles
correction
preconditioned
projector
h2
ane
numerical
rot
levels
nested
ka
equations
mod
brezzi
magdeburg
62e
babuska
cku
zulehner
divergence
degrees
rst
coecient
triangular
boundary
pd
nk
suciently
discrete
reduction
bb
mortar
midpoints
27e
riesz
uzawa
13e
ckd
ecient
variational
geometrical
kh
wj
subscrpt
cycle
child
contraction
mapping
preceding
solvability
hierarchy
behaviour
velocity
spectral
schur
euclidean
inequality
cf
2d
modied
ak
fullled
reference
coecients
isomorphisms
approximation
sup
denite
vanishing
jn
jk
analysing
onto
md
iteration
dierential
ch
mg
inf
validity
outer
benchmark
arising
coupled
inner
von
discretization
k1
multilevel
fe
regular
transforming
prescribed
duality
201
norms
46
matrix
usual
4120
113200007
gulations
possion
02e
conditioners
01e
08e
rannacher
msm
guericke
17e
06e
motive
discretely
ellipticity
decribed
25e
conditioner
nite element
v l
multi grid
u l
l 1
multi level
q l
order discretisations
level method
mesh level
t l
l k
order nonconforming
element spaces
transfer operator
element discretisations
error reduction
l l
the stokes
l u
discretisations on
nodal functionals
averaged error
for nonconforming
cell k
level solvers
p l
smoothing steps
stokes equations
nonconforming nite
lowest order
the multi
two level
higher order
new l
reduction rates
spaces v
l and
the smoothing
stokes problem
smoothing property
i2i l
u new
p mod
general transfer
discretisations in
k u
solvers for
2 t
finite element
the nite
l we
example 4
b k
element space
multigrid methods
crouzeix raviart
mixed problems
reduction rate
grid methods
local nodal
discretisations of
level solver
multigrid method
basis functions
the convergence
space v
the nest
l p
the space
the spaces
grid method
p nc
k 2
a nite
level independent
raviart element
standard multi
nonconforming discretisations
disc mesh
k2t l
reference cell
basic iteration
the discrete
l 2
any cell
convergence of
coarse level
pre smoothing
nite elements
lr b
w cycle
approximation property
low order
solution of
navier stokes
non nested
space l
the transfer
discrete problem
nonconforming finite
regularity property
discretisation of
nonconforming piecewise
braess sarazin
the crouzeix
the nonconforming
gmres method
fk 2
point problems
exible gmres
grid solvers
level correction
dierent discretisations
2 lr
1 l
level l
of 13
of multi
piecewise linear
of freedom
the coarse
of piecewise
a l
dened on
nite number
eciency of
and restriction
same mesh
independent constant
of smoothers
prolongation and
child cells
levels l
the eciency
piecewise constant
the solution
13 is
l which
have l
level 0
a multigrid
present numerical
constant functions
u j
preceding section
f l
for higher
l is
k h
methods for
space q
l the
b l
the p
bilinear form
l i
degrees of
any k
s l
u p
linear element
velocity spaces
system 13
grid level
coupled multigrid
2 discretisation
the residue
sarazin type
bb t
discretisations based
discretisation is
additional projection
projection step
operator u
nk i
q rot
valued basis
korn inequality
pd 1
the discretisations
mesh cells
and h4
cells k
discretisations with
nonconforming low
type smoother
saddle point
nite dimensional
space b
level approach
1 2
e k
for solving
the w
spaces of
problem 6
the bilinear
k we
the mapping
2 t l
nite element spaces
k 2 t
higher order discretisations
the multi level
multi level solvers
averaged error reduction
v l 1
the nite element
spaces v l
two level method
l k u
k u l
error reduction rates
l p l
q l 1
l u l
of the multi
the stokes problem
space v l
multi level method
lowest order nonconforming
cell k 2
l u new
discretisations on the
u new l
u l l
the two level
on the nest
nite element space
multigrid method for
the smoothing property
local nodal functionals
multi grid methods
nite element discretisations
error reduction rate
the multi grid
multi level solver
finite element discretisations
the transfer operator
general transfer operator
l l p
multi grid method
element spaces v
p l 1
l 1 l
l 1 and
d 1 2
new l k
element discretisations of
the stokes equations
v l we
the basic iteration
crouzeix raviart element
methods for nonconforming
order nonconforming discretisations
level solvers for
nonconforming nite element
of multi grid
lr b k
disc mesh level
the coarse level
navier stokes equations
any k 2
pre smoothing steps
t l 1
the convergence of
for higher order
and v l
the space v
u l 1
l k h
p l k
v l and
example 4 1
degrees of freedom
nonconforming finite element
space q l
solution of 13
b k k
l q l
p l p
the p mod
l is obtained
nonconforming piecewise linear
piecewise constant functions
method for nonconforming
level independent constant
s l k
the local nodal
multi grid solvers
2 lr b
any cell k
coarse level correction
the crouzeix raviart
of piecewise constant
saddle point problems
l 1 q
multigrid methods for
low order nonconforming
problem 6 7
theorem 2 1
a nite number
the solution of
for any cell
1 q l
the same mesh
u j 1
the eciency of
and q l
the error reduction
of the stokes
prolongation and restriction
present numerical results
the preceding section
l l k
l 1 v
1 v l
multi level approach
of multi level
l on the
that for any
we assume that
nite number of
for the multi
l we have
t l is
example 4 4
i2i l e
nonconforming nite elements
reference cell b
2 v l
independent constant c
from t l
sarazin type smoother
1 2 pd
pd 1 2
grid methods for
an additional projection
l 2 stability
the discrete problem
piecewise linear element
this multi grid
eciency of multi
levels l and
standard multi grid
discretisations based on
piecewise linear functions
for mixed problems
low order discretisations
discretisations of mixed
k2t l i
of mixed problems
order nonconforming low
vector valued basis
q l respectively
u l and
additional projection step
a l u
level method and
stokes problem in
stokes equations on
the averaged error
multi grid hierarchy
in the smoothing
for 2 2
1 l l
discretisations on all
fk 2 lr
grid solvers for
2 pd 1
nonconforming low order
for nite element
dierent nite element
valued basis functions
the general transfer
shows the averaged
of pre smoothing
braess sarazin type
for any k
l and l
we consider a
we have l
l l u
obtained by transforming
obtained from t
the approximation property
2 i l
for the stokes
l and q
the level l
level method for
of 13 is
u f l
conforming and nonconforming
nite dimensional space
1 and v
of t l
the spaces v
l 1 by

corpus/krapavin2000-test/635802.txt
el
msc
ale
abox
lcs
homomorphism
descriptions
concept
9r
aboxes
dls
existential
homomorphisms
ind
nr
msca
2a
nc
subsumers
completions
characterization
dl
subsumption
specic
nite
atomic
individuals
approximations
sublanguages
eectively
depth
restrictions
jaj
cyclic
trees
names
dened
8r
subsumer
conp
t4
successor
relationships
concepts
completion
9s
approximation
denition
exponential
constructors
inconsistent
sound
aln
rst
assertions
classic
grow
translated
occurring
cn
xed
tree
exponentially
negation
yields
unraveling
tk
icting
labeled
depicted
root
label
logics
innite
role
engineers
name
subsumed
ut
conjunction
engineer
double
reached
characterizations
semantics
greatest
turned
rg
graphs
notions
corollary
cycle
0nk
pletions
rosy
un0
unraveled
d2a
alen
6v
c2a
subsump
vrw
lufg
approximating
characterizing
encounters
generalizes
decided
intractability
structuring
roots
imations
rwth
approxi
inconsis
theoretische
suce
lifecycle
obviously
translating
individual
cope
additionally
a1
bases
pruning
quanti
straightfor
subsuming
vh
tent
8s
aachen
inductively
con
existence
logic
structural
cf
denitions
analogously
rome
trim
nave
mations
informatik
interpreted
conceptual
bottom
ship
sublanguage
prototypical
gc
cept
signa
incompleteness
jcj
ward
ict
sketch
blow
fpg
acyclic
onto
building
gg
construc
diculties
equivalence
fx
subsume
rene
suggestion
subtasks
questionable
innitely
race
foundations
quantiers
vn
chemical
restriction
negated
thoroughly
disjoint
descriptive
roughly
conjunctive
pg
revision
approx
dene
enumerating
speak
yield
allowing
usable
ture
containment
the msc
concept description
concept descriptions
an el
el description
description graph
g a
el concept
k approximation
for el
the el
abox a
in el
description tree
a homomorphism
a 2a
homomorphism from
el abox
instance relationships
2a c
msc of
g c
k approximations
the lcs
most specic
description trees
a g
existential restrictions
2 ind
ind a
into g
msc k
specic concepts
concept names
all concept
of instance
from g
k a
the characterization
el and
characterization of
w r
msc in
eectively be
msc can
atomic completion
atomic completions
c into
can eectively
for ale
el to
an ale
a concept
least common
description c
to el
ale description
l concept
depth c
msca a
common subsumers
r t
and el
the k
t a
a w
algorithm computing
c k
lcs of
descriptions c
least concept
from el
description logic
ale concept
instance problem
approximation of
always exists
a is
in ale
c 0
v 0
an individual
of g
of concept
not exist
with existential
of subsumption
t k
a be
2 nr
t4 a
a always
the ale
in description
c t4
individual b
to ale
concept name
ale in
ale abox
el aboxes
msc exists
value restrictions
an abox
and nr
role names
el el
el is
graph g
the instance
a a
cycle can
grow exponentially
process engineering
r r
depth k
relationships in
a i
reached in
up construction
c i
a no
labeled with
and complete
computing k
double exponential
exists a
let a
be computed
no cycle
of description
there does
be reached
sound and
number restrictions
jaj k
l abox
role name
common subsumer
description graphs
msc is
characterizing instance
engineering application
dls allowing
top concept
description w
corresponding description
concept msc
cyclic concept
for existential
dl systems
nc nr
existential restriction
9r p
msc does
el in
el can
of ale
exponentially in
u 9r
for dls
9r c
is dened
b i
concepts in
there exists
allowing for
a 2
may grow
a as
trees and
computing the
r s
exists and
translated into
descriptions of
it exists
theorem 1
c t
individual a
as instance
with role
s successor
p u
knowledge base
a otherwise
the least
yields the
description logics
with root
trees into
2 nc
completions of
of c
is nite
the concept
into an
description that
obviously there
root v
the k approximation
a g a
a 2a c
a homomorphism from
el description graph
of the msc
from g c
an el description
k approximation of
homomorphism from g
g a is
the el description
of instance relationships
an el abox
el concept description
the msc of
characterization of instance
a 2 ind
el abox a
t a g
2 ind a
a w r
exists a homomorphism
of a w
into g a
most specic concepts
el description tree
g c into
be an el
r t a
w r t
k a a
msc of a
k a g
description graph g
a concept description
msc k a
the characterization of
an el concept
can eectively be
c into g
the msc can
eectively be computed
t k a
el concept descriptions
el description trees
least common subsumers
the msc in
description graph and
concept description c
instance relationships in
msc can be
a be an
graph g a
of g a
k 2 in
all concept descriptions
the instance problem
abox a is
from a no
into an el
abox a 2
instance problem for
from el to
always exists and
characterization of subsumption
ind a and
least concept description
the least concept
be reached in
a and k
let a be
reached in a
approximation of a
g a and
does not exist
translated into an
description trees and
the concept description
computing the msc
el and el
the lcs of
a an individual
r 2 nr
concept descriptions c
into g c
no cycle can
specic concepts in
problem for el
relationships in el
a always exists
and can eectively
c t4 a
t4 a a
msc in el
msc of an
g a with
r r r
there exists a
cycle can be
can be reached
and k 2
existence of the
bottom up construction
of g c
of the characterization
a no cycle
root of g
exists and can
sound and complete
starting from a
a i 2
there does not
2 c i
i 2 c
in el in
least common subsumer
xed and nite
l concept description
atomic completion of
concept description is
and the el
description w r
of concept descriptions
for el is
grow exponentially in
14 let a
tree of c
computing k approximations
p 2 nc
an individual b
cyclic concept descriptions
the most specic
l concept descriptions
with existential restrictions
each model i
process engineering application
msc does not
concept descriptions can
9r p u
the msc does
concept descriptions and
2a c i
the msc exists
for all concept
concept descriptions of
description graph is
in description logics
ale description graph
g c k
concepts in el
is the msc
an ale description
2a c 0
an atomic completion
may grow exponentially
depth c 0
for existential restrictions
k approximations in
concept description that
description tree of
of concept names
exist an el
p u 9r
the el concept
description graph of
computed in double
ale concept descriptions
atomic completions of
the atomic completions
0 a 2a
the corresponding description
a with w
el to el
concept description w
abox a an
computing the k
g c 0
a is translated
an ale abox
in double exponential
description tree from
nc and nr
completions of g
dls allowing for
and complete characterization
el to ale
be computed in
a sound and
c i for
to see that
is the least
easy to see
i for all
of a homomorphism
g a of
double exponential time
decided in polynomial
an algorithm computing
the bottom up

corpus/krapavin2000-test/635905.txt
bdy
frontwidth
fem
boundary
stiness
cholesky
jv
numbering
meshes
dissection
partitioning
mesh
concentrated
shape
subdomains
dist
factorization
jvj
steklov
balanced
geometric
bem
nnz
poincare
frontwidths
chol
vn
dirichlet
regularity
hp
cone
denition
neumann
ops
fk
nested
sparsity
triangle
psfrag
rened
recursion
tn
dene
yn
k2t
remark
fig
proposition
neighbor
matrix
bsp
subdomain
denite
replacements
sparse
vectors
triangulation
elliptic
conrm
freedom
edge
log
assembling
schur
polylogarithmically
dims
dimvn
degrees
triangulations
degree
hk
interior
supp
clover
k2k
cients
coe
satised
figs
vertex
2d
storage
unknowns
fe
spaces
analytic
lemma
verbatim
exposition
jx
nn
operator
submatrices
delaunay
preconditioner
slope
cient
rst
estimates
nite
tangential
oating
un
center
dened
estimate
solver
toward
square
smooth
vertices
eectiveness
sup
cn
thick
vanish
polynomial
nodes
variational
numerical
symmetric
neighbors
multiplications
uniformly
expect
118
guidelines
arising
cf
mixed
internal
multiplicity
node
529340
cjvj
shewchuck
4079
analyticity
nlog4n
bdya
264600
holdsjv
v2en
2022
columnwise
trefethen
fhx
cea
profs
barycenter
withanitedimensionalsubspace
dumbbell
njg
262144
cuthill
diamk
nlog8n
picture
logarithmic
trace
complement
200
ll
violated
vector
triangles
ciently
enumerate
visible
element
refinement
motivates
131072
hanging
poole
ruppert
kuk
inmum
mckee
hackbusch
approximation
median
collected
constants
mention
quasi
realization
rigorous
numerically
justies
legendre
coercivity
577
lef
equilateral
sobolev
1043
associate
suited
splits
shape functions
boundary concentrated
concentrated fem
algorithm 3
the boundary
stiness matrix
nested dissection
the stiness
linear degree
geometric meshes
the frontwidth
geometric mesh
the partitioning
the cholesky
cholesky factorization
1 balanced
partitioning vector
partitioning vectors
degree vector
vectors t
cone condition
jv bdy
3 10
3 9
polynomial degree
v bdy
v left
internal shape
vector t
example 4
element k
shape function
v right
poincare steklov
denition 2
size h
hp fem
sparsity pattern
boundary mesh
the recursion
partitioning strategy
dist x
a geometric
q balanced
fem in
frontwidth a
degree vectors
t chol
remark 3
mesh size
a neighbor
mesh with
boundary conditions
2 7
node numbering
binary space
examples 4
meshes and
the cone
lemma 3
proposition 3
t i
the numbering
jv j
steklov operator
right j
bdy j
bdy the
a jv
the poincare
rened toward
edge shape
dist dist
side shape
a bdy
ops t
for triangle
neighbor in
element method
factorization of
space partitioning
with boundary
nodes v
log 2
functions associated
in example
psfrag replacements
subdomains i
factorization scheme
dissection algorithm
in view
condition 3
mesh t
the hp
symmetric positive
of partitioning
of freedom
cholesky factor
balanced for
nite element
of nodes
space s
numbering of
the shape
3 12
dirichlet problem
logarithmic complexity
reference element
left v
the frontwidths
analytic on
bdy starting
nnz and
dissection v
fem we
the bem
vertex shape
n frontwidth
chol sec
k bdy
frontwidth to
direct solver
solution u
function associated
the subdomains
in fig
3 8
of denition
storage requirement
positive denite
3 4
example 3
standard basis
then dene
boundary shape
mixed boundary
r nn
j jv
numbering scheme
slope 0
the schur
linear logarithmic
edge e
see fig
degrees of
t be
of v
of boundary
the constants
degree p
jv i
figs 5
triangle s
balanced in
schur complement
in h
node v
2 0
points on
a boundary
number n
let t
problem size
of geometric
2 n
the dirichlet
boundary point
meshes that
sets v
pattern of
2 4
3 11
the storage
partitioning in
the nodes
n 0
chosen such
toward a
view of
the element
with slope
and work
log 4
half spaces
in examples
the triangulation
point b
theorem 2
n log
scheme for
by algorithm
the meshes
our procedure
functions i
log n
the solution
functions is
left and
of lemma
coe cients
boundary concentrated fem
the boundary concentrated
the stiness matrix
algorithm 3 10
of the stiness
algorithm 3 9
a geometric mesh
the cholesky factorization
linear degree vector
vectors t i
partitioning vectors t
algorithm 3 2
the cone condition
lemma 3 4
of the recursion
be a geometric
boundary mesh size
geometric meshes and
neighbor in h
mesh size h
denition 2 7
a neighbor in
condition 3 9
linear degree vectors
geometric mesh with
shape functions associated
cone condition 3
mesh with boundary
with boundary mesh
binary space partitioning
internal shape functions
partitioning vector t
concentrated fem in
a linear degree
theorem 2 4
has a neighbor
in the boundary
sparsity pattern of
on the boundary
factorization of the
cholesky factorization of
scheme for the
and linear degree
vector t i
frontwidth a of
the partitioning vectors
subdomains i and
meshes and linear
shape function associated
nested dissection algorithm
ops t chol
the poincare steklov
the internal shape
be 1 balanced
the frontwidth a
stiness matrix a
side shape functions
shape functions is
of geometric meshes
the partitioning vector
poincare steklov operator
jv bdy j
number n 0
that a jv
functions associated with
in view of
be a linear
for the cholesky
the shape functions
log 2 n
degrees of freedom
let t be
example 4 3
of lemma 3
t be a
for the boundary
by algorithm 3
on the reference
of the partitioning
sense of denition
examples 4 1
in algorithm 3
in example 3
function associated with
the solution u
symmetric positive denite
linear logarithmic complexity
the reference element
concentrated fem we
the geometric mesh
results are collected
of denition 2
the frontwidth to
triangle s output
of v bdy
the side shape
the space s
with slope 0
reference element k
a polynomial degree
the partitioning in
v left v
describing the geometric
the dirichlet problem
expect the frontwidth
jv j h
collected in table
factorization scheme for
and partitioning vectors
associated with edge
are collected in
left v right
t chol sec
nested dissection v
standard basis in
with edge e
rened toward a
edge shape functions
h g has
cholesky factorization scheme
a standard basis
v bdy starting
picture of fig
log n frontwidth
a jv bdy
for triangle s
frontwidth to be
j h 1
with linear logarithmic
figs 5 6
the partitioning strategy
example 4 5
of fig 3
2 0 1
a basis of
numbering of the
in examples 4
2 n figure
mixed boundary conditions
example 3 11
2 r nn
in h g
the schur complement
a node v
in example 4
proposition 3 1
set of nodes
the problem size
the nite element
problem 2 1
points in space
assign to the
o log 2
example 3 3
we expect the
1 4 2
the constants c
we assign to
the cholesky factor
arising in the
near the boundary
on a domain
4 1 4
example 4 1
chosen such that
and the constants
the storage requirement
in lemma 3
denote by v
proposition 3 6
o n log
to the case
a 2 r
of the nite
g has a
system of linear
of a node
at each stage
as in example
finite element method
of linear equations
denition 2 1
bdy the partitioning
psfrag replacements x
shape functions v
to their multiplicity
choice of partitioning
the linear degree
the number return
if v left
requirements nnz and
clover leaf log
replace the square
however that an
jv bdy the
the hp fem
if supp consists
on geometric meshes
10 are chosen
cholesky factor l

corpus/krapavin2000-test/636260.txt
snf
coecients
nonlinear
unfolding
kth
cnf
cnfs
normal
perturbation
maple
singularity
dy
rescaling
dt
1j
simplied
equations
transformation
coecient
takens
nd
algebraic
dierential
simplest
dx
ecient
2j
frechet
0j
bracket
nding
nt
singularities
recursive
forms
near
nth
k0
identity
rst
homogeneous
snfs
hypernormal
retained
generic
polynomials
bogdanov
undetermined
dierentiation
equation
transformations
j0
dierentiating
hopf
unnecessary
equilibrium
eliminated
complementary
jth
saves
bifurcation
lie
greatly
ij
2i
1i
aid
yuan
symbolic
preprint
derivative
eort
formula
jacobian
repeatly
efcient
rescal
dxf
paid
algebra
eld
taylor
remove
simplify
bifurcations
pursuit
lx
reduction
poincare
lined
resonance
transfor
duced
codimension
dropped
belonging
row
differential
degeneracies
dh
equilibria
grading
diagonally
615
analytic
nal
pei
591
eliminate
operator
aects
downwards
complicated
lows
vector
stability
equa
nserc
jordan
hamiltonian
plus
tations
ago
compu
eral
arranging
substituting
instability
matrix
listed
vicinity
putation
fol
dene
elsevier
credit
mation
10th
imaginary
particularly
author
expansions
expansion
conventional
box
qualitatively
ascending
eigenvalue
eigenvalues
traced
council
reversed
illustrative
tm
dynamical
spanned
summarizing
nn
explicit
tables
normalizing
attention
hundred
vii
substitute
ing
yields
follow
tem
researchers
gen
2k
leading
subscripts
implying
formulations
split
unlike
continued
transform
consistent
expand
extremely
identically
coded
planar
triple
pc
continuing
multiplied
involve
secondly
employing
expanded
submitted
continue
involved
employs
solving
yu
the snf
snf of
nonlinear transformation
normal form
kth order
the coecients
the kth
coecients of
form theory
near identity
perturbation parameters
normal forms
order equations
zero singularity
the nonlinear
order terms
snf is
simplest normal
reduced system
algebraic equations
single zero
dy d
order equation
system 20
with perturbation
further reduction
generic case
dx dt
coecients h
order nonlinear
nonlinear transformations
order normal
of normal
the unfolding
the normal
with unfolding
nd the
6 0
a 11
k y
unnecessary coecients
dy dt
identity nonlinear
non generic
of cnfs
cnf theory
order algebraic
snf for
vector homogeneous
identity transformation
a 20
original system
computer memory
higher order
of system
the rescaling
the cnf
system 1
recursive formula
any order
maple program
nonlinear terms
complementary space
coecients t
snf with
snf without
20 6
g k
the reduced
11 6
coecients are
homogeneous polynomials
the maple
a cnf
without unfolding
these unnecessary
each order
t 1j
nth order
lower order
the simplest
to nd
computation of
equation 29
for computing
forms for
coecients in
the recursive
the computation
computing the
r k
computer algebra
frechet derivative
rescaling on
linear part
kth degree
greatly saves
lie bracket
unique normal
by dy
perturbation parameter
nonlinear vector
h 2j
cnfs and
three coecients
dt dy
d up
some coecients
nt coecients
form terms
computational time
complicated than
state variable
the nth
coecients for
two coecients
degree vector
the lie
simplied way
a k0
is dy
h k
equation of
the complementary
of 18
all higher
further simplied
row are
dt where
algebra system
a near
equations which
terms in
form for
be retained
this greatly
involved than
no results
retained in
reduction of
h l
of vector
g see
the coecient
rst equation
observed from
be eliminated
g 2
equation 20
20 for
the near
dierential equations
equation 17
space r
k k
theory to
in equation
basis of
y and
reported on
the perturbation
equations and
of h
form of
takens normal
2i i
using maple
saves computational
cnfs the
leading non
snf no
vector unique
the snfs
second algebraic
forms has
mentioned further
empty box
j0 s
1i i
h 11
computation eort
lie transform
jth order
consistent nonlinear
apply normal
all order
explicit expressions
transformation at
parameters unfolding
particular advantage
part belonging
coecients zero
conventional normal
contain perturbation
undetermined coecients
transformation through
1j are
simplied however
nal snf
snf however
the snf of
the kth order
of the snf
normal form theory
the nonlinear transformation
the normal form
the snf is
snf of the
coecients of the
computing the snf
single zero singularity
snf of system
the simplest normal
with perturbation parameters
the reduced system
the coecients of
up to any
to any order
the coecients h
11 6 0
a 11 6
kth order equation
simplest normal forms
coecients of h
the snf for
of system 20
near identity transformation
and the nonlinear
20 6 0
order normal form
the single zero
near identity nonlinear
order algebraic equations
a 20 6
the original system
further reduction of
of normal form
of system 1
for computing the
compute the snf
the near identity
the nth order
these unnecessary coecients
kth order terms
snf with unfolding
equation of 18
at each order
the complementary space
vector homogeneous polynomials
and computer memory
order nonlinear terms
system 20 for
simplest normal form
the maple program
time and computer
form theory to
non generic case
g k y
a near identity
that of cnfs
the snf with
then the snf
of the reduced
computation of the
of the nonlinear
form of the
normal forms of
of normal forms
normal form of
to nd the
normal forms for
normal form and
the computation of
higher order terms
6 0 and
perturbation parameters in
kth order equations
normal form terms
kth order normal
snf for the
no results have
some coecients of
form theory is
nonlinear transformation and
given by dy
the snf without
snf of a
a computer algebra
to the snf
snf of systems
of cnfs and
h k y
order equations and
from equation 29
coecients h 2j
nt coecients for
computation of normal
rescaling on time
the kth degree
f k x
the coecients t
the rescaling on
assume a 11
by dy d
snf without unfolding
coecients t 1j
higher order normal
systems with perturbation
algebraic equations which
degree vector homogeneous
computational time and
dy d up
nd the form
kth order algebraic
computer memory the
higher order equations
nonlinear transformation is
coecients for a
kth order nonlinear
idea of normal
d up to
the linear part
form and the
order terms in
that the snf
coecients in the
space r k
retained in the
of the complementary
the two coecients
all higher order
reported on the
and then add
been reported on
must be retained
computer algebra system
the lower order
of the normal
the basis of
of the system
in the normal
e g see
for the single
g 2 and
h 2 and
of the kth
the state variable
more involved than
normal form for
normal form is
the new approach
r k and
the rst equation
of the simplest
of g k
be eliminated by
more complicated than
the case a
of systems with
a normal form
that computing the
the aid of
is even more
with the aid
is to nd
this approach uses
dy dt dy
unfolding although some
system 1 does
such as maple
reduced system 23
coecient of the
equations at each
in equation 17
forms has been
vector eld f
zero singularity is
contain the kth
this greatly saves
the nal snf
unfolding to the
dt dy dt
fact the coecients
is dy dt
recursive formula 11
an independent nonlinear
dierentiating equation 8
equations containing the
thus the snf
2i i x
resulting normal form
the part belonging
uses a consistent
the undetermined coecients
many higher order
identity nonlinear transformations
dx dt a
used at this
considered using the
leading non zero

corpus/krapavin2000-test/636361.txt
filter
h6
filtering
oe
dt
ffi
sigma
wiener
noise
deduce
signal
diffusions
gamma1
filters
differentiation
phi
asymptotic
nonlinear
injective
valued
fh
matrix
riccati
dx
ds
stability
kalman
h1
gamma3
derivatives
estimation
h7
filtration
girsanov
h5
kz
differentiable
fx
restored
dy
expansions
jacobian
processes
channel
pi
differential
diffusion
stationary
noisy
estimations
integration
converges
loose
devoted
suboptimal
approximate
vanishes
filtrage
fragile
gamma2i
bruit
avec
hasffi
unnoisy
morceaux
eaire
ffp
semimartingales
vaste
coefficients
estimate
ff
dimensional
taylor
gammap
neglects
h4
detectability
formula
observation
ae
kv
law
log
nonlinearity
gammac
puted
matrices
equation
petit
h3
expectation
derivative
uniformly
summing
conditional
stable
lebesgue
injectivity
proposition
ith
boundedness
ku
multiplication
inequality
schwarz
stochastic
notations
cauchy
probability
differentiated
rp
assump
dp
differentiate
differentiating
iis
magnitude
transposition
2p
moments
invertible
convergence
articles
scale
quadratic
tracks
bounded
psi
par
fm
spaces
adopted
force
contraction
gamma
verifies
linearity
jth
dynamical
gain
body
fy
entering
fi
multiply
satisfies
efficiency
approximation
smoothing
piecewise
going
aim
enable
inverse
dealt
notices
rigorous
proceeding
rate
nonnegative
th
variation
viewed
observed
claimed
monotone
modelled
restrictive
sequel
multidimensional
submitted
asymptotically
multiplying
evident
lin
theoretically
article
behaviour
error
observations
transforming
parts
assumptions
equations
obtains
exponentially
looks
switching
converge
variance
surprising
involving
tends
replace
contents
calculus
universal
driven
negligible
log l
h6 ffi
sigma m
observation noise
x 1
t g
m t
z th
optimal filter
of order
we deduce
d dt
approximate filter
filtering error
nonlinear filtering
wiener processes
z t
a t
the filter
l t
oe f
the signal
x t
filter 3
fx t
r 0
initial condition
integration by
in l
parts formula
noise channel
order gamma1
o gamma1
standard independent
t sigma
by parts
y t
low noise
s ds
differentiation with
dt d
filter is
the matrix
probability measure
it o
one has
f t
the filtering
t is
linear case
phi t
fh x
independent wiener
from fh
h1 to
small observation
dimensional diffusions
valued process
order gamma3
the observation
deduce that
are standard
an integration
we obtain
1 s
time scale
s s
matrix valued
extended kalman
restored from
uniformly bounded
filtering problem
the differentiation
f 12
t and
condition x
this filter
change of
this equation
the processes
l 2
finite dimensional
ffi 1
p gamma1
x 0
estimation of
with bounded
gamma1 2
one dimensional
t oe
kalman filter
theorem 2
the optimal
t r
j 2
and h
almost linear
is studied
stability of
the girsanov
dimensional process
th 0
bounded partial
processes x
ffi holds
assumption h6
girsanov theorem
ds oe
assume h1
30 if
quadratic variation
signal see
filter m
filter does
kz t
dt by
processes under
dx 1
in h6
force described
filtration generated
bounded derivatives
as converges
diffusions measured
summing on
2 dt
approximate filters
diffusion with
observation function
optimal filtering
high signal
efficient suboptimal
channel nonlinear
inequality one
estimate j
noise vanishes
gamma sigma
valued processes
riccati equation
gamma3 4
by oe
oe oe
h x
the process
ffi is
of 30
the estimation
s z
t by
a change
o s
oe h
u yields
the filtration
has by
computation shows
if ffi
loose the
is differentiable
taylor expansions
obtain d
th 2
in theorem
of probability
a 11
oe and
0 x
the jacobian
v t
signal x
differentiable with
dx 2
two filters
conditional expectation
th x
asymptotic analysis
gamma1 4
be restored
l p
is uniformly
by u
filter in
this signal
0 log
process f
u gamma
s formula
expansions for
obtain that
function h
is small
solution of
d d
j 5
a 22
if phi
write that
t gamma1
is solution
the coefficients
log l t
x 1 s
sigma m t
the optimal filter
in l 2
fx t g
the filtering error
integration by parts
theorem 2 1
are standard independent
a low noise
the filter 3
t sigma m
when the observation
by parts formula
t r 0
an integration by
low noise channel
the observation noise
of order gamma1
differentiation with respect
is of order
we deduce that
l t t
t g and
the initial condition
t t r
of the optimal
in a low
term of 30
1 in l
almost linear case
independent wiener processes
the extended kalman
of order gamma3
the approximate filter
fh x t
ffi is close
x t g
matrix valued process
standard independent wiener
small observation noise
from fh x
the differentiation with
filtering error is
s z th
d d j
it o s
change of probability
a t is
a change of
condition x 0
extended kalman filter
initial condition x
the time scale
of probability measure
and we obtain
and y t
d j 2
t g is
a t a
t is o
f and h
matrix a t
0 x 1
a 11 a
to the initial
theorem 3 1
2 1 we
2 so the
loose the signal
u yields a
oe f and
one has by
obtain d dt
viewed as functions
summing on i
signal see 8
by summing on
the filter m
l t z
the processes x
be the filtration
1 s ds
filtering problem for
of this signal
we obtain d
sigma m s
uniformly bounded as
z th 0
replace the processes
two dimensional process
wiener processes under
condition and an
on f t
e p on
process f t
c 3 with
order gamma1 2
h6 ffi holds
optimal filter in
assume h1 to
z t sigma
o s formula
enough to 1
diffusions measured in
obtained from fh
differentiable with respect
filtration generated by
dt d d
with bounded derivatives
taylor expansions for
j 2 dt
f t by
that phi t
and f 12
0 log l
a t which
as converges to
1 s z
th x 1
restored from the
by u yields
d dt d
in l p
and log l
force described by
m t given
1 assume h1
the optimal filtering
3 with bounded
signal x t
channel nonlinear filtering
order gamma3 4
the taylor expansions
o gamma1 4
gamma sigma m
converges to 0
the signal see
z th x
is o gamma1
s s ds
z th 2
with small observation
filter is studied
th 2 x
observation noise vanishes
be restored from
bounded partial derivatives
dimensional diffusions measured
of approximate filters
the filtration generated
in h6 ffi
small and one
assumption h6 ffi
approximate filter is
t are standard
th 0 x
optimal filtering problem
a 22 and
nonlinear filtering and
measured in a
t by d
filter m t
one dimensional diffusions
t is solution
high signal to
for z t
r 0 log
error is small
f t g
of 30 if
is differentiable with
that d dt
yields a process
gamma3 4 thus
with bounded partial
noise channel nonlinear
the girsanov theorem
s ds oe
and we deduce
t z th
s s s
that the process
the matrix a
in theorem 2
respect to the
one can write
h x 1
is uniformly bounded
with a 11
replaced by oe
computation shows that
the matrix valued
theta 2 matrix
stability of this
is c 3
in the spaces
1 s x
by y t

corpus/krapavin2000-test/636409.txt
elementary
grzegorczyk
analog
reals
gn
dierential
computable
gpac
dened
cmc00
hierarchy
exp
dene
elementarily
proposition
integration
recursive
dynamical
en
denition
composition
primitive
xed
flix
bss89
moo96
shannon
computability
continuous
subclasses
discretization
costa
growth
functionals
equations
jy
recursion
cut80
bournez
nli
mycka
grz53
ros84
subtraction
iterated
nth
projections
sums
extensions
functional
jerzy
closed
dierentiable
bss
rational
products
arithmetical
turing
rst
successor
jos
ka
belongs
subrecursive
grz55
lacombe
tortoise
kal43
campagnolo
bou99
ko91
odi00
heaviside
har82
pou74
gak99
lac55
hainry
nite
integers
oracles
bounded
valued
achilles
kalmar
wei00
shafts
integra
euler
numerical
xn
371
tj
kh
differential
cut
homogeneous
inequalities
pour
analyser
idealization
gh
norm
arity
neural
recognizers
classical
satises
sin
emmanuel
factorial
constants
denable
climbing
technological
integer
oracle
bk
partly
innite
exponentiation
2t
iteration
subclass
olivier
closure
exponential
operator
compositions
moore
jxj
manuel
digital
extension
su
product
nd
levels
inversely
multiplication
147
molly
mee93
sie99
rill
sf98
straties
integrators
mathemat
dierentially
orp97a
funtion
rubel
arn96
18304
metamathematical
kerry
moo90
transnite
lord
discreteness
3nomena
lr87
1876
jsin
trautteur
fcul
1936
moo98
bow96
unphysical
danner
sha41
bra95
labmac
kathleen
skepticism
sylvestre
tary
gakwaya
acumulated
fct
modelos
2sin
vannevar
completness
praxis
clo99
gear
ojakian
shub
zho97
jcos
spootie
arquitecturas
lipshitz
netwoks
guglielmo
vsd86
flad
the reals
grzegorczyk hierarchy
elementary functions
the grzegorczyk
dierential equations
linear dierential
reals of
recursive functions
linear integration
the elementary
analog computation
e n
bounded product
y 1
l k
is elementary
primitive recursive
closed under
of analog
of functions
en 1
in l
in gn
bounded sums
elementarily computable
elementary functional
proposition 4
continuous time
xed k
analog class
analog computer
bounded sum
dynamical systems
non linear
functions in
an elementary
elementary function
exp n
real functions
extensions to
in e
reals is
contains extensions
nth level
the gpac
that gn
purpose analog
o subtraction
in cmc00
iterated exponential
sums and
composition and
h x
is closed
an analog
shannon s
all functions
f x
dene a
jy 1
a exp
if f
denition of
y 2
e c
subclasses of
function f
initial condition
basic functions
recursion theory
exp m
dened from
functions are
the discretization
flix costa
analog computers
gn contains
discretization error
jos flix
under bounded
of shannon
s general
cut o
functions on
to dene
f is
functions and
computable functions
an extension
equation 15
any xed
a function
functions of
is dened
to l
of computable
3 non
and bounded
initial functions
and en
be dened
dened as
the nth
dierential equation
belongs to
some extension
proposition 5
the denition
equations of
valued functions
and products
under composition
reals and
functions computable
constants 0
function in
computable in
and continuous
real function
the dierential
we will
elementary if
in elementary
continuous real
gn k
basic function
of oracles
classical recursion
zero successor
jerzy mycka
dierentiable way
under iteration
using composition
that jy
class l
continuous dynamical
bounded products
mycka jos
integer closest
dene h
is elementarily
forming bounded
reals we
computation theory
are elementarily
n computable
ka t
and g
the integers
in proposition
f and
the bounded
any function
we dene
extension to
y h
t k
recursive function
the analog
time computation
unique solutions
function theory
elementary time
euler s
to gn
on n
functions is
extension of
of real
k is
theoretical computer
of computation
functions that
step function
to solve
of continuous
the constants
hierarchy e
certain kind
all elementary
linear differential
of en
xn 1
g have
the class
is e
for functions
x z
a functional
level of
n 3
sum and
that l
proposition 2
of exp
this hierarchy
xed m
exp d
given f
primitive recursion
to the reals
the grzegorczyk hierarchy
linear dierential equations
of the grzegorczyk
the reals of
the elementary functions
primitive recursive functions
in e n
bounded sums and
is closed under
extensions to the
non linear dierential
on the reals
all functions in
is an elementary
is e c
n 3 non
nth level of
contains extensions to
elementary functions are
the reals is
general purpose analog
purpose analog computer
cut o subtraction
the nth level
3 non linear
l k is
xed k 2
f and g
proposition 4 3
for any xed
and y 2
belongs to l
extension to the
of shannon s
the constants 0
jos flix costa
of analog computation
y h x
dierential equations of
any function in
equations of a
reals of all
continuous time computation
s general purpose
the discretization error
constants 0 1
on the integers
the bounded product
an elementary functional
grzegorczyk hierarchy in
recursive functions on
an extension to
a function f
set of functions
can be dened
extension of it
proposition 4 4
to the elementary
sums and products
some extension of
level of the
the primitive recursive
closed under composition
functions on the
levels of the
of it to
of recursive functions
of real functions
any xed k
will now show
is an extension
the iterated exponential
belongs to gn
is elementary if
and linear integration
reals of en
that all functions
all n 3
and g have
closed under bounded
elementary functions and
jerzy mycka jos
therefore we claim
of primitive recursive
allowed to solve
of en 1
the reals we
the integer closest
inequalities in a
ka t k
continuous real function
closed under iteration
jy 1 n
all elementary functions
e c then
grzegorczyk hierarchy e
in elementary time
continuous dynamical systems
forming bounded sums
gn contains extensions
mycka jos flix
computable in e
bounded sum and
composition and linear
e n computable
shannon s general
is elementarily computable
growth of functions
classical recursion theory
euler s method
an elementary function
version of shannon
the reals and
integer closest to
set of oracles
bounded product for
exp n 1
hierarchy e n
e n for
that gn contains
on the growth
functions in gn
sums and bounded
of exp n
f is elementary
show that gn
that jy 1
are elementarily computable
a t is
up to n
be generated from
in l k
theoretical computer science
proposition 2 1
k for some
which is closed
dierential equations we
in l since
a exp d
functions of several
f 2 e
recursive functions and
a certain kind
highly non linear
recursive function theory
k is closed
x t k
proposition 3 1
model of computation
the growth of
to n 3
of complexity v
linear differential equations
if f and
journal of complexity
functions in l
recursive functions are
computer science v
we show that
of functions on
dene a function
in proposition 4
just have to
function f 2
over the reals
is in l
2 l k
f to the
of a certain
show that if
of continuous time
for n 3
an initial condition
1 n n
for some xed
we just have
functions that can
proposition 5 3
that for all
we will now
1 1 and
y f x
hierarchy in the
of non linear
is computable in
and space complexity
of f to
a hierarchy of
x z y
the levels of
then there is
for t 2
class of functions
be dened as
can be generated
now show that
integration can only
computation dynamical recognizers
closure properties as

corpus/krapavin2000-test/636581.txt
sperner
facet
simplices
polytope
simplex
pebble
facets
simplicial
cells
nerve
polytopes
gf
chamber
triangulation
vertices
gk
cell
polytopal
degenerate
labels
label
loera
labelling
face
ag
peterson
ridges
pebbles
adjacent
constructive
interior
atanassov
labelled
convex
parity
ridge
endpoints
spanned
cover
lemma
chambers
vertex
hull
conjecture
f1
triangulations
homology
qf
carried
paths
jg
brouwer
combinatorial
covering
boundary
odd
carries
dimension
pentagon
iv
jl
dene
subgraph
degree
connected
math
borders
stacked
su
triangulated
shaded
oxford
5g
magdalen
basepoint
bdry
beweis
simplexity
dissections
specic
suces
isomorphisms
map
ker
inductive
corollary
loops
arguments
labellings
ags
induct
polyhedra
nitely
hexagon
7g
denition
dark
ng
meets
vj
2g
sign
6g
cardinality
freund
hyperbolic
degeneracy
carr
proposition
analogs
counts
consist
locating
omits
nd
faces
identity
polyhedron
surjective
innitely
dened
shares
pivoting
davis
collection
vn
manifolds
counted
regular
intersect
contained
fully
path
repeated
light
college
dimensional
de
rst
connect
satises
fv
labeled
intersection
iii
determinant
studia
threlfall
deloera
billera
alekseyevskaya
hungar
j2jp
hungarica
seifert
4au
52b11
topes
ox1
plices
1462
91711
fame
prescott
55m20
echelon
expositions
su134453521
1928
elisha
95616
mudd
hmc
excision
fixpunktsatzes
claremont
ucdavis
meunier
darkly
2admits
neuer
anely
endpoint
subgraphs
nite
lemmas
proofs
italic
statement
dierent
commutative
gure
nodes
claim
triangles
component
images
volumes
subsequence
mathematics
full cells
full cell
sperner s
polytope p
pebble set
n d
d polytope
label set
of p
a pebble
s lemma
d simplex
nerve graph
facet f
g f
non degenerate
the nerve
full facets
degenerate full
g 0
facet of
a facet
of g
simplices of
sperner labelling
full facet
the facet
vertices of
in g
degree 1
cells in
a polytopal
polytopal sperner
simplices in
carried by
in f
face f
graph g
in gf
component g
loera e
de loera
simplex of
sperner labelled
d full
a sperner
simplex in
e peterson
ag f
peterson and
label sets
a full
f r
the polytope
a cover
e su
cell graph
facets of
f k
constructive proof
cover of
labels in
k simplex
path following
polytope with
labelled triangulation
repeated label
graph gk
adjacent to
has degree
d 1
a triangulation
simplex is
non constructive
type i
of full
map f
f 1
base facet
fully d
the simplices
one repeated
components g
ag graph
d labels
a de
triangulation t
d vertices
of simplices
by vertices
of type
the label
connected component
boundary of
triangulation of
spanned by
the vertices
derived graph
q i
l f
parity of
f e
g of
the interior
q 0
a simplex
the ag
interior of
cell in
if is
k face
a simplicial
in gk
the sperner
d simplices
two full
1 simplex
all labels
a d
the boundary
f1 2
least n
the parity
hull of
degree 2
a ag
labels of
convex hull
is adjacent
and f
of t
facets in
one pebble
f of
p i
the labels
p that
an n
the convex
or paths
identity map
whose label
is carried
q f
f is
contains at
the full
must contain
theorem 1
a face
g that
exactly two
simplex spanned
any facet
homology groups
d labeled
simplex s
a chamber
simplicial facet
every facet
pebble sets
facet on
any sperner
labels carried
two facets
chamber of
graph gf
gk is
types i
whose endpoints
the k
a polytope
loops or
the facets
in t
a constructive
j a
c p
with exactly
of f
t k
any d
1 dimensional
with label
of theorem
one full
simplex with
be odd
the pebble
carries all
theorem 22
simplices and
the map
dimension d
by lemma
the derived
face of
f d
connected components
inductive hypothesis
sperner s lemma
n d polytope
full cells in
a full cell
a pebble set
nerve graph g
g f r
the nerve graph
the facet f
non degenerate full
is a full
vertices of p
an n d
f of p
boundary of p
polytopal sperner s
peterson and f
j a de
full cell in
a de loera
e peterson and
de loera e
n d full
of full cells
a polytopal sperner
loera e peterson
the label set
full cell graph
f e su
a full facet
d full cells
least n d
and f e
g of g
of the polytope
a cover of
the polytope p
of type i
the full cells
sperner labelled triangulation
facet of p
d polytope p
a facet of
cover of p
component g of
by vertices of
spanned by vertices
of the nerve
of p that
in g 0
a d simplex
the boundary of
derived graph gk
non constructive proof
degenerate full cell
has degree 1
the map f
a sperner labelled
parity of g
one repeated label
f k 1
if is a
carried by the
nodes in g
type i or
the k simplex
component of g
the derived graph
the full cell
the parity of
the interior of
number of full
the vertices of
labels in l
convex hull of
on the boundary
are carried by
components g of
exactly one repeated
cell graph g
in the facet
face f k
label set of
connected components g
in f k
the k face
the ag graph
simplices of p
is a facet
k simplex is
loops or paths
degenerate full cells
cells in t
at least n
the convex hull
in f 1
of theorem 1
a non degenerate
is adjacent to
connected component of
is carried by
are non degenerate
of g f
of p and
of p then
vertices of s
the identity map
by the k
a connected component
the labels in
simplices of t
full facet on
size d 1
d simplex with
of loops or
with label sets
i or ii
p i 0
facet on the
pebble set of
labels carried by
simplex with exactly
labelled triangulation of
some component g
d polytope with
of p contains
sperner labelling of
any d simplex
simplex spanned by
on the facet
one full cell
a component g
size n d
simplex is carried
two full facets
facets of are
pebble set for
facets in f
fully d labeled
the sperner labelling
adjacent to in
every facet of
ag f of
cells in f
full facets in
with exactly one
nodes of g
in the interior
graph g 0
is carried in
that the parity
must be odd
a constructive proof
in f d
vertices of t
let g f
a triangulation of
f1 2 3
i is in
of an n
one point of
of degree 1
of size d
f r is
q i is
constructive proof of
even number of
convex combination of
an odd number
2 3 4
a path in
label set containing
degree 1 if
the usual sperner
triangulation t of
exactly two facets
face that it
edge f 1
or paths whose
carried by f
full cells proof
label sets contain
a specic polytope
facets of p
g f k
the simplices of
have degree 2
triangulation of an
other facets of
is a simplex
1 or f
the non constructive
d simplex spanned
its full cells
vertex of t
d simplex in
a simplicial facet
reduced homology groups
k face f
of a triangulation

corpus/krapavin2000-test/636696.txt
protocol
akc
ak
mti
public
secret
confirmation
authentication
elliptic
agreement
entity
attack
ephemeral
protocols
ra
keys
authenticated
diffie
security
subgroup
validation
attacks
hellman
cert
secure
curve
c0
entities
wa
prime
rb
vanstone
menezes
a0
adversary
key
x3
oorschot
private
establishment
authentic
static
ansi
mac
intercepts
implicit
logarithms
hash
cryptographic
possess
certificate
x4
pass
computes
shared
possession
prudent
authenti
attributes
terminates
certificates
secrecy
sends
x2
rogaway
bellare
x6
honest
believes
wiener
x9
launched
logarithm
session
field
unknown
deposit
purported
failure
validated
fr
her
burden
x5
anomalous
verify
p1363
x9f1
yacobi
ah
kea
krawczyk
rbwb
mtb
vaudenay
desirable
curves
share
assured
impersonation
cipher
verifiably
scalar
ca
message
encryption
xq
burmester
kyung
impersonate
sha
bank
proven
attribute
funds
van
derivation
qu
timestamping
blake
party
intractable
shim
tb
wilson
160
certified
securely
multiplication
transmitted
discrete
cation
mutual
reliance
subgroups
embedded
compromise
generates
divisible
encrypted
holder
integer
messages
pointed
exercised
multiplications
replaces
composite
goals
heuristic
informally
format
validating
recommended
guard
cryptography
coordinate
bits
sent
shs
pohlig
unauthenticated
tiality
ecdlp
graaf
solinas
succumbs
semaev
johann
araki
expo
hellmann
goss
bitlength
headquarters
tillich
15496
confiden
sik
cryptanalysis
skipjack
raimondo
evertse
cofactor
minding
imai
purportedly
kaliski
takashima
subverts
groschdl
strangio
mqv
engages
rawa
szekely
interactiveness
verifies
verifying
knows
key agreement
public key
key confirmation
protocol 1
f q
elliptic curve
ak protocol
shared secret
implicit key
domain parameters
static public
the mti
key validation
key authentication
a computes
ak and
and akc
akc protocols
unknown key
protocol run
the protocol
authenticated key
pass ak
key share
agreement protocol
with failure
small subgroup
mti c0
point sends
terminates the
protocol 2
random integer
b computes
akc protocol
mti a0
subgroup attack
key is
agreement protocols
the shared
run with
secret k
protocol protocol
a s
diffie hellman
integer r
protocol 3
private key
the elliptic
secret key
one pass
s static
sends this
point k
known key
share attribute
embedded key
three pass
entity b
validation fails
ephemeral public
key derivation
the attack
the point
secret is
two pass
of protocol
public keys
protocols described
verify that
discrete logarithm
key establishment
the protocols
a key
of ra
key pair
does an
that n
the validation
static private
desirable security
oorschot and
c0 protocol
of ak
entities a
and vanstone
the ca
share attack
provide implicit
key wa
a0 protocol
derivation function
arguments suggest
b terminates
e intercepts
security attributes
mutual implicit
van oorschot
s ephemeral
a generates
prime order
e f
attack on
authentication and
and key
the security
validation of
fails then
the ephemeral
provide key
elliptic curves
heuristic arguments
base point
r computes
entity a
logarithm problem
field f
keys are
the unknown
generates a
entity is
to b
hash functions
one entity
each entity
that protocol
a random
4 b
two entities
active attacks
b generates
an embedded
run of
the key
finite field
finite point
b to
protocol is
security of
related protocols
field elements
explicit key
intercepts a
confirmation from
secure ak
ansi x9
cert b
computes mac
on diffie
ra cert
key security
and wiener
confirmation is
her static
authenti cation
ra figure
validated as
formally proven
wa and
purported public
static keys
second entity
mac 0
q fr
cert a
authentic copy
ak protocols
honest entities
pass protocol
two field
ephemeral key
proper format
q is
illustrates that
not divide
order n
the subgroup
private keys
the defining
attack the
the desirable
computes the
an adversary
b does
computes s
valid set
divide q
protocols proposed
see x3
performance attributes
authentication is
fr a
parameters q
logarithms in
failure otherwise
in x3
message authentication
and rogaway
in x2
2 160
failure 3
the shared secret
the protocol run
run with failure
protocol run with
implicit key authentication
unknown key share
and akc protocols
ak and akc
terminates the protocol
key agreement protocol
authenticated key agreement
random integer r
pass ak protocol
computes the point
e f q
static public key
the point sends
a random integer
key agreement protocols
the elliptic curve
small subgroup attack
generates a random
the mti a0
the unknown key
shared secret is
key validation of
a key agreement
the point k
1 a generates
r a computes
of protocol 1
ak protocol protocol
does an embedded
shared secret k
two pass ak
domain parameters and
if the validation
embedded key validation
key share attribute
validation fails then
integer r a
the small subgroup
the validation fails
that the mti
public key validation
4 b computes
an embedded key
field f q
f q i
a generates a
sends this to
a computes the
to b 2
of f q
integer r computes
heuristic arguments suggest
of domain parameters
on the mti
r computes the
provide key confirmation
this to b
ephemeral public key
secret is the
mti c0 protocol
key share attack
of ak and
mti a0 protocol
s static public
point sends this
the mti c0
one pass ak
protocol protocol 2
arguments suggest that
b terminates the
provide implicit key
attributes of ak
van oorschot and
3 a computes
a and b
attack on the
the discrete logarithm
b generates a
discrete logarithm problem
in the subgroup
to a 3
each run of
a finite point
set of domain
q i e
protocols described in
illustrates that the
a finite field
the security of
of b to
that n 2
elements of f
the x coordinate
of secure ak
b does an
and validated as
secure ak and
s ephemeral public
a shared secret
5 the shared
said to provide
suggest that protocol
desirable security attributes
shared secret key
subgroup of order
format for elements
entity is on
the domain parameters
one entity is
with failure otherwise
on diffie hellman
two field elements
then b terminates
is on line
known key security
possess the unknown
goals of secure
domain parameters q
key confirmation is
key agreement with
parameters and static
up and validated
a s static
only one entity
fr a b
entities a and
e intercepts a
intercepts a s
see x3 2
validated as described
authentic copy of
and static keys
listed in x2
described in x3
parameters q fr
verify that n
key confirmation from
with failure 3
given a valid
the key derivation
satisfies the defining
the proper format
validation of ra
proper format for
the protocols described
oorschot and wiener
cert b to
n 2 160
equation of e
key pair is
establish a shared
two entities a
her static public
keys are set
mutual implicit key
static public keys
key derivation function
ak protocol 1
purported public key
x3 2 if
static keys are
explicit key authentication
a s ephemeral
the field f
computes mac 0
q fr a
protocol 2 is
of the proper
a three pass
2 b generates
protocol 1 is
is the point
b to a
the key is
a 3 a
authentication and key
generated by p
not divide q
in f q
hellman key agreement
for elements of
protocol is said
key authentication the
are set up
defining equation of
model of distributed
and a three
elliptic curve e
replaces it with
the defining equation
a one pass
fails then b
a valid set
set up and
valid set of
of the protocol

corpus/krapavin2000-test/636898.txt
tcp
red
flows
packet
queue
diffred
packets
window
drop
congestion
timeout
gentle
aqm
udp
queues
trip
round
ns
goodput
maxth
tail
avoidance
simulations
fairness
flow
minth
pps
priority
throughput
maxp
epoch
steady
timeouts
diffserv
da
coefficient
acks
newreno
traffic
differentiated
delay
bottleneck
service
losses
analytical
reno
rsvp
loss
congested
transmission
competing
dropped
inversely
fig
s5
option
internet
link
network
ietf
session
queuing
s2
probability
ecn
propagation
population
s3
validated
burst
drops
heterogeneous
th
responsive
average
td
sec
duplicate
simulation
gateways
services
variant
detection
vis
sessions
ack
unknowns
schematic
proportional
s4
raphson
ip
solver
topology
abouzeid
minthv
dependance
wred
sharing
reservation
validation
160
bias
links
equations
qv
nda
unfairness
aimd
formula
poisson
sink
mixed
dropping
rates
240
a3
newton
postulate
underutilized
duration
multiplicative
modeling
header
macroscopic
conditioned
routers
additive
overflow
lost
marking
neglecting
tos
s6
configure
buffer
substituting
forced
promoting
s7
roy
rio
lossy
destination
evolution
experiment
decrease
advertised
kbps
formulae
capacity
transmitted
slope
detected
c3
accurate
allocation
against
recipes
a4
a1
s1
av
margin
numerically
approximation
delays
c4
originates
differentiation
figures
ideally
reception
governed
rate
analytic
capacities
averaged
numerical
connection
slow
convergent
connections
belongs
efforts
expressions
networks
yielding
consecutive
passes
neglected
derivation
12180
2maxth
troy
352500
filed
rensselaer
formula1
3051525average
tcp flows
tail drop
window size
packet drop
red queue
of red
average queue
the gentle
queue size
drop probability
packet loss
round trip
the tcp
of tcp
congestion avoidance
flow j
gentle variant
red queues
average window
from simulations
congestion window
th flow
th queue
udp flows
and udp
steady state
the packet
tcp and
tcp flow
v th
priority coefficient
ns simulations
the steady
the red
round i
the average
size obtained
drop queue
the diffred
against ns
average goodput
the window
j denote
z w
trip time
the v
with tcp
a packet
differentiated services
timeout formula
red algorithm
comparison points
priority class
goodput obtained
gentle option
flows and
point approximation
for tcp
network of
a timeout
congestion control
red and
a network
sharing a
from analysis
average round
diffred queues
tcp timeout
of aqm
timeout behavior
tcp session
network solver
packets sec
pps approximation
th epoch
the timeout
flows with
the priority
a tail
queues with
the network
j th
the pps
flows sharing
multiple tcp
ns 2
tcp reno
the probability
the congestion
of service
a red
denote the
simulations and
inversely proportional
population of
obtained from
size for
fixed point
tcp traffic
burst loss
of diffred
simulations packets
mixed tcp
flows obtained
and diffred
packets average
packets fig
packets second
a diffred
j packets
inter loss
competing flows
fairness index
m tcp
diffred queue
state throughput
analysis packets
loss window
random early
trip delay
the j
expression for
a population
each queue
each flow
of flows
bottleneck link
single queue
for red
tcp congestion
average packet
packet drops
queue management
the fairness
analysis for
is inversely
early detection
e w
higher priority
the round
transmission rate
validated against
packet losses
each tcp
udp traffic
queuing delay
a bottleneck
k j
proportional to
table i
of heterogeneous
propagation delay
the simulations
w denote
slow start
the ns
and s3
analytical results
w j
queue is
w i
the internet
i th
current round
transmission rates
for mixed
packets are
packet is
an aqm
of epoch
two red
experimental network
bottleneck red
fairness coefficient
red packet
loss from
responsive flows
forced packet
epoch i
trip propagation
raphson technique
packets minth
different round
congested red
increase multiplicative
denote flow
consecutive da
aqm queues
heterogeneous flows
fairness results
substituting by
window increase
duplicate ack
tcp newreno
loss within
non responsive
modeling tcp
drop queues
resource reservation
first loss
average queue size
packet drop probability
the gentle variant
obtained from simulations
tcp and udp
average window size
v th queue
j th flow
the v th
the steady state
a packet loss
against ns simulations
the priority coefficient
size obtained from
fixed point approximation
round trip time
the average queue
window size for
the window size
the gentle option
obtained from analysis
a tail drop
goodput obtained from
tail drop queue
average goodput obtained
a network of
j denote the
congestion window size
simulations and analysis
of the tcp
from simulations and
average round trip
the j th
the packet drop
the average window
population of heterogeneous
i th epoch
experiments with tcp
denote the probability
and analysis for
for a population
drop probability for
the average round
flows sharing a
sharing a bottleneck
a population of
w i j
inversely proportional to
non linear equations
random early detection
round trip delay
network of aqm
gentle variant of
the network solver
the m v
from simulations packets
point approximation to
steady state throughput
from analysis packets
simulations packets average
for mixed tcp
of red queues
multiple tcp flows
a red queue
without the gentle
validated against ns
and udp flows
m tcp flows
average packet drop
the red queue
queue size obtained
network of red
mixed tcp and
flows obtained from
variant of red
analysis packets fig
in the internet
i j denote
is inversely proportional
and udp traffic
for tcp flows
tcp flows with
tcp flows and
tcp flows sharing
of red and
proportional to the
the round trip
an expression for
packets are dropped
congestion control in
w denote the
for the case
the i th
to a network
for congestion avoidance
the current round
throughput of a
analysis for the
of the packet
round trip times
denote the average
the probability that
with different round
consecutive da s
packet loss detection
the red algorithm
versions of tcp
with tcp traffic
tcp traffic only
with tcp and
window size just
additive increase multiplicative
round trip propagation
steps as before
fairness index for
red queue is
a bottleneck red
packet loss from
one packet loss
burst loss within
for the gentle
case without the
tail drop queues
for z w
sets of flows
a diffred queue
different round trip
by a timeout
the average packet
tcp congestion avoidance
total of 160
and tail drop
z w was
the first loss
case of red
j denote flow
red and tail
denote the steady
congested red queue
experimental network topology
the pps approximation
denote flow j
of epoch i
newton raphson technique
of flow j
non responsive flows
for a tail
e z w
of the diffred
increase multiplicative decrease
to tail drop
the fairness index
congestion avoidance in
queues with tcp
priority coefficient of
of a timeout
red and diffred
analysis for mixed
trip propagation and
probability of a
the analytical results
of the average
v denote the
for the probability
of k j
the congestion avoidance
congestion avoidance phase
to the round
of tcp flows
for each simulation
way propagation delay
for each queue
red in the
the tcp flows
the case without
s4 and s5
in the congestion
least one packet
active queue management
class of service
round i 1
in table i
a total of
the end of
of the i
a fixed point
the probability of
for the higher
the higher priority
congestion avoidance and
transmission rates of
window size in
for the steady
formula for a
probability that a
of both sides
expressions for the
detected by a
flows in the
of the v

corpus/krapavin2000-test/637151.txt
defective
oca
cell
intact
cells
cas
cellular
recognizable
defects
ca
leftmost
counter
rt
ocas
arrays
sd
mo
tolerant
dd
automata
ow
fault
conguration
signal
recognition
constructor
registers
diagnosis
neighbor
capabilities
links
nite
strings
failures
leftmoving
rightmost
rst
transition
string
lengths
array
reliable
link
massively
nonuniform
recognizes
congurations
corollary
1o
signals
devices
synchronization
nal
neighbors
jwj
regions
adjacent
transmit
carry
transmitted
misoperations
squad
sequel
compensated
inclusions
arrives
register
conserved
interacting
signicant
reversal
hs
repair
subroutines
denition
stop
constructors
shift
waiting
failure
pushdown
static
overflow
computations
ows
resp
dene
constructible
stores
se
symbols
receives
reset
recognized
regain
cf
ng
self
simulates
enlarged
contents
ai
nonempty
depicted
syntactical
device
enters
arrival
concerned
circuit
recognize
received
successor
nondeterminism
counters
interconnected
establishes
broken
dened
incapacitate
inheres
invalids
stepg
trellis
bidirectionality
homogenously
bounces
fww
misoperation
nearest
fail
marking
adapt
delay
symbol
reliably
correspondingly
prepared
boundary
compensate
unreliable
admissible
invalid
equivalence
formalization
needless
incrementation
characterizable
subarray
subsequently
behave
marks
latest
strictly
ring
wider
relax
indication
nobody
mapping
speed
track
language
ne
simulation
binary
lt
organisms
tomata
nization
compression
eect
lim
themselves
bit
positions
recognizers
word
sends
indicated
satises
region
modulo
located
intensively
signaled
distinguishable
adaption
belong
synchro
synchronously
enlarge
simulated
receive
jdj
neumann
digit
strictness
joint
investigated
recognizable by
defective cells
defective cell
leftmost cell
the leftmost
l rt
real time
the counter
sd ca
a defective
cellular automata
cellular arrays
time constructor
an oca
b cells
a cell
fault tolerant
a a
intact cells
way arrays
defective regions
two way
time recognizable
transition function
the cells
way cellular
cellular array
the defective
dd ca
mo ca
mo cas
intact cell
information ow
dynamic defects
time step
c t
link failures
cell is
of defective
recognition capabilities
intact neighbor
with defective
stop signal
self diagnosis
rt oca
counter c
local transition
one way
a sd
cells are
carry over
arrays with
sd cas
signal arrives
static defects
additional registers
shift right
o ca
a cells
0 a
computation result
is recognizable
a dd
defects are
with link
time steps
a 0
2 n
each cell
cell of
the stop
adjacent cells
counter value
cell has
regions are
cell i
the b
right counter
string sets
defective region
boundary state
ca in
signicant bit
cas are
over ow
of intact
defective links
are intact
intact one
ca is
is fault
the rst
of cell
t 1
cells by
actual computation
constructor for
is real
cells is
f i
the rightmost
of strings
computation would
a ca
binary counter
tolerant real
diagnosis is
capabilities of
a 8
nite state
a 7
the cell
lengths of
states from
cf figure
at time
0 w
input symbols
a 5
the lengths
states of
a 9
right neighbor
the states
7 a
every time
synchronization of
cell and
the received
ca and
oca counter
its defective
new defects
rt mo
leftmoving signal
each intact
cas with
tolerant computations
not recognizable
intact ones
cell cannot
diagnosis circuit
defects it
received counter
with speed
twice real
tolerant recognizable
adjacent defective
conguration c
hs ai
least signicant
next intact
time constructors
impossible at
oca then
ca then
of cas
such devices
reliable computations
binary oca
for cas
oca l
way array
cell states
cell enters
modify information
cas the
defective cellular
cell the
a 6
n a
input string
massively parallel
a 1
to l
cells in
register contents
speed 1
a carry
by sd
cannot modify
both links
ow the
b cell
once before
the defects
receive information
transmit it
nite nonempty
ca if
cell f
in twice
the intact
3 a
be some
cells of
a 3
all cells
to left
its right
a a a
the leftmost cell
recognizable by a
time recognizable by
real time recognizable
c t 1
the b cells
a 0 a
defective regions are
a defective cell
0 a 0
the local transition
local transition function
a 1 a
a 5 a
l rt oca
a sd ca
a 7 a
a 3 a
2 a 1
1 c t
is real time
4 a 3
t 1 c
the defective cell
within the b
time constructor for
recognizable by an
one way arrays
by an oca
c 0 w
is recognizable by
a time constructor
the stop signal
with link failures
6 a 5
a 4 a
3 a 2
a 6 a
a set is
a 2 a
1 a 0
5 a 4
is fault tolerant
of defective cells
way cellular array
defective cell is
signal arrives at
two way arrays
one way cellular
by a dd
7 a 6
8 a 7
a self diagnosis
within the rst
shift right counter
stop signal arrives
by a sd
with dynamic defects
recognition capabilities of
a 9 a
at every time
the actual computation
if a set
every time step
of two way
able to transmit
tolerant real time
a 8 a
fault tolerant real
the lengths of
set of strings
of the counter
f f f
to the left
a two way
before the actual
s is the
the synchronization of
each cell has
has been shown
in real time
in twice real
with speed 1
overall computation result
self diagnosis circuit
of cell states
enters a nal
the received counter
state 3 a
impossible at all
to l rt
once before the
at time 2
constructor for 2
states from its
to transmit it
twice real time
the information ow
nite nonempty set
leftmost cell enters
arrays with dynamic
cellular arrays with
counter c 2
oca l rt
the boundary state
cells are intact
set is fault
by 1 at
9 a 8
cannot modify information
ca then it
by one way
defective cells are
intact cells is
which is run
cell f i
run once before
n a cells
regions are bounded
received counter value
way cellular automata
is run once
a carry over
cell cannot modify
least signicant bit
ca is a
fault tolerant computations
rt oca l
oca then it
cell enters a
two way cellular
with defective links
produces an over
has a self
be some constant
defective cell cannot
an over ow
boundary state 3
of a defective
with defective cells
rt mo ca
a dd ca
the least signicant
tolerant recognizable by
set of cell
step at which
fault tolerant recognizable
intact one way
nite state machine
each intact cell
way information ow
l rt mo
set is real
right to left
is the local
2 n a
the states of
in order to
the sequel we
of the cells
for 2 n
link failures are
some constant then
step for each
3 a s
belong to l
broken into two
that a cell
increased by 1
with unit speed
time step at
1 a a
cell of a
1 at every
the parallel computation
from right to
a nal state
of input symbols
cell has a
the position is
in the sequel
now we are
of cell i
time 2 2
m 2 n
2 2 r
2 n 0
a nite state
is the boundary
not belong to
indicated by the
the overall computation
nonempty set of
that each cell
is depicted in
the rst time
are bounded by
real time and
at some time

corpus/krapavin2000-test/637236.txt
lsas
lsa
ospf
routers
router
refresh
traffic
lsar
duplicate
bdr
day
lan
eigrp
dr
lans
enterprise
ios
external
originated
areas
flooding
topology
backbone
lan2
lsars
customer
routing
area
configuration
synchronization
border
network
b2
rtrs
flapping
april
hour
refreshes
link
b1
monitoring
leased
triggered
flood
aman
roughan
isp
reachability
spf
lsag
lan1
rtr
asbr
bgp
internet
episodes
minutes
connectivity
files
ip
modes
shaikh
adjacencies
duplicated
regularg
dynamics
broadcast
prefixes
imported
advertisements
timer
jittered
flooded
reliable
customers
periodicity
periodic
minute
injected
premise
problematic
ethernet
operational
spectrum
deployed
greenberg
burstiness
hub
series
stability
links
synchronized
instability
saw
matthew
imports
finer
period
revealed
shortest
internal
received
failure
spikes
albert
hop
copies
freqency
flaps
impacting
withdrawing
lsags
clumped
spoke
utes
isett
priority
deployment
summary
cisco
2002
net
site
learns
month
multicast
fig
receives
announcing
donoho
riecke
injects
originates
witnessed
injection
route
receive
remote
soft
yin
center
measurement
connected
monitor
igp
rexford
expiry
lund
fdr
originate
prefix
carsten
rebooted
asymmetries
isis
episode
l1
ton
routes
l2
attached
scalability
basu
learnt
conveyed
reliably
persistent
ffl
localizing
drift
vii
propagate
scope
convergence
jitter
listen
proactive
arose
vendor
protocol
99
nr
lr
networks
bursts
configurable
send
cycles
failing
election
driving
jennifer
servers
status
physical
negligible
plane
evidence
networking
workload
lsa traffic
of lsas
change lsas
duplicate lsas
duplicate lsa
the ospf
refresh lsa
lan 1
on lan
in area
the lsa
area 0
ospf domain
external lsas
the routers
originated by
enterprise network
lsas originated
lsas per
the dr
the router
the lsar
of refresh
b pair
day number
refresh lsas
day april
lsas day
lsa l
other routers
per day
area 2
the refresh
lsas in
pair routers
of lsa
a router
of ospf
non backbone
the enterprise
april 2002
change lsa
in april
different routers
dr and
link state
configuration files
routers in
of change
of routers
time series
into ospf
external changes
data center
failure modes
summary lsas
total duplicate
of duplicate
the network
area 3
ios 11
backbone area
ios 12
router network
and bdr
traffic in
routers on
connected to
router configuration
the lan
and duplicate
ospf is
border routers
an lsa
lsas received
lsa to
lsas the
lsas a
backbone areas
lan2 routers
refresh traffic
network lsas
2002 refresh
flooding scope
routers that
single router
traffic is
are connected
routers are
reachability information
lsas for
topology graph
ospf s
the lsas
ospf monitoring
lan 2
customer site
bdr on
broadcast network
ospf lsa
area 8
lsas to
case study
the b
per hour
border router
lans and
in ospf
refresh period
change and
power spectrum
all areas
b1 and
of external
and b2
finer time
leased lines
control plane
level flooding
customer premise
become dr
each day
problematic router
lsas triggered
ospf areas
that lsa
state advertisements
the lsars
lsas were
2002 total
root causes
lsas and
the bdr
internal change
internal changes
state database
state refresh
lsar on
running ios
all rtrs
measurement conference
lsas due
remote areas
by lan2
ethernet lans
advertisements lsas
day in
lsa propagation
router lsa
at lsar
lsas change
ospf topology
lsas are
traffic for
the topology
traffic and
series analysis
each router
net work
two routers
routers running
soft state
total change
router r
each area
aman shaikh
lower graph
graph shows
triggered by
synchronization is
a link
matthew roughan
network wide
topology changes
upper graph
customers are
the figure
the backbone
that area
case 4
ip networks
2 total
internet measurement
the configuration
these lsas
lsas duplicate
reliable flooding
ospf networks
in duplicate
lsas by
0 router
total lsas
large enterprise
are flooded
under cases
router lsas
two lans
router g
force case
customer reachability
duplicate lsa traffic
refresh lsa traffic
number of lsas
on lan 1
lsas originated by
day number of
day april 2002
per day april
lsas day number
the b pair
lsa traffic in
the ospf domain
b pair routers
of change lsas
the enterprise network
lsas in area
lsas per day
of lsas per
in area 0
change lsa traffic
total duplicate lsas
the time series
originated by a
of lsas day
lsa traffic is
in area 2
of duplicate lsas
dr and bdr
the dr and
are connected to
a single router
april 2002 refresh
on the lan
change and duplicate
routers on the
number of change
2002 refresh lsas
lsa traffic and
non backbone areas
all the routers
of refresh lsa
the lsa to
other routers on
of lsa traffic
from different routers
lsa traffic for
bdr on lan
of lsa l
change lsas in
number of duplicate
of the ospf
b1 and b2
the power spectrum
the routers in
time series analysis
change lsas due
2 total change
total change lsas
lsas triggered by
cycles per hour
lsas due to
link state advertisements
day in april
area 2 total
to the lsar
lsas change lsas
level flooding scope
originated by lan2
class of lsas
refresh lsas change
rate of refresh
router network lsas
and duplicate lsa
the backbone area
link state database
of lsas originated
the data center
soft state refresh
state advertisements lsas
the lsa traffic
copies of lsa
by lan2 routers
internet measurement conference
of lsas triggered
a link state
of the enterprise
finer time scale
routers in the
router configuration files
the lower graph
number of external
the configuration files
at a router
routers are connected
graph shows the
the upper graph
of the router
revealed that the
of the routers
cases 1 and
number of routers
the net work
the case study
of the topology
customer reachability information
area level flooding
significant duplicate lsa
internal change lsas
predict the rate
in duplicate lsa
number of router
and duplicate lsas
from the configuration
to both lans
suggested that lsa
for routers running
external change lsas
set of lsas
the other routers
dr or bdr
april 2002 total
the lsa propagation
applications and databases
ospf is a
a large enterprise
change lsas duplicate
of duplicate lsa
analysis revealed that
lsas the class
routers running ios
the refresh lsa
running ios 12
that lsa refreshes
at lsar during
routers of the
the ospf topology
network lsas in
customers are connected
duplicate lsas received
routers attached to
lan2 routers that
non backbone area
lsa to lsar
under cases 1
a broadcast network
lsa l in
of external lsas
lsas are flooded
lsa traffic seen
lsa traffic from
area 0 router
lsa traffic at
lsar does not
partial failure modes
refresh period of
upper graph shows
as it turned
shortest path tree
a given area
the link state
of the network
case study we
than 99 of
more than 99
for a few
in the operational
is a link
routing in the
shows the number
it is connected
it turned out
the network the
of a typical
have observed that
in the network
the topology of
case study of
is connected to
this case study
is a first
we have observed
1 and 3
topology graph for
all the areas
s reliable lsa
injected into ospf
lsar on the
for each area
about 15 areas
provides highly available
enterprise network under
refresh change and
lan2 routers total
of ospf behavior
refresh lsas actual
enterprise network we
that lsas originated
2005 berkeley ca
play on lan
day the lower

corpus/krapavin2000-test/637247.txt
hop
ttl
probes
accsig
pq2
pq1
pathchar
hops
packet
probe
pacesetter
clink
invisible
pt1
pq3
route
quartets
icmp
peak
delay
ct
estimates
link
ip
accumulation
pt2
pacesetters
quartet
traffic
busy
packets
100mbps
bandwidth
receiver
measurement
noise
sender
segments
segment
variation
cross
tailgater
acc
histogram
errors
probing
routes
layer
queue
10mbps
cancels
sensitivity
lan
bandwidths
estimation
headers
detection
trip
signature
service
estimate
udp
mbps
periods
measurements
filtering
mixing
bottleneck
peaks
symmetric
uncorrected
histograms
2mbps
backward
dropped
period
measuring
est
waiting
router
22mbps
invasiveness
2x100mbps
sigcomm
internet
departure
veitch
suspected
header
atm
minima
leaving
byte
100
1500
switched
bimodal
pace
round
fw
bw
streams
suffer
sent
155mbps
nettimer
darryl
lindley
2x2mbps
2x10mbps
gater
magnification
spacing
baker
cancellation
analysed
143
slope
sizes
returning
100s
sridhar
wetherall
lai
rate
propagation
variants
fig
pq
estimated
linearities
dovrolis
utilised
arrive
queues
120
timestamps
correction
messages
machiraju
dispersion
routers
equation
forwarding
accuracy
traverse
seg
drawbacks
accurate
simulation
network
rates
expired
behaviour
iii
entering
neil
medians
stream
symmetry
erroneous
live
median
fragmented
gps
reliance
arrived
sending
arriving
won
anderson
consequences
delays
cancel
nominal
unknown
instant
09
differences
ethernet
expires
inter
analyse
links
error
arrives
equations
arrival
detected
spaced
sig
arrivals
diagnosis
sized
alternate
sec
forward
simulations
obey
ft
delay variation
invisible hops
cross traffic
peak detection
pathchar and
the probe
packet quartets
h ttl
the probes
and clink
hop h
link bandwidth
no ct
busy period
of probes
the delay
probe size
the ttl
pq1 and
pq1 pq2
packet quartet
detection errors
of invisible
ct with
with ct
probes and
service time
ttl 1
international route
packet pair
and pq2
estimate lower
w h
1 hop
last hop
link rate
upper estimate
limited ttl
hop a
different busy
ct no
acc component
pq2 pq3
bandwidth estimates
accumulation signature
pq3 pt1
same busy
pathchar clink
to peak
probe sizes
the packet
busy periods
the estimates
the route
sensitivity to
the pacesetter
invisible hop
the icmp
6 hop
of accsig
for accsig
hop route
on hop
link layer
the link
icmp messages
the hop
sender receiver
of packet
the accumulation
estimation errors
k ttl
backward route
and accsig
of pq1
for pq1
measurement methods
the tailgater
hop segments
its pacesetter
pacesetter packets
variation based
probe i
clink and
for pq2
accsig and
link rates
packet size
round trip
each hop
link bandwidths
hops the
the measurement
100 100
probe and
minimum delay
ttl is
ttl values
ttl and
for segments
1 ip
ttl field
a hop
the peak
estimates are
the methods
estimation methods
a probe
the noise
relative error
the cross
no cross
defining equation
lower layer
of probe
probe stream
5 07
at hop
packet 3
component leaving
pathchar like
quartets with
100 143
ip ttl
hop 3
hop 2
based estimates
ip 1
accsig pq1
layer headers
mixing equation
packet 4
the pacesetters
fw hop
hop mixing
100 120
path representation
pq1 is
accumulation term
receiver packet
different packet
the accsig
rate estimates
accumulation component
pacesetter packet
clink a
hop 1
single hop
packet sizes
to end
new methods
the waiting
to back
of hops
segments with
end to
estimates of
the ip
of link
like methods
network measurements
packet 2
3 packet
bandwidth estimation
cancels the
estimates from
packet 1
ttl the
the receiver
the defining
section ii
waiting time
component b
segment 9
2 packet
probes are
4 packet
packet delay
07 5
1 h
each probe
departure time
trip delay
the estimate
packets with
waiting times
bottleneck link
for method
packet is
table iii
method pq1
pt1 and
variation histogram
100mbps lan
based estimate
method pq2
hops can
suspected bottleneck
pacesetter sizes
probe packet
the delay variation
pathchar and clink
ct with ct
no ct with
upper estimate lower
peak detection errors
the last hop
of invisible hops
the cross traffic
with ct no
pq2 pq3 pt1
sensitivity to peak
pq1 pq2 pq3
the same busy
pq1 and pq2
same busy period
ct no ct
service time of
to peak detection
of the probes
delay variation based
in different busy
h ttl 1
the backward route
different busy periods
the accumulation signature
number of probes
at each hop
the defining equation
the service time
end to end
back to back
the probe and
of the probe
defining equation for
probe size and
the probe size
pathchar and its
equation for method
packet quartets with
leaving the defining
4 packet 1
the international route
accumulation component leaving
pathchar clink and
packet 4 packet
6 hop route
the peak detection
of cross traffic
2 packet 4
5 07 5
packet 3 packet
packet 2 packet
receiver packet 3
link bandwidth estimates
sender receiver packet
component leaving the
hop h ttl
no cross traffic
clink and accsig
delay variation and
and clink a
delay variation of
3 packet 2
bandwidth estimates of
the packet size
round trip delay
number of hops
to pathchar and
h w h
the waiting times
for segments with
of link bandwidth
h ttl and
the packet quartet
100 9 09
probe size the
of international route
relative error uncorrected
the accsig method
a limited ttl
from the difference
inter departure time
hops can be
lai and baker
and peak detection
the ip header
uncorrected est upper
1 hop segments
the hop mixing
delay variation histogram
for invisible hops
last hop of
h k ttl
packet pair based
delay variation histograms
model of packet
acc component sender
and its pacesetter
est upper estimate
the probe sizes
w h w
link bandwidth estimation
presence of invisible
the link rates
the tailgater method
100 100 9
correction for invisible
bw estimates upper
as for accsig
variation and peak
packet quartet methods
of packet quartets
at hop h
error uncorrected est
link layer headers
pathchar clink accsig
with no cross
equation 13 for
estimates upper estimate
accsig pq1 pq2
100 120 100
probe and its
a deterministic model
an invisible hop
of the pacesetter
and its variants
of the measurement
the estimate of
of the noise
symmetry of the
the symmetry of
along the route
of packet delay
the first hop
h s i
deterministic model of
the noise is
measuring bottleneck link
the cancellation of
that the probe
in section ii
the difference in
the link layer
time to live
the waiting time
the probes and
to live ttl
difference in the
of the ip
f i g
on the last
from the sender
section ii d
methods are based
the estimates of
of the packet
store and forward
constant for each
of the route
of the delay
to the link
in section iii
the nature of
the round trip
s i is
the accuracy of
in the case
number of different
the case of
the difference of
3 and 5
in table ii
assumption of probes
120 100 120
pathchar like methods
different network routes
the packet pair
of lai and
100 143 100
hop 3 hop
in table vi
hop mixing equation
of icmp messages
udp packet is
packet sizes used
the probes to
simulation based link
the symmetric noise
of different packet
detection errors and
generate the icmp
1 67 1
all one packet
a edge component
invisible hops correction
equation the first
the i histogram
bandwidth estimation method
50 bw estimates

corpus/krapavin2000-test/637321.txt
residually
n0
morphic
ultimately
kn
periodic
mthhn
buchi
morphism
word
monadic
xp
semigroup
decidable
predicates
predicate
un
elgot
nite
integers
fibonacci
dn
acc
rational
hn
letter
factorized
rabin
innite
alphabet
decidability
siefkes
d0l
automaton
xed
automata
dened
sequences
thue
maes
accepted
morphisms
eectively
characteristic
dierence
contraction
dene
suces
ln
fn
dierences
factorial
integer
exponentiation
morse
undecidable
landweber
nal
ng
rst
00
lemma
innitely
coecients
congruence
eective
unary
lm
proposition
expansions
theories
equivalence
au
fthhn
undecidibility
berstel
wmthhn
blkbd
1k
coecient
factorization
acceptance
corollary
powers
jean
una
grater
ang
binomials
unsettled
fen
letters
mod
recursive
closed
ehrenfeucht
qq
belongs
theoretic
k1
thm
mth
bc
claim
games
fun
primes
nally
induction
product
fk
decision
generalizations
vn
sucient
prime
successful
infinite
jn
prominent
inline
nitely
sequel
concrete
matrix
xn
satises
wn
dimension
veried
proves
belong
embed
reducible
cellular
polynomial
periodicic
sturmian
boasson
bumyampersanduml
schinzel
870
phic
hosch
allouche
buechi
myampersandlt
utzenberger
desarmenien
petazzoni
lqq
automota
sentence
said
images
icates
schutzenberger
arith
endows
carton
mfcs
ordinals
semigroups
wilke
approachable
suce
grdel
closure
thomas
obviously
strictly
concatenation
1966
matics
cidable
canonically
mathe
metic
presburger
gers
relations
imply
expansion
denitions
kk
dissertation
pictured
cial
complementing
contracted
twin
jacques
ffn
arithmetics
matrices
lim
sch
almeida
jorge
nonterminating
ultimately periodic
residually ultimately
n0 is
l n
n n0
t p
is residually
the sequence
word x
mthhn p
n rational
k n
n greater
monadic theory
sequence un
two integers
sequence k
problem acc
morphism from
innite word
characteristic word
1 kn
the word
morphic predicates
p kn
the monadic
is decidable
a into
the morphism
kn q
nite semigroup
un n0
periodic the
integer n
the fibonacci
elgot and
predicates p
any integer
n q
a morphism
kn 1
kn l
theory mthhn
buchi automaton
acc xp
of morphic
integers r
accepted by
dened by
any n
and rabin
p i
of integers
than r
kn t
q 00
contraction method
is morphic
periodic sequences
kn n0
predicate p
is accepted
sequence u
integers t
be factorized
rational sequence
then residually
morphic predicate
that kn
the characteristic
for any
class k
periodic and
hn i
of hn
p such
the predicate
k l
integer l
decision problem
by lemma
the alphabet
to k
hn p
dierence kn
into itself
also residually
of residually
un is
n0 of
n0 dened
dn q
that mthhn
n0 and
the contraction
integers n
order theory
word of
integers is
u n
and p
let un
of dierences
n l
n t
the class
the xed
p l
q l
a nite
xed point
greater than
a d0l
of elgot
acc x
d0l sequence
alphabet b
nite word
semigroup s
periodic by
morphic words
xp is
be eectively
a n0
a morphic
fibonacci predicate
the sequences
closed under
of words
is equal
the dierence
automaton a
nal state
r 0
an innite
into b
dene the
xp and
lemma 26
sequences k
alphabet a
periodic if
kn is
one has
the innite
each sequence
such that
u k
both sequences
that un
monadic second
belongs then
is n
and q
it suces
a l
any k
p the
buchi acceptance
eectively computed
n0 belongs
un a
ln n0
thue morse
25 there
a kn
word over
lemma 27
morphism 0
nite words
a buchi
the semigroup
innite words
are residually
dn r
periodic predicates
morphic word
lemma 25
word xp
rabin 11
siefkes 18
xed integers
not ultimately
morse word
factorial predicate
dierences is
sequence of
sequence v
the relation
is undecidable
k be
relation t
the nite
q for
word is
let k
matrix representation
and product
n dn
n0 be
residually ultimately periodic
is residually ultimately
from a into
mthhn p i
n greater than
n n0 is
morphism from a
sequence k n
any integer n
n0 is residually
t p kn
the characteristic word
ultimately periodic the
k n n0
accepted by a
the sequence k
i is decidable
k l n
the monadic theory
p i is
the word x
l n n0
t p l
two integers r
p kn q
n t p
is n rational
elgot and rabin
the sequence un
l n q
is accepted by
for any integer
greater than r
l n 1
for any n
that the sequence
any n greater
kn t p
problem acc xp
characteristic word of
and p such
ultimately periodic and
sequence u n
innite word x
can be factorized
an innite word
kn l n
p l n
theory mthhn p
sequence un n0
are two integers
u n n0
ultimately periodic sequences
and l n
p such that
a morphism from
the sequence u
monadic theory of
the class k
periodic sequences of
there are then
integers t and
then residually ultimately
the contraction method
n 1 kn
a nite semigroup
q l n
integers n and
kn 1 kn
t and p
n and p
the dierence kn
predicate p the
n0 dened by
also residually ultimately
buchi automaton a
hn p i
integers r and
of residually ultimately
is then residually
i is undecidable
that kn t
n0 is n
sequence of dierences
x is accepted
word x is
decision problem acc
of integers is
is equal to
the decision problem
the xed point
l n is
sequences of integers
k n l
r and q
1 l n
n l n
t p r
dene the morphism
for n greater
monadic theory mthhn
that mthhn p
then to k
n rational sequence
periodic by lemma
the fibonacci predicate
1 kn n0
the problem acc
class of residually
then two integers
ultimately periodic if
of morphic predicates
morphic predicate p
relation t p
word x can
integer n greater
acc xp and
k t p
ultimately periodic by
the alphabet b
two integers n
a d0l sequence
are then two
the innite word
of hn p
problem acc x
belongs then to
of elgot and
p to q
and q such
is the characteristic
the sequence of
for any k
if the sequence
n q for
l n t
path from p
to k the
and the sequence
greater than t
equal to a
that for any
on n that
a l i
a nal state
a into a
monadic second order
let k be
k n 1
sum and product
sequence of integers
of the predicate
n0 and l
a into itself
morphism 0 from
class of morphic
thue morse word
is not ultimately
a n0 is
sequences k n
any b in
such that kn
dierence kn 1
are residually ultimately
by lemma 27
the morphism 0
periodic the following
of dierences is
be eectively computed
n0 of integers
such that mthhn
is integer for
r t p
q for n
the factorial predicate
theory of hn
not ultimately periodic
belongs to k
can be eectively
kn n0 is
xp and hence
a matrix representation
and rabin 11
l n dn
periodic the sequence
n is integer
the alphabet a
integer for any
product and exponentiation
a buchi automaton
t p m
lemma 25 there
ultimately periodic predicates
into a nite
a n rational
dierences is then
nite semigroup s
a 0 into
un n0 is
25 there are

corpus/krapavin2000-test/637371.txt
iag
tiam
lb
__
interval
gradtest
minimizers
casado
sergeyev
martinez
rejected
ya
intervals
minimizer
univariate
multiextremal
garcia
nal
monotonicity
rangeup
tg
gradient
lipschitz
tm
inclusion
dierentiable
enclosure
evaluations
ualm
funct
subintervals
subdivision
rejection
elimination
derivative
cut
working
division
bounding
novgorod
nde
nfe
minflb
nizhni
deis
midpoint
objective
termination
optimization
fx
mail
slopes
criterion
fg
_
shortened
minimization
slope
nishes
271
boxes
continuously
fullled
save
traditional
bounds
subdivided
numerical
accelerate
spain
graphically
davinci
diago
vink
jamartin
mdashlthe
ministerio
almera
educacion
fulll
cultura
0361
fxnv
87036
iron
xnv
leo
cutotest
lagouanelle
maxff
calabria
csendes
tibor
kite
3x
hendrix
yaro
tic99
russia
miro
unical
igo
772
rule
sin
es
lists
evaluated
graphical
inma
rende
fsg
della
nonsmooth
universita
rst
stored
realization
satised
branch
isi
disposition
lling
tams
hereinafter
comment
head
global
636
445
982
cicyt
subregion
subinterval
arithmetic
78
piece
bottom
speedup
margins
711
optimiza
dierent
graphs
284
460
cnr
176
column
louis
435
268
366
456
fig
criteria
156
electronics
return
yellow
basics
gures
bridging
282
initialization
98
331
292
elaborated
depict
336
rejecting
bisection
blue
selection
tests
214
else
newton
adaptively
initializing
261
178
114
inherit
built
209
x2
search
si
206
stopping
signicantly
259
eliminated
dened
2g
colored
132
jointly
lb x
support functions
interval x
interval analysis
f x
global optimization
x lb
__ __
support function
x f
z x
new support
analysis global
m x
an interval
global minimizers
f z
hand graph
intervals x
of f
f 0
and ya
i garcia
g casado
casado i
working list
garcia j
d sergeyev
a martinez
monotonicity test
and iag
ya d
martinez and
0 x
f m
the interval
the working
tiam and
gradtest procedure
x over
cut o
objective function
division rule
f lb
o test
nal list
the gradtest
tm tg
global minimization
gradient test
inclusion function
global minimizer
for f
test functions
gradient information
the objective
x g
iag algorithm
traditional interval
rule line
save fx
of tiam
the iag
nal lists
bound f
l g
minimization algorithm
working and
new interval
an enclosure
and lb
interval v
using gradient
w x
the intervals
list q
dierentiable function
and nal
information 1
lower bound
function f
of interval
x i
list l
x is
optimization algorithm
lower bounds
x s
2 x
bounding rule
iag is
analysis support
univariate functions
x line
fx f
algorithm iag
tiam algorithm
search information
the tiam
ualm es
test is
j a
f f
the nal
continuously dierentiable
from 2
problem 1
the search
over x
elimination rule
contain global
if f
the new
the monotonicity
and f
contain any
function evaluations
for subdivision
rst derivative
x 2
a traditional
f is
new algorithm
x does
when f
interval arithmetic
better lower
x and
of global
interval will
selection rule
functions are
a continuously
any global
stored in
e mail
not contain
bound of
condition f
a support
global minimum
x the
algorithm using
ordering criterion
minflb x
two subintervals
for multiextremal
interval evaluations
interval function
lists line
iag right
minimizers in
lb c
enclosure f
return q
tiam left
rangeup test
univariate global
of multiextremal
termination rule
x stored
real range
__ f
develop more
subintervals are
a minimizer
6 fg
see lower
multiextremal univariate
bound global
information iag
__ fig
nizhni novgorod
subdivision point
between tiam
o tests
algorithm nishes
7 return
clearly shown
satised line
multiextremal test
improved all
__ g
elimination rules
analysis interval
lipschitz global
rangeup and
global search
algorithms tiam
analysis branch
lb s
g __
minimizers and
f minflb
bottom graphs
f __
inclusion functions
works almost
iag has
left hand
f 0 x
x lb x
f z x
f m x
an interval x
interval analysis global
the interval x
for f x
f x f
of f x
j a martinez
a martinez and
i garcia j
g casado i
casado i garcia
ya d sergeyev
new support functions
the working list
garcia j a
f x over
and ya d
martinez and ya
l g casado
the new support
in the working
the objective function
__ __ __
support functions are
bound of f
interval x is
using gradient information
lb x f
global minimization algorithm
tiam and iag
global optimization algorithm
cut o test
the gradtest procedure
the nal list
lb x lb
left hand graph
x is used
problem 1 1
the working and
f lb x
working list l
and nal lists
traditional interval analysis
analysis global minimization
working and nal
nal list q
lb x g
information 1 2
the iag algorithm
table 4 2
interval x the
new interval analysis
analysis global optimization
x and f
x over x
continuously dierentiable function
dierentiable function f
f x and
the new algorithm
figure 2 1
for an interval
stored in the
support functions and
z x i
lower bound f
select an interval
paper a new
new support function
of global minimizers
contain any global
4 2 shows
algorithm using gradient
m x f
z x g
the search information
minimization algorithm using
and lb x
contain global minimizers
if w x
fx f x
global optimization algorithms
the monotonicity test
if f lb
right hand graph
interval analysis support
any global minimizer
a support function
a traditional interval
bound f z
x from 2
bounds for f
evaluations of the
figures 4 1
lb x and
the gradient test
x f z
z x lb
in the nal
not contain any
value of f
and f x
of the objective
the interval v
objective function f
for global optimization
function d x
number of interval
of f 0
theorem 2 2
if the interval
if for an
a continuously dierentiable
the problem 1
x does not
function f x
f x is
figure 3 1
m x is
x 1 and
does not contain
the condition f
the global minimum
point x 2
x 2 x
be seen from
lower bound of
4 1 and
and therefore can
the new method
x can be
see for example
of tiam left
__ __ fig
a closed interval
o test is
algorithms for function
while l 6
way to calculate
global minimizers in
monotonicity test if
interval x such
the case f
develop more powerful
interval analysis branch
accelerate the search
of interval function
about the objective
and iag right
x for f
inclusion function of
bound f of
hand graph algorithms
in lipschitz global
x s f
cut o tests
interval x s
bounding rule the
and bound global
closed interval in
for multiextremal univariate
can contain global
c of f
f f v
set of multiextremal
tiam left hand
support functions using
of f m
analysis branch and
graph and iag
gradient test is
as the subdivision
interval in r
x on x
information used in
lipschitz global optimization
all intervals x
hand graph and
set to f
and its rst
line 2 and
d x from
the algorithm nishes
to develop more
test when f
f minflb x
elimination rules are
test if for
__ __ f
functions for multiextremal
of multiextremal test
graph algorithms for
functions are based
numerical comparison between
its rst derivative
presented the new
iag right hand

corpus/krapavin2000-test/637568.txt
breakpoint
inversion
genes
genomes
iebp
ede
inversions
genome
transpositions
phylogeny
grappa
distances
evolutionary
estimators
nj
phylogenetic
gene
events
score
distance
warnow
chloroplast
evolution
moret
1normalized
datasets
pairwise
bp
phylogenies
021
circular
trees
inv
inverted
joining
nadeau
transposition
061
tsp
scoring
bounding
120
campanulaceae
parsimony
rearrangements
speedup
breakpoints
rearrangement
estimator
tree
edit
dataset
reconstructing
neighbor
pruning
mitochondrial
scored
false
layered
orderings
negatives
rates
sankoff
1515normalized
bipartitions
tang
swap
chromosome
supercluster
hours
dna
plants
reversals
leaf
taylor
pruned
additive
triplet
plotted
wang
equiprobable
ordering
reconstruct
signed
scenario
rate
phylogenetics
ismb
bpanalysis
blanchette
ancient
taxa
tandy
inver
cabbage
turnip
bipartition
genomic
estimating
reconstruction
160
hundred
trend
positives
median
estimates
37
512
buckets
permutations
bins
scores
remarkably
accuracy
reconstructions
travelling
sorting
million
equally
robustness
absolute
mismatched
percentage
topological
nearly
algorithmics
fig
format
parsimonious
nonparametric
animal
exact
edge
estimate
tighten
land
leaves
underestimate
mp
edges
accurate
heuristic
efficacy
confirming
suite
probabilities
prune
likely
negative
topologically
bernard
ran
remedy
matrix
simulated
obeys
robust
consecutively
01
experimental
bounds
plots
analyses
99
instances
speedups
correlation
coordinate
plot
eliminated
np
corollary
normalized
wabi
caprara
eriksen
bluebell
254713
embraced
atteson
outgroup
pensive
13095
20709
interleaf
meetings
dcaf
worsening
systematics
iepb
mitochondria
deb
attested
logeny
biologists
vascular
tanspositions
strandedness
fruition
lucile
inversion distance
distance estimators
of evolution
pairwise inversion
of events
actual number
maximum pairwise
the breakpoint
neighbor joining
of genes
exact iebp
true evolutionary
inversion length
gene order
breakpoint phylogeny
false negative
distance actual
120 genes
inversion distances
or inversion
and inverted
negative rate
breakpoint score
of inversions
inverted transpositions
evolutionary distance
061 1normalized
iebp distance
distance relative
021 061
transpositions and
of genomes
1normalized maximum
11 021
breakpoint distance
an inversion
inversion only
and warnow
breakpoint or
37 genes
layered search
circular ordering
events actual
ede distances
distances and
absolute difference
of trees
genes 11
inv distance
true tree
genes and
moret tang
breakpoint distances
tang wang
phylogeny problem
events absolute
only scenario
evolutionary events
distance false
our distance
the tree
rates of
order data
nadeau taylor
our grappa
inversions transpositions
the nj
inversions only
taylor model
model tree
reconstructing phylogenies
nj tree
and breakpoint
tree score
relative probabilities
from gene
nj ede
tsp instances
likely events
transpositions only
the true
lower bound
the inversion
wang and
evolutionary distances
equally likely
of evolutionary
circular orderings
three estimators
genomes and
rearrangement events
topological accuracy
b transpositions
estimators as
relative breakpoint
genome rearrangements
phylogenies from
a inversions
tree space
difference actual
relative inversion
joining method
c equally
only inversions
the genome
the edit
and 120
the false
the datasets
distance based
three distance
estimators we
a breakpoint
the bp
the tsp
upper bound
of breakpoints
coordinate values
false negatives
tree t
true distance
edit distance
only c
distances are
trees that
datasets with
datasets are
maximum parsimony
remarkably robust
events inversions
many trees
bp distance
chloroplast dna
various distance
pruning rate
tree leaf
bins according
phylogenetic inference
ede distance
phylogenetic analyses
additive matrix
hundred million
the nadeau
the ede
40 genomes
normalized maximum
b inv
leaf distances
grappa software
a bp
likely number
of ede
events fig
genome rearrangement
inv distances
and ede
phylogeny and
e ede
6 hours
bp or
or inv
by reversals
genes fig
the campanulaceae
iebp is
deviation plots
1515normalized maximum
more genomes
distance estimator
that nj
software suite
nj methods
genes under
genes the
c iebp
d exact
distance b
genomes we
of nj
bound and
only b
for reconstructing
the bound
the trees
our new
inversion and
to reconstruct
distances between
distance fig
the evolutionary
events c
into bins
in reconstructing
methods under
sorting by
phylogeny reconstruction
10 20
g b
x coordinate
distance or
number of events
pairwise inversion distance
maximum pairwise inversion
actual number of
the breakpoint phylogeny
distance actual number
false negative rate
inversion distance relative
061 1normalized maximum
1normalized maximum pairwise
11 021 061
true evolutionary distance
transpositions and inverted
021 061 1normalized
events actual number
an inversion only
breakpoint or inversion
number of genes
our distance estimators
rates of evolution
of events actual
rate of evolution
genes 11 021
and inverted transpositions
distance false negative
moret tang wang
inversion only scenario
gene order data
tang wang and
number of inversions
wang and warnow
of events absolute
inversion distance false
events absolute difference
the true tree
the true evolutionary
model of evolution
nadeau taylor model
inv distance actual
from gene order
the nj tree
equally likely events
inversions transpositions and
transpositions only c
distance relative breakpoint
distance estimators we
x coordinate values
models of evolution
breakpoint phylogeny problem
only c equally
the neighbor joining
of genes and
37 genes 11
neighbor joining method
the breakpoint distance
c equally likely
of evolutionary events
number of evolutionary
inversions only b
relative inversion length
distance estimators as
relative probabilities of
number of breakpoints
b transpositions only
percentage of trees
true evolutionary distances
difference actual number
and breakpoint distances
a inversions only
phylogenies from gene
absolute difference actual
the inversion distance
relative breakpoint score
exact iebp distance
inversion and breakpoint
three distance estimators
distance relative inversion
only b transpositions
the datasets are
the actual number
let t be
the upper bound
the number of
and 120 genes
distances and three
breakpoint distance or
the relative probabilities
ede distance fig
inversion length of
true tree t
under various distance
events inversions transpositions
into bins according
the exact iebp
guaranteed to reconstruct
1515normalized maximum pairwise
events a bp
iebp distance d
of the nj
phylogenetic analyses of
80 and 160
distance estimators for
distance e ede
one hundred million
grappa software suite
numbers of genes
the nadeau taylor
number of genomes
sorting by reversals
the breakpoint or
methods under various
coordinate values the
bins according to
leaf to leaf
estimators as a
values the bp
most likely number
in our grappa
distance based methods
reconstructing phylogenies from
normalized maximum pairwise
about the model
datasets are divided
b inv distance
we presented at
bp or inv
bp distance b
likely events fig
the pruning rate
and three distance
for the breakpoint
distance d exact
events c iebp
iebp distance e
nj methods under
of trees that
circular ordering of
d exact iebp
our grappa software
divided into bins
or inv distance
evolutionary distances between
to leaf distances
c iebp distance
deviation plots for
or more genomes
a bp distance
for reconstructing phylogenies
evolutionary distance and
ede distances and
various distance estimators
of events c
e ede distance
taylor model of
of genes the
true distance estimators
distance b inv
likely number of
to their x
the bp or
37 and 120
or inversion distances
of our distance
two distances and
numbers of genomes
standard deviation plots
their x coordinate
the lower bound
lower bound and
the two distances
10 20 40
the false negative
40 80 and
appear in t
the maximum pairwise
mean and standard
the bounds we
20 40 80
the edit distance
our previous analysis
g a g
plots for the
the rate of
to reconstruct the
types of events
of events a
of our three
t be a
and standard deviation
number of false
of the bounds
of the trees
of the maximum
the most likely
of inversions per
inversion length 37
reconstruct the true
that neighbor joining
distance for 10
a new fast

corpus/krapavin2000-test/637759.txt
00
000
register
devs
trap
instruction
message
npc
alfa
msg
dest
cpu
001
regglob
cmpa
_res
students
registers
alu
05
sendoutput
window
bus
cmp
cwp
const
01
incdec
cmpb
psr
activated
pc
circuit
bits
internalmessage
unimp
dtack
device
port
byte
interrupt
r1
stb
reset
serviced
ports
coupled
store
tick
and1
and2
masmin
masmax
inc
instructions
cu
signal
organization
simulator
traps
cd
bit
transition
eth
reg
processor
address
mask
courses
decremented
comparators
issued
int
inputs
inb
passivate
outputfunction
pc_latch
bgrant
hold_in
oldb
externalmessage
_old
internalfunction
res0
0x12345678
portname
externalfunction
olda
priority
architecture
charge
clock
xor
gates
addr
dec
mem
outputs
strobe
modifiability
ina
finished
selector
sent
cycle
sparc
assembly
turned
top
multiplexers
routine
stores
circuits
delay
event
r2
incremented
atomic
transmitted
lw
linker
cen
operands
external
assembler
uc
gnu
increment
enabled
scheduled
microprocessor
chip
attacked
teaching
simulation
toolkit
internal
priv_inst
bsel
a30
out30
274543375
iack
out31
assemblers
data_acc_err
mastering
bgrantin
op0
fcod
0x01
csel1
talisman
clck
simulink
i_d
div_zero
portnum
influencees
rd_wr
irqs
addr_not_align
irq
asel
maisie
data_acc_excep
opb0
inst_acc_err
xnor
tbr
pc_inc
opa30
useing
opa31
pil
simplescalar
res3
shifter
holdin
win_over
13908050
illeg_inst
0xffffffff
traplogic
wainer
0x55555555
cclogic
data_st_err
passivates
breset
inst_acc_excep
out0
opb31
and_n_1
csel2
res4
a31
opb30
win_under
00 00
000 message
00 000
cpu 05
top 01
message y
message d
message 00
d 00
y 00
00 20
20 001
001 message
the register
to cpu
00 10
coupled model
alfa 1
computer organization
01 to
1 000
the instruction
i 00
to top
the alu
the address
message x
x 00
digital logic
root 00
01 top
the npc
control unit
message i
05 to
this model
the students
the memory
00 to
inc dec
r1 dest
sendoutput msg
msg time
return this
the trap
10 000
transition functions
in address
store the
input output
reg 1
memory image
turned on
the model
be serviced
the circuit
of reg
dec model
cmpb link
mem 02
const internalmessage
05 cpu
clock tick
the bus
32 bit
internal transition
can see
in charge
for int
the device
internal event
register window
instruction register
output ports
experimental framework
the pc
is activated
transition function
charge of
related with
model is
following figure
logic level
000 to
instruction set
trap type
cu 43
register 1
high byte
05 root
using cd
byte of
of alfa
register 4
stb r1
was enabled
chip selector
model 50
msg port
the psr
of devs
a coupled
sent through
stores the
stored in
assembly language
address of
these models
instruction cycle
the inc
boolean gates
an address
models were
the digital
is sent
log file
hardware description
the architecture
base address
32 bits
last operation
students can
model was
behavior of
is turned
register to
issued the
the models
the processor
register stores
at 00
base register
modifiability of
priority trap
trap base
the bgrant
tick in
link out
model uc
turning on
model incdec
the devs
enabled store
number received
internalmessage msg
c enable
pc_latch 11
eth line
atomic model
global registers
externalmessage msg
address strobe
internalfunction const
external event
simulated computer
outputfunction const
clock 45
y register
initial image
image addr
const externalmessage
32 i
trap to
organization courses
i eth
cwp is
to pc_latch
sparc processor
addr memory
npc to
a devs
event arrives
register number
externalfunction const
pc inc
basic behavior
model regglob
received the
the cpu
the sparc
the execution
the behavior
the chip
int i
result obtained
and architecture
each instruction
incremented or
or decremented
was issued
model definition
simulated time
execution flow
the cwp
i self
register has
according with
register 2
through the
one bit
00 00 00
00 00 000
00 000 message
d 00 00
y 00 00
message d 00
message y 00
message 00 00
000 message d
000 message 00
to cpu 05
00 00 20
00 20 001
000 message y
20 001 message
top 01 to
to top 01
00 10 000
00 00 10
10 000 message
message x 00
x 00 00
message i 00
i 00 00
000 message i
cpu 05 to
root 00 to
top 01 top
00 to top
01 top 01
sendoutput msg time
store the high
01 to cpu
the control unit
001 message y
1 in address
001 message x
reg 1 in
of reg 1
the instruction set
we can see
as we can
return this model
a coupled model
000 message x
cpu 05 cpu
digital logic level
inc dec model
1 000 to
05 cpu 05
the digital logic
can see the
in the register
in charge of
this model is
address of the
the following figure
is in charge
the register 4
of alfa 1
internal transition function
is turned on
the internal transition
stb r1 dest
the high byte
through the output
the register 1
for int i
the inc dec
store the register
the instruction register
byte of reg
cpu 05 root
an experimental framework
high byte of
05 root 00
the students can
int i 0
of the trap
input output ports
sent through the
to be serviced
the last operation
in the instruction
the result obtained
when the result
related with the
stored in the
the input output
behavior of the
the i eth
the y register
a clock tick
found in 49
const externalmessage msg
addr memory image
enabled store the
modifiability of alfa
register has changed
following figure shows
the register has
the register window
using digital logic
input was enabled
basic behavior of
to pc_latch 11
register number received
image addr memory
must be serviced
the register number
through the lines
eth line of
external event arrives
the sparc processor
the register 2
trap to be
externalfunction const externalmessage
the instruction cycle
of the sparc
computer organization courses
computer organization and
an external event
at 00 00
the basic behavior
const internalmessage msg
the execution flow
outputfunction const internalmessage
the npc to
i eth line
register stores the
the chip selector
was enabled store
000 to cpu
organization of the
the behavior of
is sent through
from the memory
last operation is
incremented or decremented
assembly language level
the assembly language
the model s
the address of
is stored in
in the address
of the address
stored in memory
the output function
as explained earlier
this model was
points to the
a 32 bit
behavior of each
is sent to
it returns the
the memory is
sent to the
model is in
i 0 i
model is used
to pc_inc 13
the circuit delay
each model was
architectural simulations on
model definition transition
and modifiability of
the alu res
the model receives
clck 1 000
in simulating a
see if cmp
a declarative multiprocessor
12 to cpu
them using digital
definition transition functions
npc to cpu
for every model
oriented simulation with
value is sent
register 4 is
the teaching of
object oriented simulation
the address 32
the bus then
issued the memory
coupled model representing
when the address
to mem 02
of the coupled
computer systems design
transmitted through the
transmit it through
times set 1
load the register
assembler and linker
001 message d
for the teaching
32 i this
enable line is
through the ports

