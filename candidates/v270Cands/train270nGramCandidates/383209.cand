scrambling
query
runnable
scrambled
joins
tuples
plan
blocked
join
unavailable
plans
operators
subtree
unscrambled
response
materialized
phase
queue
iterator
remote
selectivity
joinable
relations
delay
materialization
selectivities
sources
hash
iteration
delayed
optimizer
000
delays
queues
operator
site
arrive
materializations
materializing
c1d
seconds
joined
volcano
begun
disk
materializes
x2
ancestors
mermaid
discovered
tree
unexpected
unavailability
maximal
grey
relation
materialize
initiated
amsaleg
simulator
arrival
congestion
consume
subtrees
x3
consumer
variability
execution
sigmod
arrived
scheduling
partitioning
experiment
partitioned
database
databases
charges
unblocked
hab
a1b
gra93
paques
dskpagesize
fjk96
netbw
numdisks
trv96
c1d1e
netpagesize
leftmost
query plan
phase 2
runnable subtree
the query
phase 1
query tree
scrambled query
response time
the runnable
the scrambled
plan scrambling
query execution
scrambling algorithm
maximal runnable
scrambling is
the scrambling
query plans
query optimization
tuples of
runnable queue
query scrambling
new joins
during phase
query processing
the response
new join
unscrambled query
runnable operators
of phase
the tuples
000 tuples
the unscrambled
scrambled plans
and runnable
of scrambling
data sources
the joins
to arrive
blocked operators
iterator based
relation a
the blocked
relation b
queue of
remote sources
000 10
of scrambled
dynamic query
response times
remote data
original query
10 000
unavailable relation
a runnable
tuples from
another iteration
large memory
the selectivity
blocked queue
runnable and
of runnable
discovered to
the operators
from remote
is discovered
of blocked
be unavailable
blocked queues
scrambled plan
partitioned before
unexpected delays
query start
selectivity of
query optimizer
each iteration
blocked and
delay of
new operators
third iteration
the delay
more tuples
memory case
relations are
wide area
of tuples
and blocked
delays in
a query
materialization of
execution site
query plan scrambling
scrambled query plans
the runnable queue
maximal runnable subtree
the query tree
the response time
of the query
the scrambling algorithm
response time of
the tuples of
tuples of a
the scrambled query
remote data sources
the query plan
of phase 2
of the scrambled
the unscrambled query
blocked and runnable
during phase 1
to be partitioned
000 10 000
discovered to be
delay of a
10 000 10
queue of blocked
of blocked operators
queue of runnable
scheduling of operators
runnable and blocked
the query execution
to be unavailable
of phase 1
the original query
is discovered to
dynamic query optimization
the selectivity of
the blocked queue
begun to arrive
at the query
a runnable subtree
runnable subtree is
the scrambled plan
a maximal runnable
another iteration is
be partitioned before
the runnable and
query execution site
of the unscrambled
of runnable operators
and blocked queues
1 000 tuples
iterator based scheduling
plan scrambling is
query start up
partitioned before being
number of tuples
during phase 2
response times of
the end of
at the end
joins in the
the materialization of
the delay of
the previous experiment
delay for a
scrambled query plan
initial requested tuples
of scrambled query
runnable queue is
f and x2
times of scrambled
benefits of scrambling
normal iterator based
rooted at operator
iteration of phase
query execution plans
requested tuples from
based scheduling of
from remote sources
original query plan
and runnable queues
of query plan
of a runnable
the queue of
the memory is
start up time
selectivity of the
from remote data
the first join
by phase 2
