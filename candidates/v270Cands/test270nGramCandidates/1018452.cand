processors
log
adversary
oracle
crashes
coordinators
failures
alg
balancing
processor
synchronous
failure
prone
tasks
attended
adv
coordinator
pram
crash
message
iterative
passing
load
simulations
unattended
specic
w3
shared
phases
solves
round
omniscient
perfect
denition
alive
stop
bounds
seti
subcases
wn
ciency
shvartsman
rst
dene
teach
fault
rounds
lemma
tolerant
georgiou
chryssis
block
undone
solved
stops
progress
phase
chlebus
tids
jf
1a
extant
doall
bcc
8p
1b
fail
views
restatement
utility
dened
consensus
pid
derivative
stand
adequately
kill
expended
analyses
certified
messages
quantity
leaves
2b
surviving
byzantine
2f
lemmas
matching
w2
do all
log p
p log
p f
iterative do
log log
all o
all problem
work complexity
r do
f log
the do
prone processors
failure pattern
shared memory
f p
n f
o n
the oracle
algorithm w
algorithm an
load balancing
message passing
the work
perfect load
all n
crash prone
work w
the adversary
message complexity
log n
algorithm simulations
r log
failures f
n tasks
of algorithm
of do
n log
lower bounds
of processors
complete analysis
failure prone
for do
synchronous shared
attended phases
r iterative
all algorithm
block step
block steps
progress tree
solves do
balancing assumption
of failures
log f
n p
of work
p processors
all algorithms
an we
stop failures
of crashes
the processors
lemma 3
with work
the iterative
log b
r p
pattern f
local views
the attended
adversary adv
wn p
algorithm alg
any failure
p n
the progress
c p
that solves
when f
memory model
bounds for
passing model
failure free
write all
best known
f can
analysis of
c log
solved with
a phase
p log p
log log p
do all o
iterative do all
log p log
all o n
r do all
the do all
do all n
do all problem
log p f
p f log
p log log
of algorithm an
r p f
r r p
perfect load balancing
o n f
all n f
for do all
the iterative do
the work complexity
c p log
f log p
do all algorithms
f c p
of do all
n f can
failure prone processors
complete analysis of
p and f
log n log
log b p
f p r
for the do
solves do all
a do all
p r log
f p log
do all algorithm
b p f
load balancing assumption
crash prone processors
r iterative do
q p f
the progress tree
synchronous shared memory
the perfect load
number of failures
can be solved
the work w
the number of
number of processors
shared memory model
execution of algorithm
p lemma 5
under the perfect
all the attended
of block steps
of r do
algorithm an we
for any failure
do all is
the attended phases
f log log
of the do
n p log
log p and
log p lemma
any failure pattern
the message passing
message passing model
f can be
in any execution
n log p
any c 0
f the number
for this case
any execution of
the best known
shared memory models
attended phases and
any algorithm alg
log log f
an we have
round of r
the unattended phases
number of crashes
their local views
failure pattern f
