processors
log
adversary
oracle
crashes
coordinators
failures
alg
balancing
processor
synchronous
failure
prone
tasks
attended
adv
coordinator
pram
crash
message
iterative
passing
load
simulations
unattended
specic
w3
shared
phases
solves
round
omniscient
perfect
denition
alive
stop
bounds
seti
subcases
wn
ciency
shvartsman
rst
dene
teach
fault
rounds
lemma
tolerant
georgiou
chryssis
block
undone
solved
stops
progress
phase
chlebus
tids
jf
1a
extant
doall
bcc
8p
1b
fail
views
restatement
utility
dened
consensus
pid
derivative
stand
adequately
kill
expended
analyses
certified
messages
quantity
leaves
2b
surviving
byzantine
2f
lemmas
matching
w2
memory
pattern
tentative
existed
idempotent
2a
moderate
simulate
pr
faults
tolerating
assess
induction
impossibility
cient
iteration
iteratively
stage
2e
exceed
gathering
abstracts
establishes
task
performing
sent
fragmentable
flp
needlessly
worker
venerable
maxf1
denitive
w4
refute
pids
tings
homemyampersandmdash
fiterations
scratchpad
delphian
timeprocessor
ces
iterated
alexander
asynchronous
delays
multicast
faulty
dr
sensitive
whp
kills
crcw
unknowingly
dariusz
specics
kanellakis
minates
newest
asynchrony
rescheduling
tight
am
loads
patterns
deterministic
cooperative
loop
caused
mergeable
rolls
survives
strengthens
3p
martingale
elucidated
supercial
denitions
ideally
idling
kowalski
landscape
ticks
colleague
traversal
eect
crashed
identier
uc
omni
totally
tells
cause
sketch
partitionable
russell
gossip
347
ine
fernndez
rened
assists
simulating
proceeds
stale
identiers
dissimilar
multiplicities
dependability
do all
log p
p log
p f
iterative do
log log
all o
all problem
work complexity
r do
f log
the do
prone processors
failure pattern
shared memory
f p
n f
o n
the oracle
algorithm w
algorithm an
load balancing
message passing
the work
perfect load
all n
crash prone
work w
the adversary
message complexity
log n
algorithm simulations
r log
failures f
n tasks
of algorithm
of do
n log
lower bounds
of processors
complete analysis
failure prone
for do
synchronous shared
attended phases
r iterative
all algorithm
block step
block steps
progress tree
solves do
balancing assumption
of failures
log f
n p
of work
p processors
all algorithms
an we
stop failures
of crashes
the processors
lemma 3
with work
the iterative
log b
r p
pattern f
local views
the attended
adversary adv
wn p
algorithm alg
any failure
p n
the progress
c p
that solves
when f
memory model
bounds for
passing model
failure free
write all
best known
f can
analysis of
c log
solved with
a phase
alg that
on crash
unattended phases
processor algorithm
the unattended
phase w3
failure patterns
steps b
let do
be solved
on work
memory models
all tasks
each processor
the rst
a do
f the
f c
the failure
processors that
the perfect
p lemma
b p
u p
one coordinator
n problem
with crashes
processors perform
upper bounds
the complexity
complexity of
processors with
any execution
p and
work o
memory algorithm
failure model
new bounds
two subcases
log c
22 30
any algorithm
the message
all is
r r
we dene
the r
n processor
failures we
q p
f denote
and f
of block
work for
c 0
cases case
fail stop
matching upper
with f
simulations of
the coordinators
fail stops
coordinators and
processor steps
undone tasks
n stand
f sensitive
f stop
synchronous processors
on failure
passing algorithm
of undone
processor crashes
p crash
p failure
f problem
local view
using work
r instances
complexity w
crashes f
theorem 3
work of
is log
phases and
f when
any c
r n
the denition
n note
p r
the computation
given any
tasks and
tasks are
algorithms on
now give
during all
passing and
denition of
processors and
step i
processors in
0 f
e ciency
the synchronous
complexity arguments
cause more
all work
processors assigned
p log p
log log p
do all o
iterative do all
log p log
all o n
r do all
the do all
do all n
do all problem
log p f
p f log
p log log
of algorithm an
r p f
r r p
perfect load balancing
o n f
all n f
for do all
the iterative do
the work complexity
c p log
f log p
do all algorithms
f c p
of do all
n f can
failure prone processors
complete analysis of
p and f
log n log
log b p
f p r
for the do
solves do all
a do all
p r log
f p log
do all algorithm
b p f
load balancing assumption
crash prone processors
r iterative do
q p f
the progress tree
synchronous shared memory
the perfect load
number of failures
can be solved
the work w
the number of
number of processors
shared memory model
execution of algorithm
p lemma 5
under the perfect
all the attended
of block steps
of r do
algorithm an we
for any failure
do all is
the attended phases
f log log
of the do
n p log
log p and
log p lemma
any failure pattern
the message passing
message passing model
f can be
in any execution
n log p
any c 0
f the number
for this case
any execution of
the best known
shared memory models
attended phases and
any algorithm alg
log log f
an we have
round of r
the unattended phases
number of crashes
their local views
failure pattern f
log c 0
bounds on work
let do all
of work complexity
shared memory algorithm
work complexity of
of n p
in the progress
analysis of work
f p n
do all in
c log p
on crash prone
progress tree is
the r iterative
passing and shared
alg that solves
of failures f
algorithm alg that
therefore the work
case as o
all the unattended
that solves do
we let do
use of do
number of block
analysis of the
the work of
with work o
o n there
log p for
a unit of
be solved with
the shared memory
two cases case
the analysis of
cases case 1
n r r
analysis of algorithm
unit of work
and shared memory
in the message
during all the
upper bounds for
range of f
number of processor
log log log
r n r
leaves in the
tasks in a
of the failure
n p and
p f and
not cause more
the oracle model
adversary that causes
jf j f
algorithms on failure
of solving a
arguments on the
p failure prone
all problem in
message passing algorithm
failure pattern with
all problem that
all n problem
log p we
stop failures f
pattern with f
work complexity w
new analysis of
solved by running
algorithms on crash
on failure prone
each block step
all problem for
u log p
least one coordinator
r instances of
complexity arguments on
n f problem
case is b
bounds for do
1 f p
log n p
failure model f
p log c
new bounds for
p crash prone
f when f
all problem as
a failure pattern
of undone tasks
block steps b
o n note
on p crash
log p therefore
depends on f
n stand for
the r do
failure free processors
the failure pattern
wn p f
synchronous message passing
f stop failures
log pr f
as o u
the synchronous shared
n log log
message passing and
