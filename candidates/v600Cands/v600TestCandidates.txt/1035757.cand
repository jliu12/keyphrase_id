checkpoint
checkpoints
clock
checkpointing
forced
causal
protocol
useless
lc
cl
lamport
ckpt
netzer
sent
mostefaoui
ck
raynal
rollback
irisa
elary
message
prevention
timestamp
domino
protocols
array
enddo
manivannan
mcj
induced
delivery
8k
pk
timestamps
recovery
s2
reception
consistent
iff
s1
determination
clocks
orphan
receives
unstable
detection
p4
p6
sending
send
cycle
snapshots
deliver
messages
manages
event
singhal
breakpoints
predicates
communication
predicate
p5
managed
quasi
processes
hlary
trackability
mck
docase
ik
contradicts
sends
computations
ffl
min
initialization
booleans
piggyback
piggybacks
oe
false
boolean
synchronous
path
events
received
paths
z
piggybacking
p8
timestamped
timestamping
breakpoint
prevent
precedes
brought
depicted
tocol
russell
directs
coordination
remind
safe
pattern
mobile
family
xu
arrays
sender
save
michel
coordinated
endif
stable
arrives
25th
p3
max
belongs
delta
happened
synchronize
appended
inconsistent
delivering
conjunctions
enddocase
manitoba
emmanuelle
jichiang
leen
zcf
piggybacked
anceaume
vitenberg
coasting
netxer
agbaria
erlier
redrawn
rdt
gyung
winnipeg
cycles
interval
invariant
asynchronous
fc
indicated
previuosly
incrementation
russel
subcondition
attiya
intial
764
executes
formation
reset
updates
snapshot
tradeoff
statements
concatenation
propagation
arriving
meaning
pointing
classical
p1
adnan
occurences
youn
tsai
withdrawn
appends
sharpening
hagit
characterizes
proves
simplications
genericity
hee
fourteenth
s0
examine
logical
arrival
plications
directing
p7
hypothesis
channels
roy
encompasses
consequently
past
passing
755
luo
z path
local checkpoint
local checkpoints
checkpoint is
clock i
p i
causal z
forced checkpoints
i x
communication induced
global checkpoint
forced checkpoint
a checkpoint
to i
i k
c i
induced checkpointing
take checkpoint
checkpoint c
consistent global
k z
useless checkpoints
cl i
c k
checkpoints in
z cycle
m clock
sent to
distributed computations
the protocol
a z
global checkpoints
checkpointing protocols
min to
a forced
z pattern
process p
message m
prevention of
based prevention
communication based
z paths
taken i
m raynal
a mostefaoui
lc i
each process
a causal
in distributed
clock j
r netzer
irisa communication
h elary
mostefaoui r
netzer m
checkpoints and
elary a
ck z
of useless
by p
m 1
a message
local state
condition c
checkpointing protocol
array clock
ckpt i
checkpoints are
basic checkpoints
p k
j m
proposed protocol
c j
j y
lamport clock
procedure take
last checkpoint
checkpoint the
p j
i i
m h
detection of
the z
of forced
of local
control information
send m
boolean array
is useless
taken by
checkpoints is
checkpoints to
quasi synchronous
checkpoint when
to pk
8k do
sent i
to c
x 1
take a
receives m
of lc
rollback recovery
to p
a consistent
checkpoint of
non causal
a local
z t
protocol is
from c
between c
state oe
local clock
no local
this protocol
oe i
have c
determination of
1 n
array sent
checkpoint taken
lamport clocks
checkpoints the
checkpoint to
path m
as sent
z cycles
checkpoint forced
checkpoints c
m sent
max ck
checkpoint sends
clock lc
greater i
of checkpoints
after s1
c 1
is received
from p
a process
holds after
to take
m 2
unstable properties
clock k
2 sent
m lc
i 1
the array
it follows
sent by
i to
after c
useless the
current local
sends a
the delivery
pattern m
before c
when m
follows that
path from
of stable
distributed computation
m 0
checkpoints taken
if sent
checkpoint interval
checkpoint between
domino free
case clock
lamport timestamp
false enddo
basic checkpoint
do sent
free communication
array greater
no checkpoint
control variables
useless checkpoint
safe strategy
the lamport
or forced
first checkpoint
hypothesis ffl
no z
checkpoints that
rollback propagation
prevent useless
get max
basic or
i has
k has
at p
i false
data structures
lamport s
protocol the
of m
c i x
sent to i
to i k
c k z
communication induced checkpointing
causal z path
i x 1
min to i
a forced checkpoint
a local checkpoint
consistent global checkpoint
cl i k
c j y
local checkpoint c
process p i
induced checkpointing protocols
clock i i
of useless checkpoints
of local checkpoints
useless checkpoints in
a causal z
i 1 n
in distributed computations
by p i
checkpoint c i
checkpoints in distributed
prevention of useless
a z path
communication based prevention
based prevention of
take a forced
h elary a
m h elary
z path from
a mostefaoui r
m clock j
netzer m raynal
mostefaoui r netzer
irisa communication based
r netzer m
elary a mostefaoui
j m h
a consistent global
p i to
consistent global checkpoints
array clock i
the proposed protocol
a z cycle
number of forced
k z t
of the protocol
i x and
of forced checkpoints
induced checkpointing protocol
local checkpoint is
procedure take checkpoint
a z pattern
to p k
to take a
to i 1
p i has
when m 1
checkpoint is a
each process p
to c i
detection of stable
sent by p
state oe i
no local checkpoint
the z path
forced checkpoints to
take checkpoint is
path from c
checkpoint is useless
checkpoint is taken
i k has
between c i
forced checkpoint when
set of local
from p j
i k is
to p i
a message m
taken by p
sends a message
x and c
is a z
by p j
at p i
and c i
when it receives
message m sent
take a checkpoint
as sent to
a global checkpoint
oe i s
i to take
save the current
take checkpoint sends
checkpoint forced checkpoint
the z pattern
checkpoint of p
clock i k
message to pk
non causal z
z path m
m clock k
z pattern m
z path is
checkpoints to ensure
causal z paths
checkpoint taken by
checkpoints are taken
is a causal
checkpoint sends a
j m clock
then take checkpoint
take checkpoint forced
a boolean array
global checkpoint is
array sent to
m sent by
local state oe
it follows that
we have c
of p k
condition c 1
current local state
clock i is
1 is received
the current local
has to take
a distributed computation
contradicts the hypothesis
of a consistent
described in figure
m 1 is
receives a message
i i x
c i 2
is received by
the delivery of
c k 2
when p i
checkpoint between c
have cl i
a basic checkpoint
after c i
global checkpoint to
the last checkpoint
oe i 0
determination of consistent
checkpointing protocol that
a checkpoint between
i i false
when it sends
p i between
ffl when it
clock j m
taken a checkpoint
m 1 t
taken i i
local state with
m 2 sent
local checkpoints are
forced checkpoints are
we get max
z path that
condition c 0
z ck z
a communication induced
b h is
ffl case clock
for consistent global
local checkpoints is
known by p
the first checkpoint
to prevent useless
prevent useless checkpoints
domino free communication
i between c
free communication induced
distributed computations a
clock lc i
of communication induced
checkpoint to which
takes a basic
checkpoint when it
checkpoints c i
value of lc
array greater i
from c j
brought to p
boolean array greater
the local checkpoint
t cl i
the array clock
a useless checkpoint
of basic checkpoints
the hypothesis ffl
