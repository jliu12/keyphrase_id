primitive
garbage
symbolic
milliseconds
calculated
reversal
conditionals
cache
2001000
500500
me
ecient
optimizations
recursions
4004000
1002000
40400
nontermination
inputs
eciently
sort
heap
eects
cbleast
2003001
10200
transformations
91
accurate
bounds
1000
unknown
chez
alpa
20100
501501
insertion
2000
underestimation
ca
programs
measured
loops
yanhong
500
accurately
93
symbolically
worst
allocated
merge
200
automatic
append
rosendahl
251000
16008000
160800
cleast
car
else
transformation
program
partially
summations
analyses
constructor
cons
paths
300
lifting
constructors
disabled
timing
enabled
loop
compiler
inx
synthesizer
language
sums
conditional
inlining
languages
1001
branches
arguments
dierent
measurements
pipelining
bindings
92
incremental
97
terminate
counts
recursive
251001
xxxxxx
90600
4004001
2003000
ibonacci
8006001
501500
vcbleast
incrementalization
19953
125250
1002001
1999000
varref
499500
4000000
167mhz
40401
rst
depths
simplifying
440
analyzing
instruction
functional
inability
calls
bytes
liu
46
transformed
89
2600
stony
sunysb
20301
brook
recurses
conservatively
live
dicult
source
merging
50
subcomputation
ssl
lub
631
stoller
1000000
86
binding
union
37
lisp
measuring
85
optimizing
64mb
670
inecient
16000
structs
ultra
annotations
collection
terminates
96
cdr
app
40000
nonrecursive
95
meant
inaccurate
632
87
branch
conservative
41
optimized
sorting
94
evaluator
400
220
microseconds
1600
syntax
automatically
tried
calculate
caching
accuracy
88
constructs
accommodate
schema
53
n00014
nil
8000
cost bound
primitive cost
bound function
cost parameters
symbolic evaluation
bound functions
cost bounds
input size
bound analysis
known input
calculated time
partially known
garbage collection
me ca
the cost
calculated measured
time milliseconds
measured me
milliseconds input
size parameters
input structures
with cache
heap space
insertion sort
accurate cost
ca calculated
measured worst
original program
loop bounds
the calculated
execution paths
worst case
collection times
cache enabled
list reversal
selection sort
cost function
if else
the symbolic
language based
direct evaluation
set union
in if
reversal w
collection time
sort calculated
space bounds
direct symbolic
time bound
of primitive
merge sort
partial evaluation
cost parameter
allocated for
the source
inputs of
of cost
case times
union list
measuring primitive
sort selection
merging paths
for constructors
symbolic direct
cache disabled
eciently and
evaluation takes
source program
cost analysis
the analysis
variable reference
for time
automatic and
or execution
incremental computation
and accurately
and optimizations
analysis for
time analysis
closed forms
automatically and
and transformation
function calls
on inputs
and measured
else if
v then
resulting function
ca 50
size calculated
constructing cost
simplifying conditionals
46 37
lifting conditions
chez scheme
approximate time
reversal reversal
w append
include garbage
if v
constructors in
cost functions
yanhong a
a liu
measured time
primitive operation
sort merge
as arguments
actual running
or approximately
each constructor
and accurate
the heap
example programs
bounds or
for inputs
more ecient
or space
given values
and techniques
parameters and
evaluation and
programs on
our method
not terminate
input structure
of sizes
program analysis
then e
function terminates
dierent operations
small inputs
sort set
synthesizer generator
system alpa
size insertion
36 28
paths automatically
97 4
value unknown
recursion depths
bytes allocated
accurate conservative
1001 500500
optimized symbolic
50 26
input sizes
else e
conservatively or
2001 2001000
bounds automatically
cache eects
recursions or
the synthesizer
measured conservatively
level languages
source level
language level
language implementation
these transformations
more accurate
of experiments
complexity analysis
for analyzing
and transformations
source programs
each primitive
transformations are
source language
13 19
and primitive
a cost
analyses and
case execution
on input
and space
of size
recursive function
conditionals and
and scheme
on unknown
resulting cost
symbol c
algorithm analysis
conservative or
ecient and
car x
space allocated
when inputs
28 14
sizes 10
this transformation
e 1
analysis with
analysis results
optimizations to
calculated and
of input
the measured
inputs are
cost bound function
primitive cost parameters
the cost bound
cost bound functions
partially known input
input size parameters
milliseconds input size
calculated measured me
measured me ca
time milliseconds input
known input structures
the symbolic evaluation
of primitive cost
calculated time milliseconds
cost bound analysis
me ca calculated
in if else
ca calculated measured
if v then
if else if
measured worst case
the original program
else if v
with cache enabled
garbage collection times
primitive cost parameter
time bound analysis
accurate cost bound
of cost bound
or execution paths
and measured worst
sort calculated time
garbage collection time
the source program
on inputs of
of input size
worst case times
methods and techniques
symbolic evaluation of
the cost function
analysis and transformation
direct symbolic direct
insertion sort selection
v then e
symbolic direct symbolic
language based approach
sort merge sort
analysis with cache
inputs of sizes
measuring primitive cost
with cache disabled
for time bound
set union list
size parameters and
bound analysis with
selection sort merge
sort selection sort
allocated for constructors
for constructors in
union list reversal
of the cost
on the heap
the calculated time
reversal w append
inputs of size
bound functions in
calculated and measured
source language level
the language implementation
bounds or execution
values of input
list reversal reversal
a cost bound
cost parameters for
and primitive cost
size calculated measured
include garbage collection
reversal reversal w
loop bounds or
bound function for
me ca 50
at the source
constructors in the
yanhong a liu
the heap space
input of size
time or space
a language based
on the language
high level languages
the source language
dierent operations performed
cost parameters and
2 end in
the primitive cost
execution paths automatically
conservative or approximate
the cost bounds
allocated for each
the synthesizer generator
3 13 19
prototype system alpa
10 to 2000
space allocated for
of dierent operations
optimized symbolic evaluation
subset of scheme
the resulting function
in algorithm analysis
accurate cost bounds
1 else e
for time analysis
approximate time or
fully automatic and
13 19 21
e 2 end
automatic and accurate
heap space allocated
on small inputs
paths automatically and
sort set union
inputs are very
cache disabled the
merge sort set
conservatively or approximately
up the symbolic
consists of transformations
given values of
measured conservatively or
e 1 else
machine with cache
or approximate time
programs on inputs
accurate conservative or
for a machine
known input structure
might not terminate
then e 1
symbolic evaluation takes
values of primitive
of bytes allocated
cost parameters as
or space bounds
more accurate cost
sizes 10 to
automatically and accurately
and space bounds
and accurate cost
bytes allocated for
of sizes 10
be measured conservatively
else e 2
evaluation and optimizations
symbolic evaluation and
size insertion sort
eciently and accurately
worst case execution
the cost of
in the cost
the resulting cost
the source programs
terms of primitive
when inputs are
of experiments for
language implementation or
the measured time
analyses and transformations
bound analysis for
for inputs of
evaluation of cost
for each constructor
time and space
bounds on the
takes as arguments
in the programs
be obtained based
for high level
evaluation of the
the worst case
on input of
program analysis and
a future work
speed up the
obtained based on
number of experiments
a machine with
are very small
number of bytes
cost of the
of the analysis
a sun ultra
running time and
in terms of
have been studied
based approach for
a cost function
the numbers in
we use function
as 67 higher
to 2000 these
