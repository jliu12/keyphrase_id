ys
dag
explicitation
grammar
xs
grammars
cons
nil
denition
ura
iscons
dags
driving
eh
generalisations
ow
inversion
supercompilation
gluck
inverting
rewrites
checker
speculative
refal
soundness
termination
nite
productions
isnil
redex
production
unfolding
dened
deforestation
false
t1
xs7
generalisation
specialised
metacomputation
abramov
roots
predecessors
append
tree
ar
srensen
successors
hinders
redexes
substitution
rewritten
inference
semantics
6if
arrowcheck
normalise
6k1
fsame
ysg
typechecker
maxmatch
romanenko
ys7
instantiation
unfolded
t2
exp
sound
label
decomposed
x1
siau
fan
extracted
leaves
xy
innite
cf
branch
accumulated
outermost
drive
normalised
lab
vs
dene
leaf
rst
imagine
same xs
xs ys
dag grammar
process tree
dag grammars
a dag
the explicitation
the grammar
ys x
cons x
program inversion
iscons ys
the dag
ys false
explicitation of
x xs
object program
term t
ys cons
explicitation process
nil cons
the ura
the program
negative information
a program
control ow
f same
a term
tree grammars
inverting a
a grammar
by driving
cons x1
cons cons
x cons
vs nil
cons iscons
uniquely decomposed
ar x
7 cons
the object
a production
type inference
type checker
a nite
driving the
grammars to
size change
for inverting
nil nil
input set
x y
object language
of terms
terms that
dags over
nil ys
function denition
dag language
accumulated grammar
in refal
x xs7
isnil ys
eh f
resolving algorithm
false same
ys isnil
comparison will
xy same
ys same
cons v
universal resolving
ys 7
y z
a redex
grammar the
grammar that
a process
be rewritten
seen before
and predecessors
cf def
xs 7
dags d
non termination
a type
program p
grammar and
functional programs
grammar from
same xs ys
a dag grammar
a process tree
iscons ys x
the process tree
and control ow
xs ys false
the object program
f same xs
ys x xs
context and a
cons iscons ys
cons x cons
explicitation of the
ys cons iscons
7 cons x1
into a context
the explicitation process
in the grammar
be uniquely decomposed
data and control
a context and
the input set
x y z
given a program
xs ys isnil
the comparison will
nil ys 7
of dag grammars
false same xs
xs ys cons
process tree is
if xy same
universal resolving algorithm
xy same xs
eh f same
the universal resolving
and a redex
ys same xs
of the explicitation
ys isnil ys
the accumulated grammar
f if xy
the dag grammars
ys x xs7
t we denote
dags d and
successors and predecessors
z v w
given a dag
uniquely decomposed into
the data ow
y z v
as it were
of the input
a program p
can be uniquely
decomposed into a
can be rewritten
be rewritten into
of the program
the type checker
a program that
d and e
term t is
by means of
of terms that
extracted from a
the ura would
produce a grammar
order of successors
y z xz
x cons cons
tree grammars to
dag grammars which
the specialised typechecker
true same xs
imagine a program
xs g f
otherwise not obvious
not new for
given output the
cons x1 nil
ysg eh f
driven any further
drive the object
inversion and metacomputation
normal order semantics
grammars is not
cons x1 cons
