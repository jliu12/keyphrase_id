monoid
comprehension
oodb
query
phi
calculus
comprehensions
object
oid
transformer
denotational
oql
monoids
destructive
updates
database
res
salary
queries
hotel
db
idempotent
normalization
qualifier
employees
hotels
optimizer
commutative
semantics
primitives
unnesting
6g
binding
store
s14
obj
ext
s13
phif
lookup
referential
destructively
transformers
identity
s1
threaded
50000
fst
snd
s0
person
materialized
fm95b
oho90
fm98
languages
bags
optimizing
oriented
propagates
transparency
effects
constructs
ref
employee
int
translated
n4
nested
maintenance
transformation
arlington
monads
bed
returns
rule
translation
s15
ffnew
rea89
s17
sch85
threadedness
fm95a
revelation
ld92
declarative
update
relational
equivalences
name
e2
rules
e1
pure
functional
accumulator
earning
fegaras
unnest
oodbs
optimization
extensions
cities
odmg
s16
imperative
void
capture
impure
binds
interpretations
expressing
modifies
keying
algebra
extent
maier
comprehending
ae
flattens
language
commutativity
programs
syntax
objects
propagated
raise
formal
predicate
generator
num
inefficient
booleans
gt
captures
canonical
f1
equalities
n3
assign
rooms
cardinality
primitive
loop
meaning
proposals
reconstructs
f3
inefficiencies
mapped
equational
merge
counter
collection
fxg
handling
facilities
persistence
manipulate
proving
translating
creates
iterate
valid
bindings
encapsulation
importantly
gg
9811525
pj87
col89
ow92
ckl97
cm95a
feg97
totpay
wad90
ffgg
wad92
suchthat
ff1
km90
monotype
pau91
ag89
feg98
abover
bls
emptystore
gm95
dgk
cat94
cd92
irrefutable
cm95b
semantic
algebraic
expression
captured
the monoid
monoid comprehension
monoid calculus
object identity
the state
query optimization
state transformer
the object
side effects
object store
monoid phi
denotational semantics
of type
comprehension calculus
type t
destructive updates
state transformation
z phi
object oriented
a monoid
database updates
object updates
normalization algorithm
e salary
oodb query
comprehension is
store n
state monoid
phi is
object queries
object extensions
the normalization
u db
object monoid
transformation monoid
effective calculus
oodb queries
monoid comprehensions
oriented queries
object primitives
oql query
oodb languages
resulting programs
view maintenance
a state
the binding
obj t
in denotational
single threaded
state is
type s
if phi
referential transparency
state transformers
semantics of
of object
path u
p path
the optimizer
formal meaning
assign res
c hotels
the oid
res 0
a comprehension
database state
state s
the database
the comprehension
type obj
object query
binding list
database programming
optimizing object
binding from
our framework
the denotational
is translated
new object
u phi
and returns
propagates the
declarative query
mapped into
and query
translated into
the semantics
global array
phi to
query languages
this monoid
of employees
merge function
s13 in
realistic oodb
ext t
o query
update primitives
g s0
using denotational
of monoids
available oid
query unnesting
r bed
access e
loop iterate
max res
qualifier path
meaningful query
access n
state modification
comprehension which
project access
collection monoid
rule s14
to capture
that way
materialized view
phi z
entire database
meaning to
even though
each employee
nested relational
res max
do meaningful
set cardinality
salary 50000
handling object
list ae
query processing
r g
calculus for
object bases
proposals on
maintenance problem
store l
qualifier is
representing object
a program
an effective
input state
view f
with updates
returns the
ae v
in object
this query
identity and
any place
x phi
a query
queries with
query select
new 1
framework for
t theta
phi t
the accumulator
our state
j r
v s
the view
is mapped
store can
the store
optimization framework
that captures
l n
our object
minimal changes
e j
though this
on query
functional programming
all operations
modifies the
any type
for optimizing
updates can
with side
oriented databases
identity in
f v
to unnest
comprehension over
new materialized
program equivalences
int 100
transparency which
or commutative
unnecessary state
f res
which propagates
salary 1
fm98 fm95b
of destructive
existing optimization
comprehension f
functional database
the object store
the monoid calculus
monoid comprehension calculus
of type t
the monoid comprehension
the state is
the normalization algorithm
of object identity
the state transformer
the resulting programs
object monoid calculus
the object monoid
the object extensions
the monoid phi
an effective calculus
object oriented queries
if phi is
is translated into
denotational semantics of
the denotational semantics
of the object
f u db
phi z phi
a formal meaning
the object primitives
propagates the state
state transformation monoid
a monoid comprehension
formal meaning to
a state transformer
into the monoid
oodb query optimization
state monoid comprehension
j r g
of type s
e j r
object identity and
of the monoid
f v s
is mapped into
and query optimization
a new object
the semantics of
query optimization in
project access e
to the monoid
representing object identity
optimizing object queries
meaningful query optimization
using denotational semantics
the binding from
for handling object
resulting programs can
binding list ae
qualifier path u
the merge function
res max res
object store l
object queries using
without the object
type obj t
phi is commutative
oql query select
monoid phi z
at any place
using an effective
access e salary
e salary 50000
the binding list
on query optimization
do meaningful query
a state monoid
s13 in figure
queries using an
object identity in
us to do
semantics of the
the state transformation
view maintenance problem
destructive updates to
in object bases
of type obj
framework for handling
in r do
database updates and
in denotational semantics
to do meaningful
phi is a
mapped into the
even though this
f 2 g
is single threaded
the state of
give a formal
the state from
ff 1 f
with side effects
the view maintenance
with minimal changes
the global array
is a collection
is of type
for example the
of the normalization
of functional programming
defined as follows
a state s
store can be
values of type
function that takes
to capture all
into the following
type t is
translated into the
the entire database
of any type
state s of
object oriented databases
when the state
of the update
1 f 2
to the state
and more importantly
8 raise to
the new materialized
oid of the
bases using access
to all employees
over the monoid
satisfy x phi
transformer phi t
real object oriented
oriented comprehension is
path expressions into
res 0 loop
the oid of
ref int 100
example the previous
qualifier is a
capture database updates
the leftmost qualifier
monoid comprehension over
design of persistence
which the leftmost
path u j
following o query
next available oid
in denotational specifications
the generator domain
optimization for nested
our object oriented
salary 1 08
fm98 fm95b fm95a
ff 2 f
object extensions the
database updates can
advanced query processing
non single threaded
through all operations
state monoid comprehensions
executes the statements
access n e
type t theta
to optimizing loops
monoid phi for
plus access n
on oodb query
object identity using
s14 in figure
handling object updates
0 loop iterate
are captured as
state that way
state transformer that
leftmost qualifier is
comprehension in which
programming language o
reached by path
raise to all
normalization and query
phif e j
that perform side
monoid which is
query optimization but
denotational semantics approach
for optimizing oodb
multiple view maintenance
object with state
for physical oodb
rule s13 in
of persistence and
s f v
features often supported
sets and bags
persistence and query
an 8 raise
monoid comprehension is
best one at
extending functional database
bed num 3
