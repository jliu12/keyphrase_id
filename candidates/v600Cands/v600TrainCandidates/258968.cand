specialisation
mlet
specialiser
residual
static
monad
specialise
runm
interpreter
void
e1
ref
references
specialising
specialised
lift
metalanguage
e2
store
typed
eval
monadic
ml
moggi
specialises
env
num
specialization
erasure
constructor
interpreters
evaluators
imperative
calculus
int
lambda
rules
evaluator
contents
poly
univ
hughes
unification
formedness
binding
specialisations
specializer
autoprojection
languages
spec
quasimonad
dummy
eraser
dussart
closure
delimiters
reference
thiemann
statically
effects
constructors
tuple
s3
simplifications
polyvariant
monads
tags
offline
laws
algol
redexes
language
lazy
vl
unfolded
fun
meta
ole
isomorphisms
prompts
functional
updatable
arms
constructs
awkward
untagging
3es
typedness
monovariant
schism
typing
syntax
closures
programs
expressions
s0
hatcliff
laziness
partial
recursive
symbolic
chalmers
self
inference
thread
judgements
interpreted
e3
primer
pure
online
dereference
simplication
semantics
propagate
post
sums
erased
freely
automatic
inspected
prompt
postprocessing
computations
stores
unfold
modify
dynamic
haskell
rf
threads
oe
embodies
suspended
optimally
pass
tagging
tells
propagated
discards
hvl
speciali
uninitialised
tofte
specialisaton
interpet
bechet
specialisers
liberality
dexes
liftv
iino
firstifying
poy
hagiya
pseudomonads
beforehand
escape
tuples
assignment
deferred
modular
law
arity
simplification
style
passing
communicated
grams
annotations
swadi
kedar
kiselyov
soluble
specialisa
raiser
glossed
feat
launchbury
heine
formers
postprocessor
blunt
ads
ceptions
assigned
created
discipline
checker
wanting
carded
pasalic
polyvariance
memoized
mads
emir
constrast
afterwards
universal
sept
residual type
type specialisation
partial evaluation
static store
the residual
specialisation rules
residual types
in mlet
the specialiser
the static
optimal specialisation
static state
specialisation for
the specialisation
the monad
void erasure
mlet x
residual program
specialisation is
static references
to specialise
self interpreter
on references
eval env
during specialisation
mlet r
residual programs
rules for
r ref
be specialised
a static
the store
type specialiser
moggi s
specialisation time
class references
oe ml
interpreter for
static information
e2 in
lambda calculus
at specialisation
static part
specialisation of
a dynamic
mlet z
case eval
computation type
runm e
dynamic function
imperative languages
partial evaluators
static reference
dynamic references
partial evaluator
binding time
residual term
num int
specialises to
dynamic part
e1 in
static sum
static function
empty static
computational metalanguage
specialiser is
and mlet
computational lambda
with effects
specialisation in
operations on
evaluation order
a computation
static values
the type
two level
monad laws
dynamic state
of type
the interpreter
meta language
specialised to
a specialisation
first class
ref 2
in residual
the dynamic
specialising a
of void
standard partial
num lift
dynamic functions
store passing
specialiser to
specialise the
the interpreted
this specialiser
formedness conditions
sum type
type m
s computational
of case
same static
with first
static and
well formedness
of imperative
symbolic values
monadic operations
type tags
reference operations
constructor specialisation
dynamic store
an interpreter
in j
the monadic
calculus with
type ref
different static
post processor
we specialise
residual code
languages automatic
run time
references are
interpreter to
automatic autoprojection
autoprojection of
well typed
for static
dynamic reference
functional languages
time analysis
the lift
be dynamic
dynamic let
env e1
residual computations
mlet v
specialiser which
specialisation to
specialise a
lazy interpreter
metalanguage with
explicit store
evaluators for
mlet y
propagate static
second monad
store prompts
poly e
lift 2
for runm
dussart and
and thiemann
env e
constructor specialization
static stores
void eraser
a residual
higher order
type inference
and dynamic
interpreter is
be assigned
a reference
recursive equations
achieve optimal
our specialiser
dummy value
in hughes
universal type
order explicit
interpreted language
static computations
spec e
specialisation and
x e1
a monad
of moggi
e1 e2
strongly typed
type of
references in
a self
a tuple
online partial
different residual
dynamic the
that e1
this interpreter
for imperative
int the
arms of
local references
in e2
type 3
dynamic conditional
that type
represent values
the residual type
the static store
specialisation rules for
residual type of
the residual program
mlet r ref
the specialisation rules
type specialisation is
at specialisation time
operations on references
first class references
the type specialiser
rules for static
with first class
self interpreter for
a self interpreter
the static state
partial evaluation of
moggi s computational
2 in mlet
computational lambda calculus
type specialisation for
case eval env
specialisation for a
of case eval
in the residual
binding time analysis
of the static
a dynamic function
empty static store
achieve optimal specialisation
in mlet z
be specialised to
a static sum
well formedness conditions
in residual programs
j and mlet
static sum type
a computation type
for oe ml
same static part
the residual types
a static function
residual type 3
in mlet x
the residual term
the same static
of a dynamic
e 0 figure
the dynamic store
of the store
static and dynamic
for partial evaluation
partial evaluation and
partial evaluation is
automatic autoprojection of
lambda calculus with
of type ref
lift 2 in
e2 in j
interpreter to a
rules for store
optimal specialisation for
eval env e1
specialises to a
a dynamic state
references are created
the interpreted language
r ref 2
mlet z r
3 in r
mlet x e1
calculus with first
e of case
values in partial
interpreter for oe
explicit store passing
that type specialisation
to specialise a
e1 in mlet
partial evaluators for
the void eraser
store is known
different residual types
evaluation of imperative
standard partial evaluation
ref 2 in
propagate static information
evaluation order explicit
in mlet v
part which we
s computational metalanguage
dussart and thiemann
of moggi s
of type specialisation
the monadic operations
for runm e
of imperative languages
only be specialised
eval env e
in e 0
an interpreter for
the rules for
rules for the
a static reference
a dynamic conditional
x e1 in
a static state
static information about
dynamic part of
the residual programs
with different residual
residual programs we
the residual code
specialisation of a
the dynamic part
the monad laws
the result of
of the monad
references in the
of a static
languages automatic autoprojection
to partial evaluation
the arms of
in figure the
a tuple of
in partial evaluation
interpreter for a
type of the
types of the
the interpreter is
to achieve optimal
typed lambda calculus
a partial evaluator
of the contents
to a term
operations on the
a lazy interpreter
constructs the residual
3 int the
computation may modify
static references are
we can specialise
dynamic the specialisation
must write mlet
reference can hold
static operations on
on references at
mlet v in
for static references
of void type
static store in
env e1 of
static references we
store passing style
residual type records
when we specialise
we specialise this
while visiting chalmers
a dynamic let
s0 in e
rules for dynamic
the specialiser by
apply this specialiser
env e2 in
with computational effects
specialiser which is
we must write
of value it
the type specializer
type specialisation to
value encoding using
able to specialise
mlet z e1
partial evaluation where
type tags would
residual types of
e1 e2 in
oe ml that
residual types 1
a store prompt
ref e in
computational metalanguage ml
residual terms for
encoding using alternative
decisions are taken
rule for runm
ff conversion the
alternative values in
using alternative values
types at different
type specialisation can
static reference with
arms of a
to ff conversion
imperative operations in
types we could
for example specialising
aspects of specialization
typed self applicable
