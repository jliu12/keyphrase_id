specificational
bunkenburg
axiom
extensionality
propers
refinement
axiomatization
axioms
sqrt
proper
morris
monotone
anomalies
skolem
flat
properness
abstractions
2x
calculus
8x
improper
upclosed
cip
refinements
lo
equivalence
ss
ffl
mon
city
axiomatize
foo
xny
hehner
prescriptive
postulate
expressions
postulating
laws
liberal
booleans
larsen
hilbert
monotonicity
axiomatizing
fij
specifications
abstraction
foul
leastwrt
partsch
outcomes
hansen
inconsistency
bottom
logic
denotational
anomaly
deduce
recursive
compromises
language
cube
propositions
distributes
9f
recursion
instantiation
unfold
calculi
outcome
vdm
ap
fixpoint
strict
distributive
termination
1998b
totality
instantiating
extensional
programmer
player
abbreviate
eiffel
semantics
norvell
axm
hers
gameplayer
calculationally
angelic
jfalse
goodplayers
interpretations
fst
interpreted
don
9x
familiar
expression
antisymmetric
specification
arguments
functional
fflp
unresolvable
2u3
gamma2
body
fn
iff
promises
customer
sqr
nondeterminacy
destructor
fflx
imperative
clutter
assertion
axiomatic
ward
transitive
refined
f2g
demonic
accommodate
exotic
myriad
interpretation
phone
founded
else
shall
fig
axiomatized
delta
quantifications
smyth
conservative
infer
brand
superset
constituents
traditional
hi
elusive
occasions
tempted
languages
bodies
t0
pretty
proc
equality
lookup
thm
cities
asserting
integers
weakest
readers
game
algebra
ae
reasoning
distribute
constructs
stepwise
embodied
seriously
predicate
boolean
dijkstra
players
ruled
6j
quantifiers
letters
gammax
tn
connectives
1989
abbreviation
universally
annotate
3g
pg
operandi
ffl8x
practioner
quandary
1u2
oller
ridding
xnf
fiv
bicarregui
phonenumber
specificational functions
ffl e
x ffl
t ffl
m morris
morris and
a bunkenburg
ffl x
proper functions
functions delta
flat types
type t
z ffl
is proper
axiomatization of
function types
ffl f
the anomalies
and choice
pair types
over choice
u 3
are proper
v f
e v
function application
2x t
ss 1
refinement calculus
of functions
bottom and
2 u
f ffl
traditional functions
proper for
8x t
t u
every expression
axioms for
of type
recursive function
larsen and
non flat
ffl 2
base types
the liberal
hilbert s
x t
a refinement
x z
refinement calculi
e xny
of specificational
skolem axiom
expression e
an axiomatization
distributes over
functions are
2 else
and hansen
non monotone
the language
refinement and
and extensionality
cip l
that refinement
the axioms
abstractions are
is interpreted
j x
laws of
monotone in
the skolem
the axiomatization
types are
proper or
that function
and refinement
3 u
letters for
else 1
the integers
e u
f we
assertion expressions
environment ae
refinements other
strong equality
applying sqrt
2x z
abstractions x
proper refinements
hansen 1996
and bunkenburg
sqrt to
9x t
partsch 1990
for specificational
improper and
prescriptive expressions
proper x
hehner 1993
flat type
propers u
foul of
determine foo
liberal view
considered proper
in 2x
proper iff
we axiomatize
foo v
proper function
by extensionality
e is
e j
a denotational
choice and
for proper
recursive functions
strict and
choice in
function f
and equivalence
promises the
monotonicity requirement
ffl operator
anomalies of
underlying logic
by postulating
lo lo
all abstractions
choice over
types only
refinements of
for reasoning
each type
f is
an element
sqrt is
distribute over
of sqrt
even x
fn f
monotone mapping
don t
the axiom
body of
interpreted by
axioms of
else 3
f fn
refinement is
language constructs
deduce that
in programming
on flat
choice are
proper the
abstraction x
v x
we shall
the booleans
than itself
postulate that
a abstraction
u 6
is refined
two axioms
equivalence are
and distributive
not monotone
all proper
outcomes of
can deduce
refined by
may yield
interpretations of
base type
functions and
the logic
of base
element of
functions that
functions is
equivalent by
on functions
partial functions
j m
refinement we
axiom is
if even
a function
the function
application is
the argument
of axioms
shall see
functions we
possible outcomes
x ffl e
specificational functions delta
x t ffl
m morris and
t ffl e
morris and a
and a bunkenburg
x z ffl
x ffl f
ffl x ffl
2 u 3
f ffl x
e v f
of type t
bottom and choice
ffl e v
ffl e j
larsen and hansen
j m morris
z ffl 2
the recursive function
a refinement calculus
function types are
an axiomatization of
x of type
refinement and equivalence
over choice in
expression e of
axiomatization of functions
8x t ffl
the skolem axiom
ffl 2 u
of specificational functions
e is proper
e j x
e of type
on the integers
e and f
that function application
distribute over choice
even x then
axioms of figure
promises the existence
types are non
and equivalence are
specificational functions are
propers u and
for specificational functions
the liberal view
of proper functions
of applying sqrt
are non flat
fn f ffl
2x t j
postulate that the
distributes over choice
and hansen 1996
u x ffl
strict and distributive
9x t ffl
applying sqrt to
is proper iff
e v x
x ffl 2
2x z j
hilbert s ffl
if even x
z ffl x
then 2 else
other than itself
function application is
abstractions x t
morris and bunkenburg
functions and choice
type t u
v x ffl
ffl if even
the anomalies of
flat types only
refinements other than
the axiomatization of
f is proper
is proper or
t j p
every expression e
z j x
abstractions are proper
that x ffl
the underlying logic
case letters for
the possible outcomes
delta j m
possible outcomes of
is refined by
an element of
u 3 is
properties of functions
we can deduce
is not monotone
is interpreted by
the body of
it is not
for reasoning about
type t is
if x j
and v such
we shall see
a function f
in programming languages
t as an
t u and
functions are not
that u v
is a refinement
can deduce that
particular we develop
lo 2 else
formal axiomatization for
point of invoking
choice in their
may yield any
abstraction x z
refinement calculus is
e x ffl
as x ffl
fall foul of
refinement for example
a proper function
requirement on functions
ffl f f
specificational functions is
j u then
every expression of
them equivalent by
in partsch 1990
pair types as
application is strict
more elaborate example
the familiar laws
algebra of programming
in 2x t
2x t jfalse
liberal and conservative
u 5 u
v f ffl
of base type
the proper functions
with choice and
a denotational model
the choice over
a flat type
propose solutions in
j and extensionality
that pair formation
t satisfying predicate
the liberal and
traditional functions are
hehner 1993 1998
8x ffl e
represents choices that
foo v x
proof in vdm
all abstractions are
specificational functions a
interpreted in environment
is pretty much
2 else 3
letters for arbitrary
in contradiction of
5 u 6
bunkenburg 1998b for
choice and bottom
f axm unfold
to hilbert s
in cip l
equivalence and refinement
with proper terms
relational methods in
as in 2x
when functions and
in refinement calculi
presence of bottom
ss 1 lo
in environment ae
that are monotone
of prescriptive expressions
that function types
be considered proper
and assertion expressions
proper or bottom
the j axiom
and choice for
in calculations it
axiomatization of specificational
properness of functions
sqrt to 4
flat types and
a formal axiomatization
ffl x u
bound variable in
