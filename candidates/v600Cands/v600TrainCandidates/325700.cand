bub
blast
clp
pc1
pc2
bakery
abstraction
cts
bak
x1
predicates
x2
intermittent
predicate
esc
coinduction
assertion
subsumption
looping
abstract
tabling
x3
negations
constraint
transition
java
jml
verification
hoare
verifier
pvs
assertions
bubble
coinductive
fragment
compositional
obligation
invariants
satisfiability
postcondition
int
target
groundings
cegar
java2
pc
nondet
krakatoa
x4
finishes
prototype
subsumed
loop
renaming
increments
coq
proving
seconds
auxiliary
satisfiable
analyzer
grounding
abstracted
eg
amongst
propagation
hol
fresh
traversal
processes
incremental
checker
exclusion
obligations
substitution
var
subsequence
timing
nondeterministic
subprogram
unbounded
weakest
abstractions
projection
termination
tree
enhances
visited
spin
triple
obligaton
deonote
astraction
compostionality
anonynous
asertion
asignments
mbram
particurly
abberviate
peudocode
bebefits
mittent
yq
mutual
counterexample
tail
precondition
strongest
systematic
interpretation
hereafter
pursue
ables
javacard
counterex
uniting
subsitution
murphi
accomodates
spurious
reasoning
initialized
backtracking
recursive
tabled
combinable
algortihm
jhala
abstrac
perpetual
goal
vari
lazy
orginal
intricacies
unsatisfiability
composi
ranjit
v6
shall
invariant
transitions
composition
mulas
matically
sider
snippet
principle
symbolic
thereon
motzkin
memoization
slam
refinement
runs
successively
1000
terminal
tantamount
straction
eq
comment
sequential
ary
programs
onds
promela
synergistic
herbrand
checks
incrementally
nonterminating
compositionality
discharged
transi
renames
applet
assignment
style
program
counter
retain
primer
ghz
importantly
constraints
formula
equivalently
transformers
diophantine
engineered
relates
propagate
modular
certification
employ
flexible
concurrent
statement
predicate abstraction
n bub
program point
j t
pc1 pc2
constraint transition
pc2 x1
x1 x2
a goal
t n
proof sequence
x2 bak
1 bub
process bakery
bakery algorithm
a cts
abstract domain
intermittent abstraction
if pc1
system variables
esc java
target point
i j
start goal
cts for
bub 2
exact propagation
cts of
their negations
a constraint
program fragment
i 50
proof tree
of variables
the blast
goal g
java 2
proof method
bak 7
intermittent predicate
abstraction point
incremental satisfiability
pc1 0
pc2 0
x1 x3
7 pc1
looping version
with blast
program points
abstraction with
the clp
abstract description
the abstract
a proof
2 process
a program
clp r
the program
the start
program analysis
the cts
the assertion
abstraction a
finishes in
in clp
of predicate
p k
the abstraction
x2 x3
predicate set
clp system
in blast
bub 7
subsumption checks
full predicate
cts in
if pc2
bub 0
blast we
bub 5
bub 6
blast system
non looping
bub 3
proof sequences
bub 1
start variables
and blast
run blast
bub 4
of coinduction
n i
abstract interpretation
of predicates
proof obligation
y 1
of constraints
while true
goal has
anonymous variables
looping program
primary variables
additional predicates
start program
x3 x2
the predicates
new constraint
our proof
abstraction and
variables x
program with
our verifier
predicates x
a clp
goal p
i 1
program verification
auxiliary variables
while i
the target
p 0
unbounded number
an assertion
of p
hoare style
4 processes
abstraction at
an abstraction
of abstraction
satisfiability problem
point 2
pc i
on predicate
var a
y is
the variables
abstraction technique
int main
the looping
0 x
x 3
to denote
of program
i n
of anonymous
true do
else if
we abstract
proof step
variables is
assertions and
our prototype
while j
a term
x 1
j n
x i
pc2 1
0 pc
esc java2
n retain
principle here
groundings of
spurious counterexample
clp systems
verify mutual
fewer predicates
bakery 3
0 pc2
enhances program
predicates shown
abstraction would
pc1 2
fragment p
goal bub
seconds clp
blast using
use intermittent
1 subsumption
a grounding
have blast
exact runs
the bakery
target goal
pc1 1
even counts
x2 x1
blast generate
every visited
blast finishes
cts to
latter goal
with clp
bub 8
bakery 4
performing abstraction
clp with
its cts
pc2 2
hol light
j t n
i j t
t n bub
pc1 pc2 x1
pc2 x1 x2
x1 x2 bak
a constraint transition
esc java 2
a cts for
a proof sequence
the abstract domain
j n i
the target point
set of predicates
intermittent predicate abstraction
bub 2 i
7 pc1 pc2
2 process bakery
bak 7 pc1
incremental satisfiability problem
i 1 bub
of predicate abstraction
predicate abstraction with
x2 bak 7
a goal g
our proof method
sequence of variables
a program point
n i 1
i n 1
t n j
t n i
p 0 x
bub 4 i
of anonymous variables
6 i j
n 1 bub
4 i j
the system variables
cts for p
i i 50
goal p k
predicates x i
sequence of constraints
else if pc1
the incremental satisfiability
abstraction at every
bub 0 i
bub 6 i
start program point
on predicate abstraction
the blast system
number of variables
n i n
n j n
2 i j
goal has the
the start program
predicates that we
and 4 processes
the abstract description
subsequence of x
unbounded number of
of the form
2 x 3
a goal is
y is a
at the target
while true do
finite set of
is a goal
x 3 x
to a goal
substitution is a
let there be
0 i j
x i i
full predicate set
intermittent abstraction technique
variables var a
if pc1 0
every visited state
in the blast
x1 x2 x1
seconds clp with
branch of this
a constraint over
program with loop
subsumption and coinduction
exact propagation is
target point s
of proof sequences
new constraint y
given sequence say
bub 1 i
proof sequence from
pc1 0 pc2
created to correspond
bub 3 i
0 pc2 0
use the clp
n bub 4
one proof sequence
the non looping
principle here is
0 j x
instances p 0
5 i j
8 i j
user assertions and
true do figure
else if pc2
in predicate abstraction
verification and analysis
requires fewer predicates
clp with tabling
n bub 6
predicate abstraction based
a target goal
non looping version
two process bakery
bub 7 i
at every visited
if pc1 2
predicate abstraction the
a proof step
abstraction with clp
abstraction a g
constraint transition of
4 processes in
the cts in
x2 x1 x3
1 bub 1
for the looping
program fragment p
over system states
process of abstraction
for an assertion
sequential 2 process
conditions and class
a goal definition
bub 5 i
constraint transition system
1 while i
use intermittent abstraction
a start goal
0 pc i
target point is
x1 x2 2
of subsumption and
technique on our
bakery algorithm is
version of bakery
and its cts
have blast generate
000 subsumption checks
abstraction is performed
abstraction point 1
x and possibly
the start variables
be a goal
perform exact propagation
step from g
term or constraint
n bub 2
to verify mutual
blast finishes in
the goal bub
predicates shown in
process bakery algorithm
with the comment
and n retain
our abstract description
add the statement
abstraction technique on
pursue the then
in seconds clp
predicates we also
x initialized to
n bub 8
constraint we write
verify mutual exclusion
the bakery algorithm
abstraction and g
the principle here
process finishes in
the latter goal
while i n
n retain their
a cts to
if pc1 1
x1 x3 x2
proof sequence is
is new we
with full predicate
the abstraction operation
and class invariants
a clp system
bub 8 i
7 i j
