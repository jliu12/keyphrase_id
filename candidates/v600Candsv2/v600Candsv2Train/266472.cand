redundancies
implication
circuit
redundancy
implications
net
nets
circuits
omega
combinational
label
replacement
removal
latches
labelled
learning
stuck
unobservability
sequential
labels
gate
compatible
labelling
overwritten
overwriting
inverters
latch
unjustified
recursive
gates
redundant
hn
learnt
optimisation
unobservable
lr
propagate
offset
delay
implying
ha
bdd
vertex
cares
learn
delayed
propagating
untestability
safe
optimised
compatibility
script
constants
red
hm
berkeley
reset
observability
indicators
propagation
contradicted
fanout
rules
mapped
transduction
implied
area
synchronizing
split
inputs
rugged
inconsistent
notion
iyer
logic
cpu
inferred
invoking
permissible
sibling
backward
remove
po
removed
identification
austin
symbolic
existed
odc
miron
ruggedand
ruggedwere
unobservabilities
isola
dundancy
initialisability
belled
infer
wires
primary
assumptions
sis
outgoing
compositional
identifying
na
child
vigyan
entrena
ploiting
pixley
redundan
died
parent
optimi
dancy
combinationally
abramovici
rightly
compat
claim
powers
optimising
qadeer
shaz
labellings
ve
rule
redun
cordic
ible
incorrect
vergence
sation
unvisited
aziz
successively
safer
cadence
brayton
ondly
valued
labeling
cycle
benchmark
faults
justifications
falsify
fanins
returned
optimisations
forall
compositionality
adnan
graph
edges
cies
formalise
implication graph
recursive learning
redundancy removal
circuit graph
sequential redundancies
net n
delay replacement
area reduction
constant v
current implication
combinational redundancies
circuit obtained
sequential circuits
time offset
safe replacement
learn implications
hn 7
case split
input gates
omega omega
original circuit
consistent assumption
propagate implications
v redundant
label n
new circuit
circuit c
large circuits
redundancy identification
removal algorithm
global reset
mapped area
single net
sequential optimisation
removal without
delayed safe
delayed replacement
setting net
gate implies
unobservability indicators
sequential redundancy
ha 7
net n2
symbolic time
redundancy remove
combinational redundancy
redundancies without
k delayed
hm 7
cycle stuck
implication propagation
labelling procedure
net m
sequential optimization
global symbolic
implication graphs
propagating implications
c delay
new implication
logic optimization
cpu time
state space
lemma 2
across latches
one label
identify redundancies
unobservability conditions
assumption hn
rules c1
learning implications
implications across
labels returned
redundancies identified
c lr
compatible redundancies
fanout net
transduction method
lr a1
every implication
current labels
implying constants
similar rules
faults reported
identifying sequential
learnt implications
rule c6
compatible implications
implications learnt
net value
red c
latch redundancy
propagation scheme
red lr
stuck at v
set of labels
n i gamma1
rules for implying
redundancy removal algorithm
reduction in area
omega omega omega
use the notion
combinational redundancy removal
constants with unobservability
sequential redundancies without
delayed safe replacement
hn 7 0i
global symbolic time
removal with recursive
redundancy removal without
n i 1
graph for n
obtained by setting
c with 0
two input gates
number of latches
consider the circuit
stuck at 1
delay safe replacement
power up delay
child of n
assumption hn 7
sibling of n
illustrates the rules
hn 7 1i
exists an implication
c delay replacement
logic networks based
omega at every
redundant faults reported
circuit by propagating
learn implications g
n is stuck
input gates note
ha 7 1i
value the net
design of logic
p of nets
sequential redundancy removal
us to propagate
constant is contradicted
notion of replacement
implications g hn
k cycle stuck
recursive learning name
without recursive learning
inverters and 2
identifying sequential redundancies
g hn 7
latch redundancy removal
implication propagation scheme
transduction method design
cares in multi
algorithm is compatible
implications across latches
implication graph existed
