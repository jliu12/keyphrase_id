haskell
expr
splice
pvar
app
quasi
template
var
gensym
quotes
tre
metaml
meta
cl
quotation
genswap
monad
printf
compile
quote
reification
scoping
zipn
lift
macros
tup
exp
swap
mkzip
declarations
sel
patt
lam
monadic
declaration
ptup
string
splicing
staged
programmer
compiler
syntax
boilerplate
foo
pat
reifydecl
int
apps
typing
binding
trp
splices
ordinary
gen
quoted
reifylocn
zip
constructors
sigplan
macro
module
macroml
venv
decl
templates
typed
checked
lit
scrap
reify
assert
datatypes
scope
fragments
site
tres
hygienic
xs
checking
algebraic
datatype
names
scoped
ps
staging
fresh
expand
sheard
ghc
dec
geneq
reifytype
metao
genpat
reifyopt
rept
lexically
bind
functional
fork
name
spliced
caml
import
statically
compiling
lmmel
quotations
tvar
vf
programmers
lambda
cpp
ralf
format
rep
translation
expression
brackets
inadvertent
body
lisp
code
constructor
tip
persistence
peyton
language
inside
concrete
checker
static
generative
expressions
bindings
parse
msg
deed
teach
trps
quasiquote
pxs
tcon
varclass
baggage
bringert
casee
pcons
genswapdyn
runq
urk
genzips
reifyfixity
compiled
workshop
safe
top
tricks
programs
patterns
renamed
oregon
lexical
portland
bracket
syntactic
erwig
cased
gument
prompt
object
returns
notices
trans
alpha
fail
tapp
baroque
pasalic
emir
lifted
copy
pattern
returned
judgment
think
template haskell
quasi quotes
quasi quote
compile time
meta programming
expr expr
tre cl
quotation monad
quote notation
ordinary haskell
type checked
app var
type checking
var x
top level
static scoping
syntax construction
construction functions
pvar x
inside quasi
copy cl
data type
f var
scheme macros
var y
type check
int expr
type expr
acm sigplan
type system
run time
gensym x
time meta
algebraic datatype
ptup pvar
c templates
quasi quoted
cl app
tup app
cl es
printf error
x gensym
splice e
app f
string expr
level splice
x pvar
quasi quotation
meta function
code fragments
type safe
algebraic datatypes
exp exp
state c
meta program
sigplan workshop
object variables
var f
exp dec
lexical scoping
ary zip
swap x
q string
template meta
lit int
pvar f
lam pvar
f gensym
gensym f
line d
type classes
swap 4
original name
x app
cross stage
stage persistence
original names
functional programming
multi stage
algebraic data
meta programs
cl e
fresh names
type checker
state b
strongly typed
x var
object programs
type declaration
variables bound
data types
functional language
zipn int
function mkzip
metao caml
bound outside
lam ptup
sel int
pat statement
x lam
alpha renamed
haskell programs
splice site
app expr
inadvertent capture
pat exp
dec pat
declaration splicing
using haskell
f lam
dynamic scoping
zip function
write zipn
definition site
expr gen
expr sel
haskell function
statement pat
boilerplate code
module foo
like printf
venv exp
lisp community
define printf
patt expr
oregon usa
module m
section 9
concrete syntax
quasi quote notation
syntax construction functions
inside quasi quotes
expr expr expr
workshop on haskell
pvar x pvar
ptup pvar x
top level splice
f var x
x gensym x
acm sigplan workshop
time meta programming
n ary zip
f gensym f
compile time meta
x var y
returns a computation
tre cl app
var x var
swap 4 5
cross stage persistence
functional programming v
journal of functional
portland oregon usa
f lam pvar
tip a fork
pat exp dec
var f var
lam ptup pvar
int expr sel
gensym f lam
venv exp exp
zipn int expr
app app var
template meta programming
int int expr
exp dec pat
statement pat exp
app expr expr
var t swap
pat statement pat
data type declaration
lam pvar f
tup app f
scrap your boilerplate
group of declarations
sel int int
checked in state
haskell s existing
app var f
compile time execution
outside the quasi
allows the programmer
simon peyton jones
v is bound
section 9 1
acm sigplan notices
sigplan notices v
programming and component
conference on generative
built on top
n 9 september
section 8 1
want to generate
programmer had written
d msg line
check the body
pvar ptup etc
exp tres cl
checking the body
term t exp
m t tvar
library of syntax
quote and splice
call to printf
peyton jones scrap
functions that execute
swap and x
case y1 y2
haskell compiler ghc
