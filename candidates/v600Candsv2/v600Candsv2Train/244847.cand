latch
latches
logic
combinational
tradeooe
reachable
encoding
bdd
sentovich
horia
removal
toma
rard
sequenceur
esterel
removable
ellen
cation
veri
trappes
blifopt
tcintnocount
circuits
bdds
berry
inria
tcint
hot
rem
removed
circuit
sis
retiming
dioeerent
dioecult
rr
foreach
nova
renault
literals
reg
cant
unreachable
transformation
designs
combopt
exorbitant
controle
fsm
descriptions
speci
encodings
runner
satis
nal
lit
synthesis
registers
migrate
signi
jrj
assignment
rst
suoeciently
redundant
cofactor
optimization
eoecient
fold
removing
snecma
ubiquitously
abcdef
controlecount
heuristics
abc
encoded
remove
reachability
literal
eoeects
reaeect
eoeect
controlling
gate
dat
resynthesis
deltar
brayton
ed
script
implementations
tiger
iterating
heuristic
decoding
simpli
jlj
traversal
exploration
iscas
symbolic
fpgas
vs
nonetheless
strive
shannon
automation
gates
merge
transition
nite
blow
industrial
greedily
selecting
thoroughly
iterate
fanout
incremental
hardware
sequential
hotj
pessimize
irobustj
camurati
iredundant
resyn
mesr
gard
cumulatives
eoecacy
seawright
kalla
latchesj
priyank
resoundingly
quer
yunjian
ciesielski
remlatch
insigni
gianpiero
reaeects
igroup
extracting
favorably
replaced
expensive
subsequent
cpu
updated
machines
causal
hahnsang
epspectra
tradeooes
systemsthe
sacres
qcc
winkelmann
cabodi
genie
aoeect
aeexibility
chm
amar
traoec
bouali
metrics
benchmarks
nd
eoeciency
single latch
latch removal
logic optimization
state assignment
latch l
reachable states
m sentovich
latch logic
latch optimization
one hot
veri cation
ellen m
horia toma
removed list
circuits generated
sentovich horia
combinational logic
level descriptions
reachable state
toma g
g rard
n sigma2943
inria latch
re encoding
rard berry
rem latch
minimum latch
logic tradeooe
explicit state
rr n
combinational function
r l
state set
removable list
foreach latch
high level
one latch
redundant latches
many latches
reg lit
hot encoded
fold states
subsequent logic
logic size
redundant registers
remove latches
state l
initial implementation
transition graph
transformation 2
resulting logic
exact algorithm
signi cant
speci cation
equivalent states
remaining latches
remove latch
removing latches
best latch
states computation
tcintnocount 19
latch 2
latch cost
two latches
latch algorithms
three latches
exact single
latch encoding
nal implementation
nova sis
latch m
latch 1
list removed
migrate states
latch version
cation times
large designs
l j
small examples
care conditions
unreachable state
literal count
implementation size
encoding space
states condition
approximate reachability
reachability analysis
state machines
symbolic traversal
designs generated
bdd size
many redundant
minimum number
state encoding
state transition
logic synthesis
additional logic
removal algorithm
l 0
let l
satis ed
nite state
large circuits
r new
log 2
finite state
successively remove
maximum latch
lit reg
quite dioeerent
hot implementation
additional combinational
overall logic
list foreach
equivalent state
k brayton
good latch
e logic
re encode
number of latches
generated from high
high level descriptions
ellen m sentovich
sentovich horia toma
m sentovich horia
optimization in circuits
rr n sigma2943
inria latch optimization
horia toma g
toma g rard
single latch removal
latch logic tradeooe
g rard berry
reachable state set
set of latches
foreach latch l
one hot encoded
explicit state assignment
d and e
state transition graph
l i l
n by n
n 1 algorithm
single latch 1
latch removal algorithm
states the re
remove latch m
subsequent logic optimization
single latch 2
latch m l
single latch algorithms
best latch cost
removal and optimization
list removed list
log 2 jrj
reachable states computation
n sigma2943 ellen
veri cation times
approximate reachability analysis
far too expensive
condition the condition
state l 1
explicit state transition
l i 2
l 1 l
synthesis and optimization
hardware and software
single latch algorithm
sequenceur and trappes
assignment from high
selecting the latch
j oe return
trappes 53 154
controlling the logic
runner 6 5
implies r l
generated from esterel
latches to remove
k for r
unreachable state l
latch removal algorithms
encoding function e
couple each reachable
reg lit reg
latches as possible
state space decomposition
latches inria latch
removed list removed
list j oe
incremental re encoding
robert k brayton
reachable states ffl
l i deltar
decomposition for approximate
signi cant logic
removing as many
encoding will couple
apply heuristic techniques
optimization in sis
lit reg lit
l to produce
exact state minimization
examples behaved similarly
many redundant registers
removed latch l
removed list foreach
