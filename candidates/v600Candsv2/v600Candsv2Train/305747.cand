feas
depth
forests
deg
decision
trees
pure
assignments
boolean
probability
rfc
inputs
bits
ff
tree
help
agreement
probe
forest
circuits
xor
bit
randomized
leaf
polylog
circuit
queries
variate
assignment
counting
agree
yao
query
parity
polynomial
unbiased
irw
nk
tuple
monomial
fraction
abg
covers
product
poly
black
ck
py
cover
copies
seek
box
distribution
correctly
linial
vacuous
sign
unrelated
fix
tuples
majority
vari
closed
conditioning
sized
wigderson
simultaneous
attained
probed
nathan
computable
claim
probing
avi
probes
proposition
sufficiently
ordinary
covered
contracting
intuition
disjoint
conditioned
family
lemma
ulig
bsh
lexicographi
rectangularly
degs
pny
vaz
multiplicativity
cghfrs
segerlind
probd
krw
feasible
deduce
answer
event
exceeding
ables
remark
jg
child
pitassi
domized
toniann
fkn
miltersen
pnn
polynomialg
answers
prob
oracle
bro
shaltiel
distributions
associates
questions
amplifying
sorry
nati
obvi
plicated
dependently
ask
induction
approximate
induced
beame
armed
impagliazzo
agrees
dt
barrier
xng
trying
erage
trapdoor
false
rooted
suffices
yy
umn
irrelevant
outputs
multiparty
ous
amplification
appendices
protocols
proving
feasibly
disjointness
gt
computes
outside
approximates
rectly
knowl
paul
sketch
favorite
corollary
plexity
beigel
conditional
conceivably
children
ronen
corruption
pk
monomials
nonnegative
communication
imply
gl
indexed
distributional
says
root
expression
rename
qualified
integers
convenient
anna
blum
jd
help bits
decision tree
help bit
f d
pure f
decision trees
agreement probability
p f
depth d
distribution d
r decision
boolean function
assignment ff
x r
product theorem
k l
expected depth
product problem
q d
d k
bits problem
decision forest
k counting
simultaneous agreement
l pure
size circuits
xor lemma
function f
d f
l f
communication complexity
c k
first probe
bit problem
product distribution
k pure
approximate product
variables outside
compute f
tree complexity
k inputs
f ff
forest f
ordinary decision
assignments ff
sized circuit
probability q
computing f
n variate
polynomial sized
k tuple
variable set
h k
x 1
k decision
black box
polynomial size
n variables
boolean functions
boolean circuits
r function
pure tree
f deg
polylog bit
input ff
feas 1
d 1
tree algorithm
computes f
majority function
ff chosen
poly size
sufficiently large
direct sum
d 2
f j
range r
tree depth
boolean assignments
tree computation
d variables
large k
set x
k f
complexity measure
chosen according
distribution q
approximate f
two inputs
theta d
complexity c
proposition 4
k functions
b x
ff k
direct product
ff 1
maximum depth
must agree
every fixed
p f d
deg s f
q d f
x r decision
h k l
c k l
f d k
k l f
pure f d
r decision tree
feas is closed
trees of depth
copies of f
boolean function f
k f d
closed under k
help bits problem
k l pure
probability q d
agreement probability q
f with probability
f d 2
f d 1
assignments to x
variable set x
decision tree complexity
approximate product theorem
polynomial sized circuit
l pure f
k pure f
help bit problem
x r function
agree with f
ordinary decision tree
set of assignments
d 2 l
variables in x
value of f
polynomial size circuits
decision tree algorithm
every fixed value
simultaneous agreement probability
poly size circuits
f i ff
outside of x
f on k
cover all assignments
decision tree depth
c t ff
d on assignments
pair of inputs
decision forest f
k decision trees
function and suppose
r decision trees
d 1 2
f on n
according to d
probability with respect
theorem 3 1
d a b
f d e
sufficiently large k
tree of depth
theorem 4 1
proposition 4 2
forests that cover
ff chosen according
probability exceeding 1
depth d tree
k parallel decision
help bit queries
forests of depth
model and complexity
exceeding 1 2
decision trees used
