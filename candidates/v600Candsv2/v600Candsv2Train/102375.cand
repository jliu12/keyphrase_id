lp
lsl
trait
lslc
traits
larch
linearcontainer
dd
totalorder
priorityqueue
obligations
deduction
cd
specifications
axioms
addw
converts
qed
claims
naturalnumber
specifiers
discharge
assertions
clause
rewrite
specification
declare
isgenerated
conjecture
theories
isempty
asserts
subgoal
equational
insert
commands
implication
coord
rules
guidance
operators
emptyv
inw
discharged
forall
assert
interpretations
command
obligation
induction
window
rewriting
containment
assistance
fg
checking
resume
inconsistencies
displayable
debugging
clauses
consistency
hypotheses
proving
partitioned
alse
consequences
specifier
checkable
formulates
commutative
clu
exempting
natpriorityqueue
otalorder
subgoals
coordinate
directs
proofs
axiom
interface
nat
propositions
diagnostics
hypothesis
implications
completion
prover
damon
checks
ada
inconsistency
debug
jackson
certifying
lcf
semantic
mechanisms
extracts
facilities
sorts
checker
equations
feg
inference
completeness
modet
nonconsequence
orall
andres
multisorted
language
automatically
assumes
check
logical
flaws
rule
logic
wid
normalizes
declarations
attempted
users
identities
introduces
ontic
operator
conjectures
syntax
sort
discover
formulate
inferences
terminating
languages
empty
semantics
hierarchy
shared
craig
counterexample
certify
normalization
appearance
inconsistent
textually
nonterminating
axiomatized
uncovers
liskov
erroneous
plan
detector
id
axiomatizations
lemmas
6d
syntactically
associative
unintended
sample
incompleteness
transitively
execute
handbook
daniel
inductive
tri
imply
initiate
identity
detecting
vacuously
incomplete
programmers
logically
observational
consist
reasoning
critical
backward
circuits
revised
encourages
informal
attempting
origin
subtle
enhance
categories
overloaded
mistakes
contradict
easier
windows
bool
cartesianview
proof obligations
rewrite rules
deduction rules
deduction rule
larch shared
shared language
cd 0
lsl specifications
converts clause
dd y
theory containment
completion procedure
x dd
qed prove
lp commands
e dd
critical pairs
lsl traits
y dd
empty q
prove x
use lp
implies clause
dd e
addw v
next rest
proof obligation
handle case
declare variables
induction rules
next new
lslc formulates
operator theories
obligations associated
empty 0
larch interface
trait view
z proofs
rest new
directs lp
v 0
interface specifications
logical system
lp provides
explicit theory
lp uses
user assistance
e 2
q e
dd x
next q
z dd
trait hierarchy
emptyv cd
proof mechanisms
dd true
declare operators
lsl specification
interface languages
x qed
v cd
lsl checker
assumes coordinate
lslc extracts
e 0
empty c
user guidance
first order
ordering methods
set name
daniel jackson
order logic
rewriting theory
lslc checks
declare sorts
fg insert
lp command
c dd
yield x
file totalorder
cd coord
checkable claims
attempted proof
asserts forall
totalorder assertions
introduces asserts
lsl trait
q qed
semantic claims
categories consistency
cd cd
isgenerated x
larch prover
check traits
check implications
larch shared language
generated by fg
lp the larch
resume by case
proof obligations associated
isempty and 2
y dd y
x 0 dd
insert s e
case is empty
theory of linearcontainer
prove x y
dd e 2
empty q 0
x y dd
first order logic
proof by cases
case e 0
rules and deduction
equations and rewrite
e 2 x
cd 0 cd
addw v cd
syntax and static
case v 0
declare sorts e
dd y 0
q qed prove
lp is used
performance of lp
assumes coordinate includes
true dd f
x qed prove
v 0 next
lslc the lsl
declare variables x
craig a damon
next c 0
equations rewrite rules
dd y x
dd f alse
guidance is required
dd is empty
lp to discharge
work on lsl
lslc and lp
lp to prove
three categories consistency
new and rest
prove the subgoal
qed prove x
semantics of lsl
search for inconsistencies
y x qed
attempting to prove
partitioned by 2
hypothesis t 0
family of specification
fall into three
attempt to prove
attempts to prove
set of operators
b c c
within a newly
extended example illustrating
else if next
traits that imply
execute set assertions
