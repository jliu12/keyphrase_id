disk
lru
buffer
fetches
omega
schedule
os
discards
disks
prefetching
block
blocks
consumed
prefetch
fetch
referenced
sigma
fetched
consumptions
replacement
lookahead
min
makespan
gammacon
demand
tp
unread
discard
con
fi
consumption
opt
paging
kallahalla
varman
1disk
zg
buffers
schedules
accesses
round
ut
ff
competitive
gammalru
management
mahesh
prefetched
delta
matches
inflate
sequential
tight
worst
policies
valid
fzg
evict
tmin
axiom
cpu
parallelism
optimality
overlapped
initiated
fl
differ
consume
fifo
minimizes
semi
fq
poorer
fp
hypothesis
caching
aggressive
resident
questions
pg
gammamin
dtmin
aslo
policy
replaces
concatenating
induction
idle
concurrently
longest
precede
elapsed
breslauer
penner
sytems
fy
suboptimal
agree
till
references
serializes
inspires
analyzed
subsystem
preference
read
match
conservative
subsequence
schlumberger
peter
retained
accessed
degrade
paged
parenthesized
minimizing
opportunity
viktor
progressed
overlap
mirroring
sleator
serialize
crete
greedy
striping
prasanna
raid
choices
sketch
suffixes
randomized
jea
unexpectedly
serialization
prefix
serialized
hf
hai
discarded
mon
upto
prematurely
judicious
quence
fundamental
lemma
abstractthe
algorithmics
hwang
mt
whence
island
contrasts
phase
advocated
operated
cao
offline
sequences
centric
tarjan
normal
beyond
replace
friendly
absolutely
imbalance
thirteenth
repetitions
discarding
reference
overlapping
deferred
roy
ho
kai
forward
candidate
reading
investigate
decisions
summarizes
fetching
gorithm
develops
fresh
poor
p lru
p min
p con
time step
valid schedule
discards block
buffer management
demand block
min block
time steps
os done
single disk
ffl omega
o parallelism
consumption sequence
discards q
o time
block p
block q
block u
discard block
tp gammacon
fetches block
blocks consumed
fetches p
disk buffer
o systems
sequence sigma
optimal schedule
block z
min schedule
o phase
unread block
next unread
o step
ff fetches
disk systems
replacement choices
since delta
fetch block
min algorithm
multiple disk
lemma 10
sequential schedule
block v
management algorithms
schedule fi
longest forward
round disk
o steps
mahesh kallahalla
disk 1disk
construct omega
1disk 2
consumption sequences
forward distance
kallahalla peter
fetches z
j varman
analyze p
f k
prefetch blocks
paging algorithms
fundamental questions
os performed
normal sequential
see theorem
next reference
valid schedules
worst case
algorithm p
several fundamental
multiple disks
step k
management algorithm
every block
one block
induction hypothesis
fetches y
buffer omega
either discard
always matches
matches omega
lru schedule
discards z
axiom a1
omega t 1
parallel i o
omega t fetches
prefetching and buffer
demand i o
number of disks
fetch any block
p and discards
delta and omega
number of parallel
parallel i os
u i 2
buffer management algorithms
lru is independent
next unread block
p min schedule
semi on line
performance of p
also be consumed
block of disk
single disk systems
start of time
step t 1
using lemma 10
minimizes the number
p or z
consumed by fi
consumed by ff
step k u
con an algorithm
consumed by omega
normal sequential schedule
buffers of ff
disk 1disk 2
buffer management algorithm
omega t differ
longest forward distance
o step k
y and discards
z and discards
several fundamental questions
peter j varman
round disk 1disk
1disk 2 cpu
u and discards
min that minimizes
contrast to p
o at time
consumption sequence sigma
questions on prefetching
mahesh kallahalla peter
algorithm p min
kallahalla peter j
o at ffl
min and p
disks in contrast
every i o
made by p
prefetching and caching
prove the optimality
worst case bound
ff and fi
induction hypothesis delta
subsequence of sigma
corresponding optimal schedule
delta at time
