ys
dag
explicitation
grammar
xs
grammars
cons
nil
denition
ura
iscons
dags
driving
eh
generalisations
ow
inversion
supercompilation
gluck
inverting
rewrites
checker
speculative
refal
soundness
termination
nite
productions
isnil
redex
production
unfolding
dened
deforestation
false
generalisation
specialised
metacomputation
abramov
roots
predecessors
append
tree
ar
srensen
successors
hinders
redexes
substitution
rewritten
inference
semantics
arrowcheck
normalise
fsame
ysg
typechecker
maxmatch
romanenko
instantiation
unfolded
exp
sound
label
decomposed
siau
fan
extracted
leaves
xy
innite
cf
branch
accumulated
outermost
drive
normalised
lab
vs
dene
leaf
rst
imagine
disjoint
constructor
def
feg
khoo
transformers
resolving
xz
object
yz
syntactic
calculus
kun
synchronisation
gram
compromise
haskell
match
language
rewrite
akin
bookkeeping
york
discriminate
essence
strength
eectively
pairwise
instantiations
tthen
secher
amram
synchroni
explicitate
tomb
eralisations
consg
expchk
culprits
cripple
elimchk
fhi
generalisa
fegd
aloows
turchin
bauderon
contracta
incorporated
usability
xml
terminates
tuples
executions
propagate
hopefully
constructors
dening
ground
symbol
kn
uniquely
roundabout
synthesising
concretisation
heine
lamping
metacompuation
sacrices
cormac
explication
courcelle
denitions
springer
something
substitutions
specialization
verlag
shi
contexts
hyper
lambda
superscript
dle
klimov
sacrice
uninstantiated
spines
dissolve
fs
ect
universal
terminate
viously
exemplied
synchronising
glck
parameterise
equality
extract
jones
closure
xs ys
dag grammar
process tree
dag grammars
ys x
cons x
program inversion
iscons ys
ys false
x xs
object program
ys cons
explicitation process
nil cons
negative information
control ow
tree grammars
cons x1
cons cons
x cons
vs nil
cons iscons
uniquely decomposed
ar x
type inference
type checker
size change
nil nil
input set
x y
object language
nil ys
function denition
dag language
accumulated grammar
x xs7
isnil ys
eh f
resolving algorithm
ys isnil
cons v
universal resolving
ys 7
y z
cf def
xs 7
dags d
non termination
program p
functional programs
given output
z v
symbol r
order functional
data ow
z xz
line generalisation
main denition
v vs
xs cons
explicitation eh
false g
initial dag
bookkeeping symbol
xs g
answers true
specialised typechecker
graph grammar
nil xs
inverse computation
ys 6
xs ys7
ysg eh
normal order
roots g
append cons
nil vs
equivalent dags
ys g
let terms
partial inversion
use subscripts
necessary generalisations
srensen gluck
gluck 1
dag rewrites
match z
incorporating negative
two dags
given dags
nil append
hinders unfolding
ura would
approximate termination
xs ysg
kun shi
change principle
main term
generalisation analysis
subscripts like
append vs
syntactic class
ys iscons
haskell like
constraint specialization
fsame xs
khoo kun
g eh
change graphs
satisfying input
iscons ys x
xs ys false
f same xs
ys x xs
cons iscons ys
cons x cons
ys cons iscons
data and control
x y z
given a program
xs ys isnil
nil ys 7
false same xs
xs ys cons
universal resolving algorithm
xy same xs
ys same xs
ys isnil ys
f if xy
ys x xs7
successors and predecessors
z v w
given a dag
y z v
d and e
produce a grammar
order of successors
y z xz
x cons cons
true same xs
imagine a program
xs g f
otherwise not obvious
cons x1 nil
ysg eh f
drive the object
inversion and metacomputation
normal order semantics
cons x1 cons
bookkeeping symbol r
nil nil cons
line generalisation analysis
xs ysg eh
append vs nil
inverting a program
ar x y
replace the speculative
terminates on p
behaviour of deforestation
fsame xs ysg
size change graphs
process tree although
constructs a process
cons cons x
xs ys 6
o line generalisation
compiling with proofs
program that checks
abramov gluck 1
use subscripts like
successors of j
new for instance
vs nil append
ar ar x
idea of approximating
x xs7 7
isnil ys g
approximate termination behaviour
principle for program
size change principle
grammars to approximate
produces a nite
either the comparison
x xs cons
incorporating negative information
ys 7 cons
cannot be driven
comparison will fail
hyper graph grammars
z xz yz
false g f
cannot be decomposed
cons x xs
given dags d
ys g eh
xs 7 cons
output constraint specialization
driving the program
ys false g
approximating functional programs
technique using tree
nil xs 7
programs by grammars
cons x2 nil
extract a dag
ys iscons ys
x xs g
see srensen gluck
