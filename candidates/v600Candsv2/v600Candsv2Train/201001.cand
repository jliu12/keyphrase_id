bondorf
closure
palsberg
prefixed
flg
var
analyses
abstraction
beta
sestoft
cmap
subterm
metavariables
ex
label
jens
schwartzbach
reflexivity
heintze
abstractions
constraint
induction
redex
abstract
steckler
metavar
cenv
labels
cset
untyped
metavariable
autoprojection
upd
sigplan
languages
wand
lemma
jagannathan
meunier
nielson
theta
suresh
binding
globalization
substitution
ponens
inference
modus
felleisen
article
polyvariant
discharge
flow
consel
clashes
says
entailment
ayers
interpretations
barendregt
seidl
findler
horn
sigact
body
notices
ae
inclusions
safety
thetab
componential
shivers
aarhus
anindya
interpretation
rgensen
flemming
toplas
hypothesis
hanne
similix
polymorphic
calculus
informally
riis
typed
lab
matthias
philippe
symbols
syntax
flanagan
semantics
fst
correctness
lambda
functional
substituted
krishna
clauses
weakening
transitivity
occurrences
recovery
domains
binds
banerjee
jensen
reduction
dk
questions
conversion
andrew
wright
rocca
tolmach
carolyn
fecht
caap
solberg
aau
daimi
blasio
immediate
versus
modular
permission
proceed
normalizing
aug
lightweight
remained
decade
bruce
klarlund
giannini
pavlopoulou
amtoft
torben
cipline
talcott
gasser
munkegade
answers
inheritance
paris
contraction
delta
entails
spaces
recursive
schism
oliva
loving
nandivada
notice
operand
ml
everything
typings
thiemann
cml
ez
deforestation
srensen
agesen
glew
evaluates
jones
renaming
kirsten
danvy
dino
ramanathan
ananth
kathleen
realisation
closure analysis
theta theta
x e
l x
constraint system
prefixed point
e 0
var e
label l
x l
beta reduction
m e
c e
flg l
lemma 4
jens palsberg
constraint form
c ex
cmap e
l 0
e 1
solution l
closure information
application point
arbitrary beta
closure analyses
every l
case consider
e y
result follows
term e
smaller flow
l var
form delta
higher order
abstract interpretation
w e
binding time
three closure
based analysis
contains l
flow information
analysis versus
e u
type inference
using reflexivity
cenv e
ex contains
versus type
cset e
step consider
induction hypothesis
abstract interpretations
acm sigplan
flow analysis
subject reduction
type recovery
analyses defined
program analysis
set based
constraint systems
y e
safety analysis
program points
mapping l
induction step
definition 2
automatic autoprojection
least solution
suresh jagannathan
c l
label 2
substitution lemma
time analysis
abstract domains
programming languages
ex e
reduction result
schwartzbach 1992a
theorems says
see palsberg
analysis acm
base case
function spaces
sigplan sigact
sigact symposium
recursive equations
bound variable
matthias felleisen
simpler abstract
philippe meunier
bondorf 1991
consider finally
sestoft 1989
l 6j
bound variables
first l
y l
lab e
untyped functional
languages p
consider x
functional languages
control flow
name clashes
modus ponens
consider first
z e
next lemma
cases suppose
r e
sigplan notices
notices v
l x e
theta theta theta
abstraction with label
point of m
bondorf s definition
solution of c
analysis in constraint
x e 0
lemma 4 6
constraint form delta
every l x
palsberg and schwartzbach
smaller flow information
arbitrary beta reduction
m e 1
c e 1
w e u
c l x
result then follows
set based analysis
correct with respect
var e 0
u and lemma
l var e
label l 0
three closure analyses
step consider first
labels are distinct
binding time analysis
induction step consider
structure of e
analysis of bondorf
closure analyses defined
ex has solution
consider first l
flg l var
first l x
safety analysis versus
z e 0
abstractions with label
consider a subterm
analysis versus type
versus type inference
r e 1
follows from lemma
analysis is correct
thus we need
base case consider
analysis of e
definition 2 1
proceed by induction
analysis of palsberg
set r e
l y e
analyses of untyped
consider x l
ex e y
y l 0
e then ex
label 2 l
based on sestoft
bondorf s original
x e suppose
simpler abstract interpretation
case consider x
ex contains l
subject reduction result
reflexivity we get
applied to terms
every in e
theorem 4 10
acm sigplan sigact
sigplan sigact symposium
programming languages p
y e 0
x l 0
e 0 x
principles of programming
e by computing
u x l
l 0 y
respect to arbitrary
using a constraint
transactions on programming
