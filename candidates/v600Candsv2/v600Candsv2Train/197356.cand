powerlist
powerlists
fdefinition
phi
rev
deconstruction
ps
batcher
inv
fft
ift
bm
prefix
zip
fourier
ep
sps
singleton
sorting
bi
scalars
scalar
lf
bitonic
hypercube
sorted
ladner
items
law
gray
induction
ffrom
deconstructions
lists
tie
hypercubes
laws
steele
pointwise
conquer
deconstruct
adams
fischer
fapply
hhci
fapplying
erlist
hbii
ruleg
finductiong
structural
miranda
constructors
rr
rotates
operator
nonsingleton
kornerup
finduction
dimension
transform
transposition
rs
commute
adder
depth
logarithmic
hxi
bit
recursion
merge
correctness
indices
sublist
array
list
permutation
ls
matrices
ml
infix
pow
ftg
arrays
len
hhhai
hdiii
revg
hyi
gorlatch
bmg
epg
invg
reverses
operators
recursive
index
liberated
grr
deconstructed
hhxii
algebraic
manipulations
shuffle
qg
strings
embedding
backus
unnested
nesl
vuillemin
mou
rl
hx
skeletons
powers
zp
succinct
rotate
ascending
item
kapur
lexicographically
inverses
circuit
divide
duals
commutativity
compactness
preparata
red
parallelism
th
blelloch
style
lisp
ramachandran
fusing
matrix
employing
shape
sequential
jr
processors
describing
brackets
element
inductive
di
principal
commutes
unknowns
misra
highest
aggregates
circuits
argument
concatenation
base
versatile
cube
nested
lookahead
proofs
lowest
permute
numbered
de
listsg
explotied
coeeficients
birge
susanna
quartering
prefix sum
p q
linear lists
powerlist p
structural induction
fourier transform
gray code
logarithmic length
ps p
ps l
u v
batcher merge
singleton powerlist
phi p
q phi
highest bit
linear list
scalar function
parallel algorithms
fast fourier
powerlist notation
j rev
phi q
lowest bit
parallel steps
non singleton
principal root
red phi
similar powerlists
function rev
two powerlists
singleton list
using powerlists
fft p
ladner fischer
pointwise application
fischer scheme
th principal
operator phi
p j
p phi
sorting networks
code sequence
data parallel
w n
r phi
argument powerlists
function bi
sorted powerlist
function lf
list obtained
dual deconstruction
lists p
argument powerlist
q sorted
law l2
rev reverses
adder circuits
powerlist u
lf p
rs ls
ml 17
rev q
pow erlist
standard gray
unique deconstruction
parallel computations
u j
binary operator
higher dimensional
permutation function
c di
list theory
bi p
construction operators
evaluating p
length 1
empty list
n bit
f 0
steps using
o m
infix operator
two lists
dimensional arrays
using de
parallel computing
following function
steele jr
argument list
inductive proofs
p l
cube connected
using o
e phi
scalar functions
induction base
bitonic sort
j q
whose elements
algebraic manipulations
j v
prefix computation
powerlist of length
ps p q
fast fourier transform
q phi p
gray code sequence
th principal root
tie and zip
scalar function f
ladner fischer scheme
divide and conquer
length of p
root of 1
u j v
proof by structural
p j q
differ in exactly
correctness of sps
structural induction base
length 1 containing
p a powerlist
o m processors
powerlist of depth
adder circuits using
fdefinition of big
b c di
j rev q
right by one
p j rev
non singleton powerlist
parallelism and recursion
lists p q
standard gray code
linear list theory
steps using o
p phi q
parallel steps using
higher dimensional arrays
n parallel steps
exactly one bit
element of p
power of 2
p and q
prove the result
binary operator op
within angular brackets
transform and batcher
singleton powerlist p
fft p q
merged by applying
describing parallel algorithms
powerlist of c
j rev v
operations on scalars
m sequential steps
using law l2g
index is 0
hbii hhci hdiii
processor i holds
fdefinition of ftg
sublist of elements
r bm v
programming be liberated
returns a sorted
functions over powerlists
fdefinition of revg
fdefinition of j
o 1 parallel
two deconstructions apply
facts about sorting
q is sorted
