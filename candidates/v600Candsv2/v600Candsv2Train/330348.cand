struct
modularization
stack
lattice
queue
concept
attributes
int
isempty
modules
concepts
isemptystack
isemptyq
partitions
enq
atomic
mammal
fcats
tvertex
module
fields
tangled
worklist
chimpanzees
dolphins
tedge
tface
chull
whalesg
sp
partition
legged
attribute
front
subconcept
fhair
marine
coveredg
pop
hair
push
deq
complemented
objects
fintelligent
obad
dogsg
whales
fchimpanzees
initstack
sups
initq
void
bot
return
mammals
modularizations
friend
extents
dogs
cats
humans
identifying
thumbedg
penta
fintelligentg
thumbed
untangle
fdolphins
ffour
marineg
koschke
tease
page
fff
suprema
wilde
canfora
offers
sizeof
gerardo
stacks
private
extent
engineer
analyzer
declared
malloc
monolithic
partitioner
covered
public
identification
overflow
rainer
identify
singleton
intelligent
legacy
endfor
prototype
collections
base
unsatisfactory
lattices
user
abstract
crude
mappings
bool
printvertices
humansg
fisemptystack
makeedge
wendorff
constructhull
maletic
volumed
makevertex
superconcept
superconcepts
sartipi
makestructs
printedges
christl
antimonotone
makeccw
ancs
popg
neteler
analysisa
readvertices
czeranski
recs
ftopg
printfaces
addone
canforaharman
cleanedges
chimpanzeesg
makeface
nora
cleanfaces
subconcepts
gwo
finitstackg
storey
cleanvertices
modernized
leggedg
code
bottom
twenty
endif
listed
automate
rg
ff
argument
tool
modularizing
arduous
stumble
nonsensical
typedef
coated
merlo
renovation
clustering
object
hoc
back
inference
contexts
intents
antoniol
reflexion
procedural
recovery
recovering
discriminatory
kamran
fuh
kontogiannis
member
identified
roughly
fed
inferencing
cohesion
tioner
intervene
manuvir
cohesive
similarities
concept analysis
concept lattice
struct queue
struct stack
atomic partition
atomic concepts
uses fields
g int
potential modules
concept partition
queue example
mammal example
q back
concept partitions
isempty return
analysis approach
legged hair
dolphins humans
q front
chull c
stack module
c code
return type
data types
return 1
f return
context relation
struct types
return sp
stack concept
modularization problem
concepts c
complemented extension
use fields
hair covered
proposed modularization
void enq
defined struct
abstract data
negative information
concept c
class queue
struct type
queue module
stack queue
type struct
new stack
page 8
queue q
input program
base int
concept analyzer
dogs dolphins
uses concept
covered intelligent
stack return
extent containing
stack front
f private
f struct
int base
fhair coveredg
isempty f
int isempty
intelligent marine
four legged
bot fff
stack fields
eight concepts
overflow check
humans whalesg
base g
back pop
apply concept
stack f
queue f
identifying modules
isemptystack q
tangled stack
concept x
back isempty
int deq
tvertex tedge
modularization algorithms
int pop
f uses
void push
c 6
c 7
identify potential
queue size
object set
common attributes
prototype tool
attribute set
user defined
c 0
c programs
software engineer
fundamental theorem
possible partitions
fdolphins whalesg
concept lattices
stack uses
back base
dogsg fhair
context o
tedge tface
struct data
partitions collections
empty concept
attributes listed
fcats dogsg
tangled code
top f
public stack
di penta
maximal collection
fields of struct
stack and queue
concept analysis approach
argument of type
int i f
struct queue q
f if isempty
queue and stack
new stack queue
user defined struct
type is struct
isempty return 1
legged hair covered
stack queue size
int base int
hair covered intelligent
isempty f return
int isempty f
return 1 return
scale the user
apply concept analysis
fine a scale
g int pop
queue q f
uses concept analysis
struct stack return
dolphins humans whalesg
four legged hair
isemptyq and enq
dogs dolphins humans
base g int
lattice in roughly
covered intelligent marine
identify potential modules
function f uses
abstract data types
set of attributes
given a context
set of concepts
analysis to identify
c to c
set of objects
see section 3
identifying potential modules
malloc sizeof struct
front back public
add additional attributes
coarse the user
identification of potential
modularizations of c
identify such partitions
int pop f
concepts whose extents
queue ff 6
public new stack
lattice see section
struct queue ff
size g int
fields of tvertex
struct data types
resulting concept lattice
f private stack
table on page
stack return type
analysis to propose
stack uses fields
conventional procedural language
opposed to applying
top f 0
class stack f
new int isempty
via concept analysis
sp base g
f return sp
consists of roughly
concept partition corresponds
lattice elements y
use of modules
c 7 g
back new stack
int public stack
int isemptyq struct
bot fff 0
fdolphins whalesg fintelligent
queue f private
q f return
analysis approach offers
q back g
back isempty return
sp void push
overflow check class
stack concept c
