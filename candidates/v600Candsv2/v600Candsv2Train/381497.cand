encoding
compaction
trace
encodings
dag
sequitur
gprof
java
fsa
automaton
thread
automata
grammar
visualization
abbbbbbbbbcdddbcdc
string
fsas
strings
visualizing
repetitions
resultant
digrams
files
sigsoft
traces
calls
discovering
tracer
tracing
inferring
knight
repetition
reiss
records
manning
orso
merged
nonterminals
file
deployed
profiling
onsets
digram
gammatella
showmeanings
bcdc
library
allocations
harrold
sequences
raw
encoded
fread
jerding
madeline
fprintf
garbage
balanced
roychoudhury
abhik
decaf
neville
automa
elbaum
fopen
symbols
object
alessandro
sigplan
compacts
bcd
exit
encode
rules
tails
collapsed
repetitive
tour
subsequences
prof
threads
invocation
self
notes
invariants
ate
layer
spot
building
monitor
synchronization
leaks
hooks
tail
executions
profiler
sol
calling
compacting
larus
mary
looked
jvm
binaries
emit
steven
meaningful
usage
jones
postprocessing
alternation
selection
loop
events
working
loops
executables
statistics
parenthesis
collecting
james
shanghai
executable
attempting
associations
wolf
instructions
bug
engineering
opening
jean
arcs
sebastian
statistic
ddbcdc
threadnames
jinlin
thisisof
intermingling
balsa
renieris
thirumalesh
bhardwaj
smartic
fscanf
flexibil
langevine
hamiltonianb
ramaprasad
abbbbbbbbbcd
tmerge
fwrite
webserver
abbbc
jvmpi
tmon
gaines
knightsolution
thenencoded
viggers
andasetoffinalstatesf
ankit
knighttour
aaaabababc
levelcalcompaction
shashank
jited
jinsight
findrestoftour
knightstour
lorenzoli
perracotta
mariani
liblit
thefirstd
dallmeier
knightsquareinfo
anslow
tree
unbalanced
closing
ba
trace data
run length
length encoding
various encodings
first argument
call tree
trace files
software engineering
self loop
dag node
deployed software
selection techniques
dynamic call
software visualization
middle layer
state q0
sequitur algorithm
balanced rules
files contain
immediate repetitions
k tails
k tail
sequence encoding
trace file
acm sigsoft
compaction techniques
raw trace
p reiss
program executions
steven p
original nodes
self loops
encoding techniques
state automata
engineering notes
sigsoft software
notes v
program execution
alessandro orso
execution data
per thread
program paths
jean harrold
mary jean
finite state
non garbage
contain records
solving memory
visualizing reference
resultant grammar
called address
compaction selection
allocate free
emit records
gprof 9
automa ton
java trace
find immediate
orso james
jones mary
d bcdc
call sequences
string compaction
sequence abbbbbbbbbcdddbcdc
spot checks
neville manning
encodings especially
resultant automata
basic algorithm
engineering p
thread run
jerding et
function invocation
calls function
program trace
analysis driven
program evolution
support program
synchronization object
library usage
generated rules
debugging p
driven debugging
data compaction
discovering likely
class correctly
visualization june
extreme one
discovering models
elbaum madeline
layer closest
visualizing interactions
x q
java programs
acm sigplan
generating java
dynamically discovering
abhik roychoudhury
class selection
sebastian elbaum
program invariants
likely program
common subsequences
becomes interesting
second modification
post processing
may 23
sensitive profiling
memory leaks
generating sequences
collecting data
run length encoding
knight s tour
data for deployed
compaction and selection
dynamic call tree
program execution data
steven p reiss
finite state automata
software engineering notes
engineering notes v
acm sigsoft software
sigsoft software engineering
mary jean harrold
entry and exit
conference on software
repetition of b
jones mary jean
generating java trace
one per thread
patterns for solving
degree of compaction
java trace data
sequence encoding techniques
visualization of program
deployed software proceedings
java and c
building the automaton
calls function b
find immediate repetitions
patterns and code
thread run time
alessandro orso james
working with patterns
leaks in java
limitations of gprof
c 3 d
one is attempting
solving memory leaks
visualizing reference patterns
function a calls
want our models
discovering likely program
event based data
driven debugging p
invariants to support
symposium on automated
jerding et al
sebastian elbaum madeline
b c 3
dynamically discovering likely
processes from event
interactions in program
suite of tools
likely program invariants
analysis driven debugging
would be encoded
automated analysis driven
support program evolution
james a jones
visualization june 11
software visualization june
working on developing
would be mapped
whole program paths
sixth international symposium
use the class
written in c
september 19 21
automaton that accepts
counters with flow
exploiting hardware performance
context sensitive profiling
software engineering p
build a model
value of k
hardware performance counters
flow and context
