bin
subdesign
isabelle
circ
ci
cla
tac
tactics
veritas
bus
lsout
lsin
eqout
eqin
subgoal
spec
tactic
grout
synthesis
grin
adder
subgoaling
metavariable
clas
circuit
port
bitless
bitcomp
div
compcells
nat
validation
circuits
subdesigns
sat
imp
subgoals
hol
reinterpretation
carry
rules
instantiated
formal
args
nnat
busses
lambda
aux
reveal
specification
ls
parameterized
resolution
quantification
synthesize
library
signature
join
subparts
thm
prover
designs
logic
ports
quantifiers
eq
induction
constructors
comparator
propagate
metavariables
rule
bit
implication
lookahead
datatype
elims
9dec
dels
bitcomps
nmod
proving
goals
methodologies
gates
existential
theories
definitions
bits
wire
specifications
metalogic
tifiers
validations
build
decompose
discharges
elide
hi
inside
unify
voltage
verification
proofs
recursive
concrete
ands
combinational
claim
unification
gr
digit
standing
conjunctive
style
automate
incoming
ripple
ex
hardware
intro
wiring
entails
str
digits
synthesized
kent
quantified
compatible
abstraction
conjunct
quan
monadic
abstractions
claimed
development
split
behavioral
conjunction
methodology
adders
supports
parametric
incrementally
instantiating
connectives
decomposes
xor
outermost
clearer
bitlesss
isabelles
simplifiers
reinterpret
reinterpreting
carrys
pitm
compcell
fourman
wires
correctness
instantiate
founded
achieves
comp
simplification
synthesizing
builds
co
logics
calculus
def
interactive
hooked
reinterpreted
metavari
reuse
hypothesis
tm
reasoning
val
burden
axiomatizes
orem
induct
propositional
afterwards
bin bus
bus n
formal synthesis
g ci
b bin
p g
bin ci
p bin
g bin
bin g
ci bin
design goal
n div
div 2
design theorem
grin eqin
eqout lsout
grout eqout
clas n
eqin lsin
sat clas
ci sat
proof state
cla n
b grin
order resolution
bin cla
lsin grout
lower n
subgoaling function
definition context
original goal
n b
higher order
incoming carry
specification spec
first subgoal
n p
order logic
nat b
propagate bit
new subdesign
port values
b nat
nnat 1
use isabelle
bin ex
generate bit
validation functions
carry c
set theory
spec 2
spec 1
binary values
lookahead adder
carry lookahead
args subdesign
library tac
design tac
n nnat
concrete technology
claim tac
subgoal 1
reveal tac
lambda system
clas k
x bin
apply rules
values induction
goal spec
subdesign tac
specification entails
bus cla
cla k
case analysis
lower upper
logic programs
design goals
part args
validation rules
synthesis based
bin b
synthesized circuit
based synthesis
theorem prover
resolution based
derived rules
main design
proof rule
new techniques
induction hypothesis
original design
existential quantification
context h
achieves spec
bin n
internal wiring
bin g1
bin p
bin p1
tactic discharges
eq lsin
synthesis style
tac dels
bin bus n
b s p
p g ci
n a b
g bin ci
p bin g
bin g bin
bin ci bin
n div 2
bus n b
n s bin
b bin bus
n b bin
n p bin
bus n p
port a bin
grout eqout lsout
grin eqin lsin
g ci sat
ci sat clas
lsin grout eqout
eqin lsin grout
lower n div
bin cla n
b grin eqin
sat clas n
ci bin cla
higher order logic
compcells a b
higher order resolution
k a b
nat b nat
rules and tactics
carry lookahead adder
bin b bin
bin bus cla
entails the original
nnat 1 port
theory of higher
n nnat 1
ci a bin
bus cla k
isabelle s hol
sat clas k
course of values
kinds of reasoning
spec 1 spec
incoming carry c
using higher order
ls y lsout
reinterpretation of formal
bin c1 bin
args subdesign args
args library part
gr bin eq
definition context h
tactics that automate
g ci 1
synthesis in isabelle
tactic based theorem
div 2 nmod
library library tac
adder from two
circ achieves spec
div 2 lower
split the subgoaling
extends the signature
reveal reveal tac
bin x bin
g ci port
relations where existential
isabelle s theory
propagate and generate
veritas validation rules
build a circuit
div 2 b
h has become
library part args
eq eqin eqout
analysis over binary
bin ls bin
bit width n
hol set theory
resolution based synthesis
spec the validation
abstractions and concrete
isabelle s metalogic
original design goal
x bin y
following proof state
bin eq bin
isabelle s set
bin g0 bin
goal is given
using a previously
lambda style design
b lower n
ci bin n
initial design goal
construct a parameterized
following design theorem
bin p bin
induction is used
