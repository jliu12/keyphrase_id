banks
register
bank
srg
asips
registers
mst
spam
vsr
instruction
uncompacted
move
live
mac
assignment
coloring
alu
memory
allocation
compiler
compacted
color
gpps
spanning
optimized
compilation
dual
decoupled
asip
mov
agu
gsr
reg
code
colored
splitting
temporaries
mpy
instructions
compaction
operand
heterogeneous
dsp
merging
word
motorola
processors
ranges
regk
msts
mpya
coupled
benchmarks
embedded
phases
operands
compilers
targeting
referenced
retargetable
allocated
name
uncolored
temporary
speedup
visitors
jl
unmarked
assigned
subgraph
memories
nonconflicting
guthaus
mpyr
jlgjv
orthogonal
architecture
marsman
dasika
convolution
xiaobo
homogeneous
assembly
generation
simultaneous
senger
sharon
signal
od
op
ravindran
buses
files
multiplies
physical
phase
hsuan
names
shifter
partition
modes
dsps
mahlke
homogenous
subgraphs
digital
addressing
compacting
meet
tree
architectures
ratios
jv
conventional
spilling
eu
ganesh
automation
reference
heuristic
mainly
nodes
merge
spill
compiled
sparc
inevitably
rajiv
classes
sr
binding
suites
weight
jej
moves
priority
zhong
microsystems
opposed
comparative
twelve
todaes
cycle
marked
exploiting
incresing
xdb
coros
banerji
incapability
crunching
mwp
ydb
grwal
multibank
studie
xyn
architectre
pinedspcore
memory banks
memory bank
bank assignment
register class
parallel move
name splitting
register classes
dual memory
code generation
move x
graph coloring
data memory
live ranges
register assignment
y memory
multi memory
hand optimized
optimized code
uncompacted code
register allocation
code size
class allocation
heterogeneous registers
simultaneous reference
spanning tree
mac r3
move high
mac r0
e r4
f r5
maximum spanning
non orthogonal
physical registers
live range
coupled approach
dual data
instruction selection
c r2
data alu
banks x
address alu
spam code
compacted code
signal processors
code compaction
register architecture
x r1
generation phases
color v
d r3
compilation times
digital signal
coloring algorithm
y b
y colored
reference graph
motorola dsp56000
v move
compiler optimized
b y0
x color
reference allocation
y color
decoupled approach
b r1
heterogeneous register
alu operations
compilation time
op code
mst algorithm
processors code
embedded processors
two data
different memory
resulting code
output code
low w
high v
w move
high w
y r5
low r2
high r5
high r2
x r0
partitioned memory
next visitors
convolution complex_multiply
move conditions
reg j
conventional graph
x memory
visitors q
exploiting dual
entire variables
c r6
add r2
add x1
mov x
mpy x0
e r8
low r5
y r4
coloring approach
instruction word
assignment algorithm
data path
machine instructions
memory bank assignment
data memory banks
register class allocation
splitting and merging
maximum spanning tree
dual memory banks
mac r0 r1
mac r3 r4
dual data memory
hand optimized code
graph coloring algorithm
digital signal processors
code generation phases
different memory banks
code in figure
multi memory bank
x a x0
nodes in vsr
b r1 move
y b y0
f r5 mac
memory banks x
simultaneous reference graph
multi memory banks
bank assignment algorithm
two data memory
variables to memory
x and y
graph coloring approach
v move high
d r3 mac
compiler optimized code
parallel move conditions
d y1 add
uncolored node v
add r2 r6
y r4 y0
registers and multi
c r6 add
y d y1
e r8 move
y b r1
conventional graph coloring
c x1 y
convolution complex_multiply iir_biquad_n_sections
v in vsr
move high r5
x r0 x0
low v move
low w move
x c x1
move high r2
next visitors q
mpy x0 y0
w move high
add x1 y1
mov a x
assigned to different
non orthogonal architectures
simultaneous reference allocation
instruction selection phase
heterogeneous register architecture
memory bank asips
multiple memory banks
registers are assigned
processors code generation
register and memory
assignment of variables
spanning tree mst
generation for embedded
via graph coloring
centralized general purpose
y e r8
vsr of x
nodes than y
partitioned memory move
dual memory architecture
move r10 x
disjoint live ranges
optimized the uncompacted
