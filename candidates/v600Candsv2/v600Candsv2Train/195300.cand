spis
psc
speckle
spi
specifications
compiler
defineunique
unify
clu
discharge
lsl
checks
optimizations
abstraction
map
modifies
opportunities
specialized
invariants
specialize
guards
runtime
procedures
assertions
specification
clause
ac
insert
sim
cfg
spots
immutable
mchugh
intset
sites
iterators
clauses
proving
client
guard
mutable
hot
lp
dom
larch
ran
bugs
dynamicarray
supplying
debugging
wrote
commented
gypsy
substitution
compilers
equational
supertypes
modularity
postconditions
clients
calling
implementations
dawson
engler
nine
language
optimize
int
rep
abstractions
precondition
unsorted
eliminating
array
postcondition
discharging
elem
discharged
env
prototype
code
programs
diagnostics
checking
iterator
vars
subtypes
aliasing
implementor
tuning
undefined
objects
occasions
inefficiencies
compile
programmer
unacceptably
unfortunate
compiling
worked
merely
conjectures
formal
german
anna
axiomatic
ut
implications
languages
sound
unnecessary
places
caller
fmtv
addnode
insertpair
clobbering
grips
integerset
addnewnode
pclu
substitutiona
guttagg
unhappy
hisgen
ghemawat
interfaces
prover
incorporates
transformation
duplicates
rules
deduce
nil
pascal
supplied
optimizing
documentation
wishful
dorothy
intlist
fresh
garbage
abstract
mit
substitutions
commutative
interface
signals
detect
manual
mapping
sorts
deducible
internalizes
baden
sounder
overflow
understand
procedural
sigsoft
seven
heap
fications
lclint
reification
kathy
kohn
wolski
eliminates
propagating
lookup
effort
subsidiary
dsl
bets
mandated
griswold
decorate
mutations
ensures
null
avoids
logical
simulates
duplicate
unimplemented
yelick
plenty
horning
detlefs
vdm
primitive
examining
ac unify
map define
abstraction functions
map defineunique
theorem proving
low bound
partial specifications
runtime checks
mapping insert
runtime errors
psc uses
procedure specifications
map m
specialized procedures
m dom
proving technology
proof rules
dom d
program state
hot spots
use spis
modifies clauses
d ran
substitution store
eliminate runtime
unify psc
modifies clause
spi compiler
spi compilers
specialized implementations
contains clauses
data type
array bounds
formal specifications
calling context
lsl specifications
ran r
procedure call
domain element
general one
compiler must
call sites
client code
transformation rule
prototype compiler
improve program
abstraction function
programming language
clu reference
env contains
ensures defines
dual implementation
spi eliminates
high bound
ut interactive
insert last
defines r
exploiting specifications
representation invariants
clu 14
call iterator
subtypes etc
define map
exists specialize
make programs
using spis
checking languages
provide diagnostics
six kinds
m ensures
tuning performance
ran map
requires clause
duplicate vars
checking nil
null ran
specifications worked
bound check
lookup map
explained merely
specialized implementation
code map
modifies m
rep insert
procedure say
significant opportunities
interactive prover
procedures psc
optimize p
signals exists
r ran
nil checks
psc could
index low
source language
m figure
worked well
may exhibit
program performance
using psc
vars figure
bounds checking
defined abstract
generalized approach
procedure specification
iterator call
e int
seven lines
general implementation
program documentation
verified programs
specialized procedure
implementation of map
guards of spis
map m dom
m dom d
image of d
theorem proving technology
undefined in m
discharge the guards
d ran r
ac unify psc
building a compiler
p s implementation
eliminate runtime checks
merely by examining
dom d ran
d in m
lines of commented
d is undefined
examining the code
opportunities to use
choose the appropriate
improve program performance
specifications of procedures
absence of runtime
defined abstract data
set of proof
may exhibit behavior
specialize when index
need to trade
modifies m ensures
map define map
make programs run
specialize when d
guards of specialized
approach to equational
uses the abstraction
assignment procedure call
ut interactive prover
clu reference manual
specifications worked well
map lookup map
bounds checking nil
functions and invariants
compiler would detect
procedure call iterator
specifications can make
low bound checks
spis to reduce
verifying the absence
last s e
clause which states
go about building
call iterator call
use of spis
code from verified
towards the generation
invariants and abstraction
assignments from supertypes
optimization of user
bound checking languages
interface for maps
checking nil checks
spi of mapping
specifications to improve
partial specifications worked
supertypes to subtypes
optimizations in ac
rep insert last
performance that cannot
ensures defines r
m ensures defines
duplicate vars figure
define map m
lines to state
signals exists specialize
detect all opportunities
index low bound
optimizing array bound
cannot be explained
used in p
array bounds checking
advantage of information
programs run faster
user defined abstract
conference on domain
merge and loop
debugging and performance
basis for computer
dawson r engler
pre and postconditions
look at optimizing
tools for formal
defined in m
code that uses
built a prototype
