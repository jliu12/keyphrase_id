lg
hashing
buckets
bucket
hash
keys
injective
active
cell
crcw
pram
dominant
probability
doubly
dietzfelbinger
heide
oblivious
lookup
injectively
collision
concurrent
matias
iteration
auf
bits
processors
hashed
processor
allocation
dictionary
ptr
block
balancing
exponential
meyer
sorting
omega
memory
iterations
template
vishkin
koml
injectiveness
failures
read
tolerant
szemer
universe
inactive
random
distinctness
deactivated
allocated
fredman
der
sector
failure
array
edi
sectors
colliding
collided
leaders
decrease
robust
uniquely
election
load
inequality
stage
lemma
hx
reallocation
designated
succeeds
acknowledgement
fail
qrqw
gammaeq
congestions
selections
stirling
gammaffl
collide
successful
markov
gil
decreases
blocks
deactivation
os
expectations
randomized
mapped
probabilistic
collides
deactivate
perfect
inductive
key
ji
luby
prams
polynomial
standing
rate
selected
successfully
pairwise
priority
consumes
paradigm
estimates
corollary
participate
implementations
contents
jr
selects
beginning
crux
sufficiently
logarithmic
randomness
attempt
kt
auxiliary
select
relies
wigderson
records
weaker
imposes
mt
karp
query
induction
universal
fi
lb
chebyshev
succeeded
moment
mapping
selection
hy
contention
consumed
membership
insertions
representatives
allocate
priori
idealized
mappings
hagerup
gammail
rohnert
reallocations
garble
ffie
ercw
searching
queries
carries
wrap
demanding
circumvent
speedup
failing
copies
careful
private
iterative
nge
bast
incomparability
uzi
suffix
convexity
supports
visits
mostx
curiously
jerrum
singe
splits
fraction
simulations
binomially
broadcasting
conflicting
lg n
lg lg
o lg
active buckets
dominant probability
n dominant
hashing algorithm
n lg
memory block
hashing step
hash function
parallel hashing
lg u
hash functions
active keys
exponential rate
hash table
hashing problem
random bits
key x
level 2
fact 2
doubly exponential
oblivious execution
concurrent read
n time
allocation step
constant time
level 1
bucket may
algorithm template
memory blocks
der heide
meyer auf
crcw pram
auf der
o n
active key
injective level
multi set
high probability
memory cell
load balancing
level hashing
active elements
concurrent write
lemma 5
dictionary algorithm
uniquely select
balancing algorithm
n processors
hashing scheme
random words
integer sorting
constant probability
u bits
polynomial hash
perfect hash
expected time
second stage
n iterations
leaders election
exponential decrease
u random
fredman koml
auxiliary hash
edi 16
uniquely selected
p lg
size k
remain active
n keys
hashing algorithms
array ptr
lg m
memory used
processor j
using n
koml os
active bucket
linear size
running time
element distinctness
problem size
level scheme
robust model
szemer edi
total memory
input set
corollary 2
bucket size
lg lg n
o lg lg
n dominant probability
lg n time
number of active
o lg n
level 2 hash
doubly exponential rate
n lg n
lg n lg
number of buckets
n lg lg
level 1 hash
level 2 function
number of random
lg n iterations
g t x
level 1 function
auf der heide
meyer auf der
beginning of iteration
time with high
injective level 2
lg lg u
parallel hashing algorithm
buckets that fail
o n lg
block of size
number of keys
corollary 2 3
lg u bits
find an injective
load balancing algorithm
rate of decrease
using n processors
array of size
select a block
polynomial hash functions
szemer edi 16
u random bits
o lg u
p lg lg
failure the bucket
n random words
lg n omega
lg u random
fredman koml os
hashing by oblivious
matias and vishkin
auxiliary hash table
select a memory
fail to uniquely
markov s inequality
fail to find
os and szemer
m t m
dietzfelbinger and meyer
selected at random
buckets of size
fact 2 2
size o n
lemma 5 7
lg n random
least t 4
lg n expected
m t active
lg n 3
active key x
u the hashing
selected a block
