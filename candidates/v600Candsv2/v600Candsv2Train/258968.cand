specialisation
mlet
specialiser
residual
static
monad
specialise
runm
interpreter
void
ref
references
specialising
specialised
lift
metalanguage
store
typed
eval
monadic
ml
moggi
specialises
env
num
specialization
erasure
constructor
interpreters
evaluators
imperative
calculus
int
lambda
rules
evaluator
contents
poly
univ
hughes
unification
formedness
binding
specialisations
specializer
autoprojection
languages
spec
quasimonad
dummy
eraser
dussart
closure
delimiters
reference
thiemann
statically
effects
constructors
tuple
simplifications
polyvariant
monads
tags
offline
laws
algol
redexes
language
lazy
vl
unfolded
fun
meta
ole
isomorphisms
prompts
functional
updatable
arms
constructs
awkward
untagging
typedness
monovariant
schism
typing
syntax
closures
programs
expressions
hatcliff
laziness
partial
recursive
symbolic
chalmers
self
inference
thread
judgements
interpreted
primer
pure
online
dereference
simplication
semantics
propagate
post
sums
erased
freely
automatic
inspected
prompt
postprocessing
computations
stores
unfold
modify
dynamic
haskell
rf
threads
oe
embodies
suspended
optimally
pass
tagging
tells
propagated
discards
hvl
speciali
uninitialised
tofte
specialisaton
interpet
bechet
specialisers
liberality
dexes
liftv
iino
firstifying
poy
hagiya
pseudomonads
beforehand
escape
tuples
assignment
deferred
modular
law
arity
simplification
style
passing
communicated
grams
annotations
swadi
kedar
kiselyov
soluble
specialisa
raiser
glossed
feat
launchbury
heine
formers
postprocessor
blunt
ads
ceptions
assigned
created
discipline
checker
wanting
carded
pasalic
polyvariance
memoized
mads
emir
constrast
afterwards
universal
sept
residual type
type specialisation
partial evaluation
static store
specialisation rules
residual types
optimal specialisation
static state
void erasure
mlet x
residual program
static references
self interpreter
eval env
mlet r
residual programs
r ref
type specialiser
specialisation time
class references
oe ml
static information
lambda calculus
static part
mlet z
case eval
computation type
runm e
dynamic function
imperative languages
partial evaluators
static reference
dynamic references
partial evaluator
binding time
residual term
num int
dynamic part
static sum
static function
empty static
computational metalanguage
computational lambda
evaluation order
static values
two level
monad laws
dynamic state
meta language
first class
ref 2
standard partial
num lift
dynamic functions
store passing
formedness conditions
sum type
type m
well formedness
symbolic values
monadic operations
type tags
reference operations
constructor specialisation
dynamic store
type ref
different static
post processor
residual code
languages automatic
run time
automatic autoprojection
well typed
dynamic reference
functional languages
time analysis
dynamic let
env e1
residual computations
mlet v
lazy interpreter
explicit store
mlet y
propagate static
second monad
store prompts
poly e
lift 2
env e
constructor specialization
static stores
void eraser
higher order
type inference
recursive equations
achieve optimal
dummy value
universal type
order explicit
interpreted language
static computations
spec e
x e1
strongly typed
online partial
different residual
local references
type 3
dynamic conditional
represent values
mlet r ref
operations on references
first class references
rules for static
moggi s computational
computational lambda calculus
case eval env
binding time analysis
empty static store
achieve optimal specialisation
well formedness conditions
j and mlet
static sum type
residual type 3
e 0 figure
static and dynamic
rules for store
eval env e1
references are created
r ref 2
mlet z r
mlet x e1
calculus with first
e of case
values in partial
interpreter for oe
explicit store passing
store is known
different residual types
evaluation of imperative
standard partial evaluation
propagate static information
evaluation order explicit
dussart and thiemann
eval env e
languages automatic autoprojection
typed lambda calculus
constructs the residual
computation may modify
dynamic the specialisation
must write mlet
reference can hold
store passing style
residual type records
rules for dynamic
apply this specialiser
value encoding using
able to specialise
mlet z e1
type tags would
residual types 1
computational metalanguage ml
encoding using alternative
decisions are taken
rule for runm
using alternative values
types at different
types we could
aspects of specialization
typed self applicable
