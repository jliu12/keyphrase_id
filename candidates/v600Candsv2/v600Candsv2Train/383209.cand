scrambling
query
runnable
scrambled
joins
tuples
plan
blocked
join
unavailable
plans
operators
subtree
unscrambled
response
materialized
phase
queue
iterator
remote
selectivity
joinable
relations
delay
materialization
selectivities
sources
hash
iteration
delayed
optimizer
delays
queues
operator
site
arrive
materializations
materializing
seconds
joined
volcano
begun
disk
materializes
ancestors
mermaid
discovered
tree
unexpected
unavailability
maximal
grey
relation
materialize
initiated
amsaleg
simulator
arrival
congestion
consume
subtrees
consumer
variability
execution
sigmod
arrived
scheduling
partitioning
experiment
partitioned
database
databases
charges
unblocked
hab
paques
dskpagesize
netbw
numdisks
netpagesize
leftmost
hide
arriving
calton
gruser
raschid
louiqa
haridas
costly
heterogeneous
instr
requested
created
unary
terminates
iterations
henrique
vms
rdb
jaidev
costs
sensitivity
os
ooi
client
ongoing
invoked
bursty
laurent
disco
reordering
imposes
tomasic
creates
queries
optimization
bushy
nected
beng
complimentary
shipping
multidatabase
rooted
checks
consumed
schedule
sites
memory
synthesizes
initiates
stops
scan
overhead
requesting
hd
negate
pu
hc
cartesian
hou
sec
franklin
resumed
decisions
attribute
width
scenario
qiang
vladimir
record
dashed
iterates
topmost
alon
benefits
phases
iteratively
entirely
slower
sensor
create
cope
bytes
creation
inputs
producer
switches
peer
tradeoffs
runtime
varying
beneficial
caching
inserted
hides
partitions
discovers
statically
contention
ling
pipelined
oper
xprs
pratik
goraczko
query plan
phase 2
runnable subtree
phase 1
query tree
scrambled query
response time
plan scrambling
query execution
scrambling algorithm
maximal runnable
query plans
query optimization
runnable queue
query scrambling
new joins
query processing
new join
unscrambled query
runnable operators
scrambled plans
data sources
blocked operators
iterator based
relation b
remote sources
dynamic query
response times
remote data
original query
unavailable relation
another iteration
large memory
blocked queue
blocked queues
scrambled plan
unexpected delays
query start
query optimizer
new operators
third iteration
memory case
wide area
execution site
unavailable data
initial requested
created joins
requested tuples
selected tuples
grey line
runnable queues
normal iterator
execution plans
previous experiment
base relation
small memory
delayed data
first join
initial delays
useful work
relation g
distributed query
memory varying
remote source
build hash
iterator model
static query
expensive joins
various delays
different selectivities
call query
runnable sub
join created
d e2
requesting tuples
join attribute
joinable relations
based scheduling
record v
sigmod record
hash table
distributed sources
delay sec
initial exploration
query plan scrambling
scrambled query plans
maximal runnable subtree
remote data sources
blocked and runnable
queue of blocked
queue of runnable
scheduling of operators
runnable and blocked
dynamic query optimization
begun to arrive
query execution site
iterator based scheduling
number of tuples
scrambled query plan
initial requested tuples
f and x2
times of scrambled
benefits of scrambling
normal iterator based
rooted at operator
iteration of phase
query execution plans
original query plan
start up time
shows the response
iteration is initiated
sigmod record v
tuples of relation
result of c1d
switches to phase
phase 2 starts
runnable sub tree
tuples from remote
joins it creates
sensitivity of phase
memory is large
build hash table
response time problems
receiving the initial
phase 2 may
times more tuples
large memory case
first join created
enters phase 2
acm sigmod record
adaptive query processing
optimization and execution
distributed query processing
wide area environment
