experiment
developer
prototype
development
monitoring
prototyping
day
queueing
prototyped
spent
people
days
weekend
waiting
processes
blocking
progress
developers
instrumentation
analyses
reconstructed
effort
wolf
working
arc
tasks
category
developments
rework
vacation
statemate
daily
librarian
sampling
software
repeatability
monitor
cook
hardware
feature
trinary
guindon
activities
designer
jonathan
interact
waterfall
reworking
agile
arcadia
conjectures
emphasis
blocked
rewriting
plot
oth
tame
experimenters
menu
weekends
reproducibility
categorizations
discovers
training
basili
productively
enacting
sojourn
intermixed
lengthy
things
inception
automating
alexander
unassigned
strands
morning
documentation
inventory
afternoon
intrusive
accuracy
gather
factors
document
organizations
wait
laboratory
interactions
feedback
maturity
inefficiencies
project
management
productive
perry
understood
person
pvm
experimentation
coding
spending
spend
teams
developing
engineering
tool
seven
intriguing
measurement
weiss
intervals
organizational
guided
gaining
tosem
prevalent
task
sampled
resolves
interference
diagrams
categories
understand
amadeus
damiani
interwoven
intentis
feich
retrospection
elicits
workday
librar
muerl
kellner
misinterpret
accreted
austen
scacchi
gianini
shiou
schedulebehaviour
cmpan
fredericks
prototech
unflagging
oquendo
notebooks
tinkering
livesey
articulator
barshefsky
hone
colombo
experience
lack
managing
notes
percentages
engineer
consult
modeling
manufacturing
kinds
representative
feature development
software process
process monitoring
monitoring experiment
software development
development processes
development process
queueing network
figure 1a
long term
software engineering
figure 1b
e cook
prototype experiment
hardware designer
design component
scale long
alexander l
experimental design
blocking factors
l wolf
reconstructed data
jonathan e
time spent
software developer
subsequent experiments
feature developments
development interval
term effort
guided software
weekend data
cook alexander
wait oth
making progress
spent waiting
designer figure
engineering laboratory
software processes
large software
states represent
new design
experiment finally
much time
state categorizations
network map
point plot
tame project
empirically guided
lead engineer
sampling tool
process virtual
represent long
spent productively
term development
fold waiting
estimating average
minus two
lengthy processes
auxiliary step
previous days
seven plus
oth category
actual experiment
metric driven
rewriting documentation
prototyped development
analyses represent
developer decides
measurements little
development task
reducing costs
systems managing
development data
represent results
production intervals
development management
inventory measurements
kind size
tool presents
enabling empirically
term efforts
using inventory
efforts spanning
several years
process models
various aspects
cost precision
representative process
arcadia environment
feedback systems
environment architecture
library figure
average production
process development
engineering processes
features concurrently
necessary auxiliary
prototyping effort
process monitoring experiment
time was spent
figure 1a arc
figure 1b day
feature development processes
scale long term
jonathan e cook
alexander l wolf
large scale long
new design component
cook alexander l
tasks and states
long term effort
guided software development
software engineering laboratory
lack of progress
task and state
unit of development
e cook alexander
large software system
software development process
law for partially
executing the process
term process monitoring
level of blocking
precision and accuracy
analysis and feedback
basili and weiss
features are often
managing the software
necessary auxiliary step
experience with software
library figure 1a
reworking the process
time spent productively
prototyping a necessary
process software process
process virtual machine
measurement and control
selected the tool
empirically guided software
percentages of time
reactive systems managing
prototyped development process
estimating average production
long term process
prototyping is often
enabling empirically guided
environment architecture representing
enacting the software
metric driven analysis
systems for enabling
repeatability and reproducibility
software process software
prototype the experiment
analyses represent results
hope to validate
using inventory measurements
hardware designer figure
use the discussion
term development effort
several features concurrently
intervals using inventory
tasks over time
partially observable processes
designer figure 1a
long term efforts
long term development
rework and rewriting
design and instrumentation
representing and enacting
average production intervals
term efforts spanning
wait oth category
understand the interactions
often a necessary
day the tool
inception to actual
years from inception
inventory measurements little
prototyping the experimental
production intervals using
represent long term
often the basic
development and analyses
