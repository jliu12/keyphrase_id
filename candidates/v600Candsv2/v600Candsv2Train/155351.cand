maple
kmaplek
strand
worker
pipe
obner
polynomials
manager
spol
fwd
polys
resultlist
inpoly
symbolic
expr
comp
sieve
parallelizing
inline
gr
parallelized
mvar
sumexpr
siegl
svar
mexpr
ys
producer
parallelization
speedup
consumer
int
conquer
par
mres
divconq
unevaluated
termlist
xs
workers
split
mcall
mlist
request
init
fun
shell
char
sequential
sps
parallelize
mode
compose
bases
interface
guard
programing
uspensky
tps
maplelist
resultexpr
fmexpr
schreiner
tdeg
exprlist
jrequest
testpoly
algebra
append
res
parallelism
rps
sends
foster
divide
additionally
io
calls
soon
prolog
sac
stream
gained
args
tmp
spawn
collects
tasks
parsing
balancing
linda
canceled
sequent
declarative
var
returns
flowing
strings
annotated
bp
porting
isolation
finished
generic
appended
pipeline
guards
portable
bosa
readlib
iltern
unifica
lynomial
yjys
resgjwork
mresg
basiselemente
nulldimensionalen
einem
dyna
expressi
restklassenringes
kuechlin
karoly
mittermaier
dings
buchberger
posso
lelizations
auffinden
jrs
groebner
fullfiled
xjxs
shellinput
polynomideal
thematics
parsac
paclib
boege
mically
balan
primitiva
list
algebraic
roots
print
kernel
libraries
symbolically
communication
looks
polynomial
ts
algorithmus
mana
fwf
loos
ced
query
garbage
processes
critical
filter
subproblems
front
recursive
eratosthenes
builtin
nach
zum
overtake
legible
statements
quick
declaration
channel
bodies
lor
todays
proc
user
shared
basis
overhead
tay
parallelizations
merger
grain
inherent
send
sent
gr obner
obner bases
symbolic computation
computer algebra
manager worker
init worker
parallelizing algorithms
split comp
parallel programming
par int
compose fun
arbitrary maple
language strand
par list
bases algorithm
algebra systems
generating new
n workers
ys fwd
worker scheme
io interface
parallel declarative
basis polynomials
maple list
maple variable
append spol
new critical
maple maple
generic divide
kmaplek system
recursive calls
input polynomials
char et
maple statements
root isolation
maple function
conquer algorithm
input values
new input
user interface
concurrent prolog
sequential computer
parallel symbolic
programming language
real root
procedure generates
individual terms
critical pairs
memory machine
parallelized using
parallel evaluation
producer consumer
shared memory
parallel tasks
linear speedup
may compute
flow synchronization
maple program
mode par
parts result
m mexpr
basis polynomial
strand variable
variable svar
siegl 1990
speedup gained
sequent shared
evaluated functions
uspensky procedure
maple int
sum expression
int resultlist
mexpr result
polynomials flowing
polys basis
since kmaplek
strand program
res mres
request mode
end sieve
quick parallelization
tps sps
sequential maple
procedure collects
independent sub
kmaplek program
worker approach
reduction processes
basis main
sub procedures
polynomial ideal
worker n1
int sumexpr
maple expressions
divide conquer
main inpoly
output par
kmaplek may
pair completion
result maple
result mode
mode split
processor sequent
top end
expr mexpr
combine int
basis polys
test polys
char 1990
calls unevaluated
intermediate filter
interface maple
y par
mvar svar
comp parts
pipe process
inpoly basis
taylor 1989
resultlist result
critical polynomials
base case
parallel computers
symbolic algebraic
high speedup
comp comp
y ys
procedures p1
x result
bases computation
worker n
consumer process
declarative programming
end process
progress report
gr obner bases
programming language strand
obner bases algorithm
computer algebra systems
parallel declarative programming
list to maple
manager worker scheme
sequential computer algebra
declarative programming language
real root isolation
algorithms for symbolic
char et al
divide and conquer
shared memory machine
main inpoly basis
var and returns
inpoly basis main
overhead for parsing
f x result
examples for solving
partially evaluated functions
equations by calculating
used for parallelizing
foster and taylor
generating new input
parallel programming system
split comp comp
independent sub procedures
sequent shared memory
result is sent
algorithms in symbolic
obner bases computation
strand variable svar
strand as well
algorithms in kmaplek
knowledge in parallel
polys basis polys
io interface maple
strand and maple
parallel symbolic algebraic
m mexpr result
sub procedures p1
problems in symbolic
method allows easy
purpose parallel symbolic
recursive calls unevaluated
critical pair completion
system for general
new input values
pipe for generating
comp parts result
int f x
processor sequent shared
new critical pairs
init worker n
input output par
using the manager
procedures p1 3
combine int resultlist
main procedure generates
comp comp parts
result mode split
manager worker approach
tested with respect
design of maple
data flow synchronization
dynamic load balancing
developing parallel algorithms
program looks like
interactive user interface
input and returns
used in symbolic
without any modification
computer algebra system
super linear speedup
computing the result
returns a list
systems of algebraic
parallel programming language
et al 1983
use the value
returns the result
general purpose parallel
see section 4
set of properties
