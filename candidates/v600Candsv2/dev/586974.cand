deque
steque
deques
pop
push
catenation
sf
inject
gp
prex
amortized
persistent
gs
eject
memoization
catenate
buers
pr
su
catenable
buer
okasaki
kaplan
green
uently
prexes
steques
tarjan
triple
noncatenable
overwriting
nonempty
ld
gr
rr
triples
node
rst
popping
persistence
pointer
reversal
red
secondary
gg
injecting
memoized
child
ended
aive
middle
xes
return
primary
lists
princeton
pointers
recopying
tarjen
jpr
md
stacks
dene
stack
skeleton
specically
purely
terminal
converts
inspect
simplies
rd
functional
list
nonterminal
bits
nodes
creates
calls
create
implementations
recursive
structures
elds
jsf
debit
confluently
sleator
tuple
ip
con
lisp
descendants
operation
middles
cdr
driscoll
uent
jpj
potential
redundant
undened
memoizing
pops
lazy
tuples
ciency
ve
sided
queue
ipping
double
excluding
representing
aviv
overwrites
queues
analogous
represented
columbia
paying
subcases
cons
saves
numbering
tel
heap
representations
functionality
charge
denitions
simpler
dened
worst
older
containing
haimk
persistant
subdeques
culminated
fiat
strapping
intertrust
nondestructive
hartline
sarnak
sunnyvale
csto
bottommost
replacd
simultanously
sioutas
cokasaki
replaca
fteen
recurs
devide
catenated
catenating
panagis
lagogiannis
sistence
subdeque
car
reversed
incremental
eects
pure
dietz
athanasios
amortization
precursors
esc
tsakalidis
spyros
goldwasser
haim
transiently
ques
boot
yannis
folowing
six
dominates
ow
bit
recursion
cient
su x
sf d
pr d
push pop
amortized time
deque d
pop inject
rst element
con uently
steque d
o 1
kaplan tarjan
uently persistent
child deque
purely functional
x sf
middle buer
amortized analysis
nonempty deque
md d
data structure
two elements
three elements
nonempty middle
constant amortized
double ended
tarjan structure
su xes
fully persistent
amortized cost
d 1
per operation
operations push
return case
case 1
takes o
new list
case 2
last element
prex p
n aive
prex pr
deque c
inject eject
using overwriting
pointer structure
six elements
green otherwise
green prex
x return
aive pop
persistent data
child steque
catenable deques
gr node
push takes
noncatenable deques
gg node
reversal bits
return p
c d
time bound
node representing
potential function
nodes representing
data structures
containing two
jpr d
ld 00
ended queues
new prexes
secondary node
prexes p
new secondary
kaplan c
structure presented
h kaplan
persistent deques
persistent catenable
new primary
e tarjen
c okasaki
ld d
amortized costs
d is represented
gp and gs
o 1 amortized
push pop inject
con uently persistent
x sf d
takes o 1
call to gp
inject and eject
su x sf
deque of triples
kaplan tarjan structure
operations push pop
nonempty middle buer
amortized time bound
gp or gs
d to form
deques with catenation
constant amortized time
order of elements
sf d 1
n aive pop
d by popping
elements in pr
call to pop
prex pr d
elements and green
prexes and su
popping the rst
call to push
create a su
push takes o
d and return
return a new
rst two elements
creates a new
o 1 time
nodes in states
case constant time
pr d 2
create two new
elements of sf
kaplan c okasaki
double ended queues
achieves an o
bound per operation
jpr d j
case 2 steque
element from x
let x return
child deque c
return case 2
new list formed
push and inject
prex or su
okasaki and r
element on sf
structure of 10
green su x
inspect the rst
implementation of deques
converts a primary
x s containing
contains a nonempty
work the structure
pr d 1
making data structures
nonempty deque d
two new prexes
h kaplan c
injecting the rst
onto sf d
must be nonempty
stack of stacks
return the pair
r e tarjen
new prexes p
purely functional programming
rr and gr
dened above takes
