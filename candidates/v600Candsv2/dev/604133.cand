memo
memoized
memoization
mfl
mfun
mcase
dependences
quicksort
val
expr
mapply
consing
hash
letbang
memoizing
mks
branch
bang
letx
boxed
caching
res
expose
indexable
cons
programmer
rec
incremental
hcons
inr
ibang
unbox
marrow
blist
resources
calls
mqs
mfib
bbang
modal
semantics
fibonacci
fn
selective
inl
int
resource
tables
qs
pivot
lookup
judgments
recursive
fun
subtree
box
elimination
library
sml
spine
adaptivity
spines
nil
logn
modality
body
prod
ed
sigplan
ml
replacement
speci
return
ef
shallow
keys
deep
soundness
irl
boxlist
keyed
bind
ne
policy
lazy
equality
purged
monad
fil
datatype
insertion
usage
language
dom
nition
branches
expressions
pfenning
suf
dependence
modi
notices
syntax
davies
lists
identi
evaluation
tt
hashing
suspension
exposes
jbj
typing
checks
exploration
rst
intuitionistic
functional
alphonse
mfil
funval
acar
umut
fib
disposed
ineend
bangs
memoiza
susp
primitive
roll
binds
cache
injective
garbage
knapsack
static
nlogn
consulted
heydon
anatomy
ow
countable
attribute
sums
primitives
boxes
safe
lter
dynamic
else
list
neil
blelloch
judgmental
abadi
languages
automating
key
index
dependencies
outcome
fz
conventional
tabulation
nitions
mf
stores
locations
copy
programs
returned
stored
pugh
rerun
returns
tracking
recording
effects
reuse
ks
acm
safety
benign
disregarded
monadic
guy
dif
memo table
memo tables
hash consing
memoized function
mfun rec
selective memoization
memoizing semantics
caching scheme
underlying value
modal type
non memoizing
memoized version
recursive calls
memoized quicksort
cons h
result re
incremental computation
boxed lists
quicksort algorithm
letbang expose
b sum
index function
case unbox
v s0
b marrow
unbox l
memoized functions
val val
elimination form
non memoized
time checks
val mapply
local dependences
data dependences
indexable type
c expr
nil nil
function caching
b expr
type system
re use
replacement policy
re used
dynamic programming
expected o
resource free
blist box
sml library
correct usage
b prod
expected constant
res b
return fn
nite function
q l0
bang type
fibonacci function
o logn
functional language
acm sigplan
calls whose
new key
input list
left subtree
elimination forms
non local
whose results
control ow
right subtree
let construct
speci c
hash tables
ow information
incremental exploration
sum val
expr val
stored value
else v2
memoized code
precise dependences
mfun hcons
via function
fz z
current memo
mfl language
ibang c
indexable types
performance effects
mapply mks
space management
outer form
mapply f
term context
table lookup
memo functions
adaptive functional
incremental attribute
marrow val
memoized fibonacci
space usage
de ne
sigplan notices
program analysis
non memoizing semantics
result re use
case unbox l
subtree of p
run time checks
let and mcase
calls whose results
type a res
modal type system
expected constant time
semantics of mfl
non local dependences
l of cons
memoization and adaptivity
rules for deriving
p in q
type a b
control ow information
lookup or update
computation via function
memoized quicksort algorithm
control over equality
cost of equality
results are re
y or z
adaptive functional programming
h t let
soundness of mfl
injective function called
b marrow val
e e v
memo table lookup
extends the branch
applies the body
called the index
current memo table
exposes the underlying
b sum val
key the memo
via function caching
standard non memoizing
res c expr
nil nil nil
incremental computation via
res b expr
l 2 dom
acm sigplan notices
pfenning and davies
allows the programmer
x is positive
inserting a new
introduction and elimination
sigplan notices v
sequence of integers
languages and systems
notices v 38
