processors
log
adversary
oracle
crashes
coordinators
failures
alg
balancing
processor
synchronous
failure
prone
tasks
attended
adv
coordinator
pram
crash
message
iterative
passing
load
simulations
unattended
specic
shared
phases
solves
round
omniscient
perfect
denition
alive
stop
bounds
seti
subcases
wn
ciency
shvartsman
rst
dene
teach
fault
rounds
lemma
tolerant
georgiou
chryssis
block
undone
solved
stops
progress
phase
chlebus
tids
jf
extant
doall
bcc
fail
views
restatement
utility
dened
consensus
pid
derivative
stand
adequately
kill
expended
analyses
certified
messages
quantity
leaves
surviving
byzantine
lemmas
matching
memory
pattern
tentative
existed
idempotent
moderate
simulate
pr
faults
tolerating
assess
induction
impossibility
cient
iteration
iteratively
stage
exceed
gathering
abstracts
establishes
task
performing
sent
fragmentable
flp
needlessly
worker
venerable
denitive
refute
pids
tings
homemyampersandmdash
fiterations
scratchpad
delphian
timeprocessor
ces
iterated
alexander
asynchronous
delays
multicast
faulty
dr
sensitive
whp
kills
crcw
unknowingly
dariusz
specics
kanellakis
minates
newest
asynchrony
rescheduling
tight
loads
patterns
deterministic
cooperative
loop
caused
mergeable
rolls
survives
strengthens
martingale
elucidated
supercial
denitions
ideally
idling
kowalski
landscape
ticks
colleague
traversal
eect
crashed
identier
uc
omni
totally
tells
cause
sketch
partitionable
russell
gossip
ine
fernndez
rened
assists
simulating
proceeds
stale
identiers
dissimilar
multiplicities
dependability
log p
p log
p f
log log
work complexity
f log
prone processors
failure pattern
shared memory
f p
n f
o n
algorithm w
load balancing
message passing
perfect load
crash prone
work w
message complexity
log n
algorithm simulations
r log
failures f
n tasks
n log
lower bounds
complete analysis
failure prone
synchronous shared
attended phases
r iterative
block step
block steps
progress tree
balancing assumption
log f
n p
p processors
stop failures
lemma 3
log b
r p
pattern f
local views
adversary adv
wn p
algorithm alg
p n
c p
memory model
passing model
failure free
best known
c log
unattended phases
processor algorithm
phase w3
failure patterns
steps b
memory models
f c
p lemma
b p
u p
one coordinator
n problem
processors perform
upper bounds
work o
memory algorithm
failure model
new bounds
two subcases
log c
r r
n processor
q p
f denote
c 0
cases case
fail stop
matching upper
fail stops
processor steps
undone tasks
n stand
f sensitive
f stop
synchronous processors
passing algorithm
processor crashes
p crash
p failure
f problem
local view
using work
r instances
complexity w
crashes f
theorem 3
r n
n note
p r
e ciency
complexity arguments
processors assigned
p log p
log log p
log p log
log p f
p f log
p log log
r p f
r r p
perfect load balancing
o n f
c p log
f log p
f c p
failure prone processors
p and f
log n log
log b p
f p r
p r log
f p log
b p f
load balancing assumption
crash prone processors
q p f
synchronous shared memory
number of failures
number of processors
shared memory model
execution of algorithm
p lemma 5
f log log
n p log
log p lemma
message passing model
n log p
f the number
shared memory models
log log f
round of r
number of crashes
failure pattern f
log c 0
bounds on work
shared memory algorithm
analysis of work
f p n
c log p
passing and shared
alg that solves
therefore the work
case as o
number of block
two cases case
cases case 1
n r r
analysis of algorithm
unit of work
range of f
number of processor
log log log
r n r
adversary that causes
jf j f
algorithms on failure
p failure prone
message passing algorithm
stop failures f
pattern with f
work complexity w
solved by running
algorithms on crash
u log p
least one coordinator
n f problem
case is b
log n p
failure model f
p log c
p crash prone
f when f
block steps b
o n note
log p therefore
depends on f
failure free processors
wn p f
synchronous message passing
f stop failures
log pr f
n log log
