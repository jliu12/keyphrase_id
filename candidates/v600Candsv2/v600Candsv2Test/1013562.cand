pebble
mso
pas
ras
pebbles
automata
ra
fo
string
automaton
hypersets
strings
1d
nlogspace
alphabets
hyperset
register
configurations
xml
erent
pa
francez
kaminski
configuration
2d
alphabet
pcp
registers
lmow
transitions
symbols
weak
accepts
delimiter
di
definable
alternating
undecidable
ga
emptiness
transition
lmo
accepting
symbol
head
parties
positions
universality
dialogue
membership
tape
alternation
expressiveness
infinite
languages
protocol
ptime
agap
accessible
monadic
strong
logics
reverse
accepted
logspace
position
gtm
reachability
lift
dom
placed
containment
deterministic
quantifier
logic
exp
expressive
party
successors
agent
closed
proposition
val
encodings
simulate
iw
dialogues
regular
syntactically
decidable
subsumed
labeled
variants
formula
vertex
quantification
encodes
erence
universal
kleene
dtd
segoufin
metafinite
etl
schwentick
adel
milo
equiped
globerman
formalisms
sym
walking
encode
sentence
messages
discipline
existential
trees
equality
harel
pebbled
vianu
suciu
transformers
xslt
subcomputations
yardstick
guesses
decidability
conjunct
closure
split
ph
tuple
inductively
stack
collapse
language
inclusion
theoretic
computable
lifting
gurevich
determinism
claim
incomparable
leftmost
stay
encoded
equip
assignment
recognize
finite
heads
occurrence
message
contradiction
dc
applies
encoding
star
depth
luc
lifts
unary
simulated
leaves
turing
nondeterministic
sweeps
checks
equals
ers
concatenation
formulas
express
undecidability
inclusions
rounds
accept
accessibility
completes
sends
liberal
numbered
web
quantifying
abbreviate
occurring
replies
sink
lifted
formalism
acts
enters
query
pebble automata
2d ra
reverse closed
infinite alphabets
di erent
q q
input string
1d pa
register automata
data values
1d pas
weak 1d
strong 1d
string w
u v
weak 1n
ga w
pcp instance
two way
second pebble
dom w
strong pas
state q
communication complexity
non emptiness
multi head
position l
d strings
automata models
decision problems
new pebble
theoretic assumptions
regular languages
p v
current symbol
head automata
ordered reachability
current pebble
2d ras
val w
weak pas
finite alphabet
v q
finite set
q u
transition relation
complexity theoretic
string u
pairs q
initial configuration
form u
place new
pebble assignment
stack discipline
u equals
n di
pebble model
k pebble
pa proof
mso formula
strong pebble
consider strings
split strings
lmo u
third pebble
register assignment
final configurations
finite alphabets
right delimiter
infinite alphabet
d symbols
standard decision
syntactically correct
x x
exp 2
communication protocol
non deterministic
one way
q 0
one pebble
initial register
x vertex
w l
current position
vertex x
monadic second
first position
finite memory
assume w
kaminski and francez
strong 1d pa
pebble is placed
u and v
complexity theoretic assumptions
form u v
weak 1d pas
weak 1n pa
p v q
hypersets over d
multi head automata
sets of configurations
input string w
set of states
q q q
hard for nlogspace
standard decision problems
x vertex x
ra is complete
n di erent
initial register assignment
string u v
based on communication
pairs q q
assume w l
set of symbols
monadic second order
l o g
w l o
b i 1
x x x
set of transitions
second order logic
v where u
d 1 2
represent a solution
pebble i 1
q q d
accepts an input
erent data values
lift current pebble
show that pas
notion of regular
b on w
show that universality
weak 1d pa
fo and mso
place new pebble
strong pebble automata
q 0 0
ras and pas
w a configuration
accepted by b
d that applies
finite memory automata
strings over infinite
register and pebble
concatenation and kleene
definable in mso
set of pebbles
x x vertex
k pebble automaton
defined in mso
q 0 q
