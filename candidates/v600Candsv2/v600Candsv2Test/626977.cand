tmr
rshw
rhwr
permanent
faults
voting
fault
failure
voter
redundancy
unsuccessful
faulty
probabilities
reconfiguration
rshws
voters
module
spares
modules
retry
nominal
recovery
failures
transient
phi
mnr
likelihoods
comparator
disappearance
modular
detection
fs
ovrs
ovr
occurrence
pdf
transition
km
policy
disagreement
ftmp
retries
switching
recover
triple
rollback
tolerant
vmp
microcomputer
votings
merger
markov
reliability
coincident
hardware
hours
inducing
omega
renewed
evolved
prior
fig
figs
oe
sm
transitions
spare
ij
disappear
checkpointing
chain
detected
resynchronizing
koren
watchdog
hagbae
pmn
task
recovers
detectors
bayes
kim
shin
multiprocessor
successful
nonfaulty
healthy
purging
effects
simplified
processor
simplex
replacement
caused
resynchronization
comparators
upon
restart
reload
eq
instruction
adaptive
reconfigure
resetting
overhead
buses
estimating
frequent
costs
simulations
execution
self
probability
spatial
infrequent
laplace
persistence
majority
manifest
rates
redundant
accurately
arrival
units
diagnosis
unlimited
occurrences
detecting
merged
kang
masks
likewise
tasks
allowable
occurred
estimated
prob
effective
mismatch
minimizing
ccoincident
redun
kolmogrov
kook
tfa
recoverying
jpl
rhwrs
chuck
dancy
collectors
naresh
triplicated
currence
metra
intercheckpoint
meissner
demerit
oereconfiguration
hasty
mmp
nonpermanent
byonghyo
shanbhag
cazeaux
transited
byung
mask
paths
tolerate
shift
tolerance
star
recovering
controller
recovered
erroneous
persistency
fij
hfa
daniele
rollbacks
cecilia
rail
standby
sojourn
hypercube
chip
hybrid
priori
update
gammaf
tmr failure
tmr system
permanent faults
non permanent
permanent fault
possible states
tmr failures
upon detection
task execution
unsuccessful rshw
time x
phi phi
system state
faulty module
modular redundancy
x f
triple modular
fault state
system reconfiguration
chain model
prior state
execution time
re execution
nominal task
expected cost
transition probabilities
fault states
tmr systems
spatial redundancy
switching operation
two voters
retry policy
omega omega
method 1
faulty modules
time overhead
markov chain
multiple module
voting policy
occurrence rate
rshw becomes
voting failure
simplified markov
tmr structure
voting interval
frequent voting
time redundancy
adaptive method
fault parameters
nominal execution
voter fault
rhwr based
transient faults
optimal recovery
possible fault
c ij
prior probabilities
state model
oe oe
method 2
transition matrix
bayes theorem
fault tolerant
failure detection
state probabilities
c vmp
module replacement
rshw upon
general rollback
unsuccessful rshws
module faults
x increases
one rshw
voting time
instruction retry
optimal voting
failure possible
path j
th voting
model fs
without estimating
failure increases
fault modules
fault detection
coincident faults
fs 1
fs 0
sub paths
re executed
prior states
fault occurrence
fig 3
type ii
self checking
transient fault
processing modules
expected costs
eq 3
p n
hardware cost
e gamma
rshw and rhwr
non permanent faults
task execution time
phi phi phi
time x f
cost of rshw
non permanent fault
markov chain model
nominal task execution
occurrence of permanent
execution time x
triple modular redundancy
omega omega omega
possible fault states
behavior of non
estimating the system
simplified markov chain
model in fig
number of unsuccessful
time of voting
nominal execution time
rshw or rhwr
number of spares
states at time
due to multiple
gamma 1 th
multiple module faults
caused the tmr
number of rshws
e gamma 2
increases with x
back off time
detecting a tmr
one faulty module
gamma 2 n
failure possible states
permanent fault modules
state model fs
tmr failure increases
rshw becomes larger
tmr failure detection
oe oe oe
units of time
p and r
x i2f2 5
x without estimating
detected and recovered
x f evolved
using triple modular
cost of rhwr
modular tmr multiprocessor
time and hardware
multi voting policy
type ii failure
c 1 k
ii and type
probability of permanent
re executed without
faults in different
costs of rshw
modular redundancy fault
