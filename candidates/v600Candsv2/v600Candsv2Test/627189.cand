primitive
garbage
symbolic
milliseconds
calculated
reversal
conditionals
cache
ecient
optimizations
recursions
nontermination
inputs
eciently
sort
heap
eects
cbleast
transformations
accurate
bounds
unknown
chez
alpa
insertion
underestimation
ca
programs
measured
loops
yanhong
accurately
symbolically
worst
allocated
merge
automatic
append
rosendahl
cleast
car
else
transformation
program
partially
summations
analyses
constructor
cons
paths
lifting
constructors
disabled
timing
enabled
loop
compiler
inx
synthesizer
language
sums
conditional
inlining
languages
branches
arguments
dierent
measurements
pipelining
bindings
incremental
terminate
counts
recursive
xxxxxx
ibonacci
vcbleast
incrementalization
varref
rst
depths
simplifying
analyzing
instruction
functional
inability
calls
bytes
liu
transformed
stony
sunysb
brook
recurses
conservatively
live
dicult
source
merging
subcomputation
ssl
lub
stoller
binding
union
lisp
measuring
optimizing
inecient
structs
ultra
annotations
collection
terminates
cdr
app
nonrecursive
meant
inaccurate
branch
conservative
optimized
sorting
evaluator
microseconds
syntax
automatically
tried
calculate
caching
accuracy
constructs
accommodate
schema
nil
cost bound
primitive cost
bound function
cost parameters
symbolic evaluation
bound functions
cost bounds
input size
bound analysis
known input
calculated time
partially known
garbage collection
calculated measured
time milliseconds
milliseconds input
size parameters
input structures
heap space
insertion sort
accurate cost
ca calculated
measured worst
original program
loop bounds
execution paths
worst case
collection times
cache enabled
list reversal
selection sort
cost function
language based
direct evaluation
set union
reversal w
collection time
sort calculated
space bounds
direct symbolic
time bound
merge sort
partial evaluation
cost parameter
case times
union list
measuring primitive
sort selection
merging paths
symbolic direct
cache disabled
evaluation takes
source program
cost analysis
variable reference
incremental computation
time analysis
closed forms
function calls
resulting function
ca 50
size calculated
constructing cost
simplifying conditionals
lifting conditions
chez scheme
approximate time
reversal reversal
w append
include garbage
cost functions
measured time
primitive operation
sort merge
actual running
example programs
given values
input structure
program analysis
function terminates
dierent operations
small inputs
sort set
synthesizer generator
system alpa
size insertion
paths automatically
value unknown
recursion depths
bytes allocated
accurate conservative
optimized symbolic
input sizes
else e
bounds automatically
cache eects
measured conservatively
level languages
source level
language level
language implementation
complexity analysis
source programs
source language
case execution
recursive function
resulting cost
symbol c
algorithm analysis
car x
space allocated
sizes 10
e 1
analysis results
cost bound function
primitive cost parameters
cost bound functions
partially known input
input size parameters
milliseconds input size
measured me ca
time milliseconds input
known input structures
calculated time milliseconds
cost bound analysis
ca calculated measured
measured worst case
else if v
garbage collection times
primitive cost parameter
time bound analysis
accurate cost bound
sort calculated time
garbage collection time
worst case times
methods and techniques
analysis and transformation
direct symbolic direct
insertion sort selection
v then e
symbolic direct symbolic
language based approach
sort merge sort
analysis with cache
inputs of sizes
measuring primitive cost
set union list
selection sort merge
sort selection sort
allocated for constructors
union list reversal
reversal w append
inputs of size
calculated and measured
source language level
bounds or execution
values of input
list reversal reversal
size calculated measured
include garbage collection
reversal reversal w
yanhong a liu
input of size
time or space
high level languages
dierent operations performed
execution paths automatically
conservative or approximate
prototype system alpa
optimized symbolic evaluation
subset of scheme
accurate cost bounds
e 2 end
automatic and accurate
heap space allocated
sort set union
merge sort set
conservatively or approximately
consists of transformations
e 1 else
machine with cache
programs on inputs
known input structure
might not terminate
symbolic evaluation takes
values of primitive
automatically and accurately
else e 2
evaluation and optimizations
size insertion sort
eciently and accurately
worst case execution
terms of primitive
analyses and transformations
evaluation of cost
time and space
takes as arguments
number of experiments
number of bytes
