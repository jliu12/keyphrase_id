evolutionary
wcet
sa
timing
categorizations
cache
fitness
generations
instruction
analyzer
caches
bcet
individuals
longest
population
testing
mutation
cycles
recombination
schedulability
loop
reinsertion
bubblesort
temporal
shortest
static
caching
loops
extreme
defense
mueller
hit
offspring
miss
execution
associativity
flow
predictions
railroad
gnat
kiran
preemptive
hardware
instructions
worst
trio
portability
loc
calculator
misses
calling
frank
permissible
chapter
simulator
deadlines
compiler
estimates
calculated
references
conflicts
systematic
matrices
stopping
seth
correctness
reproduction
uncached
benz
rotenberg
daimler
kaustubh
aravindh
anantaraman
instrumentation
genetic
gcc
electronics
datum
regard
risc
pipeline
harman
crossover
yifan
ipx
insufficiently
dfa
cles
patil
iterations
cy
multitude
program
cached
processor
prediction
afterwards
paths
optima
toolbox
cycle
generation
portable
confidence
software
assuring
edf
tighter
multiplication
examination
inner
simulation
safe
procedures
graphics
child
analytical
programs
matlab
recommend
executing
et
tester
coverage
logical
interrupt
quantify
thoroughly
overhead
fit
categorization
embedded
stopped
adjustments
optimum
timed
zhu
measurements
outer
diversity
pipelining
parents
header
procedural
nested
sys
configurations
selection
inversely
missed
conservative
addresses
deadline
categoriza
popula
expenditure
bination
retargeting
preheaders
vpcc
mandrioli
fittest
sporadically
regehr
creased
dasarathy
brylow
asymptoted
sibin
substantiated
mutating
decls
pohlheim
timum
vpo
binkley
brightest
dudani
execution times
evolutionary testing
time systems
timing analyzer
real time
longest execution
extreme execution
temporal behavior
execution time
evolutionary algorithms
static cache
timing analysis
static analysis
schedulability analysis
test object
timing constraints
loop level
case execution
control flow
test data
cycle level
temporal correctness
best worst
actual execution
cache simulation
flow information
cache simulator
frank mueller
test objects
evolutionary computation
shortest execution
best case
logical correctness
worst case
data flow
instruction categorizations
systematic test
timing tree
time environments
worst best
bubblesort algorithm
testing real
timing predictions
remaining associativity
associativity levels
input parameters
test methods
caching behavior
run times
cache behavior
path analysis
static timing
population size
evolutionary optimization
sa approach
testing et
test program
shortest run
calling structure
test datum
et approach
time determined
input situations
kiran seth
defense electronics
gnat gcc
function instance
times determined
discrete recombination
fitness values
address calculator
evolutionary algorithm
data caches
entire program
current work
instruction cache
data references
first miss
specified timing
existing test
analytical method
stopping condition
cache state
instruction caches
first hit
processor cycles
test programs
call graph
two methods
random testing
first misses
high fitness
driven software
mutation probability
since instruction
miss hit
analysis sa
cycles results
program lines
real time systems
extreme execution times
longest execution time
actual execution times
behavior of real
sa and et
number of generations
longest execution times
static cache simulation
case execution time
instruction and data
shortest execution time
shortest and longest
testing the temporal
method of static
worst best worst
static cache simulator
multiplication of matrices
testing real time
real time environments
remaining associativity levels
bcet and wcet
best worst best
control flow information
worst case execution
n a n
best case execution
static timing analysis
determined by sa
evolutionary testing et
execution time determined
case and best
execution times determined
shortest run time
executing the test
analysis and evolutionary
specified timing constraints
case execution times
provides the means
number of input
data flow analysis
obtain high fitness
calculated by sa
time environments may
temporal system behavior
actual running system
support for testing
use of formal
constraints of real
methods to verify
run times possible
timing constraints specified
within the control
important analytical method
test methods shows
afterwards the new
actual real time
extreme run times
static analysis sa
bottom up within
verify timing constraints
individuals are selected
execution times obtain
lack of support
development of real
method for assuring
