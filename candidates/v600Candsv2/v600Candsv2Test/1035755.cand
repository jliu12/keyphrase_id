token
processor
superstabilizing
superstabilization
legitimate
registers
fault
protocol
passage
circulation
stabilizing
stabilization
register
latent
mutex
transient
exclusion
faults
ring
predicate
mutual
unidirectional
rounds
lc
masking
round
legitimacy
processors
holders
minor
protocols
oe
faulty
bidirectional
critical
illegitimate
holder
writes
counter
nonmasking
convergence
corrupt
circulate
segment
counters
circulates
tokens
tolerance
waiting
dijkstra
correcting
cycle
inflicted
spliced
fifi
unidirectionally
latency
passing
handshake
ij
reconfigurations
trval
detectably
corrective
ffff
mask
recovery
impossibility
reads
interrupts
reading
ffi
splicing
writer
correction
lw
exceptional
fffi
read
infinitely
fields
containment
severe
self
atomic
tolerant
fiff
hive
holding
corrupts
toggles
multireader
spurious
fl
safety
subsegment
supervisor
fi
internal
major
sequel
program
refinement
simultaneous
strategy
appendix
executes
specifies
optimum
history
multivalued
contradiction
corruption
regular
segments
safe
execute
concatenation
tolerances
reactive
waits
lemma
layered
subsequent
detectable
reconfiguration
worst
injected
lg
observes
gamma
located
closure
contradicts
pr
ff
differs
encryption
stabilize
passed
asynchronously
liveness
subsection
understood
statements
voting
quantification
dummy
propagate
specification
unidirec
eiichiro
failstop
toshimitsu
enabledness
stabiliz
masuzawa
invalidly
crd
illegitimacy
dummies
affair
superstabiliza
bilizing
colocated
underscored
processor local
local fault
legitimate state
passage predicate
critical section
token circulation
mutual exclusion
minor token
major token
transient fault
superstabilization time
local faults
state oe
latent protocol
exclusion protocol
program counter
faulty state
processor zero
transient faults
token passing
superstabilizing protocol
token holders
token holder
mutex passage
perform critical
linear round
output registers
stabilization time
waiting strategy
input registers
processor j
program counters
internal variables
stabilizing mutual
n latent
computation starting
r ij
reading model
state reading
c variable
computation segment
token value
minor tokens
superstabilizing mutual
register protocol
superstabilizing protocols
legitimate states
o 1
processor p
processor step
two registers
token values
mutex protocol
bidirectional protocol
fault masking
local state
one processor
register r
two processors
self stabilizing
fault tolerance
r p
correcting strategy
latent unidirectional
n register
one register
round zero
spliced corrupt
corrupt state
severe transient
q ffi
gamma 1
oe 0
k state
masking fault
handshake mechanism
token circulates
unidirectional ring
stabilizing protocols
see appendix
history variables
self stabilization
global state
o n
processor local fault
processor local faults
protocol of figure
mutual exclusion protocol
mutex passage predicate
perform critical section
stabilizing mutual exclusion
processor i 1
state reading model
superstabilizing mutual exclusion
superstabilizing with respect
o 1 superstabilization
appendix for proof
writes to r
protocol is superstabilizing
stabilizing with respect
problem of mutual
ring of processors
number of registers
register r ij
protocol is optimal
fault of type
state of processor
protocol of section
spliced corrupt state
legitimate state oe
following a processor
state in l
proof by contradiction
o 1 rounds
respect to p
fields r ij
cycle of processor
stronger passage predicate
regular 1 latent
processors are token
set the program
token passing registers
impossible to prevent
protocol for processor
self stabilizing mutual
n latent protocol
minor token circulation
dijkstra s protocol
within o 1
consists of processor
j its input
registers of processor
protocol is stabilizing
uses a waiting
token from processor
complete token circulation
major and minor
steps of p
arbitrary initial state
