rp
bucket
dp
overflow
aggregation
tuples
partitioning
gridfile
partitions
ov
canmerge
overflows
cuts
grid
cfd
sw
utilization
rectilinear
utilizations
nw
buckets
directory
bulk
loading
skewed
dimension
gridfiles
tuple
se
merge
bin
ne
li
tov
blocksover
quadrants
plot
bins
subranges
aggregate
files
cut
precalculated
subdirectory
precalculation
page
bytes
attribute
mega
unstructured
seconds
partition
session
directories
sparse
blocks
headed
column
theta
fit
strip
coordinates
axis
multiattribute
subdirectories
maxfp
overflowed
sorting
aggregating
occupancy
lowerbound
uninterested
buddy
square
hours
file
spaced
post
discovered
nicol
uniformly
disk
columns
horizontal
orders
sampling
plotted
seeks
seek
varied
byte
attributes
creating
capacity
spent
tg
indexing
coordinate
faster
indexed
magnitude
lacking
phase
physical
synthetic
pairing
highly
minimizes
optimality
poor
megabytes
reals
created
qualified
fluid
fetch
runtime
versus
finds
significantly
quickly
unchanging
effectual
expermental
airflows
probalistic
unstructure
pmr
multikey
expend
aydt
precalculating
symetric
ruth
retrivial
positionally
reword
gisli
logarithmic
rectangle
regions
pre
exposition
conduct
vertical
recursion
majority
groups
conversely
irregular
unravel
wings
rotem
subrange
hjaltason
lization
neglects
uti
dora
rundensteiner
geoinformatica
presume
rp algorithm
dp algorithm
bucket utilization
data sets
total overflow
li et
data set
cfd data
ov 1
bulk loading
rectilinear partitioning
bucket utilizations
aggregation phase
grid directory
se j
fixed partitioning
dp dp2
partitioning algorithm
o p
per page
average bucket
tuple size
grid files
dynamic programming
tuples per
aggregation post
pre aggregation
overflow free
post aggregation
call merge
ne se
partitioning session
nw ne
partitions pre
highly skewed
aggregation algorithm
bucket capacity
unique attribute
ne j
rp algorithms
maximum domain
physical partitioning
grid file
sw j
computation time
algorithm required
nw sw
sw se
algorithm dp
tuple data
canmerge nw
tuples fit
merge nw
sparse relative
u 2
r k
skewed data
domain value
fit per
one dimension
uniformly distributed
mega bytes
two phase
run time
four orders
phase bulk
seconds versus
cut set
new blocks
utilization bucket
overflow equals
columns headed
grid cfd
aggregation partitions
byte tuples
logical partitioning
tov 1
partitions needed
overflow blocks
et al
present results
distributed data
n theta
p time
c 1
attribute values
one bucket
unique values
log u
phase algorithm
partitioning given
partitions p
bucket overflows
unstructured grid
size increases
programming solution
theta n
number of partitions
number of tuples
li et al
cfd data sets
number of unique
pre aggregation post
j then call
aggregation post aggregation
tuples per page
partitions pre aggregation
k 1 j
unique attribute values
r k 1
o p 2
uniformly distributed data
call merge nw
plot the computation
dp and dp2
set of cuts
rp algorithm dp
dp dp2 algorithm
nw sw j
rectilinear partitioning algorithm
average bucket utilizations
tuples fit per
nw ne j
sw se j
tuple size increases
maximum domain value
ne se j
relative to n
given a fixed
bucket utilization bucket
fit per page
number of subranges
average bucket utilization
axis is logarithmic
j 1 aggregate
present the utilizations
unstructured grid cfd
o p time
highly skewed data
sorting the tuples
algorithm for bulk
post aggregation partitions
two phase bulk
utilization bucket utilization
tuple data set
cuts in one
tov 1 1
algorithm dp algorithm
aggregation partitions pre
n theta n
side of figure
orders of magnitude
two phase algorithm
dynamic programming solution
algorithm is used
find the smallest
synthetic data sets
versus the number
define the first
set into r
algorithm of li
times more computation
find c 2
retrieval of subsets
loading data sets
nw ne se
maxfp 2 u
