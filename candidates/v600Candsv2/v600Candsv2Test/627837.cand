analogical
reuse
specifications
matching
doublelist
analogies
matches
dbllist
analogy
stack
specification
subproblems
spec
match
query
reusable
expr
similarity
ospl
software
modifies
old
hierarchy
commutative
matchable
cg
expressions
cbr
sort
branch
modification
retrieved
tiered
reqcoll
armp
arguments
equivalence
library
faceted
container
reasoning
reusing
phi
program
schemas
retrieval
distance
candidate
predicate
topelement
addattail
telos
caret
heuristic
connectives
fi
postconditions
lists
operators
ff
pred
push
symbols
matchability
conceptual
theta
clause
reusability
ensures
formal
dershowitz
heuristics
amenable
graphical
similarities
descriptions
cgs
attribution
od
subproblem
projects
universally
associations
postcondition
transformational
permuted
sorted
automated
gg
analogous
sorts
incorporated
minflevel
skolemized
fopl
maiden
trashed
sutcliffe
fms
lassie
conflict
quantified
component
investigations
destructor
carol
widgets
tailorable
scoring
classification
oe
destroy
synthesis
predicates
modifying
retrieving
facilitate
matched
thesaurus
unmatched
atc
cas
distances
relationships
grained
prolog
hierarchies
tail
overviews
precondition
arcs
determination
schema
subsort
pairings
rose
isa
programmer
retrieve
templates
cardinality
frames
development
facilitates
head
facet
customize
attribute
identifier
subsumption
displays
conflicts
pursued
supplied
synthesize
bijective
queue
commutativity
entity
sigma
designs
emphasized
documentation
abstractions
target
logic
effort
browsing
inherit
ancestor
classify
artifacts
return
developer
division
sought
keyword
paradigm
operator
semantic
newelement
bhansali
addathead
algorithsm
didactic
guifa
ail
domainsort
derivational
singlelist
abstractusing
xiaodong
jurisica
spanoudakis
detachattail
matching process
analogical matching
analogical matches
matching two
query specification
software reuse
software components
branch subproblems
query spec
old program
algorithm match
formal specifications
two terms
sort hierarchy
analogical match
match expr
old spec
two expressions
match term
based heuristic
matching algorithm
equivalence class
reusable software
analogical reasoning
modification process
partial matches
program modification
existing components
return match
modifies dbllist
method doublelist
case matching
order sorted
query specifications
matches two
query component
matches theta
tiered hierarchy
stack ensures
old cases
dbllist ensures
input expressions
two input
two tiered
query program
reusable components
components based
software component
candidate specifications
reuse system
component specification
analogy based
ff 7
reuse framework
dbllist element
existing component
modifies stack
existing specification
argument order
automated reasoning
matching algorithms
domain specific
process generates
input terms
commutative operators
term case
method specification
case based
two operators
similarity based
case 6
formal methods
reuse based
existing program
od end
two lists
based reasoning
reasoning systems
design schemas
top stack
ensures top
requires clause
design family
determine software
program synthesis
sorted predicate
analogical relationships
identical associations
program old
given component
equivalence based
matches phi
doublelist modifies
match oe
e matching
design library
two specifications
name identifier
candidate components
new subproblems
match else
ensures method
specification level
stack modifies
lists case
predicate connectives
implementation old
existing set
implementation query
method destroy
formally specified
square root
domain knowledge
predicate logic
conceptual distance
domain analysis
computing similarity
specification query
scoring function
sorted specifications
knowledge base
two methods
analogical matching process
set of analogical
distance between two
algorithm match term
matching two terms
based on analogy
case matching two
set of matches
set of partial
subproblems are generated
matching process generates
algorithm match expr
modifies dbllist ensures
two tiered hierarchy
algorithm for matching
reusable software components
let the distance
components to satisfy
matching two expressions
modifies stack ensures
case based reasoning
call this approach
denoted by d
two input expressions
determine software reuse
numbers of arguments
based on analogies
domain specific information
stack ensures top
method doublelist modifies
order sorted predicate
specifications is used
program old program
matches two operators
sorted predicate logic
e do od
ff 7 gg
match else return
ensures top stack
specification query spec
e ff fi
existing and query
spec and query
doublelist modifies dbllist
match term case
implementation query program
d e ff
pair of lists
similarity based techniques
stack modifies stack
used to determine
program that satisfies
order sorted specifications
software reuse based
set of candidate
satisfy the query
generates a set
based on similarity
given in figure
used to guide
order to increase
matches between old
empty lists case
projects that use
else return case
proposed an analogy
head dbllist element
determination of reusable
term g f
structure based heuristic
match input two
applying formal methods
program modification model
