bool
fn
int
unification
explanation
typeof
binding
bindings
why
substitution
ml
deductions
programmer
polymorphic
explanations
syntax
identifier
typed
reconstruction
typing
expression
inconsistency
atomic
arose
wand
errors
nationality
identifiers
deduction
body
explain
inferred
unifiable
explaining
elided
british
parse
explains
subexpressions
inference
citizenship
instantiation
minority
tree
milner
programmers
conditional
sigplan
unify
detected
jersey
argument
lerner
renamings
polymorphism
formal
mistake
notices
generic
usage
deductive
grossman
languages
come
traversal
constructs
expressions
operand
functional
language
chambers
haskell
annotated
augmented
asked
stand
anomaly
specialize
else
instantiations
decorates
kima
exeter
hboolean
incredulity
chitil
wazny
ajiro
bastiaan
heeren
type bool
type variable
the type
have type
why does
type int
fn b
fn x
type reconstruction
type errors
the explanation
type of
syntax tree
a fn
does the
explanation space
type analysis
formal parameter
to type
the function
bool int
a type
the unification
int bool
fn a
function definition
the programmer
of type
fn y
the syntax
function fn
argument true
atomic bindings
binding arose
bool i
bound to
type error
int int
polymorphic type
variable b
type variables
x have
arose during
to explain
standard ml
variable a
the argument
type b
be bound
the expression
else a
b else
atomic binding
let statement
a substitution
come to
the program
has type
parameter x
true 3
true have
assigned type
does formal
did type
bool bool
b come
expression fn
how did
f true
ml of
an expression
the typing
function application
the let
x fn
to unification
explain the
during type
function how
generic type
type inference
typing rules
the types
actual argument
then b
during analysis
function body
b if
why and
the identifier
why does the
have type bool
the type of
bound to type
have type int
type of the
fn b if
the syntax tree
of type errors
a fn b
type variable a
fn a fn
x have type
does the function
come to be
the type analysis
b else a
of the function
to be bound
then b else
fn y x
type variable b
binding arose during
formal parameter x
the argument true
type of a
the function fn
be bound to
b then b
source of type
if b then
of the type
type int bool
to explain the
during the unification
the type variable
the formal parameter
type of an
standard ml of
the source of
does formal parameter
type bool bool
type bool int
function fn x
the type reconstruction
during analysis of
has type bool
b have type
explanation space for
arose during analysis
fn x fn
true have type
to type bool
x fn y
type bool i
did type variable
b come to
does the argument
does the expression
type for an
this binding arose
3 f true
the type b
how did type
type b b
fn x x
of the argument
of the program
f 3 f
the function how
type c d
is the range
application is the
by the type
why and how
an application is
type of its
with the type
of the syntax
the instantiation of
type int int
for an expression
the types of
the programmer may
b if b
definition is determined
inferred for the
3 have type
28 why does
parameter x have
