specialisation
mlet
specialiser
residual
static
monad
specialise
runm
interpreter
void
e1
ref
references
specialising
specialised
lift
metalanguage
e2
store
typed
eval
monadic
ml
moggi
specialises
env
num
specialization
erasure
constructor
interpreters
evaluators
imperative
calculus
int
lambda
rules
evaluator
contents
poly
univ
hughes
unification
formedness
binding
specialisations
specializer
autoprojection
languages
spec
quasimonad
dummy
eraser
dussart
closure
delimiters
reference
thiemann
statically
effects
constructors
tuple
s3
simplifications
polyvariant
monads
tags
offline
laws
algol
redexes
language
lazy
vl
unfolded
fun
meta
ole
isomorphisms
prompts
functional
updatable
arms
constructs
awkward
untagging
3es
typedness
monovariant
schism
residual type
type specialisation
partial evaluation
static store
the residual
specialisation rules
residual types
in mlet
the specialiser
the static
optimal specialisation
static state
specialisation for
the specialisation
the monad
void erasure
mlet x
residual program
specialisation is
static references
to specialise
self interpreter
on references
eval env
during specialisation
mlet r
residual programs
rules for
r ref
be specialised
a static
the store
type specialiser
moggi s
specialisation time
class references
oe ml
interpreter for
static information
e2 in
lambda calculus
at specialisation
static part
specialisation of
a dynamic
mlet z
case eval
computation type
runm e
dynamic function
imperative languages
partial evaluators
static reference
dynamic references
partial evaluator
binding time
residual term
num int
specialises to
dynamic part
e1 in
static sum
static function
empty static
computational metalanguage
specialiser is
and mlet
computational lambda
with effects
specialisation in
operations on
evaluation order
a computation
static values
the type
two level
monad laws
dynamic state
of type
the interpreter
meta language
specialised to
a specialisation
first class
ref 2
in residual
the dynamic
specialising a
of void
standard partial
the residual type
the static store
specialisation rules for
residual type of
the residual program
mlet r ref
the specialisation rules
type specialisation is
at specialisation time
operations on references
first class references
the type specialiser
rules for static
with first class
self interpreter for
a self interpreter
the static state
partial evaluation of
moggi s computational
2 in mlet
computational lambda calculus
type specialisation for
case eval env
specialisation for a
of case eval
in the residual
binding time analysis
of the static
a dynamic function
empty static store
achieve optimal specialisation
in mlet z
be specialised to
a static sum
well formedness conditions
in residual programs
j and mlet
static sum type
a computation type
for oe ml
same static part
the residual types
a static function
residual type 3
in mlet x
the residual term
the same static
of a dynamic
e 0 figure
the dynamic store
of the store
static and dynamic
for partial evaluation
partial evaluation and
partial evaluation is
automatic autoprojection of
lambda calculus with
of type ref
lift 2 in
e2 in j
interpreter to a
rules for store
optimal specialisation for
eval env e1
specialises to a
a dynamic state
references are created
the interpreted language
r ref 2
mlet z r
3 in r
mlet x e1
calculus with first
e of case
values in partial
interpreter for oe
explicit store passing
that type specialisation
to specialise a
e1 in mlet
partial evaluators for
the void eraser
store is known
different residual types
evaluation of imperative
standard partial evaluation
ref 2 in
propagate static information
evaluation order explicit
in mlet v
