conditionals
optimizations
transformations
bounds
programs
transformation
cons
paths
timing
languages
pipelining
depths
analyzing
binding
measuring
optimizing
structs
sorting
constructs
primitive cost
bound function
cost parameters
symbolic evaluation
bound functions
cost bounds
input size
bound analysis
time milliseconds
size parameters
input structures
heap space
insertion sort
measured worst
original program
loop bounds
execution paths
worst case
list reversal
selection sort
cost function
direct evaluation
set union
space bounds
merge sort
partial evaluation
cost parameter
cost analysis
variable reference
incremental computation
time analysis
closed forms
simplifying conditionals
lifting conditions
approximate time
cost functions
primitive operation
actual running
example programs
input structure
program analysis
function terminates
dierent operations
synthesizer generator
recursion depths
level languages
source level
language level
language implementation
complexity analysis
recursive function
algorithm analysis
analysis results
primitive cost parameters
partially known input
input size parameters
known input structures
calculated time milliseconds
garbage collection times
primitive cost parameter
accurate cost bound
worst case times
methods and techniques
measuring primitive cost
allocated for constructors
bounds or execution
loop bounds or
high level languages
dierent operations performed
execution paths automatically
accurate cost bounds
heap space allocated
paths automatically and
conservatively or approximately
known input structure
automatically and accurately
eciently and accurately
program analysis and
number of experiments
