supernodes
hyperplanes
tiling
transformation
partitioning
lengths
loops
processors
running
iterations
discusses
cutting
grouping
planes
dencies
minimizing
dependencies
supernode size
supernode transformation
total running
grain size
optimal supernode
linear schedule
index space
running time
optimal grain
length vector
side lengths
iteration index
relative side
dependence matrix
dependence vectors
different supernode
parameter model
relative length
parameter communication
optimal linear
partitioning hyperplanes
supernode transformations
parallelepiped supernode
communication model
communication time
communication phases
nested loops
side length
matrix h
closed form
supernode partitioning
r g
n partitioning
memory parallel
communication phase
iteration space
consider algorithm
optimal shape
dimensional algorithm
distributed memory
single processor
form expression
computation time
loop nests
affine function
normal vectors
nested loop
athanasaki aristidis
parallelepiped supernodes
athanasaki nectarios
square containing
extreme vectors
algorithm problems
total running time
optimal grain size
optimal supernode size
iteration index space
grain size and
supernode size and
optimal linear schedule
parameter communication model
relative length vector
side length vector
relative side length
length vector r
different supernode sizes
one parameter model
optimal relative length
grain size g
one parameter communication
communication cost is
relative side lengths
index space and
supernode relative side
distributed memory parallel
two parameter model
constant bounded loop
discusses how to
optimal supernode shape
optimal supernode relative
closed form expression
memory parallel computer
bounded loop iteration
supernode size changes
also provided for
n partitioning hyperplanes
supernode relative length
