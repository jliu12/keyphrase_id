join
bushy
query
joins
processors
allocation
processor
parallelism
heuristics
multiprocessor
te
heuristic
fragmentation
st
dependency
synchronous
sequences
scheduling
pipelining
execution
relations
queries
database
sequential
proc
inter
operator
schemes
simulation
merge
exploiting
relational
trees
exploit
minimize
despite
outperform
evaluated
exe
concept
opt
categorized
multi
allocates
evaluate
explore
join sequence
processor allocation
bushy tree
join sequences
operator parallelism
execution time
general join
execution dependency
sequential join
synchronous execution
operational point
system fragmentation
sequence scheduling
join query
sequence efficiency
operational curve
r 5
efficiency point
query graph
execution costs
r 4
sequence heuristics
resulting relation
cumulative execution
dependency and
query execution
multiprocessor system
processors allocated
join queries
point selection
bushy trees
next join
join operation
internal node
r r
merge join
r 6
child nodes
optimal sequential
execution of
r j
average execution
different join
tree in
scheduling and
sequence heuristic
heuristic se
heuristics proposed
resulting join
execution cost
parallel execution
r 2
processors to
data skew
sequences obtained
processors are
minimum time
simulation results
allocation heuristics
exploiting inter
schemes evaluated
built bottom
resulting r
processors for
determine the
h p
r 3
processor system
concept of
allocation for
allocation efficiency
join methods
hash joins
join method
execution tree
single processor
minimize the
parallelism is
scheduling schemes
execution sequence
p b
heuristic to
query complexity
join operations
several heuristics
number of processors
synchronous execution time
inter operator parallelism
concept of synchronous
join sequence scheduling
general join sequences
multi join query
join sequence efficiency
query execution time
execution dependency and
number of relations
sequential join sequence
general join sequence
intra operator parallelism
query in figure
operational point selection
sequence scheduling and
dependency and system
join sequence heuristics
scheduling and processor
sequential join sequences
minimal cost join
bushy tree in
minimum time point
processors allocated to
execution time of
bushy tree is
optimal sequential join
multi join queries
tree in figure
join sequence for
single processor system
join sequences obtained
join sequence heuristic
gmc and gmr
minimize the query
cardinalities of relations
execution of multi
best efficiency point
processor allocation for
execution time to
time of a
sequence of joins
despite their simplicity
processor allocation efficiency
processor allocation heuristics
processor allocation it
built bottom up
sequences obtained by
proc no starting
within a query
cumulative execution cost
join sequence in
minimize the execution
cumulative execution costs
resulting relation of
several heuristics to
sequence proc no
execute the join
database operations in
time efficiency point
processors to execute
cardinalities of attributes
exploiting inter operator
join sequences are
execution dependency is
propose and evaluate
light of the
join to be
top down approaches
bottom up approach
evaluated by simulation
join in the
join can be
execution of each
seen that the
determine the number
execution time is
top down approach
join sequence and
relations attribute a
form of parallelism
processor allocation heuristic
join in a
execute each join
