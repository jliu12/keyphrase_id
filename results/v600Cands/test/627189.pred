primitive
symbolic
calculated
ecient
optimizations
eciently
transformations
accurate
bounds
programs
measured
yanhong
accurately
automatic
transformation
program
partially
cons
timing
compiler
language
languages
pipelining
analyzing
source
optimizing
inaccurate
automatically
calculate
schema
cost bound
primitive cost
bound function
cost parameters
symbolic evaluation
bound functions
cost bounds
input size
bound analysis
known input
partially known
garbage collection
time milliseconds
milliseconds input
size parameters
input structures
heap space
insertion sort
accurate cost
measured worst
original program
loop bounds
execution paths
worst case
collection times
list reversal
selection sort
cost function
direct evaluation
set union
reversal w
collection time
sort calculated
space bounds
time bound
merge sort
partial evaluation
cost parameter
measuring primitive
merging paths
evaluation takes
cost analysis
variable reference
incremental computation
analysis for
time analysis
automatically and
function calls
resulting function
constructing cost
simplifying conditionals
lifting conditions
approximate time
reversal reversal
include garbage
cost functions
yanhong a
primitive operation
actual running
example programs
given values
evaluation and
input structure
program analysis
function terminates
dierent operations
synthesizer generator
paths automatically
recursion depths
bytes allocated
accurate conservative
bounds automatically
measured conservatively
level languages
source level
language level
language implementation
complexity analysis
transformations are
source language
recursive function
resulting cost
algorithm analysis
space allocated
e 1
analysis results
optimizations to
cost bound function
primitive cost parameters
cost bound functions
partially known input
input size parameters
milliseconds input size
calculated measured me
time milliseconds input
known input structures
calculated time milliseconds
cost bound analysis
ca calculated measured
measured worst case
garbage collection times
primitive cost parameter
time bound analysis
accurate cost bound
sort calculated time
garbage collection time
worst case times
methods and techniques
symbolic evaluation of
analysis and transformation
insertion sort selection
symbolic direct symbolic
language based approach
sort merge sort
analysis with cache
inputs of sizes
measuring primitive cost
size parameters and
bound analysis with
selection sort merge
sort selection sort
allocated for constructors
union list reversal
reversal w append
inputs of size
bound functions in
calculated and measured
source language level
bounds or execution
values of input
list reversal reversal
cost parameters for
size calculated measured
include garbage collection
reversal reversal w
loop bounds or
bound function for
constructors in the
input of size
time or space
high level languages
dierent operations performed
cost parameters and
execution paths automatically
conservative or approximate
allocated for each
prototype system alpa
space allocated for
optimized symbolic evaluation
subset of scheme
accurate cost bounds
approximate time or
automatic and accurate
heap space allocated
paths automatically and
cache disabled the
conservatively or approximately
consists of transformations
given values of
measured conservatively or
programs on inputs
accurate conservative or
known input structure
might not terminate
symbolic evaluation takes
values of primitive
cost parameters as
automatically and accurately
bytes allocated for
evaluation and optimizations
symbolic evaluation and
eciently and accurately
worst case execution
terms of primitive
language implementation or
analyses and transformations
bound analysis for
evaluation of cost
time and space
bounds on the
takes as arguments
evaluation of the
program analysis and
speed up the
obtained based on
number of experiments
number of bytes
cost of the
running time and
based approach for
