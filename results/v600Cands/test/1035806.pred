adversary
processes
wait
naming
randomized
register
shared
atomic
protocol
keys
probability
faulty
renaming
consensus
asynchronous
object
adversaries
resilient
selects
running
var
concurrent
anonymous
free
memory
deterministic
executed
synchronous
setonce object
writer n
shared memory
log q
one process
process p
n log
running time
key range
n processes
adaptive adversary
free atomic
log n
naming protocol
log log
o n
shared bits
coin flip
composite register
naming problem
processes is
every process
system execution
name space
high probability
probability ff
atomic read
competing processes
system executions
reader shared
write registers
randomized wait
bit operations
non faulty
random key
reader 1
shared variables
expected running
probability at
symmetric shared
naming algorithm
free naming
invoking processes
faulty process
protocol is
process can
free solution
crash failures
bit registers
memory model
writer multi
coin flips
using shared
protocol segment
bit components
anonymous communication
shared atomic
least ff
using ff
private register
reader o
intercommunication primitives
atomic bits
shared registers
component composite
processes back
first random
probability 1
possibly different
ff test setonce
test setonce object
writer n reader
wait free atomic
log log n
atomic read write
free atomic read
n log q
randomized wait free
read write registers
n log log
test setonce objects
setonce object that
owned by process
running time is
expected running time
processes is at
time is o
n log n
probability at least
symmetric shared memory
wait free naming
object is invoked
reader shared bits
wait free solution
n reader shared
name space of
gets a key
non faulty process
get a key
number of processes
n log 2
single writer multi
space of size
log n log
writer multi reader
succeeds with probability
using shared memory
initial segment of
probability that the
n bit components
private register and
k out of
multi reader wait
processes back off
process steps forward
hard to analyze
writer per component
register and can
shared bits proof
back off and
bit operations with
adaptive adversary the
way not known
uses a name
per component n
initial execution segment
writes to shared
exactly one process
n component composite
selects a winner
non faulty processes
reads the other
known to each
read by all
reader 1 writer
proof a process
reader wait free
component n component
log 2 n
probability of having
n processes is
one process can
log log q
