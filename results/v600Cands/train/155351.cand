maple
kmaplek
strand
worker
pipe
obner
polynomials
manager
spol
fwd
polys
resultlist
inpoly
symbolic
expr
comp
sieve
parallelizing
inline
gr
parallelized
mvar
sumexpr
siegl
svar
mexpr
ys
producer
parallelization
speedup
consumer
int
conquer
par
mres
divconq
unevaluated
termlist
xs
workers
split
mcall
mlist
request
init
fun
shell
char
sequential
sps
parallelize
mode
compose
bases
interface
guard
programing
uspensky
tps
maplelist
resultexpr
katsura3
fmexpr
schreiner
tdeg
exprlist
jrequest
testpoly
algebra
append
res
parallelism
rps
sends
foster
divide
additionally
1990
io
calls
soon
prolog
sac
stream
gained
args
tmp
spawn
collects
tasks
parsing
balancing
linda
canceled
sequent
declarative
var
returns
flowing
strings
annotated
bp
porting
isolation
finished
generic
appended
pipeline
guards
portable
bosa
readlib
iltern
unifica
lynomial
yjys
resgjwork
mresg
basiselemente
nulldimensionalen
einem
dyna
expressi
restklassenringes
kuechlin
karoly
mittermaier
trinks2
dings
buchberger
posso
lelizations
auffinden
jrs
groebner
fullfiled
xjxs
sps1
shellinput
polynomideal
thematics
parsac
paclib
boege
mically
balan
primitiva
list
algebraic
roots
print
kernel
libraries
symbolically
communication
looks
polynomial
ts
algorithmus
mana
fwf
loos
ced
2568
query
garbage
processes
n1
critical
filter
subproblems
front
recursive
eratosthenes
i386
builtin
nach
zum
overtake
legible
1983
statements
quick
declaration
channel
bodies
lor
todays
proc
user
shared
basis
overhead
tay
parallelizations
merger
grain
inherent
send
sent
the pipe
gr obner
obner bases
symbolic computation
of maple
in kmaplek
the manager
computer algebra
manager worker
init worker
the maple
in symbolic
parallelizing algorithms
s polynomials
the kmaplek
split comp
a maple
to maple
for parallelizing
the strand
in maple
parallel programming
par int
strand and
compose fun
arbitrary maple
language strand
par list
bases algorithm
the parallel
maple has
all individual
the gr
algebra systems
generating new
n workers
ys fwd
pipe for
worker scheme
io interface
parallel declarative
basis polynomials
maple list
maple variable
append spol
kmaplek we
new critical
maple maple
of strand
generic divide
kmaplek system
and returns
for communication
recursive calls
to parallelize
input polynomials
char et
inline in
maple and
maple statements
root isolation
maple function
conquer algorithm
input values
new input
user interface
concurrent prolog
sequential computer
parallel symbolic
and conquer
divide and
for symbolic
programming language
real root
procedure generates
foster and
individual terms
critical pairs
as soon
memory machine
back through
as result
parallelized using
pipe the
parallel evaluation
producer consumer
shared memory
parallel tasks
linear speedup
polynomials the
may compute
algorithms in
flow synchronization
fun has
maple program
mode par
in args
parts result
m mexpr
basis polynomial
pipe again
strand variable
variable svar
siegl 1990
speedup gained
sequent shared
evaluated functions
the uspensky
uspensky procedure
maple int
sum expression
int resultlist
maple a
mexpr result
polynomials flowing
polys basis
since kmaplek
strand program
res mres
request mode
end sieve
quick parallelization
tps sps
and maple
sequential maple
procedure collects
kmaplek is
independent sub
kmaplek program
worker approach
reduction processes
basis main
sub procedures
polynomial ideal
worker n1
int sumexpr
maple expressions
divide conquer
main inpoly
output par
kmaplek may
pair completion
result maple
result mode
kmaplek on
mode split
processor sequent
s polys
top end
expr mexpr
combine int
basis polys
test polys
char 1990
calls unevaluated
intermediate filter
interface maple
in char
y par
mvar svar
comp parts
pipe process
inpoly basis
in siegl
taylor 1989
resultlist result
critical polynomials
parallelization of
base case
polynomials with
in parallel
parallel computers
symbolic algebraic
maple this
high speedup
linda is
comp comp
maple is
parallelizing this
y ys
procedures p1
x result
print out
20 processor
bases computation
worker n
consumer process
and strand
strand as
the result
a pipeline
declarative programming
and sends
returns the
the inline
end process
p1 3
progress report
1990 where
int t
in symbolic computation
gr obner bases
through the pipe
of the pipe
the manager worker
programming language strand
obner bases algorithm
the gr obner
for generating new
computer algebra systems
parallel declarative programming
list to maple
manager worker scheme
sequential computer algebra
basis polynomials the
the pipe for
in kmaplek we
the parallel declarative
for parallelizing algorithms
declarative programming language
real root isolation
algorithms for symbolic
the kmaplek system
all individual terms
char et al
the recursive calls
divide and conquer
back through the
for symbolic computation
and returns the
shared memory machine
and conquer algorithm
of the kmaplek
main inpoly basis
maple function and
var and returns
the uspensky procedure
procedure collects all
critical pairs are
and taylor 1989
inpoly basis main
overhead for parsing
pipe again the
progress report on
f x result
the independent sub
between parallel tasks
algebraic equations by
char 1990 where
examples for solving
partially evaluated functions
equations by calculating
on a 20
in siegl 1990
used for parallelizing
the reduction processes
a maple list
of maple statements
the maple variable
foster and taylor
generating new input
parallel programming system
split comp comp
20 processor sequent
the strand variable
independent sub procedures
sequent shared memory
result is sent
algorithms in symbolic
computing time of
obner bases computation
strand variable svar
on the manager
strand as well
algorithms in kmaplek
fun has to
knowledge in parallel
the speedup gained
i o process
polys basis polys
io interface maple
strand and maple
print out all
parallel symbolic algebraic
the pipe again
m mexpr result
sub procedures p1
problems in symbolic
may compute all
generic divide and
and new critical
method allows easy
purpose parallel symbolic
recursive calls unevaluated
a high speedup
to a maple
critical pair completion
system for general
new input values
strand and the
pipe for generating
comp parts result
compose fun has
of arbitrary maple
int f x
processor sequent shared
new critical pairs
init worker n
input output par
using the manager
procedures p1 3
combine int resultlist
main procedure generates
maple has the
comp comp parts
a quick parallelization
to the maple
result mode split
manager worker approach
tested with respect
parallelizing algorithms in
design of maple
maple is a
symbolic computation is
data flow synchronization
dynamic load balancing
as input and
have to combine
developing parallel algorithms
input values are
goal should be
the consumer process
the parallel processors
has been parallelized
the pipe the
parallel program we
some examples for
from the pipe
a 20 processor
program looks like
interactive user interface
for parallelizing this
are appended to
symbolic computation in
an interface between
input and returns
a super linear
parallelized using a
used in symbolic
without any modification
of parallel processes
computer algebra system
a list of
to the manager
super linear speedup
computing the result
in parallel programming
the test set
we found out
process takes the
returns a list
systems of algebraic
parallel programming language
a dynamic load
we have to
this method allows
of algebraic equations
the computing time
even possible to
we may compute
et al 1983
a parallel programming
in more detail
them to the
found out that
use the value
returns the result
to the basis
the main procedure
report on a
general purpose parallel
see section 4
it sends the
2 based on
the system was
has the ability
and sends them
set of properties
a system for
on a system
for solving systems
appended to the
that takes a
base case is
for general purpose
the back end
is a parallel
solving systems of
parallelization of the
the front end
