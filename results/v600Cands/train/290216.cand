lg
hashing
buckets
bucket
hash
keys
injective
active
cell
crcw
pram
dominant
probability
doubly
dietzfelbinger
heide
oblivious
lookup
injectively
collision
concurrent
matias
iteration
auf
bits
processors
hashed
processor
allocation
dictionary
ptr
block
balancing
exponential
meyer
sorting
omega
memory
iterations
template
vishkin
koml
injectiveness
failures
read
tolerant
szemer
universe
inactive
random
distinctness
deactivated
allocated
fredman
der
sector
failure
array
edi
sectors
colliding
collided
leaders
decrease
robust
uniquely
election
load
inequality
stage
lemma
hx
reallocation
designated
succeeds
v0
acknowledgement
fail
qrqw
gammaeq
congestions
selections
stirling
gammaffl
collide
successful
markov
gil
decreases
2k
blocks
deactivation
gamma21
os
expectations
randomized
mapped
probabilistic
collides
deactivate
perfect
inductive
key
ji
luby
prams
polynomial
standing
rate
selected
successfully
3m
39
pairwise
priority
consumes
paradigm
estimates
corollary
participate
implementations
contents
jr
selects
beginning
crux
sufficiently
logarithmic
randomness
attempt
kt
auxiliary
select
relies
wigderson
records
weaker
imposes
mt
karp
query
induction
universal
fi
lb
chebyshev
succeeded
moment
mapping
selection
hy
contention
consumed
membership
insertions
representatives
allocate
priori
idealized
mappings
hagerup
gammail
gamma27
rohnert
gamma329
reallocations
garble
ffie
ercw
searching
queries
carries
wrap
demanding
circumvent
speedup
failing
copies
careful
private
iterative
nge
bast
incomparability
uzi
suffix
convexity
supports
visits
mostx
curiously
jerrum
singe
splits
fraction
simulations
binomially
gamma26
broadcasting
conflicting
lg n
lg lg
o lg
active buckets
dominant probability
n dominant
the hashing
hashing algorithm
n lg
m t
of active
memory block
hashing step
hash function
parallel hashing
iteration t
the bucket
lg u
hash functions
2 hash
active keys
exponential rate
hash table
hashing problem
a bucket
random bits
key x
level 2
fact 2
each bucket
doubly exponential
oblivious execution
concurrent read
buckets that
n time
of buckets
allocation step
the hash
bucket is
g t
constant time
k t
level 1
bucket may
algorithm template
1 hash
with n
memory blocks
a memory
of size
der heide
meyer auf
2 lg
keys in
is injective
crcw pram
in constant
probability the
the algorithm
auf der
o n
active key
on tolerant
injective level
of keys
multi set
high probability
by 20
2 function
the level
memory cell
load balancing
matias and
level hashing
active elements
probability at
a doubly
concurrent write
this implementation
lemma 5
in o
an injective
2k t
dictionary algorithm
uniquely select
at most
buckets and
that fail
balancing algorithm
each iteration
n processors
a block
the cell
fi t
of iteration
with high
the memory
at random
hashing scheme
random words
buckets at
dietzfelbinger and
integer sorting
constant probability
an iteration
bucket i
of random
of decrease
and meyer
implementation on
s inequality
a level
u bits
all buckets
polynomial hash
perfect hash
20 by
1 function
expected time
decreases at
v t
2 level
most fi
under h
second stage
that cell
n iterations
time with
the allocation
leaders election
exponential decrease
u random
fredman koml
auxiliary hash
t lg
hashing by
edi 16
uniquely selected
p lg
size k
decrease in
remain active
n keys
each key
keys are
key is
markov s
hashing algorithms
is deactivated
on collision
array ptr
lg m
a designated
after o
with probability
memory used
a random
is o
same key
processor j
buckets in
using n
by oblivious
cell t
koml os
of hashing
active bucket
t active
linear size
the dictionary
to o
of hash
fail to
running time
implementation is
select a
element distinctness
same bucket
and szemer
the analysis
the probability
problem size
level scheme
robust model
szemer edi
total memory
input set
t g
size at
most m
first t
corollary 2
the robust
block in
buckets are
bucket size
the concurrent
all processors
a pram
to uniquely
lg lg n
o lg lg
n dominant probability
with n dominant
lg n time
of active buckets
number of active
o lg n
level 2 hash
doubly exponential rate
the hashing step
of active keys
in the hashing
the hashing problem
2 hash function
in o lg
n lg n
lg n lg
to o lg
the number of
the hash table
number of buckets
a memory block
the level 1
n lg lg
of random bits
the hashing algorithm
level 1 hash
of iteration t
1 hash function
level 2 function
a doubly exponential
number of random
n time with
of buckets that
in constant time
t t g
lg n iterations
by 20 by
g t x
level 1 function
the algorithm template
the allocation step
auf der heide
of the hashing
meyer auf der
with high probability
2 lg n
a level 2
beginning of iteration
time with high
injective level 2
lg lg u
parallel hashing algorithm
size k t
dominant probability the
buckets that fail
only o lg
an o lg
and k t
t and k
memory block of
o n lg
most m t
block of size
number of keys
into a memory
and meyer auf
exponential rate of
corollary 2 3
t g t
a multi set
lg u bits
after o lg
hashing problem in
dominant probability at
an active key
to uniquely select
at a doubly
of n keys
t m t
an injective level
uniquely select a
of o lg
that a bucket
the bucket may
find an injective
load balancing algorithm
m t and
the memory block
decrease in the
rate of decrease
using n processors
array of size
select a block
buckets at the
the second stage
hash function is
polynomial hash functions
each bucket is
bucket i is
20 by 20
of size k
at most fi
a memory cell
the level 2
of the algorithm
size at most
probability at most
the 2 level
szemer edi 16
2 level scheme
u random bits
cell t t
o lg u
p lg lg
failure the bucket
n random words
lg n omega
most fi t
uniquely selected a
active buckets and
lg u random
active buckets at
by oblivious execution
fredman koml os
hashing by oblivious
matias and vishkin
t active buckets
key x is
auxiliary hash table
hashing algorithm is
is o lg
select a memory
iteration t is
1 level hashing
fail to uniquely
markov s inequality
of size at
this implementation is
of hash functions
of the hash
that fail to
fail to find
in the number
is with n
os and szemer
koml os and
m t m
dietzfelbinger and meyer
of active elements
by corollary 2
the same key
of the level
by fact 2
that with n
decreases at a
the total memory
selected at random
the first t
n processors on
buckets of size
the same bucket
written into a
at iteration t
fact 2 2
an implementation on
and szemer edi
with probability at
at most m
the problem size
size o n
in the allocation
the beginning of
a constant factor
an exponential rate
which the input
the load balancing
lemma 5 7
to processor j
hashing step of
lg n random
for the hashing
input set into
a lookup query
s inequality let
least t 4
lg n expected
m t active
hashing algorithm for
o m t
lg n 3
the robust model
memory blocks each
active buckets is
active key x
t memory blocks
u the hashing
on the robust
selected a block
