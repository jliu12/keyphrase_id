ys
dag
explicitation
grammar
xs
grammars
cons
nil
denition
ura
iscons
dags
driving
eh
generalisations
ow
inversion
supercompilation
gluck
inverting
rewrites
checker
speculative
refal
soundness
termination
nite
productions
isnil
redex
production
unfolding
dened
deforestation
false
t1
xs7
generalisation
specialised
metacomputation
abramov
roots
predecessors
append
tree
ar
srensen
successors
hinders
redexes
substitution
rewritten
inference
semantics
6if
arrowcheck
normalise
6k1
fsame
ysg
typechecker
maxmatch
romanenko
ys7
instantiation
unfolded
t2
exp
sound
label
decomposed
x1
siau
fan
extracted
leaves
xy
innite
cf
branch
accumulated
outermost
drive
normalised
lab
vs
dene
leaf
rst
imagine
disjoint
constructor
def
feg
khoo
transformers
resolving
xz
object
yz
syntactic
calculus
kun
synchronisation
gram
compromise
haskell
match
language
rewrite
akin
bookkeeping
york
discriminate
essence
strength
eectively
pairwise
instantiations
6xs
tthen
secher
amram
synchroni
explicitate
6same
6isnil
tomb
eralisations
consg
expchk
culprits
cripple
elimchk
6iscons
fhi
generalisa
fegd
xs7g
aloows
turchin
bauderon
contracta
incorporated
usability
xml
terminates
tuples
executions
propagate
hopefully
constructors
dening
ground
symbol
kn
uniquely
roundabout
synthesising
concretisation
heine
lamping
metacompuation
sacrices
cormac
explication
courcelle
denitions
116
springer
something
substitutions
specialization
verlag
shi
contexts
hyper
lambda
superscript
dle
klimov
sacrice
uninstantiated
spines
fs0
dissolve
fs
ect
universal
terminate
viously
exemplied
synchronising
glck
parameterise
106
equality
extract
jones
closure
same xs
xs ys
dag grammar
process tree
dag grammars
a dag
the explicitation
the grammar
ys x
cons x
program inversion
iscons ys
the dag
ys false
explicitation of
x xs
object program
term t
ys cons
explicitation process
nil cons
the ura
the program
negative information
a program
control ow
f same
a term
tree grammars
inverting a
a grammar
by driving
cons x1
cons cons
x cons
vs nil
cons iscons
uniquely decomposed
ar x
7 cons
the object
a production
type inference
type checker
a nite
driving the
grammars to
size change
for inverting
nil nil
input set
x y
object language
of terms
terms that
dags over
nil ys
function denition
dag language
accumulated grammar
in refal
x xs7
isnil ys
eh f
resolving algorithm
false same
ys isnil
comparison will
xy same
ys same
cons v
universal resolving
ys 7
y z
a redex
grammar the
grammar that
a process
be rewritten
seen before
and predecessors
cf def
xs 7
dags d
non termination
a type
program p
grammar and
functional programs
grammar from
the accumulated
of dag
given output
grammar by
grammars are
if xy
given a
z v
symbol r
a substitution
of dags
successors and
order functional
be uniquely
if false
is dened
rewritten into
and control
be driven
extracted from
the semantics
of successors
6 6
context and
the process
data ow
false we
the speculative
decomposed into
program that
z xz
line generalisation
true same
main denition
v vs
xs cons
explicitation eh
false g
2 explicitation
initial dag
bookkeeping symbol
x1 nil
xs g
answers true
grammar over
x1 cons
ura is
compiling with
specialised typechecker
graph grammar
nil xs
inverse computation
ys 6
xs ys7
ysg eh
normal order
and metacomputation
roots g
append cons
nil vs
equivalent dags
ys g
6 6if
let terms
partial inversion
of deforestation
use subscripts
by abramov
x2 nil
necessary generalisations
srensen gluck
gluck 1
6 6k1
dag rewrites
match z
incorporating negative
ys in
two dags
given dags
nil append
the generalisations
speculative with
xs7 7
while driving
of rewrites
we meet
will superscript
hinders unfolding
ura would
approximate termination
xs ysg
kun shi
change principle
main term
generalisation analysis
subscripts like
driven any
append vs
syntactic class
ys iscons
haskell like
constraint specialization
over fs
fsame xs
khoo kun
g eh
feg as
6k1 kn
change graphs
satisfying input
same xs ys
a dag grammar
a process tree
iscons ys x
the process tree
and control ow
xs ys false
the object program
f same xs
ys x xs
context and a
cons iscons ys
cons x cons
explicitation of the
ys cons iscons
7 cons x1
into a context
the explicitation process
in the grammar
be uniquely decomposed
data and control
a context and
the input set
x y z
given a program
xs ys isnil
the comparison will
nil ys 7
of dag grammars
false same xs
xs ys cons
process tree is
if xy same
universal resolving algorithm
xy same xs
eh f same
the universal resolving
and a redex
ys same xs
of the explicitation
ys isnil ys
the accumulated grammar
f if xy
the dag grammars
ys x xs7
t we denote
dags d and
successors and predecessors
z v w
given a dag
uniquely decomposed into
the data ow
y z v
as it were
of the input
a program p
can be uniquely
decomposed into a
can be rewritten
be rewritten into
of the program
the type checker
a program that
d and e
term t is
by means of
of terms that
extracted from a
the ura would
produce a grammar
order of successors
y z xz
x cons cons
tree grammars to
dag grammars which
the specialised typechecker
true same xs
imagine a program
xs g f
otherwise not obvious
not new for
given output the
cons x1 nil
ysg eh f
driven any further
drive the object
inversion and metacomputation
normal order semantics
grammars is not
cons x1 cons
functional programs by
6 6k1 kn
bookkeeping symbol r
nil nil cons
an s can
the bookkeeping symbol
for program termination
line generalisation analysis
x1 cons x2
dag grammar over
an initial dag
checker that is
dag grammar and
a generalisation is
xs ysg eh
append vs nil
inverting a program
we will superscript
to approximate termination
ar x y
replace the speculative
terminates on p
grammar such that
behaviour of deforestation
fsame xs ysg
the speculative with
production for t
size change graphs
process tree although
the satisfying input
if false same
constructs a process
cons cons x
xs ys 6
dag grammar can
o line generalisation
compiling with proofs
program that checks
the explicitation of
a nite dag
is otherwise not
by abramov gluck
abramov gluck 1
use subscripts like
successors of j
new for instance
a type scheme
t1 in t2
process tree a
into a description
vs nil append
ar ar x
idea of approximating
x xs7 7
isnil ys g
approximate termination behaviour
principle for program
size change principle
dag grammars to
grammars to approximate
be driven any
produces a nite
either the comparison
x xs cons
incorporating negative information
xs ys same
by grammars is
of let terms
ys 7 cons
cannot be driven
disjoint in the
the dag grammar
process tree from
change principle for
comparison will fail
hyper graph grammars
z xz yz
g f same
false g f
of program transformers
dag grammars we
cannot be decomposed
with to denote
cons x xs
of successors and
given dags d
the main denition
2 and t1
ys g eh
dag grammar that
will use subscripts
xs 7 cons
output constraint specialization
driving the program
ys false g
approximating functional programs
of dags over
the size change
technique using tree
of approximating functional
a function denition
nil xs 7
an o line
programs by grammars
cons x2 nil
termination behaviour of
extract a dag
ys iscons ys
x xs g
see srensen gluck
