schedule
profile
super
scheduling
precedence
retirement
exits
exit
heuristic
blocks
vertices
critical
falu
vertex
insensitive
scheduler
rank
benchmarks
sink
cccp
tbl
benchmark
branch
speculative
gains
subgraph
schedules
ratio
wc
lex
weighted
utilization
espresso
finish
functional
qsort
instruction
parallelism
probabilities
compiler
yacc
processor
units
block
weights
successive
completion
branches
eqn
chekuri
alvinn
ilp
path
sc
compress
oblivious
formation
sequential
superblock
shobaki
uler
cmp
heterogenous
motwani
weight
regions
wilken
ialus
ghassan
meleis
waleed
sequencing
improvement
region
sched
predicated
list
precedes
addendum
9357849
heuristics
intractable
microarchitecture
eichenberger
enjoy
compiling
unity
superblocks
ialu
schlumberger
numerator
box
makespan
converting
hyperblock
vliw
rooted
predominant
retire
cydra
duplication
saturate
alexandre
acyclic
kent
opcode
marked
funds
cycles
fork
cumulative
award
appending
283
li
priority
sensitive
earliest
pipelined
siam
segments
percentage
shell
characterizing
and28
qsort0
maher
mrank
exploitinginstruction
tuition
70critical
digesting
schichl
heffernan
subishi
stien
withtwo
computatational
applyingthe
followingterms
predom
functionalunits
nethercote
yoder
burrill
procesor
mckinle
parallism
schedulingchain
insensive
inant
annual
append
tail
yield
speculation
lemma
dag
falls
delete
rearranging
gain
against
light
graph
chain
quency
functinal
strung
0007
cavazos
anoma
vredeveld
uetz
u8
digested
tjark
megow
nears
compilers
preceding
np
mem
polynomially
enhancing
probability
bootstraps
underutilization
wenow
baev
compila
deitrich
ibm
scheduled
plots
driven
conditional
solvable
composing
plot
critical path
path ratio
super blocks
super block
precedence graph
profile information
successive retirement
path scheduling
profile insensitive
our heuristic
the schedule
s graph
modified rank
the profile
basic blocks
basic lemma
the critical
optimal sequential
the precedence
last exit
a super
insensitive scheduler
speculative yield
to profile
functional units
the super
list schedule
total schedule
profile list
exit probabilities
sequential schedule
code region
heuristic over
of vertices
finish time
retirement scheduling
under modified
schedule for
code regions
list scheduling
processor utilization
schedule length
unit machine
exits are
side exits
0 4
two functional
i k
is improvement
5 0
7 4
8 4
level parallelism
instruction level
the blocks
lex 1
profile sensitive
the insensitive
improvement espresso
insensitive list
path schedule
over critical
vertices preceding
completion cycles
expected finish
list scheduler
functional unit
scheduling heuristic
performance gains
scheduling algorithm
scheduling is
an s
the list
scheduling critical
finding g
heuristic against
1 5
1 1
regions such
our scheduling
the graph
a benchmark
3 0
g under
expected completion
benchmark improvement
of benchmarks
k i
oblivious to
utilization factor
with profile
a expected
as super
profile driven
the heuristic
the branch
little performance
4 0
length of
u 4
2 0
a sink
wc 2
exits at
uler shown
retirement schedule
insensitive sched
weighted precedence
falu and
precedence closed
against critical
2 8
0 3
0 9
3 8
schedule s
vertex i
the subgraph
4 9
by our
shown is
the weights
impact compiler
machine models
graph is
at vertex
a profile
branch vertices
u 8
sequential schedules
1 3
a vertex
of table
completion time
weights are
performance gain
weighted sum
of heuristic
the rank
1 7
improvements achieved
tail duplication
average completion
0 7
precedence constraints
ratio of
the weighted
8 3
the side
model h
for converting
0 5
improvement in
eqn 2
driven scheduling
blocks with
sum of
for g
vertex 3
the processor
for super
4 7
table 7
graph of
g 7
graph g
9 3
of basic
1 8
list for
1 0
sched uler
gains of
theoretical analysis
ratio and
u 2
scheduling with
for predicated
3 6
2 6
heuristic is
predicated execution
schedule using
3 7
scheduling as
non zero
schedule of
each vertex
1 6
microarchitecture p
and super
hard even
5 4
8 0
cccp 1
generic code
identical functional
preceding u
uniform processor
arbitrary precedence
critical path ratio
critical path scheduling
a super block
the precedence graph
the critical path
the super block
an s graph
the profile insensitive
the last exit
k i k
by our heuristic
precedence graph is
i k i
total schedule length
of a super
our heuristic over
optimal sequential schedule
path scheduling is
to profile information
the profile information
precedence graph of
is the profile
two functional unit
schedule length of
of the blocks
g under modified
path ratio of
successive retirement scheduling
under modified rank
functional unit machine
profile insensitive scheduler
shown is improvement
set of vertices
scheduling is the
is improvement in
the basic blocks
of the critical
regions such as
of the schedule
a expected completion
path ratio and
the s graph
in total schedule
a two functional
heuristic over critical
schedule of table
as super blocks
benchmark improvement espresso
with a expected
critical path schedule
improvement in total
expected completion cycles
scheduling critical path
path ratio is
such as super
exits are marked
over critical path
super block of
length of benchmarks
of heuristic against
expected finish time
finish time of
instruction level parallelism
2 8 3
schedule for the
1 2 0
the code region
the optimal sequential
profile information we
comparison of heuristic
little performance gain
block of figure
achieved by our
as the list
4 7 4
of the side
of basic blocks
the weighted sum
of a benchmark
0 4 4
for the super
3 8 4
for super blocks
optimal sequential schedules
our basic lemma
uler shown is
profile driven scheduling
profile insensitive sched
rooted at vertex
successive retirement schedule
4 and u
insensitive sched uler
the side exits
critical path from
code regions such
schedule we would
and u 8
list schedule for
path ratio the
against critical path
chain of basic
and super blocks
the successive retirement
the basic lemma
sched uler shown
insensitive list scheduler
oblivious to profile
the expected finish
our scheduling heuristic
the modified rank
1 1 1
the weights are
list scheduling algorithm
7 4 9
weighted sum of
1 1 8
the impact compiler
0 5 0
where the weights
1 1 5
1 7 1
u 4 and
with profile information
profile information as
sequential schedule as
list for g
improvements achieved by
for performance gains
would obtain in
weights are the
are the execution
of the exit
shows the improvements
from the last
of figure 1
3 6 3
1 3 0
5 4 3
length of the
graph of a
average completion time
the improvements achieved
shows the schedule
the schedule s
the total schedule
performance gains of
1 3 1
graph is a
marked with a
for a two
1 5 1
the processor utilization
8 4 0
the schedule we
are marked with
sum of the
of table 7
np hard even
9 3 7
2 6 5
2 5 1
obtain in this
optimal schedule for
5 0 4
1 5 0
the general problem
for predicated execution
the list for
support for predicated
3 7 4
1 3 6
in light of
weight w i
0 3 0
we would obtain
a critical path
0 1 3
basic blocks and
on microarchitecture p
the length of
figure 1 for
using the optimal
1 0 9
good measure of
symposium on microarchitecture
the rank of
1 1 2
is the weighted
2 1 0
3 0 3
a good measure
2 1 1
vertices preceding u
modified rank using
scheduler as the
saturate the processor
as cumulative percentage
enjoy very little
will exit via
the insensitive list
