lp
lsl
trait
lslc
traits
larch
linearcontainer
dd
totalorder
priorityqueue
obligations
deduction
cd
specifications
axioms
addw
converts
qed
claims
naturalnumber
specifiers
discharge
assertions
clause
rewrite
specification
declare
isgenerated
conjecture
theories
isempty
asserts
subgoal
equational
insert
commands
implication
coord
rules
guidance
operators
emptyv
inw
discharged
forall
assert
interpretations
command
obligation
induction
window
rewriting
containment
assistance
fg
checking
resume
inconsistencies
displayable
debugging
clauses
consistency
hypotheses
proving
partitioned
alse
consequences
specifier
checkable
formulates
commutative
clu
exempting
natpriorityqueue
otalorder
subgoals
coordinate
directs
proofs
axiom
interface
nat
propositions
diagnostics
hypothesis
implications
completion
prover
damon
checks
ada
inconsistency
debug
jackson
certifying
lcf
semantic
mechanisms
extracts
facilities
sorts
checker
equations
feg
inference
completeness
setinduction2
modet
nonconsequence
orall
andres
multisorted
language
automatically
assumes
check
logical
flaws
rule
logic
wid
normalizes
declarations
attempted
users
identities
introduces
ontic
operator
conjectures
syntax
sort
discover
formulate
inferences
terminating
languages
empty
semantics
hierarchy
shared
craig
counterexample
certify
normalization
appearance
inconsistent
textually
nonterminating
axiomatized
uncovers
liskov
erroneous
plan
detector
id
axiomatizations
lemmas
6d
syntactically
associative
unintended
sample
incompleteness
transitively
execute
handbook
daniel
inductive
tri
imply
initiate
identity
detecting
vacuously
incomplete
programmers
logically
observational
consist
reasoning
critical
backward
circuits
revised
encourages
informal
attempting
origin
1996
subtle
enhance
categories
overloaded
mistakes
contradict
easier
windows
bool
cartesianview
the trait
proof obligations
the larch
rewrite rules
deduction rules
in lp
lp to
deduction rule
a trait
larch shared
shared language
partitioned by
cd 0
in lsl
lsl specifications
converts clause
dd y
theory containment
the conjecture
completion procedure
x dd
qed prove
lp commands
claims about
the axioms
a specification
lp the
e dd
critical pairs
assertions of
of linearcontainer
lsl traits
all traits
the converts
y dd
resume by
the assertions
is empty
of lsl
empty q
lp is
prove x
use lp
implies clause
dd e
addw v
next rest
proof obligation
of lp
for lp
handle case
declare variables
the lsl
lp s
induction rules
by cases
the proof
0 dd
next new
lslc formulates
of totalorder
operator theories
obligations associated
empty 0
s partitioned
larch interface
trait view
z proofs
rest new
directs lp
axioms of
traits that
v 0
interface specifications
by fg
logical system
interpretations for
lp provides
explicit theory
the traits
lp uses
s generated
to discharge
user assistance
e 2
to lp
q e
a window
traits s
dd x
next q
lslc and
z dd
of priorityqueue
trait hierarchy
emptyv cd
proof mechanisms
t consist
dd true
declare operators
lsl specification
interface languages
trait the
x qed
v cd
isempty and
if cd
lsl checker
assumes coordinate
guidance is
lslc extracts
trait t
by induction
to check
and deduction
e 0
the lp
to prove
the implication
insert s
an identity
0 handle
an lsl
a deduction
lp as
of traits
specifiers to
the command
the deduction
proofs by
generated by
the propositions
conjecture to
empty c
user guidance
for inconsistencies
obligation for
the implies
a proof
first order
and lp
lp and
the partitioned
ordering methods
which lp
an inconsistency
claims that
set name
and rest
daniel jackson
order logic
of operators
proof by
the view
of specification
when checking
the completion
z the
specifications to
the subgoal
proving a
each trait
how lp
rewriting theory
lslc checks
declare sorts
fg insert
lslc can
lsl and
then lslc
lp command
linearcontainer is
0 resume
c dd
the asserts
yield x
containment that
assumes t
file totalorder
cd coord
checkable claims
t otalorder
into terminating
attempted proof
asserts forall
totalorder assertions
0 cd
how lslc
introduces asserts
lsl trait
lsl s
q qed
semantic claims
categories consistency
cd cd
isgenerated x
larch prover
cases t
check traits
check implications
larch shared language
the assertions of
the larch shared
the completion procedure
the converts clause
of all traits
is empty q
the proof obligations
generated by fg
in the trait
the axioms of
that a specification
lp the larch
s partitioned by
and deduction rules
the partitioned by
resume by case
use lp to
obligations associated with
to an identity
of the trait
proof obligations associated
directs lp to
is empty 0
s generated by
the deduction rule
the implies clause
isempty and 2
y dd y
x 0 dd
insert s e
of t consist
the lp commands
cd 0 then
0 handle case
case is empty
theory of linearcontainer
t consist of
completion procedure to
is empty c
prove x y
dd e 2
the lsl checker
empty q 0
the conjecture to
if cd 0
x y dd
converts clause in
proof obligation for
in a proof
first order logic
proof by cases
case e 0
rules and deduction
a deduction rule
equations and rewrite
of the implication
is to say
e 2 x
a logical system
that is to
the conjecture is
the proof obligation
of the conjecture
s c t
and rewrite rules
implies clause of
cd 0 cd
then if cd
the trait linearcontainer
addw v cd
in lp as
syntax and static
case v 0
theory containment that
z proofs by
the larch prover
declare sorts e
to check lsl
dd y 0
how lp is
q qed prove
lp is used
of lsl specifications
lp commands that
and static semantics
performance of lp
assumes coordinate includes
true dd f
an lsl trait
0 resume by
x qed prove
0 c dd
v 0 next
as in lsl
lslc the lsl
of a trait
shared language a
declare variables x
the trait hierarchy
normalizes to an
by fg f
an identity the
by fg insert
craig a damon
next c 0
the command prove
equations rewrite rules
dd y x
dd f alse
guidance is required
dd is empty
lp to discharge
work on lsl
deduction rules to
the file totalorder
these proof obligations
next new and
lslc and lp
and relative completeness
and rest new
lp to prove
three categories consistency
in the implies
new and rest
to check traits
prove the subgoal
lslc checks the
qed prove x
semantics of lsl
a partitioned by
must follow from
check traits that
0 q dd
to use lp
search for inconsistencies
y x qed
the explicit theory
consist of the
of rewrite rules
the generated by
of deduction rules
explicit theory of
theory of t
attempting to prove
0 then else
0 next c
partitioned by 2
hypothesis t 0
static semantics of
proof obligations from
on the larch
to be proved
complete sets of
larch family of
family of specification
the larch family
hypothesis of the
the proof by
that the axioms
the rewrite rules
the propositions in
of specification languages
fall into three
rewrite rules and
by induction on
we plan to
the hypothesis of
attempt to prove
attempts to prove
equations such as
a specification is
it easier to
a front end
set of operators
b c c
specification does not
is a theorem
the assumptions of
the theory of
into two cases
of formal specifications
in the view
to say the
condition 2 is
relative completeness that
development have been
within a newly
the conjecture reduces
extended example illustrating
if next q
with this trait
else if next
traits that imply
rule normalizes to
deduction rule when
view could be
lp and to
execute set assertions
in trait view
