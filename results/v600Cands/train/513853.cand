banks
register
dsp56000
bank
srg
asips
r5
registers
y0
mst
r0
r2
spam
vsr
instruction
x0
uncompacted
r4
move
live
mac
assignment
coloring
r3
alu
y1
memory
r1
allocation
compiler
compacted
color
gpps
spanning
optimized
compilation
x1
dual
decoupled
asip
r6
mov
agu
gsr
reg
code
colored
splitting
temporaries
mpy
instructions
compaction
operand
heterogeneous
dsp
merging
r10
word
motorola
processors
ranges
least_mean_square
adapt_predict_1
regk
tone_detector_1
msts
mpya
scale_factor_1
adapt_quant
iadpt_quant
complex_multiply
iir_biquad_n_sections
speed_control_2
l10
matrix_multiply_1
coupled
benchmarks
r7
embedded
d2
phases
operands
compilers
targeting
referenced
retargetable
allocated
name
uncolored
temporary
speedup
r8
visitors
theirs
jl
unmarked
assigned
subgraph
memories
nonconflicting
guthaus
mpyr
y1g
jlgjv
orthogonal
architecture
marsman
dasika
convolution
xiaobo
homogeneous
assembly
generation
simultaneous
r9
senger
sharon
signal
od
op
ravindran
buses
files
multiplies
physical
phase
hsuan
names
shifter
partition
modes
dsps
mahlke
homogenous
subgraphs
digital
addressing
compacting
meet
a2
tree
g2
architectures
ratios
jv
conventional
spilling
eu
ganesh
automation
reference
heuristic
mainly
nodes
merge
spill
compiled
sparc
inevitably
rajiv
classes
611
sr
g1
binding
suites
weight
jej
moves
priority
zhong
microsystems
opposed
comparative
twelve
todaes
cycle
marked
exploiting
adsp2100
incresing
xdb
coros
banerji
incapability
crunching
bank11
mwp
4fir2dim
upd77016
ydb
101000100000
execution0
grwal
multibank
studie
xyn
architectre
10312
pinedspcore
memory banks
memory bank
bank assignment
register class
parallel move
name splitting
register classes
dual memory
code generation
move x
graph coloring
data memory
live ranges
the srg
register assignment
y memory
the dsp56000
multi memory
hand optimized
in vsr
the code
optimized code
a mst
x0 y
uncompacted code
r2 x
the register
register allocation
code size
class allocation
heterogeneous registers
simultaneous reference
spanning tree
mac r3
move high
mac r0
e r4
y0 a
the uncompacted
f r5
maximum spanning
non orthogonal
physical registers
our compiler
live range
coupled approach
banks as
r0 r1
banks in
dual data
and merging
instruction selection
c r2
data alu
banks x
address alu
spam code
compacted code
splitting and
signal processors
x0 y0
r4 r5
code compaction
registers are
r3 r4
to memory
register architecture
x r1
generation phases
color v
d r3
generation for
for embedded
compilation times
digital signal
coloring algorithm
y b
assigned to
of compilation
for register
y colored
each temporary
our decoupled
reference graph
r5 mac
r5 low
vsr of
motorola dsp56000
r5 y
of gsr
a x0
r1 move
v move
of dsp56000
r1 r2
compiler optimized
our memory
a x
a register
can see
b y0
x color
reference allocation
x1 y
y color
a r0
decoupled approach
b r1
registers and
heterogeneous register
after register
alu operations
code in
assignment for
compilation time
in code
each live
op code
allocation and
are assigned
and memory
mst algorithm
for dual
processors code
embedded processors
two data
for asips
different memory
resulting code
output code
low w
complex_multiply iir_biquad_n_sections
high v
w move
scale_factor_1 speed_control_2
speed_control_2 tone_detector_1
high w
reg i
y r5
least_mean_square matrix_multiply_1
r2 r6
adapt_predict_1 iadpt_quant
r5 r2
low r2
high r5
their literature
r6 add
r0 x0
high r2
mst t
x r0
partitioned memory
next visitors
r3 mac
convolution complex_multiply
adapt_quant adapt_predict_1
move conditions
reg j
r0 y
dsp56000 assembly
banks which
the agu
conventional graph
x memory
visitors q
exploiting dual
entire variables
srg and
mov a
tone_detector_1 benchmarks
c r6
y1 a
add r2
r8 move
add x1
r7 r5
mov x
matrix_multiply_1 adapt_quant
their coupled
mpy x0
y1 add
vsr do
iir_biquad_n_sections least_mean_square
iadpt_quant scale_factor_1
e r8
low r5
r4 y0
x1 y0
y r4
the instruction
a spanning
coloring approach
in figure
instruction word
assignment algorithm
data path
the memory
and y
be assigned
machine instructions
memory bank assignment
data memory banks
name splitting and
to memory banks
memory banks in
a parallel move
register class allocation
splitting and merging
the register class
r0 r1 r2
maximum spanning tree
x0 y0 a
the uncompacted code
dual memory banks
mac r0 r1
mac r3 r4
memory banks as
code generation for
dual data memory
hand optimized code
r3 r4 r5
graph coloring algorithm
of the dsp56000
and memory bank
our memory bank
y0 a x
digital signal processors
heterogeneous registers and
code generation phases
bank assignment for
different memory banks
in the code
code in figure
we can see
multi memory bank
x a x0
nodes in vsr
banks x and
the memory bank
in vsr of
b r1 move
y b y0
color v with
a x0 y
f r5 mac
memory banks x
simultaneous reference graph
the parallel move
x0 y b
multi memory banks
bank assignment algorithm
r5 mac r3
two data memory
each live range
the register classes
register classes for
is mainly because
variables to memory
register allocation and
x and y
in the register
physical registers are
graph coloring approach
live ranges of
a spanning tree
in code generation
the code in
x1 y d
after register assignment
v move high
x1 y1 a
d r3 mac
compiler optimized code
parallel move conditions
d y1 add
uncolored node v
add r2 r6
over the uncompacted
y r4 y0
registers and multi
banks in this
adapt_predict_1 iadpt_quant scale_factor_1
c r6 add
least_mean_square matrix_multiply_1 adapt_quant
y d y1
a x r1
memory banks which
iadpt_quant scale_factor_1 speed_control_2
e r8 move
adapt_quant adapt_predict_1 iadpt_quant
a memory bank
our output code
and y memory
y b r1
the dual memory
memory banks are
conventional graph coloring
speed_control_2 tone_detector_1 benchmarks
c x1 y
a register class
convolution complex_multiply iir_biquad_n_sections
v in vsr
r6 r7 r5
y1 add x1
mov x a
move high r5
r2 r6 r7
r3 mac r0
x r0 x0
r4 r5 r2
low v move
dsp56000 assembly code
low w move
a maximum spanning
x c x1
their coupled approach
r1 r2 x
our decoupled approach
variables referenced in
matrix_multiply_1 adapt_quant adapt_predict_1
in vsr do
scale_factor_1 speed_control_2 tone_detector_1
r0 y b
move high r2
uncompacted code is
r1 move x
next visitors q
r6 add r2
of compilation times
mpy x0 y0
alu operations are
w move high
complex_multiply iir_biquad_n_sections least_mean_square
add x1 y1
mov a x
iir_biquad_n_sections least_mean_square matrix_multiply_1
be assigned to
the code generation
can see that
assigned to different
resulting code after
for register assignment
non orthogonal architectures
a partition from
simultaneous reference allocation
instruction selection phase
register class for
heterogeneous register architecture
of register classes
memory bank asips
multiple memory banks
to different memory
this is mainly
code over the
the instruction selection
optimized code over
for non orthogonal
the hand optimized
of our compiler
the spam compiler
registers are assigned
live range of
can see in
the resulting code
processors code generation
a x e
a x c
for fixed point
assigned to the
register and memory
assignment of variables
spanning tree mst
and instruction scheduling
instruction scheduling for
variables a and
generation for embedded
for digital signal
nodes have been
via graph coloring
a graph coloring
for embedded processors
referenced in the
the data path
for the code
a single instruction
centralized general purpose
y e r8
colored ones if
vsr of x
portable optimizer for
nodes than y
a mov a
r5 y e
partitioned memory move
dual memory architecture
move r10 x
r5 low w
r5 low r2
disjoint live ranges
optimized the uncompacted
