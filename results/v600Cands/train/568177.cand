matcher
rematch
pat
txt
kmp
imperative
string
jp
ltxt
lpat
staged
match
kp
matchers
abstract
functional
text
abac
abscomp
sync
characters
residual
trace
specialization
pratt
invariants
morris
character
similix
grobauer
lambda
pattern
ref
comparisons
specializing
lawall
derivation
knuth
r5
identifiers
danvy
memoization
eq
specialized
opr
bac
r3
premises
evaluator
matching
od
traces
shift
naive
r4
binding
faithfully
aba
preservation
strings
semantics
invariant
indices
synchronized
korsholm
rohde
r1
r2
preserved
futamura
mutable
article
fin
quadratic
expressions
letrec
int
singleton
mismatch
faithful
tabulating
henning
rise
scope
backtracking
consel
correspondence
premise
vid
jpth
charras
recompare
lecroq
appsem
configuration
var
tail
m2
cient
m1
static
boyer
uck
su
initialization
terminates
obtaining
recursive
optimiser
mads
stm
indexing
c2
compare
computations
keeps
traverses
specializer
ager
autoprojection
c1
evaluating
successive
partial
subsequences
arrays
expressible
olivier
ab
programs
razor
track
displays
moore
synchronization
occam
immutable
numerals
num
piece
language
erent
corollary
calling
serious
negative
concrete
gl
yields
body
haskell
reads
lifting
successively
exp
remark
formalize
big
alphabet
330
ac
calls
informal
essence
pseudocode
transforming
conditional
statically
sig
return
page
indexf
percompiler
memoizes
chiroko
nygaard
malmkj
revisitation
yoshihiko
initalization
germn
rensen
zenjiro
midtgaard
filinski
imperatively
empty
injection
corollaries
res
dictated
index
conjecture
prefix
linearisation
triv
amtoft
isons
supercompiler
metacomputation
string matcher
functional matcher
the kmp
compare j
next table
kmp algorithm
abstract functional
imperative matcher
the imperative
the pattern
partial evaluation
the text
abstract imperative
staged string
pattern and
pat j
string matchers
pat txt
the functional
program points
matcher and
rematch j
match j
next j
sync i
abstract state
the abstract
jp kp
lpat and
pat jp
string ref
functional computation
and ltxt
a staged
k jp
next abstract
morris and
j k
matcher is
if eq
matcher that
and pratt
abstract computations
let pat
txt k
i states
residual program
data specialization
match 0
negative information
quadratic string
imperative computation
pat and
residual programs
abstract states
knuth morris
last i
lambda j
shift j
states int
evaluating match
match compare
j pat
eq string
matcher section
ref pat
compare jp
rematch function
pratt s
of abstract
characters in
program point
evaluation relation
by definition
matcher of
kp f
j lpat
imperative trace
successive comparisons
definition compare
and txt
linear string
step evaluation
j compare
of negative
generalized partial
an imperative
trace semantics
last f
partial computation
character in
in strings
between characters
the rematch
f states
abscomp f
kp jp
k ltxt
r5 holds
txt and
0 pat
pat 0
k pat
complete abstract
grobauer and
abstract trace
specializing the
text and
case assumption
comparisons between
the invariants
and pat
binding time
staged matcher
i match
functional trace
match 1
matcher we
jp k
and lawall
matching in
string matching
linear in
i compare
final configuration
of pattern
states i
rematch rematch
f rematch
match rematch
definition rematch
match abac
of txt
kp if
a bac
assumption sync
invariant r5
compare function
txt be
f match
abstract matcher
jp rematch
functional string
i last
pattern matching
partial evaluator
while j
source program
compare and
of indices
the premises
the string
relation for
functional state
as evaluating
match pat
text in
specialized programs
string length
the staged
jp 1
functional program
recursive equations
a residual
imperative computations
j match
aba c
functional computations
0 match
matcher the
dynamic tests
trivial expressions
memoization points
function environment
r4 holds
is match
definition match
matcher with
define compare
k match
naive quadratic
complete functional
abac k
of ltxt
6 concrete
each premise
ref txt
synchronized i
states fin
matcher using
ltxt yields
serious expressions
invariants r1
abscomp i
imperative string
define match
are faithful
of lpat
ltxt do
and lpat
the functional matcher
the pattern and
the kmp algorithm
the next table
staged string matcher
rematch j k
the imperative matcher
j k jp
morris and pratt
in the pattern
next abstract state
the next abstract
of negative information
k jp kp
partial evaluation of
let pat txt
the string matcher
knuth morris and
pattern and in
quadratic string matcher
string matcher that
of the pattern
and pratt s
evaluation of pattern
evaluation relation for
if eq string
compare j k
eq string ref
sync i i
step evaluation relation
lpat and ltxt
a staged string
abstract state is
string ref pat
the case assumption
the text and
in the text
generalized partial computation
pattern matching in
characters in the
of the text
jp kp f
the successive comparisons
comparisons between characters
between characters in
abstract imperative matcher
string matcher and
by definition compare
string matcher is
definition compare j
of pattern matching
set of abstract
in the scope
matching in strings
the abstract functional
of the imperative
to the successive
i i holds
of the kmp
j compare j
ref pat jp
pat 0 pat
the rematch function
of abstract states
matcher that keeps
grobauer and lawall
abstract functional matcher
compare jp k
in the length
linear in the
of the functional
sequence of abstract
of partial evaluation
character in the
the text in
0 by definition
a residual program
program points and
functional string matcher
successive comparisons between
state is therefore
a trace semantics
definition rematch j
the functional trace
pat txt be
an imperative computation
while j lpat
by definition rematch
matcher of figure
pat txt and
the abstract imperative
k pat j
by assumption sync
assumption sync i
the imperative trace
txt be given
imperative matcher and
string matcher of
abstract functional computation
of abstract functional
the compare function
result as evaluating
abstract functional state
similarly by definition
functional computation is
pat and txt
specializing the functional
pattern and the
is linear in
1 the next
k in the
is a derivation
holds by assumption
a character in
the length of
of indices corresponding
sequence of comparisons
i of s
to a pattern
the corresponding residual
length of the
and the text
su x of
sequence of indices
the invariants are
states i states
e do s
contain any program
by definition match
one character of
match compare and
imperative string matcher
any program points
k evaluating match
match or compare
definition match j
i last f
of lpat and
imperative matcher section
scope of lpat
an abstract functional
scope of ltxt
the imperative language
and k ltxt
i e sync
character of negative
do s od
are synchronized i
in the kmp
sequence of singleton
k ltxt do
staged string matchers
ltxt yields the
all k evaluating
i states int
f states int
ref txt k
lambda j if
traverses the text
while e do
of singleton sets
of abstract imperative
small step evaluation
txt k pat
abstract computations are
i states i
of ltxt yields
the abstract trace
functional matcher and
0 pat j
string ref txt
match 0 0
the abstract computations
of staged string
j lpat and
functional matcher section
characters of negative
0 and pat
as evaluating match
synchronized i e
and pat j
matcher section 2
matcher with respect
match j compare
a functional computation
invariant r5 holds
lpat and k
matcher section 3
string matcher the
section 3 6
text in the
indices corresponding to
the final configuration
same result as
the scope of
pattern and text
of residual programs
of comparisons between
subset of scheme
the derivation contains
