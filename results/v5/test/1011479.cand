loc
predomain
leino
st
abadi
denotational
specifications
calculus
thetast
m2m
val
imperative
fixpoint
object
logic
oe
phi
specification
bm
rec
flat
predomains
calculi
scott
hoare
predicate
functional
recursive
id
monotonic
denotationally
recl
tm
admissible
semantics
store
cit
mild
cardelli
existence
untyped
ob
pitts
predicates
induction
soundness
logics
recursion
counterexamples
thetarec
8o
bval
ocl
predom
closures
fields
theta
inv
formation
reasoning
oriented
resp
languages
transition
algol
predi
modelling
uniqueness
spec
record
interpretation
families
objects
garbage
cates
diverges
field
creation
java
ject
update
invariants
realizations
countable
2s
closed
typed
ambient
employing
invariant
ae
machinery
finds
precondition
op
fresh
indisputable
r65190
o2o
recm
schwinghammer
thetao
2st
dubious
endo
bifree
coalgebraic
gested
nuffield
evid
o2s
stval
reus
sug
00244
v2val
hv
8evid
freyd
definedness
knaster
o2i
thetaa
endomap
a2o
tarski
letx
variant
recursively
verifying
alter
assertions
grams
inheritance
accordance
domains
iii
coinduction
cristiano
exemplify
gously
mysterious
hearn
notationally
calcagno
lcf
oei
prospective
handy
bifunctor
parison
records
operational
sake
continuous
relational
var
awkward
embarking
uncountable
viously
derivability
inclined
nineties
presupposes
characterising
2a
nonempty
obvi
aliases
employ
lattice
labels
semantic
syntax
simplifies
distinguish
fixpoints
conceive
clone
reminds
smalltalk
wp
locations
extensions
validity
greatest
implication
programs
adaption
pcf
fication
fulfilling
specifica
clarified
overriding
ful
313
bernhard
plementation
object calculus
object specifications
abadi leino
imperative object
logic of
f st
e o
e oe
the store
scott closed
object calculi
the abadi
leino logic
the imperative
of object
a denotational
rec loc
st e
loc thetast
fixpoint induction
o m
e e
functional object
theta st
denotational semantics
of specification
is scott
transition specifications
unique s
st with
method update
flat predomain
p o
the object
oe 0
a logic
f e
flat part
m o
the functional
object oriented
o 0
2 l
specification s
i a
p e
a predomain
admissible predicate
recursive object
condition iii
theorem 4
it follows
partial continuous
functional case
of predomains
phi y
recursive type
oriented programs
l i
object logic
condition y
only refer
p id
existence theorem
finds its
the flat
o o
basic values
st for
oe 00
val theta
st val
object formation
phi satisfies
store i
domain equations
loc theta
unique with
object expression
non flat
op theta
order store
relational properties
val thetast
method closures
loc cit
a op
st m2m
any predicates
object specification
hoare calculus
s loc
interpretation within
recursive objects
specifications under
phi a
of objects
oe m
the specification
reasoning about
oriented languages
the predicate
of recursive
predicate s
inv a
provided s
environment ae
program logic
introduction rule
presented approach
with provided
mild assumptions
and imperative
induction principle
that f
a m
n w
an object
calculus for
of phi
existence of
v id
by fixpoint
o thus
2 phi
iii of
oe n
thus by
object creation
specifications is
abadi and
the admissible
the recursively
logic 2
its interpretation
calculus of
follows that
store and
recursive types
class based
w r
of specifications
logic but
fixpoint of
method m
the existence
by y
semantics for
a t
that phi
a monotonic
definition 3
a specification
m e
recursively defined
fields and
thetast and
2s o
verifying java
that bm
constrained design
store oe
natural counterexamples
recursively specified
alter data
domain equation
o 2a
field update
defined predomain
f val
needs recursion
8o 0
p ffi
calculus without
programs recursive
greatest fixpoint
loc ob
java realizations
quite in
theta val
algol like
imperative untyped
loc rec
l loc
a hoare
loc n
and families
ocl constrained
guarantee existence
3 imperative
abadi cardelli
bm x
loc val
result specifications
untyped object
programming logics
and leino
garbage and
thetast val
cates resp
l i a
f e e
e e o
abadi leino logic
the object calculus
the abadi leino
imperative object calculus
f st e
logic of object
of the store
a logic of
o m o
notion of specification
unique s 2
the imperative object
a unique s
s 2 l
flat part of
of object oriented
e o m
the flat part
functional object calculus
to the flat
for the imperative
object calculus of
of phi a
of the abadi
st e e
object oriented programs
e oe 0
denotational semantics for
only refer to
theorem 4 4
show that f
of theorem 4
a denotational semantics
oe 0 n
provided s is
and logic of
object expression a
is scott closed
that f st
of recursive objects
calculus of 1
store i e
with provided s
by fixpoint induction
inv a t
loc theta st
val theta st
is unique with
a op theta
relational properties of
the functional object
interpretation within the
o m e
logic of recursive
theta st m2m
functional and imperative
the store i
e v id
the predicate s
higher order store
of object calculi
2 phi y
the admissible predicate
by y that
oe n w
logic of predomains
within the recursively
phi a t
i a op
environment ae 2
that e oe
s is unique
m o 0
a flat predomain
i a l
m e o
condition iii of
that i e
theorem 4 2
object oriented languages
exists a unique
it follows that
e e oe
properties of domains
o p o
p o p
the condition y
the functional case
the presented approach
e f e
w r t
properties of objects
a l i
y 2 l
lemma 7 1
the store and
that a m
be the predicate
of the functional
of the object
definition 3 3
in the object
refer to the
part of the
not distinguish between
semantics for the
garbage and program
st theta val
quite in accordance
f st for
e oe n
for any predicates
loc n is
its introduction rule
3 as e
untyped object calculus
call method update
on o o
fixpoint induction principle
phi y x
0 2s o
l loc st
rec loc rec
also suggests extensions
specifications and their
a fresh location
partial continuous functions
4 definition 3
3 imperative object
and program logic
is scott open
of specifications under
its interpretation within
induction hypothesis p
object calculus without
e o 2a
fixpoint of phi
object based a
classes in algol
the existence theorem
y of theorem
recursively defined predomain
st loc thetast
2s o m
method call method
through the store
the underlying store
theta i a
phi satisfies the
to guarantee existence
of ocl constrained
interpretation of object
transition specifications that
the object formation
loc rec f
of loc cit
and families of
p ffi e
that phi satisfies
w oe 0
recursive object types
that alter data
2 functional object
simple imperative languages
predicates and families
thetast val thetast
for verifying java
oriented programs recursive
a locally continuous
logics for object
for object calculi
in the store
functional object specifications
o thus it
theta val theta
specification as the
needs recursion in
recursion through the
f by y
st with provided
the complete lattice
alter data structures
imperative object specifications
n w e
object calculus which
2 p o
finds its interpretation
existence of specifications
a a predomain
one needs recursion
fresh location not
any predicates and
constrained design models
hoare calculus for
condition y of
verifying java realizations
n w oe
