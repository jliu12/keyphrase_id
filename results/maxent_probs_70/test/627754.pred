join sequence
processor allocation
bushy tree
join sequences
operator parallelism
execution time
general join
execution dependency
sequential join
synchronous execution
operational point
system fragmentation
sequence scheduling
join query
sequence efficiency
r 5
query graph
execution costs
r 4
sequence heuristics
resulting relation
query execution
multiprocessor system
processors allocated
join queries
point selection
bushy trees
next join
join operation
internal node
r r
merge join
child nodes
optimal sequential
r j
different join
sequence heuristic
heuristics proposed
execution cost
parallel execution
r 2
data skew
sequences obtained
simulation results
allocation heuristics
exploiting inter
schemes evaluated
built bottom
resulting r
h p
processor system
allocation efficiency
hash joins
execution tree
single processor
scheduling schemes
execution sequence
query complexity
join operations
several heuristics
number of processors
synchronous execution time
concept of synchronous
join sequence scheduling
general join sequences
join sequence efficiency
query execution time
execution dependency and
number of relations
sequential join sequence
general join sequence
operational point selection
sequence scheduling and
dependency and system
join sequence heuristics
scheduling and processor
sequential join sequences
bushy tree in
processors allocated to
execution time of
bushy tree is
optimal sequential join
tree in figure
single processor system
join sequences obtained
join sequence heuristic
minimize the query
execution of multi
processor allocation for
time of a
despite their simplicity
processor allocation efficiency
built bottom up
sequences obtained by
resulting relation of
several heuristics to
database operations in
processors to execute
cardinalities of attributes
propose and evaluate
light of the
bottom up approach
evaluated by simulation
join in the
execution of each
determine the number
execution time is
top down approach
processor allocation heuristic
execute each join
